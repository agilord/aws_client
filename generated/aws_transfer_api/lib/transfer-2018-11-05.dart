// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import 'package:shared_aws_api/shared.dart' as _s;
import 'package:shared_aws_api/shared.dart'
    show
        Uint8ListConverter,
        Uint8ListListConverter,
        rfc822fromJson,
        rfc822toJson,
        iso8601fromJson,
        iso8601toJson,
        unixFromJson,
        unixToJson;

export 'package:shared_aws_api/shared.dart' show AwsClientCredentials;

part 'transfer-2018-11-05.g.dart';

/// AWS Transfer for SFTP is a fully managed service that enables the transfer
/// of files directly into and out of Amazon S3 using the Secure File Transfer
/// Protocol (SFTP)—also known as Secure Shell (SSH) File Transfer Protocol. AWS
/// helps you seamlessly migrate your file transfer workflows to AWS Transfer
/// for SFTP—by integrating with existing authentication systems, and providing
/// DNS routing with Amazon Route 53—so nothing changes for your customers and
/// partners, or their applications. With your data in S3, you can use it with
/// AWS services for processing, analytics, machine learning, and archiving.
/// Getting started with AWS Transfer for SFTP (AWS SFTP) is easy; there is no
/// infrastructure to buy and set up.
class Transfer {
  final _s.JsonProtocol _protocol;
  Transfer({
    @_s.required String region,
    @_s.required _s.AwsClientCredentials credentials,
    _s.Client client,
    String endpointUrl,
  }) : _protocol = _s.JsonProtocol(
          client: client,
          service: 'transfer',
          region: region,
          credentials: credentials,
          endpointUrl: endpointUrl,
        );

  /// Instantiates an autoscaling virtual server based on Secure File Transfer
  /// Protocol (SFTP) in AWS. When you make updates to your server or when you
  /// work with users, use the service-generated <code>ServerId</code> property
  /// that is assigned to the newly created server.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceExistsException].
  ///
  /// Parameter [endpointDetails] :
  /// The virtual private cloud (VPC) endpoint settings that are configured for
  /// your SFTP server. With a VPC endpoint, you can restrict access to your
  /// SFTP server to resources only within your VPC. To control incoming
  /// internet traffic, you will need to invoke the <code>UpdateServer</code>
  /// API and attach an Elastic IP to your server's endpoint.
  ///
  /// Parameter [endpointType] :
  /// The type of VPC endpoint that you want your SFTP server to connect to. You
  /// can choose to connect to the public internet or a virtual private cloud
  /// (VPC) endpoint. With a VPC endpoint, you can restrict access to your SFTP
  /// server and resources only within your VPC.
  ///
  /// Parameter [hostKey] :
  /// The RSA private key as generated by the <code>ssh-keygen -N "" -f
  /// my-new-server-key</code> command.
  /// <important>
  /// If you aren't planning to migrate existing users from an existing SFTP
  /// server to a new AWS SFTP server, don't update the host key. Accidentally
  /// changing a server's host key can be disruptive.
  /// </important>
  /// For more information, see
  /// "https://alpha-docs-aws.amazon.com/transfer/latest/userguide/configuring-servers.html#change-host-key"
  /// in the <i>AWS SFTP User Guide.</i>
  ///
  /// Parameter [identityProviderDetails] :
  /// This parameter is required when the <code>IdentityProviderType</code> is
  /// set to <code>API_GATEWAY</code>. Accepts an array containing all of the
  /// information required to call a customer-supplied authentication API,
  /// including the API Gateway URL. This property is not required when the
  /// <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.
  ///
  /// Parameter [identityProviderType] :
  /// Specifies the mode of authentication for the SFTP server. The default
  /// value is <code>SERVICE_MANAGED</code>, which allows you to store and
  /// access SFTP user credentials within the AWS Transfer for SFTP service. Use
  /// the <code>API_GATEWAY</code> value to integrate with an identity provider
  /// of your choosing. The <code>API_GATEWAY</code> setting requires you to
  /// provide an API Gateway endpoint URL to call for authentication using the
  /// <code>IdentityProviderDetails</code> parameter.
  ///
  /// Parameter [loggingRole] :
  /// A value that allows the service to write your SFTP users' activity to your
  /// Amazon CloudWatch logs for monitoring and auditing purposes.
  ///
  /// Parameter [tags] :
  /// Key-value pairs that can be used to group and search for servers.
  Future<CreateServerResponse> createServer({
    EndpointDetails endpointDetails,
    EndpointType endpointType,
    String hostKey,
    IdentityProviderDetails identityProviderDetails,
    IdentityProviderType identityProviderType,
    String loggingRole,
    List<Tag> tags,
  }) async {
    _s.validateStringLength(
      'hostKey',
      hostKey,
      0,
      4096,
    );
    _s.validateStringLength(
      'loggingRole',
      loggingRole,
      20,
      2048,
    );
    _s.validateStringPattern(
      'loggingRole',
      loggingRole,
      r'''arn:.*role/.*''',
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.CreateServer'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'EndpointDetails': endpointDetails,
        'EndpointType': endpointType,
        'HostKey': hostKey,
        'IdentityProviderDetails': identityProviderDetails,
        'IdentityProviderType': identityProviderType,
        'LoggingRole': loggingRole,
        'Tags': tags,
      },
    );

    return CreateServerResponse.fromJson(jsonResponse.body);
  }

  /// Creates a user and associates them with an existing Secure File Transfer
  /// Protocol (SFTP) server. You can only create and associate users with SFTP
  /// servers that have the <code>IdentityProviderType</code> set to
  /// <code>SERVICE_MANAGED</code>. Using parameters for
  /// <code>CreateUser</code>, you can specify the user name, set the home
  /// directory, store the user's public key, and assign the user's AWS Identity
  /// and Access Management (IAM) role. You can also optionally add a scope-down
  /// policy, and assign metadata with tags that can be used to group and search
  /// for users.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [role] :
  /// The IAM role that controls your user's access to your Amazon S3 bucket.
  /// The policies attached to this role will determine the level of access you
  /// want to provide your users when transferring files into and out of your
  /// Amazon S3 bucket or buckets. The IAM role should also contain a trust
  /// relationship that allows the SFTP server to access your resources when
  /// servicing your SFTP user's transfer requests.
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server instance. This is
  /// the specific SFTP server that you added your user to.
  ///
  /// Parameter [userName] :
  /// A unique string that identifies a user and is associated with a server as
  /// specified by the <code>ServerId</code>. This user name must be a minimum
  /// of 3 and a maximum of 32 characters long. The following are valid
  /// characters: a-z, A-Z, 0-9, underscore, and hyphen. The user name can't
  /// start with a hyphen.
  ///
  /// Parameter [homeDirectory] :
  /// The landing directory (folder) for a user when they log in to the server
  /// using their SFTP client.
  ///
  /// An example is
  /// &lt;<code>your-Amazon-S3-bucket-name&gt;/home/username</code>.
  ///
  /// Parameter [homeDirectoryMappings] :
  /// Logical directory mappings that specify what S3 paths and keys should be
  /// visible to your user and how you want to make them visible. You will need
  /// to specify the "<code>Entry</code>" and "<code>Target</code>" pair, where
  /// <code>Entry</code> shows how the path is made visible and
  /// <code>Target</code> is the actual S3 path. If you only specify a target,
  /// it will be displayed as is. You will need to also make sure that your AWS
  /// IAM Role provides access to paths in <code>Target</code>. The following is
  /// an example.
  ///
  /// <code>'[ "/bucket2/documentation", { "Entry": "your-personal-report.pdf",
  /// "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" }
  /// ]'</code>
  ///
  /// In most cases, you can use this value instead of the scope down policy to
  /// lock your user down to the designated home directory ("chroot"). To do
  /// this, you can set <code>Entry</code> to '/' and set <code>Target</code> to
  /// the HomeDirectory parameter value.
  /// <note>
  /// If the target of a logical directory entry does not exist in S3, the entry
  /// will be ignored. As a workaround, you can use the S3 api to create 0 byte
  /// objects as place holders for your directory. If using the CLI, use the
  /// s3api call instead of s3 so you can use the put-object operation. For
  /// example, you use the following: <code>aws s3api put-object --bucket
  /// bucketname --key path/to/folder/</code>. Make sure that the end of the key
  /// name ends in a / for it to be considered a folder.
  /// </note>
  ///
  /// Parameter [homeDirectoryType] :
  /// The type of landing directory (folder) you want your users' home directory
  /// to be when they log into the SFTP server. If you set it to
  /// <code>PATH</code>, the user will see the absolute Amazon S3 bucket paths
  /// as is in their SFTP clients. If you set it <code>LOGICAL</code>, you will
  /// need to provide mappings in the <code>HomeDirectoryMappings</code> for how
  /// you want to make S3 paths visible to your user.
  ///
  /// Parameter [policy] :
  /// A scope-down policy for your user so you can use the same IAM role across
  /// multiple users. This policy scopes down user access to portions of their
  /// Amazon S3 bucket. Variables that you can use inside this policy include
  /// <code>${Transfer:UserName}</code>, <code>${Transfer:HomeDirectory}</code>,
  /// and <code>${Transfer:HomeBucket}</code>.
  /// <note>
  /// For scope-down policies, AWS Transfer for SFTP stores the policy as a JSON
  /// blob, instead of the Amazon Resource Name (ARN) of the policy. You save
  /// the policy as a JSON blob and pass it in the <code>Policy</code> argument.
  ///
  /// For an example of a scope-down policy, see
  /// "https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down"&gt;Creating
  /// a Scope-Down Policy.
  ///
  /// For more information, see
  /// "https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html"
  /// in the <i>AWS Security Token Service API Reference</i>.
  /// </note>
  ///
  /// Parameter [sshPublicKeyBody] :
  /// The public portion of the Secure Shell (SSH) key used to authenticate the
  /// user to the SFTP server.
  ///
  /// Parameter [tags] :
  /// Key-value pairs that can be used to group and search for users. Tags are
  /// metadata attached to users for any purpose.
  Future<CreateUserResponse> createUser({
    @_s.required String role,
    @_s.required String serverId,
    @_s.required String userName,
    String homeDirectory,
    List<HomeDirectoryMapEntry> homeDirectoryMappings,
    HomeDirectoryType homeDirectoryType,
    String policy,
    String sshPublicKeyBody,
    List<Tag> tags,
  }) async {
    ArgumentError.checkNotNull(role, 'role');
    _s.validateStringLength(
      'role',
      role,
      20,
      2048,
      isRequired: true,
    );
    _s.validateStringPattern(
      'role',
      role,
      r'''arn:.*role/.*''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    _s.validateStringLength(
      'homeDirectory',
      homeDirectory,
      0,
      1024,
    );
    _s.validateStringPattern(
      'homeDirectory',
      homeDirectory,
      r'''^$|/.*''',
    );
    _s.validateStringLength(
      'policy',
      policy,
      0,
      2048,
    );
    _s.validateStringLength(
      'sshPublicKeyBody',
      sshPublicKeyBody,
      0,
      2048,
    );
    _s.validateStringPattern(
      'sshPublicKeyBody',
      sshPublicKeyBody,
      r'''^ssh-rsa\s+[A-Za-z0-9+/]+[=]{0,3}(\s+.+)?\s*$''',
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.CreateUser'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Role': role,
        'ServerId': serverId,
        'UserName': userName,
        'HomeDirectory': homeDirectory,
        'HomeDirectoryMappings': homeDirectoryMappings,
        'HomeDirectoryType': homeDirectoryType,
        'Policy': policy,
        'SshPublicKeyBody': sshPublicKeyBody,
        'Tags': tags,
      },
    );

    return CreateUserResponse.fromJson(jsonResponse.body);
  }

  /// Deletes the Secure File Transfer Protocol (SFTP) server that you specify.
  ///
  /// No response returns from this operation.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [serverId] :
  /// A unique system-assigned identifier for an SFTP server instance.
  Future<void> deleteServer({
    @_s.required String serverId,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.DeleteServer'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
      },
    );
  }

  /// Deletes a user's Secure Shell (SSH) public key.
  ///
  /// No response is returned from this operation.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for a Secure File Transfer Protocol
  /// (SFTP) server instance that has the user assigned to it.
  ///
  /// Parameter [sshPublicKeyId] :
  /// A unique identifier used to reference your user's specific SSH key.
  ///
  /// Parameter [userName] :
  /// A unique string that identifies a user whose public key is being deleted.
  Future<void> deleteSshPublicKey({
    @_s.required String serverId,
    @_s.required String sshPublicKeyId,
    @_s.required String userName,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(sshPublicKeyId, 'sshPublicKeyId');
    _s.validateStringLength(
      'sshPublicKeyId',
      sshPublicKeyId,
      21,
      21,
      isRequired: true,
    );
    _s.validateStringPattern(
      'sshPublicKeyId',
      sshPublicKeyId,
      r'''^key-[0-9a-f]{17}$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.DeleteSshPublicKey'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'SshPublicKeyId': sshPublicKeyId,
        'UserName': userName,
      },
    );
  }

  /// Deletes the user belonging to the server you specify.
  ///
  /// No response returns from this operation.
  /// <note>
  /// When you delete a user from a server, the user's information is lost.
  /// </note>
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server instance that has
  /// the user assigned to it.
  ///
  /// Parameter [userName] :
  /// A unique string that identifies a user that is being deleted from the
  /// server.
  Future<void> deleteUser({
    @_s.required String serverId,
    @_s.required String userName,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.DeleteUser'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'UserName': userName,
      },
    );
  }

  /// Describes the server that you specify by passing the <code>ServerId</code>
  /// parameter.
  ///
  /// The response contains a description of the server's properties. When you
  /// set <code>EndpointType</code> to VPC, the response will contain the
  /// <code>EndpointDetails</code>.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server.
  Future<DescribeServerResponse> describeServer({
    @_s.required String serverId,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.DescribeServer'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
      },
    );

    return DescribeServerResponse.fromJson(jsonResponse.body);
  }

  /// Describes the user assigned to a specific server, as identified by its
  /// <code>ServerId</code> property.
  ///
  /// The response from this call returns the properties of the user associated
  /// with the <code>ServerId</code> value that was specified.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server that has this user
  /// assigned.
  ///
  /// Parameter [userName] :
  /// The name of the user assigned to one or more servers. User names are part
  /// of the sign-in credentials to use the AWS Transfer for SFTP service and
  /// perform file transfer tasks.
  Future<DescribeUserResponse> describeUser({
    @_s.required String serverId,
    @_s.required String userName,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.DescribeUser'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'UserName': userName,
      },
    );

    return DescribeUserResponse.fromJson(jsonResponse.body);
  }

  /// Adds a Secure Shell (SSH) public key to a user account identified by a
  /// <code>UserName</code> value assigned to a specific server, identified by
  /// <code>ServerId</code>.
  ///
  /// The response returns the <code>UserName</code> value, the
  /// <code>ServerId</code> value, and the name of the
  /// <code>SshPublicKeyId</code>.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server.
  ///
  /// Parameter [sshPublicKeyBody] :
  /// The public key portion of an SSH key pair.
  ///
  /// Parameter [userName] :
  /// The name of the user account that is assigned to one or more servers.
  Future<ImportSshPublicKeyResponse> importSshPublicKey({
    @_s.required String serverId,
    @_s.required String sshPublicKeyBody,
    @_s.required String userName,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(sshPublicKeyBody, 'sshPublicKeyBody');
    _s.validateStringLength(
      'sshPublicKeyBody',
      sshPublicKeyBody,
      0,
      2048,
      isRequired: true,
    );
    _s.validateStringPattern(
      'sshPublicKeyBody',
      sshPublicKeyBody,
      r'''^ssh-rsa\s+[A-Za-z0-9+/]+[=]{0,3}(\s+.+)?\s*$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.ImportSshPublicKey'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'SshPublicKeyBody': sshPublicKeyBody,
        'UserName': userName,
      },
    );

    return ImportSshPublicKeyResponse.fromJson(jsonResponse.body);
  }

  /// Lists the Secure File Transfer Protocol (SFTP) servers that are associated
  /// with your AWS account.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidNextTokenException].
  /// May throw [InvalidRequestException].
  ///
  /// Parameter [maxResults] :
  /// Specifies the number of servers to return as a response to the
  /// <code>ListServers</code> query.
  ///
  /// Parameter [nextToken] :
  /// When additional results are obtained from the <code>ListServers</code>
  /// command, a <code>NextToken</code> parameter is returned in the output. You
  /// can then pass the <code>NextToken</code> parameter in a subsequent command
  /// to continue listing additional servers.
  Future<ListServersResponse> listServers({
    int maxResults,
    String nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      6144,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.ListServers'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'MaxResults': maxResults,
        'NextToken': nextToken,
      },
    );

    return ListServersResponse.fromJson(jsonResponse.body);
  }

  /// Lists all of the tags associated with the Amazon Resource Number (ARN) you
  /// specify. The resource can be a user, server, or role.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidNextTokenException].
  /// May throw [InvalidRequestException].
  ///
  /// Parameter [arn] :
  /// Requests the tags associated with a particular Amazon Resource Name (ARN).
  /// An ARN is an identifier for a specific AWS resource, such as a server,
  /// user, or role.
  ///
  /// Parameter [maxResults] :
  /// Specifies the number of tags to return as a response to the
  /// <code>ListTagsForResource</code> request.
  ///
  /// Parameter [nextToken] :
  /// When you request additional results from the
  /// <code>ListTagsForResource</code> operation, a <code>NextToken</code>
  /// parameter is returned in the input. You can then pass in a subsequent
  /// command to the <code>NextToken</code> parameter to continue listing
  /// additional tags.
  Future<ListTagsForResourceResponse> listTagsForResource({
    @_s.required String arn,
    int maxResults,
    String nextToken,
  }) async {
    ArgumentError.checkNotNull(arn, 'arn');
    _s.validateStringLength(
      'arn',
      arn,
      20,
      1600,
      isRequired: true,
    );
    _s.validateStringPattern(
      'arn',
      arn,
      r'''arn:.*''',
      isRequired: true,
    );
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      6144,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.ListTagsForResource'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Arn': arn,
        'MaxResults': maxResults,
        'NextToken': nextToken,
      },
    );

    return ListTagsForResourceResponse.fromJson(jsonResponse.body);
  }

  /// Lists the users for the server that you specify by passing the
  /// <code>ServerId</code> parameter.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidNextTokenException].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for a Secure File Transfer Protocol
  /// (SFTP) server that has users assigned to it.
  ///
  /// Parameter [maxResults] :
  /// Specifies the number of users to return as a response to the
  /// <code>ListUsers</code> request.
  ///
  /// Parameter [nextToken] :
  /// When you can get additional results from the <code>ListUsers</code> call,
  /// a <code>NextToken</code> parameter is returned in the output. You can then
  /// pass in a subsequent command to the <code>NextToken</code> parameter to
  /// continue listing additional users.
  Future<ListUsersResponse> listUsers({
    @_s.required String serverId,
    int maxResults,
    String nextToken,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      6144,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.ListUsers'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'MaxResults': maxResults,
        'NextToken': nextToken,
      },
    );

    return ListUsersResponse.fromJson(jsonResponse.body);
  }

  /// Changes the state of a Secure File Transfer Protocol (SFTP) server from
  /// <code>OFFLINE</code> to <code>ONLINE</code>. It has no impact on an SFTP
  /// server that is already <code>ONLINE</code>. An <code>ONLINE</code> server
  /// can accept and process file transfer jobs.
  ///
  /// The state of <code>STARTING</code> indicates that the server is in an
  /// intermediate state, either not fully able to respond, or not fully online.
  /// The values of <code>START_FAILED</code> can indicate an error condition.
  ///
  /// No response is returned from this call.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server that you start.
  Future<void> startServer({
    @_s.required String serverId,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.StartServer'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
      },
    );
  }

  /// Changes the state of an SFTP server from <code>ONLINE</code> to
  /// <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and
  /// process file transfer jobs. Information tied to your server such as server
  /// and user properties are not affected by stopping your server. Stopping a
  /// server will not reduce or impact your Secure File Transfer Protocol (SFTP)
  /// endpoint billing.
  ///
  /// The state of <code>STOPPING</code> indicates that the server is in an
  /// intermediate state, either not fully able to respond, or not fully
  /// offline. The values of <code>STOP_FAILED</code> can indicate an error
  /// condition.
  ///
  /// No response is returned from this call.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server that you stopped.
  Future<void> stopServer({
    @_s.required String serverId,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.StopServer'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
      },
    );
  }

  /// Attaches a key-value pair to a resource, as identified by its Amazon
  /// Resource Name (ARN). Resources are users, servers, roles, and other
  /// entities.
  ///
  /// There is no response returned from this call.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [arn] :
  /// An Amazon Resource Name (ARN) for a specific AWS resource, such as a
  /// server, user, or role.
  ///
  /// Parameter [tags] :
  /// Key-value pairs assigned to ARNs that you can use to group and search for
  /// resources by type. You can attach this metadata to user accounts for any
  /// purpose.
  Future<void> tagResource({
    @_s.required String arn,
    @_s.required List<Tag> tags,
  }) async {
    ArgumentError.checkNotNull(arn, 'arn');
    _s.validateStringLength(
      'arn',
      arn,
      20,
      1600,
      isRequired: true,
    );
    _s.validateStringPattern(
      'arn',
      arn,
      r'''arn:.*''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(tags, 'tags');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.TagResource'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Arn': arn,
        'Tags': tags,
      },
    );
  }

  /// If the <code>IdentityProviderType</code> of the server is
  /// <code>API_Gateway</code>, tests whether your API Gateway is set up
  /// successfully. We highly recommend that you call this operation to test
  /// your authentication method as soon as you create your server. By doing so,
  /// you can troubleshoot issues with the API Gateway integration to ensure
  /// that your users can successfully use the service.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned identifier for a specific server. That server's user
  /// authentication method is tested with a user name and password.
  ///
  /// Parameter [userName] :
  /// This request parameter is the name of the user account to be tested.
  ///
  /// Parameter [userPassword] :
  /// The password of the user account to be tested.
  Future<TestIdentityProviderResponse> testIdentityProvider({
    @_s.required String serverId,
    @_s.required String userName,
    String userPassword,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    _s.validateStringLength(
      'userPassword',
      userPassword,
      0,
      2048,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.TestIdentityProvider'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'UserName': userName,
        'UserPassword': userPassword,
      },
    );

    return TestIdentityProviderResponse.fromJson(jsonResponse.body);
  }

  /// Detaches a key-value pair from a resource, as identified by its Amazon
  /// Resource Name (ARN). Resources are users, servers, roles, and other
  /// entities.
  ///
  /// No response is returned from this call.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [arn] :
  /// This is the value of the resource that will have the tag removed. An
  /// Amazon Resource Name (ARN) is an identifier for a specific AWS resource,
  /// such as a server, user, or role.
  ///
  /// Parameter [tagKeys] :
  /// TagKeys are key-value pairs assigned to ARNs that can be used to group and
  /// search for resources by type. This metadata can be attached to resources
  /// for any purpose.
  Future<void> untagResource({
    @_s.required String arn,
    @_s.required List<String> tagKeys,
  }) async {
    ArgumentError.checkNotNull(arn, 'arn');
    _s.validateStringLength(
      'arn',
      arn,
      20,
      1600,
      isRequired: true,
    );
    _s.validateStringPattern(
      'arn',
      arn,
      r'''arn:.*''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(tagKeys, 'tagKeys');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.UntagResource'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Arn': arn,
        'TagKeys': tagKeys,
      },
    );
  }

  /// Updates the server properties after that server has been created.
  ///
  /// The <code>UpdateServer</code> call returns the <code>ServerId</code> of
  /// the Secure File Transfer Protocol (SFTP) server you updated.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [ConflictException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server instance that the
  /// user account is assigned to.
  ///
  /// Parameter [endpointDetails] :
  /// The virtual private cloud (VPC) endpoint settings that are configured for
  /// your SFTP server. With a VPC endpoint, you can restrict access to your
  /// SFTP server to resources only within your VPC. To control incoming
  /// internet traffic, you will need to associate one or more Elastic IP
  /// addresses with your server's endpoint.
  ///
  /// Parameter [endpointType] :
  /// The type of endpoint that you want your SFTP server to connect to. You can
  /// choose to connect to the public internet or a virtual private cloud (VPC)
  /// endpoint. With a VPC endpoint, your SFTP server isn't accessible over the
  /// public internet.
  ///
  /// Parameter [hostKey] :
  /// The RSA private key as generated by <code>ssh-keygen -N "" -f
  /// my-new-server-key</code>.
  /// <important>
  /// If you aren't planning to migrate existing users from an existing SFTP
  /// server to a new AWS SFTP server, don't update the host key. Accidentally
  /// changing a server's host key can be disruptive.
  /// </important>
  /// For more information, see
  /// "https://docs.aws.amazon.com/transfer/latest/userguide/configuring-servers.html#change-host-key"
  /// in the <i>AWS SFTP User Guide.</i>
  ///
  /// Parameter [identityProviderDetails] :
  /// This response parameter is an array containing all of the information
  /// required to call a customer's authentication API method.
  ///
  /// Parameter [loggingRole] :
  /// A value that changes the AWS Identity and Access Management (IAM) role
  /// that allows Amazon S3 events to be logged in Amazon CloudWatch, turning
  /// logging on or off.
  Future<UpdateServerResponse> updateServer({
    @_s.required String serverId,
    EndpointDetails endpointDetails,
    EndpointType endpointType,
    String hostKey,
    IdentityProviderDetails identityProviderDetails,
    String loggingRole,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    _s.validateStringLength(
      'hostKey',
      hostKey,
      0,
      4096,
    );
    _s.validateStringLength(
      'loggingRole',
      loggingRole,
      0,
      2048,
    );
    _s.validateStringPattern(
      'loggingRole',
      loggingRole,
      r'''^$|arn:.*role/.*''',
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.UpdateServer'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'EndpointDetails': endpointDetails,
        'EndpointType': endpointType,
        'HostKey': hostKey,
        'IdentityProviderDetails': identityProviderDetails,
        'LoggingRole': loggingRole,
      },
    );

    return UpdateServerResponse.fromJson(jsonResponse.body);
  }

  /// Assigns new properties to a user. Parameters you pass modify any or all of
  /// the following: the home directory, role, and policy for the
  /// <code>UserName</code> and <code>ServerId</code> you specify.
  ///
  /// The response returns the <code>ServerId</code> and the
  /// <code>UserName</code> for the updated user.
  ///
  /// May throw [ServiceUnavailableException].
  /// May throw [InternalServiceError].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [serverId] :
  /// A system-assigned unique identifier for an SFTP server instance that the
  /// user account is assigned to.
  ///
  /// Parameter [userName] :
  /// A unique string that identifies a user and is associated with a server as
  /// specified by the <code>ServerId</code>. This is the string that will be
  /// used by your user when they log in to your SFTP server. This user name is
  /// a minimum of 3 and a maximum of 32 characters long. The following are
  /// valid characters: a-z, A-Z, 0-9, underscore, and hyphen. The user name
  /// can't start with a hyphen.
  ///
  /// Parameter [homeDirectory] :
  /// A parameter that specifies the landing directory (folder) for a user when
  /// they log in to the server using their client.
  ///
  /// An example is
  /// <code>&lt;your-Amazon-S3-bucket-name&gt;/home/username</code>.
  ///
  /// Parameter [homeDirectoryMappings] :
  /// Logical directory mappings that specify what S3 paths and keys should be
  /// visible to your user and how you want to make them visible. You will need
  /// to specify the "<code>Entry</code>" and "<code>Target</code>" pair, where
  /// <code>Entry</code> shows how the path is made visible and
  /// <code>Target</code> is the actual S3 path. If you only specify a target,
  /// it will be displayed as is. You will need to also make sure that your AWS
  /// IAM Role provides access to paths in <code>Target</code>. The following is
  /// an example.
  ///
  /// <code>'[ "/bucket2/documentation", { "Entry": "your-personal-report.pdf",
  /// "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" }
  /// ]'</code>
  ///
  /// In most cases, you can use this value instead of the scope down policy to
  /// lock your user down to the designated home directory ("chroot"). To do
  /// this, you can set <code>Entry</code> to '/' and set <code>Target</code> to
  /// the HomeDirectory parameter value.
  /// <note>
  /// If the target of a logical directory entry does not exist in S3, the entry
  /// will be ignored. As a workaround, you can use the S3 api to create 0 byte
  /// objects as place holders for your directory. If using the CLI, use the
  /// s3api call instead of s3 so you can use the put-object operation. For
  /// example, you use the following: <code>aws s3api put-object --bucket
  /// bucketname --key path/to/folder/</code>. Make sure that the end of the key
  /// name ends in a / for it to be considered a folder.
  /// </note>
  ///
  /// Parameter [homeDirectoryType] :
  /// The type of landing directory (folder) you want your users' home directory
  /// to be when they log into the SFTP serve. If you set it to
  /// <code>PATH</code>, the user will see the absolute Amazon S3 bucket paths
  /// as is in their SFTP clients. If you set it <code>LOGICAL</code>, you will
  /// need to provide mappings in the <code>HomeDirectoryMappings</code> for how
  /// you want to make S3 paths visible to your user.
  ///
  /// Parameter [policy] :
  /// Allows you to supply a scope-down policy for your user so you can use the
  /// same AWS Identity and Access Management (IAM) role across multiple users.
  /// The policy scopes down user access to portions of your Amazon S3 bucket.
  /// Variables you can use inside this policy include
  /// <code>${Transfer:UserName}</code>, <code>${Transfer:HomeDirectory}</code>,
  /// and <code>${Transfer:HomeBucket}</code>.
  /// <note>
  /// For scope-down policies, AWS Transfer for SFTP stores the policy as a JSON
  /// blob, instead of the Amazon Resource Name (ARN) of the policy. You save
  /// the policy as a JSON blob and pass it in the <code>Policy</code> argument.
  ///
  /// For an example of a scope-down policy, see
  /// "https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down"&gt;Creating
  /// a Scope-Down Policy.
  ///
  /// For more information, see
  /// "https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html"
  /// in the <i>AWS Security Token Service API Reference</i>.
  /// </note>
  ///
  /// Parameter [role] :
  /// The IAM role that controls your user's access to your Amazon S3 bucket.
  /// The policies attached to this role will determine the level of access you
  /// want to provide your users when transferring files into and out of your
  /// Amazon S3 bucket or buckets. The IAM role should also contain a trust
  /// relationship that allows the Secure File Transfer Protocol (SFTP) server
  /// to access your resources when servicing your SFTP user's transfer
  /// requests.
  Future<UpdateUserResponse> updateUser({
    @_s.required String serverId,
    @_s.required String userName,
    String homeDirectory,
    List<HomeDirectoryMapEntry> homeDirectoryMappings,
    HomeDirectoryType homeDirectoryType,
    String policy,
    String role,
  }) async {
    ArgumentError.checkNotNull(serverId, 'serverId');
    _s.validateStringLength(
      'serverId',
      serverId,
      19,
      19,
      isRequired: true,
    );
    _s.validateStringPattern(
      'serverId',
      serverId,
      r'''^s-([0-9a-f]{17})$''',
      isRequired: true,
    );
    ArgumentError.checkNotNull(userName, 'userName');
    _s.validateStringLength(
      'userName',
      userName,
      3,
      32,
      isRequired: true,
    );
    _s.validateStringPattern(
      'userName',
      userName,
      r'''^[a-zA-Z0-9_][a-zA-Z0-9_-]{2,31}$''',
      isRequired: true,
    );
    _s.validateStringLength(
      'homeDirectory',
      homeDirectory,
      0,
      1024,
    );
    _s.validateStringPattern(
      'homeDirectory',
      homeDirectory,
      r'''^$|/.*''',
    );
    _s.validateStringLength(
      'policy',
      policy,
      0,
      2048,
    );
    _s.validateStringLength(
      'role',
      role,
      20,
      2048,
    );
    _s.validateStringPattern(
      'role',
      role,
      r'''arn:.*role/.*''',
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'TransferService.UpdateUser'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ServerId': serverId,
        'UserName': userName,
        'HomeDirectory': homeDirectory,
        'HomeDirectoryMappings': homeDirectoryMappings,
        'HomeDirectoryType': homeDirectoryType,
        'Policy': policy,
        'Role': role,
      },
    );

    return UpdateUserResponse.fromJson(jsonResponse.body);
  }
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class CreateServerResponse {
  /// The service-assigned ID of the SFTP server that is created.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  CreateServerResponse({
    @_s.required this.serverId,
  });
  factory CreateServerResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateServerResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class CreateUserResponse {
  /// The ID of the SFTP server that the user is attached to.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// A unique string that identifies a user account associated with an SFTP
  /// server.
  @_s.JsonKey(name: 'UserName')
  final String userName;

  CreateUserResponse({
    @_s.required this.serverId,
    @_s.required this.userName,
  });
  factory CreateUserResponse.fromJson(Map<String, dynamic> json) =>
      _$CreateUserResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class DescribeServerResponse {
  /// An array containing the properties of the server with the
  /// <code>ServerID</code> you specified.
  @_s.JsonKey(name: 'Server')
  final DescribedServer server;

  DescribeServerResponse({
    @_s.required this.server,
  });
  factory DescribeServerResponse.fromJson(Map<String, dynamic> json) =>
      _$DescribeServerResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class DescribeUserResponse {
  /// A system-assigned unique identifier for an SFTP server that has this user
  /// assigned.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// An array containing the properties of the user account for the
  /// <code>ServerID</code> value that you specified.
  @_s.JsonKey(name: 'User')
  final DescribedUser user;

  DescribeUserResponse({
    @_s.required this.serverId,
    @_s.required this.user,
  });
  factory DescribeUserResponse.fromJson(Map<String, dynamic> json) =>
      _$DescribeUserResponseFromJson(json);
}

/// Describes the properties of the server that was specified. Information
/// returned includes the following: the server Amazon Resource Name (ARN), the
/// authentication configuration and type, the logging role, the server ID and
/// state, and assigned tags or metadata.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class DescribedServer {
  /// Specifies the unique Amazon Resource Name (ARN) for the server to be
  /// described.
  @_s.JsonKey(name: 'Arn')
  final String arn;

  /// The virtual private cloud (VPC) endpoint settings that you configured for
  /// your SFTP server.
  @_s.JsonKey(name: 'EndpointDetails')
  final EndpointDetails endpointDetails;

  /// The type of endpoint that your SFTP server is connected to. If your SFTP
  /// server is connected to a VPC endpoint, your server isn't accessible over the
  /// public internet.
  @_s.JsonKey(name: 'EndpointType')
  final EndpointType endpointType;

  /// This value contains the message-digest algorithm (MD5) hash of the server's
  /// host key. This value is equivalent to the output of the <code>ssh-keygen -l
  /// -E md5 -f my-new-server-key</code> command.
  @_s.JsonKey(name: 'HostKeyFingerprint')
  final String hostKeyFingerprint;

  /// Specifies information to call a customer-supplied authentication API. This
  /// field is not populated when the <code>IdentityProviderType</code> of the
  /// server is <code>SERVICE_MANAGED</code>&gt;.
  @_s.JsonKey(name: 'IdentityProviderDetails')
  final IdentityProviderDetails identityProviderDetails;

  /// This property defines the mode of authentication method enabled for this
  /// service. A value of <code>SERVICE_MANAGED</code> means that you are using
  /// this server to store and access SFTP user credentials within the service. A
  /// value of <code>API_GATEWAY</code> indicates that you have integrated an API
  /// Gateway endpoint that will be invoked for authenticating your user into the
  /// service.
  @_s.JsonKey(name: 'IdentityProviderType')
  final IdentityProviderType identityProviderType;

  /// This property is an AWS Identity and Access Management (IAM) entity that
  /// allows the server to turn on Amazon CloudWatch logging for Amazon S3 events.
  /// When set, user activity can be viewed in your CloudWatch logs.
  @_s.JsonKey(name: 'LoggingRole')
  final String loggingRole;

  /// This property is a unique system-assigned identifier for the SFTP server
  /// that you instantiate.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// The condition of the SFTP server for the server that was described. A value
  /// of <code>ONLINE</code> indicates that the server can accept jobs and
  /// transfer files. A <code>State</code> value of <code>OFFLINE</code> means
  /// that the server cannot perform file transfer operations.
  ///
  /// The states of <code>STARTING</code> and <code>STOPPING</code> indicate that
  /// the server is in an intermediate state, either not fully able to respond, or
  /// not fully offline. The values of <code>START_FAILED</code> or
  /// <code>STOP_FAILED</code> can indicate an error condition.
  @_s.JsonKey(name: 'State')
  final State state;

  /// This property contains the key-value pairs that you can use to search for
  /// and group servers that were assigned to the server that was described.
  @_s.JsonKey(name: 'Tags')
  final List<Tag> tags;

  /// The number of users that are assigned to the SFTP server you specified with
  /// the <code>ServerId</code>.
  @_s.JsonKey(name: 'UserCount')
  final int userCount;

  DescribedServer({
    @_s.required this.arn,
    this.endpointDetails,
    this.endpointType,
    this.hostKeyFingerprint,
    this.identityProviderDetails,
    this.identityProviderType,
    this.loggingRole,
    this.serverId,
    this.state,
    this.tags,
    this.userCount,
  });
  factory DescribedServer.fromJson(Map<String, dynamic> json) =>
      _$DescribedServerFromJson(json);
}

/// Returns properties of the user that you want to describe.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class DescribedUser {
  /// This property contains the unique Amazon Resource Name (ARN) for the user
  /// that was requested to be described.
  @_s.JsonKey(name: 'Arn')
  final String arn;

  /// This property specifies the landing directory (or folder), which is the
  /// location that files are written to or read from in an Amazon S3 bucket for
  /// the described user. An example is <code>/<i>your s3 bucket
  /// name</i>/home/<i>username</i> </code>.
  @_s.JsonKey(name: 'HomeDirectory')
  final String homeDirectory;

  /// Logical directory mappings that you specified for what S3 paths and keys
  /// should be visible to your user and how you want to make them visible. You
  /// will need to specify the "<code>Entry</code>" and "<code>Target</code>"
  /// pair, where <code>Entry</code> shows how the path is made visible and
  /// <code>Target</code> is the actual S3 path. If you only specify a target, it
  /// will be displayed as is. You will need to also make sure that your AWS IAM
  /// Role provides access to paths in <code>Target</code>.
  ///
  /// In most cases, you can use this value instead of the scope down policy to
  /// lock your user down to the designated home directory ("chroot"). To do this,
  /// you can set <code>Entry</code> to '/' and set <code>Target</code> to the
  /// HomeDirectory parameter value.
  ///
  /// In most cases, you can use this value instead of the scope down policy to
  /// lock your user down to the designated home directory ("chroot"). To do this,
  /// you can set <code>Entry</code> to '/' and set <code>Target</code> to the
  /// HomeDirectory parameter value.
  @_s.JsonKey(name: 'HomeDirectoryMappings')
  final List<HomeDirectoryMapEntry> homeDirectoryMappings;

  /// The type of landing directory (folder) you mapped for your users' to see
  /// when they log into the SFTP server. If you set it to <code>PATH</code>, the
  /// user will see the absolute Amazon S3 bucket paths as is in their SFTP
  /// clients. If you set it <code>LOGICAL</code>, you will need to provide
  /// mappings in the <code>HomeDirectoryMappings</code> for how you want to make
  /// S3 paths visible to your user.
  @_s.JsonKey(name: 'HomeDirectoryType')
  final HomeDirectoryType homeDirectoryType;

  /// Specifies the name of the policy in use for the described user.
  @_s.JsonKey(name: 'Policy')
  final String policy;

  /// This property specifies the IAM role that controls your user's access to
  /// your Amazon S3 bucket. The policies attached to this role will determine the
  /// level of access you want to provide your users when transferring files into
  /// and out of your Amazon S3 bucket or buckets. The IAM role should also
  /// contain a trust relationship that allows the SFTP server to access your
  /// resources when servicing your SFTP user's transfer requests.
  @_s.JsonKey(name: 'Role')
  final String role;

  /// This property contains the public key portion of the Secure Shell (SSH) keys
  /// stored for the described user.
  @_s.JsonKey(name: 'SshPublicKeys')
  final List<SshPublicKey> sshPublicKeys;

  /// This property contains the key-value pairs for the user requested. Tag can
  /// be used to search for and group users for a variety of purposes.
  @_s.JsonKey(name: 'Tags')
  final List<Tag> tags;

  /// This property is the name of the user that was requested to be described.
  /// User names are used for authentication purposes. This is the string that
  /// will be used by your user when they log in to your SFTP server.
  @_s.JsonKey(name: 'UserName')
  final String userName;

  DescribedUser({
    @_s.required this.arn,
    this.homeDirectory,
    this.homeDirectoryMappings,
    this.homeDirectoryType,
    this.policy,
    this.role,
    this.sshPublicKeys,
    this.tags,
    this.userName,
  });
  factory DescribedUser.fromJson(Map<String, dynamic> json) =>
      _$DescribedUserFromJson(json);
}

/// The virtual private cloud (VPC) endpoint settings that are configured for
/// your SFTP server. With a VPC endpoint, you can restrict access to your SFTP
/// server and resources only within your VPC. To control incoming internet
/// traffic, invoke the <code>UpdateServer</code> API and attach an Elastic IP
/// to your server's endpoint.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: true)
class EndpointDetails {
  /// A list of address allocation IDs that are required to attach an Elastic IP
  /// address to your SFTP server's endpoint. This is only valid in the
  /// <code>UpdateServer</code> API.
  /// <note>
  /// This property can only be use when <code>EndpointType</code> is set to
  /// <code>VPC</code>.
  /// </note>
  @_s.JsonKey(name: 'AddressAllocationIds')
  final List<String> addressAllocationIds;

  /// A list of subnet IDs that are required to host your SFTP server endpoint in
  /// your VPC.
  @_s.JsonKey(name: 'SubnetIds')
  final List<String> subnetIds;

  /// The ID of the VPC endpoint.
  @_s.JsonKey(name: 'VpcEndpointId')
  final String vpcEndpointId;

  /// The VPC ID of the virtual private cloud in which the SFTP server's endpoint
  /// will be hosted.
  @_s.JsonKey(name: 'VpcId')
  final String vpcId;

  EndpointDetails({
    this.addressAllocationIds,
    this.subnetIds,
    this.vpcEndpointId,
    this.vpcId,
  });
  factory EndpointDetails.fromJson(Map<String, dynamic> json) =>
      _$EndpointDetailsFromJson(json);

  Map<String, dynamic> toJson() => _$EndpointDetailsToJson(this);
}

enum EndpointType {
  @_s.JsonValue('PUBLIC')
  public,
  @_s.JsonValue('VPC')
  vpc,
  @_s.JsonValue('VPC_ENDPOINT')
  vpcEndpoint,
}

/// Represents an object that contains entries and a targets for
/// <code>HomeDirectoryMappings</code>.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: true)
class HomeDirectoryMapEntry {
  /// Represents an entry and a target for <code>HomeDirectoryMappings</code>.
  @_s.JsonKey(name: 'Entry')
  final String entry;

  /// Represents the map target that is used in a
  /// <code>HomeDirectorymapEntry</code>.
  @_s.JsonKey(name: 'Target')
  final String target;

  HomeDirectoryMapEntry({
    @_s.required this.entry,
    @_s.required this.target,
  });
  factory HomeDirectoryMapEntry.fromJson(Map<String, dynamic> json) =>
      _$HomeDirectoryMapEntryFromJson(json);

  Map<String, dynamic> toJson() => _$HomeDirectoryMapEntryToJson(this);
}

enum HomeDirectoryType {
  @_s.JsonValue('PATH')
  path,
  @_s.JsonValue('LOGICAL')
  logical,
}

/// Returns information related to the type of user authentication that is in
/// use for a server's users. A server can have only one method of
/// authentication.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: true)
class IdentityProviderDetails {
  /// The <code>InvocationRole</code> parameter provides the type of
  /// <code>InvocationRole</code> used to authenticate the user account.
  @_s.JsonKey(name: 'InvocationRole')
  final String invocationRole;

  /// The <code>Url</code> parameter provides contains the location of the service
  /// endpoint used to authenticate users.
  @_s.JsonKey(name: 'Url')
  final String url;

  IdentityProviderDetails({
    this.invocationRole,
    this.url,
  });
  factory IdentityProviderDetails.fromJson(Map<String, dynamic> json) =>
      _$IdentityProviderDetailsFromJson(json);

  Map<String, dynamic> toJson() => _$IdentityProviderDetailsToJson(this);
}

/// Returns information related to the type of user authentication that is in
/// use for a server's users. For <code>SERVICE_MANAGED</code> authentication,
/// the Secure Shell (SSH) public keys are stored with a user on an SFTP server
/// instance. For <code>API_GATEWAY</code> authentication, your custom
/// authentication method is implemented by using an API call. A server can have
/// only one method of authentication.
enum IdentityProviderType {
  @_s.JsonValue('SERVICE_MANAGED')
  serviceManaged,
  @_s.JsonValue('API_GATEWAY')
  apiGateway,
}

/// This response identifies the user, the server they belong to, and the
/// identifier of the SSH public key associated with that user. A user can have
/// more than one key on each server that they are associated with.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ImportSshPublicKeyResponse {
  /// A system-assigned unique identifier for an SFTP server.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// This identifier is the name given to a public key by the system that was
  /// imported.
  @_s.JsonKey(name: 'SshPublicKeyId')
  final String sshPublicKeyId;

  /// A user name assigned to the <code>ServerID</code> value that you specified.
  @_s.JsonKey(name: 'UserName')
  final String userName;

  ImportSshPublicKeyResponse({
    @_s.required this.serverId,
    @_s.required this.sshPublicKeyId,
    @_s.required this.userName,
  });
  factory ImportSshPublicKeyResponse.fromJson(Map<String, dynamic> json) =>
      _$ImportSshPublicKeyResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListServersResponse {
  /// An array of servers that were listed.
  @_s.JsonKey(name: 'Servers')
  final List<ListedServer> servers;

  /// When you can get additional results from the <code>ListServers</code>
  /// operation, a <code>NextToken</code> parameter is returned in the output. In
  /// a following command, you can pass in the <code>NextToken</code> parameter to
  /// continue listing additional servers.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  ListServersResponse({
    @_s.required this.servers,
    this.nextToken,
  });
  factory ListServersResponse.fromJson(Map<String, dynamic> json) =>
      _$ListServersResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListTagsForResourceResponse {
  /// This value is the ARN you specified to list the tags of.
  @_s.JsonKey(name: 'Arn')
  final String arn;

  /// When you can get additional results from the
  /// <code>ListTagsForResource</code> call, a <code>NextToken</code> parameter is
  /// returned in the output. You can then pass in a subsequent command to the
  /// <code>NextToken</code> parameter to continue listing additional tags.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  /// Key-value pairs that are assigned to a resource, usually for the purpose of
  /// grouping and searching for items. Tags are metadata that you define.
  @_s.JsonKey(name: 'Tags')
  final List<Tag> tags;

  ListTagsForResourceResponse({
    this.arn,
    this.nextToken,
    this.tags,
  });
  factory ListTagsForResourceResponse.fromJson(Map<String, dynamic> json) =>
      _$ListTagsForResourceResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListUsersResponse {
  /// A system-assigned unique identifier for an SFTP server that the users are
  /// assigned to.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// Returns the user accounts and their properties for the <code>ServerId</code>
  /// value that you specify.
  @_s.JsonKey(name: 'Users')
  final List<ListedUser> users;

  /// When you can get additional results from the <code>ListUsers</code> call, a
  /// <code>NextToken</code> parameter is returned in the output. You can then
  /// pass in a subsequent command to the <code>NextToken</code> parameter to
  /// continue listing additional users.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  ListUsersResponse({
    @_s.required this.serverId,
    @_s.required this.users,
    this.nextToken,
  });
  factory ListUsersResponse.fromJson(Map<String, dynamic> json) =>
      _$ListUsersResponseFromJson(json);
}

/// Returns properties of the server that was specified.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListedServer {
  /// The unique Amazon Resource Name (ARN) for the server to be listed.
  @_s.JsonKey(name: 'Arn')
  final String arn;

  /// The type of VPC endpoint that your SFTP server is connected to. If your SFTP
  /// server is connected to a VPC endpoint, your server isn't accessible over the
  /// public internet.
  @_s.JsonKey(name: 'EndpointType')
  final EndpointType endpointType;

  /// The authentication method used to validate a user for the server that was
  /// specified. This can include Secure Shell (SSH), user name and password
  /// combinations, or your own custom authentication method. Valid values include
  /// <code>SERVICE_MANAGED</code> or <code>API_GATEWAY</code>.
  @_s.JsonKey(name: 'IdentityProviderType')
  final IdentityProviderType identityProviderType;

  /// The AWS Identity and Access Management entity that allows the server to turn
  /// on Amazon CloudWatch logging.
  @_s.JsonKey(name: 'LoggingRole')
  final String loggingRole;

  /// This value is the unique system assigned identifier for the SFTP servers
  /// that were listed.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// This property describes the condition of the SFTP server for the server that
  /// was described. A value of <code>ONLINE</code>&gt; indicates that the server
  /// can accept jobs and transfer files. A <code>State</code> value of
  /// <code>OFFLINE</code> means that the server cannot perform file transfer
  /// operations.
  ///
  /// The states of <code>STARTING</code> and <code>STOPPING</code> indicate that
  /// the server is in an intermediate state, either not fully able to respond, or
  /// not fully offline. The values of <code>START_FAILED</code> or
  /// <code>STOP_FAILED</code> can indicate an error condition.
  @_s.JsonKey(name: 'State')
  final State state;

  /// This property is a numeric value that indicates the number of users that are
  /// assigned to the SFTP server you specified with the <code>ServerId</code>.
  @_s.JsonKey(name: 'UserCount')
  final int userCount;

  ListedServer({
    @_s.required this.arn,
    this.endpointType,
    this.identityProviderType,
    this.loggingRole,
    this.serverId,
    this.state,
    this.userCount,
  });
  factory ListedServer.fromJson(Map<String, dynamic> json) =>
      _$ListedServerFromJson(json);
}

/// Returns properties of the user that you specify.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListedUser {
  /// This property is the unique Amazon Resource Name (ARN) for the user that you
  /// want to learn about.
  @_s.JsonKey(name: 'Arn')
  final String arn;

  /// This value specifies the location that files are written to or read from an
  /// Amazon S3 bucket for the user you specify by their ARN.
  @_s.JsonKey(name: 'HomeDirectory')
  final String homeDirectory;

  /// The type of landing directory (folder) you mapped for your users' home
  /// directory. If you set it to <code>PATH</code>, the user will see the
  /// absolute Amazon S3 bucket paths as is in their SFTP clients. If you set it
  /// <code>LOGICAL</code>, you will need to provide mappings in the
  /// <code>HomeDirectoryMappings</code> for how you want to make S3 paths visible
  /// to your user.
  @_s.JsonKey(name: 'HomeDirectoryType')
  final HomeDirectoryType homeDirectoryType;

  /// The role in use by this user. A <i>role</i> is an AWS Identity and Access
  /// Management (IAM) entity that, in this case, allows the SFTP server to act on
  /// a user's behalf. It allows the server to inherit the trust relationship that
  /// enables that user to perform file operations to their Amazon S3 bucket.
  @_s.JsonKey(name: 'Role')
  final String role;

  /// This value is the number of SSH public keys stored for the user you
  /// specified.
  @_s.JsonKey(name: 'SshPublicKeyCount')
  final int sshPublicKeyCount;

  /// The name of the user whose ARN was specified. User names are used for
  /// authentication purposes.
  @_s.JsonKey(name: 'UserName')
  final String userName;

  ListedUser({
    @_s.required this.arn,
    this.homeDirectory,
    this.homeDirectoryType,
    this.role,
    this.sshPublicKeyCount,
    this.userName,
  });
  factory ListedUser.fromJson(Map<String, dynamic> json) =>
      _$ListedUserFromJson(json);
}

/// Provides information about the public Secure Shell (SSH) key that is
/// associated with a user account for a specific server (as identified by
/// <code>ServerId</code>). The information returned includes the date the key
/// was imported, the public key contents, and the public key ID. A user can
/// store more than one SSH public key associated with their user name on a
/// specific SFTP server.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class SshPublicKey {
  /// The date that the public key was added to the user account.
  @_s.JsonKey(name: 'DateImported', fromJson: unixFromJson, toJson: unixToJson)
  final DateTime dateImported;

  /// The content of the SSH public key as specified by the
  /// <code>PublicKeyId</code>.
  @_s.JsonKey(name: 'SshPublicKeyBody')
  final String sshPublicKeyBody;

  /// The <code>SshPublicKeyId</code> parameter contains the identifier of the
  /// public key.
  @_s.JsonKey(name: 'SshPublicKeyId')
  final String sshPublicKeyId;

  SshPublicKey({
    @_s.required this.dateImported,
    @_s.required this.sshPublicKeyBody,
    @_s.required this.sshPublicKeyId,
  });
  factory SshPublicKey.fromJson(Map<String, dynamic> json) =>
      _$SshPublicKeyFromJson(json);
}

/// Describes the condition of the SFTP server with respect to its ability to
/// perform file operations. There are six possible states:
/// <code>OFFLINE</code>, <code>ONLINE</code>, <code>STARTING</code>,
/// <code>STOPPING</code>, <code>START_FAILED</code>, and
/// <code>STOP_FAILED</code>.
///
/// <code>OFFLINE</code> indicates that the SFTP server exists, but that it is
/// not available for file operations. <code>ONLINE</code> indicates that the
/// SFTP server is available to perform file operations. <code>STARTING</code>
/// indicates that the SFTP server's was instantiated, but the server is not yet
/// available to perform file operations. Under normal conditions, it can take a
/// couple of minutes for an SFTP server to be completely operational. Both
/// <code>START_FAILED</code> and <code>STOP_FAILED</code> are error conditions.
enum State {
  @_s.JsonValue('OFFLINE')
  offline,
  @_s.JsonValue('ONLINE')
  online,
  @_s.JsonValue('STARTING')
  starting,
  @_s.JsonValue('STOPPING')
  stopping,
  @_s.JsonValue('START_FAILED')
  startFailed,
  @_s.JsonValue('STOP_FAILED')
  stopFailed,
}

/// Creates a key-value pair for a specific resource. Tags are metadata that you
/// can use to search for and group a resource for various purposes. You can
/// apply tags to servers, users, and roles. A tag key can take more than one
/// value. For example, to group servers for accounting purposes, you might
/// create a tag called <code>Group</code> and assign the values
/// <code>Research</code> and <code>Accounting</code> to that group.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: true)
class Tag {
  /// The name assigned to the tag that you create.
  @_s.JsonKey(name: 'Key')
  final String key;

  /// This property contains one or more values that you assigned to the key name
  /// you create.
  @_s.JsonKey(name: 'Value')
  final String value;

  Tag({
    @_s.required this.key,
    @_s.required this.value,
  });
  factory Tag.fromJson(Map<String, dynamic> json) => _$TagFromJson(json);

  Map<String, dynamic> toJson() => _$TagToJson(this);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class TestIdentityProviderResponse {
  /// The HTTP status code that is the response from your API Gateway.
  @_s.JsonKey(name: 'StatusCode')
  final int statusCode;

  /// The endpoint of the service used to authenticate a user.
  @_s.JsonKey(name: 'Url')
  final String url;

  /// A message that indicates whether the test was successful or not.
  @_s.JsonKey(name: 'Message')
  final String message;

  /// The response that is returned from your API Gateway.
  @_s.JsonKey(name: 'Response')
  final String response;

  TestIdentityProviderResponse({
    @_s.required this.statusCode,
    @_s.required this.url,
    this.message,
    this.response,
  });
  factory TestIdentityProviderResponse.fromJson(Map<String, dynamic> json) =>
      _$TestIdentityProviderResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class UpdateServerResponse {
  /// A system-assigned unique identifier for an SFTP server that the user account
  /// is assigned to.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  UpdateServerResponse({
    @_s.required this.serverId,
  });
  factory UpdateServerResponse.fromJson(Map<String, dynamic> json) =>
      _$UpdateServerResponseFromJson(json);
}

/// <code>UpdateUserResponse</code> returns the user name and server identifier
/// for the request to update a user's properties.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class UpdateUserResponse {
  /// A system-assigned unique identifier for an SFTP server instance that the
  /// user account is assigned to.
  @_s.JsonKey(name: 'ServerId')
  final String serverId;

  /// The unique identifier for a user that is assigned to the SFTP server
  /// instance that was specified in the request.
  @_s.JsonKey(name: 'UserName')
  final String userName;

  UpdateUserResponse({
    @_s.required this.serverId,
    @_s.required this.userName,
  });
  factory UpdateUserResponse.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserResponseFromJson(json);
}

class ConflictException extends _s.GenericAwsException {
  ConflictException({String type, String message})
      : super(type: type, code: 'ConflictException', message: message);
}

class InternalServiceError extends _s.GenericAwsException {
  InternalServiceError({String type, String message})
      : super(type: type, code: 'InternalServiceError', message: message);
}

class InvalidNextTokenException extends _s.GenericAwsException {
  InvalidNextTokenException({String type, String message})
      : super(type: type, code: 'InvalidNextTokenException', message: message);
}

class InvalidRequestException extends _s.GenericAwsException {
  InvalidRequestException({String type, String message})
      : super(type: type, code: 'InvalidRequestException', message: message);
}

class ResourceExistsException extends _s.GenericAwsException {
  ResourceExistsException({String type, String message})
      : super(type: type, code: 'ResourceExistsException', message: message);
}

class ResourceNotFoundException extends _s.GenericAwsException {
  ResourceNotFoundException({String type, String message})
      : super(type: type, code: 'ResourceNotFoundException', message: message);
}

class ServiceUnavailableException extends _s.GenericAwsException {
  ServiceUnavailableException({String type, String message})
      : super(
            type: type, code: 'ServiceUnavailableException', message: message);
}

class ThrottlingException extends _s.GenericAwsException {
  ThrottlingException({String type, String message})
      : super(type: type, code: 'ThrottlingException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'ConflictException': (type, message) =>
      ConflictException(type: type, message: message),
  'InternalServiceError': (type, message) =>
      InternalServiceError(type: type, message: message),
  'InvalidNextTokenException': (type, message) =>
      InvalidNextTokenException(type: type, message: message),
  'InvalidRequestException': (type, message) =>
      InvalidRequestException(type: type, message: message),
  'ResourceExistsException': (type, message) =>
      ResourceExistsException(type: type, message: message),
  'ResourceNotFoundException': (type, message) =>
      ResourceNotFoundException(type: type, message: message),
  'ServiceUnavailableException': (type, message) =>
      ServiceUnavailableException(type: type, message: message),
  'ThrottlingException': (type, message) =>
      ThrottlingException(type: type, message: message),
};
