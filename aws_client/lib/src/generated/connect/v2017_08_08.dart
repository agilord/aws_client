// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        nonNullableTimeStampFromJson,
        timeStampFromJson;

export '../../shared/shared.dart' show AwsClientCredentials;

/// Amazon Connect is a cloud-based contact center solution that you use to set
/// up and manage a customer contact center and provide reliable customer
/// engagement at any scale.
///
/// Amazon Connect provides metrics and real-time reporting that enable you to
/// optimize contact routing. You can also resolve customer issues more
/// efficiently by getting customers in touch with the appropriate agents.
///
/// There are limits to the number of Amazon Connect resources that you can
/// create. There are also limits to the number of requests that you can make
/// per second. For more information, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon
/// Connect Service Quotas</a> in the <i>Amazon Connect Administrator Guide</i>.
///
/// You can connect programmatically to an Amazon Web Services service by using
/// an endpoint. For a list of Amazon Connect endpoints, see <a
/// href="https://docs.aws.amazon.com/general/latest/gr/connect_region.html">Amazon
/// Connect Endpoints</a>.
class Connect {
  final _s.RestJsonProtocol _protocol;
  Connect({
    required String region,
    _s.AwsClientCredentials? credentials,
    _s.AwsClientCredentialsProvider? credentialsProvider,
    _s.Client? client,
    String? endpointUrl,
  }) : _protocol = _s.RestJsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'connect',
            signingName: 'connect',
          ),
          region: region,
          credentials: credentials,
          credentialsProvider: credentialsProvider,
          endpointUrl: endpointUrl,
        );

  /// Closes the internal HTTP client if none was provided at creation.
  /// If a client was passed as a constructor argument, this becomes a noop.
  ///
  /// It's important to close all clients when it's done being used; failing to
  /// do so can cause the Dart process to hang.
  void close() {
    _protocol.close();
  }

  /// Activates an evaluation form in the specified Amazon Connect instance.
  /// After the evaluation form is activated, it is available to start new
  /// evaluations based on the form.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationFormId] :
  /// The unique identifier for the evaluation form.
  ///
  /// Parameter [evaluationFormVersion] :
  /// The version of the evaluation form to activate. If the version property is
  /// not provided, the latest version of the evaluation form is activated.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<ActivateEvaluationFormResponse> activateEvaluationForm({
    required String evaluationFormId,
    required int evaluationFormVersion,
    required String instanceId,
  }) async {
    _s.validateNumRange(
      'evaluationFormVersion',
      evaluationFormVersion,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'EvaluationFormVersion': evaluationFormVersion,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/evaluation-forms/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationFormId)}/activate',
      exceptionFnMap: _exceptionFns,
    );
    return ActivateEvaluationFormResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Associates the specified dataset for a Amazon Connect instance with the
  /// target account. You can associate only one dataset in a single call.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [dataSetId] :
  /// The identifier of the dataset to associate with the target account.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [targetAccountId] :
  /// The identifier of the target account. Use to associate a dataset to a
  /// different account than the one containing the Amazon Connect instance. If
  /// not specified, by default this value is the Amazon Web Services account
  /// that has the Amazon Connect instance.
  Future<AssociateAnalyticsDataSetResponse> associateAnalyticsDataSet({
    required String dataSetId,
    required String instanceId,
    String? targetAccountId,
  }) async {
    final $payload = <String, dynamic>{
      'DataSetId': dataSetId,
      if (targetAccountId != null) 'TargetAccountId': targetAccountId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/analytics-data/instance/${Uri.encodeComponent(instanceId)}/association',
      exceptionFnMap: _exceptionFns,
    );
    return AssociateAnalyticsDataSetResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Associates an approved origin to an Amazon Connect instance.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [origin] :
  /// The domain to add to your allow list.
  Future<void> associateApprovedOrigin({
    required String instanceId,
    required String origin,
  }) async {
    final $payload = <String, dynamic>{
      'Origin': origin,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/approved-origin',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Allows the specified Amazon Connect instance to access the specified
  /// Amazon Lex or Amazon Lex V2 bot.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [LimitExceededException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [lexV2Bot] :
  /// The Amazon Lex V2 bot to associate with the instance.
  Future<void> associateBot({
    required String instanceId,
    LexBot? lexBot,
    LexV2Bot? lexV2Bot,
  }) async {
    final $payload = <String, dynamic>{
      if (lexBot != null) 'LexBot': lexBot,
      if (lexV2Bot != null) 'LexV2Bot': lexV2Bot,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/bot',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Associates an existing vocabulary as the default. Contact Lens for Amazon
  /// Connect uses the vocabulary in post-call and real-time analysis sessions
  /// for the given language.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [languageCode] :
  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  ///
  /// Parameter [vocabularyId] :
  /// The identifier of the custom vocabulary. If this is empty, the default is
  /// set to none.
  Future<void> associateDefaultVocabulary({
    required String instanceId,
    required VocabularyLanguageCode languageCode,
    String? vocabularyId,
  }) async {
    final $payload = <String, dynamic>{
      if (vocabularyId != null) 'VocabularyId': vocabularyId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/default-vocabulary/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(languageCode.value)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Associates a connect resource to a flow.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [flowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceId] :
  /// The identifier of the resource.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<void> associateFlow({
    required String flowId,
    required String instanceId,
    required String resourceId,
    required FlowAssociationResourceType resourceType,
  }) async {
    final $payload = <String, dynamic>{
      'FlowId': flowId,
      'ResourceId': resourceId,
      'ResourceType': resourceType.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/flow-associations/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Associates a storage resource type for the first time. You can only
  /// associate one type of storage configuration in a single call. This means,
  /// for example, that you can't define an instance with multiple S3 buckets
  /// for storing chat transcripts.
  ///
  /// This API does not create a resource that doesn't exist. It only associates
  /// it to the instance. Ensure that the resource being specified in the
  /// storage configuration, like an S3 bucket, exists when being used for
  /// association.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type. To <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/enable-contact-analysis-segment-streams.html">enable
  /// streaming for real-time analysis of contacts</a>, use the following types:
  ///
  /// <ul>
  /// <li>
  /// For chat contacts, use
  /// <code>REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS</code>.
  /// </li>
  /// <li>
  /// For voice contacts, use
  /// <code>REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS</code>.
  /// </li>
  /// </ul> <note>
  /// <code>REAL_TIME_CONTACT_ANALYSIS_SEGMENTS</code> is deprecated, but it is
  /// still supported and will apply only to VOICE channel contacts. Use
  /// <code>REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS</code> for voice contacts
  /// moving forward.
  ///
  /// If you have previously associated a stream with
  /// <code>REAL_TIME_CONTACT_ANALYSIS_SEGMENTS</code>, no action is needed to
  /// update the stream to
  /// <code>REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS</code>.
  /// </note>
  ///
  /// Parameter [storageConfig] :
  /// A valid storage type.
  Future<AssociateInstanceStorageConfigResponse>
      associateInstanceStorageConfig({
    required String instanceId,
    required InstanceStorageResourceType resourceType,
    required InstanceStorageConfig storageConfig,
  }) async {
    final $payload = <String, dynamic>{
      'ResourceType': resourceType.value,
      'StorageConfig': storageConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/storage-config',
      exceptionFnMap: _exceptionFns,
    );
    return AssociateInstanceStorageConfigResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Allows the specified Amazon Connect instance to access the specified
  /// Lambda function.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [functionArn] :
  /// The Amazon Resource Name (ARN) for the Lambda function being associated.
  /// Maximum number of characters allowed is 140.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> associateLambdaFunction({
    required String functionArn,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'FunctionArn': functionArn,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/lambda-function',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Allows the specified Amazon Connect instance to access the specified
  /// Amazon Lex V1 bot. This API only supports the association of Amazon Lex V1
  /// bots.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [lexBot] :
  /// The Amazon Lex bot to associate with the instance.
  Future<void> associateLexBot({
    required String instanceId,
    required LexBot lexBot,
  }) async {
    final $payload = <String, dynamic>{
      'LexBot': lexBot,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/lex-bot',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Associates a flow with a phone number claimed to your Amazon Connect
  /// instance.
  /// <important>
  /// If the number is claimed to a traffic distribution group, and you are
  /// calling this API using an instance in the Amazon Web Services Region where
  /// the traffic distribution group was created, you can use either a full
  /// phone number ARN or UUID value for the <code>PhoneNumberId</code> URI
  /// request parameter. However, if the number is claimed to a traffic
  /// distribution group and you are calling this API using an instance in the
  /// alternate Amazon Web Services Region associated with the traffic
  /// distribution group, you must provide a full phone number ARN. If a UUID is
  /// provided in this scenario, you will receive a
  /// <code>ResourceNotFoundException</code>.
  /// </important>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [phoneNumberId] :
  /// A unique identifier for the phone number.
  Future<void> associatePhoneNumberContactFlow({
    required String contactFlowId,
    required String instanceId,
    required String phoneNumberId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactFlowId': contactFlowId,
      'InstanceId': instanceId,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/phone-number/${Uri.encodeComponent(phoneNumberId)}/contact-flow',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Associates a set of quick connects with a queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [quickConnectIds] :
  /// The quick connects to associate with this queue.
  Future<void> associateQueueQuickConnects({
    required String instanceId,
    required String queueId,
    required List<String> quickConnectIds,
  }) async {
    final $payload = <String, dynamic>{
      'QuickConnectIds': quickConnectIds,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/associate-quick-connects',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Associates a set of queues with a routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueConfigs] :
  /// The queues to associate with this routing profile.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> associateRoutingProfileQueues({
    required String instanceId,
    required List<RoutingProfileQueueConfig> queueConfigs,
    required String routingProfileId,
  }) async {
    final $payload = <String, dynamic>{
      'QueueConfigs': queueConfigs,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/associate-queues',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Associates a security key to the instance.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [key] :
  /// A valid security key in PEM format.
  Future<AssociateSecurityKeyResponse> associateSecurityKey({
    required String instanceId,
    required String key,
  }) async {
    final $payload = <String, dynamic>{
      'Key': key,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/security-key',
      exceptionFnMap: _exceptionFns,
    );
    return AssociateSecurityKeyResponse.fromJson(response);
  }

  /// Associates an agent with a traffic distribution group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [trafficDistributionGroupId] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account. This can be the ID or the ARN of the
  /// user.
  Future<void> associateTrafficDistributionGroupUser({
    required String instanceId,
    required String trafficDistributionGroupId,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      'UserId': userId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/traffic-distribution-group/${Uri.encodeComponent(trafficDistributionGroupId)}/user',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// &gt;Associates a set of proficiencies with a user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN of the instance).
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  ///
  /// Parameter [userProficiencies] :
  /// The proficiencies to associate with the user.
  Future<void> associateUserProficiencies({
    required String instanceId,
    required String userId,
    required List<UserProficiency> userProficiencies,
  }) async {
    final $payload = <String, dynamic>{
      'UserProficiencies': userProficiencies,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/associate-proficiencies',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Associates a list of analytics datasets for a given Amazon Connect
  /// instance to a target account. You can associate multiple datasets in a
  /// single call.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [dataSetIds] :
  /// An array of dataset identifiers to associate.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [targetAccountId] :
  /// The identifier of the target account. Use to associate a dataset to a
  /// different account than the one containing the Amazon Connect instance. If
  /// not specified, by default this value is the Amazon Web Services account
  /// that has the Amazon Connect instance.
  Future<BatchAssociateAnalyticsDataSetResponse>
      batchAssociateAnalyticsDataSet({
    required List<String> dataSetIds,
    required String instanceId,
    String? targetAccountId,
  }) async {
    final $payload = <String, dynamic>{
      'DataSetIds': dataSetIds,
      if (targetAccountId != null) 'TargetAccountId': targetAccountId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/analytics-data/instance/${Uri.encodeComponent(instanceId)}/associations',
      exceptionFnMap: _exceptionFns,
    );
    return BatchAssociateAnalyticsDataSetResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Removes a list of analytics datasets associated with a given Amazon
  /// Connect instance. You can disassociate multiple datasets in a single call.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [dataSetIds] :
  /// An array of associated dataset identifiers to remove.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [targetAccountId] :
  /// The identifier of the target account. Use to disassociate a dataset from a
  /// different account than the one containing the Amazon Connect instance. If
  /// not specified, by default this value is the Amazon Web Services account
  /// that has the Amazon Connect instance.
  Future<BatchDisassociateAnalyticsDataSetResponse>
      batchDisassociateAnalyticsDataSet({
    required List<String> dataSetIds,
    required String instanceId,
    String? targetAccountId,
  }) async {
    final $payload = <String, dynamic>{
      'DataSetIds': dataSetIds,
      if (targetAccountId != null) 'TargetAccountId': targetAccountId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/analytics-data/instance/${Uri.encodeComponent(instanceId)}/associations',
      exceptionFnMap: _exceptionFns,
    );
    return BatchDisassociateAnalyticsDataSetResponse.fromJson(response);
  }

  /// Allows you to retrieve metadata about multiple attached files on an
  /// associated resource. Each attached file provided in the input list must be
  /// associated with the input AssociatedResourceArn.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associatedResourceArn] :
  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  /// <note>
  /// This value must be a valid ARN.
  /// </note>
  ///
  /// Parameter [fileIds] :
  /// The unique identifiers of the attached file resource.
  ///
  /// Parameter [instanceId] :
  /// The unique identifier of the Connect instance.
  Future<BatchGetAttachedFileMetadataResponse> batchGetAttachedFileMetadata({
    required String associatedResourceArn,
    required List<String> fileIds,
    required String instanceId,
  }) async {
    final $query = <String, List<String>>{
      'associatedResourceArn': [associatedResourceArn],
    };
    final $payload = <String, dynamic>{
      'FileIds': fileIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/attached-files/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return BatchGetAttachedFileMetadataResponse.fromJson(response);
  }

  /// Retrieve the flow associations for the given resources.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceIds] :
  /// A list of resource identifiers to retrieve flow associations.
  ///
  /// Parameter [resourceType] :
  /// The type of resource association.
  Future<BatchGetFlowAssociationResponse> batchGetFlowAssociation({
    required String instanceId,
    required List<String> resourceIds,
    ListFlowAssociationResourceType? resourceType,
  }) async {
    final $payload = <String, dynamic>{
      'ResourceIds': resourceIds,
      if (resourceType != null) 'ResourceType': resourceType.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/flow-associations-batch/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return BatchGetFlowAssociationResponse.fromJson(response);
  }

  /// <note>
  /// Only the Amazon Connect outbound campaigns service principal is allowed to
  /// assume a role in your account and call this API.
  /// </note>
  /// Allows you to create a batch of contacts in Amazon Connect. The outbound
  /// campaigns capability ingests dial requests via the <a
  /// href="https://docs.aws.amazon.com/connect-outbound/latest/APIReference/API_PutDialRequestBatch.html">PutDialRequestBatch</a>
  /// API. It then uses BatchPutContact to create contacts corresponding to
  /// those dial requests. If agents are available, the dial requests are dialed
  /// out, which results in a voice call. The resulting voice call uses the same
  /// contactId that was created by BatchPutContact.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [IdempotencyException].
  ///
  /// Parameter [contactDataRequestList] :
  /// List of individual contact requests.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<BatchPutContactResponse> batchPutContact({
    required List<ContactDataRequest> contactDataRequestList,
    required String instanceId,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'ContactDataRequestList': contactDataRequestList,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact/batch/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return BatchPutContactResponse.fromJson(response);
  }

  /// Claims an available phone number to your Amazon Connect instance or
  /// traffic distribution group. You can call this API only in the same Amazon
  /// Web Services Region where the Amazon Connect instance or traffic
  /// distribution group was created.
  ///
  /// For more information about how to use this operation, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/claim-phone-number.html">Claim
  /// a phone number in your country</a> and <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/claim-phone-numbers-traffic-distribution-groups.html">Claim
  /// phone numbers to traffic distribution groups</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  /// <important>
  /// You can call the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_SearchAvailablePhoneNumbers.html">SearchAvailablePhoneNumbers</a>
  /// API for available phone numbers that you can claim. Call the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a>
  /// API to verify the status of a previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>
  /// operation.
  /// </important>
  /// If you plan to claim and release numbers frequently, contact us for a
  /// service quota exception. Otherwise, it is possible you will be blocked
  /// from claiming and releasing any more numbers until up to 180 days past the
  /// oldest number released has expired.
  ///
  /// By default you can claim and release up to 200% of your maximum number of
  /// active phone numbers. If you claim and release phone numbers using the UI
  /// or API during a rolling 180 day cycle that exceeds 200% of your phone
  /// number service level quota, you will be blocked from claiming any more
  /// numbers until 180 days past the oldest number released has expired.
  ///
  /// For example, if you already have 99 claimed numbers and a service level
  /// quota of 99 phone numbers, and in any 180 day period you release 99, claim
  /// 99, and then release 99, you will have exceeded the 200% limit. At that
  /// point you are blocked from claiming any more numbers until you open an
  /// Amazon Web Services support ticket.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [IdempotencyException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [phoneNumber] :
  /// The phone number you want to claim. Phone numbers are formatted <code>[+]
  /// [country code] [subscriber number including area code]</code>.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Pattern:
  /// <code>^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$</code>
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance that phone numbers are
  /// claimed to. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance. You
  /// must enter <code>InstanceId</code> or <code>TargetArn</code>.
  ///
  /// Parameter [phoneNumberDescription] :
  /// The description of the phone number.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  ///
  /// Parameter [targetArn] :
  /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic
  /// distribution groups that phone number inbound traffic is routed through.
  /// You must enter <code>InstanceId</code> or <code>TargetArn</code>.
  Future<ClaimPhoneNumberResponse> claimPhoneNumber({
    required String phoneNumber,
    String? clientToken,
    String? instanceId,
    String? phoneNumberDescription,
    Map<String, String>? tags,
    String? targetArn,
  }) async {
    final $payload = <String, dynamic>{
      'PhoneNumber': phoneNumber,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (instanceId != null) 'InstanceId': instanceId,
      if (phoneNumberDescription != null)
        'PhoneNumberDescription': phoneNumberDescription,
      if (tags != null) 'Tags': tags,
      if (targetArn != null) 'TargetArn': targetArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/phone-number/claim',
      exceptionFnMap: _exceptionFns,
    );
    return ClaimPhoneNumberResponse.fromJson(response);
  }

  /// Allows you to confirm that the attached file has been uploaded using the
  /// pre-signed URL provided in the StartAttachedFileUpload API.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associatedResourceArn] :
  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  /// <note>
  /// This value must be a valid ARN.
  /// </note>
  ///
  /// Parameter [fileId] :
  /// The unique identifier of the attached file resource.
  ///
  /// Parameter [instanceId] :
  /// The unique identifier of the Connect instance.
  Future<void> completeAttachedFileUpload({
    required String associatedResourceArn,
    required String fileId,
    required String instanceId,
  }) async {
    final $query = <String, List<String>>{
      'associatedResourceArn': [associatedResourceArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri:
          '/attached-files/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(fileId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Creates an agent status for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the status.
  ///
  /// Parameter [state] :
  /// The state of the status.
  ///
  /// Parameter [description] :
  /// The description of the status.
  ///
  /// Parameter [displayOrder] :
  /// The display order of the status.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateAgentStatusResponse> createAgentStatus({
    required String instanceId,
    required String name,
    required AgentStatusState state,
    String? description,
    int? displayOrder,
    Map<String, String>? tags,
  }) async {
    _s.validateNumRange(
      'displayOrder',
      displayOrder,
      1,
      50,
    );
    final $payload = <String, dynamic>{
      'Name': name,
      'State': state.value,
      if (description != null) 'Description': description,
      if (displayOrder != null) 'DisplayOrder': displayOrder,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/agent-status/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateAgentStatusResponse.fromJson(response);
  }

  /// Creates a flow for the specified Amazon Connect instance.
  ///
  /// You can also create and update flows using the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon
  /// Connect Flow language</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidContactFlowException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [content] :
  /// The JSON string that represents the content of the flow. For an example,
  /// see <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example
  /// flow in Amazon Connect Flow language</a>.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256000.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance.
  ///
  /// Parameter [name] :
  /// The name of the flow.
  ///
  /// Parameter [type] :
  /// The type of the flow. For descriptions of the available types, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose
  /// a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// Parameter [description] :
  /// The description of the flow.
  ///
  /// Parameter [status] :
  /// Indicates the flow status as either <code>SAVED</code> or
  /// <code>PUBLISHED</code>. The <code>PUBLISHED</code> status will initiate
  /// validation on the content. the <code>SAVED</code> status does not initiate
  /// validation of the content. <code>SAVED</code> | <code>PUBLISHED</code>.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateContactFlowResponse> createContactFlow({
    required String content,
    required String instanceId,
    required String name,
    required ContactFlowType type,
    String? description,
    ContactFlowStatus? status,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
      'Name': name,
      'Type': type.value,
      if (description != null) 'Description': description,
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact-flows/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateContactFlowResponse.fromJson(response);
  }

  /// Creates a flow module for the specified Amazon Connect instance.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidContactFlowModuleException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [IdempotencyException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [content] :
  /// The JSON string that represents the content of the flow. For an example,
  /// see <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example
  /// flow in Amazon Connect Flow language</a>.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the flow module.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [description] :
  /// The description of the flow module.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateContactFlowModuleResponse> createContactFlowModule({
    required String content,
    required String instanceId,
    required String name,
    String? clientToken,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
      'Name': name,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact-flow-modules/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateContactFlowModuleResponse.fromJson(response);
  }

  /// Creates an evaluation form in the specified Amazon Connect instance. The
  /// form can be used to define questions related to agent performance, and
  /// create sections to organize such questions. Question and section
  /// identifiers cannot be duplicated within the same evaluation form.
  ///
  /// May throw [InternalServiceException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [items] :
  /// Items that are part of the evaluation form. The total number of sections
  /// and questions must not exceed 100 each. Questions must be contained in a
  /// section.
  ///
  /// Parameter [title] :
  /// A title of the evaluation form.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [description] :
  /// The description of the evaluation form.
  ///
  /// Parameter [scoringStrategy] :
  /// A scoring strategy of the evaluation form.
  Future<CreateEvaluationFormResponse> createEvaluationForm({
    required String instanceId,
    required List<EvaluationFormItem> items,
    required String title,
    String? clientToken,
    String? description,
    EvaluationFormScoringStrategy? scoringStrategy,
  }) async {
    final $payload = <String, dynamic>{
      'Items': items,
      'Title': title,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (description != null) 'Description': description,
      if (scoringStrategy != null) 'ScoringStrategy': scoringStrategy,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/evaluation-forms/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateEvaluationFormResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Creates hours of operation.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [config] :
  /// Configuration information for the hours of operation: day, start time, and
  /// end time.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the hours of operation.
  ///
  /// Parameter [timeZone] :
  /// The time zone of the hours of operation.
  ///
  /// Parameter [description] :
  /// The description of the hours of operation.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateHoursOfOperationResponse> createHoursOfOperation({
    required List<HoursOfOperationConfig> config,
    required String instanceId,
    required String name,
    required String timeZone,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Config': config,
      'Name': name,
      'TimeZone': timeZone,
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/hours-of-operations/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateHoursOfOperationResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Initiates an Amazon Connect instance with all the supported channels
  /// enabled. It does not attach any storage, such as Amazon Simple Storage
  /// Service (Amazon S3) or Amazon Kinesis. It also does not allow for any
  /// configurations on features, such as Contact Lens for Amazon Connect.
  ///
  /// Amazon Connect enforces a limit on the total number of instances that you
  /// can create or delete in 30 days. If you exceed this limit, you will get an
  /// error message indicating there has been an excessive number of attempts at
  /// creating or deleting instances. You must wait 30 days before you can
  /// restart creating and deleting instances in your account.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [identityManagementType] :
  /// The type of identity management for your Amazon Connect users.
  ///
  /// Parameter [inboundCallsEnabled] :
  /// Your contact center handles incoming contacts.
  ///
  /// Parameter [outboundCallsEnabled] :
  /// Your contact center allows outbound calls.
  ///
  /// Parameter [clientToken] :
  /// The idempotency token.
  ///
  /// Parameter [directoryId] :
  /// The identifier for the directory.
  ///
  /// Parameter [instanceAlias] :
  /// The name for your instance.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, <code>{ "tags": {"key1":"value1", "key2":"value2"} }</code>.
  Future<CreateInstanceResponse> createInstance({
    required DirectoryType identityManagementType,
    required bool inboundCallsEnabled,
    required bool outboundCallsEnabled,
    String? clientToken,
    String? directoryId,
    String? instanceAlias,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'IdentityManagementType': identityManagementType.value,
      'InboundCallsEnabled': inboundCallsEnabled,
      'OutboundCallsEnabled': outboundCallsEnabled,
      if (clientToken != null) 'ClientToken': clientToken,
      if (directoryId != null) 'DirectoryId': directoryId,
      if (instanceAlias != null) 'InstanceAlias': instanceAlias,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/instance',
      exceptionFnMap: _exceptionFns,
    );
    return CreateInstanceResponse.fromJson(response);
  }

  /// Creates an Amazon Web Services resource association with an Amazon Connect
  /// instance.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [integrationArn] :
  /// The Amazon Resource Name (ARN) of the integration.
  /// <note>
  /// When integrating with Amazon Pinpoint, the Amazon Connect and Amazon
  /// Pinpoint instances must be in the same account.
  /// </note>
  ///
  /// Parameter [integrationType] :
  /// The type of information to be ingested.
  ///
  /// Parameter [sourceApplicationName] :
  /// The name of the external application. This field is only required for the
  /// EVENT integration type.
  ///
  /// Parameter [sourceApplicationUrl] :
  /// The URL for the external application. This field is only required for the
  /// EVENT integration type.
  ///
  /// Parameter [sourceType] :
  /// The type of the data source. This field is only required for the EVENT
  /// integration type.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateIntegrationAssociationResponse> createIntegrationAssociation({
    required String instanceId,
    required String integrationArn,
    required IntegrationType integrationType,
    String? sourceApplicationName,
    String? sourceApplicationUrl,
    SourceType? sourceType,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'IntegrationArn': integrationArn,
      'IntegrationType': integrationType.value,
      if (sourceApplicationName != null)
        'SourceApplicationName': sourceApplicationName,
      if (sourceApplicationUrl != null)
        'SourceApplicationUrl': sourceApplicationUrl,
      if (sourceType != null) 'SourceType': sourceType.value,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/integration-associations',
      exceptionFnMap: _exceptionFns,
    );
    return CreateIntegrationAssociationResponse.fromJson(response);
  }

  /// Adds a new participant into an on-going chat contact. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-customize-flow.html">Customize
  /// chat flow experiences by integrating custom participants</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect. Only
  /// contacts in the CHAT channel are supported.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [participantDetails] :
  /// Information identifying the participant.
  /// <important>
  /// The only Valid value for <code>ParticipantRole</code> is
  /// <code>CUSTOM_BOT</code>.
  ///
  /// <code>DisplayName</code> is <b>Required</b>.
  /// </important>
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<CreateParticipantResponse> createParticipant({
    required String contactId,
    required String instanceId,
    required ParticipantDetailsToAdd participantDetails,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      'ParticipantDetails': participantDetails,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/create-participant',
      exceptionFnMap: _exceptionFns,
    );
    return CreateParticipantResponse.fromJson(response);
  }

  /// Enables rehydration of chats for the lifespan of a contact. For more
  /// information about chat rehydration, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable
  /// persistent chat</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [initialContactId] :
  /// This is the contactId of the current contact that the
  /// <code>CreatePersistentContactAssociation</code> API is being called from.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [rehydrationType] :
  /// The contactId chosen for rehydration depends on the type chosen.
  ///
  /// <ul>
  /// <li>
  /// <code>ENTIRE_PAST_SESSION</code>: Rehydrates a chat from the most recently
  /// terminated past chat contact of the specified past ended chat session. To
  /// use this type, provide the <code>initialContactId</code> of the past ended
  /// chat session in the <code>sourceContactId</code> field. In this type,
  /// Amazon Connect determines what the most recent chat contact on the past
  /// ended chat session and uses it to start a persistent chat.
  /// </li>
  /// <li>
  /// <code>FROM_SEGMENT</code>: Rehydrates a chat from the specified past chat
  /// contact provided in the <code>sourceContactId</code> field.
  /// </li>
  /// </ul>
  /// The actual contactId used for rehydration is provided in the response of
  /// this API.
  ///
  /// To illustrate how to use rehydration type, consider the following example:
  /// A customer starts a chat session. Agent a1 accepts the chat and a
  /// conversation starts between the customer and Agent a1. This first contact
  /// creates a contact ID <b>C1</b>. Agent a1 then transfers the chat to Agent
  /// a2. This creates another contact ID <b>C2</b>. At this point Agent a2 ends
  /// the chat. The customer is forwarded to the disconnect flow for a post chat
  /// survey that creates another contact ID <b>C3</b>. After the chat survey,
  /// the chat session ends. Later, the customer returns and wants to resume
  /// their past chat session. At this point, the customer can have following
  /// use cases:
  ///
  /// <ul>
  /// <li>
  /// <b>Use Case 1</b>: The customer wants to continue the past chat session
  /// but they want to hide the post chat survey. For this they will use the
  /// following configuration:
  ///
  /// <ul>
  /// <li>
  /// <b>Configuration</b>
  ///
  /// <ul>
  /// <li>
  /// SourceContactId = "C2"
  /// </li>
  /// <li>
  /// RehydrationType = "FROM_SEGMENT"
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <b>Expected behavior</b>
  ///
  /// <ul>
  /// <li>
  /// This starts a persistent chat session from the specified past ended
  /// contact (C2). Transcripts of past chat sessions C2 and C1 are accessible
  /// in the current persistent chat session. Note that chat segment C3 is
  /// dropped from the persistent chat session.
  /// </li>
  /// </ul> </li>
  /// </ul> </li>
  /// <li>
  /// <b>Use Case 2</b>: The customer wants to continue the past chat session
  /// and see the transcript of the entire past engagement, including the post
  /// chat survey. For this they will use the following configuration:
  ///
  /// <ul>
  /// <li>
  /// <b>Configuration</b>
  ///
  /// <ul>
  /// <li>
  /// SourceContactId = "C1"
  /// </li>
  /// <li>
  /// RehydrationType = "ENTIRE_PAST_SESSION"
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <b>Expected behavior</b>
  ///
  /// <ul>
  /// <li>
  /// This starts a persistent chat session from the most recently ended chat
  /// contact (C3). Transcripts of past chat sessions C3, C2 and C1 are
  /// accessible in the current persistent chat session.
  /// </li>
  /// </ul> </li>
  /// </ul> </li>
  /// </ul>
  ///
  /// Parameter [sourceContactId] :
  /// The contactId from which a persistent chat session must be started.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<CreatePersistentContactAssociationResponse>
      createPersistentContactAssociation({
    required String initialContactId,
    required String instanceId,
    required RehydrationType rehydrationType,
    required String sourceContactId,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'RehydrationType': rehydrationType.value,
      'SourceContactId': sourceContactId,
      if (clientToken != null) 'ClientToken': clientToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact/persistent-contact-association/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(initialContactId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreatePersistentContactAssociationResponse.fromJson(response);
  }

  /// Creates a new predefined attribute for the specified Amazon Connect
  /// instance.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the predefined attribute.
  ///
  /// Parameter [values] :
  /// The values of the predefined attribute.
  Future<void> createPredefinedAttribute({
    required String instanceId,
    required String name,
    required PredefinedAttributeValues values,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      'Values': values,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/predefined-attributes/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Creates a prompt. For more information about prompts, such as supported
  /// file types and maximum length, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/prompts.html">Create
  /// prompts</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the prompt.
  ///
  /// Parameter [s3Uri] :
  /// The URI for the S3 bucket where the prompt is stored. You can provide S3
  /// pre-signed URLs returned by the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_GetPromptFile.html">GetPromptFile</a>
  /// API instead of providing S3 URIs.
  ///
  /// Parameter [description] :
  /// The description of the prompt.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreatePromptResponse> createPrompt({
    required String instanceId,
    required String name,
    required String s3Uri,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      'S3Uri': s3Uri,
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/prompts/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreatePromptResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Creates a new queue for the specified Amazon Connect instance.
  /// <important>
  /// <ul>
  /// <li>
  /// If the phone number is claimed to a traffic distribution group that was
  /// created in the same Region as the Amazon Connect instance where you are
  /// calling this API, then you can use a full phone number ARN or a UUID for
  /// <code>OutboundCallerIdNumberId</code>. However, if the phone number is
  /// claimed to a traffic distribution group that is in one Region, and you are
  /// calling this API from an instance in another Amazon Web Services Region
  /// that is associated with the traffic distribution group, you must provide a
  /// full phone number ARN. If a UUID is provided in this scenario, you will
  /// receive a <code>ResourceNotFoundException</code>.
  /// </li>
  /// <li>
  /// Only use the phone number ARN format that doesn't contain
  /// <code>instance</code> in the path, for example,
  /// <code>arn:aws:connect:us-east-1:1234567890:phone-number/uuid</code>. This
  /// is the same ARN format that is returned when you call the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html">ListPhoneNumbersV2</a>
  /// API.
  /// </li>
  /// <li>
  /// If you plan to use IAM policies to allow/deny access to this API for phone
  /// number resources claimed to a traffic distribution group, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_resource-level-policy-examples.html#allow-deny-queue-actions-replica-region">Allow
  /// or Deny queue API actions for phone numbers in a replica Region</a>.
  /// </li>
  /// </ul> </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hoursOfOperationId] :
  /// The identifier for the hours of operation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the queue.
  ///
  /// Parameter [description] :
  /// The description of the queue.
  ///
  /// Parameter [maxContacts] :
  /// The maximum number of contacts that can be in the queue before it is
  /// considered full.
  ///
  /// Parameter [outboundCallerConfig] :
  /// The outbound caller ID name, number, and outbound whisper flow.
  ///
  /// Parameter [quickConnectIds] :
  /// The quick connects available to agents who are working the queue.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateQueueResponse> createQueue({
    required String hoursOfOperationId,
    required String instanceId,
    required String name,
    String? description,
    int? maxContacts,
    OutboundCallerConfig? outboundCallerConfig,
    List<String>? quickConnectIds,
    Map<String, String>? tags,
  }) async {
    _s.validateNumRange(
      'maxContacts',
      maxContacts,
      0,
      1152921504606846976,
    );
    final $payload = <String, dynamic>{
      'HoursOfOperationId': hoursOfOperationId,
      'Name': name,
      if (description != null) 'Description': description,
      if (maxContacts != null) 'MaxContacts': maxContacts,
      if (outboundCallerConfig != null)
        'OutboundCallerConfig': outboundCallerConfig,
      if (quickConnectIds != null) 'QuickConnectIds': quickConnectIds,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/queues/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateQueueResponse.fromJson(response);
  }

  /// Creates a quick connect for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// A unique name of the quick connect.
  ///
  /// Parameter [quickConnectConfig] :
  /// Configuration settings for the quick connect.
  ///
  /// Parameter [description] :
  /// The description of the quick connect.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateQuickConnectResponse> createQuickConnect({
    required String instanceId,
    required String name,
    required QuickConnectConfig quickConnectConfig,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      'QuickConnectConfig': quickConnectConfig,
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/quick-connects/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateQuickConnectResponse.fromJson(response);
  }

  /// Creates a new routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [defaultOutboundQueueId] :
  /// The default outbound queue for the routing profile.
  ///
  /// Parameter [description] :
  /// Description of the routing profile. Must not be more than 250 characters.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [mediaConcurrencies] :
  /// The channels that agents can handle in the Contact Control Panel (CCP) for
  /// this routing profile.
  ///
  /// Parameter [name] :
  /// The name of the routing profile. Must not be more than 127 characters.
  ///
  /// Parameter [agentAvailabilityTimer] :
  /// Whether agents with this routing profile will have their routing order
  /// calculated based on <i>longest idle time</i> or <i>time since their last
  /// inbound contact</i>.
  ///
  /// Parameter [queueConfigs] :
  /// The inbound queues associated with the routing profile. If no queue is
  /// added, the agent can make only outbound calls.
  ///
  /// The limit of 10 array members applies to the maximum number of
  /// <code>RoutingProfileQueueConfig</code> objects that can be passed during a
  /// CreateRoutingProfile API request. It is different from the quota of 50
  /// queues per routing profile per instance that is listed in <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon
  /// Connect service quotas</a>.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateRoutingProfileResponse> createRoutingProfile({
    required String defaultOutboundQueueId,
    required String description,
    required String instanceId,
    required List<MediaConcurrency> mediaConcurrencies,
    required String name,
    AgentAvailabilityTimer? agentAvailabilityTimer,
    List<RoutingProfileQueueConfig>? queueConfigs,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'DefaultOutboundQueueId': defaultOutboundQueueId,
      'Description': description,
      'MediaConcurrencies': mediaConcurrencies,
      'Name': name,
      if (agentAvailabilityTimer != null)
        'AgentAvailabilityTimer': agentAvailabilityTimer.value,
      if (queueConfigs != null) 'QueueConfigs': queueConfigs,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/routing-profiles/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateRoutingProfileResponse.fromJson(response);
  }

  /// Creates a rule for the specified Amazon Connect instance.
  ///
  /// Use the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/connect-rules-language.html">Rules
  /// Function language</a> to code conditions for the rule.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceConflictException].
  /// May throw [ServiceQuotaExceededException].
  ///
  /// Parameter [actions] :
  /// A list of actions to be run when the rule is triggered.
  ///
  /// Parameter [function] :
  /// The conditions of the rule.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// A unique name for the rule.
  ///
  /// Parameter [publishStatus] :
  /// The publish status of the rule.
  ///
  /// Parameter [triggerEventSource] :
  /// The event source to trigger the rule.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<CreateRuleResponse> createRule({
    required List<RuleAction> actions,
    required String function,
    required String instanceId,
    required String name,
    required RulePublishStatus publishStatus,
    required RuleTriggerEventSource triggerEventSource,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'Actions': actions,
      'Function': function,
      'Name': name,
      'PublishStatus': publishStatus.value,
      'TriggerEventSource': triggerEventSource,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/rules/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateRuleResponse.fromJson(response);
  }

  /// Creates a security profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [LimitExceededException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileName] :
  /// The name of the security profile.
  ///
  /// Parameter [allowedAccessControlHierarchyGroupId] :
  /// The identifier of the hierarchy group that a security profile uses to
  /// restrict access to resources in Amazon Connect.
  ///
  /// Parameter [allowedAccessControlTags] :
  /// The list of tags that a security profile uses to restrict access to
  /// resources in Amazon Connect.
  ///
  /// Parameter [applications] :
  /// A list of third-party applications that the security profile will give
  /// access to.
  ///
  /// Parameter [description] :
  /// The description of the security profile.
  ///
  /// Parameter [hierarchyRestrictedResources] :
  /// The list of resources that a security profile applies hierarchy
  /// restrictions to in Amazon Connect. Following are acceptable ResourceNames:
  /// <code>User</code>.
  ///
  /// Parameter [permissions] :
  /// Permissions assigned to the security profile. For a list of valid
  /// permissions, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List
  /// of security profile permissions</a>.
  ///
  /// Parameter [tagRestrictedResources] :
  /// The list of resources that a security profile applies tag restrictions to
  /// in Amazon Connect. Following are acceptable ResourceNames:
  /// <code>User</code> | <code>SecurityProfile</code> | <code>Queue</code> |
  /// <code>RoutingProfile</code>
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateSecurityProfileResponse> createSecurityProfile({
    required String instanceId,
    required String securityProfileName,
    String? allowedAccessControlHierarchyGroupId,
    Map<String, String>? allowedAccessControlTags,
    List<Application>? applications,
    String? description,
    List<String>? hierarchyRestrictedResources,
    List<String>? permissions,
    List<String>? tagRestrictedResources,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'SecurityProfileName': securityProfileName,
      if (allowedAccessControlHierarchyGroupId != null)
        'AllowedAccessControlHierarchyGroupId':
            allowedAccessControlHierarchyGroupId,
      if (allowedAccessControlTags != null)
        'AllowedAccessControlTags': allowedAccessControlTags,
      if (applications != null) 'Applications': applications,
      if (description != null) 'Description': description,
      if (hierarchyRestrictedResources != null)
        'HierarchyRestrictedResources': hierarchyRestrictedResources,
      if (permissions != null) 'Permissions': permissions,
      if (tagRestrictedResources != null)
        'TagRestrictedResources': tagRestrictedResources,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/security-profiles/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateSecurityProfileResponse.fromJson(response);
  }

  /// Creates a new task template in the specified Amazon Connect instance.
  ///
  /// May throw [PropertyValidationException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [fields] :
  /// Fields that are part of the template.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the task template.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [constraints] :
  /// Constraints that are applicable to the fields listed.
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow that runs by default when a task is created by
  /// referencing this template.
  ///
  /// Parameter [defaults] :
  /// The default values for fields when a task is created by referencing this
  /// template.
  ///
  /// Parameter [description] :
  /// The description of the task template.
  ///
  /// Parameter [status] :
  /// Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a
  /// task to refer to it. Tasks can only be created from <code>ACTIVE</code>
  /// templates. If a template is marked as <code>INACTIVE</code>, then a task
  /// that refers to this template cannot be created.
  Future<CreateTaskTemplateResponse> createTaskTemplate({
    required List<TaskTemplateField> fields,
    required String instanceId,
    required String name,
    String? clientToken,
    TaskTemplateConstraints? constraints,
    String? contactFlowId,
    TaskTemplateDefaults? defaults,
    String? description,
    TaskTemplateStatus? status,
  }) async {
    final $payload = <String, dynamic>{
      'Fields': fields,
      'Name': name,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (constraints != null) 'Constraints': constraints,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
      if (defaults != null) 'Defaults': defaults,
      if (description != null) 'Description': description,
      if (status != null) 'Status': status.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/task/template',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTaskTemplateResponse.fromJson(response);
  }

  /// Creates a traffic distribution group given an Amazon Connect instance that
  /// has been replicated.
  /// <note>
  /// The <code>SignInConfig</code> distribution is available only on a default
  /// <code>TrafficDistributionGroup</code> (see the <code>IsDefault</code>
  /// parameter in the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_TrafficDistributionGroup.html">TrafficDistributionGroup</a>
  /// data type). If you call <code>UpdateTrafficDistribution</code> with a
  /// modified <code>SignInConfig</code> and a non-default
  /// <code>TrafficDistributionGroup</code>, an
  /// <code>InvalidRequestException</code> is returned.
  /// </note>
  /// For more information about creating traffic distribution groups, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-traffic-distribution-groups.html">Set
  /// up traffic distribution groups</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  /// May throw [ResourceNotReadyException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance that has been replicated.
  /// You can find the <code>instanceId</code> in the ARN of the instance.
  ///
  /// Parameter [name] :
  /// The name for the traffic distribution group.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [description] :
  /// A description for the traffic distribution group.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateTrafficDistributionGroupResponse>
      createTrafficDistributionGroup({
    required String instanceId,
    required String name,
    String? clientToken,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      'Name': name,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/traffic-distribution-group',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTrafficDistributionGroupResponse.fromJson(response);
  }

  /// Creates a use case for an integration association.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [integrationAssociationId] :
  /// The identifier for the integration association.
  ///
  /// Parameter [useCaseType] :
  /// The type of use case to associate to the integration association. Each
  /// integration association can have only one of each use case type.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateUseCaseResponse> createUseCase({
    required String instanceId,
    required String integrationAssociationId,
    required UseCaseType useCaseType,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'UseCaseType': useCaseType.value,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/integration-associations/${Uri.encodeComponent(integrationAssociationId)}/use-cases',
      exceptionFnMap: _exceptionFns,
    );
    return CreateUseCaseResponse.fromJson(response);
  }

  /// Creates a user account for the specified Amazon Connect instance.
  /// <important>
  /// Certain <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UserIdentityInfo.html">UserIdentityInfo</a>
  /// parameters are required in some situations. For example,
  /// <code>Email</code> is required if you are using SAML for identity
  /// management. <code>FirstName</code> and <code>LastName</code> are required
  /// if you are using Amazon Connect or SAML for identity management.
  /// </important>
  /// For information about how to create users using the Amazon Connect admin
  /// website, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/user-management.html">Add
  /// Users</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [LimitExceededException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [phoneConfig] :
  /// The phone settings for the user.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile for the user.
  ///
  /// Parameter [securityProfileIds] :
  /// The identifier of the security profile for the user.
  ///
  /// Parameter [username] :
  /// The user name for the account. For instances not using SAML for identity
  /// management, the user name can include up to 20 characters. If you are
  /// using SAML for identity management, the user name can include up to 64
  /// characters from [a-zA-Z0-9_-.\@]+.
  ///
  /// Username can include @ only if used in an email format. For example:
  ///
  /// <ul>
  /// <li>
  /// Correct: testuser
  /// </li>
  /// <li>
  /// Correct: testuser@example.com
  /// </li>
  /// <li>
  /// Incorrect: testuser@example
  /// </li>
  /// </ul>
  ///
  /// Parameter [directoryUserId] :
  /// The identifier of the user account in the directory used for identity
  /// management. If Amazon Connect cannot access the directory, you can specify
  /// this identifier to authenticate users. If you include the identifier, we
  /// assume that Amazon Connect cannot access the directory. Otherwise, the
  /// identity information is used to authenticate users from your directory.
  ///
  /// This parameter is required if you are using an existing directory for
  /// identity management in Amazon Connect when Amazon Connect cannot access
  /// your directory to authenticate users. If you are using SAML for identity
  /// management and include this parameter, an error is returned.
  ///
  /// Parameter [hierarchyGroupId] :
  /// The identifier of the hierarchy group for the user.
  ///
  /// Parameter [identityInfo] :
  /// The information about the identity of the user.
  ///
  /// Parameter [password] :
  /// The password for the user account. A password is required if you are using
  /// Amazon Connect for identity management. Otherwise, it is an error to
  /// include a password.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateUserResponse> createUser({
    required String instanceId,
    required UserPhoneConfig phoneConfig,
    required String routingProfileId,
    required List<String> securityProfileIds,
    required String username,
    String? directoryUserId,
    String? hierarchyGroupId,
    UserIdentityInfo? identityInfo,
    String? password,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'PhoneConfig': phoneConfig,
      'RoutingProfileId': routingProfileId,
      'SecurityProfileIds': securityProfileIds,
      'Username': username,
      if (directoryUserId != null) 'DirectoryUserId': directoryUserId,
      if (hierarchyGroupId != null) 'HierarchyGroupId': hierarchyGroupId,
      if (identityInfo != null) 'IdentityInfo': identityInfo,
      if (password != null) 'Password': password,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/users/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateUserResponse.fromJson(response);
  }

  /// Creates a new user hierarchy group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the user hierarchy group. Must not be more than 100
  /// characters.
  ///
  /// Parameter [parentGroupId] :
  /// The identifier for the parent hierarchy group. The user hierarchy is
  /// created at level one if the parent group ID is null.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateUserHierarchyGroupResponse> createUserHierarchyGroup({
    required String instanceId,
    required String name,
    String? parentGroupId,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      if (parentGroupId != null) 'ParentGroupId': parentGroupId,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/user-hierarchy-groups/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateUserHierarchyGroupResponse.fromJson(response);
  }

  /// Creates a new view with the possible status of <code>SAVED</code> or
  /// <code>PUBLISHED</code>.
  ///
  /// The views will have a unique name for each connect instance.
  ///
  /// It performs basic content validation if the status is <code>SAVED</code>
  /// or full content validation if the status is set to <code>PUBLISHED</code>.
  /// An error is returned if validation fails. It associates either the
  /// <code>$SAVED</code> qualifier or both of the <code>$SAVED</code> and
  /// <code>$LATEST</code> qualifiers with the provided view content based on
  /// the status. The view is idempotent if ClientToken is provided.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [DuplicateResourceException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [TooManyRequestsException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [content] :
  /// View content containing all content necessary to render a view except for
  /// runtime input data.
  ///
  /// The total uncompressed content has a maximum file size of 400kB.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [name] :
  /// The name of the view.
  ///
  /// Parameter [status] :
  /// Indicates the view status as either <code>SAVED</code> or
  /// <code>PUBLISHED</code>. The <code>PUBLISHED</code> status will initiate
  /// validation on the content.
  ///
  /// Parameter [clientToken] :
  /// A unique Id for each create view request to avoid duplicate view creation.
  /// For example, the view is idempotent ClientToken is provided.
  ///
  /// Parameter [description] :
  /// The description of the view.
  ///
  /// Parameter [tags] :
  /// The tags associated with the view resource (not specific to view
  /// version).These tags can be used to organize, track, or control access for
  /// this resource. For example, { "tags": {"key1":"value1", "key2":"value2"}
  /// }.
  Future<CreateViewResponse> createView({
    required ViewInputContent content,
    required String instanceId,
    required String name,
    required ViewStatus status,
    String? clientToken,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
      'Name': name,
      'Status': status.value,
      if (clientToken != null) 'ClientToken': clientToken,
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/views/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateViewResponse.fromJson(response);
  }

  /// Publishes a new version of the view identifier.
  ///
  /// Versions are immutable and monotonically increasing.
  ///
  /// It returns the highest version if there is no change in content compared
  /// to that version. An error is displayed if the supplied ViewContentSha256
  /// is different from the ViewContentSha256 of the <code>$LATEST</code> alias.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [viewId] :
  /// The identifier of the view. Both <code>ViewArn</code> and
  /// <code>ViewId</code> can be used.
  ///
  /// Parameter [versionDescription] :
  /// The description for the version being published.
  ///
  /// Parameter [viewContentSha256] :
  /// Indicates the checksum value of the latest published view content.
  Future<CreateViewVersionResponse> createViewVersion({
    required String instanceId,
    required String viewId,
    String? versionDescription,
    String? viewContentSha256,
  }) async {
    final $payload = <String, dynamic>{
      if (versionDescription != null) 'VersionDescription': versionDescription,
      if (viewContentSha256 != null) 'ViewContentSha256': viewContentSha256,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}/versions',
      exceptionFnMap: _exceptionFns,
    );
    return CreateViewVersionResponse.fromJson(response);
  }

  /// Creates a custom vocabulary associated with your Amazon Connect instance.
  /// You can set a custom vocabulary to be your default vocabulary for a given
  /// language. Contact Lens for Amazon Connect uses the default vocabulary in
  /// post-call and real-time contact analysis sessions for that language.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceConflictException].
  /// May throw [ServiceQuotaExceededException].
  ///
  /// Parameter [content] :
  /// The content of the custom vocabulary in plain-text format with a table of
  /// values. Each row in the table represents a word or a phrase, described
  /// with <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and
  /// <code>DisplayAs</code> fields. Separate the fields with TAB characters.
  /// The size limit is 50KB. For more information, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create
  /// a custom vocabulary using a table</a>.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [languageCode] :
  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  ///
  /// Parameter [vocabularyName] :
  /// A unique name of the custom vocabulary.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>. If a create request is received
  /// more than once with same client token, subsequent requests return the
  /// previous response without creating a vocabulary again.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<CreateVocabularyResponse> createVocabulary({
    required String content,
    required String instanceId,
    required VocabularyLanguageCode languageCode,
    required String vocabularyName,
    String? clientToken,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
      'LanguageCode': languageCode.value,
      'VocabularyName': vocabularyName,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/vocabulary/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateVocabularyResponse.fromJson(response);
  }

  /// Deactivates an evaluation form in the specified Amazon Connect instance.
  /// After a form is deactivated, it is no longer available for users to start
  /// new evaluations based on the form.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationFormId] :
  /// The unique identifier for the evaluation form.
  ///
  /// Parameter [evaluationFormVersion] :
  /// A version of the evaluation form. If the version property is not provided,
  /// the latest version of the evaluation form is deactivated.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DeactivateEvaluationFormResponse> deactivateEvaluationForm({
    required String evaluationFormId,
    required int evaluationFormVersion,
    required String instanceId,
  }) async {
    _s.validateNumRange(
      'evaluationFormVersion',
      evaluationFormVersion,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'EvaluationFormVersion': evaluationFormVersion,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/evaluation-forms/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationFormId)}/deactivate',
      exceptionFnMap: _exceptionFns,
    );
    return DeactivateEvaluationFormResponse.fromJson(response);
  }

  /// Deletes an attached file along with the underlying S3 Object.
  /// <important>
  /// The attached file is <b>permanently deleted</b> if S3 bucket versioning is
  /// not enabled.
  /// </important>
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associatedResourceArn] :
  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  /// <note>
  /// This value must be a valid ARN.
  /// </note>
  ///
  /// Parameter [fileId] :
  /// The unique identifier of the attached file resource.
  ///
  /// Parameter [instanceId] :
  /// The unique identifier of the Connect instance.
  Future<void> deleteAttachedFile({
    required String associatedResourceArn,
    required String fileId,
    required String instanceId,
  }) async {
    final $query = <String, List<String>>{
      'associatedResourceArn': [associatedResourceArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/attached-files/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(fileId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a contact evaluation in the specified Amazon Connect instance.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationId] :
  /// A unique identifier for the contact evaluation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> deleteContactEvaluation({
    required String evaluationId,
    required String instanceId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/contact-evaluations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a flow for the specified Amazon Connect instance.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> deleteContactFlow({
    required String contactFlowId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/contact-flows/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes the specified flow module.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowModuleId] :
  /// The identifier of the flow module.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> deleteContactFlowModule({
    required String contactFlowModuleId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/contact-flow-modules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowModuleId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes an evaluation form in the specified Amazon Connect instance.
  ///
  /// <ul>
  /// <li>
  /// If the version property is provided, only the specified version of the
  /// evaluation form is deleted.
  /// </li>
  /// <li>
  /// If no version is provided, then the full form (all versions) is deleted.
  /// </li>
  /// </ul>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationFormId] :
  /// The unique identifier for the evaluation form.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [evaluationFormVersion] :
  /// The unique identifier for the evaluation form.
  Future<void> deleteEvaluationForm({
    required String evaluationFormId,
    required String instanceId,
    int? evaluationFormVersion,
  }) async {
    _s.validateNumRange(
      'evaluationFormVersion',
      evaluationFormVersion,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (evaluationFormVersion != null)
        'version': [evaluationFormVersion.toString()],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/evaluation-forms/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationFormId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Deletes an hours of operation.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hoursOfOperationId] :
  /// The identifier for the hours of operation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> deleteHoursOfOperation({
    required String hoursOfOperationId,
    required String instanceId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/hours-of-operations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(hoursOfOperationId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Deletes the Amazon Connect instance.
  ///
  /// Amazon Connect enforces a limit on the total number of instances that you
  /// can create or delete in 30 days. If you exceed this limit, you will get an
  /// error message indicating there has been an excessive number of attempts at
  /// creating or deleting instances. You must wait 30 days before you can
  /// restart creating and deleting instances in your account.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> deleteInstance({
    required String instanceId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes an Amazon Web Services resource association from an Amazon Connect
  /// instance. The association must not have any use cases associated with it.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [integrationAssociationId] :
  /// The identifier for the integration association.
  Future<void> deleteIntegrationAssociation({
    required String instanceId,
    required String integrationAssociationId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/integration-associations/${Uri.encodeComponent(integrationAssociationId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a predefined attribute from the specified Amazon Connect instance.
  ///
  /// May throw [ResourceInUseException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the predefined attribute.
  Future<void> deletePredefinedAttribute({
    required String instanceId,
    required String name,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/predefined-attributes/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(name)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a prompt.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [promptId] :
  /// A unique identifier for the prompt.
  Future<void> deletePrompt({
    required String instanceId,
    required String promptId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/prompts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(promptId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  Future<void> deleteQueue({
    required String instanceId,
    required String queueId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a quick connect.
  /// <important>
  /// After calling <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteUser.html">DeleteUser</a>,
  /// it's important to call <code>DeleteQuickConnect</code> to delete any
  /// records related to the deleted users. This will help you:
  ///
  /// <ul>
  /// <li>
  /// Avoid dangling resources that impact your service quotas.
  /// </li>
  /// <li>
  /// Remove deleted users so they don't appear to agents as transfer options.
  /// </li>
  /// <li>
  /// Avoid the disruption of other Amazon Connect processes, such as instance
  /// replication and syncing if you're using <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-connect-global-resiliency.html">Amazon
  /// Connect Global Resiliency</a>.
  /// </li>
  /// </ul> </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [quickConnectId] :
  /// The identifier for the quick connect.
  Future<void> deleteQuickConnect({
    required String instanceId,
    required String quickConnectId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/quick-connects/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(quickConnectId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> deleteRoutingProfile({
    required String instanceId,
    required String routingProfileId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a rule for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [ruleId] :
  /// A unique identifier for the rule.
  Future<void> deleteRule({
    required String instanceId,
    required String ruleId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/rules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(ruleId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a security profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileId] :
  /// The identifier for the security profle.
  Future<void> deleteSecurityProfile({
    required String instanceId,
    required String securityProfileId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/security-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(securityProfileId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes the task template.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [taskTemplateId] :
  /// A unique identifier for the task template.
  Future<void> deleteTaskTemplate({
    required String instanceId,
    required String taskTemplateId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/task/template/${Uri.encodeComponent(taskTemplateId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a traffic distribution group. This API can be called only in the
  /// Region where the traffic distribution group is created.
  ///
  /// For more information about deleting traffic distribution groups, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/delete-traffic-distribution-groups.html">Delete
  /// traffic distribution groups</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceInUseException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [trafficDistributionGroupId] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  Future<void> deleteTrafficDistributionGroup({
    required String trafficDistributionGroupId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/traffic-distribution-group/${Uri.encodeComponent(trafficDistributionGroupId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a use case from an integration association.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [integrationAssociationId] :
  /// The identifier for the integration association.
  ///
  /// Parameter [useCaseId] :
  /// The identifier for the use case.
  Future<void> deleteUseCase({
    required String instanceId,
    required String integrationAssociationId,
    required String useCaseId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/integration-associations/${Uri.encodeComponent(integrationAssociationId)}/use-cases/${Uri.encodeComponent(useCaseId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a user account from the specified Amazon Connect instance.
  ///
  /// For information about what happens to a user's data when their account is
  /// deleted, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/delete-users.html">Delete
  /// Users from Your Amazon Connect Instance</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  /// <important>
  /// After calling DeleteUser, call <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteQuickConnect.html">DeleteQuickConnect</a>
  /// to delete any records related to the deleted users. This will help you:
  ///
  /// <ul>
  /// <li>
  /// Avoid dangling resources that impact your service quotas.
  /// </li>
  /// <li>
  /// Remove deleted users so they don't appear to agents as transfer options.
  /// </li>
  /// <li>
  /// Avoid the disruption of other Amazon Connect processes, such as instance
  /// replication and syncing if you're using <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-connect-global-resiliency.html">Amazon
  /// Connect Global Resiliency</a>.
  /// </li>
  /// </ul> </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user.
  Future<void> deleteUser({
    required String instanceId,
    required String userId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes an existing user hierarchy group. It must not be associated with
  /// any agents or have any active child groups.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hierarchyGroupId] :
  /// The identifier of the hierarchy group.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> deleteUserHierarchyGroup({
    required String hierarchyGroupId,
    required String instanceId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/user-hierarchy-groups/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(hierarchyGroupId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes the view entirely. It deletes the view and all associated
  /// qualifiers (versions and aliases).
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [viewId] :
  /// The identifier of the view. Both <code>ViewArn</code> and
  /// <code>ViewId</code> can be used.
  Future<void> deleteView({
    required String instanceId,
    required String viewId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes the particular version specified in <code>ViewVersion</code>
  /// identifier.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [viewId] :
  /// The identifier of the view. Both <code>ViewArn</code> and
  /// <code>ViewId</code> can be used.
  ///
  /// Parameter [viewVersion] :
  /// The version number of the view.
  Future<void> deleteViewVersion({
    required String instanceId,
    required String viewId,
    required int viewVersion,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}/versions/${Uri.encodeComponent(viewVersion.toString())}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes the vocabulary that has the given identifier.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [vocabularyId] :
  /// The identifier of the custom vocabulary.
  Future<DeleteVocabularyResponse> deleteVocabulary({
    required String instanceId,
    required String vocabularyId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri:
          '/vocabulary-remove/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(vocabularyId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteVocabularyResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Describes an agent status.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [agentStatusId] :
  /// The identifier for the agent status.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeAgentStatusResponse> describeAgentStatus({
    required String agentStatusId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/agent-status/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(agentStatusId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAgentStatusResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Describes the specified contact.
  /// <important>
  /// Contact information remains available in Amazon Connect for 24 months, and
  /// then it is deleted.
  ///
  /// Only data from November 12, 2021, and later is returned by this API.
  /// </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeContactResponse> describeContact({
    required String contactId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contacts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeContactResponse.fromJson(response);
  }

  /// Describes a contact evaluation in the specified Amazon Connect instance.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [evaluationId] :
  /// A unique identifier for the contact evaluation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeContactEvaluationResponse> describeContactEvaluation({
    required String evaluationId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contact-evaluations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeContactEvaluationResponse.fromJson(response);
  }

  /// Describes the specified flow.
  ///
  /// You can also create and update flows using the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon
  /// Connect Flow language</a>.
  ///
  /// Use the <code>$SAVED</code> alias in the request to describe the
  /// <code>SAVED</code> content of a Flow. For example,
  /// <code>arn:aws:.../contact-flow/{id}:$SAVED</code>. Once a contact flow is
  /// published, <code>$SAVED</code> needs to be supplied to view saved content
  /// that has not been published.
  ///
  /// In the response, <b>Status</b> indicates the flow status as either
  /// <code>SAVED</code> or <code>PUBLISHED</code>. The <code>PUBLISHED</code>
  /// status will initiate validation on the content. <code>SAVED</code> does
  /// not initiate validation of the content. <code>SAVED</code> |
  /// <code>PUBLISHED</code>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ContactFlowNotPublishedException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance.
  Future<DescribeContactFlowResponse> describeContactFlow({
    required String contactFlowId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contact-flows/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeContactFlowResponse.fromJson(response);
  }

  /// Describes the specified flow module.
  ///
  /// Use the <code>$SAVED</code> alias in the request to describe the
  /// <code>SAVED</code> content of a Flow. For example,
  /// <code>arn:aws:.../contact-flow/{id}:$SAVED</code>. Once a contact flow is
  /// published, <code>$SAVED</code> needs to be supplied to view saved content
  /// that has not been published.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowModuleId] :
  /// The identifier of the flow module.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeContactFlowModuleResponse> describeContactFlowModule({
    required String contactFlowModuleId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contact-flow-modules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowModuleId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeContactFlowModuleResponse.fromJson(response);
  }

  /// Describes an evaluation form in the specified Amazon Connect instance. If
  /// the version property is not provided, the latest version of the evaluation
  /// form is described.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [evaluationFormId] :
  /// A unique identifier for the contact evaluation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [evaluationFormVersion] :
  /// A version of the evaluation form.
  Future<DescribeEvaluationFormResponse> describeEvaluationForm({
    required String evaluationFormId,
    required String instanceId,
    int? evaluationFormVersion,
  }) async {
    _s.validateNumRange(
      'evaluationFormVersion',
      evaluationFormVersion,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (evaluationFormVersion != null)
        'version': [evaluationFormVersion.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/evaluation-forms/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationFormId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeEvaluationFormResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Describes the hours of operation.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hoursOfOperationId] :
  /// The identifier for the hours of operation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeHoursOfOperationResponse> describeHoursOfOperation({
    required String hoursOfOperationId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/hours-of-operations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(hoursOfOperationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeHoursOfOperationResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns the current state of the specified instance identifier. It tracks
  /// the instance while it is being created and returns an error status, if
  /// applicable.
  ///
  /// If an instance is not created successfully, the instance status reason
  /// field returns details relevant to the reason. The instance in a failed
  /// state is returned only for 24 hours after the CreateInstance API was
  /// invoked.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeInstanceResponse> describeInstance({
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeInstanceResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Describes the specified instance attribute.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [attributeType] :
  /// The type of attribute.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeInstanceAttributeResponse> describeInstanceAttribute({
    required InstanceAttributeType attributeType,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/attribute/${Uri.encodeComponent(attributeType.value)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeInstanceAttributeResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Retrieves the current storage configurations for the specified resource
  /// type, association ID, and instance ID.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associationId] :
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<DescribeInstanceStorageConfigResponse> describeInstanceStorageConfig({
    required String associationId,
    required String instanceId,
    required InstanceStorageResourceType resourceType,
  }) async {
    final $query = <String, List<String>>{
      'resourceType': [resourceType.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/storage-config/${Uri.encodeComponent(associationId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeInstanceStorageConfigResponse.fromJson(response);
  }

  /// Gets details and status of a phone number that’s claimed to your Amazon
  /// Connect instance or traffic distribution group.
  /// <important>
  /// If the number is claimed to a traffic distribution group, and you are
  /// calling in the Amazon Web Services Region where the traffic distribution
  /// group was created, you can use either a phone number ARN or UUID value for
  /// the <code>PhoneNumberId</code> URI request parameter. However, if the
  /// number is claimed to a traffic distribution group and you are calling this
  /// API in the alternate Amazon Web Services Region associated with the
  /// traffic distribution group, you must provide a full phone number ARN. If a
  /// UUID is provided in this scenario, you will receive a
  /// <code>ResourceNotFoundException</code>.
  /// </important>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [phoneNumberId] :
  /// A unique identifier for the phone number.
  Future<DescribePhoneNumberResponse> describePhoneNumber({
    required String phoneNumberId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/phone-number/${Uri.encodeComponent(phoneNumberId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribePhoneNumberResponse.fromJson(response);
  }

  /// Describes a predefined attribute for the specified Amazon Connect
  /// instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the predefined attribute.
  Future<DescribePredefinedAttributeResponse> describePredefinedAttribute({
    required String instanceId,
    required String name,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/predefined-attributes/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(name)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribePredefinedAttributeResponse.fromJson(response);
  }

  /// Describes the prompt.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [promptId] :
  /// A unique identifier for the prompt.
  Future<DescribePromptResponse> describePrompt({
    required String instanceId,
    required String promptId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/prompts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(promptId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribePromptResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Describes the specified queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  Future<DescribeQueueResponse> describeQueue({
    required String instanceId,
    required String queueId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeQueueResponse.fromJson(response);
  }

  /// Describes the quick connect.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [quickConnectId] :
  /// The identifier for the quick connect.
  Future<DescribeQuickConnectResponse> describeQuickConnect({
    required String instanceId,
    required String quickConnectId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/quick-connects/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(quickConnectId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeQuickConnectResponse.fromJson(response);
  }

  /// Describes the specified routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<DescribeRoutingProfileResponse> describeRoutingProfile({
    required String instanceId,
    required String routingProfileId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeRoutingProfileResponse.fromJson(response);
  }

  /// Describes a rule for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [ruleId] :
  /// A unique identifier for the rule.
  Future<DescribeRuleResponse> describeRule({
    required String instanceId,
    required String ruleId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/rules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(ruleId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeRuleResponse.fromJson(response);
  }

  /// Gets basic information about the security profle.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileId] :
  /// The identifier for the security profle.
  Future<DescribeSecurityProfileResponse> describeSecurityProfile({
    required String instanceId,
    required String securityProfileId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/security-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(securityProfileId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeSecurityProfileResponse.fromJson(response);
  }

  /// Gets details and status of a traffic distribution group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [trafficDistributionGroupId] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  Future<DescribeTrafficDistributionGroupResponse>
      describeTrafficDistributionGroup({
    required String trafficDistributionGroupId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/traffic-distribution-group/${Uri.encodeComponent(trafficDistributionGroupId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTrafficDistributionGroupResponse.fromJson(response);
  }

  /// Describes the specified user. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID in the Amazon Connect console</a> (it’s the final part of
  /// the ARN). The console does not display the user IDs. Instead, list the
  /// users and note the IDs provided in the output.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  Future<DescribeUserResponse> describeUser({
    required String instanceId,
    required String userId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeUserResponse.fromJson(response);
  }

  /// Describes the specified hierarchy group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hierarchyGroupId] :
  /// The identifier of the hierarchy group.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeUserHierarchyGroupResponse> describeUserHierarchyGroup({
    required String hierarchyGroupId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/user-hierarchy-groups/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(hierarchyGroupId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeUserHierarchyGroupResponse.fromJson(response);
  }

  /// Describes the hierarchy structure of the specified Amazon Connect
  /// instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<DescribeUserHierarchyStructureResponse>
      describeUserHierarchyStructure({
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/user-hierarchy-structure/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeUserHierarchyStructureResponse.fromJson(response);
  }

  /// Retrieves the view for the specified Amazon Connect instance and view
  /// identifier.
  ///
  /// The view identifier can be supplied as a ViewId or ARN.
  ///
  /// <code>$SAVED</code> needs to be supplied if a view is unpublished.
  ///
  /// The view identifier can contain an optional qualifier, for example,
  /// <code>&lt;view-id&gt;:$SAVED</code>, which is either an actual version
  /// number or an Amazon Connect managed qualifier <code>$SAVED |
  /// $LATEST</code>. If it is not supplied, then <code>$LATEST</code> is
  /// assumed for customer managed views and an error is returned if there is no
  /// published content available. Version 1 is assumed for Amazon Web Services
  /// managed views.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [viewId] :
  /// The ViewId of the view. This must be an ARN for Amazon Web Services
  /// managed views.
  Future<DescribeViewResponse> describeView({
    required String instanceId,
    required String viewId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeViewResponse.fromJson(response);
  }

  /// Describes the specified vocabulary.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [vocabularyId] :
  /// The identifier of the custom vocabulary.
  Future<DescribeVocabularyResponse> describeVocabulary({
    required String instanceId,
    required String vocabularyId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/vocabulary/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(vocabularyId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeVocabularyResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Removes the dataset ID associated with a given Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [dataSetId] :
  /// The identifier of the dataset to remove.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [targetAccountId] :
  /// The identifier of the target account. Use to associate a dataset to a
  /// different account than the one containing the Amazon Connect instance. If
  /// not specified, by default this value is the Amazon Web Services account
  /// that has the Amazon Connect instance.
  Future<void> disassociateAnalyticsDataSet({
    required String dataSetId,
    required String instanceId,
    String? targetAccountId,
  }) async {
    final $payload = <String, dynamic>{
      'DataSetId': dataSetId,
      if (targetAccountId != null) 'TargetAccountId': targetAccountId,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/analytics-data/instance/${Uri.encodeComponent(instanceId)}/association',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Revokes access to integrated applications from Amazon Connect.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [origin] :
  /// The domain URL of the integrated application.
  Future<void> disassociateApprovedOrigin({
    required String instanceId,
    required String origin,
  }) async {
    final $query = <String, List<String>>{
      'origin': [origin],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/approved-origin',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Revokes authorization from the specified instance to access the specified
  /// Amazon Lex or Amazon Lex V2 bot.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [lexV2Bot] :
  /// The Amazon Lex V2 bot to disassociate from the instance.
  Future<void> disassociateBot({
    required String instanceId,
    LexBot? lexBot,
    LexV2Bot? lexV2Bot,
  }) async {
    final $payload = <String, dynamic>{
      if (lexBot != null) 'LexBot': lexBot,
      if (lexV2Bot != null) 'LexV2Bot': lexV2Bot,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/bot',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disassociates a connect resource from a flow.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceId] :
  /// The identifier of the resource.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<void> disassociateFlow({
    required String instanceId,
    required String resourceId,
    required FlowAssociationResourceType resourceType,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/flow-associations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(resourceId)}/${Uri.encodeComponent(resourceType.value)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Removes the storage type configurations for the specified resource type
  /// and association ID.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associationId] :
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<void> disassociateInstanceStorageConfig({
    required String associationId,
    required String instanceId,
    required InstanceStorageResourceType resourceType,
  }) async {
    final $query = <String, List<String>>{
      'resourceType': [resourceType.value],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/storage-config/${Uri.encodeComponent(associationId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Remove the Lambda function from the dropdown options available in the
  /// relevant flow blocks.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [functionArn] :
  /// The Amazon Resource Name (ARN) of the Lambda function being disassociated.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance..
  Future<void> disassociateLambdaFunction({
    required String functionArn,
    required String instanceId,
  }) async {
    final $query = <String, List<String>>{
      'functionArn': [functionArn],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/lambda-function',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Revokes authorization from the specified instance to access the specified
  /// Amazon Lex bot.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [botName] :
  /// The name of the Amazon Lex bot. Maximum character limit of 50.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [lexRegion] :
  /// The Amazon Web Services Region in which the Amazon Lex bot has been
  /// created.
  Future<void> disassociateLexBot({
    required String botName,
    required String instanceId,
    required String lexRegion,
  }) async {
    final $query = <String, List<String>>{
      'botName': [botName],
      'lexRegion': [lexRegion],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/lex-bot',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Removes the flow association from a phone number claimed to your Amazon
  /// Connect instance.
  /// <important>
  /// If the number is claimed to a traffic distribution group, and you are
  /// calling this API using an instance in the Amazon Web Services Region where
  /// the traffic distribution group was created, you can use either a full
  /// phone number ARN or UUID value for the <code>PhoneNumberId</code> URI
  /// request parameter. However, if the number is claimed to a traffic
  /// distribution group and you are calling this API using an instance in the
  /// alternate Amazon Web Services Region associated with the traffic
  /// distribution group, you must provide a full phone number ARN. If a UUID is
  /// provided in this scenario, you will receive a
  /// <code>ResourceNotFoundException</code>.
  /// </important>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [phoneNumberId] :
  /// A unique identifier for the phone number.
  Future<void> disassociatePhoneNumberContactFlow({
    required String instanceId,
    required String phoneNumberId,
  }) async {
    final $query = <String, List<String>>{
      'instanceId': [instanceId],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/phone-number/${Uri.encodeComponent(phoneNumberId)}/contact-flow',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Disassociates a set of quick connects from a queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [quickConnectIds] :
  /// The quick connects to disassociate from the queue.
  Future<void> disassociateQueueQuickConnects({
    required String instanceId,
    required String queueId,
    required List<String> quickConnectIds,
  }) async {
    final $payload = <String, dynamic>{
      'QuickConnectIds': quickConnectIds,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/disassociate-quick-connects',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disassociates a set of queues from a routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueReferences] :
  /// The queues to disassociate from this routing profile.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> disassociateRoutingProfileQueues({
    required String instanceId,
    required List<RoutingProfileQueueReference> queueReferences,
    required String routingProfileId,
  }) async {
    final $payload = <String, dynamic>{
      'QueueReferences': queueReferences,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/disassociate-queues',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Deletes the specified security key.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associationId] :
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> disassociateSecurityKey({
    required String associationId,
    required String instanceId,
  }) async {
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/security-key/${Uri.encodeComponent(associationId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disassociates an agent from a traffic distribution group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [trafficDistributionGroupId] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  ///
  /// Parameter [userId] :
  /// The identifier for the user. This can be the ID or the ARN of the user.
  Future<void> disassociateTrafficDistributionGroupUser({
    required String instanceId,
    required String trafficDistributionGroupId,
    required String userId,
  }) async {
    final $query = <String, List<String>>{
      'InstanceId': [instanceId],
      'UserId': [userId],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/traffic-distribution-group/${Uri.encodeComponent(trafficDistributionGroupId)}/user',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disassociates a set of proficiencies from a user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  ///
  /// Parameter [userProficiencies] :
  /// The proficiencies to disassociate from the user.
  Future<void> disassociateUserProficiencies({
    required String instanceId,
    required String userId,
    required List<UserProficiencyDisassociate> userProficiencies,
  }) async {
    final $payload = <String, dynamic>{
      'UserProficiencies': userProficiencies,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/disassociate-proficiencies',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Dismisses contacts from an agent’s CCP and returns the agent to an
  /// available state, which allows the agent to receive a new routed contact.
  /// Contacts can only be dismissed if they are in a <code>MISSED</code>,
  /// <code>ERROR</code>, <code>ENDED</code>, or <code>REJECTED</code> state in
  /// the <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">Agent
  /// Event Stream</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  Future<void> dismissUserContact({
    required String contactId,
    required String instanceId,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/contact',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Provides a pre-signed URL for download of an approved attached file. This
  /// API also returns metadata about the attached file. It will only return a
  /// downloadURL if the status of the attached file is <code>APPROVED</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associatedResourceArn] :
  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  /// <note>
  /// This value must be a valid ARN.
  /// </note>
  ///
  /// Parameter [fileId] :
  /// The unique identifier of the attached file resource.
  ///
  /// Parameter [instanceId] :
  /// The unique identifier of the Connect instance.
  ///
  /// Parameter [urlExpiryInSeconds] :
  /// Optional override for the expiry of the pre-signed S3 URL in seconds. The
  /// default value is 300.
  Future<GetAttachedFileResponse> getAttachedFile({
    required String associatedResourceArn,
    required String fileId,
    required String instanceId,
    int? urlExpiryInSeconds,
  }) async {
    _s.validateNumRange(
      'urlExpiryInSeconds',
      urlExpiryInSeconds,
      5,
      300,
    );
    final $query = <String, List<String>>{
      'associatedResourceArn': [associatedResourceArn],
      if (urlExpiryInSeconds != null)
        'urlExpiryInSeconds': [urlExpiryInSeconds.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/attached-files/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(fileId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetAttachedFileResponse.fromJson(response);
  }

  /// Retrieves the contact attributes for the specified contact.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [initialContactId] :
  /// The identifier of the initial contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance.
  Future<GetContactAttributesResponse> getContactAttributes({
    required String initialContactId,
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contact/attributes/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(initialContactId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetContactAttributesResponse.fromJson(response);
  }

  /// Gets the real-time metric data from the specified Amazon Connect instance.
  ///
  /// For a description of each metric, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time
  /// Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [currentMetrics] :
  /// The metrics to retrieve. Specify the name and unit for each metric. The
  /// following metrics are available. For a description of all the metrics, see
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time
  /// Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
  /// <dl> <dt>AGENTS_AFTER_CONTACT_WORK</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#aftercallwork-real-time">ACW</a>
  /// </dd> <dt>AGENTS_AVAILABLE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#available-real-time">Available</a>
  /// </dd> <dt>AGENTS_ERROR</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#error-real-time">Error</a>
  /// </dd> <dt>AGENTS_NON_PRODUCTIVE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#non-productive-time-real-time">NPT
  /// (Non-Productive Time)</a>
  /// </dd> <dt>AGENTS_ON_CALL</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On
  /// contact</a>
  /// </dd> <dt>AGENTS_ON_CONTACT</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#on-call-real-time">On
  /// contact</a>
  /// </dd> <dt>AGENTS_ONLINE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#online-real-time">Online</a>
  /// </dd> <dt>AGENTS_STAFFED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#staffed-real-time">Staffed</a>
  /// </dd> <dt>CONTACTS_IN_QUEUE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#in-queue-real-time">In
  /// queue</a>
  /// </dd> <dt>CONTACTS_SCHEDULED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#scheduled-real-time">Scheduled</a>
  /// </dd> <dt>OLDEST_CONTACT_AGE</dt> <dd>
  /// Unit: SECONDS
  ///
  /// When you use groupings, Unit says SECONDS and the Value is returned in
  /// SECONDS.
  ///
  /// When you do not use groupings, Unit says SECONDS but the Value is returned
  /// in MILLISECONDS. For example, if you get a response like this:
  ///
  /// <code>{ "Metric": { "Name": "OLDEST_CONTACT_AGE", "Unit": "SECONDS" },
  /// "Value": 24113.0 </code>}
  ///
  /// The actual OLDEST_CONTACT_AGE is 24 seconds.
  ///
  /// When the filter <code>RoutingStepExpression</code> is used, this metric is
  /// still calculated from enqueue time. For example, if a contact that has
  /// been queued under <code>&lt;Expression 1&gt;</code> for 10 seconds has
  /// expired and <code>&lt;Expression 2&gt;</code> becomes active, then
  /// <code>OLDEST_CONTACT_AGE</code> for this queue will be counted starting
  /// from 10, not 0.
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#oldest-real-time">Oldest</a>
  /// </dd> <dt>SLOTS_ACTIVE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#active-real-time">Active</a>
  /// </dd> <dt>SLOTS_AVAILABLE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Name in real-time metrics report: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html#availability-real-time">Availability</a>
  /// </dd> </dl>
  ///
  /// Parameter [filters] :
  /// The filters to apply to returned metrics. You can filter up to the
  /// following limits:
  ///
  /// <ul>
  /// <li>
  /// Queues: 100
  /// </li>
  /// <li>
  /// Routing profiles: 100
  /// </li>
  /// <li>
  /// Channels: 3 (VOICE, CHAT, and TASK channels are supported.)
  /// </li>
  /// <li>
  /// RoutingStepExpressions: 50
  /// </li>
  /// </ul>
  /// Metric data is retrieved only for the resources associated with the queues
  /// or routing profiles, and by any channels included in the filter. (You
  /// cannot filter by both queue AND routing profile.) You can include both
  /// resource IDs and resource ARNs in the same request.
  ///
  /// When using the <code>RoutingStepExpression</code> filter, you need to pass
  /// exactly one <code>QueueId</code>. The filter is also case sensitive so
  /// when using the <code>RoutingStepExpression</code> filter, grouping by
  /// <code>ROUTING_STEP_EXPRESSION</code> is required.
  ///
  /// Currently tagging is only supported on the resources that are passed in
  /// the filter.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [groupings] :
  /// The grouping applied to the metrics returned. For example, when grouped by
  /// <code>QUEUE</code>, the metrics returned apply to each queue rather than
  /// aggregated for all queues.
  ///
  /// <ul>
  /// <li>
  /// If you group by <code>CHANNEL</code>, you should include a Channels
  /// filter. VOICE, CHAT, and TASK channels are supported.
  /// </li>
  /// <li>
  /// If you group by <code>ROUTING_PROFILE</code>, you must include either a
  /// queue or routing profile filter. In addition, a routing profile filter is
  /// required for metrics <code>CONTACTS_SCHEDULED</code>,
  /// <code>CONTACTS_IN_QUEUE</code>, and <code> OLDEST_CONTACT_AGE</code>.
  /// </li>
  /// <li>
  /// If no <code>Grouping</code> is included in the request, a summary of
  /// metrics is returned.
  /// </li>
  /// <li>
  /// When using the <code>RoutingStepExpression</code> filter, group by
  /// <code>ROUTING_STEP_EXPRESSION</code> is required.
  /// </li>
  /// </ul>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// The token expires after 5 minutes from the time it is created. Subsequent
  /// requests that use the token must use the same request parameters as the
  /// request that generated the token.
  ///
  /// Parameter [sortCriteria] :
  /// The way to sort the resulting response based on metrics. You can enter one
  /// sort criteria. By default resources are sorted based on
  /// <code>AGENTS_ONLINE</code>, <code>DESCENDING</code>. The metric collection
  /// is sorted based on the input metrics.
  ///
  /// Note the following:
  ///
  /// <ul>
  /// <li>
  /// Sorting on <code>SLOTS_ACTIVE</code> and <code>SLOTS_AVAILABLE</code> is
  /// not supported.
  /// </li>
  /// </ul>
  Future<GetCurrentMetricDataResponse> getCurrentMetricData({
    required List<CurrentMetric> currentMetrics,
    required Filters filters,
    required String instanceId,
    List<Grouping>? groupings,
    int? maxResults,
    String? nextToken,
    List<CurrentMetricSortCriteria>? sortCriteria,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'CurrentMetrics': currentMetrics,
      'Filters': filters,
      if (groupings != null)
        'Groupings': groupings.map((e) => e.value).toList(),
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (sortCriteria != null) 'SortCriteria': sortCriteria,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/metrics/current/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetCurrentMetricDataResponse.fromJson(response);
  }

  /// Gets the real-time active user data from the specified Amazon Connect
  /// instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [filters] :
  /// The filters to apply to returned user data. You can filter up to the
  /// following limits:
  ///
  /// <ul>
  /// <li>
  /// Queues: 100
  /// </li>
  /// <li>
  /// Routing profiles: 100
  /// </li>
  /// <li>
  /// Agents: 100
  /// </li>
  /// <li>
  /// Contact states: 9
  /// </li>
  /// <li>
  /// User hierarchy groups: 1
  /// </li>
  /// </ul>
  /// The user data is retrieved for only the specified values/resources in the
  /// filter. A maximum of one filter can be passed from queues, routing
  /// profiles, agents, and user hierarchy groups.
  ///
  /// Currently tagging is only supported on the resources that are passed in
  /// the filter.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<GetCurrentUserDataResponse> getCurrentUserData({
    required UserDataFilters filters,
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/metrics/userdata/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetCurrentUserDataResponse.fromJson(response);
  }

  /// Supports SAML sign-in for Amazon Connect. Retrieves a token for
  /// federation. The token is for the Amazon Connect user which corresponds to
  /// the IAM credentials that were used to invoke this action.
  ///
  /// For more information about how SAML sign-in works in Amazon Connect, see
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/configure-saml.html
  /// ">Configure SAML with IAM for Amazon Connect in the <i>Amazon Connect
  /// Administrator Guide</i>.</a>
  /// <note>
  /// This API doesn't support root users. If you try to invoke
  /// GetFederationToken with root credentials, an error message similar to the
  /// following one appears:
  ///
  /// <code>Provided identity: Principal: .... User: .... cannot be used for
  /// federation with Amazon Connect</code>
  /// </note>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UserNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [DuplicateResourceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<GetFederationTokenResponse> getFederationToken({
    required String instanceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/user/federate/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetFederationTokenResponse.fromJson(response);
  }

  /// Retrieves the flow associated for a given resource.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceId] :
  /// The identifier of the resource.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<GetFlowAssociationResponse> getFlowAssociation({
    required String instanceId,
    required String resourceId,
    required FlowAssociationResourceType resourceType,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/flow-associations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(resourceId)}/${Uri.encodeComponent(resourceType.value)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetFlowAssociationResponse.fromJson(response);
  }

  /// Gets historical metric data from the specified Amazon Connect instance.
  ///
  /// For a description of each historical metric, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical
  /// Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
  /// <note>
  /// We recommend using the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_GetMetricDataV2.html">GetMetricDataV2</a>
  /// API. It provides more flexibility, features, and the ability to query
  /// longer time ranges than <code>GetMetricData</code>. Use it to retrieve
  /// historical agent and contact metrics for the last 3 months, at varying
  /// intervals. You can also use it to build custom dashboards to measure
  /// historical queue and agent performance. For example, you can track the
  /// number of incoming contacts for the last 7 days, with data split by day,
  /// to see how contact volume changed per day of the week.
  /// </note>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [endTime] :
  /// The timestamp, in UNIX Epoch time format, at which to end the reporting
  /// interval for the retrieval of historical metrics data. The time must be
  /// specified using an interval of 5 minutes, such as 11:00, 11:05, 11:10, and
  /// must be later than the start time timestamp.
  ///
  /// The time range between the start and end time must be less than 24 hours.
  ///
  /// Parameter [filters] :
  /// The queues, up to 100, or channels, to use to filter the metrics returned.
  /// Metric data is retrieved only for the resources associated with the queues
  /// or channels included in the filter. You can include both queue IDs and
  /// queue ARNs in the same request. VOICE, CHAT, and TASK channels are
  /// supported.
  ///
  /// RoutingStepExpression is not a valid filter for GetMetricData and we
  /// recommend switching to GetMetricDataV2 for more up-to-date features.
  /// <note>
  /// To filter by <code>Queues</code>, enter the queue ID/ARN, not the name of
  /// the queue.
  /// </note>
  ///
  /// Parameter [historicalMetrics] :
  /// The metrics to retrieve. Specify the name, unit, and statistic for each
  /// metric. The following historical metrics are available. For a description
  /// of each metric, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical
  /// Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
  /// <note>
  /// This API does not support a contacts incoming metric (there's no
  /// CONTACTS_INCOMING metric missing from the documented list).
  /// </note> <dl> <dt>ABANDON_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>AFTER_CONTACT_WORK_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>API_CONTACTS_HANDLED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CALLBACK_CONTACTS_HANDLED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_ABANDONED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_AGENT_HUNG_UP_FIRST</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_CONSULTED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_HANDLED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_HANDLED_INCOMING</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_HANDLED_OUTBOUND</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_HOLD_ABANDONS</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_MISSED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_QUEUED</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_TRANSFERRED_IN</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_TRANSFERRED_IN_FROM_QUEUE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_TRANSFERRED_OUT</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>CONTACTS_TRANSFERRED_OUT_FROM_QUEUE</dt> <dd>
  /// Unit: COUNT
  ///
  /// Statistic: SUM
  /// </dd> <dt>HANDLE_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>HOLD_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>INTERACTION_AND_HOLD_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>INTERACTION_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>OCCUPANCY</dt> <dd>
  /// Unit: PERCENT
  ///
  /// Statistic: AVG
  /// </dd> <dt>QUEUE_ANSWER_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: AVG
  /// </dd> <dt>QUEUED_TIME</dt> <dd>
  /// Unit: SECONDS
  ///
  /// Statistic: MAX
  /// </dd> <dt>SERVICE_LEVEL</dt> <dd>
  /// You can include up to 20 SERVICE_LEVEL metrics in a request.
  ///
  /// Unit: PERCENT
  ///
  /// Statistic: AVG
  ///
  /// Threshold: For <code>ThresholdValue</code>, enter any whole number from 1
  /// to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must
  /// enter <code>LT</code> (for "Less than").
  /// </dd> </dl>
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [startTime] :
  /// The timestamp, in UNIX Epoch time format, at which to start the reporting
  /// interval for the retrieval of historical metrics data. The time must be
  /// specified using a multiple of 5 minutes, such as 10:05, 10:10, 10:15.
  ///
  /// The start time cannot be earlier than 24 hours before the time of the
  /// request. Historical metrics are available only for 24 hours.
  ///
  /// Parameter [groupings] :
  /// The grouping applied to the metrics returned. For example, when results
  /// are grouped by queue, the metrics returned are grouped by queue. The
  /// values returned apply to the metrics for each queue rather than aggregated
  /// for all queues.
  ///
  /// If no grouping is specified, a summary of metrics for all queues is
  /// returned.
  ///
  /// RoutingStepExpression is not a valid filter for GetMetricData and we
  /// recommend switching to GetMetricDataV2 for more up-to-date features.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<GetMetricDataResponse> getMetricData({
    required DateTime endTime,
    required Filters filters,
    required List<HistoricalMetric> historicalMetrics,
    required String instanceId,
    required DateTime startTime,
    List<Grouping>? groupings,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'EndTime': unixTimestampToJson(endTime),
      'Filters': filters,
      'HistoricalMetrics': historicalMetrics,
      'StartTime': unixTimestampToJson(startTime),
      if (groupings != null)
        'Groupings': groupings.map((e) => e.value).toList(),
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/metrics/historical/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetMetricDataResponse.fromJson(response);
  }

  /// Gets metric data from the specified Amazon Connect instance.
  ///
  /// <code>GetMetricDataV2</code> offers more features than <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_GetMetricData.html">GetMetricData</a>,
  /// the previous version of this API. It has new metrics, offers filtering at
  /// a metric level, and offers the ability to filter and group data by
  /// channels, queues, routing profiles, agents, and agent hierarchy levels. It
  /// can retrieve historical data for the last 3 months, at varying intervals.
  ///
  /// For a description of the historical metrics that are supported by
  /// <code>GetMetricDataV2</code> and <code>GetMetricData</code>, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical
  /// metrics definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [endTime] :
  /// The timestamp, in UNIX Epoch time format, at which to end the reporting
  /// interval for the retrieval of historical metrics data. The time must be
  /// later than the start time timestamp. It cannot be later than the current
  /// timestamp.
  ///
  /// Parameter [filters] :
  /// The filters to apply to returned metrics. You can filter on the following
  /// resources:
  ///
  /// <ul>
  /// <li>
  /// Agents
  /// </li>
  /// <li>
  /// Channels
  /// </li>
  /// <li>
  /// Feature
  /// </li>
  /// <li>
  /// Queues
  /// </li>
  /// <li>
  /// Routing profiles
  /// </li>
  /// <li>
  /// Routing step expression
  /// </li>
  /// <li>
  /// User hierarchy groups
  /// </li>
  /// </ul>
  /// At least one filter must be passed from queues, routing profiles, agents,
  /// or user hierarchy groups.
  ///
  /// To filter by phone number, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/create-historical-metrics-report.html">Create
  /// a historical metrics report</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  ///
  /// Note the following limits:
  ///
  /// <ul>
  /// <li>
  /// <b>Filter keys</b>: A maximum of 5 filter keys are supported in a single
  /// request. Valid filter keys: <code>AGENT</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_ONE</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_TWO</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_THREE</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_FOUR</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_FIVE</code> | <code>CASE_TEMPLATE_ARN</code> |
  /// <code>CASE_STATUS</code> | <code>CHANNEL</code> |
  /// <code>contact/segmentAttributes/connect:Subtype</code> |
  /// <code>FEATURE</code> | <code>FLOW_TYPE</code> |
  /// <code>FLOWS_NEXT_RESOURCE_ID</code> |
  /// <code>FLOWS_NEXT_RESOURCE_QUEUE_ID</code> |
  /// <code>FLOWS_OUTCOME_TYPE</code> | <code>FLOWS_RESOURCE_ID</code> |
  /// <code>INITIATION_METHOD</code> | <code>RESOURCE_PUBLISHED_TIMESTAMP</code>
  /// | <code>ROUTING_PROFILE</code> | <code>ROUTING_STEP_EXPRESSION</code> |
  /// <code>QUEUE</code> | <code>Q_CONNECT_ENABLED</code> |
  /// </li>
  /// <li>
  /// <b>Filter values</b>: A maximum of 100 filter values are supported in a
  /// single request. VOICE, CHAT, and TASK are valid <code>filterValue</code>
  /// for the CHANNEL filter key. They do not count towards limitation of 100
  /// filter values. For example, a GetMetricDataV2 request can filter by 50
  /// queues, 35 agents, and 15 routing profiles for a total of 100 filter
  /// values, along with 3 channel filters.
  ///
  /// <code>contact_lens_conversational_analytics</code> is a valid filterValue
  /// for the <code>FEATURE</code> filter key. It is available only to contacts
  /// analyzed by Contact Lens conversational analytics.
  ///
  /// <code>connect:Chat</code>, <code>connect:SMS</code>,
  /// <code>connect:Telephony</code>, and <code>connect:WebRTC</code> are valid
  /// <code>filterValue</code> examples (not exhaustive) for the
  /// <code>contact/segmentAttributes/connect:Subtype filter</code> key.
  ///
  /// <code>ROUTING_STEP_EXPRESSION</code> is a valid filter key with a filter
  /// value up to 3000 length. This filter is case and order sensitive. JSON
  /// string fields must be sorted in ascending order and JSON array order
  /// should be kept as is.
  ///
  /// <code>Q_CONNECT_ENABLED</code>. TRUE and FALSE are the only valid
  /// filterValues for the <code>Q_CONNECT_ENABLED</code> filter key.
  ///
  /// <ul>
  /// <li>
  /// TRUE includes all contacts that had Amazon Q in Connect enabled as part of
  /// the flow.
  /// </li>
  /// <li>
  /// FALSE includes all contacts that did not have Amazon Q in Connect enabled
  /// as part of the flow
  /// </li>
  /// </ul>
  /// This filter is available only for contact record-driven metrics.
  /// </li>
  /// </ul>
  ///
  /// Parameter [metrics] :
  /// The metrics to retrieve. Specify the name, groupings, and filters for each
  /// metric. The following historical metrics are available. For a description
  /// of each metric, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical
  /// metrics definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
  /// <dl> <dt>ABANDONMENT_RATE</dt> <dd>
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#abandonment-rate-historical">Abandonment
  /// rate</a>
  /// </dd> <dt>AGENT_ADHERENT_TIME</dt> <dd>
  /// This metric is available only in Amazon Web Services Regions where <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region">Forecasting,
  /// capacity planning, and scheduling</a> is available.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#adherent-time-historical">Adherent
  /// time</a>
  /// </dd> <dt>AGENT_ANSWER_RATE</dt> <dd>
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-answer-rate-historical">Agent
  /// answer rate</a>
  /// </dd> <dt>AGENT_NON_ADHERENT_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#non-adherent-time">Non-adherent
  /// time</a>
  /// </dd> <dt>AGENT_NON_RESPONSE</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-non-response">Agent
  /// non-response</a>
  /// </dd> <dt>AGENT_NON_RESPONSE_WITHOUT_CUSTOMER_ABANDONS</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// Data for this metric is available starting from October 1, 2023 0:00:00
  /// GMT.
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-nonresponse-no-abandon-historical">Agent
  /// non-response without customer abandons</a>
  /// </dd> <dt>AGENT_OCCUPANCY</dt> <dd>
  /// Unit: Percentage
  ///
  /// Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#occupancy-historical">Occupancy</a>
  /// </dd> <dt>AGENT_SCHEDULE_ADHERENCE</dt> <dd>
  /// This metric is available only in Amazon Web Services Regions where <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region">Forecasting,
  /// capacity planning, and scheduling</a> is available.
  ///
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#adherence-historical">Adherence</a>
  /// </dd> <dt>AGENT_SCHEDULED_TIME</dt> <dd>
  /// This metric is available only in Amazon Web Services Regions where <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/regions.html#optimization_region">Forecasting,
  /// capacity planning, and scheduling</a> is available.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#scheduled-time-historical">Scheduled
  /// time</a>
  /// </dd> <dt>AVG_ABANDON_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-queue-abandon-time-historical">Average
  /// queue abandon time</a>
  /// </dd> <dt>AVG_ACTIVE_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-active-time-historical">Average
  /// active time</a>
  /// </dd> <dt>AVG_AFTER_CONTACT_WORK_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-acw-time-historical">Average
  /// after contact work time</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_AGENT_CONNECTING_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>. For now, this
  /// metric only supports the following as <code>INITIATION_METHOD</code>:
  /// <code>INBOUND</code> | <code>OUTBOUND</code> | <code>CALLBACK</code> |
  /// <code>API</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#htm-avg-agent-api-connecting-time">Average
  /// agent API connecting time</a>
  /// <note>
  /// The <code>Negate</code> key in Metric Level Filters is not applicable for
  /// this metric.
  /// </note> </dd> <dt>AVG_AGENT_PAUSE_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-agent-pause-time-historical">Average
  /// agent pause time</a>
  /// </dd> <dt>AVG_CASE_RELATED_CONTACTS</dt> <dd>
  /// Unit: Count
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-contacts-case-historical">Average
  /// contacts per case</a>
  /// </dd> <dt>AVG_CASE_RESOLUTION_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-case-resolution-time-historical">Average
  /// case resolution time</a>
  /// </dd> <dt>AVG_CONTACT_DURATION</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-contact-duration-historical">Average
  /// contact duration</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_CONVERSATION_DURATION</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-conversation-duration-historical">Average
  /// conversation duration</a>
  /// </dd> <dt>AVG_FLOW_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Channel,
  /// contact/segmentAttributes/connect:Subtype, Flow type, Flows module
  /// resource ID, Flows next resource ID, Flows next resource queue ID, Flows
  /// outcome type, Flows resource ID, Initiation method, Resource published
  /// timestamp
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-flow-time-historical">Average
  /// flow time</a>
  /// </dd> <dt>AVG_GREETING_TIME_AGENT</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-greeting-time-agent-historical">Average
  /// agent greeting time</a>
  /// </dd> <dt>AVG_HANDLE_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype,
  /// RoutingStepExpression
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-handle-time-historical">Average
  /// handle time</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_HOLD_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-customer-hold-time-historical">Average
  /// customer hold time</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_HOLD_TIME_ALL_CONTACTS</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#avg-customer-hold-time-all-contacts-historical">Average
  /// customer hold time all contacts</a>
  /// </dd> <dt>AVG_HOLDS</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-holds-historical">Average
  /// holds</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_INTERACTION_AND_HOLD_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-agent-interaction-customer-hold-time-historical">Average
  /// agent interaction and customer hold time</a>
  /// </dd> <dt>AVG_INTERACTION_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Feature,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-agent-interaction-time-historical">Average
  /// agent interaction time</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_INTERRUPTIONS_AGENT</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-interruptions-agent-historical">Average
  /// agent interruptions</a>
  /// </dd> <dt>AVG_INTERRUPTION_TIME_AGENT</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-interruptions-time-agent-historical">Average
  /// agent interruption time</a>
  /// </dd> <dt>AVG_NON_TALK_TIME</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html##average-non-talk-time-historical">Average
  /// non-talk time</a>
  /// </dd> <dt>AVG_QUEUE_ANSWER_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Feature,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-queue-answer-time-historical">Average
  /// queue answer time</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>AVG_RESOLUTION_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-resolution-time-historical">Average
  /// resolution time</a>
  /// </dd> <dt>AVG_TALK_TIME</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-talk-time-historical">Average
  /// talk time</a>
  /// </dd> <dt>AVG_TALK_TIME_AGENT</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-talk-time-agent-historical">Average
  /// agent talk time</a>
  /// </dd> <dt>AVG_TALK_TIME_CUSTOMER</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#average-talk-time-customer-historical">Average
  /// customer talk time</a>
  /// </dd> <dt>CASES_CREATED</dt> <dd>
  /// Unit: Count
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html##cases-created-historical">Cases
  /// created</a>
  /// </dd> <dt>CONTACTS_ABANDONED</dt> <dd>
  /// Unit: Count
  ///
  /// Metric filter:
  ///
  /// <ul>
  /// <li>
  /// Valid values: <code>API</code>| <code>Incoming</code> |
  /// <code>Outbound</code> | <code>Transfer</code> | <code>Callback</code> |
  /// <code>Queue_Transfer</code>| <code>Disconnect</code>
  /// </li>
  /// </ul>
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype,
  /// RoutingStepExpression, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-abandoned-historical">Contact
  /// abandoned</a>
  /// </dd> <dt>CONTACTS_ABANDONED_IN_X</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// Threshold: For <code>ThresholdValue</code>, enter any whole number from 1
  /// to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must
  /// enter <code>LT</code> (for "Less than").
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-abandoned-x-historical">Contacts
  /// abandoned in X seconds</a>
  /// </dd> <dt>CONTACTS_ANSWERED_IN_X</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// Threshold: For <code>ThresholdValue</code>, enter any whole number from 1
  /// to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must
  /// enter <code>LT</code> (for "Less than").
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-answered-x-historical">Contacts
  /// answered in X seconds</a>
  /// </dd> <dt>CONTACTS_CREATED</dt> <dd>
  /// Unit: Count
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Feature,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-created-historical">Contacts
  /// created</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>CONTACTS_HANDLED</dt> <dd>
  /// Unit: Count
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>,
  /// <code>DISCONNECT_REASON</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype,
  /// RoutingStepExpression, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#api-contacts-handled-historical">API
  /// contacts handled</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>CONTACTS_HANDLED_BY_CONNECTED_TO_AGENT</dt> <dd>
  /// Unit: Count
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Agent, Agent Hierarchy,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-handled-by-connected-to-agent-historical">Contacts
  /// handled (connected to agent timestamp)</a>
  /// </dd> <dt>CONTACTS_HOLD_ABANDONS</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-handled-by-connected-to-agent-historical">Contacts
  /// hold disconnect</a>
  /// </dd> <dt>CONTACTS_ON_HOLD_AGENT_DISCONNECT</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-hold-agent-disconnect-historical">Contacts
  /// hold agent disconnect</a>
  /// </dd> <dt>CONTACTS_ON_HOLD_CUSTOMER_DISCONNECT</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-hold-customer-disconnect-historical">Contacts
  /// hold customer disconnect</a>
  /// </dd> <dt>CONTACTS_PUT_ON_HOLD</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-hold-customer-disconnect-historical">Contacts
  /// put on hold</a>
  /// </dd> <dt>CONTACTS_TRANSFERRED_OUT_EXTERNAL</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-external-historical">Contacts
  /// transferred out external</a>
  /// </dd> <dt>CONTACTS_TRANSFERRED_OUT_INTERNAL</dt> <dd>
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-internal-historical">Contacts
  /// transferred out internal</a>
  /// </dd> <dt>CONTACTS_QUEUED</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-queued-historical">Contacts
  /// queued</a>
  /// </dd> <dt>CONTACTS_QUEUED_BY_ENQUEUE</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Agent, Agent Hierarchy,
  /// contact/segmentAttributes/connect:Subtype
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-queued-by-enqueue-historical">Contacts
  /// queued (enqueue timestamp)</a>
  /// </dd> <dt>CONTACTS_RESOLVED_IN_X</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// Threshold: For <code>ThresholdValue</code> enter any whole number from 1
  /// to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must
  /// enter <code>LT</code> (for "Less than").
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-resolved-historical">Contacts
  /// resolved in X</a>
  /// </dd> <dt>CONTACTS_TRANSFERRED_OUT</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Feature, contact/segmentAttributes/connect:Subtype, Q in
  /// Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-historical">Contacts
  /// transferred out</a>
  /// <note>
  /// Feature is a valid filter but not a valid grouping.
  /// </note> </dd> <dt>CONTACTS_TRANSFERRED_OUT_BY_AGENT</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-by-agent-historical">Contacts
  /// transferred out by agent</a>
  /// </dd> <dt>CONTACTS_TRANSFERRED_OUT_FROM_QUEUE</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contacts-transferred-out-by-agent-historical">Contacts
  /// transferred out queue</a>
  /// </dd> <dt>CURRENT_CASES</dt> <dd>
  /// Unit: Count
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#current-cases-historical">Current
  /// cases</a>
  /// </dd> <dt>FLOWS_OUTCOME</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Channel,
  /// contact/segmentAttributes/connect:Subtype, Flow type, Flows module
  /// resource ID, Flows next resource ID, Flows next resource queue ID, Flows
  /// outcome type, Flows resource ID, Initiation method, Resource published
  /// timestamp
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#flows-outcome-historical">Flows
  /// outcome</a>
  /// </dd> <dt>FLOWS_STARTED</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Channel,
  /// contact/segmentAttributes/connect:Subtype, Flow type, Flows module
  /// resource ID, Flows resource ID, Initiation method, Resource published
  /// timestamp
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#flows-started-historical">Flows
  /// started</a>
  /// </dd> <dt>MAX_FLOW_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Channel,
  /// contact/segmentAttributes/connect:Subtype, Flow type, Flows module
  /// resource ID, Flows next resource ID, Flows next resource queue ID, Flows
  /// outcome type, Flows resource ID, Initiation method, Resource published
  /// timestamp
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#maximum-flow-time-historical">Maximum
  /// flow time</a>
  /// </dd> <dt>MAX_QUEUED_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#maximum-queued-time-historical">Maximum
  /// queued time</a>
  /// </dd> <dt>MIN_FLOW_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Channel,
  /// contact/segmentAttributes/connect:Subtype, Flow type, Flows module
  /// resource ID, Flows next resource ID, Flows next resource queue ID, Flows
  /// outcome type, Flows resource ID, Initiation method, Resource published
  /// timestamp
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#minimum-flow-time-historical">Minimum
  /// flow time</a>
  /// </dd> <dt>PERCENT_CASES_FIRST_CONTACT_RESOLVED</dt> <dd>
  /// Unit: Percent
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-resolved-first-contact-historical">Cases
  /// resolved on first contact</a>
  /// </dd> <dt>PERCENT_CONTACTS_STEP_EXPIRED</dt> <dd>
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, RoutingStepExpression
  ///
  /// UI name: Not available
  /// </dd> <dt>PERCENT_CONTACTS_STEP_JOINED</dt> <dd>
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, RoutingStepExpression
  ///
  /// UI name: Not available
  /// </dd> <dt>PERCENT_FLOWS_OUTCOME</dt> <dd>
  /// Unit: Percent
  ///
  /// Valid metric filter key: <code>FLOWS_OUTCOME_TYPE</code>
  ///
  /// Valid groupings and filters: Channel,
  /// contact/segmentAttributes/connect:Subtype, Flow type, Flows module
  /// resource ID, Flows next resource ID, Flows next resource queue ID, Flows
  /// outcome type, Flows resource ID, Initiation method, Resource published
  /// timestamp
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#flows-outcome-percentage-historical">Flows
  /// outcome percentage</a>.
  /// <note>
  /// The <code>FLOWS_OUTCOME_TYPE</code> is not a valid grouping.
  /// </note> </dd> <dt>PERCENT_NON_TALK_TIME</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Percentage
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#ntt-historical">Non-talk
  /// time percent</a>
  /// </dd> <dt>PERCENT_TALK_TIME</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Percentage
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#tt-historical">Talk
  /// time percent</a>
  /// </dd> <dt>PERCENT_TALK_TIME_AGENT</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Percentage
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#ttagent-historical">Agent
  /// talk time percent</a>
  /// </dd> <dt>PERCENT_TALK_TIME_CUSTOMER</dt> <dd>
  /// This metric is available only for contacts analyzed by Contact Lens
  /// conversational analytics.
  ///
  /// Unit: Percentage
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#ttcustomer-historical">Customer
  /// talk time percent</a>
  /// </dd> <dt>REOPENED_CASE_ACTIONS</dt> <dd>
  /// Unit: Count
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-reopened-historical">Cases
  /// reopened</a>
  /// </dd> <dt>RESOLVED_CASE_ACTIONS</dt> <dd>
  /// Unit: Count
  ///
  /// Required filter key: CASE_TEMPLATE_ARN
  ///
  /// Valid groupings and filters: CASE_TEMPLATE_ARN, CASE_STATUS
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#cases-resolved-historicall">Cases
  /// resolved</a>
  /// </dd> <dt>SERVICE_LEVEL</dt> <dd>
  /// You can include up to 20 SERVICE_LEVEL metrics in a request.
  ///
  /// Unit: Percent
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Q in Connect
  ///
  /// Threshold: For <code>ThresholdValue</code>, enter any whole number from 1
  /// to 604800 (inclusive), in seconds. For <code>Comparison</code>, you must
  /// enter <code>LT</code> (for "Less than").
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#service-level-historical">Service
  /// level X</a>
  /// </dd> <dt>STEP_CONTACTS_QUEUED</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, RoutingStepExpression
  ///
  /// UI name: Not available
  /// </dd> <dt>SUM_AFTER_CONTACT_WORK_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#acw-historical">After
  /// contact work time</a>
  /// </dd> <dt>SUM_CONNECTING_TIME_AGENT</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid metric filter key: <code>INITIATION_METHOD</code>. This metric only
  /// supports the following filter keys as <code>INITIATION_METHOD</code>:
  /// <code>INBOUND</code> | <code>OUTBOUND</code> | <code>CALLBACK</code> |
  /// <code>API</code>
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#htm-agent-api-connecting-time">Agent
  /// API connecting time</a>
  /// <note>
  /// The <code>Negate</code> key in Metric Level Filters is not applicable for
  /// this metric.
  /// </note> </dd> <dt>SUM_CONTACT_FLOW_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contact-flow-time-historical">Contact
  /// flow time</a>
  /// </dd> <dt>SUM_CONTACT_TIME_AGENT</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-on-contact-time-historical">Agent
  /// on contact time</a>
  /// </dd> <dt>SUM_CONTACTS_DISCONNECTED </dt> <dd>
  /// Valid metric filter key: <code>DISCONNECT_REASON</code>
  ///
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contact-disconnected-historical">Contact
  /// disconnected</a>
  /// </dd> <dt>SUM_ERROR_STATUS_TIME_AGENT</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#error-status-time-historical">Error
  /// status time</a>
  /// </dd> <dt>SUM_HANDLE_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#contact-handle-time-historical">Contact
  /// handle time</a>
  /// </dd> <dt>SUM_HOLD_TIME</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#customer-hold-time-historical">Customer
  /// hold time</a>
  /// </dd> <dt>SUM_IDLE_TIME_AGENT</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-idle-time-historica">Agent
  /// idle time</a>
  /// </dd> <dt>SUM_INTERACTION_AND_HOLD_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-interaction-hold-time-historical">Agent
  /// interaction and hold time</a>
  /// </dd> <dt>SUM_INTERACTION_TIME</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile, Agent, Agent
  /// Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#agent-interaction-time-historical">Agent
  /// interaction time</a>
  /// </dd> <dt>SUM_NON_PRODUCTIVE_TIME_AGENT</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#npt-historical">Non-Productive
  /// Time</a>
  /// </dd> <dt>SUM_ONLINE_TIME_AGENT</dt> <dd>
  /// Unit: Seconds
  ///
  /// Valid groupings and filters: Routing Profile, Agent, Agent Hierarchy
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#online-time-historical">Online
  /// time</a>
  /// </dd> <dt>SUM_RETRY_CALLBACK_ATTEMPTS</dt> <dd>
  /// Unit: Count
  ///
  /// Valid groupings and filters: Queue, Channel, Routing Profile,
  /// contact/segmentAttributes/connect:Subtype, Q in Connect
  ///
  /// UI name: <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html#callback-attempts-historical">Callback
  /// attempts</a>
  /// </dd> </dl>
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource. This includes the
  /// <code>instanceId</code> an Amazon Connect instance.
  ///
  /// Parameter [startTime] :
  /// The timestamp, in UNIX Epoch time format, at which to start the reporting
  /// interval for the retrieval of historical metrics data. The time must be
  /// before the end time timestamp. The start and end time depends on the
  /// <code>IntervalPeriod</code> selected. By default the time range between
  /// start and end time is 35 days. Historical metrics are available for 3
  /// months.
  ///
  /// Parameter [groupings] :
  /// The grouping applied to the metrics that are returned. For example, when
  /// results are grouped by queue, the metrics returned are grouped by queue.
  /// The values that are returned apply to the metrics for each queue. They are
  /// not aggregated for all queues.
  ///
  /// If no grouping is specified, a summary of all metrics is returned.
  ///
  /// Valid grouping keys: <code>AGENT</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_ONE</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_TWO</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_THREE</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_FOUR</code> |
  /// <code>AGENT_HIERARCHY_LEVEL_FIVE</code> | <code>CASE_TEMPLATE_ARN</code> |
  /// <code>CASE_STATUS</code> | <code>CHANNEL</code> |
  /// <code>contact/segmentAttributes/connect:Subtype</code> |
  /// <code>FLOWS_RESOURCE_ID</code> | <code>FLOWS_MODULE_RESOURCE_ID</code> |
  /// <code>FLOW_TYPE</code> | <code>FLOWS_OUTCOME_TYPE</code> |
  /// <code>INITIATION_METHOD</code> | <code>Q_CONNECT_ENABLED</code> |
  /// <code>QUEUE</code> | <code>RESOURCE_PUBLISHED_TIMESTAMP</code> |
  /// <code>ROUTING_PROFILE</code> | <code>ROUTING_STEP_EXPRESSION</code>
  ///
  /// Parameter [interval] :
  /// The interval period and timezone to apply to returned metrics.
  ///
  /// <ul>
  /// <li>
  /// <code>IntervalPeriod</code>: An aggregated grouping applied to request
  /// metrics. Valid <code>IntervalPeriod</code> values are:
  /// <code>FIFTEEN_MIN</code> | <code>THIRTY_MIN</code> | <code>HOUR</code> |
  /// <code>DAY</code> | <code>WEEK</code> | <code>TOTAL</code>.
  ///
  /// For example, if <code>IntervalPeriod</code> is selected
  /// <code>THIRTY_MIN</code>, <code>StartTime</code> and <code>EndTime</code>
  /// differs by 1 day, then Amazon Connect returns 48 results in the response.
  /// Each result is aggregated by the THIRTY_MIN period. By default Amazon
  /// Connect aggregates results based on the <code>TOTAL</code> interval
  /// period.
  ///
  /// The following list describes restrictions on <code>StartTime</code> and
  /// <code>EndTime</code> based on which <code>IntervalPeriod</code> is
  /// requested.
  ///
  /// <ul>
  /// <li>
  /// <code>FIFTEEN_MIN</code>: The difference between <code>StartTime</code>
  /// and <code>EndTime</code> must be less than 3 days.
  /// </li>
  /// <li>
  /// <code>THIRTY_MIN</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 3 days.
  /// </li>
  /// <li>
  /// <code>HOUR</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 3 days.
  /// </li>
  /// <li>
  /// <code>DAY</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 35 days.
  /// </li>
  /// <li>
  /// <code>WEEK</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 35 days.
  /// </li>
  /// <li>
  /// <code>TOTAL</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 35 days.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>TimeZone</code>: The timezone applied to requested metrics.
  /// </li>
  /// </ul>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<GetMetricDataV2Response> getMetricDataV2({
    required DateTime endTime,
    required List<FilterV2> filters,
    required List<MetricV2> metrics,
    required String resourceArn,
    required DateTime startTime,
    List<String>? groupings,
    IntervalDetails? interval,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'EndTime': unixTimestampToJson(endTime),
      'Filters': filters,
      'Metrics': metrics,
      'ResourceArn': resourceArn,
      'StartTime': unixTimestampToJson(startTime),
      if (groupings != null) 'Groupings': groupings,
      if (interval != null) 'Interval': interval,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/metrics/data',
      exceptionFnMap: _exceptionFns,
    );
    return GetMetricDataV2Response.fromJson(response);
  }

  /// Gets the prompt file.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [promptId] :
  /// A unique identifier for the prompt.
  Future<GetPromptFileResponse> getPromptFile({
    required String instanceId,
    required String promptId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/prompts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(promptId)}/file',
      exceptionFnMap: _exceptionFns,
    );
    return GetPromptFileResponse.fromJson(response);
  }

  /// Gets details about a specific task template in the specified Amazon
  /// Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [taskTemplateId] :
  /// A unique identifier for the task template.
  ///
  /// Parameter [snapshotVersion] :
  /// The system generated version of a task template that is associated with a
  /// task, when the task is created.
  Future<GetTaskTemplateResponse> getTaskTemplate({
    required String instanceId,
    required String taskTemplateId,
    String? snapshotVersion,
  }) async {
    final $query = <String, List<String>>{
      if (snapshotVersion != null) 'snapshotVersion': [snapshotVersion],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/task/template/${Uri.encodeComponent(taskTemplateId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetTaskTemplateResponse.fromJson(response);
  }

  /// Retrieves the current traffic distribution for a given traffic
  /// distribution group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [id] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  Future<GetTrafficDistributionResponse> getTrafficDistribution({
    required String id,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/traffic-distribution/${Uri.encodeComponent(id)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetTrafficDistributionResponse.fromJson(response);
  }

  /// Imports a claimed phone number from an external service, such as Amazon
  /// Pinpoint, into an Amazon Connect instance. You can call this API only in
  /// the same Amazon Web Services Region where the Amazon Connect instance was
  /// created.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [IdempotencyException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [sourcePhoneNumberArn] :
  /// The claimed phone number ARN being imported from the external service,
  /// such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks like the
  /// ARN of the phone number to import from Amazon Pinpoint.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [phoneNumberDescription] :
  /// The description of the phone number.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<ImportPhoneNumberResponse> importPhoneNumber({
    required String instanceId,
    required String sourcePhoneNumberArn,
    String? clientToken,
    String? phoneNumberDescription,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      'SourcePhoneNumberArn': sourcePhoneNumberArn,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (phoneNumberDescription != null)
        'PhoneNumberDescription': phoneNumberDescription,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/phone-number/import',
      exceptionFnMap: _exceptionFns,
    );
    return ImportPhoneNumberResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Lists agent statuses.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [agentStatusTypes] :
  /// Available agent status types.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListAgentStatusResponse> listAgentStatuses({
    required String instanceId,
    List<AgentStatusType>? agentStatusTypes,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (agentStatusTypes != null)
        'AgentStatusTypes': agentStatusTypes.map((e) => e.value).toList(),
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/agent-status/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListAgentStatusResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Lists the association status of requested dataset ID for a given Amazon
  /// Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [dataSetId] :
  /// The identifier of the dataset to get the association status.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListAnalyticsDataAssociationsResponse> listAnalyticsDataAssociations({
    required String instanceId,
    String? dataSetId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (dataSetId != null) 'DataSetId': [dataSetId],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/analytics-data/instance/${Uri.encodeComponent(instanceId)}/association',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListAnalyticsDataAssociationsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns a paginated list of all approved origins associated with the
  /// instance.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListApprovedOriginsResponse> listApprovedOrigins({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/approved-origins',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListApprovedOriginsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// For the specified version of Amazon Lex, returns a paginated list of all
  /// the Amazon Lex bots currently associated with the instance. Use this API
  /// to returns both Amazon Lex V1 and V2 bots.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [lexVersion] :
  /// The version of Amazon Lex or Amazon Lex V2.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListBotsResponse> listBots({
    required String instanceId,
    required LexVersion lexVersion,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      25,
    );
    final $query = <String, List<String>>{
      'lexVersion': [lexVersion.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/bots',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListBotsResponse.fromJson(response);
  }

  /// Lists contact evaluations in the specified Amazon Connect instance.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  /// <important>
  /// This is not expected to be set because the value returned in the previous
  /// response is always null.
  /// </important>
  Future<ListContactEvaluationsResponse> listContactEvaluations({
    required String contactId,
    required String instanceId,
    String? nextToken,
  }) async {
    final $query = <String, List<String>>{
      'contactId': [contactId],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/contact-evaluations/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListContactEvaluationsResponse.fromJson(response);
  }

  /// Provides information about the flow modules for the specified Amazon
  /// Connect instance.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [contactFlowModuleState] :
  /// The state of the flow module.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListContactFlowModulesResponse> listContactFlowModules({
    required String instanceId,
    ContactFlowModuleState? contactFlowModuleState,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (contactFlowModuleState != null)
        'state': [contactFlowModuleState.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contact-flow-modules-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListContactFlowModulesResponse.fromJson(response);
  }

  /// Provides information about the flows for the specified Amazon Connect
  /// instance.
  ///
  /// You can also create and update flows using the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon
  /// Connect Flow language</a>.
  ///
  /// For more information about flows, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-contact-flows.html">Flows</a>
  /// in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [contactFlowTypes] :
  /// The type of flow.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListContactFlowsResponse> listContactFlows({
    required String instanceId,
    List<ContactFlowType>? contactFlowTypes,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (contactFlowTypes != null)
        'contactFlowTypes': contactFlowTypes.map((e) => e.value).toList(),
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/contact-flows-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListContactFlowsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// For the specified <code>referenceTypes</code>, returns a list of
  /// references associated with the contact. <i>References</i> are links to
  /// documents that are related to a contact, such as emails, attachments, or
  /// URLs.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the initial contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [referenceTypes] :
  /// The type of reference.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  /// <important>
  /// This is not expected to be set, because the value returned in the previous
  /// response is always null.
  /// </important>
  Future<ListContactReferencesResponse> listContactReferences({
    required String contactId,
    required String instanceId,
    required List<ReferenceType> referenceTypes,
    String? nextToken,
  }) async {
    final $query = <String, List<String>>{
      'referenceTypes': referenceTypes.map((e) => e.value).toList(),
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/contact/references/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListContactReferencesResponse.fromJson(response);
  }

  /// Lists the default vocabularies for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [languageCode] :
  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListDefaultVocabulariesResponse> listDefaultVocabularies({
    required String instanceId,
    VocabularyLanguageCode? languageCode,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (languageCode != null) 'LanguageCode': languageCode.value,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/default-vocabulary-summary/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return ListDefaultVocabulariesResponse.fromJson(response);
  }

  /// Lists versions of an evaluation form in the specified Amazon Connect
  /// instance.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [evaluationFormId] :
  /// The unique identifier for the evaluation form.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListEvaluationFormVersionsResponse> listEvaluationFormVersions({
    required String evaluationFormId,
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/evaluation-forms/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationFormId)}/versions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListEvaluationFormVersionsResponse.fromJson(response);
  }

  /// Lists evaluation forms in the specified Amazon Connect instance.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListEvaluationFormsResponse> listEvaluationForms({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/evaluation-forms/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListEvaluationFormsResponse.fromJson(response);
  }

  /// List the flow association based on the filters.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<ListFlowAssociationsResponse> listFlowAssociations({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    ListFlowAssociationResourceType? resourceType,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (resourceType != null) 'ResourceType': [resourceType.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/flow-associations-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListFlowAssociationsResponse.fromJson(response);
  }

  /// Provides information about the hours of operation for the specified Amazon
  /// Connect instance.
  ///
  /// For more information about hours of operation, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/set-hours-operation.html">Set
  /// the Hours of Operation for a Queue</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListHoursOfOperationsResponse> listHoursOfOperations({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/hours-of-operations-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListHoursOfOperationsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns a paginated list of all attribute types for the given instance.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListInstanceAttributesResponse> listInstanceAttributes({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      7,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/attributes',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListInstanceAttributesResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns a paginated list of storage configs for the identified instance
  /// and resource type.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListInstanceStorageConfigsResponse> listInstanceStorageConfigs({
    required String instanceId,
    required InstanceStorageResourceType resourceType,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $query = <String, List<String>>{
      'resourceType': [resourceType.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/storage-configs',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListInstanceStorageConfigsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Return a list of instances which are in active state, creation-in-progress
  /// state, and failed state. Instances that aren't successfully created (they
  /// are in a failed state) are returned only for 24 hours after the
  /// CreateInstance API was invoked.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListInstancesResponse> listInstances({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListInstancesResponse.fromJson(response);
  }

  /// Provides summary information about the Amazon Web Services resource
  /// associations for the specified Amazon Connect instance.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [integrationArn] :
  /// The Amazon Resource Name (ARN) of the integration.
  ///
  /// Parameter [integrationType] :
  /// The integration type.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListIntegrationAssociationsResponse> listIntegrationAssociations({
    required String instanceId,
    String? integrationArn,
    IntegrationType? integrationType,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (integrationArn != null) 'integrationArn': [integrationArn],
      if (integrationType != null) 'integrationType': [integrationType.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/integration-associations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListIntegrationAssociationsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns a paginated list of all Lambda functions that display in the
  /// dropdown options in the relevant flow blocks.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListLambdaFunctionsResponse> listLambdaFunctions({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/lambda-functions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListLambdaFunctionsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns a paginated list of all the Amazon Lex V1 bots currently
  /// associated with the instance. To return both Amazon Lex V1 and V2 bots,
  /// use the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListBots.html">ListBots</a>
  /// API.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. If no value is
  /// specified, the default is 10.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListLexBotsResponse> listLexBots({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/lex-bots',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListLexBotsResponse.fromJson(response);
  }

  /// Provides information about the phone numbers for the specified Amazon
  /// Connect instance.
  ///
  /// For more information about phone numbers, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-center-phone-number.html">Set
  /// Up Phone Numbers for Your Contact Center</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  /// <important>
  /// <ul>
  /// <li>
  /// We recommend using <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html">ListPhoneNumbersV2</a>
  /// to return phone number types. ListPhoneNumbers doesn't support number
  /// types <code>UIFN</code>, <code>SHARED</code>, <code>THIRD_PARTY_TF</code>,
  /// and <code>THIRD_PARTY_DID</code>. While it returns numbers of those types,
  /// it incorrectly lists them as <code>TOLL_FREE</code> or <code>DID</code>.
  /// </li>
  /// <li>
  /// The phone number <code>Arn</code> value that is returned from each of the
  /// items in the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbers.html#connect-ListPhoneNumbers-response-PhoneNumberSummaryList">PhoneNumberSummaryList</a>
  /// cannot be used to tag phone number resources. It will fail with a
  /// <code>ResourceNotFoundException</code>. Instead, use the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html">ListPhoneNumbersV2</a>
  /// API. It returns the new phone number ARN that can be used to tag phone
  /// number resources.
  /// </li>
  /// </ul> </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [phoneNumberCountryCodes] :
  /// The ISO country code.
  ///
  /// Parameter [phoneNumberTypes] :
  /// The type of phone number.
  /// <note>
  /// We recommend using <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html">ListPhoneNumbersV2</a>
  /// to return phone number types. While ListPhoneNumbers returns number types
  /// <code>UIFN</code>, <code>SHARED</code>, <code>THIRD_PARTY_TF</code>, and
  /// <code>THIRD_PARTY_DID</code>, it incorrectly lists them as
  /// <code>TOLL_FREE</code> or <code>DID</code>.
  /// </note>
  Future<ListPhoneNumbersResponse> listPhoneNumbers({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    List<PhoneNumberCountryCode>? phoneNumberCountryCodes,
    List<PhoneNumberType>? phoneNumberTypes,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (phoneNumberCountryCodes != null)
        'phoneNumberCountryCodes':
            phoneNumberCountryCodes.map((e) => e.value).toList(),
      if (phoneNumberTypes != null)
        'phoneNumberTypes': phoneNumberTypes.map((e) => e.value).toList(),
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/phone-numbers-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListPhoneNumbersResponse.fromJson(response);
  }

  /// Lists phone numbers claimed to your Amazon Connect instance or traffic
  /// distribution group. If the provided <code>TargetArn</code> is a traffic
  /// distribution group, you can call this API in both Amazon Web Services
  /// Regions associated with traffic distribution group.
  ///
  /// For more information about phone numbers, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-center-phone-number.html">Set
  /// Up Phone Numbers for Your Contact Center</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  /// <note>
  /// <ul>
  /// <li>
  /// When given an instance ARN, <code>ListPhoneNumbersV2</code> returns only
  /// the phone numbers claimed to the instance.
  /// </li>
  /// <li>
  /// When given a traffic distribution group ARN
  /// <code>ListPhoneNumbersV2</code> returns only the phone numbers claimed to
  /// the traffic distribution group.
  /// </li>
  /// </ul> </note>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance that phone numbers are
  /// claimed to. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance. If
  /// both <code>TargetArn</code> and <code>InstanceId</code> are not provided,
  /// this API lists numbers claimed to all the Amazon Connect instances
  /// belonging to your account in the same AWS Region as the request.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [phoneNumberCountryCodes] :
  /// The ISO country code.
  ///
  /// Parameter [phoneNumberPrefix] :
  /// The prefix of the phone number. If provided, it must contain
  /// <code>+</code> as part of the country code.
  ///
  /// Parameter [phoneNumberTypes] :
  /// The type of phone number.
  ///
  /// Parameter [targetArn] :
  /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic
  /// distribution groups that phone number inbound traffic is routed through.
  /// If both <code>TargetArn</code> and <code>InstanceId</code> input are not
  /// provided, this API lists numbers claimed to all the Amazon Connect
  /// instances belonging to your account in the same Amazon Web Services Region
  /// as the request.
  Future<ListPhoneNumbersV2Response> listPhoneNumbersV2({
    String? instanceId,
    int? maxResults,
    String? nextToken,
    List<PhoneNumberCountryCode>? phoneNumberCountryCodes,
    String? phoneNumberPrefix,
    List<PhoneNumberType>? phoneNumberTypes,
    String? targetArn,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $payload = <String, dynamic>{
      if (instanceId != null) 'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (phoneNumberCountryCodes != null)
        'PhoneNumberCountryCodes':
            phoneNumberCountryCodes.map((e) => e.value).toList(),
      if (phoneNumberPrefix != null) 'PhoneNumberPrefix': phoneNumberPrefix,
      if (phoneNumberTypes != null)
        'PhoneNumberTypes': phoneNumberTypes.map((e) => e.value).toList(),
      if (targetArn != null) 'TargetArn': targetArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/phone-number/list',
      exceptionFnMap: _exceptionFns,
    );
    return ListPhoneNumbersV2Response.fromJson(response);
  }

  /// Lists predefined attributes for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListPredefinedAttributesResponse> listPredefinedAttributes({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/predefined-attributes/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListPredefinedAttributesResponse.fromJson(response);
  }

  /// Provides information about the prompts for the specified Amazon Connect
  /// instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListPromptsResponse> listPrompts({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/prompts-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListPromptsResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Lists the quick connects associated with a queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListQueueQuickConnectsResponse> listQueueQuickConnects({
    required String instanceId,
    required String queueId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/quick-connects',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListQueueQuickConnectsResponse.fromJson(response);
  }

  /// Provides information about the queues for the specified Amazon Connect
  /// instance.
  ///
  /// If you do not specify a <code>QueueTypes</code> parameter, both standard
  /// and agent queues are returned. This might cause an unexpected truncation
  /// of results if you have more than 1000 agents and you limit the number of
  /// results of the API call in code.
  ///
  /// For more information about queues, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-queues-standard-and-agent.html">Queues:
  /// Standard and Agent</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [queueTypes] :
  /// The type of queue.
  Future<ListQueuesResponse> listQueues({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    List<QueueType>? queueTypes,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (queueTypes != null)
        'queueTypes': queueTypes.map((e) => e.value).toList(),
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/queues-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListQueuesResponse.fromJson(response);
  }

  /// Provides information about the quick connects for the specified Amazon
  /// Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [quickConnectTypes] :
  /// The type of quick connect. In the Amazon Connect admin website, when you
  /// create a quick connect, you are prompted to assign one of the following
  /// types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
  Future<ListQuickConnectsResponse> listQuickConnects({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    List<QuickConnectType>? quickConnectTypes,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (quickConnectTypes != null)
        'QuickConnectTypes': quickConnectTypes.map((e) => e.value).toList(),
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/quick-connects/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListQuickConnectsResponse.fromJson(response);
  }

  /// Provides a list of analysis segments for a real-time analysis session.
  ///
  /// May throw [OutputTypeNotFoundException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [outputType] :
  /// The Contact Lens output type to be returned.
  ///
  /// Parameter [segmentTypes] :
  /// Enum with segment types . Each value corresponds to a segment type
  /// returned in the segments list of the API. Each segment type has its own
  /// structure. Different channels may have different sets of supported segment
  /// types.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListRealtimeContactAnalysisSegmentsV2Response>
      listRealtimeContactAnalysisSegmentsV2({
    required String contactId,
    required String instanceId,
    required RealTimeContactAnalysisOutputType outputType,
    required List<RealTimeContactAnalysisSegmentType> segmentTypes,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'OutputType': outputType.value,
      'SegmentTypes': segmentTypes.map((e) => e.value).toList(),
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact/list-real-time-analysis-segments-v2/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}',
      exceptionFnMap: _exceptionFns,
    );
    return ListRealtimeContactAnalysisSegmentsV2Response.fromJson(response);
  }

  /// Lists the queues associated with a routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListRoutingProfileQueuesResponse> listRoutingProfileQueues({
    required String instanceId,
    required String routingProfileId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/queues',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListRoutingProfileQueuesResponse.fromJson(response);
  }

  /// Provides summary information about the routing profiles for the specified
  /// Amazon Connect instance.
  ///
  /// For more information about routing profiles, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing.html">Routing
  /// Profiles</a> and <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/routing-profiles.html">Create
  /// a Routing Profile</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListRoutingProfilesResponse> listRoutingProfiles({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/routing-profiles-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListRoutingProfilesResponse.fromJson(response);
  }

  /// List all rules for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [eventSourceName] :
  /// The name of the event source.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [publishStatus] :
  /// The publish status of the rule.
  Future<ListRulesResponse> listRules({
    required String instanceId,
    EventSourceName? eventSourceName,
    int? maxResults,
    String? nextToken,
    RulePublishStatus? publishStatus,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      200,
    );
    final $query = <String, List<String>>{
      if (eventSourceName != null) 'eventSourceName': [eventSourceName.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (publishStatus != null) 'publishStatus': [publishStatus.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/rules/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListRulesResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Returns a paginated list of all security keys associated with the
  /// instance.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListSecurityKeysResponse> listSecurityKeys({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      2,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/security-keys',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListSecurityKeysResponse.fromJson(response);
  }

  /// Returns a list of third-party applications in a specific security profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileId] :
  /// The identifier for the security profle.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListSecurityProfileApplicationsResponse>
      listSecurityProfileApplications({
    required String instanceId,
    required String securityProfileId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/security-profiles-applications/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(securityProfileId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListSecurityProfileApplicationsResponse.fromJson(response);
  }

  /// Lists the permissions granted to a security profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileId] :
  /// The identifier for the security profle.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListSecurityProfilePermissionsResponse>
      listSecurityProfilePermissions({
    required String instanceId,
    required String securityProfileId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/security-profiles-permissions/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(securityProfileId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListSecurityProfilePermissionsResponse.fromJson(response);
  }

  /// Provides summary information about the security profiles for the specified
  /// Amazon Connect instance.
  ///
  /// For more information about security profiles, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/connect-security-profiles.html">Security
  /// Profiles</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListSecurityProfilesResponse> listSecurityProfiles({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/security-profiles-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListSecurityProfilesResponse.fromJson(response);
  }

  /// Lists the tags for the specified resource.
  ///
  /// For sample policies that use tags, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_id-based-policy-examples.html">Amazon
  /// Connect Identity-Based Policy Examples</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource. All Amazon Connect
  /// resources (instances, queues, flows, routing profiles, etc) have an ARN.
  /// To locate the ARN for an instance, for example, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">Find
  /// your Amazon Connect instance ID/ARN</a>.
  Future<ListTagsForResourceResponse> listTagsForResource({
    required String resourceArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/tags/${Uri.encodeComponent(resourceArn)}',
      exceptionFnMap: _exceptionFns,
    );
    return ListTagsForResourceResponse.fromJson(response);
  }

  /// Lists task templates for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  /// <important>
  /// It is not expected that you set this.
  /// </important>
  ///
  /// Parameter [name] :
  /// The name of the task template.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  /// <important>
  /// It is not expected that you set this because the value returned in the
  /// previous response is always null.
  /// </important>
  ///
  /// Parameter [status] :
  /// Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a
  /// task to refer to it. Tasks can only be created from <code>ACTIVE</code>
  /// templates. If a template is marked as <code>INACTIVE</code>, then a task
  /// that refers to this template cannot be created.
  Future<ListTaskTemplatesResponse> listTaskTemplates({
    required String instanceId,
    int? maxResults,
    String? name,
    String? nextToken,
    TaskTemplateStatus? status,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (name != null) 'name': [name],
      if (nextToken != null) 'nextToken': [nextToken],
      if (status != null) 'status': [status.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/task/template',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTaskTemplatesResponse.fromJson(response);
  }

  /// Lists traffic distribution group users.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [trafficDistributionGroupId] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListTrafficDistributionGroupUsersResponse>
      listTrafficDistributionGroupUsers({
    required String trafficDistributionGroupId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/traffic-distribution-group/${Uri.encodeComponent(trafficDistributionGroupId)}/user',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTrafficDistributionGroupUsersResponse.fromJson(response);
  }

  /// Lists traffic distribution groups.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListTrafficDistributionGroupsResponse> listTrafficDistributionGroups({
    String? instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $query = <String, List<String>>{
      if (instanceId != null) 'instanceId': [instanceId],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/traffic-distribution-groups',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTrafficDistributionGroupsResponse.fromJson(response);
  }

  /// Lists the use cases for the integration association.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [integrationAssociationId] :
  /// The identifier for the integration association.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListUseCasesResponse> listUseCases({
    required String instanceId,
    required String integrationAssociationId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/integration-associations/${Uri.encodeComponent(integrationAssociationId)}/use-cases',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListUseCasesResponse.fromJson(response);
  }

  /// Provides summary information about the hierarchy groups for the specified
  /// Amazon Connect instance.
  ///
  /// For more information about agent hierarchies, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/agent-hierarchy.html">Set
  /// Up Agent Hierarchies</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListUserHierarchyGroupsResponse> listUserHierarchyGroups({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/user-hierarchy-groups-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListUserHierarchyGroupsResponse.fromJson(response);
  }

  /// Lists proficiencies associated with a user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListUserProficienciesResponse> listUserProficiencies({
    required String instanceId,
    required String userId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/proficiencies',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListUserProficienciesResponse.fromJson(response);
  }

  /// Provides summary information about the users for the specified Amazon
  /// Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListUsersResponse> listUsers({
    required String instanceId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      1000,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/users-summary/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListUsersResponse.fromJson(response);
  }

  /// Returns all the available versions for the specified Amazon Connect
  /// instance and view identifier.
  ///
  /// Results will be sorted from highest to lowest.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [viewId] :
  /// The identifier of the view. Both <code>ViewArn</code> and
  /// <code>ViewId</code> can be used.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  Future<ListViewVersionsResponse> listViewVersions({
    required String instanceId,
    required String viewId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}/versions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListViewVersionsResponse.fromJson(response);
  }

  /// Returns views in the given instance.
  ///
  /// Results are sorted primarily by type, and secondarily by name.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page. The default MaxResult
  /// size is 100.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [type] :
  /// The type of the view.
  Future<ListViewsResponse> listViews({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    ViewType? type,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (type != null) 'type': [type.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/views/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListViewsResponse.fromJson(response);
  }

  /// Initiates silent monitoring of a contact. The Contact Control Panel (CCP)
  /// of the user specified by <i>userId</i> will be set to silent monitoring
  /// mode on the contact.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [IdempotencyException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  ///
  /// Parameter [allowedMonitorCapabilities] :
  /// Specify which monitoring actions the user is allowed to take. For example,
  /// whether the user is allowed to escalate from silent monitoring to barge.
  /// AllowedMonitorCapabilities is required if barge is enabled.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<MonitorContactResponse> monitorContact({
    required String contactId,
    required String instanceId,
    required String userId,
    List<MonitorCapability>? allowedMonitorCapabilities,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      'UserId': userId,
      if (allowedMonitorCapabilities != null)
        'AllowedMonitorCapabilities':
            allowedMonitorCapabilities.map((e) => e.value).toList(),
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/monitor',
      exceptionFnMap: _exceptionFns,
    );
    return MonitorContactResponse.fromJson(response);
  }

  /// Allows pausing an ongoing task contact.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [ConflictException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the
  /// <code>instanceId</code> in the ARN of the instance.
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  Future<void> pauseContact({
    required String contactId,
    required String instanceId,
    String? contactFlowId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/pause',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Changes the current status of a user or agent in Amazon Connect. If the
  /// agent is currently handling a contact, this sets the agent's next status.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/metrics-agent-status.html">Agent
  /// status</a> and <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/set-next-status.html">Set
  /// your next status</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [agentStatusId] :
  /// The identifier of the agent status.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user.
  Future<void> putUserStatus({
    required String agentStatusId,
    required String instanceId,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'AgentStatusId': agentStatusId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/status',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Releases a phone number previously claimed to an Amazon Connect instance
  /// or traffic distribution group. You can call this API only in the Amazon
  /// Web Services Region where the number was claimed.
  /// <important>
  /// To release phone numbers from a traffic distribution group, use the
  /// <code>ReleasePhoneNumber</code> API, not the Amazon Connect admin website.
  ///
  /// After releasing a phone number, the phone number enters into a cooldown
  /// period for up to 180 days. It cannot be searched for or claimed again
  /// until the period has ended. If you accidentally release a phone number,
  /// contact Amazon Web Services Support.
  /// </important>
  /// If you plan to claim and release numbers frequently, contact us for a
  /// service quota exception. Otherwise, it is possible you will be blocked
  /// from claiming and releasing any more numbers until up to 180 days past the
  /// oldest number released has expired.
  ///
  /// By default you can claim and release up to 200% of your maximum number of
  /// active phone numbers. If you claim and release phone numbers using the UI
  /// or API during a rolling 180 day cycle that exceeds 200% of your phone
  /// number service level quota, you will be blocked from claiming any more
  /// numbers until 180 days past the oldest number released has expired.
  ///
  /// For example, if you already have 99 claimed numbers and a service level
  /// quota of 99 phone numbers, and in any 180 day period you release 99, claim
  /// 99, and then release 99, you will have exceeded the 200% limit. At that
  /// point you are blocked from claiming any more numbers until you open an
  /// Amazon Web Services support ticket.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceInUseException].
  /// May throw [IdempotencyException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [phoneNumberId] :
  /// A unique identifier for the phone number.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<void> releasePhoneNumber({
    required String phoneNumberId,
    String? clientToken,
  }) async {
    final $query = <String, List<String>>{
      if (clientToken != null) 'clientToken': [clientToken],
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/phone-number/${Uri.encodeComponent(phoneNumberId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Replicates an Amazon Connect instance in the specified Amazon Web Services
  /// Region and copies configuration information for Amazon Connect resources
  /// across Amazon Web Services Regions.
  ///
  /// For more information about replicating an Amazon Connect instance, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/create-replica-connect-instance.html">Create
  /// a replica of your existing Amazon Connect instance</a> in the <i>Amazon
  /// Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotReadyException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance. You
  /// can provide the <code>InstanceId</code>, or the entire ARN.
  ///
  /// Parameter [replicaAlias] :
  /// The alias for the replicated instance. The <code>ReplicaAlias</code> must
  /// be unique.
  ///
  /// Parameter [replicaRegion] :
  /// The Amazon Web Services Region where to replicate the Amazon Connect
  /// instance.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<ReplicateInstanceResponse> replicateInstance({
    required String instanceId,
    required String replicaAlias,
    required String replicaRegion,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'ReplicaAlias': replicaAlias,
      'ReplicaRegion': replicaRegion,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/instance/${Uri.encodeComponent(instanceId)}/replicate',
      exceptionFnMap: _exceptionFns,
    );
    return ReplicateInstanceResponse.fromJson(response);
  }

  /// Allows resuming a task contact in a paused state.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the
  /// <code>instanceId</code> in the ARN of the instance.
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  Future<void> resumeContact({
    required String contactId,
    required String instanceId,
    String? contactFlowId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/resume',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// When a contact is being recorded, and the recording has been suspended
  /// using SuspendContactRecording, this API resumes recording whatever
  /// recording is selected in the flow configuration: call, screen, or both. If
  /// only call recording or only screen recording is enabled, then it would
  /// resume.
  ///
  /// Voice and screen recordings are supported.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [initialContactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> resumeContactRecording({
    required String contactId,
    required String initialContactId,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InitialContactId': initialContactId,
      'InstanceId': instanceId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/resume-recording',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Searches for available phone numbers that you can claim to your Amazon
  /// Connect instance or traffic distribution group. If the provided
  /// <code>TargetArn</code> is a traffic distribution group, you can call this
  /// API in both Amazon Web Services Regions associated with the traffic
  /// distribution group.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [phoneNumberCountryCode] :
  /// The ISO country code.
  ///
  /// Parameter [phoneNumberType] :
  /// The type of phone number.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance that phone numbers are
  /// claimed to. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance. You
  /// must enter <code>InstanceId</code> or <code>TargetArn</code>.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [phoneNumberPrefix] :
  /// The prefix of the phone number. If provided, it must contain
  /// <code>+</code> as part of the country code.
  ///
  /// Parameter [targetArn] :
  /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic
  /// distribution groups that phone number inbound traffic is routed through.
  /// You must enter <code>InstanceId</code> or <code>TargetArn</code>.
  Future<SearchAvailablePhoneNumbersResponse> searchAvailablePhoneNumbers({
    required PhoneNumberCountryCode phoneNumberCountryCode,
    required PhoneNumberType phoneNumberType,
    String? instanceId,
    int? maxResults,
    String? nextToken,
    String? phoneNumberPrefix,
    String? targetArn,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $payload = <String, dynamic>{
      'PhoneNumberCountryCode': phoneNumberCountryCode.value,
      'PhoneNumberType': phoneNumberType.value,
      if (instanceId != null) 'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (phoneNumberPrefix != null) 'PhoneNumberPrefix': phoneNumberPrefix,
      if (targetArn != null) 'TargetArn': targetArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/phone-number/search-available',
      exceptionFnMap: _exceptionFns,
    );
    return SearchAvailablePhoneNumbersResponse.fromJson(response);
  }

  /// Searches the flow modules in an Amazon Connect instance, with optional
  /// filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return contact flow modules.
  /// <note>
  /// The <code>name</code> and <code>description</code> fields support
  /// "contains" queries with a minimum of 2 characters and a maximum of 25
  /// characters. Any queries with character lengths outside of this range will
  /// result in invalid results.
  /// </note>
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchContactFlowModulesResponse> searchContactFlowModules({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    ContactFlowModuleSearchCriteria? searchCriteria,
    ContactFlowModuleSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-contact-flow-modules',
      exceptionFnMap: _exceptionFns,
    );
    return SearchContactFlowModulesResponse.fromJson(response);
  }

  /// Searches the contact flows in an Amazon Connect instance, with optional
  /// filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return flows.
  /// <note>
  /// The <code>name</code> and <code>description</code> fields support
  /// "contains" queries with a minimum of 2 characters and a maximum of 25
  /// characters. Any queries with character lengths outside of this range will
  /// result in invalid results.
  /// </note>
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchContactFlowsResponse> searchContactFlows({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    ContactFlowSearchCriteria? searchCriteria,
    ContactFlowSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-contact-flows',
      exceptionFnMap: _exceptionFns,
    );
    return SearchContactFlowsResponse.fromJson(response);
  }

  /// Searches contacts in an Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of Amazon Connect instance. You can find the instance ID in
  /// the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [timeRange] :
  /// Time range that you want to search results.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return contacts.
  ///
  /// Parameter [sort] :
  /// Specifies a field to sort by and a sort order.
  Future<SearchContactsResponse> searchContacts({
    required String instanceId,
    required SearchContactsTimeRange timeRange,
    int? maxResults,
    String? nextToken,
    SearchCriteria? searchCriteria,
    Sort? sort,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      'TimeRange': timeRange,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (sort != null) 'Sort': sort,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-contacts',
      exceptionFnMap: _exceptionFns,
    );
    return SearchContactsResponse.fromJson(response);
  }

  /// Searches the hours of operation in an Amazon Connect instance, with
  /// optional filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return hours of operations.
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchHoursOfOperationsResponse> searchHoursOfOperations({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    HoursOfOperationSearchCriteria? searchCriteria,
    HoursOfOperationSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-hours-of-operations',
      exceptionFnMap: _exceptionFns,
    );
    return SearchHoursOfOperationsResponse.fromJson(response);
  }

  /// Predefined attributes that meet certain criteria.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return predefined attributes.
  Future<SearchPredefinedAttributesResponse> searchPredefinedAttributes({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    PredefinedAttributeSearchCriteria? searchCriteria,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-predefined-attributes',
      exceptionFnMap: _exceptionFns,
    );
    return SearchPredefinedAttributesResponse.fromJson(response);
  }

  /// Searches prompts in an Amazon Connect instance, with optional filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return prompts.
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchPromptsResponse> searchPrompts({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    PromptSearchCriteria? searchCriteria,
    PromptSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-prompts',
      exceptionFnMap: _exceptionFns,
    );
    return SearchPromptsResponse.fromJson(response);
  }

  /// Searches queues in an Amazon Connect instance, with optional filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return queues.
  /// <note>
  /// The <code>name</code> and <code>description</code> fields support
  /// "contains" queries with a minimum of 2 characters and a maximum of 25
  /// characters. Any queries with character lengths outside of this range will
  /// throw invalid results.
  /// </note>
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchQueuesResponse> searchQueues({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    QueueSearchCriteria? searchCriteria,
    QueueSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      500,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-queues',
      exceptionFnMap: _exceptionFns,
    );
    return SearchQueuesResponse.fromJson(response);
  }

  /// Searches quick connects in an Amazon Connect instance, with optional
  /// filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return quick connects.
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchQuickConnectsResponse> searchQuickConnects({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    QuickConnectSearchCriteria? searchCriteria,
    QuickConnectSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-quick-connects',
      exceptionFnMap: _exceptionFns,
    );
    return SearchQuickConnectsResponse.fromJson(response);
  }

  /// Searches tags used in an Amazon Connect instance using optional search
  /// criteria.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [MaximumResultReturnedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [resourceTypes] :
  /// The list of resource types to be used to search tags from. If not provided
  /// or if any empty list is provided, this API will search from all supported
  /// resource types.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return tags.
  Future<SearchResourceTagsResponse> searchResourceTags({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    List<String>? resourceTypes,
    ResourceTagsSearchCriteria? searchCriteria,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (resourceTypes != null) 'ResourceTypes': resourceTypes,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-resource-tags',
      exceptionFnMap: _exceptionFns,
    );
    return SearchResourceTagsResponse.fromJson(response);
  }

  /// Searches routing profiles in an Amazon Connect instance, with optional
  /// filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return routing profiles.
  /// <note>
  /// The <code>name</code> and <code>description</code> fields support
  /// "contains" queries with a minimum of 2 characters and a maximum of 25
  /// characters. Any queries with character lengths outside of this range will
  /// throw invalid results.
  /// </note>
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchRoutingProfilesResponse> searchRoutingProfiles({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    RoutingProfileSearchCriteria? searchCriteria,
    RoutingProfileSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      500,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-routing-profiles',
      exceptionFnMap: _exceptionFns,
    );
    return SearchRoutingProfilesResponse.fromJson(response);
  }

  /// Searches security profiles in an Amazon Connect instance, with optional
  /// filtering.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchCriteria] :
  /// The search criteria to be used to return security profiles.
  /// <note>
  /// The <code>name</code> field support "contains" queries with a minimum of 2
  /// characters and maximum of 25 characters. Any queries with character
  /// lengths outside of this range will throw invalid results.
  /// </note> <note>
  /// The currently supported value for <code>FieldName</code>:
  /// <code>name</code>
  /// </note>
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchSecurityProfilesResponse> searchSecurityProfiles({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    SecurityProfileSearchCriteria? searchCriteria,
    SecurityProfilesSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-security-profiles',
      exceptionFnMap: _exceptionFns,
    );
    return SearchSecurityProfilesResponse.fromJson(response);
  }

  /// Searches users in an Amazon Connect instance, with optional filtering.
  /// <note>
  /// <code>AfterContactWorkTimeLimit</code> is returned in milliseconds.
  /// </note>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  /// <note>
  /// InstanceID is a required field. The "Required: No" below is incorrect.
  /// </note>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [searchFilter] :
  /// Filters to be applied to search results.
  Future<SearchUsersResponse> searchUsers({
    required String instanceId,
    int? maxResults,
    String? nextToken,
    UserSearchCriteria? searchCriteria,
    UserSearchFilter? searchFilter,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      500,
    );
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (searchCriteria != null) 'SearchCriteria': searchCriteria,
      if (searchFilter != null) 'SearchFilter': searchFilter,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/search-users',
      exceptionFnMap: _exceptionFns,
    );
    return SearchUsersResponse.fromJson(response);
  }

  /// Searches for vocabularies within a specific Amazon Connect instance using
  /// <code>State</code>, <code>NameStartsWith</code>, and
  /// <code>LanguageCode</code>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [languageCode] :
  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return per page.
  ///
  /// Parameter [nameStartsWith] :
  /// The starting pattern of the name of the vocabulary.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  ///
  /// Parameter [state] :
  /// The current state of the custom vocabulary.
  Future<SearchVocabulariesResponse> searchVocabularies({
    required String instanceId,
    VocabularyLanguageCode? languageCode,
    int? maxResults,
    String? nameStartsWith,
    String? nextToken,
    VocabularyState? state,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (languageCode != null) 'LanguageCode': languageCode.value,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nameStartsWith != null) 'NameStartsWith': nameStartsWith,
      if (nextToken != null) 'NextToken': nextToken,
      if (state != null) 'State': state.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/vocabulary-summary/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return SearchVocabulariesResponse.fromJson(response);
  }

  /// Processes chat integration events from Amazon Web Services or external
  /// integrations to Amazon Connect. A chat integration event includes:
  ///
  /// <ul>
  /// <li>
  /// SourceId, DestinationId, and Subtype: a set of identifiers, uniquely
  /// representing a chat
  /// </li>
  /// <li>
  /// ChatEvent: details of the chat action to perform such as sending a
  /// message, event, or disconnecting from a chat
  /// </li>
  /// </ul>
  /// When a chat integration event is sent with chat identifiers that do not
  /// map to an active chat contact, a new chat contact is also created before
  /// handling chat action.
  ///
  /// Access to this API is currently restricted to Amazon Pinpoint for
  /// supporting SMS integration.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [destinationId] :
  /// Chat system identifier, used in part to uniquely identify chat. This is
  /// associated with the Amazon Connect instance and flow to be used to start
  /// chats. For SMS, this is the phone number destination of inbound SMS
  /// messages represented by an Amazon Pinpoint phone number ARN.
  ///
  /// Parameter [event] :
  /// Chat integration event payload
  ///
  /// Parameter [sourceId] :
  /// External identifier of chat customer participant, used in part to uniquely
  /// identify a chat. For SMS, this is the E164 phone number of the chat
  /// customer participant.
  ///
  /// Parameter [newSessionDetails] :
  /// Contact properties to apply when starting a new chat. If the integration
  /// event is handled with an existing chat, this is ignored.
  ///
  /// Parameter [subtype] :
  /// Classification of a channel. This is used in part to uniquely identify
  /// chat.
  ///
  /// Valid value: <code>["connect:sms"]</code>
  Future<SendChatIntegrationEventResponse> sendChatIntegrationEvent({
    required String destinationId,
    required ChatEvent event,
    required String sourceId,
    NewSessionDetails? newSessionDetails,
    String? subtype,
  }) async {
    final $payload = <String, dynamic>{
      'DestinationId': destinationId,
      'Event': event,
      'SourceId': sourceId,
      if (newSessionDetails != null) 'NewSessionDetails': newSessionDetails,
      if (subtype != null) 'Subtype': subtype,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/chat-integration-event',
      exceptionFnMap: _exceptionFns,
    );
    return SendChatIntegrationEventResponse.fromJson(response);
  }

  /// Provides a pre-signed Amazon S3 URL in response for uploading your
  /// content.
  /// <important>
  /// You may only use this API to upload attachments to a <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Connect
  /// Case</a>.
  /// </important>
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceConflictException].
  /// May throw [ServiceQuotaExceededException].
  ///
  /// Parameter [associatedResourceArn] :
  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  /// <note>
  /// This value must be a valid ARN.
  /// </note>
  ///
  /// Parameter [fileName] :
  /// A case-sensitive name of the attached file being uploaded.
  ///
  /// Parameter [fileSizeInBytes] :
  /// The size of the attached file in bytes.
  ///
  /// Parameter [fileUseCaseType] :
  /// The use case for the file.
  ///
  /// Parameter [instanceId] :
  /// The unique identifier of the Connect instance.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [createdBy] :
  /// Represents the identity that created the file.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, <code>{ "Tags": {"key1":"value1", "key2":"value2"} }</code>.
  ///
  /// Parameter [urlExpiryInSeconds] :
  /// Optional override for the expiry of the pre-signed S3 URL in seconds. The
  /// default value is 300.
  Future<StartAttachedFileUploadResponse> startAttachedFileUpload({
    required String associatedResourceArn,
    required String fileName,
    required int fileSizeInBytes,
    required FileUseCaseType fileUseCaseType,
    required String instanceId,
    String? clientToken,
    CreatedByInfo? createdBy,
    Map<String, String>? tags,
    int? urlExpiryInSeconds,
  }) async {
    _s.validateNumRange(
      'fileSizeInBytes',
      fileSizeInBytes,
      1,
      1152921504606846976,
      isRequired: true,
    );
    _s.validateNumRange(
      'urlExpiryInSeconds',
      urlExpiryInSeconds,
      5,
      300,
    );
    final $query = <String, List<String>>{
      'associatedResourceArn': [associatedResourceArn],
    };
    final $payload = <String, dynamic>{
      'FileName': fileName,
      'FileSizeInBytes': fileSizeInBytes,
      'FileUseCaseType': fileUseCaseType.value,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (createdBy != null) 'CreatedBy': createdBy,
      if (tags != null) 'Tags': tags,
      if (urlExpiryInSeconds != null) 'UrlExpiryInSeconds': urlExpiryInSeconds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/attached-files/${Uri.encodeComponent(instanceId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return StartAttachedFileUploadResponse.fromJson(response);
  }

  /// Initiates a flow to start a new chat for the customer. Response of this
  /// API provides a token required to obtain credentials from the <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a>
  /// API in the Amazon Connect Participant Service.
  ///
  /// When a new chat contact is successfully created, clients must subscribe to
  /// the participant’s connection for the created chat within 5 minutes. This
  /// is achieved by invoking <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a>
  /// with WEBSOCKET and CONNECTION_CREDENTIALS.
  ///
  /// A 429 error occurs in the following situations:
  ///
  /// <ul>
  /// <li>
  /// API rate limit is exceeded. API TPS throttling returns a
  /// <code>TooManyRequests</code> exception.
  /// </li>
  /// <li>
  /// The <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">quota
  /// for concurrent active chats</a> is exceeded. Active chat throttling
  /// returns a <code>LimitExceededException</code>.
  /// </li>
  /// </ul>
  /// If you use the <code>ChatDurationInMinutes</code> parameter and receive a
  /// 400 error, your account may not support the ability to configure custom
  /// chat durations. For more information, contact Amazon Web Services Support.
  ///
  /// For more information about chat, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat.html">Chat</a>
  /// in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow for initiating the chat. To see the
  /// ContactFlowId in the Amazon Connect admin website, on the navigation menu
  /// go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow
  /// page, under the name of the flow, choose <b>Show additional flow
  /// information</b>. The ContactFlowId is the last part of the ARN, shown here
  /// in bold:
  ///
  /// arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [participantDetails] :
  /// Information identifying the participant.
  ///
  /// Parameter [attributes] :
  /// A custom key-value pair using an attribute map. The attributes are
  /// standard Amazon Connect attributes. They can be accessed in flows just
  /// like any other contact attributes.
  ///
  /// There can be up to 32,768 UTF-8 bytes across all key-value pairs per
  /// contact. Attribute keys can include only alphanumeric, dash, and
  /// underscore characters.
  ///
  /// Parameter [chatDurationInMinutes] :
  /// The total duration of the newly started chat session. If not specified,
  /// the chat session duration defaults to 25 hour. The minimum configurable
  /// time is 60 minutes. The maximum configurable time is 10,080 minutes (7
  /// days).
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [initialMessage] :
  /// The initial message to be sent to the newly created chat. If you have a
  /// Lex bot in your flow, the initial message is not delivered to the Lex bot.
  ///
  /// Parameter [persistentChat] :
  /// Enable persistent chats. For more information about enabling persistent
  /// chat, and for example use cases and how to configure for them, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable
  /// persistent chat</a>.
  ///
  /// Parameter [relatedContactId] :
  /// The unique identifier for an Amazon Connect contact. This identifier is
  /// related to the chat starting.
  /// <note>
  /// You cannot provide data for both RelatedContactId and PersistentChat.
  /// </note>
  ///
  /// Parameter [segmentAttributes] :
  /// A set of system defined key-value pairs stored on individual contact
  /// segments using an attribute map. The attributes are standard Amazon
  /// Connect attributes. They can be accessed in flows.
  ///
  /// Attribute keys can include only alphanumeric, -, and _.
  ///
  /// This field can be used to show channel subtype, such as
  /// <code>connect:Guide</code>.
  /// <note>
  /// The types
  /// <code>application/vnd.amazonaws.connect.message.interactive</code> and
  /// <code>application/vnd.amazonaws.connect.message.interactive.response</code>
  /// must be present in the SupportedMessagingContentTypes field of this API in
  /// order to set <code>SegmentAttributes</code> as {<code> "connect:Subtype":
  /// {"valueString" : "connect:Guide" }}</code>.
  /// </note>
  ///
  /// Parameter [supportedMessagingContentTypes] :
  /// The supported chat message content types. Supported types are
  /// <code>text/plain</code>, <code>text/markdown</code>,
  /// <code>application/json</code>,
  /// <code>application/vnd.amazonaws.connect.message.interactive</code>, and
  /// <code>application/vnd.amazonaws.connect.message.interactive.response</code>.
  ///
  /// Content types must always contain <code>text/plain</code>. You can then
  /// put any other supported type in the list. For example, all the following
  /// lists are valid because they contain <code>text/plain</code>:
  /// <code>[text/plain, text/markdown, application/json]</code>,
  /// <code>[text/markdown, text/plain]</code>, <code>[text/plain,
  /// application/json,
  /// application/vnd.amazonaws.connect.message.interactive.response]</code>.
  /// <note>
  /// The type
  /// <code>application/vnd.amazonaws.connect.message.interactive</code> is
  /// required to use the <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/show-view-block.html">Show
  /// view</a> flow block.
  /// </note>
  Future<StartChatContactResponse> startChatContact({
    required String contactFlowId,
    required String instanceId,
    required ParticipantDetails participantDetails,
    Map<String, String>? attributes,
    int? chatDurationInMinutes,
    String? clientToken,
    ChatMessage? initialMessage,
    PersistentChat? persistentChat,
    String? relatedContactId,
    Map<String, SegmentAttributeValue>? segmentAttributes,
    List<String>? supportedMessagingContentTypes,
  }) async {
    _s.validateNumRange(
      'chatDurationInMinutes',
      chatDurationInMinutes,
      60,
      10080,
    );
    final $payload = <String, dynamic>{
      'ContactFlowId': contactFlowId,
      'InstanceId': instanceId,
      'ParticipantDetails': participantDetails,
      if (attributes != null) 'Attributes': attributes,
      if (chatDurationInMinutes != null)
        'ChatDurationInMinutes': chatDurationInMinutes,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (initialMessage != null) 'InitialMessage': initialMessage,
      if (persistentChat != null) 'PersistentChat': persistentChat,
      if (relatedContactId != null) 'RelatedContactId': relatedContactId,
      if (segmentAttributes != null) 'SegmentAttributes': segmentAttributes,
      if (supportedMessagingContentTypes != null)
        'SupportedMessagingContentTypes': supportedMessagingContentTypes,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact/chat',
      exceptionFnMap: _exceptionFns,
    );
    return StartChatContactResponse.fromJson(response);
  }

  /// Starts an empty evaluation in the specified Amazon Connect instance, using
  /// the given evaluation form for the particular contact. The evaluation form
  /// version used for the contact evaluation corresponds to the currently
  /// activated version. If no version is activated for the evaluation form, the
  /// contact evaluation cannot be started.
  /// <note>
  /// Evaluations created through the public API do not contain answer values
  /// suggested from automation.
  /// </note>
  ///
  /// May throw [InternalServiceException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [evaluationFormId] :
  /// The unique identifier for the evaluation form.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<StartContactEvaluationResponse> startContactEvaluation({
    required String contactId,
    required String evaluationFormId,
    required String instanceId,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'EvaluationFormId': evaluationFormId,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact-evaluations/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return StartContactEvaluationResponse.fromJson(response);
  }

  /// Starts recording the contact:
  ///
  /// <ul>
  /// <li>
  /// If the API is called <i>before</i> the agent joins the call, recording
  /// starts when the agent joins the call.
  /// </li>
  /// <li>
  /// If the API is called <i>after</i> the agent joins the call, recording
  /// starts at the time of the API call.
  /// </li>
  /// </ul>
  /// StartContactRecording is a one-time action. For example, if you use
  /// StopContactRecording to stop recording an ongoing call, you can't use
  /// StartContactRecording to restart it. For scenarios where the recording has
  /// started and you want to suspend and resume it, such as when collecting
  /// sensitive information (for example, a credit card number), use
  /// SuspendContactRecording and ResumeContactRecording.
  ///
  /// You can use this API to override the recording behavior configured in the
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/set-recording-behavior.html">Set
  /// recording behavior</a> block.
  ///
  /// Only voice recordings are supported at this time.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [initialContactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [voiceRecordingConfiguration] :
  /// The person being recorded.
  Future<void> startContactRecording({
    required String contactId,
    required String initialContactId,
    required String instanceId,
    required VoiceRecordingConfiguration voiceRecordingConfiguration,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InitialContactId': initialContactId,
      'InstanceId': instanceId,
      'VoiceRecordingConfiguration': voiceRecordingConfiguration,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/start-recording',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Initiates real-time message streaming for a new chat contact.
  ///
  /// For more information about message streaming, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-message-streaming.html">Enable
  /// real-time chat message streaming</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [chatStreamingConfiguration] :
  /// The streaming configuration, such as the Amazon SNS streaming endpoint.
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  Future<StartContactStreamingResponse> startContactStreaming({
    required ChatStreamingConfiguration chatStreamingConfiguration,
    required String contactId,
    required String instanceId,
    String? clientToken,
  }) async {
    final $payload = <String, dynamic>{
      'ChatStreamingConfiguration': chatStreamingConfiguration,
      'ContactId': contactId,
      'InstanceId': instanceId,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/start-streaming',
      exceptionFnMap: _exceptionFns,
    );
    return StartContactStreamingResponse.fromJson(response);
  }

  /// Places an outbound call to a contact, and then initiates the flow. It
  /// performs the actions in the flow that's specified (in
  /// <code>ContactFlowId</code>).
  ///
  /// Agents do not initiate the outbound API, which means that they do not dial
  /// the contact. If the flow places an outbound call to a contact, and then
  /// puts the contact in queue, the call is then routed to the agent, like any
  /// other inbound case.
  ///
  /// There is a 60-second dialing timeout for this operation. If the call is
  /// not connected after 60 seconds, it fails.
  /// <note>
  /// UK numbers with a 447 prefix are not allowed by default. Before you can
  /// dial these UK mobile numbers, you must submit a service quota increase
  /// request. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon
  /// Connect Service Quotas</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  /// </note> <note>
  /// Campaign calls are not allowed by default. Before you can make a call with
  /// <code>TrafficType</code> = <code>CAMPAIGN</code>, you must submit a
  /// service quota increase request to the quota <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#outbound-communications-quotas">Amazon
  /// Connect campaigns</a>.
  /// </note>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [LimitExceededException].
  /// May throw [DestinationNotAllowedException].
  /// May throw [OutboundContactNotPermittedException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow for the outbound call. To see the ContactFlowId
  /// in the Amazon Connect admin website, on the navigation menu go to
  /// <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow page,
  /// under the name of the flow, choose <b>Show additional flow
  /// information</b>. The ContactFlowId is the last part of the ARN, shown here
  /// in bold:
  ///
  /// arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
  ///
  /// Parameter [destinationPhoneNumber] :
  /// The phone number of the customer, in E.164 format.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [answerMachineDetectionConfig] :
  /// Configuration of the answering machine detection for this outbound call.
  ///
  /// Parameter [attributes] :
  /// A custom key-value pair using an attribute map. The attributes are
  /// standard Amazon Connect attributes, and can be accessed in flows just like
  /// any other contact attributes.
  ///
  /// There can be up to 32,768 UTF-8 bytes across all key-value pairs per
  /// contact. Attribute keys can include only alphanumeric, dash, and
  /// underscore characters.
  ///
  /// Parameter [campaignId] :
  /// The campaign identifier of the outbound communication.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>. The token is valid for 7 days after
  /// creation. If a contact is already started, the contact ID is returned.
  ///
  /// Parameter [description] :
  /// A description of the voice contact that is shown to an agent in the
  /// Contact Control Panel (CCP).
  ///
  /// Parameter [name] :
  /// The name of a voice contact that is shown to an agent in the Contact
  /// Control Panel (CCP).
  ///
  /// Parameter [queueId] :
  /// The queue for the call. If you specify a queue, the phone displayed for
  /// caller ID is the phone number specified in the queue. If you do not
  /// specify a queue, the queue defined in the flow is used. If you do not
  /// specify a queue, you must specify a source phone number.
  ///
  /// Parameter [references] :
  /// A formatted URL that is shown to an agent in the Contact Control Panel
  /// (CCP). Contacts can have the following reference types at the time of
  /// creation: <code>URL</code> | <code>NUMBER</code> | <code>STRING</code> |
  /// <code>DATE</code> | <code>EMAIL</code>. <code>ATTACHMENT</code> is not a
  /// supported reference type during voice contact creation.
  ///
  /// Parameter [relatedContactId] :
  /// The <code>contactId</code> that is related to this contact. Linking voice,
  /// task, or chat by using <code>RelatedContactID</code> copies over contact
  /// attributes from the related contact to the new contact. All updates to
  /// user-defined attributes in the new contact are limited to the individual
  /// contact ID. There are no limits to the number of contacts that can be
  /// linked by using <code>RelatedContactId</code>.
  ///
  /// Parameter [sourcePhoneNumber] :
  /// The phone number associated with the Amazon Connect instance, in E.164
  /// format. If you do not specify a source phone number, you must specify a
  /// queue.
  ///
  /// Parameter [trafficType] :
  /// Denotes the class of traffic. Calls with different traffic types are
  /// handled differently by Amazon Connect. The default value is
  /// <code>GENERAL</code>. Use <code>CAMPAIGN</code> if
  /// <code>EnableAnswerMachineDetection</code> is set to <code>true</code>. For
  /// all other cases, use <code>GENERAL</code>.
  Future<StartOutboundVoiceContactResponse> startOutboundVoiceContact({
    required String contactFlowId,
    required String destinationPhoneNumber,
    required String instanceId,
    AnswerMachineDetectionConfig? answerMachineDetectionConfig,
    Map<String, String>? attributes,
    String? campaignId,
    String? clientToken,
    String? description,
    String? name,
    String? queueId,
    Map<String, Reference>? references,
    String? relatedContactId,
    String? sourcePhoneNumber,
    TrafficType? trafficType,
  }) async {
    final $payload = <String, dynamic>{
      'ContactFlowId': contactFlowId,
      'DestinationPhoneNumber': destinationPhoneNumber,
      'InstanceId': instanceId,
      if (answerMachineDetectionConfig != null)
        'AnswerMachineDetectionConfig': answerMachineDetectionConfig,
      if (attributes != null) 'Attributes': attributes,
      if (campaignId != null) 'CampaignId': campaignId,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (queueId != null) 'QueueId': queueId,
      if (references != null) 'References': references,
      if (relatedContactId != null) 'RelatedContactId': relatedContactId,
      if (sourcePhoneNumber != null) 'SourcePhoneNumber': sourcePhoneNumber,
      if (trafficType != null) 'TrafficType': trafficType.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact/outbound-voice',
      exceptionFnMap: _exceptionFns,
    );
    return StartOutboundVoiceContactResponse.fromJson(response);
  }

  /// Initiates a flow to start a new task contact. For more information about
  /// task contacts, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/tasks.html">Concepts:
  /// Tasks in Amazon Connect</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  ///
  /// When using <code>PreviousContactId</code> and
  /// <code>RelatedContactId</code> input parameters, note the following:
  ///
  /// <ul>
  /// <li>
  /// <code>PreviousContactId</code>
  ///
  /// <ul>
  /// <li>
  /// Any updates to user-defined task contact attributes on any contact linked
  /// through the same <code>PreviousContactId</code> will affect every contact
  /// in the chain.
  /// </li>
  /// <li>
  /// There can be a maximum of 12 linked task contacts in a chain. That is, 12
  /// task contacts can be created that share the same
  /// <code>PreviousContactId</code>.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>RelatedContactId</code>
  ///
  /// <ul>
  /// <li>
  /// Copies contact attributes from the related task contact to the new
  /// contact.
  /// </li>
  /// <li>
  /// Any update on attributes in a new task contact does not update attributes
  /// on previous contact.
  /// </li>
  /// <li>
  /// There’s no limit on the number of task contacts that can be created that
  /// use the same <code>RelatedContactId</code>.
  /// </li>
  /// </ul> </li>
  /// </ul>
  /// In addition, when calling StartTaskContact include only one of these
  /// parameters: <code>ContactFlowID</code>, <code>QuickConnectID</code>, or
  /// <code>TaskTemplateID</code>. Only one parameter is required as long as the
  /// task template has a flow configured to run it. If more than one parameter
  /// is specified, or only the <code>TaskTemplateID</code> is specified but it
  /// does not have a flow configured, the request returns an error because
  /// Amazon Connect cannot identify the unique flow to run when the task is
  /// created.
  ///
  /// A <code>ServiceQuotaExceededException</code> occurs when the number of
  /// open tasks exceeds the active tasks quota or there are already 12 tasks
  /// referencing the same <code>PreviousContactId</code>. For more information
  /// about service quotas for task contacts, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html">Amazon
  /// Connect service quotas</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of a task that is shown to an agent in the Contact Control Panel
  /// (CCP).
  ///
  /// Parameter [attributes] :
  /// A custom key-value pair using an attribute map. The attributes are
  /// standard Amazon Connect attributes, and can be accessed in flows just like
  /// any other contact attributes.
  ///
  /// There can be up to 32,768 UTF-8 bytes across all key-value pairs per
  /// contact. Attribute keys can include only alphanumeric, dash, and
  /// underscore characters.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow for initiating the tasks. To see the
  /// ContactFlowId in the Amazon Connect admin website, on the navigation menu
  /// go to <b>Routing</b>, <b>Contact Flows</b>. Choose the flow. On the flow
  /// page, under the name of the flow, choose <b>Show additional flow
  /// information</b>. The ContactFlowId is the last part of the ARN, shown here
  /// in bold:
  ///
  /// arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
  ///
  /// Parameter [description] :
  /// A description of the task that is shown to an agent in the Contact Control
  /// Panel (CCP).
  ///
  /// Parameter [previousContactId] :
  /// The identifier of the previous chat, voice, or task contact. Any updates
  /// to user-defined attributes to task contacts linked using the same
  /// <code>PreviousContactID</code> will affect every contact in the chain.
  /// There can be a maximum of 12 linked task contacts in a chain.
  ///
  /// Parameter [quickConnectId] :
  /// The identifier for the quick connect. Tasks that are created by using
  /// <code>QuickConnectId</code> will use the flow that is defined on agent or
  /// queue quick connect. For more information about quick connects, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/quick-connects.html">Create
  /// quick connects</a>.
  ///
  /// Parameter [references] :
  /// A formatted URL that is shown to an agent in the Contact Control Panel
  /// (CCP). Tasks can have the following reference types at the time of
  /// creation: <code>URL</code> | <code>NUMBER</code> | <code>STRING</code> |
  /// <code>DATE</code> | <code>EMAIL</code>. <code>ATTACHMENT</code> is not a
  /// supported reference type during task creation.
  ///
  /// Parameter [relatedContactId] :
  /// The contactId that is <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/tasks.html#linked-tasks">related</a>
  /// to this contact. Linking tasks together by using
  /// <code>RelatedContactID</code> copies over contact attributes from the
  /// related task contact to the new task contact. All updates to user-defined
  /// attributes in the new task contact are limited to the individual contact
  /// ID, unlike what happens when tasks are linked by using
  /// <code>PreviousContactID</code>. There are no limits to the number of
  /// contacts that can be linked by using <code>RelatedContactId</code>.
  ///
  /// Parameter [scheduledTime] :
  /// The timestamp, in Unix Epoch seconds format, at which to start running the
  /// inbound flow. The scheduled time cannot be in the past. It must be within
  /// up to 6 days in future.
  ///
  /// Parameter [taskTemplateId] :
  /// A unique identifier for the task template. For more information about task
  /// templates, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/task-templates.html">Create
  /// task templates</a> in the <i>Amazon Connect Administrator Guide</i>.
  Future<StartTaskContactResponse> startTaskContact({
    required String instanceId,
    required String name,
    Map<String, String>? attributes,
    String? clientToken,
    String? contactFlowId,
    String? description,
    String? previousContactId,
    String? quickConnectId,
    Map<String, Reference>? references,
    String? relatedContactId,
    DateTime? scheduledTime,
    String? taskTemplateId,
  }) async {
    final $payload = <String, dynamic>{
      'InstanceId': instanceId,
      'Name': name,
      if (attributes != null) 'Attributes': attributes,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
      if (description != null) 'Description': description,
      if (previousContactId != null) 'PreviousContactId': previousContactId,
      if (quickConnectId != null) 'QuickConnectId': quickConnectId,
      if (references != null) 'References': references,
      if (relatedContactId != null) 'RelatedContactId': relatedContactId,
      if (scheduledTime != null)
        'ScheduledTime': unixTimestampToJson(scheduledTime),
      if (taskTemplateId != null) 'TaskTemplateId': taskTemplateId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact/task',
      exceptionFnMap: _exceptionFns,
    );
    return StartTaskContactResponse.fromJson(response);
  }

  /// Places an inbound in-app, web, or video call to a contact, and then
  /// initiates the flow. It performs the actions in the flow that are specified
  /// (in ContactFlowId) and present in the Amazon Connect instance (specified
  /// as InstanceId).
  ///
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow for the call. To see the ContactFlowId in the
  /// Amazon Connect admin website, on the navigation menu go to <b>Routing</b>,
  /// <b>Contact Flows</b>. Choose the flow. On the flow page, under the name of
  /// the flow, choose <b>Show additional flow information</b>. The
  /// ContactFlowId is the last part of the ARN, shown here in bold:
  ///
  /// arn:aws:connect:us-west-2:xxxxxxxxxxxx:instance/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/contact-flow/<b>846ec553-a005-41c0-8341-xxxxxxxxxxxx</b>
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [allowedCapabilities] :
  /// Information about the video sharing capabilities of the participants
  /// (customer, agent).
  ///
  /// Parameter [attributes] :
  /// A custom key-value pair using an attribute map. The attributes are
  /// standard Amazon Connect attributes, and can be accessed in flows just like
  /// any other contact attributes.
  ///
  /// There can be up to 32,768 UTF-8 bytes across all key-value pairs per
  /// contact. Attribute keys can include only alphanumeric, -, and _
  /// characters.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// The token is valid for 7 days after creation. If a contact is already
  /// started, the contact ID is returned.
  ///
  /// Parameter [description] :
  /// A description of the task that is shown to an agent in the Contact Control
  /// Panel (CCP).
  ///
  /// Parameter [references] :
  /// A formatted URL that is shown to an agent in the Contact Control Panel
  /// (CCP). Tasks can have the following reference types at the time of
  /// creation: <code>URL</code> | <code>NUMBER</code> | <code>STRING</code> |
  /// <code>DATE</code> | <code>EMAIL</code>. <code>ATTACHMENT</code> is not a
  /// supported reference type during task creation.
  ///
  /// Parameter [relatedContactId] :
  /// The unique identifier for an Amazon Connect contact. This identifier is
  /// related to the contact starting.
  Future<StartWebRTCContactResponse> startWebRTCContact({
    required String contactFlowId,
    required String instanceId,
    required ParticipantDetails participantDetails,
    AllowedCapabilities? allowedCapabilities,
    Map<String, String>? attributes,
    String? clientToken,
    String? description,
    Map<String, Reference>? references,
    String? relatedContactId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactFlowId': contactFlowId,
      'InstanceId': instanceId,
      'ParticipantDetails': participantDetails,
      if (allowedCapabilities != null)
        'AllowedCapabilities': allowedCapabilities,
      if (attributes != null) 'Attributes': attributes,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (description != null) 'Description': description,
      if (references != null) 'References': references,
      if (relatedContactId != null) 'RelatedContactId': relatedContactId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/contact/webrtc',
      exceptionFnMap: _exceptionFns,
    );
    return StartWebRTCContactResponse.fromJson(response);
  }

  /// Ends the specified contact. Use this API to stop queued callbacks. It does
  /// not work for voice contacts that use the following initiation methods:
  ///
  /// <ul>
  /// <li>
  /// DISCONNECT
  /// </li>
  /// <li>
  /// TRANSFER
  /// </li>
  /// <li>
  /// QUEUE_TRANSFER
  /// </li>
  /// <li>
  /// EXTERNAL_OUTBOUND
  /// </li>
  /// <li>
  /// MONITOR
  /// </li>
  /// </ul>
  /// Chat and task contacts can be terminated in any state, regardless of
  /// initiation method.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ContactNotFoundException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The ID of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [disconnectReason] :
  /// The reason a contact can be disconnected. Only Amazon Connect outbound
  /// campaigns can provide this field.
  Future<void> stopContact({
    required String contactId,
    required String instanceId,
    DisconnectReason? disconnectReason,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      if (disconnectReason != null) 'DisconnectReason': disconnectReason,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/stop',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Stops recording a call when a contact is being recorded.
  /// StopContactRecording is a one-time action. If you use StopContactRecording
  /// to stop recording an ongoing call, you can't use StartContactRecording to
  /// restart it. For scenarios where the recording has started and you want to
  /// suspend it for sensitive information (for example, to collect a credit
  /// card number), and then restart it, use SuspendContactRecording and
  /// ResumeContactRecording.
  ///
  /// Only voice recordings are supported at this time.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [initialContactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> stopContactRecording({
    required String contactId,
    required String initialContactId,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InitialContactId': initialContactId,
      'InstanceId': instanceId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/stop-recording',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Ends message streaming on a specified contact. To restart message
  /// streaming on that contact, call the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_StartContactStreaming.html">StartContactStreaming</a>
  /// API.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact. This is the identifier of the contact that
  /// is associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [streamingId] :
  /// The identifier of the streaming configuration enabled.
  Future<void> stopContactStreaming({
    required String contactId,
    required String instanceId,
    required String streamingId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      'StreamingId': streamingId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/stop-streaming',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Submits a contact evaluation in the specified Amazon Connect instance.
  /// Answers included in the request are merged with existing answers for the
  /// given evaluation. If no answers or notes are passed, the evaluation is
  /// submitted with the existing answers and notes. You can delete an answer or
  /// note by passing an empty object (<code>{}</code>) to the question
  /// identifier.
  ///
  /// If a contact evaluation is already in submitted state, this operation will
  /// trigger a resubmission.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationId] :
  /// A unique identifier for the contact evaluation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [answers] :
  /// A map of question identifiers to answer value.
  ///
  /// Parameter [notes] :
  /// A map of question identifiers to note value.
  Future<SubmitContactEvaluationResponse> submitContactEvaluation({
    required String evaluationId,
    required String instanceId,
    Map<String, EvaluationAnswerInput>? answers,
    Map<String, EvaluationNote>? notes,
  }) async {
    final $payload = <String, dynamic>{
      if (answers != null) 'Answers': answers,
      if (notes != null) 'Notes': notes,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-evaluations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationId)}/submit',
      exceptionFnMap: _exceptionFns,
    );
    return SubmitContactEvaluationResponse.fromJson(response);
  }

  /// When a contact is being recorded, this API suspends recording whatever is
  /// selected in the flow configuration: call, screen, or both. If only call
  /// recording or only screen recording is enabled, then it would be suspended.
  /// For example, you might suspend the screen recording while collecting
  /// sensitive information, such as a credit card number. Then use
  /// ResumeContactRecording to restart recording the screen.
  ///
  /// The period of time that the recording is suspended is filled with silence
  /// in the final recording.
  ///
  /// Voice and screen recordings are supported.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [initialContactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> suspendContactRecording({
    required String contactId,
    required String initialContactId,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InitialContactId': initialContactId,
      'InstanceId': instanceId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/suspend-recording',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Adds the specified tags to the contact resource. For more information
  /// about this API is used, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/granular-billing.html">Set
  /// up granular billing for a detailed view of your Amazon Connect usage</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [tags] :
  /// The tags to be assigned to the contact resource. For example, { "Tags":
  /// {"key1":"value1", "key2":"value2"} }.
  /// <note>
  /// Authorization is not supported by this tag.
  /// </note>
  Future<void> tagContact({
    required String contactId,
    required String instanceId,
    required Map<String, String> tags,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/tags',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Adds the specified tags to the specified resource.
  ///
  /// Some of the supported resource types are agents, routing profiles, queues,
  /// quick connects, contact flows, agent statuses, hours of operation, phone
  /// numbers, security profiles, and task templates. For a complete list, see
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/tagging.html">Tagging
  /// resources in Amazon Connect</a>.
  ///
  /// For sample policies that use tags, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_id-based-policy-examples.html">Amazon
  /// Connect Identity-Based Policy Examples</a> in the <i>Amazon Connect
  /// Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource.
  ///
  /// Parameter [tags] :
  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  Future<void> tagResource({
    required String resourceArn,
    required Map<String, String> tags,
  }) async {
    final $payload = <String, dynamic>{
      'tags': tags,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/tags/${Uri.encodeComponent(resourceArn)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Transfers contacts from one agent or queue to another agent or queue at
  /// any point after a contact is created. You can transfer a contact to
  /// another queue by providing the flow which orchestrates the contact to the
  /// destination queue. This gives you more control over contact handling and
  /// helps you adhere to the service level agreement (SLA) guaranteed to your
  /// customers.
  ///
  /// Note the following requirements:
  ///
  /// <ul>
  /// <li>
  /// Transfer is supported for only <code>TASK</code> contacts.
  /// </li>
  /// <li>
  /// Do not use both <code>QueueId</code> and <code>UserId</code> in the same
  /// call.
  /// </li>
  /// <li>
  /// The following flow types are supported: Inbound flow, Transfer to agent
  /// flow, and Transfer to queue flow.
  /// </li>
  /// <li>
  /// The <code>TransferContact</code> API can be called only on active
  /// contacts.
  /// </li>
  /// <li>
  /// A contact cannot be transferred more than 11 times.
  /// </li>
  /// </ul>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [IdempotencyException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [userId] :
  /// The identifier for the user. This can be the ID or the ARN of the user.
  Future<TransferContactResponse> transferContact({
    required String contactFlowId,
    required String contactId,
    required String instanceId,
    String? clientToken,
    String? queueId,
    String? userId,
  }) async {
    final $payload = <String, dynamic>{
      'ContactFlowId': contactFlowId,
      'ContactId': contactId,
      'InstanceId': instanceId,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (queueId != null) 'QueueId': queueId,
      if (userId != null) 'UserId': userId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/transfer',
      exceptionFnMap: _exceptionFns,
    );
    return TransferContactResponse.fromJson(response);
  }

  /// Removes the specified tags from the contact resource. For more information
  /// about this API is used, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/granular-billing.html">Set
  /// up granular billing for a detailed view of your Amazon Connect usage</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [tagKeys] :
  /// A list of tag keys. Existing tags on the contact whose keys are members of
  /// this list will be removed.
  Future<void> untagContact({
    required String contactId,
    required String instanceId,
    required List<String> tagKeys,
  }) async {
    final $query = <String, List<String>>{
      'TagKeys': tagKeys,
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/contact/tags/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Removes the specified tags from the specified resource.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource.
  ///
  /// Parameter [tagKeys] :
  /// The tag keys.
  Future<void> untagResource({
    required String resourceArn,
    required List<String> tagKeys,
  }) async {
    final $query = <String, List<String>>{
      'tagKeys': tagKeys,
    };
    await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/tags/${Uri.encodeComponent(resourceArn)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates agent status.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [agentStatusId] :
  /// The identifier of the agent status.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [description] :
  /// The description of the agent status.
  ///
  /// Parameter [displayOrder] :
  /// The display order of the agent status.
  ///
  /// Parameter [name] :
  /// The name of the agent status.
  ///
  /// Parameter [resetOrderNumber] :
  /// A number indicating the reset order of the agent status.
  ///
  /// Parameter [state] :
  /// The state of the agent status.
  Future<void> updateAgentStatus({
    required String agentStatusId,
    required String instanceId,
    String? description,
    int? displayOrder,
    String? name,
    bool? resetOrderNumber,
    AgentStatusState? state,
  }) async {
    _s.validateNumRange(
      'displayOrder',
      displayOrder,
      1,
      50,
    );
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (displayOrder != null) 'DisplayOrder': displayOrder,
      if (name != null) 'Name': name,
      if (resetOrderNumber != null) 'ResetOrderNumber': resetOrderNumber,
      if (state != null) 'State': state.value,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/agent-status/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(agentStatusId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Adds or updates user-defined contact information associated with the
  /// specified contact. At least one field to be updated must be present in the
  /// request.
  /// <important>
  /// You can add or update user-defined contact information for both ongoing
  /// and completed contacts.
  /// </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with your contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [description] :
  /// The description of the contact.
  ///
  /// Parameter [name] :
  /// The name of the contact.
  ///
  /// Parameter [references] :
  /// Well-formed data on contact, shown to agents on Contact Control Panel
  /// (CCP).
  Future<void> updateContact({
    required String contactId,
    required String instanceId,
    String? description,
    String? name,
    Map<String, Reference>? references,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (references != null) 'References': references,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contacts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Creates or updates user-defined contact attributes associated with the
  /// specified contact.
  ///
  /// You can create or update user-defined attributes for both ongoing and
  /// completed contacts. For example, while the call is active, you can update
  /// the customer's name or the reason the customer called. You can add notes
  /// about steps that the agent took during the call that display to the next
  /// agent that takes the call. You can also update attributes for a contact
  /// using data from your CRM application and save the data with the contact in
  /// Amazon Connect. You could also flag calls for additional analysis, such as
  /// legal review or to identify abusive callers.
  ///
  /// Contact attributes are available in Amazon Connect for 24 months, and are
  /// then deleted. For information about contact record retention and the
  /// maximum size of the contact record attributes section, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/amazon-connect-service-limits.html#feature-limits">Feature
  /// specifications</a> in the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [attributes] :
  /// The Amazon Connect attributes. These attributes can be accessed in flows
  /// just like any other contact attributes.
  ///
  /// You can have up to 32,768 UTF-8 bytes across all attributes for a contact.
  /// Attribute keys can include only alphanumeric, dash, and underscore
  /// characters.
  ///
  /// When the attributes for a contact exceed 32 KB, the contact is routed down
  /// the Error branch of the flow. As a mitigation, consider the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// Remove unnecessary attributes by setting their values to empty.
  /// </li>
  /// <li>
  /// If the attributes are only used in one flow and don't need to be referred
  /// to outside of that flow (for example, by a Lambda or another flow), then
  /// use flow attributes. This way you aren't needlessly persisting the 32 KB
  /// of information from one flow to another. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/set-contact-attributes.html">Flow
  /// block: Set contact attributes</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  /// </li>
  /// </ul>
  ///
  /// Parameter [initialContactId] :
  /// The identifier of the contact. This is the identifier of the contact
  /// associated with the first interaction with the contact center.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> updateContactAttributes({
    required Map<String, String> attributes,
    required String initialContactId,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'Attributes': attributes,
      'InitialContactId': initialContactId,
      'InstanceId': instanceId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/attributes',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates details about a contact evaluation in the specified Amazon Connect
  /// instance. A contact evaluation must be in draft state. Answers included in
  /// the request are merged with existing answers for the given evaluation. An
  /// answer or note can be deleted by passing an empty object (<code>{}</code>)
  /// to the question identifier.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationId] :
  /// A unique identifier for the contact evaluation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [answers] :
  /// A map of question identifiers to answer value.
  ///
  /// Parameter [notes] :
  /// A map of question identifiers to note value.
  Future<UpdateContactEvaluationResponse> updateContactEvaluation({
    required String evaluationId,
    required String instanceId,
    Map<String, EvaluationAnswerInput>? answers,
    Map<String, EvaluationNote>? notes,
  }) async {
    final $payload = <String, dynamic>{
      if (answers != null) 'Answers': answers,
      if (notes != null) 'Notes': notes,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-evaluations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateContactEvaluationResponse.fromJson(response);
  }

  /// Updates the specified flow.
  ///
  /// You can also create and update flows using the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon
  /// Connect Flow language</a>.
  ///
  /// Use the <code>$SAVED</code> alias in the request to describe the
  /// <code>SAVED</code> content of a Flow. For example,
  /// <code>arn:aws:.../contact-flow/{id}:$SAVED</code>. Once a contact flow is
  /// published, <code>$SAVED</code> needs to be supplied to view saved content
  /// that has not been published.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidContactFlowException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [content] :
  /// The JSON string that represents the content of the flow. For an example,
  /// see <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example
  /// flow in Amazon Connect Flow language</a>.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256000.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance.
  Future<void> updateContactFlowContent({
    required String contactFlowId,
    required String content,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-flows/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowId)}/content',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates metadata about specified flow.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [contactFlowState] :
  /// The state of flow.
  ///
  /// Parameter [description] :
  /// The description of the flow.
  ///
  /// Parameter [name] :
  /// The name of the flow.
  Future<void> updateContactFlowMetadata({
    required String contactFlowId,
    required String instanceId,
    ContactFlowState? contactFlowState,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (contactFlowState != null) 'ContactFlowState': contactFlowState.value,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-flows/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowId)}/metadata',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates specified flow module for the specified Amazon Connect instance.
  ///
  /// Use the <code>$SAVED</code> alias in the request to describe the
  /// <code>SAVED</code> content of a Flow. For example,
  /// <code>arn:aws:.../contact-flow/{id}:$SAVED</code>. Once a contact flow is
  /// published, <code>$SAVED</code> needs to be supplied to view saved content
  /// that has not been published.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidContactFlowModuleException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowModuleId] :
  /// The identifier of the flow module.
  ///
  /// Parameter [content] :
  /// The JSON string that represents the content of the flow. For an example,
  /// see <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example
  /// flow in Amazon Connect Flow language</a>.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> updateContactFlowModuleContent({
    required String contactFlowModuleId,
    required String content,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-flow-modules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowModuleId)}/content',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates metadata about specified flow module.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowModuleId] :
  /// The identifier of the flow module.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [description] :
  /// The description of the flow module.
  ///
  /// Parameter [name] :
  /// The name of the flow module.
  ///
  /// Parameter [state] :
  /// The state of flow module.
  Future<void> updateContactFlowModuleMetadata({
    required String contactFlowModuleId,
    required String instanceId,
    String? description,
    String? name,
    ContactFlowModuleState? state,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (state != null) 'State': state.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-flow-modules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowModuleId)}/metadata',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// The name of the flow.
  ///
  /// You can also create and update flows using the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon
  /// Connect Flow language</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance.
  ///
  /// Parameter [description] :
  /// The description of the flow.
  ///
  /// Parameter [name] :
  /// The name of the flow.
  Future<void> updateContactFlowName({
    required String contactFlowId,
    required String instanceId,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contact-flows/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactFlowId)}/name',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates routing priority and age on the contact (<b>QueuePriority</b> and
  /// <b>QueueTimeAdjustmentInSeconds</b>). These properties can be used to
  /// change a customer's position in the queue. For example, you can move a
  /// contact to the back of the queue by setting a lower routing priority
  /// relative to other contacts in queue; or you can move a contact to the
  /// front of the queue by increasing the routing age which will make the
  /// contact look artificially older and therefore higher up in the
  /// first-in-first-out routing order. Note that adjusting the routing age of a
  /// contact affects only its position in queue, and not its actual queue wait
  /// time as reported through metrics. These properties can also be updated by
  /// using <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/change-routing-priority.html">the
  /// Set routing priority / age flow block</a>.
  /// <note>
  /// Either <b>QueuePriority</b> or <b>QueueTimeAdjustmentInSeconds</b> should
  /// be provided within the request body, but not both.
  /// </note>
  ///
  /// May throw [ResourceConflictException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queuePriority] :
  /// Priority of the contact in the queue. The default priority for new
  /// contacts is 5. You can raise the priority of a contact compared to other
  /// contacts in the queue by assigning them a higher priority, such as 1 or 2.
  ///
  /// Parameter [queueTimeAdjustmentSeconds] :
  /// The number of seconds to add or subtract from the contact's routing age.
  /// Contacts are routed to agents on a first-come, first-serve basis. This
  /// means that changing their amount of time in queue compared to others also
  /// changes their position in queue.
  Future<void> updateContactRoutingData({
    required String contactId,
    required String instanceId,
    int? queuePriority,
    int? queueTimeAdjustmentSeconds,
  }) async {
    _s.validateNumRange(
      'queuePriority',
      queuePriority,
      1,
      9223372036854776000.0,
    );
    final $payload = <String, dynamic>{
      if (queuePriority != null) 'QueuePriority': queuePriority,
      if (queueTimeAdjustmentSeconds != null)
        'QueueTimeAdjustmentSeconds': queueTimeAdjustmentSeconds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/contacts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}/routing-data',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the scheduled time of a task contact that is already scheduled.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [scheduledTime] :
  /// The timestamp, in Unix Epoch seconds format, at which to start running the
  /// inbound flow. The scheduled time cannot be in the past. It must be within
  /// up to 6 days in future.
  Future<void> updateContactSchedule({
    required String contactId,
    required String instanceId,
    required DateTime scheduledTime,
  }) async {
    final $payload = <String, dynamic>{
      'ContactId': contactId,
      'InstanceId': instanceId,
      'ScheduledTime': unixTimestampToJson(scheduledTime),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/contact/schedule',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates details about a specific evaluation form version in the specified
  /// Amazon Connect instance. Question and section identifiers cannot be
  /// duplicated within the same evaluation form.
  ///
  /// This operation does not support partial updates. Instead it does a full
  /// update of evaluation form content.
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [evaluationFormId] :
  /// The unique identifier for the evaluation form.
  ///
  /// Parameter [evaluationFormVersion] :
  /// A version of the evaluation form to update.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [items] :
  /// Items that are part of the evaluation form. The total number of sections
  /// and questions must not exceed 100 each. Questions must be contained in a
  /// section.
  ///
  /// Parameter [title] :
  /// A title of the evaluation form.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [createNewVersion] :
  /// A flag indicating whether the operation must create a new version.
  ///
  /// Parameter [description] :
  /// The description of the evaluation form.
  ///
  /// Parameter [scoringStrategy] :
  /// A scoring strategy of the evaluation form.
  Future<UpdateEvaluationFormResponse> updateEvaluationForm({
    required String evaluationFormId,
    required int evaluationFormVersion,
    required String instanceId,
    required List<EvaluationFormItem> items,
    required String title,
    String? clientToken,
    bool? createNewVersion,
    String? description,
    EvaluationFormScoringStrategy? scoringStrategy,
  }) async {
    _s.validateNumRange(
      'evaluationFormVersion',
      evaluationFormVersion,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'EvaluationFormVersion': evaluationFormVersion,
      'Items': items,
      'Title': title,
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (createNewVersion != null) 'CreateNewVersion': createNewVersion,
      if (description != null) 'Description': description,
      if (scoringStrategy != null) 'ScoringStrategy': scoringStrategy,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/evaluation-forms/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(evaluationFormId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateEvaluationFormResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the hours of operation.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hoursOfOperationId] :
  /// The identifier of the hours of operation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [config] :
  /// Configuration information of the hours of operation.
  ///
  /// Parameter [description] :
  /// The description of the hours of operation.
  ///
  /// Parameter [name] :
  /// The name of the hours of operation.
  ///
  /// Parameter [timeZone] :
  /// The time zone of the hours of operation.
  Future<void> updateHoursOfOperation({
    required String hoursOfOperationId,
    required String instanceId,
    List<HoursOfOperationConfig>? config,
    String? description,
    String? name,
    String? timeZone,
  }) async {
    final $payload = <String, dynamic>{
      if (config != null) 'Config': config,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (timeZone != null) 'TimeZone': timeZone,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/hours-of-operations/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(hoursOfOperationId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the value for the specified attribute type.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [attributeType] :
  /// The type of attribute.
  /// <note>
  /// Only allowlisted customers can consume USE_CUSTOM_TTS_VOICES. To access
  /// this feature, contact Amazon Web Services Support for allowlisting.
  /// </note>
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [value] :
  /// The value for the attribute. Maximum character limit is 100.
  Future<void> updateInstanceAttribute({
    required InstanceAttributeType attributeType,
    required String instanceId,
    required String value,
  }) async {
    final $payload = <String, dynamic>{
      'Value': value,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/attribute/${Uri.encodeComponent(attributeType.value)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates an existing configuration for a resource type. This API is
  /// idempotent.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ThrottlingException].
  ///
  /// Parameter [associationId] :
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [resourceType] :
  /// A valid resource type.
  Future<void> updateInstanceStorageConfig({
    required String associationId,
    required String instanceId,
    required InstanceStorageResourceType resourceType,
    required InstanceStorageConfig storageConfig,
  }) async {
    final $query = <String, List<String>>{
      'resourceType': [resourceType.value],
    };
    final $payload = <String, dynamic>{
      'StorageConfig': storageConfig,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/storage-config/${Uri.encodeComponent(associationId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates timeouts for when human chat participants are to be considered
  /// idle, and when agents are automatically disconnected from a chat due to
  /// idleness. You can set four timers:
  ///
  /// <ul>
  /// <li>
  /// Customer idle timeout
  /// </li>
  /// <li>
  /// Customer auto-disconnect timeout
  /// </li>
  /// <li>
  /// Agent idle timeout
  /// </li>
  /// <li>
  /// Agent auto-disconnect timeout
  /// </li>
  /// </ul>
  /// For more information about how chat timeouts work, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html">Set
  /// up chat timeouts for human participants</a>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [channelConfiguration] :
  /// The Amazon Connect channel you want to configure.
  ///
  /// Parameter [contactId] :
  /// The identifier of the contact in this instance of Amazon Connect.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> updateParticipantRoleConfig({
    required UpdateParticipantRoleConfigChannelInfo channelConfiguration,
    required String contactId,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'ChannelConfiguration': channelConfiguration,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/contact/participant-role-config/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(contactId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates your claimed phone number from its current Amazon Connect instance
  /// or traffic distribution group to another Amazon Connect instance or
  /// traffic distribution group in the same Amazon Web Services Region.
  /// <important>
  /// After using this API, you must verify that the phone number is attached to
  /// the correct flow in the target instance or traffic distribution group. You
  /// need to do this because the API switches only the phone number to a new
  /// instance or traffic distribution group. It doesn't migrate the flow
  /// configuration of the phone number, too.
  ///
  /// You can call <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a>
  /// API to verify the status of a previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>
  /// operation.
  /// </important>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  /// May throw [ResourceInUseException].
  /// May throw [IdempotencyException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [phoneNumberId] :
  /// A unique identifier for the phone number.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance that phone numbers are
  /// claimed to. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance. You
  /// must enter <code>InstanceId</code> or <code>TargetArn</code>.
  ///
  /// Parameter [targetArn] :
  /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic
  /// distribution groups that phone number inbound traffic is routed through.
  /// You must enter <code>InstanceId</code> or <code>TargetArn</code>.
  Future<UpdatePhoneNumberResponse> updatePhoneNumber({
    required String phoneNumberId,
    String? clientToken,
    String? instanceId,
    String? targetArn,
  }) async {
    final $payload = <String, dynamic>{
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (instanceId != null) 'InstanceId': instanceId,
      if (targetArn != null) 'TargetArn': targetArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/phone-number/${Uri.encodeComponent(phoneNumberId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdatePhoneNumberResponse.fromJson(response);
  }

  /// Updates a phone number’s metadata.
  /// <important>
  /// To verify the status of a previous UpdatePhoneNumberMetadata operation,
  /// call the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a>
  /// API.
  /// </important>
  ///
  /// May throw [InvalidParameterException].
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  /// May throw [IdempotencyException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [phoneNumberId] :
  /// The Amazon Resource Name (ARN) or resource ID of the phone number.
  ///
  /// Parameter [clientToken] :
  /// A unique, case-sensitive identifier that you provide to ensure the
  /// idempotency of the request. If not provided, the Amazon Web Services SDK
  /// populates this field. For more information about idempotency, see <a
  /// href="https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/">Making
  /// retries safe with idempotent APIs</a>.
  ///
  /// Parameter [phoneNumberDescription] :
  /// The description of the phone number.
  Future<void> updatePhoneNumberMetadata({
    required String phoneNumberId,
    String? clientToken,
    String? phoneNumberDescription,
  }) async {
    final $payload = <String, dynamic>{
      'ClientToken': clientToken ?? _s.generateIdempotencyToken(),
      if (phoneNumberDescription != null)
        'PhoneNumberDescription': phoneNumberDescription,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/phone-number/${Uri.encodeComponent(phoneNumberId)}/metadata',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates a predefined attribute for the specified Amazon Connect instance.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the predefined attribute.
  ///
  /// Parameter [values] :
  /// The values of the predefined attribute.
  Future<void> updatePredefinedAttribute({
    required String instanceId,
    required String name,
    PredefinedAttributeValues? values,
  }) async {
    final $payload = <String, dynamic>{
      if (values != null) 'Values': values,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/predefined-attributes/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(name)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates a prompt.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [promptId] :
  /// A unique identifier for the prompt.
  ///
  /// Parameter [description] :
  /// A description of the prompt.
  ///
  /// Parameter [name] :
  /// The name of the prompt.
  ///
  /// Parameter [s3Uri] :
  /// The URI for the S3 bucket where the prompt is stored. You can provide S3
  /// pre-signed URLs returned by the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_GetPromptFile.html">GetPromptFile</a>
  /// API instead of providing S3 URIs.
  Future<UpdatePromptResponse> updatePrompt({
    required String instanceId,
    required String promptId,
    String? description,
    String? name,
    String? s3Uri,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (s3Uri != null) 'S3Uri': s3Uri,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/prompts/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(promptId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdatePromptResponse.fromJson(response);
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the hours of operation for the specified queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hoursOfOperationId] :
  /// The identifier for the hours of operation.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  Future<void> updateQueueHoursOfOperation({
    required String hoursOfOperationId,
    required String instanceId,
    required String queueId,
  }) async {
    final $payload = <String, dynamic>{
      'HoursOfOperationId': hoursOfOperationId,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/hours-of-operation',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the maximum number of contacts allowed in a queue before it is
  /// considered full.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [maxContacts] :
  /// The maximum number of contacts that can be in the queue before it is
  /// considered full.
  Future<void> updateQueueMaxContacts({
    required String instanceId,
    required String queueId,
    int? maxContacts,
  }) async {
    _s.validateNumRange(
      'maxContacts',
      maxContacts,
      0,
      1152921504606846976,
    );
    final $payload = <String, dynamic>{
      if (maxContacts != null) 'MaxContacts': maxContacts,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/max-contacts',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the name and description of a queue. At least <code>Name</code> or
  /// <code>Description</code> must be provided.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [description] :
  /// The description of the queue.
  ///
  /// Parameter [name] :
  /// The name of the queue.
  Future<void> updateQueueName({
    required String instanceId,
    required String queueId,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/name',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the outbound caller ID name, number, and outbound whisper flow for
  /// a specified queue.
  /// <important>
  /// <ul>
  /// <li>
  /// If the phone number is claimed to a traffic distribution group that was
  /// created in the same Region as the Amazon Connect instance where you are
  /// calling this API, then you can use a full phone number ARN or a UUID for
  /// <code>OutboundCallerIdNumberId</code>. However, if the phone number is
  /// claimed to a traffic distribution group that is in one Region, and you are
  /// calling this API from an instance in another Amazon Web Services Region
  /// that is associated with the traffic distribution group, you must provide a
  /// full phone number ARN. If a UUID is provided in this scenario, you will
  /// receive a <code>ResourceNotFoundException</code>.
  /// </li>
  /// <li>
  /// Only use the phone number ARN format that doesn't contain
  /// <code>instance</code> in the path, for example,
  /// <code>arn:aws:connect:us-east-1:1234567890:phone-number/uuid</code>. This
  /// is the same ARN format that is returned when you call the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ListPhoneNumbersV2.html">ListPhoneNumbersV2</a>
  /// API.
  /// </li>
  /// <li>
  /// If you plan to use IAM policies to allow/deny access to this API for phone
  /// number resources claimed to a traffic distribution group, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security_iam_resource-level-policy-examples.html#allow-deny-queue-actions-replica-region">Allow
  /// or Deny queue API actions for phone numbers in a replica Region</a>.
  /// </li>
  /// </ul> </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [outboundCallerConfig] :
  /// The outbound caller ID name, number, and outbound whisper flow.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  Future<void> updateQueueOutboundCallerConfig({
    required String instanceId,
    required OutboundCallerConfig outboundCallerConfig,
    required String queueId,
  }) async {
    final $payload = <String, dynamic>{
      'OutboundCallerConfig': outboundCallerConfig,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/outbound-caller-config',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This API is in preview release for Amazon Connect and is subject to
  /// change.
  ///
  /// Updates the status of the queue.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueId] :
  /// The identifier for the queue.
  ///
  /// Parameter [status] :
  /// The status of the queue.
  Future<void> updateQueueStatus({
    required String instanceId,
    required String queueId,
    required QueueStatus status,
  }) async {
    final $payload = <String, dynamic>{
      'Status': status.value,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/queues/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(queueId)}/status',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the configuration settings for the specified quick connect.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [quickConnectConfig] :
  /// Information about the configuration settings for the quick connect.
  ///
  /// Parameter [quickConnectId] :
  /// The identifier for the quick connect.
  Future<void> updateQuickConnectConfig({
    required String instanceId,
    required QuickConnectConfig quickConnectConfig,
    required String quickConnectId,
  }) async {
    final $payload = <String, dynamic>{
      'QuickConnectConfig': quickConnectConfig,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/quick-connects/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(quickConnectId)}/config',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the name and description of a quick connect. The request accepts
  /// the following data in JSON format. At least <code>Name</code> or
  /// <code>Description</code> must be provided.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [quickConnectId] :
  /// The identifier for the quick connect.
  ///
  /// Parameter [description] :
  /// The description of the quick connect.
  ///
  /// Parameter [name] :
  /// The name of the quick connect.
  Future<void> updateQuickConnectName({
    required String instanceId,
    required String quickConnectId,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/quick-connects/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(quickConnectId)}/name',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Whether agents with this routing profile will have their routing order
  /// calculated based on <i>time since their last inbound contact</i> or
  /// <i>longest idle time</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [agentAvailabilityTimer] :
  /// Whether agents with this routing profile will have their routing order
  /// calculated based on <i>time since their last inbound contact</i> or
  /// <i>longest idle time</i>.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> updateRoutingProfileAgentAvailabilityTimer({
    required AgentAvailabilityTimer agentAvailabilityTimer,
    required String instanceId,
    required String routingProfileId,
  }) async {
    final $payload = <String, dynamic>{
      'AgentAvailabilityTimer': agentAvailabilityTimer.value,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/agent-availability-timer',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the channels that agents can handle in the Contact Control Panel
  /// (CCP) for a routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [mediaConcurrencies] :
  /// The channels that agents can handle in the Contact Control Panel (CCP).
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> updateRoutingProfileConcurrency({
    required String instanceId,
    required List<MediaConcurrency> mediaConcurrencies,
    required String routingProfileId,
  }) async {
    final $payload = <String, dynamic>{
      'MediaConcurrencies': mediaConcurrencies,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/concurrency',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the default outbound queue of a routing profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [defaultOutboundQueueId] :
  /// The identifier for the default outbound queue.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> updateRoutingProfileDefaultOutboundQueue({
    required String defaultOutboundQueueId,
    required String instanceId,
    required String routingProfileId,
  }) async {
    final $payload = <String, dynamic>{
      'DefaultOutboundQueueId': defaultOutboundQueueId,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/default-outbound-queue',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the name and description of a routing profile. The request accepts
  /// the following data in JSON format. At least <code>Name</code> or
  /// <code>Description</code> must be provided.
  ///
  /// May throw [DuplicateResourceException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  ///
  /// Parameter [description] :
  /// The description of the routing profile. Must not be more than 250
  /// characters.
  ///
  /// Parameter [name] :
  /// The name of the routing profile. Must not be more than 127 characters.
  Future<void> updateRoutingProfileName({
    required String instanceId,
    required String routingProfileId,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/name',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the properties associated with a set of queues for a routing
  /// profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [queueConfigs] :
  /// The queues to be updated for this routing profile. Queues must first be
  /// associated to the routing profile. You can do this using
  /// AssociateRoutingProfileQueues.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile.
  Future<void> updateRoutingProfileQueues({
    required String instanceId,
    required List<RoutingProfileQueueConfig> queueConfigs,
    required String routingProfileId,
  }) async {
    final $payload = <String, dynamic>{
      'QueueConfigs': queueConfigs,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/routing-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(routingProfileId)}/queues',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates a rule for the specified Amazon Connect instance.
  ///
  /// Use the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/connect-rules-language.html">Rules
  /// Function language</a> to code conditions for the rule.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [actions] :
  /// A list of actions to be run when the rule is triggered.
  ///
  /// Parameter [function] :
  /// The conditions of the rule.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the rule. You can change the name only if
  /// <code>TriggerEventSource</code> is one of the following values:
  /// <code>OnZendeskTicketCreate</code> |
  /// <code>OnZendeskTicketStatusUpdate</code> |
  /// <code>OnSalesforceCaseCreate</code>
  ///
  /// Parameter [publishStatus] :
  /// The publish status of the rule.
  ///
  /// Parameter [ruleId] :
  /// A unique identifier for the rule.
  Future<void> updateRule({
    required List<RuleAction> actions,
    required String function,
    required String instanceId,
    required String name,
    required RulePublishStatus publishStatus,
    required String ruleId,
  }) async {
    final $payload = <String, dynamic>{
      'Actions': actions,
      'Function': function,
      'Name': name,
      'PublishStatus': publishStatus.value,
    };
    await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/rules/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(ruleId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates a security profile.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileId] :
  /// The identifier for the security profle.
  ///
  /// Parameter [allowedAccessControlHierarchyGroupId] :
  /// The identifier of the hierarchy group that a security profile uses to
  /// restrict access to resources in Amazon Connect.
  ///
  /// Parameter [allowedAccessControlTags] :
  /// The list of tags that a security profile uses to restrict access to
  /// resources in Amazon Connect.
  ///
  /// Parameter [applications] :
  /// A list of the third-party application's metadata.
  ///
  /// Parameter [description] :
  /// The description of the security profile.
  ///
  /// Parameter [hierarchyRestrictedResources] :
  /// The list of resources that a security profile applies hierarchy
  /// restrictions to in Amazon Connect. Following are acceptable ResourceNames:
  /// <code>User</code>.
  ///
  /// Parameter [permissions] :
  /// The permissions granted to a security profile. For a list of valid
  /// permissions, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List
  /// of security profile permissions</a>.
  ///
  /// Parameter [tagRestrictedResources] :
  /// The list of resources that a security profile applies tag restrictions to
  /// in Amazon Connect.
  Future<void> updateSecurityProfile({
    required String instanceId,
    required String securityProfileId,
    String? allowedAccessControlHierarchyGroupId,
    Map<String, String>? allowedAccessControlTags,
    List<Application>? applications,
    String? description,
    List<String>? hierarchyRestrictedResources,
    List<String>? permissions,
    List<String>? tagRestrictedResources,
  }) async {
    final $payload = <String, dynamic>{
      if (allowedAccessControlHierarchyGroupId != null)
        'AllowedAccessControlHierarchyGroupId':
            allowedAccessControlHierarchyGroupId,
      if (allowedAccessControlTags != null)
        'AllowedAccessControlTags': allowedAccessControlTags,
      if (applications != null) 'Applications': applications,
      if (description != null) 'Description': description,
      if (hierarchyRestrictedResources != null)
        'HierarchyRestrictedResources': hierarchyRestrictedResources,
      if (permissions != null) 'Permissions': permissions,
      if (tagRestrictedResources != null)
        'TagRestrictedResources': tagRestrictedResources,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/security-profiles/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(securityProfileId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates details about a specific task template in the specified Amazon
  /// Connect instance. This operation does not support partial updates. Instead
  /// it does a full update of template content.
  ///
  /// May throw [PropertyValidationException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ServiceQuotaExceededException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [taskTemplateId] :
  /// A unique identifier for the task template.
  ///
  /// Parameter [constraints] :
  /// Constraints that are applicable to the fields listed.
  ///
  /// Parameter [contactFlowId] :
  /// The identifier of the flow that runs by default when a task is created by
  /// referencing this template.
  ///
  /// Parameter [defaults] :
  /// The default values for fields when a task is created by referencing this
  /// template.
  ///
  /// Parameter [description] :
  /// The description of the task template.
  ///
  /// Parameter [fields] :
  /// Fields that are part of the template.
  ///
  /// Parameter [name] :
  /// The name of the task template.
  ///
  /// Parameter [status] :
  /// Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a
  /// task to refer to it. Tasks can only be created from <code>ACTIVE</code>
  /// templates. If a template is marked as <code>INACTIVE</code>, then a task
  /// that refers to this template cannot be created.
  Future<UpdateTaskTemplateResponse> updateTaskTemplate({
    required String instanceId,
    required String taskTemplateId,
    TaskTemplateConstraints? constraints,
    String? contactFlowId,
    TaskTemplateDefaults? defaults,
    String? description,
    List<TaskTemplateField>? fields,
    String? name,
    TaskTemplateStatus? status,
  }) async {
    final $payload = <String, dynamic>{
      if (constraints != null) 'Constraints': constraints,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
      if (defaults != null) 'Defaults': defaults,
      if (description != null) 'Description': description,
      if (fields != null) 'Fields': fields,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/instance/${Uri.encodeComponent(instanceId)}/task/template/${Uri.encodeComponent(taskTemplateId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTaskTemplateResponse.fromJson(response);
  }

  /// Updates the traffic distribution for a given traffic distribution group.
  /// <note>
  /// The <code>SignInConfig</code> distribution is available only on a default
  /// <code>TrafficDistributionGroup</code> (see the <code>IsDefault</code>
  /// parameter in the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_TrafficDistributionGroup.html">TrafficDistributionGroup</a>
  /// data type). If you call <code>UpdateTrafficDistribution</code> with a
  /// modified <code>SignInConfig</code> and a non-default
  /// <code>TrafficDistributionGroup</code>, an
  /// <code>InvalidRequestException</code> is returned.
  /// </note>
  /// For more information about updating a traffic distribution group, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/update-telephony-traffic-distribution.html">Update
  /// telephony traffic distribution across Amazon Web Services Regions </a> in
  /// the <i>Amazon Connect Administrator Guide</i>.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [id] :
  /// The identifier of the traffic distribution group. This can be the ID or
  /// the ARN if the API is being called in the Region where the traffic
  /// distribution group was created. The ARN must be provided if the call is
  /// from the replicated Region.
  ///
  /// Parameter [agentConfig] :
  /// The distribution of agents between the instance and its replica(s).
  ///
  /// Parameter [signInConfig] :
  /// The distribution that determines which Amazon Web Services Regions should
  /// be used to sign in agents in to both the instance and its replica(s).
  ///
  /// Parameter [telephonyConfig] :
  /// The distribution of traffic between the instance and its replica(s).
  Future<void> updateTrafficDistribution({
    required String id,
    AgentConfig? agentConfig,
    SignInConfig? signInConfig,
    TelephonyConfig? telephonyConfig,
  }) async {
    final $payload = <String, dynamic>{
      if (agentConfig != null) 'AgentConfig': agentConfig,
      if (signInConfig != null) 'SignInConfig': signInConfig,
      if (telephonyConfig != null) 'TelephonyConfig': telephonyConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/traffic-distribution/${Uri.encodeComponent(id)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Assigns the specified hierarchy group to the specified user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  ///
  /// Parameter [hierarchyGroupId] :
  /// The identifier of the hierarchy group.
  Future<void> updateUserHierarchy({
    required String instanceId,
    required String userId,
    String? hierarchyGroupId,
  }) async {
    final $payload = <String, dynamic>{
      if (hierarchyGroupId != null) 'HierarchyGroupId': hierarchyGroupId,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/hierarchy',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the name of the user hierarchy group.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hierarchyGroupId] :
  /// The identifier of the hierarchy group.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [name] :
  /// The name of the hierarchy group. Must not be more than 100 characters.
  Future<void> updateUserHierarchyGroupName({
    required String hierarchyGroupId,
    required String instanceId,
    required String name,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/user-hierarchy-groups/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(hierarchyGroupId)}/name',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the user hierarchy structure: add, remove, and rename user
  /// hierarchy levels.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [hierarchyStructure] :
  /// The hierarchy levels to update.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  Future<void> updateUserHierarchyStructure({
    required HierarchyStructureUpdate hierarchyStructure,
    required String instanceId,
  }) async {
    final $payload = <String, dynamic>{
      'HierarchyStructure': hierarchyStructure,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/user-hierarchy-structure/${Uri.encodeComponent(instanceId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the identity information for the specified user.
  /// <important>
  /// We strongly recommend limiting who has the ability to invoke
  /// <code>UpdateUserIdentityInfo</code>. Someone with that ability can change
  /// the login credentials of other users by changing their email address. This
  /// poses a security risk to your organization. They can change the email
  /// address of a user to the attacker's email address, and then reset the
  /// password through email. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-best-practices.html">Best
  /// Practices for Security Profiles</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  /// </important>
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [identityInfo] :
  /// The identity information for the user.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  Future<void> updateUserIdentityInfo({
    required UserIdentityInfo identityInfo,
    required String instanceId,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'IdentityInfo': identityInfo,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/identity-info',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the phone configuration settings for the specified user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [phoneConfig] :
  /// Information about phone configuration settings for the user.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  Future<void> updateUserPhoneConfig({
    required String instanceId,
    required UserPhoneConfig phoneConfig,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'PhoneConfig': phoneConfig,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/phone-config',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the properties associated with the proficiencies of a user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instance
  /// ID in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  ///
  /// Parameter [userProficiencies] :
  /// The proficiencies to be updated for the user. Proficiencies must first be
  /// associated to the user. You can do this using AssociateUserProficiencies
  /// API.
  Future<void> updateUserProficiencies({
    required String instanceId,
    required String userId,
    required List<UserProficiency> userProficiencies,
  }) async {
    final $payload = <String, dynamic>{
      'UserProficiencies': userProficiencies,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/proficiencies',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Assigns the specified routing profile to the specified user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [routingProfileId] :
  /// The identifier of the routing profile for the user.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  Future<void> updateUserRoutingProfile({
    required String instanceId,
    required String routingProfileId,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'RoutingProfileId': routingProfileId,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/routing-profile',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Assigns the specified security profiles to the specified user.
  ///
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalServiceException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  ///
  /// Parameter [securityProfileIds] :
  /// The identifiers of the security profiles for the user.
  ///
  /// Parameter [userId] :
  /// The identifier of the user account.
  Future<void> updateUserSecurityProfiles({
    required String instanceId,
    required List<String> securityProfileIds,
    required String userId,
  }) async {
    final $payload = <String, dynamic>{
      'SecurityProfileIds': securityProfileIds,
    };
    await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/users/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(userId)}/security-profiles',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the view content of the given view identifier in the specified
  /// Amazon Connect instance.
  ///
  /// It performs content validation if <code>Status</code> is set to
  /// <code>SAVED</code> and performs full content validation if
  /// <code>Status</code> is <code>PUBLISHED</code>. Note that the
  /// <code>$SAVED</code> alias' content will always be updated, but the
  /// <code>$LATEST</code> alias' content will only be updated if
  /// <code>Status</code> is <code>PUBLISHED</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [content] :
  /// View content containing all content necessary to render a view except for
  /// runtime input data and the runtime input schema, which is auto-generated
  /// by this operation.
  ///
  /// The total uncompressed content has a maximum file size of 400kB.
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [status] :
  /// Indicates the view status as either <code>SAVED</code> or
  /// <code>PUBLISHED</code>. The <code>PUBLISHED</code> status will initiate
  /// validation on the content.
  ///
  /// Parameter [viewId] :
  /// The identifier of the view. Both <code>ViewArn</code> and
  /// <code>ViewId</code> can be used.
  Future<UpdateViewContentResponse> updateViewContent({
    required ViewInputContent content,
    required String instanceId,
    required ViewStatus status,
    required String viewId,
  }) async {
    final $payload = <String, dynamic>{
      'Content': content,
      'Status': status.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateViewContentResponse.fromJson(response);
  }

  /// Updates the view metadata. Note that either <code>Name</code> or
  /// <code>Description</code> must be provided.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidRequestException].
  /// May throw [InvalidParameterException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServiceException].
  /// May throw [TooManyRequestsException].
  /// May throw [DuplicateResourceException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [instanceId] :
  /// The identifier of the Amazon Connect instance. You can find the instanceId
  /// in the ARN of the instance.
  ///
  /// Parameter [viewId] :
  /// The identifier of the view. Both <code>ViewArn</code> and
  /// <code>ViewId</code> can be used.
  ///
  /// Parameter [description] :
  /// The description of the view.
  ///
  /// Parameter [name] :
  /// The name of the view.
  Future<void> updateViewMetadata({
    required String instanceId,
    required String viewId,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/views/${Uri.encodeComponent(instanceId)}/${Uri.encodeComponent(viewId)}/metadata',
      exceptionFnMap: _exceptionFns,
    );
  }
}

/// Information about an action.
class ActionSummary {
  /// The action type.
  final ActionType actionType;

  ActionSummary({
    required this.actionType,
  });

  factory ActionSummary.fromJson(Map<String, dynamic> json) {
    return ActionSummary(
      actionType: ActionType.fromString((json['ActionType'] as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final actionType = this.actionType;
    return {
      'ActionType': actionType.value,
    };
  }
}

enum ActionType {
  createTask('CREATE_TASK'),
  assignContactCategory('ASSIGN_CONTACT_CATEGORY'),
  generateEventbridgeEvent('GENERATE_EVENTBRIDGE_EVENT'),
  sendNotification('SEND_NOTIFICATION'),
  createCase('CREATE_CASE'),
  updateCase('UPDATE_CASE'),
  endAssociatedTasks('END_ASSOCIATED_TASKS'),
  submitAutoEvaluation('SUBMIT_AUTO_EVALUATION'),
  ;

  final String value;

  const ActionType(this.value);

  static ActionType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum ActionType'));
}

class ActivateEvaluationFormResponse {
  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// A version of the evaluation form.
  final int evaluationFormVersion;

  ActivateEvaluationFormResponse({
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.evaluationFormVersion,
  });

  factory ActivateEvaluationFormResponse.fromJson(Map<String, dynamic> json) {
    return ActivateEvaluationFormResponse(
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormVersion: json['EvaluationFormVersion'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormVersion = this.evaluationFormVersion;
    return {
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormVersion': evaluationFormVersion,
    };
  }
}

enum AgentAvailabilityTimer {
  timeSinceLastActivity('TIME_SINCE_LAST_ACTIVITY'),
  timeSinceLastInbound('TIME_SINCE_LAST_INBOUND'),
  ;

  final String value;

  const AgentAvailabilityTimer(this.value);

  static AgentAvailabilityTimer fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum AgentAvailabilityTimer'));
}

/// The distribution of agents between the instance and its replica(s).
class AgentConfig {
  /// Information about traffic distributions.
  final List<Distribution> distributions;

  AgentConfig({
    required this.distributions,
  });

  factory AgentConfig.fromJson(Map<String, dynamic> json) {
    return AgentConfig(
      distributions: (json['Distributions'] as List)
          .nonNulls
          .map((e) => Distribution.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final distributions = this.distributions;
    return {
      'Distributions': distributions,
    };
  }
}

/// Information about the <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_Contact.html">contact</a>
/// associated to the user.
class AgentContactReference {
  /// The <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">state
  /// of the contact</a>.
  /// <note>
  /// When <code>AgentContactState</code> is set to <code>CONNECTED_ONHOLD</code>,
  /// <code>StateStartTimestamp</code> is not changed. Instead,
  /// <code>StateStartTimestamp</code> reflects the time the contact was
  /// <code>CONNECTED</code> to the agent.
  /// </note>
  final ContactState? agentContactState;

  /// The channel of the contact.
  final Channel? channel;

  /// The time at which the contact was connected to an agent.
  final DateTime? connectedToAgentTimestamp;

  /// The identifier of the contact in this instance of Amazon Connect.
  final String? contactId;

  /// How the contact was initiated.
  final ContactInitiationMethod? initiationMethod;
  final QueueReference? queue;

  /// The epoch timestamp when the contact state started.
  final DateTime? stateStartTimestamp;

  AgentContactReference({
    this.agentContactState,
    this.channel,
    this.connectedToAgentTimestamp,
    this.contactId,
    this.initiationMethod,
    this.queue,
    this.stateStartTimestamp,
  });

  factory AgentContactReference.fromJson(Map<String, dynamic> json) {
    return AgentContactReference(
      agentContactState:
          (json['AgentContactState'] as String?)?.let(ContactState.fromString),
      channel: (json['Channel'] as String?)?.let(Channel.fromString),
      connectedToAgentTimestamp:
          timeStampFromJson(json['ConnectedToAgentTimestamp']),
      contactId: json['ContactId'] as String?,
      initiationMethod: (json['InitiationMethod'] as String?)
          ?.let(ContactInitiationMethod.fromString),
      queue: json['Queue'] != null
          ? QueueReference.fromJson(json['Queue'] as Map<String, dynamic>)
          : null,
      stateStartTimestamp: timeStampFromJson(json['StateStartTimestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    final agentContactState = this.agentContactState;
    final channel = this.channel;
    final connectedToAgentTimestamp = this.connectedToAgentTimestamp;
    final contactId = this.contactId;
    final initiationMethod = this.initiationMethod;
    final queue = this.queue;
    final stateStartTimestamp = this.stateStartTimestamp;
    return {
      if (agentContactState != null)
        'AgentContactState': agentContactState.value,
      if (channel != null) 'Channel': channel.value,
      if (connectedToAgentTimestamp != null)
        'ConnectedToAgentTimestamp':
            unixTimestampToJson(connectedToAgentTimestamp),
      if (contactId != null) 'ContactId': contactId,
      if (initiationMethod != null) 'InitiationMethod': initiationMethod.value,
      if (queue != null) 'Queue': queue,
      if (stateStartTimestamp != null)
        'StateStartTimestamp': unixTimestampToJson(stateStartTimestamp),
    };
  }
}

/// Information about an agent hierarchy group.
class AgentHierarchyGroup {
  /// The Amazon Resource Name (ARN) of the group.
  final String? arn;

  AgentHierarchyGroup({
    this.arn,
  });

  factory AgentHierarchyGroup.fromJson(Map<String, dynamic> json) {
    return AgentHierarchyGroup(
      arn: json['Arn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    return {
      if (arn != null) 'Arn': arn,
    };
  }
}

/// A structure that defines search criteria for contacts using agent hierarchy
/// group levels. For more information about agent hierarchies, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/agent-hierarchy.html">Set
/// Up Agent Hierarchies</a> in the <i>Amazon Connect Administrator Guide</i>.
class AgentHierarchyGroups {
  /// The identifiers for level 1 hierarchy groups.
  final List<String>? l1Ids;

  /// The identifiers for level 2 hierarchy groups.
  final List<String>? l2Ids;

  /// The identifiers for level 3 hierarchy groups.
  final List<String>? l3Ids;

  /// The identifiers for level 4 hierarchy groups.
  final List<String>? l4Ids;

  /// The identifiers for level 5 hierarchy groups.
  final List<String>? l5Ids;

  AgentHierarchyGroups({
    this.l1Ids,
    this.l2Ids,
    this.l3Ids,
    this.l4Ids,
    this.l5Ids,
  });

  Map<String, dynamic> toJson() {
    final l1Ids = this.l1Ids;
    final l2Ids = this.l2Ids;
    final l3Ids = this.l3Ids;
    final l4Ids = this.l4Ids;
    final l5Ids = this.l5Ids;
    return {
      if (l1Ids != null) 'L1Ids': l1Ids,
      if (l2Ids != null) 'L2Ids': l2Ids,
      if (l3Ids != null) 'L3Ids': l3Ids,
      if (l4Ids != null) 'L4Ids': l4Ids,
      if (l5Ids != null) 'L5Ids': l5Ids,
    };
  }
}

/// Information about the agent who accepted the contact.
class AgentInfo {
  /// Agent pause duration for a contact in seconds.
  final int? agentPauseDurationInSeconds;
  final ParticipantCapabilities? capabilities;

  /// The timestamp when the contact was connected to the agent.
  final DateTime? connectedToAgentTimestamp;

  /// Information regarding Agent’s device.
  final DeviceInfo? deviceInfo;

  /// The agent hierarchy groups for the agent.
  final HierarchyGroups? hierarchyGroups;

  /// The identifier of the agent who accepted the contact.
  final String? id;

  AgentInfo({
    this.agentPauseDurationInSeconds,
    this.capabilities,
    this.connectedToAgentTimestamp,
    this.deviceInfo,
    this.hierarchyGroups,
    this.id,
  });

  factory AgentInfo.fromJson(Map<String, dynamic> json) {
    return AgentInfo(
      agentPauseDurationInSeconds: json['AgentPauseDurationInSeconds'] as int?,
      capabilities: json['Capabilities'] != null
          ? ParticipantCapabilities.fromJson(
              json['Capabilities'] as Map<String, dynamic>)
          : null,
      connectedToAgentTimestamp:
          timeStampFromJson(json['ConnectedToAgentTimestamp']),
      deviceInfo: json['DeviceInfo'] != null
          ? DeviceInfo.fromJson(json['DeviceInfo'] as Map<String, dynamic>)
          : null,
      hierarchyGroups: json['HierarchyGroups'] != null
          ? HierarchyGroups.fromJson(
              json['HierarchyGroups'] as Map<String, dynamic>)
          : null,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final agentPauseDurationInSeconds = this.agentPauseDurationInSeconds;
    final capabilities = this.capabilities;
    final connectedToAgentTimestamp = this.connectedToAgentTimestamp;
    final deviceInfo = this.deviceInfo;
    final hierarchyGroups = this.hierarchyGroups;
    final id = this.id;
    return {
      if (agentPauseDurationInSeconds != null)
        'AgentPauseDurationInSeconds': agentPauseDurationInSeconds,
      if (capabilities != null) 'Capabilities': capabilities,
      if (connectedToAgentTimestamp != null)
        'ConnectedToAgentTimestamp':
            unixTimestampToJson(connectedToAgentTimestamp),
      if (deviceInfo != null) 'DeviceInfo': deviceInfo,
      if (hierarchyGroups != null) 'HierarchyGroups': hierarchyGroups,
      if (id != null) 'Id': id,
    };
  }
}

/// Information about the quality of the Agent's media connection
class AgentQualityMetrics {
  /// Information about the audio quality of the Agent
  final AudioQualityMetricsInfo? audio;

  AgentQualityMetrics({
    this.audio,
  });

  factory AgentQualityMetrics.fromJson(Map<String, dynamic> json) {
    return AgentQualityMetrics(
      audio: json['Audio'] != null
          ? AudioQualityMetricsInfo.fromJson(
              json['Audio'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final audio = this.audio;
    return {
      if (audio != null) 'Audio': audio,
    };
  }
}

/// Contains information about an agent status.
class AgentStatus {
  /// The Amazon Resource Name (ARN) of the agent status.
  final String? agentStatusARN;

  /// The identifier of the agent status.
  final String? agentStatusId;

  /// The description of the agent status.
  final String? description;

  /// The display order of the agent status.
  final int? displayOrder;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the agent status.
  final String? name;

  /// The state of the agent status.
  final AgentStatusState? state;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  /// The type of agent status.
  final AgentStatusType? type;

  AgentStatus({
    this.agentStatusARN,
    this.agentStatusId,
    this.description,
    this.displayOrder,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.state,
    this.tags,
    this.type,
  });

  factory AgentStatus.fromJson(Map<String, dynamic> json) {
    return AgentStatus(
      agentStatusARN: json['AgentStatusARN'] as String?,
      agentStatusId: json['AgentStatusId'] as String?,
      description: json['Description'] as String?,
      displayOrder: json['DisplayOrder'] as int?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      state: (json['State'] as String?)?.let(AgentStatusState.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      type: (json['Type'] as String?)?.let(AgentStatusType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final agentStatusARN = this.agentStatusARN;
    final agentStatusId = this.agentStatusId;
    final description = this.description;
    final displayOrder = this.displayOrder;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final state = this.state;
    final tags = this.tags;
    final type = this.type;
    return {
      if (agentStatusARN != null) 'AgentStatusARN': agentStatusARN,
      if (agentStatusId != null) 'AgentStatusId': agentStatusId,
      if (description != null) 'Description': description,
      if (displayOrder != null) 'DisplayOrder': displayOrder,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (state != null) 'State': state.value,
      if (tags != null) 'Tags': tags,
      if (type != null) 'Type': type.value,
    };
  }
}

/// Information about the agent's status.
class AgentStatusReference {
  /// The Amazon Resource Name (ARN) of the agent's status.
  final String? statusArn;

  /// The name of the agent status.
  final String? statusName;

  /// The start timestamp of the agent's status.
  final DateTime? statusStartTimestamp;

  AgentStatusReference({
    this.statusArn,
    this.statusName,
    this.statusStartTimestamp,
  });

  factory AgentStatusReference.fromJson(Map<String, dynamic> json) {
    return AgentStatusReference(
      statusArn: json['StatusArn'] as String?,
      statusName: json['StatusName'] as String?,
      statusStartTimestamp: timeStampFromJson(json['StatusStartTimestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    final statusArn = this.statusArn;
    final statusName = this.statusName;
    final statusStartTimestamp = this.statusStartTimestamp;
    return {
      if (statusArn != null) 'StatusArn': statusArn,
      if (statusName != null) 'StatusName': statusName,
      if (statusStartTimestamp != null)
        'StatusStartTimestamp': unixTimestampToJson(statusStartTimestamp),
    };
  }
}

enum AgentStatusState {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const AgentStatusState(this.value);

  static AgentStatusState fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum AgentStatusState'));
}

/// Summary information for an agent status.
class AgentStatusSummary {
  /// The Amazon Resource Name (ARN) for the agent status.
  final String? arn;

  /// The identifier for an agent status.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the agent status.
  final String? name;

  /// The type of the agent status.
  final AgentStatusType? type;

  AgentStatusSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.type,
  });

  factory AgentStatusSummary.fromJson(Map<String, dynamic> json) {
    return AgentStatusSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      type: (json['Type'] as String?)?.let(AgentStatusType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final type = this.type;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (type != null) 'Type': type.value,
    };
  }
}

enum AgentStatusType {
  routable('ROUTABLE'),
  custom('CUSTOM'),
  offline('OFFLINE'),
  ;

  final String value;

  const AgentStatusType(this.value);

  static AgentStatusType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum AgentStatusType'));
}

/// Information about the capabilities enabled for participants of the contact.
class AllowedCapabilities {
  /// Information about the agent's video sharing capabilities.
  final ParticipantCapabilities? agent;

  /// Information about the customer's video sharing capabilities.
  final ParticipantCapabilities? customer;

  AllowedCapabilities({
    this.agent,
    this.customer,
  });

  Map<String, dynamic> toJson() {
    final agent = this.agent;
    final customer = this.customer;
    return {
      if (agent != null) 'Agent': agent,
      if (customer != null) 'Customer': customer,
    };
  }
}

/// This API is in preview release for Amazon Connect and is subject to change.
///
/// Information about associations that are successfully created:
/// <code>DataSetId</code>, <code>TargetAccountId</code>,
/// <code>ResourceShareId</code>, <code>ResourceShareArn</code>.
class AnalyticsDataAssociationResult {
  /// The identifier of the dataset.
  final String? dataSetId;

  /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
  final String? resourceShareArn;

  /// The Resource Access Manager share ID.
  final String? resourceShareId;

  /// The identifier of the target account.
  final String? targetAccountId;

  AnalyticsDataAssociationResult({
    this.dataSetId,
    this.resourceShareArn,
    this.resourceShareId,
    this.targetAccountId,
  });

  factory AnalyticsDataAssociationResult.fromJson(Map<String, dynamic> json) {
    return AnalyticsDataAssociationResult(
      dataSetId: json['DataSetId'] as String?,
      resourceShareArn: json['ResourceShareArn'] as String?,
      resourceShareId: json['ResourceShareId'] as String?,
      targetAccountId: json['TargetAccountId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetId = this.dataSetId;
    final resourceShareArn = this.resourceShareArn;
    final resourceShareId = this.resourceShareId;
    final targetAccountId = this.targetAccountId;
    return {
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (resourceShareArn != null) 'ResourceShareArn': resourceShareArn,
      if (resourceShareId != null) 'ResourceShareId': resourceShareId,
      if (targetAccountId != null) 'TargetAccountId': targetAccountId,
    };
  }
}

/// Configuration of the answering machine detection.
class AnswerMachineDetectionConfig {
  /// Wait for the answering machine prompt.
  final bool? awaitAnswerMachinePrompt;

  /// The flag to indicate if answer machine detection analysis needs to be
  /// performed for a voice call. If set to <code>true</code>,
  /// <code>TrafficType</code> must be set as <code>CAMPAIGN</code>.
  final bool? enableAnswerMachineDetection;

  AnswerMachineDetectionConfig({
    this.awaitAnswerMachinePrompt,
    this.enableAnswerMachineDetection,
  });

  Map<String, dynamic> toJson() {
    final awaitAnswerMachinePrompt = this.awaitAnswerMachinePrompt;
    final enableAnswerMachineDetection = this.enableAnswerMachineDetection;
    return {
      if (awaitAnswerMachinePrompt != null)
        'AwaitAnswerMachinePrompt': awaitAnswerMachinePrompt,
      if (enableAnswerMachineDetection != null)
        'EnableAnswerMachineDetection': enableAnswerMachineDetection,
    };
  }
}

enum AnsweringMachineDetectionStatus {
  answered('ANSWERED'),
  undetected('UNDETECTED'),
  error('ERROR'),
  humanAnswered('HUMAN_ANSWERED'),
  sitToneDetected('SIT_TONE_DETECTED'),
  sitToneBusy('SIT_TONE_BUSY'),
  sitToneInvalidNumber('SIT_TONE_INVALID_NUMBER'),
  faxMachineDetected('FAX_MACHINE_DETECTED'),
  voicemailBeep('VOICEMAIL_BEEP'),
  voicemailNoBeep('VOICEMAIL_NO_BEEP'),
  amdUnresolved('AMD_UNRESOLVED'),
  amdUnanswered('AMD_UNANSWERED'),
  amdError('AMD_ERROR'),
  amdNotApplicable('AMD_NOT_APPLICABLE'),
  ;

  final String value;

  const AnsweringMachineDetectionStatus(this.value);

  static AnsweringMachineDetectionStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum AnsweringMachineDetectionStatus'));
}

/// This API is in preview release for Amazon Connect and is subject to change.
///
/// A third-party application's metadata.
class Application {
  /// The permissions that the agent is granted on the application. Only the
  /// <code>ACCESS</code> permission is supported.
  final List<String>? applicationPermissions;

  /// Namespace of the application that you want to give access to.
  final String? namespace;

  Application({
    this.applicationPermissions,
    this.namespace,
  });

  factory Application.fromJson(Map<String, dynamic> json) {
    return Application(
      applicationPermissions: (json['ApplicationPermissions'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      namespace: json['Namespace'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final applicationPermissions = this.applicationPermissions;
    final namespace = this.namespace;
    return {
      if (applicationPermissions != null)
        'ApplicationPermissions': applicationPermissions,
      if (namespace != null) 'Namespace': namespace,
    };
  }
}

enum ArtifactStatus {
  approved('APPROVED'),
  rejected('REJECTED'),
  inProgress('IN_PROGRESS'),
  ;

  final String value;

  const ArtifactStatus(this.value);

  static ArtifactStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ArtifactStatus'));
}

/// This action must be set if <code>TriggerEventSource</code> is one of the
/// following values: <code>OnPostCallAnalysisAvailable</code> |
/// <code>OnRealTimeCallAnalysisAvailable</code> |
/// <code>OnRealTimeChatAnalysisAvailable</code> |
/// <code>OnPostChatAnalysisAvailable</code>. Contact is categorized using the
/// rule name.
///
/// <code>RuleName</code> is used as <code>ContactCategory</code>.
class AssignContactCategoryActionDefinition {
  AssignContactCategoryActionDefinition();

  factory AssignContactCategoryActionDefinition.fromJson(
      Map<String, dynamic> _) {
    return AssignContactCategoryActionDefinition();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class AssociateAnalyticsDataSetResponse {
  /// The identifier of the dataset that was associated.
  final String? dataSetId;

  /// The Amazon Resource Name (ARN) of the Resource Access Manager share.
  final String? resourceShareArn;

  /// The Resource Access Manager share ID that is generated.
  final String? resourceShareId;

  /// The identifier of the target account.
  final String? targetAccountId;

  AssociateAnalyticsDataSetResponse({
    this.dataSetId,
    this.resourceShareArn,
    this.resourceShareId,
    this.targetAccountId,
  });

  factory AssociateAnalyticsDataSetResponse.fromJson(
      Map<String, dynamic> json) {
    return AssociateAnalyticsDataSetResponse(
      dataSetId: json['DataSetId'] as String?,
      resourceShareArn: json['ResourceShareArn'] as String?,
      resourceShareId: json['ResourceShareId'] as String?,
      targetAccountId: json['TargetAccountId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetId = this.dataSetId;
    final resourceShareArn = this.resourceShareArn;
    final resourceShareId = this.resourceShareId;
    final targetAccountId = this.targetAccountId;
    return {
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (resourceShareArn != null) 'ResourceShareArn': resourceShareArn,
      if (resourceShareId != null) 'ResourceShareId': resourceShareId,
      if (targetAccountId != null) 'TargetAccountId': targetAccountId,
    };
  }
}

class AssociateDefaultVocabularyResponse {
  AssociateDefaultVocabularyResponse();

  factory AssociateDefaultVocabularyResponse.fromJson(Map<String, dynamic> _) {
    return AssociateDefaultVocabularyResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class AssociateFlowResponse {
  AssociateFlowResponse();

  factory AssociateFlowResponse.fromJson(Map<String, dynamic> _) {
    return AssociateFlowResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class AssociateInstanceStorageConfigResponse {
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  final String? associationId;

  AssociateInstanceStorageConfigResponse({
    this.associationId,
  });

  factory AssociateInstanceStorageConfigResponse.fromJson(
      Map<String, dynamic> json) {
    return AssociateInstanceStorageConfigResponse(
      associationId: json['AssociationId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationId = this.associationId;
    return {
      if (associationId != null) 'AssociationId': associationId,
    };
  }
}

class AssociateSecurityKeyResponse {
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  final String? associationId;

  AssociateSecurityKeyResponse({
    this.associationId,
  });

  factory AssociateSecurityKeyResponse.fromJson(Map<String, dynamic> json) {
    return AssociateSecurityKeyResponse(
      associationId: json['AssociationId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationId = this.associationId;
    return {
      if (associationId != null) 'AssociationId': associationId,
    };
  }
}

class AssociateTrafficDistributionGroupUserResponse {
  AssociateTrafficDistributionGroupUserResponse();

  factory AssociateTrafficDistributionGroupUserResponse.fromJson(
      Map<String, dynamic> _) {
    return AssociateTrafficDistributionGroupUserResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Information about the attached file.
class AttachedFile {
  /// The time of Creation of the file resource as an ISO timestamp. It's
  /// specified in ISO 8601 format: <code>yyyy-MM-ddThh:mm:ss.SSSZ</code>. For
  /// example, <code>2024-05-03T02:41:28.172Z</code>.
  final String creationTime;

  /// The unique identifier of the attached file resource (ARN).
  final String fileArn;

  /// The unique identifier of the attached file resource.
  final String fileId;

  /// A case-sensitive name of the attached file being uploaded.
  final String fileName;

  /// The size of the attached file in bytes.
  final int fileSizeInBytes;

  /// The current status of the attached file.
  final FileStatusType fileStatus;

  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  /// <note>
  /// This value must be a valid ARN.
  /// </note>
  final String? associatedResourceArn;

  /// Represents the identity that created the file.
  final CreatedByInfo? createdBy;

  /// The use case for the file.
  final FileUseCaseType? fileUseCaseType;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, <code>{ "Tags": {"key1":"value1", "key2":"value2"} }</code>.
  final Map<String, String>? tags;

  AttachedFile({
    required this.creationTime,
    required this.fileArn,
    required this.fileId,
    required this.fileName,
    required this.fileSizeInBytes,
    required this.fileStatus,
    this.associatedResourceArn,
    this.createdBy,
    this.fileUseCaseType,
    this.tags,
  });

  factory AttachedFile.fromJson(Map<String, dynamic> json) {
    return AttachedFile(
      creationTime: json['CreationTime'] as String,
      fileArn: json['FileArn'] as String,
      fileId: json['FileId'] as String,
      fileName: json['FileName'] as String,
      fileSizeInBytes: json['FileSizeInBytes'] as int,
      fileStatus: FileStatusType.fromString((json['FileStatus'] as String)),
      associatedResourceArn: json['AssociatedResourceArn'] as String?,
      createdBy: json['CreatedBy'] != null
          ? CreatedByInfo.fromJson(json['CreatedBy'] as Map<String, dynamic>)
          : null,
      fileUseCaseType:
          (json['FileUseCaseType'] as String?)?.let(FileUseCaseType.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final creationTime = this.creationTime;
    final fileArn = this.fileArn;
    final fileId = this.fileId;
    final fileName = this.fileName;
    final fileSizeInBytes = this.fileSizeInBytes;
    final fileStatus = this.fileStatus;
    final associatedResourceArn = this.associatedResourceArn;
    final createdBy = this.createdBy;
    final fileUseCaseType = this.fileUseCaseType;
    final tags = this.tags;
    return {
      'CreationTime': creationTime,
      'FileArn': fileArn,
      'FileId': fileId,
      'FileName': fileName,
      'FileSizeInBytes': fileSizeInBytes,
      'FileStatus': fileStatus.value,
      if (associatedResourceArn != null)
        'AssociatedResourceArn': associatedResourceArn,
      if (createdBy != null) 'CreatedBy': createdBy,
      if (fileUseCaseType != null) 'FileUseCaseType': fileUseCaseType.value,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Error describing a failure to retrieve attached file metadata through
/// BatchGetAttachedFileMetadata action.
class AttachedFileError {
  /// Status code describing the failure.
  final String? errorCode;

  /// Why the attached file couldn't be retrieved.
  final String? errorMessage;

  /// The unique identifier of the attached file resource.
  final String? fileId;

  AttachedFileError({
    this.errorCode,
    this.errorMessage,
    this.fileId,
  });

  factory AttachedFileError.fromJson(Map<String, dynamic> json) {
    return AttachedFileError(
      errorCode: json['ErrorCode'] as String?,
      errorMessage: json['ErrorMessage'] as String?,
      fileId: json['FileId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final errorMessage = this.errorMessage;
    final fileId = this.fileId;
    return {
      if (errorCode != null) 'ErrorCode': errorCode,
      if (errorMessage != null) 'ErrorMessage': errorMessage,
      if (fileId != null) 'FileId': fileId,
    };
  }
}

/// Information about a reference when the <code>referenceType</code> is
/// <code>ATTACHMENT</code>. Otherwise, null.
class AttachmentReference {
  /// Identifier of the attachment reference.
  final String? name;

  /// Status of the attachment reference type.
  final ReferenceStatus? status;

  /// The location path of the attachment reference.
  final String? value;

  AttachmentReference({
    this.name,
    this.status,
    this.value,
  });

  factory AttachmentReference.fromJson(Map<String, dynamic> json) {
    return AttachmentReference(
      name: json['Name'] as String?,
      status: (json['Status'] as String?)?.let(ReferenceStatus.fromString),
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final status = this.status;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
      if (value != null) 'Value': value,
    };
  }
}

/// The attendee information, including attendee ID and join token.
class Attendee {
  /// The Amazon Chime SDK attendee ID.
  final String? attendeeId;

  /// The join token used by the Amazon Chime SDK attendee.
  final String? joinToken;

  Attendee({
    this.attendeeId,
    this.joinToken,
  });

  factory Attendee.fromJson(Map<String, dynamic> json) {
    return Attendee(
      attendeeId: json['AttendeeId'] as String?,
      joinToken: json['JoinToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attendeeId = this.attendeeId;
    final joinToken = this.joinToken;
    return {
      if (attendeeId != null) 'AttendeeId': attendeeId,
      if (joinToken != null) 'JoinToken': joinToken,
    };
  }
}

/// A toggle for an individual feature at the instance level.
class Attribute {
  /// The type of attribute.
  final InstanceAttributeType? attributeType;

  /// The value of the attribute.
  final String? value;

  Attribute({
    this.attributeType,
    this.value,
  });

  factory Attribute.fromJson(Map<String, dynamic> json) {
    return Attribute(
      attributeType: (json['AttributeType'] as String?)
          ?.let(InstanceAttributeType.fromString),
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attributeType = this.attributeType;
    final value = this.value;
    return {
      if (attributeType != null) 'AttributeType': attributeType.value,
      if (value != null) 'Value': value,
    };
  }
}

/// A list of conditions which would be applied together with an
/// <code>AND</code> condition.
class AttributeAndCondition {
  final HierarchyGroupCondition? hierarchyGroupCondition;

  /// A leaf node condition which can be used to specify a tag condition.
  final List<TagCondition>? tagConditions;

  AttributeAndCondition({
    this.hierarchyGroupCondition,
    this.tagConditions,
  });

  Map<String, dynamic> toJson() {
    final hierarchyGroupCondition = this.hierarchyGroupCondition;
    final tagConditions = this.tagConditions;
    return {
      if (hierarchyGroupCondition != null)
        'HierarchyGroupCondition': hierarchyGroupCondition,
      if (tagConditions != null) 'TagConditions': tagConditions,
    };
  }
}

/// An object to specify the predefined attribute condition.
class AttributeCondition {
  /// The operator of the condition.
  final String? comparisonOperator;

  /// The name of predefined attribute.
  final String? name;

  /// The proficiency level of the condition.
  final double? proficiencyLevel;

  /// The value of predefined attribute.
  final String? value;

  AttributeCondition({
    this.comparisonOperator,
    this.name,
    this.proficiencyLevel,
    this.value,
  });

  factory AttributeCondition.fromJson(Map<String, dynamic> json) {
    return AttributeCondition(
      comparisonOperator: json['ComparisonOperator'] as String?,
      name: json['Name'] as String?,
      proficiencyLevel: json['ProficiencyLevel'] as double?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final comparisonOperator = this.comparisonOperator;
    final name = this.name;
    final proficiencyLevel = this.proficiencyLevel;
    final value = this.value;
    return {
      if (comparisonOperator != null) 'ComparisonOperator': comparisonOperator,
      if (name != null) 'Name': name,
      if (proficiencyLevel != null) 'ProficiencyLevel': proficiencyLevel,
      if (value != null) 'Value': value,
    };
  }
}

/// Has audio-specific configurations as the operating parameter for Echo
/// Reduction.
class AudioFeatures {
  /// Makes echo reduction available to clients who connect to the meeting.
  final MeetingFeatureStatus? echoReduction;

  AudioFeatures({
    this.echoReduction,
  });

  factory AudioFeatures.fromJson(Map<String, dynamic> json) {
    return AudioFeatures(
      echoReduction: (json['EchoReduction'] as String?)
          ?.let(MeetingFeatureStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final echoReduction = this.echoReduction;
    return {
      if (echoReduction != null) 'EchoReduction': echoReduction.value,
    };
  }
}

/// Contains information for score and potential quality issues for Audio
class AudioQualityMetricsInfo {
  /// List of potential issues causing degradation of quality on a media
  /// connection. If the service did not detect any potential quality issues the
  /// list is empty.
  ///
  /// Valid values: <code>HighPacketLoss</code> | <code>HighRoundTripTime</code> |
  /// <code>HighJitterBuffer</code>
  final List<String>? potentialQualityIssues;

  /// Number measuring the estimated quality of the media connection.
  final double? qualityScore;

  AudioQualityMetricsInfo({
    this.potentialQualityIssues,
    this.qualityScore,
  });

  factory AudioQualityMetricsInfo.fromJson(Map<String, dynamic> json) {
    return AudioQualityMetricsInfo(
      potentialQualityIssues: (json['PotentialQualityIssues'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      qualityScore: json['QualityScore'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final potentialQualityIssues = this.potentialQualityIssues;
    final qualityScore = this.qualityScore;
    return {
      if (potentialQualityIssues != null)
        'PotentialQualityIssues': potentialQualityIssues,
      if (qualityScore != null) 'QualityScore': qualityScore,
    };
  }
}

/// Information about available phone numbers.
class AvailableNumberSummary {
  /// The phone number. Phone numbers are formatted <code>[+] [country code]
  /// [subscriber number including area code]</code>.
  final String? phoneNumber;

  /// The ISO country code.
  final PhoneNumberCountryCode? phoneNumberCountryCode;

  /// The type of phone number.
  final PhoneNumberType? phoneNumberType;

  AvailableNumberSummary({
    this.phoneNumber,
    this.phoneNumberCountryCode,
    this.phoneNumberType,
  });

  factory AvailableNumberSummary.fromJson(Map<String, dynamic> json) {
    return AvailableNumberSummary(
      phoneNumber: json['PhoneNumber'] as String?,
      phoneNumberCountryCode: (json['PhoneNumberCountryCode'] as String?)
          ?.let(PhoneNumberCountryCode.fromString),
      phoneNumberType:
          (json['PhoneNumberType'] as String?)?.let(PhoneNumberType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final phoneNumber = this.phoneNumber;
    final phoneNumberCountryCode = this.phoneNumberCountryCode;
    final phoneNumberType = this.phoneNumberType;
    return {
      if (phoneNumber != null) 'PhoneNumber': phoneNumber,
      if (phoneNumberCountryCode != null)
        'PhoneNumberCountryCode': phoneNumberCountryCode.value,
      if (phoneNumberType != null) 'PhoneNumberType': phoneNumberType.value,
    };
  }
}

class BatchAssociateAnalyticsDataSetResponse {
  /// Information about associations that are successfully created:
  /// <code>DataSetId</code>, <code>TargetAccountId</code>,
  /// <code>ResourceShareId</code>, <code>ResourceShareArn</code>.
  final List<AnalyticsDataAssociationResult>? created;

  /// A list of errors for datasets that aren't successfully associated with the
  /// target account.
  final List<ErrorResult>? errors;

  BatchAssociateAnalyticsDataSetResponse({
    this.created,
    this.errors,
  });

  factory BatchAssociateAnalyticsDataSetResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchAssociateAnalyticsDataSetResponse(
      created: (json['Created'] as List?)
          ?.nonNulls
          .map((e) => AnalyticsDataAssociationResult.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      errors: (json['Errors'] as List?)
          ?.nonNulls
          .map((e) => ErrorResult.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final created = this.created;
    final errors = this.errors;
    return {
      if (created != null) 'Created': created,
      if (errors != null) 'Errors': errors,
    };
  }
}

class BatchDisassociateAnalyticsDataSetResponse {
  /// An array of successfully disassociated dataset identifiers.
  final List<String>? deleted;

  /// A list of errors for any datasets not successfully removed.
  final List<ErrorResult>? errors;

  BatchDisassociateAnalyticsDataSetResponse({
    this.deleted,
    this.errors,
  });

  factory BatchDisassociateAnalyticsDataSetResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchDisassociateAnalyticsDataSetResponse(
      deleted:
          (json['Deleted'] as List?)?.nonNulls.map((e) => e as String).toList(),
      errors: (json['Errors'] as List?)
          ?.nonNulls
          .map((e) => ErrorResult.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final deleted = this.deleted;
    final errors = this.errors;
    return {
      if (deleted != null) 'Deleted': deleted,
      if (errors != null) 'Errors': errors,
    };
  }
}

class BatchGetAttachedFileMetadataResponse {
  /// List of errors of attached files that could not be retrieved.
  final List<AttachedFileError>? errors;

  /// List of attached files that were successfully retrieved.
  final List<AttachedFile>? files;

  BatchGetAttachedFileMetadataResponse({
    this.errors,
    this.files,
  });

  factory BatchGetAttachedFileMetadataResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchGetAttachedFileMetadataResponse(
      errors: (json['Errors'] as List?)
          ?.nonNulls
          .map((e) => AttachedFileError.fromJson(e as Map<String, dynamic>))
          .toList(),
      files: (json['Files'] as List?)
          ?.nonNulls
          .map((e) => AttachedFile.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final errors = this.errors;
    final files = this.files;
    return {
      if (errors != null) 'Errors': errors,
      if (files != null) 'Files': files,
    };
  }
}

class BatchGetFlowAssociationResponse {
  /// Information about flow associations.
  final List<FlowAssociationSummary>? flowAssociationSummaryList;

  BatchGetFlowAssociationResponse({
    this.flowAssociationSummaryList,
  });

  factory BatchGetFlowAssociationResponse.fromJson(Map<String, dynamic> json) {
    return BatchGetFlowAssociationResponse(
      flowAssociationSummaryList: (json['FlowAssociationSummaryList'] as List?)
          ?.nonNulls
          .map(
              (e) => FlowAssociationSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final flowAssociationSummaryList = this.flowAssociationSummaryList;
    return {
      if (flowAssociationSummaryList != null)
        'FlowAssociationSummaryList': flowAssociationSummaryList,
    };
  }
}

class BatchPutContactResponse {
  /// List of requests for which contact creation failed.
  final List<FailedRequest>? failedRequestList;

  /// List of requests for which contact was successfully created.
  final List<SuccessfulRequest>? successfulRequestList;

  BatchPutContactResponse({
    this.failedRequestList,
    this.successfulRequestList,
  });

  factory BatchPutContactResponse.fromJson(Map<String, dynamic> json) {
    return BatchPutContactResponse(
      failedRequestList: (json['FailedRequestList'] as List?)
          ?.nonNulls
          .map((e) => FailedRequest.fromJson(e as Map<String, dynamic>))
          .toList(),
      successfulRequestList: (json['SuccessfulRequestList'] as List?)
          ?.nonNulls
          .map((e) => SuccessfulRequest.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final failedRequestList = this.failedRequestList;
    final successfulRequestList = this.successfulRequestList;
    return {
      if (failedRequestList != null) 'FailedRequestList': failedRequestList,
      if (successfulRequestList != null)
        'SuccessfulRequestList': successfulRequestList,
    };
  }
}

enum BehaviorType {
  routeCurrentChannelOnly('ROUTE_CURRENT_CHANNEL_ONLY'),
  routeAnyChannel('ROUTE_ANY_CHANNEL'),
  ;

  final String value;

  const BehaviorType(this.value);

  static BehaviorType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum BehaviorType'));
}

/// Information associated with a campaign.
class Campaign {
  /// A unique identifier for a campaign.
  final String? campaignId;

  Campaign({
    this.campaignId,
  });

  factory Campaign.fromJson(Map<String, dynamic> json) {
    return Campaign(
      campaignId: json['CampaignId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final campaignId = this.campaignId;
    return {
      if (campaignId != null) 'CampaignId': campaignId,
    };
  }
}

enum Channel {
  voice('VOICE'),
  chat('CHAT'),
  task('TASK'),
  ;

  final String value;

  const Channel(this.value);

  static Channel fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception('$value is not known in enum Channel'));
}

/// Chat integration event containing payload to perform different chat actions
/// such as:
///
/// <ul>
/// <li>
/// Sending a chat message
/// </li>
/// <li>
/// Sending a chat event, such as typing
/// </li>
/// <li>
/// Disconnecting from a chat
/// </li>
/// </ul>
class ChatEvent {
  /// Type of chat integration event.
  final ChatEventType type;

  /// Content of the message or event. This is required when <code>Type</code> is
  /// <code>MESSAGE</code> and for certain <code>ContentTypes</code> when
  /// <code>Type</code> is <code>EVENT</code>.
  ///
  /// <ul>
  /// <li>
  /// For allowed message content, see the <code>Content</code> parameter in the
  /// <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendMessage.html">SendMessage</a>
  /// topic in the <i>Amazon Connect Participant Service API Reference</i>.
  /// </li>
  /// <li>
  /// For allowed event content, see the <code>Content</code> parameter in the <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendEvent.html">SendEvent</a>
  /// topic in the <i>Amazon Connect Participant Service API Reference</i>.
  /// </li>
  /// </ul>
  final String? content;

  /// Type of content. This is required when <code>Type</code> is
  /// <code>MESSAGE</code> or <code>EVENT</code>.
  ///
  /// <ul>
  /// <li>
  /// For allowed message content types, see the <code>ContentType</code>
  /// parameter in the <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendMessage.html">SendMessage</a>
  /// topic in the <i>Amazon Connect Participant Service API Reference</i>.
  /// </li>
  /// <li>
  /// For allowed event content types, see the <code>ContentType</code> parameter
  /// in the <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_SendEvent.html">SendEvent</a>
  /// topic in the <i>Amazon Connect Participant Service API Reference</i>.
  /// </li>
  /// </ul>
  final String? contentType;

  ChatEvent({
    required this.type,
    this.content,
    this.contentType,
  });

  Map<String, dynamic> toJson() {
    final type = this.type;
    final content = this.content;
    final contentType = this.contentType;
    return {
      'Type': type.value,
      if (content != null) 'Content': content,
      if (contentType != null) 'ContentType': contentType,
    };
  }
}

enum ChatEventType {
  disconnect('DISCONNECT'),
  message('MESSAGE'),
  event('EVENT'),
  ;

  final String value;

  const ChatEventType(this.value);

  static ChatEventType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ChatEventType'));
}

/// A chat message.
class ChatMessage {
  /// The content of the chat message.
  ///
  /// <ul>
  /// <li>
  /// For <code>text/plain</code> and <code>text/markdown</code>, the Length
  /// Constraints are Minimum of 1, Maximum of 1024.
  /// </li>
  /// <li>
  /// For <code>application/json</code>, the Length Constraints are Minimum of 1,
  /// Maximum of 12000.
  /// </li>
  /// <li>
  /// For
  /// <code>application/vnd.amazonaws.connect.message.interactive.response</code>,
  /// the Length Constraints are Minimum of 1, Maximum of 12288.
  /// </li>
  /// </ul>
  final String content;

  /// The type of the content. Supported types are <code>text/plain</code>,
  /// <code>text/markdown</code>, <code>application/json</code>, and
  /// <code>application/vnd.amazonaws.connect.message.interactive.response</code>.
  final String contentType;

  ChatMessage({
    required this.content,
    required this.contentType,
  });

  Map<String, dynamic> toJson() {
    final content = this.content;
    final contentType = this.contentType;
    return {
      'Content': content,
      'ContentType': contentType,
    };
  }
}

/// Configuration information for the chat participant role.
class ChatParticipantRoleConfig {
  /// A list of participant timers. You can specify any unique combination of role
  /// and timer type. Duplicate entries error out the request with a 400.
  final List<ParticipantTimerConfiguration> participantTimerConfigList;

  ChatParticipantRoleConfig({
    required this.participantTimerConfigList,
  });

  Map<String, dynamic> toJson() {
    final participantTimerConfigList = this.participantTimerConfigList;
    return {
      'ParticipantTimerConfigList': participantTimerConfigList,
    };
  }
}

/// The streaming configuration, such as the Amazon SNS streaming endpoint.
class ChatStreamingConfiguration {
  /// The Amazon Resource Name (ARN) of the standard Amazon SNS topic. The Amazon
  /// Resource Name (ARN) of the streaming endpoint that is used to publish
  /// real-time message streaming for chat conversations.
  final String streamingEndpointArn;

  ChatStreamingConfiguration({
    required this.streamingEndpointArn,
  });

  Map<String, dynamic> toJson() {
    final streamingEndpointArn = this.streamingEndpointArn;
    return {
      'StreamingEndpointArn': streamingEndpointArn,
    };
  }
}

class ClaimPhoneNumberResponse {
  /// The Amazon Resource Name (ARN) of the phone number.
  final String? phoneNumberArn;

  /// A unique identifier for the phone number.
  final String? phoneNumberId;

  ClaimPhoneNumberResponse({
    this.phoneNumberArn,
    this.phoneNumberId,
  });

  factory ClaimPhoneNumberResponse.fromJson(Map<String, dynamic> json) {
    return ClaimPhoneNumberResponse(
      phoneNumberArn: json['PhoneNumberArn'] as String?,
      phoneNumberId: json['PhoneNumberId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final phoneNumberArn = this.phoneNumberArn;
    final phoneNumberId = this.phoneNumberId;
    return {
      if (phoneNumberArn != null) 'PhoneNumberArn': phoneNumberArn,
      if (phoneNumberId != null) 'PhoneNumberId': phoneNumberId,
    };
  }
}

/// Information about a phone number that has been claimed to your Amazon
/// Connect instance or traffic distribution group.
class ClaimedPhoneNumberSummary {
  /// The identifier of the Amazon Connect instance that phone numbers are claimed
  /// to. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? instanceId;

  /// The phone number. Phone numbers are formatted <code>[+] [country code]
  /// [subscriber number including area code]</code>.
  final String? phoneNumber;

  /// The Amazon Resource Name (ARN) of the phone number.
  final String? phoneNumberArn;

  /// The ISO country code.
  final PhoneNumberCountryCode? phoneNumberCountryCode;

  /// The description of the phone number.
  final String? phoneNumberDescription;

  /// A unique identifier for the phone number.
  final String? phoneNumberId;

  /// The status of the phone number.
  ///
  /// <ul>
  /// <li>
  /// <code>CLAIMED</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>
  /// or <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>
  /// operation succeeded.
  /// </li>
  /// <li>
  /// <code>IN_PROGRESS</code> means a <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>,
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>,
  /// or <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumberMetadata.html">UpdatePhoneNumberMetadata</a>
  /// operation is still in progress and has not yet completed. You can call <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a>
  /// at a later time to verify if the previous operation has completed.
  /// </li>
  /// <li>
  /// <code>FAILED</code> indicates that the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>
  /// or <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>
  /// operation has failed. It will include a message indicating the failure
  /// reason. A common reason for a failure may be that the <code>TargetArn</code>
  /// value you are claiming or updating a phone number to has reached its limit
  /// of total claimed numbers. If you received a <code>FAILED</code> status from
  /// a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming
  /// the phone number before the number is released back to the inventory for
  /// other customers to claim.
  /// </li>
  /// </ul> <note>
  /// You will not be billed for the phone number during the 1-day period if
  /// number claiming fails.
  /// </note>
  final PhoneNumberStatus? phoneNumberStatus;

  /// The type of phone number.
  final PhoneNumberType? phoneNumberType;

  /// The claimed phone number ARN that was previously imported from the external
  /// service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks
  /// like the ARN of the phone number that was imported from Amazon Pinpoint.
  final String? sourcePhoneNumberArn;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic
  /// distribution groups that phone number inbound traffic is routed through.
  final String? targetArn;

  ClaimedPhoneNumberSummary({
    this.instanceId,
    this.phoneNumber,
    this.phoneNumberArn,
    this.phoneNumberCountryCode,
    this.phoneNumberDescription,
    this.phoneNumberId,
    this.phoneNumberStatus,
    this.phoneNumberType,
    this.sourcePhoneNumberArn,
    this.tags,
    this.targetArn,
  });

  factory ClaimedPhoneNumberSummary.fromJson(Map<String, dynamic> json) {
    return ClaimedPhoneNumberSummary(
      instanceId: json['InstanceId'] as String?,
      phoneNumber: json['PhoneNumber'] as String?,
      phoneNumberArn: json['PhoneNumberArn'] as String?,
      phoneNumberCountryCode: (json['PhoneNumberCountryCode'] as String?)
          ?.let(PhoneNumberCountryCode.fromString),
      phoneNumberDescription: json['PhoneNumberDescription'] as String?,
      phoneNumberId: json['PhoneNumberId'] as String?,
      phoneNumberStatus: json['PhoneNumberStatus'] != null
          ? PhoneNumberStatus.fromJson(
              json['PhoneNumberStatus'] as Map<String, dynamic>)
          : null,
      phoneNumberType:
          (json['PhoneNumberType'] as String?)?.let(PhoneNumberType.fromString),
      sourcePhoneNumberArn: json['SourcePhoneNumberArn'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      targetArn: json['TargetArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final instanceId = this.instanceId;
    final phoneNumber = this.phoneNumber;
    final phoneNumberArn = this.phoneNumberArn;
    final phoneNumberCountryCode = this.phoneNumberCountryCode;
    final phoneNumberDescription = this.phoneNumberDescription;
    final phoneNumberId = this.phoneNumberId;
    final phoneNumberStatus = this.phoneNumberStatus;
    final phoneNumberType = this.phoneNumberType;
    final sourcePhoneNumberArn = this.sourcePhoneNumberArn;
    final tags = this.tags;
    final targetArn = this.targetArn;
    return {
      if (instanceId != null) 'InstanceId': instanceId,
      if (phoneNumber != null) 'PhoneNumber': phoneNumber,
      if (phoneNumberArn != null) 'PhoneNumberArn': phoneNumberArn,
      if (phoneNumberCountryCode != null)
        'PhoneNumberCountryCode': phoneNumberCountryCode.value,
      if (phoneNumberDescription != null)
        'PhoneNumberDescription': phoneNumberDescription,
      if (phoneNumberId != null) 'PhoneNumberId': phoneNumberId,
      if (phoneNumberStatus != null) 'PhoneNumberStatus': phoneNumberStatus,
      if (phoneNumberType != null) 'PhoneNumberType': phoneNumberType.value,
      if (sourcePhoneNumberArn != null)
        'SourcePhoneNumberArn': sourcePhoneNumberArn,
      if (tags != null) 'Tags': tags,
      if (targetArn != null) 'TargetArn': targetArn,
    };
  }
}

enum Comparison {
  lt('LT'),
  ;

  final String value;

  const Comparison(this.value);

  static Comparison fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum Comparison'));
}

/// Response from CompleteAttachedFileUpload API
class CompleteAttachedFileUploadResponse {
  CompleteAttachedFileUploadResponse();

  factory CompleteAttachedFileUploadResponse.fromJson(Map<String, dynamic> _) {
    return CompleteAttachedFileUploadResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Information required to join the call.
class ConnectionData {
  /// The attendee information, including attendee ID and join token.
  final Attendee? attendee;

  /// A meeting created using the Amazon Chime SDK.
  final Meeting? meeting;

  ConnectionData({
    this.attendee,
    this.meeting,
  });

  factory ConnectionData.fromJson(Map<String, dynamic> json) {
    return ConnectionData(
      attendee: json['Attendee'] != null
          ? Attendee.fromJson(json['Attendee'] as Map<String, dynamic>)
          : null,
      meeting: json['Meeting'] != null
          ? Meeting.fromJson(json['Meeting'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final attendee = this.attendee;
    final meeting = this.meeting;
    return {
      if (attendee != null) 'Attendee': attendee,
      if (meeting != null) 'Meeting': meeting,
    };
  }
}

/// Contains information about a contact.
class Contact {
  /// Information about the agent who accepted the contact.
  final AgentInfo? agentInfo;

  /// Indicates how an <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/how-to-create-campaigns.html">outbound
  /// campaign</a> call is actually disposed if the contact is connected to Amazon
  /// Connect.
  final AnsweringMachineDetectionStatus? answeringMachineDetectionStatus;

  /// The Amazon Resource Name (ARN) for the contact.
  final String? arn;
  final Campaign? campaign;

  /// How the contact reached your contact center.
  final Channel? channel;

  /// The timestamp when customer endpoint connected to Amazon Connect.
  final DateTime? connectedToSystemTimestamp;

  /// Information about the Customer on the contact.
  final Customer? customer;

  /// Information about customer’s voice activity.
  final CustomerVoiceActivity? customerVoiceActivity;

  /// The description of the contact.
  final String? description;

  /// Information about the call disconnect experience.
  final DisconnectDetails? disconnectDetails;

  /// The timestamp when the customer endpoint disconnected from Amazon Connect.
  final DateTime? disconnectTimestamp;

  /// The identifier for the contact.
  final String? id;

  /// If this contact is related to other contacts, this is the ID of the initial
  /// contact.
  final String? initialContactId;

  /// Indicates how the contact was initiated.
  final ContactInitiationMethod? initiationMethod;

  /// The date and time this contact was initiated, in UTC time. For
  /// <code>INBOUND</code>, this is when the contact arrived. For
  /// <code>OUTBOUND</code>, this is when the agent began dialing. For
  /// <code>CALLBACK</code>, this is when the callback contact was created. For
  /// <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the
  /// transfer was initiated. For <code>API</code>, this is when the request
  /// arrived. For <code>EXTERNAL_OUTBOUND</code>, this is when the agent started
  /// dialing the external participant. For <code>MONITOR</code>, this is when the
  /// supervisor started listening to a contact.
  final DateTime? initiationTimestamp;

  /// The timestamp when the contact was last paused.
  final DateTime? lastPausedTimestamp;

  /// The timestamp when the contact was last resumed.
  final DateTime? lastResumedTimestamp;

  /// The timestamp when contact was last updated.
  final DateTime? lastUpdateTimestamp;

  /// The name of the contact.
  final String? name;

  /// If this contact is not the first contact, this is the ID of the previous
  /// contact.
  final String? previousContactId;

  /// Information about the quality of the participant's media connection.
  final QualityMetrics? qualityMetrics;

  /// If this contact was queued, this contains information about the queue.
  final QueueInfo? queueInfo;

  /// An integer that represents the queue priority to be applied to the contact
  /// (lower priorities are routed preferentially). Cannot be specified if the
  /// QueueTimeAdjustmentSeconds is specified. Must be statically defined, must be
  /// larger than zero, and a valid integer value. Default Value is 5.
  final int? queuePriority;

  /// An integer that represents the queue time adjust to be applied to the
  /// contact, in seconds (longer / larger queue time are routed preferentially).
  /// Cannot be specified if the QueuePriority is specified. Must be statically
  /// defined and a valid integer value.
  final int? queueTimeAdjustmentSeconds;

  /// The contactId that is <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html#relatedcontactid">related</a>
  /// to this contact.
  final String? relatedContactId;

  /// Latest routing criteria on the contact.
  final RoutingCriteria? routingCriteria;

  /// The timestamp, in Unix epoch time format, at which to start running the
  /// inbound flow.
  final DateTime? scheduledTimestamp;

  /// A set of system defined key-value pairs stored on individual contact
  /// segments using an attribute map. The attributes are standard Amazon Connect
  /// attributes and can be accessed in flows. Attribute keys can include only
  /// alphanumeric, -, and _ characters. This field can be used to show channel
  /// subtype. For example, <code>connect:Guide</code> or
  /// <code>connect:SMS</code>.
  final Map<String, SegmentAttributeValue>? segmentAttributes;

  /// Tags associated with the contact. This contains both Amazon Web Services
  /// generated and user-defined tags.
  final Map<String, String>? tags;

  /// Total pause count for a contact.
  final int? totalPauseCount;

  /// Total pause duration for a contact in seconds.
  final int? totalPauseDurationInSeconds;

  /// Information about Amazon Connect Wisdom.
  final WisdomInfo? wisdomInfo;

  Contact({
    this.agentInfo,
    this.answeringMachineDetectionStatus,
    this.arn,
    this.campaign,
    this.channel,
    this.connectedToSystemTimestamp,
    this.customer,
    this.customerVoiceActivity,
    this.description,
    this.disconnectDetails,
    this.disconnectTimestamp,
    this.id,
    this.initialContactId,
    this.initiationMethod,
    this.initiationTimestamp,
    this.lastPausedTimestamp,
    this.lastResumedTimestamp,
    this.lastUpdateTimestamp,
    this.name,
    this.previousContactId,
    this.qualityMetrics,
    this.queueInfo,
    this.queuePriority,
    this.queueTimeAdjustmentSeconds,
    this.relatedContactId,
    this.routingCriteria,
    this.scheduledTimestamp,
    this.segmentAttributes,
    this.tags,
    this.totalPauseCount,
    this.totalPauseDurationInSeconds,
    this.wisdomInfo,
  });

  factory Contact.fromJson(Map<String, dynamic> json) {
    return Contact(
      agentInfo: json['AgentInfo'] != null
          ? AgentInfo.fromJson(json['AgentInfo'] as Map<String, dynamic>)
          : null,
      answeringMachineDetectionStatus:
          (json['AnsweringMachineDetectionStatus'] as String?)
              ?.let(AnsweringMachineDetectionStatus.fromString),
      arn: json['Arn'] as String?,
      campaign: json['Campaign'] != null
          ? Campaign.fromJson(json['Campaign'] as Map<String, dynamic>)
          : null,
      channel: (json['Channel'] as String?)?.let(Channel.fromString),
      connectedToSystemTimestamp:
          timeStampFromJson(json['ConnectedToSystemTimestamp']),
      customer: json['Customer'] != null
          ? Customer.fromJson(json['Customer'] as Map<String, dynamic>)
          : null,
      customerVoiceActivity: json['CustomerVoiceActivity'] != null
          ? CustomerVoiceActivity.fromJson(
              json['CustomerVoiceActivity'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      disconnectDetails: json['DisconnectDetails'] != null
          ? DisconnectDetails.fromJson(
              json['DisconnectDetails'] as Map<String, dynamic>)
          : null,
      disconnectTimestamp: timeStampFromJson(json['DisconnectTimestamp']),
      id: json['Id'] as String?,
      initialContactId: json['InitialContactId'] as String?,
      initiationMethod: (json['InitiationMethod'] as String?)
          ?.let(ContactInitiationMethod.fromString),
      initiationTimestamp: timeStampFromJson(json['InitiationTimestamp']),
      lastPausedTimestamp: timeStampFromJson(json['LastPausedTimestamp']),
      lastResumedTimestamp: timeStampFromJson(json['LastResumedTimestamp']),
      lastUpdateTimestamp: timeStampFromJson(json['LastUpdateTimestamp']),
      name: json['Name'] as String?,
      previousContactId: json['PreviousContactId'] as String?,
      qualityMetrics: json['QualityMetrics'] != null
          ? QualityMetrics.fromJson(
              json['QualityMetrics'] as Map<String, dynamic>)
          : null,
      queueInfo: json['QueueInfo'] != null
          ? QueueInfo.fromJson(json['QueueInfo'] as Map<String, dynamic>)
          : null,
      queuePriority: json['QueuePriority'] as int?,
      queueTimeAdjustmentSeconds: json['QueueTimeAdjustmentSeconds'] as int?,
      relatedContactId: json['RelatedContactId'] as String?,
      routingCriteria: json['RoutingCriteria'] != null
          ? RoutingCriteria.fromJson(
              json['RoutingCriteria'] as Map<String, dynamic>)
          : null,
      scheduledTimestamp: timeStampFromJson(json['ScheduledTimestamp']),
      segmentAttributes: (json['SegmentAttributes'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(
              k, SegmentAttributeValue.fromJson(e as Map<String, dynamic>))),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      totalPauseCount: json['TotalPauseCount'] as int?,
      totalPauseDurationInSeconds: json['TotalPauseDurationInSeconds'] as int?,
      wisdomInfo: json['WisdomInfo'] != null
          ? WisdomInfo.fromJson(json['WisdomInfo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final agentInfo = this.agentInfo;
    final answeringMachineDetectionStatus =
        this.answeringMachineDetectionStatus;
    final arn = this.arn;
    final campaign = this.campaign;
    final channel = this.channel;
    final connectedToSystemTimestamp = this.connectedToSystemTimestamp;
    final customer = this.customer;
    final customerVoiceActivity = this.customerVoiceActivity;
    final description = this.description;
    final disconnectDetails = this.disconnectDetails;
    final disconnectTimestamp = this.disconnectTimestamp;
    final id = this.id;
    final initialContactId = this.initialContactId;
    final initiationMethod = this.initiationMethod;
    final initiationTimestamp = this.initiationTimestamp;
    final lastPausedTimestamp = this.lastPausedTimestamp;
    final lastResumedTimestamp = this.lastResumedTimestamp;
    final lastUpdateTimestamp = this.lastUpdateTimestamp;
    final name = this.name;
    final previousContactId = this.previousContactId;
    final qualityMetrics = this.qualityMetrics;
    final queueInfo = this.queueInfo;
    final queuePriority = this.queuePriority;
    final queueTimeAdjustmentSeconds = this.queueTimeAdjustmentSeconds;
    final relatedContactId = this.relatedContactId;
    final routingCriteria = this.routingCriteria;
    final scheduledTimestamp = this.scheduledTimestamp;
    final segmentAttributes = this.segmentAttributes;
    final tags = this.tags;
    final totalPauseCount = this.totalPauseCount;
    final totalPauseDurationInSeconds = this.totalPauseDurationInSeconds;
    final wisdomInfo = this.wisdomInfo;
    return {
      if (agentInfo != null) 'AgentInfo': agentInfo,
      if (answeringMachineDetectionStatus != null)
        'AnsweringMachineDetectionStatus':
            answeringMachineDetectionStatus.value,
      if (arn != null) 'Arn': arn,
      if (campaign != null) 'Campaign': campaign,
      if (channel != null) 'Channel': channel.value,
      if (connectedToSystemTimestamp != null)
        'ConnectedToSystemTimestamp':
            unixTimestampToJson(connectedToSystemTimestamp),
      if (customer != null) 'Customer': customer,
      if (customerVoiceActivity != null)
        'CustomerVoiceActivity': customerVoiceActivity,
      if (description != null) 'Description': description,
      if (disconnectDetails != null) 'DisconnectDetails': disconnectDetails,
      if (disconnectTimestamp != null)
        'DisconnectTimestamp': unixTimestampToJson(disconnectTimestamp),
      if (id != null) 'Id': id,
      if (initialContactId != null) 'InitialContactId': initialContactId,
      if (initiationMethod != null) 'InitiationMethod': initiationMethod.value,
      if (initiationTimestamp != null)
        'InitiationTimestamp': unixTimestampToJson(initiationTimestamp),
      if (lastPausedTimestamp != null)
        'LastPausedTimestamp': unixTimestampToJson(lastPausedTimestamp),
      if (lastResumedTimestamp != null)
        'LastResumedTimestamp': unixTimestampToJson(lastResumedTimestamp),
      if (lastUpdateTimestamp != null)
        'LastUpdateTimestamp': unixTimestampToJson(lastUpdateTimestamp),
      if (name != null) 'Name': name,
      if (previousContactId != null) 'PreviousContactId': previousContactId,
      if (qualityMetrics != null) 'QualityMetrics': qualityMetrics,
      if (queueInfo != null) 'QueueInfo': queueInfo,
      if (queuePriority != null) 'QueuePriority': queuePriority,
      if (queueTimeAdjustmentSeconds != null)
        'QueueTimeAdjustmentSeconds': queueTimeAdjustmentSeconds,
      if (relatedContactId != null) 'RelatedContactId': relatedContactId,
      if (routingCriteria != null) 'RoutingCriteria': routingCriteria,
      if (scheduledTimestamp != null)
        'ScheduledTimestamp': unixTimestampToJson(scheduledTimestamp),
      if (segmentAttributes != null) 'SegmentAttributes': segmentAttributes,
      if (tags != null) 'Tags': tags,
      if (totalPauseCount != null) 'TotalPauseCount': totalPauseCount,
      if (totalPauseDurationInSeconds != null)
        'TotalPauseDurationInSeconds': totalPauseDurationInSeconds,
      if (wisdomInfo != null) 'WisdomInfo': wisdomInfo,
    };
  }
}

/// A structure that defines search criteria for contacts using analysis outputs
/// from Amazon Connect Contact Lens.
class ContactAnalysis {
  /// Search criteria based on transcript analyzed by Amazon Connect Contact Lens.
  final Transcript? transcript;

  ContactAnalysis({
    this.transcript,
  });

  Map<String, dynamic> toJson() {
    final transcript = this.transcript;
    return {
      if (transcript != null) 'Transcript': transcript,
    };
  }
}

/// Request object with information to create a contact.
class ContactDataRequest {
  /// List of attributes to be stored in a contact.
  final Map<String, String>? attributes;

  /// Structure to store information associated with a campaign.
  final Campaign? campaign;

  /// Endpoint of the customer for which contact will be initiated.
  final Endpoint? customerEndpoint;

  /// The identifier of the queue associated with the Amazon Connect instance in
  /// which contacts that are created will be queued.
  final String? queueId;

  /// Identifier to uniquely identify individual requests in the batch.
  final String? requestIdentifier;

  /// Endpoint associated with the Amazon Connect instance from which outbound
  /// contact will be initiated for the campaign.
  final Endpoint? systemEndpoint;

  ContactDataRequest({
    this.attributes,
    this.campaign,
    this.customerEndpoint,
    this.queueId,
    this.requestIdentifier,
    this.systemEndpoint,
  });

  Map<String, dynamic> toJson() {
    final attributes = this.attributes;
    final campaign = this.campaign;
    final customerEndpoint = this.customerEndpoint;
    final queueId = this.queueId;
    final requestIdentifier = this.requestIdentifier;
    final systemEndpoint = this.systemEndpoint;
    return {
      if (attributes != null) 'Attributes': attributes,
      if (campaign != null) 'Campaign': campaign,
      if (customerEndpoint != null) 'CustomerEndpoint': customerEndpoint,
      if (queueId != null) 'QueueId': queueId,
      if (requestIdentifier != null) 'RequestIdentifier': requestIdentifier,
      if (systemEndpoint != null) 'SystemEndpoint': systemEndpoint,
    };
  }
}

/// Filters user data based on the contact information that is associated to the
/// users. It contains a list of <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact
/// states</a>.
class ContactFilter {
  /// A list of up to 9 <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/about-contact-states.html">contact
  /// states</a>.
  final List<ContactState>? contactStates;

  ContactFilter({
    this.contactStates,
  });

  Map<String, dynamic> toJson() {
    final contactStates = this.contactStates;
    return {
      if (contactStates != null)
        'ContactStates': contactStates.map((e) => e.value).toList(),
    };
  }
}

/// Contains information about a flow.
class ContactFlow {
  /// The Amazon Resource Name (ARN) of the flow.
  final String? arn;

  /// The JSON string that represents the content of the flow. For an example, see
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example
  /// flow in Amazon Connect Flow language</a>.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256000.
  final String? content;

  /// The description of the flow.
  final String? description;

  /// The identifier of the flow.
  final String? id;

  /// The name of the flow.
  final String? name;

  /// The type of flow.
  final ContactFlowState? state;

  /// The status of the contact flow.
  final ContactFlowStatus? status;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  /// The type of the flow. For descriptions of the available types, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/create-contact-flow.html#contact-flow-types">Choose
  /// a flow type</a> in the <i>Amazon Connect Administrator Guide</i>.
  final ContactFlowType? type;

  ContactFlow({
    this.arn,
    this.content,
    this.description,
    this.id,
    this.name,
    this.state,
    this.status,
    this.tags,
    this.type,
  });

  factory ContactFlow.fromJson(Map<String, dynamic> json) {
    return ContactFlow(
      arn: json['Arn'] as String?,
      content: json['Content'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      state: (json['State'] as String?)?.let(ContactFlowState.fromString),
      status: (json['Status'] as String?)?.let(ContactFlowStatus.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      type: (json['Type'] as String?)?.let(ContactFlowType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final content = this.content;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final state = this.state;
    final status = this.status;
    final tags = this.tags;
    final type = this.type;
    return {
      if (arn != null) 'Arn': arn,
      if (content != null) 'Content': content,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (state != null) 'State': state.value,
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
      if (type != null) 'Type': type.value,
    };
  }
}

/// Contains information about a flow module.
class ContactFlowModule {
  /// The Amazon Resource Name (ARN).
  final String? arn;

  /// The JSON string that represents the content of the flow. For an example, see
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language-example.html">Example
  /// flow in Amazon Connect Flow language</a>.
  final String? content;

  /// The description of the flow module.
  final String? description;

  /// The identifier of the flow module.
  final String? id;

  /// The name of the flow module.
  final String? name;

  /// The type of flow module.
  final ContactFlowModuleState? state;

  /// The status of the flow module.
  final ContactFlowModuleStatus? status;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  ContactFlowModule({
    this.arn,
    this.content,
    this.description,
    this.id,
    this.name,
    this.state,
    this.status,
    this.tags,
  });

  factory ContactFlowModule.fromJson(Map<String, dynamic> json) {
    return ContactFlowModule(
      arn: json['Arn'] as String?,
      content: json['Content'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      state: (json['State'] as String?)?.let(ContactFlowModuleState.fromString),
      status:
          (json['Status'] as String?)?.let(ContactFlowModuleStatus.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final content = this.content;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final state = this.state;
    final status = this.status;
    final tags = this.tags;
    return {
      if (arn != null) 'Arn': arn,
      if (content != null) 'Content': content,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (state != null) 'State': state.value,
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// The search criteria to be used to return flow modules.
class ContactFlowModuleSearchCriteria {
  /// A list of conditions which would be applied together with an
  /// <code>AND</code> condition.
  final List<ContactFlowModuleSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an <code>OR</code>
  /// condition.
  final List<ContactFlowModuleSearchCriteria>? orConditions;
  final StringCondition? stringCondition;

  ContactFlowModuleSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// The search criteria to be used to return flow modules.
class ContactFlowModuleSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  ContactFlowModuleSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

enum ContactFlowModuleState {
  active('ACTIVE'),
  archived('ARCHIVED'),
  ;

  final String value;

  const ContactFlowModuleState(this.value);

  static ContactFlowModuleState fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ContactFlowModuleState'));
}

enum ContactFlowModuleStatus {
  published('PUBLISHED'),
  saved('SAVED'),
  ;

  final String value;

  const ContactFlowModuleStatus(this.value);

  static ContactFlowModuleStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ContactFlowModuleStatus'));
}

/// Contains summary information about a flow.
class ContactFlowModuleSummary {
  /// The Amazon Resource Name (ARN) of the flow module.
  final String? arn;

  /// The identifier of the flow module.
  final String? id;

  /// The name of the flow module.
  final String? name;

  /// The type of flow module.
  final ContactFlowModuleState? state;

  ContactFlowModuleSummary({
    this.arn,
    this.id,
    this.name,
    this.state,
  });

  factory ContactFlowModuleSummary.fromJson(Map<String, dynamic> json) {
    return ContactFlowModuleSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      state: (json['State'] as String?)?.let(ContactFlowModuleState.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final name = this.name;
    final state = this.state;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (state != null) 'State': state.value,
    };
  }
}

/// The search criteria to be used to return contact flows.
class ContactFlowSearchCriteria {
  /// A list of conditions which would be applied together with an
  /// <code>AND</code> condition.
  final List<ContactFlowSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an <code>OR</code>
  /// condition.
  final List<ContactFlowSearchCriteria>? orConditions;

  /// The state of the flow.
  final ContactFlowState? stateCondition;

  /// The status of the flow.
  final ContactFlowStatus? statusCondition;
  final StringCondition? stringCondition;

  /// The type of flow.
  final ContactFlowType? typeCondition;

  ContactFlowSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stateCondition,
    this.statusCondition,
    this.stringCondition,
    this.typeCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stateCondition = this.stateCondition;
    final statusCondition = this.statusCondition;
    final stringCondition = this.stringCondition;
    final typeCondition = this.typeCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stateCondition != null) 'StateCondition': stateCondition.value,
      if (statusCondition != null) 'StatusCondition': statusCondition.value,
      if (stringCondition != null) 'StringCondition': stringCondition,
      if (typeCondition != null) 'TypeCondition': typeCondition.value,
    };
  }
}

/// Filters to be applied to search results.
class ContactFlowSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  ContactFlowSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

enum ContactFlowState {
  active('ACTIVE'),
  archived('ARCHIVED'),
  ;

  final String value;

  const ContactFlowState(this.value);

  static ContactFlowState fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ContactFlowState'));
}

enum ContactFlowStatus {
  published('PUBLISHED'),
  saved('SAVED'),
  ;

  final String value;

  const ContactFlowStatus(this.value);

  static ContactFlowStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ContactFlowStatus'));
}

/// Contains summary information about a flow.
///
/// You can also create and update flows using the <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/flow-language.html">Amazon
/// Connect Flow language</a>.
class ContactFlowSummary {
  /// The Amazon Resource Name (ARN) of the flow.
  final String? arn;

  /// The type of flow.
  final ContactFlowState? contactFlowState;

  /// The status of the contact flow.
  final ContactFlowStatus? contactFlowStatus;

  /// The type of flow.
  final ContactFlowType? contactFlowType;

  /// The identifier of the flow.
  final String? id;

  /// The name of the flow.
  final String? name;

  ContactFlowSummary({
    this.arn,
    this.contactFlowState,
    this.contactFlowStatus,
    this.contactFlowType,
    this.id,
    this.name,
  });

  factory ContactFlowSummary.fromJson(Map<String, dynamic> json) {
    return ContactFlowSummary(
      arn: json['Arn'] as String?,
      contactFlowState: (json['ContactFlowState'] as String?)
          ?.let(ContactFlowState.fromString),
      contactFlowStatus: (json['ContactFlowStatus'] as String?)
          ?.let(ContactFlowStatus.fromString),
      contactFlowType:
          (json['ContactFlowType'] as String?)?.let(ContactFlowType.fromString),
      id: json['Id'] as String?,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final contactFlowState = this.contactFlowState;
    final contactFlowStatus = this.contactFlowStatus;
    final contactFlowType = this.contactFlowType;
    final id = this.id;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (contactFlowState != null) 'ContactFlowState': contactFlowState.value,
      if (contactFlowStatus != null)
        'ContactFlowStatus': contactFlowStatus.value,
      if (contactFlowType != null) 'ContactFlowType': contactFlowType.value,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
    };
  }
}

enum ContactFlowType {
  contactFlow('CONTACT_FLOW'),
  customerQueue('CUSTOMER_QUEUE'),
  customerHold('CUSTOMER_HOLD'),
  customerWhisper('CUSTOMER_WHISPER'),
  agentHold('AGENT_HOLD'),
  agentWhisper('AGENT_WHISPER'),
  outboundWhisper('OUTBOUND_WHISPER'),
  agentTransfer('AGENT_TRANSFER'),
  queueTransfer('QUEUE_TRANSFER'),
  ;

  final String value;

  const ContactFlowType(this.value);

  static ContactFlowType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ContactFlowType'));
}

enum ContactInitiationMethod {
  inbound('INBOUND'),
  outbound('OUTBOUND'),
  transfer('TRANSFER'),
  queueTransfer('QUEUE_TRANSFER'),
  callback('CALLBACK'),
  api('API'),
  disconnect('DISCONNECT'),
  monitor('MONITOR'),
  externalOutbound('EXTERNAL_OUTBOUND'),
  ;

  final String value;

  const ContactInitiationMethod(this.value);

  static ContactInitiationMethod fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ContactInitiationMethod'));
}

/// Information of returned contact.
class ContactSearchSummary {
  /// Information about the agent who accepted the contact.
  final ContactSearchSummaryAgentInfo? agentInfo;

  /// The Amazon Resource Name (ARN) of the contact.
  final String? arn;

  /// How the contact reached your contact center.
  final Channel? channel;

  /// The timestamp when the customer endpoint disconnected from Amazon Connect.
  final DateTime? disconnectTimestamp;

  /// The identifier of the contact summary.
  final String? id;

  /// If this contact is related to other contacts, this is the ID of the initial
  /// contact.
  final String? initialContactId;

  /// Indicates how the contact was initiated.
  final ContactInitiationMethod? initiationMethod;

  /// The date and time this contact was initiated, in UTC time. For
  /// <code>INBOUND</code>, this is when the contact arrived. For
  /// <code>OUTBOUND</code>, this is when the agent began dialing. For
  /// <code>CALLBACK</code>, this is when the callback contact was created. For
  /// <code>TRANSFER</code> and <code>QUEUE_TRANSFER</code>, this is when the
  /// transfer was initiated. For API, this is when the request arrived. For
  /// <code>EXTERNAL_OUTBOUND</code>, this is when the agent started dialing the
  /// external participant. For <code>MONITOR</code>, this is when the supervisor
  /// started listening to a contact.
  final DateTime? initiationTimestamp;

  /// If this contact is not the first contact, this is the ID of the previous
  /// contact.
  final String? previousContactId;

  /// If this contact was queued, this contains information about the queue.
  final ContactSearchSummaryQueueInfo? queueInfo;

  /// The timestamp, in Unix epoch time format, at which to start running the
  /// inbound flow.
  final DateTime? scheduledTimestamp;

  ContactSearchSummary({
    this.agentInfo,
    this.arn,
    this.channel,
    this.disconnectTimestamp,
    this.id,
    this.initialContactId,
    this.initiationMethod,
    this.initiationTimestamp,
    this.previousContactId,
    this.queueInfo,
    this.scheduledTimestamp,
  });

  factory ContactSearchSummary.fromJson(Map<String, dynamic> json) {
    return ContactSearchSummary(
      agentInfo: json['AgentInfo'] != null
          ? ContactSearchSummaryAgentInfo.fromJson(
              json['AgentInfo'] as Map<String, dynamic>)
          : null,
      arn: json['Arn'] as String?,
      channel: (json['Channel'] as String?)?.let(Channel.fromString),
      disconnectTimestamp: timeStampFromJson(json['DisconnectTimestamp']),
      id: json['Id'] as String?,
      initialContactId: json['InitialContactId'] as String?,
      initiationMethod: (json['InitiationMethod'] as String?)
          ?.let(ContactInitiationMethod.fromString),
      initiationTimestamp: timeStampFromJson(json['InitiationTimestamp']),
      previousContactId: json['PreviousContactId'] as String?,
      queueInfo: json['QueueInfo'] != null
          ? ContactSearchSummaryQueueInfo.fromJson(
              json['QueueInfo'] as Map<String, dynamic>)
          : null,
      scheduledTimestamp: timeStampFromJson(json['ScheduledTimestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    final agentInfo = this.agentInfo;
    final arn = this.arn;
    final channel = this.channel;
    final disconnectTimestamp = this.disconnectTimestamp;
    final id = this.id;
    final initialContactId = this.initialContactId;
    final initiationMethod = this.initiationMethod;
    final initiationTimestamp = this.initiationTimestamp;
    final previousContactId = this.previousContactId;
    final queueInfo = this.queueInfo;
    final scheduledTimestamp = this.scheduledTimestamp;
    return {
      if (agentInfo != null) 'AgentInfo': agentInfo,
      if (arn != null) 'Arn': arn,
      if (channel != null) 'Channel': channel.value,
      if (disconnectTimestamp != null)
        'DisconnectTimestamp': unixTimestampToJson(disconnectTimestamp),
      if (id != null) 'Id': id,
      if (initialContactId != null) 'InitialContactId': initialContactId,
      if (initiationMethod != null) 'InitiationMethod': initiationMethod.value,
      if (initiationTimestamp != null)
        'InitiationTimestamp': unixTimestampToJson(initiationTimestamp),
      if (previousContactId != null) 'PreviousContactId': previousContactId,
      if (queueInfo != null) 'QueueInfo': queueInfo,
      if (scheduledTimestamp != null)
        'ScheduledTimestamp': unixTimestampToJson(scheduledTimestamp),
    };
  }
}

/// Information about the agent who accepted the contact.
class ContactSearchSummaryAgentInfo {
  /// The timestamp when the contact was connected to the agent.
  final DateTime? connectedToAgentTimestamp;

  /// The identifier of the agent who accepted the contact.
  final String? id;

  ContactSearchSummaryAgentInfo({
    this.connectedToAgentTimestamp,
    this.id,
  });

  factory ContactSearchSummaryAgentInfo.fromJson(Map<String, dynamic> json) {
    return ContactSearchSummaryAgentInfo(
      connectedToAgentTimestamp:
          timeStampFromJson(json['ConnectedToAgentTimestamp']),
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final connectedToAgentTimestamp = this.connectedToAgentTimestamp;
    final id = this.id;
    return {
      if (connectedToAgentTimestamp != null)
        'ConnectedToAgentTimestamp':
            unixTimestampToJson(connectedToAgentTimestamp),
      if (id != null) 'Id': id,
    };
  }
}

/// If this contact was queued, this contains information about the queue.
class ContactSearchSummaryQueueInfo {
  /// The timestamp when the contact was added to the queue.
  final DateTime? enqueueTimestamp;

  /// The unique identifier for the queue.
  final String? id;

  ContactSearchSummaryQueueInfo({
    this.enqueueTimestamp,
    this.id,
  });

  factory ContactSearchSummaryQueueInfo.fromJson(Map<String, dynamic> json) {
    return ContactSearchSummaryQueueInfo(
      enqueueTimestamp: timeStampFromJson(json['EnqueueTimestamp']),
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final enqueueTimestamp = this.enqueueTimestamp;
    final id = this.id;
    return {
      if (enqueueTimestamp != null)
        'EnqueueTimestamp': unixTimestampToJson(enqueueTimestamp),
      if (id != null) 'Id': id,
    };
  }
}

enum ContactState {
  incoming('INCOMING'),
  pending('PENDING'),
  connecting('CONNECTING'),
  connected('CONNECTED'),
  connectedOnhold('CONNECTED_ONHOLD'),
  missed('MISSED'),
  error('ERROR'),
  ended('ENDED'),
  rejected('REJECTED'),
  ;

  final String value;

  const ContactState(this.value);

  static ContactState fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ContactState'));
}

/// An object that can be used to specify Tag conditions inside the
/// <code>SearchFilter</code>. This accepts an <code>OR</code> of
/// <code>AND</code> (List of List) input where:
///
/// <ul>
/// <li>
/// Top level list specifies conditions that need to be applied with
/// <code>OR</code> operator
/// </li>
/// <li>
/// Inner list specifies conditions that need to be applied with
/// <code>AND</code> operator.
/// </li>
/// </ul>
class ControlPlaneTagFilter {
  /// A list of conditions which would be applied together with an
  /// <code>AND</code> condition.
  final List<TagCondition>? andConditions;

  /// A list of conditions which would be applied together with an <code>OR</code>
  /// condition.
  final List<List<TagCondition>>? orConditions;

  /// A leaf node condition which can be used to specify a tag condition.
  final TagCondition? tagCondition;

  ControlPlaneTagFilter({
    this.andConditions,
    this.orConditions,
    this.tagCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final tagCondition = this.tagCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (tagCondition != null) 'TagCondition': tagCondition,
    };
  }
}

/// An object that can be used to specify Tag conditions or Hierarchy Group
/// conditions inside the <code>SearchFilter</code>.
///
/// This accepts an <code>OR</code> of <code>AND</code> (List of List) input
/// where:
///
/// <ul>
/// <li>
/// The top level list specifies conditions that need to be applied with
/// <code>OR</code> operator
/// </li>
/// <li>
/// The inner list specifies conditions that need to be applied with
/// <code>AND</code> operator.
/// </li>
/// </ul> <note>
/// Only one field can be populated. Maximum number of allowed Tag conditions is
/// 25. Maximum number of allowed Hierarchy Group conditions is 20.
/// </note>
class ControlPlaneUserAttributeFilter {
  /// A list of conditions which would be applied together with an
  /// <code>AND</code> condition.
  final AttributeAndCondition? andCondition;
  final HierarchyGroupCondition? hierarchyGroupCondition;

  /// A list of conditions which would be applied together with an <code>OR</code>
  /// condition.
  final List<AttributeAndCondition>? orConditions;
  final TagCondition? tagCondition;

  ControlPlaneUserAttributeFilter({
    this.andCondition,
    this.hierarchyGroupCondition,
    this.orConditions,
    this.tagCondition,
  });

  Map<String, dynamic> toJson() {
    final andCondition = this.andCondition;
    final hierarchyGroupCondition = this.hierarchyGroupCondition;
    final orConditions = this.orConditions;
    final tagCondition = this.tagCondition;
    return {
      if (andCondition != null) 'AndCondition': andCondition,
      if (hierarchyGroupCondition != null)
        'HierarchyGroupCondition': hierarchyGroupCondition,
      if (orConditions != null) 'OrConditions': orConditions,
      if (tagCondition != null) 'TagCondition': tagCondition,
    };
  }
}

class CreateAgentStatusResponse {
  /// The Amazon Resource Name (ARN) of the agent status.
  final String? agentStatusARN;

  /// The identifier of the agent status.
  final String? agentStatusId;

  CreateAgentStatusResponse({
    this.agentStatusARN,
    this.agentStatusId,
  });

  factory CreateAgentStatusResponse.fromJson(Map<String, dynamic> json) {
    return CreateAgentStatusResponse(
      agentStatusARN: json['AgentStatusARN'] as String?,
      agentStatusId: json['AgentStatusId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final agentStatusARN = this.agentStatusARN;
    final agentStatusId = this.agentStatusId;
    return {
      if (agentStatusARN != null) 'AgentStatusARN': agentStatusARN,
      if (agentStatusId != null) 'AgentStatusId': agentStatusId,
    };
  }
}

/// The <code>CreateCase</code> action definition.
class CreateCaseActionDefinition {
  /// An array of objects with <code>Field ID</code> and <code>Value</code> data.
  final List<FieldValue> fields;

  /// A unique identifier of a template.
  final String templateId;

  CreateCaseActionDefinition({
    required this.fields,
    required this.templateId,
  });

  factory CreateCaseActionDefinition.fromJson(Map<String, dynamic> json) {
    return CreateCaseActionDefinition(
      fields: (json['Fields'] as List)
          .nonNulls
          .map((e) => FieldValue.fromJson(e as Map<String, dynamic>))
          .toList(),
      templateId: json['TemplateId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final fields = this.fields;
    final templateId = this.templateId;
    return {
      'Fields': fields,
      'TemplateId': templateId,
    };
  }
}

class CreateContactFlowModuleResponse {
  /// The Amazon Resource Name (ARN) of the flow module.
  final String? arn;

  /// The identifier of the flow module.
  final String? id;

  CreateContactFlowModuleResponse({
    this.arn,
    this.id,
  });

  factory CreateContactFlowModuleResponse.fromJson(Map<String, dynamic> json) {
    return CreateContactFlowModuleResponse(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

class CreateContactFlowResponse {
  /// The Amazon Resource Name (ARN) of the flow.
  final String? contactFlowArn;

  /// The identifier of the flow.
  final String? contactFlowId;

  CreateContactFlowResponse({
    this.contactFlowArn,
    this.contactFlowId,
  });

  factory CreateContactFlowResponse.fromJson(Map<String, dynamic> json) {
    return CreateContactFlowResponse(
      contactFlowArn: json['ContactFlowArn'] as String?,
      contactFlowId: json['ContactFlowId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowArn = this.contactFlowArn;
    final contactFlowId = this.contactFlowId;
    return {
      if (contactFlowArn != null) 'ContactFlowArn': contactFlowArn,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
    };
  }
}

class CreateEvaluationFormResponse {
  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  CreateEvaluationFormResponse({
    required this.evaluationFormArn,
    required this.evaluationFormId,
  });

  factory CreateEvaluationFormResponse.fromJson(Map<String, dynamic> json) {
    return CreateEvaluationFormResponse(
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    return {
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
    };
  }
}

class CreateHoursOfOperationResponse {
  /// The Amazon Resource Name (ARN) for the hours of operation.
  final String? hoursOfOperationArn;

  /// The identifier for the hours of operation.
  final String? hoursOfOperationId;

  CreateHoursOfOperationResponse({
    this.hoursOfOperationArn,
    this.hoursOfOperationId,
  });

  factory CreateHoursOfOperationResponse.fromJson(Map<String, dynamic> json) {
    return CreateHoursOfOperationResponse(
      hoursOfOperationArn: json['HoursOfOperationArn'] as String?,
      hoursOfOperationId: json['HoursOfOperationId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hoursOfOperationArn = this.hoursOfOperationArn;
    final hoursOfOperationId = this.hoursOfOperationId;
    return {
      if (hoursOfOperationArn != null)
        'HoursOfOperationArn': hoursOfOperationArn,
      if (hoursOfOperationId != null) 'HoursOfOperationId': hoursOfOperationId,
    };
  }
}

class CreateInstanceResponse {
  /// The Amazon Resource Name (ARN) of the instance.
  final String? arn;

  /// The identifier for the instance.
  final String? id;

  CreateInstanceResponse({
    this.arn,
    this.id,
  });

  factory CreateInstanceResponse.fromJson(Map<String, dynamic> json) {
    return CreateInstanceResponse(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

class CreateIntegrationAssociationResponse {
  /// The Amazon Resource Name (ARN) for the association.
  final String? integrationAssociationArn;

  /// The identifier for the integration association.
  final String? integrationAssociationId;

  CreateIntegrationAssociationResponse({
    this.integrationAssociationArn,
    this.integrationAssociationId,
  });

  factory CreateIntegrationAssociationResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateIntegrationAssociationResponse(
      integrationAssociationArn: json['IntegrationAssociationArn'] as String?,
      integrationAssociationId: json['IntegrationAssociationId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final integrationAssociationArn = this.integrationAssociationArn;
    final integrationAssociationId = this.integrationAssociationId;
    return {
      if (integrationAssociationArn != null)
        'IntegrationAssociationArn': integrationAssociationArn,
      if (integrationAssociationId != null)
        'IntegrationAssociationId': integrationAssociationId,
    };
  }
}

class CreateParticipantResponse {
  /// The token used by the chat participant to call
  /// <code>CreateParticipantConnection</code>. The participant token is valid for
  /// the lifetime of a chat participant.
  final ParticipantTokenCredentials? participantCredentials;

  /// The identifier for a chat participant. The participantId for a chat
  /// participant is the same throughout the chat lifecycle.
  final String? participantId;

  CreateParticipantResponse({
    this.participantCredentials,
    this.participantId,
  });

  factory CreateParticipantResponse.fromJson(Map<String, dynamic> json) {
    return CreateParticipantResponse(
      participantCredentials: json['ParticipantCredentials'] != null
          ? ParticipantTokenCredentials.fromJson(
              json['ParticipantCredentials'] as Map<String, dynamic>)
          : null,
      participantId: json['ParticipantId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final participantCredentials = this.participantCredentials;
    final participantId = this.participantId;
    return {
      if (participantCredentials != null)
        'ParticipantCredentials': participantCredentials,
      if (participantId != null) 'ParticipantId': participantId,
    };
  }
}

class CreatePersistentContactAssociationResponse {
  /// The contactId from which a persistent chat session is started. This field is
  /// populated only for persistent chat.
  final String? continuedFromContactId;

  CreatePersistentContactAssociationResponse({
    this.continuedFromContactId,
  });

  factory CreatePersistentContactAssociationResponse.fromJson(
      Map<String, dynamic> json) {
    return CreatePersistentContactAssociationResponse(
      continuedFromContactId: json['ContinuedFromContactId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final continuedFromContactId = this.continuedFromContactId;
    return {
      if (continuedFromContactId != null)
        'ContinuedFromContactId': continuedFromContactId,
    };
  }
}

class CreatePromptResponse {
  /// The Amazon Resource Name (ARN) of the prompt.
  final String? promptARN;

  /// A unique identifier for the prompt.
  final String? promptId;

  CreatePromptResponse({
    this.promptARN,
    this.promptId,
  });

  factory CreatePromptResponse.fromJson(Map<String, dynamic> json) {
    return CreatePromptResponse(
      promptARN: json['PromptARN'] as String?,
      promptId: json['PromptId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final promptARN = this.promptARN;
    final promptId = this.promptId;
    return {
      if (promptARN != null) 'PromptARN': promptARN,
      if (promptId != null) 'PromptId': promptId,
    };
  }
}

class CreateQueueResponse {
  /// The Amazon Resource Name (ARN) of the queue.
  final String? queueArn;

  /// The identifier for the queue.
  final String? queueId;

  CreateQueueResponse({
    this.queueArn,
    this.queueId,
  });

  factory CreateQueueResponse.fromJson(Map<String, dynamic> json) {
    return CreateQueueResponse(
      queueArn: json['QueueArn'] as String?,
      queueId: json['QueueId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final queueArn = this.queueArn;
    final queueId = this.queueId;
    return {
      if (queueArn != null) 'QueueArn': queueArn,
      if (queueId != null) 'QueueId': queueId,
    };
  }
}

class CreateQuickConnectResponse {
  /// The Amazon Resource Name (ARN) for the quick connect.
  final String? quickConnectARN;

  /// The identifier for the quick connect.
  final String? quickConnectId;

  CreateQuickConnectResponse({
    this.quickConnectARN,
    this.quickConnectId,
  });

  factory CreateQuickConnectResponse.fromJson(Map<String, dynamic> json) {
    return CreateQuickConnectResponse(
      quickConnectARN: json['QuickConnectARN'] as String?,
      quickConnectId: json['QuickConnectId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final quickConnectARN = this.quickConnectARN;
    final quickConnectId = this.quickConnectId;
    return {
      if (quickConnectARN != null) 'QuickConnectARN': quickConnectARN,
      if (quickConnectId != null) 'QuickConnectId': quickConnectId,
    };
  }
}

class CreateRoutingProfileResponse {
  /// The Amazon Resource Name (ARN) of the routing profile.
  final String? routingProfileArn;

  /// The identifier of the routing profile.
  final String? routingProfileId;

  CreateRoutingProfileResponse({
    this.routingProfileArn,
    this.routingProfileId,
  });

  factory CreateRoutingProfileResponse.fromJson(Map<String, dynamic> json) {
    return CreateRoutingProfileResponse(
      routingProfileArn: json['RoutingProfileArn'] as String?,
      routingProfileId: json['RoutingProfileId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final routingProfileArn = this.routingProfileArn;
    final routingProfileId = this.routingProfileId;
    return {
      if (routingProfileArn != null) 'RoutingProfileArn': routingProfileArn,
      if (routingProfileId != null) 'RoutingProfileId': routingProfileId,
    };
  }
}

class CreateRuleResponse {
  /// The Amazon Resource Name (ARN) of the rule.
  final String ruleArn;

  /// A unique identifier for the rule.
  final String ruleId;

  CreateRuleResponse({
    required this.ruleArn,
    required this.ruleId,
  });

  factory CreateRuleResponse.fromJson(Map<String, dynamic> json) {
    return CreateRuleResponse(
      ruleArn: json['RuleArn'] as String,
      ruleId: json['RuleId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final ruleArn = this.ruleArn;
    final ruleId = this.ruleId;
    return {
      'RuleArn': ruleArn,
      'RuleId': ruleId,
    };
  }
}

class CreateSecurityProfileResponse {
  /// The Amazon Resource Name (ARN) for the security profile.
  final String? securityProfileArn;

  /// The identifier for the security profle.
  final String? securityProfileId;

  CreateSecurityProfileResponse({
    this.securityProfileArn,
    this.securityProfileId,
  });

  factory CreateSecurityProfileResponse.fromJson(Map<String, dynamic> json) {
    return CreateSecurityProfileResponse(
      securityProfileArn: json['SecurityProfileArn'] as String?,
      securityProfileId: json['SecurityProfileId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final securityProfileArn = this.securityProfileArn;
    final securityProfileId = this.securityProfileId;
    return {
      if (securityProfileArn != null) 'SecurityProfileArn': securityProfileArn,
      if (securityProfileId != null) 'SecurityProfileId': securityProfileId,
    };
  }
}

class CreateTaskTemplateResponse {
  /// The Amazon Resource Name (ARN) for the task template resource.
  final String arn;

  /// The identifier of the task template resource.
  final String id;

  CreateTaskTemplateResponse({
    required this.arn,
    required this.id,
  });

  factory CreateTaskTemplateResponse.fromJson(Map<String, dynamic> json) {
    return CreateTaskTemplateResponse(
      arn: json['Arn'] as String,
      id: json['Id'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      'Arn': arn,
      'Id': id,
    };
  }
}

class CreateTrafficDistributionGroupResponse {
  /// The Amazon Resource Name (ARN) of the traffic distribution group.
  final String? arn;

  /// The identifier of the traffic distribution group. This can be the ID or the
  /// ARN if the API is being called in the Region where the traffic distribution
  /// group was created. The ARN must be provided if the call is from the
  /// replicated Region.
  final String? id;

  CreateTrafficDistributionGroupResponse({
    this.arn,
    this.id,
  });

  factory CreateTrafficDistributionGroupResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateTrafficDistributionGroupResponse(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

class CreateUseCaseResponse {
  /// The Amazon Resource Name (ARN) for the use case.
  final String? useCaseArn;

  /// The identifier of the use case.
  final String? useCaseId;

  CreateUseCaseResponse({
    this.useCaseArn,
    this.useCaseId,
  });

  factory CreateUseCaseResponse.fromJson(Map<String, dynamic> json) {
    return CreateUseCaseResponse(
      useCaseArn: json['UseCaseArn'] as String?,
      useCaseId: json['UseCaseId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final useCaseArn = this.useCaseArn;
    final useCaseId = this.useCaseId;
    return {
      if (useCaseArn != null) 'UseCaseArn': useCaseArn,
      if (useCaseId != null) 'UseCaseId': useCaseId,
    };
  }
}

class CreateUserHierarchyGroupResponse {
  /// The Amazon Resource Name (ARN) of the hierarchy group.
  final String? hierarchyGroupArn;

  /// The identifier of the hierarchy group.
  final String? hierarchyGroupId;

  CreateUserHierarchyGroupResponse({
    this.hierarchyGroupArn,
    this.hierarchyGroupId,
  });

  factory CreateUserHierarchyGroupResponse.fromJson(Map<String, dynamic> json) {
    return CreateUserHierarchyGroupResponse(
      hierarchyGroupArn: json['HierarchyGroupArn'] as String?,
      hierarchyGroupId: json['HierarchyGroupId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hierarchyGroupArn = this.hierarchyGroupArn;
    final hierarchyGroupId = this.hierarchyGroupId;
    return {
      if (hierarchyGroupArn != null) 'HierarchyGroupArn': hierarchyGroupArn,
      if (hierarchyGroupId != null) 'HierarchyGroupId': hierarchyGroupId,
    };
  }
}

class CreateUserResponse {
  /// The Amazon Resource Name (ARN) of the user account.
  final String? userArn;

  /// The identifier of the user account.
  final String? userId;

  CreateUserResponse({
    this.userArn,
    this.userId,
  });

  factory CreateUserResponse.fromJson(Map<String, dynamic> json) {
    return CreateUserResponse(
      userArn: json['UserArn'] as String?,
      userId: json['UserId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final userArn = this.userArn;
    final userId = this.userId;
    return {
      if (userArn != null) 'UserArn': userArn,
      if (userId != null) 'UserId': userId,
    };
  }
}

class CreateViewResponse {
  /// A view resource object. Contains metadata and content necessary to render
  /// the view.
  final View? view;

  CreateViewResponse({
    this.view,
  });

  factory CreateViewResponse.fromJson(Map<String, dynamic> json) {
    return CreateViewResponse(
      view: json['View'] != null
          ? View.fromJson(json['View'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final view = this.view;
    return {
      if (view != null) 'View': view,
    };
  }
}

class CreateViewVersionResponse {
  /// All view data is contained within the View object.
  final View? view;

  CreateViewVersionResponse({
    this.view,
  });

  factory CreateViewVersionResponse.fromJson(Map<String, dynamic> json) {
    return CreateViewVersionResponse(
      view: json['View'] != null
          ? View.fromJson(json['View'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final view = this.view;
    return {
      if (view != null) 'View': view,
    };
  }
}

class CreateVocabularyResponse {
  /// The current state of the custom vocabulary.
  final VocabularyState state;

  /// The Amazon Resource Name (ARN) of the custom vocabulary.
  final String vocabularyArn;

  /// The identifier of the custom vocabulary.
  final String vocabularyId;

  CreateVocabularyResponse({
    required this.state,
    required this.vocabularyArn,
    required this.vocabularyId,
  });

  factory CreateVocabularyResponse.fromJson(Map<String, dynamic> json) {
    return CreateVocabularyResponse(
      state: VocabularyState.fromString((json['State'] as String)),
      vocabularyArn: json['VocabularyArn'] as String,
      vocabularyId: json['VocabularyId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final state = this.state;
    final vocabularyArn = this.vocabularyArn;
    final vocabularyId = this.vocabularyId;
    return {
      'State': state.value,
      'VocabularyArn': vocabularyArn,
      'VocabularyId': vocabularyId,
    };
  }
}

/// Information on the identity that created the file.
class CreatedByInfo {
  /// STS or IAM ARN representing the identity of API Caller. SDK users cannot
  /// populate this and this value is calculated automatically if
  /// <code>ConnectUserArn</code> is not provided.
  final String? awsIdentityArn;

  /// An agent ARN representing a <a
  /// href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-resources-for-iam-policies">connect
  /// user</a>.
  final String? connectUserArn;

  CreatedByInfo({
    this.awsIdentityArn,
    this.connectUserArn,
  });

  factory CreatedByInfo.fromJson(Map<String, dynamic> json) {
    return CreatedByInfo(
      awsIdentityArn: json['AWSIdentityArn'] as String?,
      connectUserArn: json['ConnectUserArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsIdentityArn = this.awsIdentityArn;
    final connectUserArn = this.connectUserArn;
    return {
      if (awsIdentityArn != null) 'AWSIdentityArn': awsIdentityArn,
      if (connectUserArn != null) 'ConnectUserArn': connectUserArn,
    };
  }
}

/// Contains credentials to use for federation.
class Credentials {
  /// An access token generated for a federated user to access Amazon Connect.
  final String? accessToken;

  /// A token generated with an expiration time for the session a user is logged
  /// in to Amazon Connect.
  final DateTime? accessTokenExpiration;

  /// Renews a token generated for a user to access the Amazon Connect instance.
  final String? refreshToken;

  /// Renews the expiration timer for a generated token.
  final DateTime? refreshTokenExpiration;

  Credentials({
    this.accessToken,
    this.accessTokenExpiration,
    this.refreshToken,
    this.refreshTokenExpiration,
  });

  factory Credentials.fromJson(Map<String, dynamic> json) {
    return Credentials(
      accessToken: json['AccessToken'] as String?,
      accessTokenExpiration: timeStampFromJson(json['AccessTokenExpiration']),
      refreshToken: json['RefreshToken'] as String?,
      refreshTokenExpiration: timeStampFromJson(json['RefreshTokenExpiration']),
    );
  }

  Map<String, dynamic> toJson() {
    final accessToken = this.accessToken;
    final accessTokenExpiration = this.accessTokenExpiration;
    final refreshToken = this.refreshToken;
    final refreshTokenExpiration = this.refreshTokenExpiration;
    return {
      if (accessToken != null) 'AccessToken': accessToken,
      if (accessTokenExpiration != null)
        'AccessTokenExpiration': unixTimestampToJson(accessTokenExpiration),
      if (refreshToken != null) 'RefreshToken': refreshToken,
      if (refreshTokenExpiration != null)
        'RefreshTokenExpiration': unixTimestampToJson(refreshTokenExpiration),
    };
  }
}

/// Defines the cross-channel routing behavior that allows an agent working on a
/// contact in one channel to be offered a contact from a different channel.
class CrossChannelBehavior {
  /// Specifies the other channels that can be routed to an agent handling their
  /// current channel.
  final BehaviorType behaviorType;

  CrossChannelBehavior({
    required this.behaviorType,
  });

  factory CrossChannelBehavior.fromJson(Map<String, dynamic> json) {
    return CrossChannelBehavior(
      behaviorType: BehaviorType.fromString((json['BehaviorType'] as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final behaviorType = this.behaviorType;
    return {
      'BehaviorType': behaviorType.value,
    };
  }
}

/// Contains information about a real-time metric. For a description of each
/// metric, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/real-time-metrics-definitions.html">Real-time
/// Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
class CurrentMetric {
  /// The name of the metric.
  final CurrentMetricName? name;

  /// The unit for the metric.
  final Unit? unit;

  CurrentMetric({
    this.name,
    this.unit,
  });

  factory CurrentMetric.fromJson(Map<String, dynamic> json) {
    return CurrentMetric(
      name: (json['Name'] as String?)?.let(CurrentMetricName.fromString),
      unit: (json['Unit'] as String?)?.let(Unit.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final unit = this.unit;
    return {
      if (name != null) 'Name': name.value,
      if (unit != null) 'Unit': unit.value,
    };
  }
}

/// Contains the data for a real-time metric.
class CurrentMetricData {
  /// Information about the metric.
  final CurrentMetric? metric;

  /// The value of the metric.
  final double? value;

  CurrentMetricData({
    this.metric,
    this.value,
  });

  factory CurrentMetricData.fromJson(Map<String, dynamic> json) {
    return CurrentMetricData(
      metric: json['Metric'] != null
          ? CurrentMetric.fromJson(json['Metric'] as Map<String, dynamic>)
          : null,
      value: json['Value'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final metric = this.metric;
    final value = this.value;
    return {
      if (metric != null) 'Metric': metric,
      if (value != null) 'Value': value,
    };
  }
}

/// The current metric names.
enum CurrentMetricName {
  agentsOnline('AGENTS_ONLINE'),
  agentsAvailable('AGENTS_AVAILABLE'),
  agentsOnCall('AGENTS_ON_CALL'),
  agentsNonProductive('AGENTS_NON_PRODUCTIVE'),
  agentsAfterContactWork('AGENTS_AFTER_CONTACT_WORK'),
  agentsError('AGENTS_ERROR'),
  agentsStaffed('AGENTS_STAFFED'),
  contactsInQueue('CONTACTS_IN_QUEUE'),
  oldestContactAge('OLDEST_CONTACT_AGE'),
  contactsScheduled('CONTACTS_SCHEDULED'),
  agentsOnContact('AGENTS_ON_CONTACT'),
  slotsActive('SLOTS_ACTIVE'),
  slotsAvailable('SLOTS_AVAILABLE'),
  ;

  final String value;

  const CurrentMetricName(this.value);

  static CurrentMetricName fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum CurrentMetricName'));
}

/// Contains information about a set of real-time metrics.
class CurrentMetricResult {
  /// The set of metrics.
  final List<CurrentMetricData>? collections;

  /// The dimensions for the metrics.
  final Dimensions? dimensions;

  CurrentMetricResult({
    this.collections,
    this.dimensions,
  });

  factory CurrentMetricResult.fromJson(Map<String, dynamic> json) {
    return CurrentMetricResult(
      collections: (json['Collections'] as List?)
          ?.nonNulls
          .map((e) => CurrentMetricData.fromJson(e as Map<String, dynamic>))
          .toList(),
      dimensions: json['Dimensions'] != null
          ? Dimensions.fromJson(json['Dimensions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final collections = this.collections;
    final dimensions = this.dimensions;
    return {
      if (collections != null) 'Collections': collections,
      if (dimensions != null) 'Dimensions': dimensions,
    };
  }
}

/// The way to sort the resulting response based on metrics. By default
/// resources are sorted based on <code>AGENTS_ONLINE</code>,
/// <code>DESCENDING</code>. The metric collection is sorted based on the input
/// metrics.
class CurrentMetricSortCriteria {
  final CurrentMetricName? sortByMetric;

  /// The way to sort.
  final SortOrder? sortOrder;

  CurrentMetricSortCriteria({
    this.sortByMetric,
    this.sortOrder,
  });

  Map<String, dynamic> toJson() {
    final sortByMetric = this.sortByMetric;
    final sortOrder = this.sortOrder;
    return {
      if (sortByMetric != null) 'SortByMetric': sortByMetric.value,
      if (sortOrder != null) 'SortOrder': sortOrder.value,
    };
  }
}

/// Information about the Customer on the contact.
class Customer {
  final ParticipantCapabilities? capabilities;

  /// Information regarding Customer’s device.
  final DeviceInfo? deviceInfo;

  Customer({
    this.capabilities,
    this.deviceInfo,
  });

  factory Customer.fromJson(Map<String, dynamic> json) {
    return Customer(
      capabilities: json['Capabilities'] != null
          ? ParticipantCapabilities.fromJson(
              json['Capabilities'] as Map<String, dynamic>)
          : null,
      deviceInfo: json['DeviceInfo'] != null
          ? DeviceInfo.fromJson(json['DeviceInfo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final capabilities = this.capabilities;
    final deviceInfo = this.deviceInfo;
    return {
      if (capabilities != null) 'Capabilities': capabilities,
      if (deviceInfo != null) 'DeviceInfo': deviceInfo,
    };
  }
}

/// Information about the quality of the Customer's media connection
class CustomerQualityMetrics {
  /// Information about the audio quality of the Customer
  final AudioQualityMetricsInfo? audio;

  CustomerQualityMetrics({
    this.audio,
  });

  factory CustomerQualityMetrics.fromJson(Map<String, dynamic> json) {
    return CustomerQualityMetrics(
      audio: json['Audio'] != null
          ? AudioQualityMetricsInfo.fromJson(
              json['Audio'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final audio = this.audio;
    return {
      if (audio != null) 'Audio': audio,
    };
  }
}

/// Information about customer’s voice activity.
class CustomerVoiceActivity {
  /// Timestamp that measures the end of the customer greeting from an outbound
  /// voice call.
  final DateTime? greetingEndTimestamp;

  /// Timestamp that measures the beginning of the customer greeting from an
  /// outbound voice call.
  final DateTime? greetingStartTimestamp;

  CustomerVoiceActivity({
    this.greetingEndTimestamp,
    this.greetingStartTimestamp,
  });

  factory CustomerVoiceActivity.fromJson(Map<String, dynamic> json) {
    return CustomerVoiceActivity(
      greetingEndTimestamp: timeStampFromJson(json['GreetingEndTimestamp']),
      greetingStartTimestamp: timeStampFromJson(json['GreetingStartTimestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    final greetingEndTimestamp = this.greetingEndTimestamp;
    final greetingStartTimestamp = this.greetingStartTimestamp;
    return {
      if (greetingEndTimestamp != null)
        'GreetingEndTimestamp': unixTimestampToJson(greetingEndTimestamp),
      if (greetingStartTimestamp != null)
        'GreetingStartTimestamp': unixTimestampToJson(greetingStartTimestamp),
    };
  }
}

/// Information about a reference when the <code>referenceType</code> is
/// <code>DATE</code>. Otherwise, null.
class DateReference {
  /// Identifier of the date reference.
  final String? name;

  /// A valid date.
  final String? value;

  DateReference({
    this.name,
    this.value,
  });

  factory DateReference.fromJson(Map<String, dynamic> json) {
    return DateReference(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

class DeactivateEvaluationFormResponse {
  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// The version of the deactivated evaluation form resource.
  final int evaluationFormVersion;

  DeactivateEvaluationFormResponse({
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.evaluationFormVersion,
  });

  factory DeactivateEvaluationFormResponse.fromJson(Map<String, dynamic> json) {
    return DeactivateEvaluationFormResponse(
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormVersion: json['EvaluationFormVersion'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormVersion = this.evaluationFormVersion;
    return {
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormVersion': evaluationFormVersion,
    };
  }
}

/// Contains information about a default vocabulary.
class DefaultVocabulary {
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String instanceId;

  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  final VocabularyLanguageCode languageCode;

  /// The identifier of the custom vocabulary.
  final String vocabularyId;

  /// A unique name of the custom vocabulary.
  final String vocabularyName;

  DefaultVocabulary({
    required this.instanceId,
    required this.languageCode,
    required this.vocabularyId,
    required this.vocabularyName,
  });

  factory DefaultVocabulary.fromJson(Map<String, dynamic> json) {
    return DefaultVocabulary(
      instanceId: json['InstanceId'] as String,
      languageCode:
          VocabularyLanguageCode.fromString((json['LanguageCode'] as String)),
      vocabularyId: json['VocabularyId'] as String,
      vocabularyName: json['VocabularyName'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final instanceId = this.instanceId;
    final languageCode = this.languageCode;
    final vocabularyId = this.vocabularyId;
    final vocabularyName = this.vocabularyName;
    return {
      'InstanceId': instanceId,
      'LanguageCode': languageCode.value,
      'VocabularyId': vocabularyId,
      'VocabularyName': vocabularyName,
    };
  }
}

/// Response from DeleteAttachedFile API
class DeleteAttachedFileResponse {
  DeleteAttachedFileResponse();

  factory DeleteAttachedFileResponse.fromJson(Map<String, dynamic> _) {
    return DeleteAttachedFileResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteContactFlowModuleResponse {
  DeleteContactFlowModuleResponse();

  factory DeleteContactFlowModuleResponse.fromJson(Map<String, dynamic> _) {
    return DeleteContactFlowModuleResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteContactFlowResponse {
  DeleteContactFlowResponse();

  factory DeleteContactFlowResponse.fromJson(Map<String, dynamic> _) {
    return DeleteContactFlowResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteTaskTemplateResponse {
  DeleteTaskTemplateResponse();

  factory DeleteTaskTemplateResponse.fromJson(Map<String, dynamic> _) {
    return DeleteTaskTemplateResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteTrafficDistributionGroupResponse {
  DeleteTrafficDistributionGroupResponse();

  factory DeleteTrafficDistributionGroupResponse.fromJson(
      Map<String, dynamic> _) {
    return DeleteTrafficDistributionGroupResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteViewResponse {
  DeleteViewResponse();

  factory DeleteViewResponse.fromJson(Map<String, dynamic> _) {
    return DeleteViewResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteViewVersionResponse {
  DeleteViewVersionResponse();

  factory DeleteViewVersionResponse.fromJson(Map<String, dynamic> _) {
    return DeleteViewVersionResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteVocabularyResponse {
  /// The current state of the custom vocabulary.
  final VocabularyState state;

  /// The Amazon Resource Name (ARN) of the custom vocabulary.
  final String vocabularyArn;

  /// The identifier of the custom vocabulary.
  final String vocabularyId;

  DeleteVocabularyResponse({
    required this.state,
    required this.vocabularyArn,
    required this.vocabularyId,
  });

  factory DeleteVocabularyResponse.fromJson(Map<String, dynamic> json) {
    return DeleteVocabularyResponse(
      state: VocabularyState.fromString((json['State'] as String)),
      vocabularyArn: json['VocabularyArn'] as String,
      vocabularyId: json['VocabularyId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final state = this.state;
    final vocabularyArn = this.vocabularyArn;
    final vocabularyId = this.vocabularyId;
    return {
      'State': state.value,
      'VocabularyArn': vocabularyArn,
      'VocabularyId': vocabularyId,
    };
  }
}

class DescribeAgentStatusResponse {
  /// The agent status.
  final AgentStatus? agentStatus;

  DescribeAgentStatusResponse({
    this.agentStatus,
  });

  factory DescribeAgentStatusResponse.fromJson(Map<String, dynamic> json) {
    return DescribeAgentStatusResponse(
      agentStatus: json['AgentStatus'] != null
          ? AgentStatus.fromJson(json['AgentStatus'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final agentStatus = this.agentStatus;
    return {
      if (agentStatus != null) 'AgentStatus': agentStatus,
    };
  }
}

class DescribeContactEvaluationResponse {
  /// Information about the evaluation form completed for a specific contact.
  final Evaluation evaluation;

  /// Information about the evaluation form.
  final EvaluationFormContent evaluationForm;

  DescribeContactEvaluationResponse({
    required this.evaluation,
    required this.evaluationForm,
  });

  factory DescribeContactEvaluationResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeContactEvaluationResponse(
      evaluation:
          Evaluation.fromJson(json['Evaluation'] as Map<String, dynamic>),
      evaluationForm: EvaluationFormContent.fromJson(
          json['EvaluationForm'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final evaluation = this.evaluation;
    final evaluationForm = this.evaluationForm;
    return {
      'Evaluation': evaluation,
      'EvaluationForm': evaluationForm,
    };
  }
}

class DescribeContactFlowModuleResponse {
  /// Information about the flow module.
  final ContactFlowModule? contactFlowModule;

  DescribeContactFlowModuleResponse({
    this.contactFlowModule,
  });

  factory DescribeContactFlowModuleResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeContactFlowModuleResponse(
      contactFlowModule: json['ContactFlowModule'] != null
          ? ContactFlowModule.fromJson(
              json['ContactFlowModule'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowModule = this.contactFlowModule;
    return {
      if (contactFlowModule != null) 'ContactFlowModule': contactFlowModule,
    };
  }
}

class DescribeContactFlowResponse {
  /// Information about the flow.
  final ContactFlow? contactFlow;

  DescribeContactFlowResponse({
    this.contactFlow,
  });

  factory DescribeContactFlowResponse.fromJson(Map<String, dynamic> json) {
    return DescribeContactFlowResponse(
      contactFlow: json['ContactFlow'] != null
          ? ContactFlow.fromJson(json['ContactFlow'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlow = this.contactFlow;
    return {
      if (contactFlow != null) 'ContactFlow': contactFlow,
    };
  }
}

class DescribeContactResponse {
  /// Information about the contact.
  final Contact? contact;

  DescribeContactResponse({
    this.contact,
  });

  factory DescribeContactResponse.fromJson(Map<String, dynamic> json) {
    return DescribeContactResponse(
      contact: json['Contact'] != null
          ? Contact.fromJson(json['Contact'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contact = this.contact;
    return {
      if (contact != null) 'Contact': contact,
    };
  }
}

class DescribeEvaluationFormResponse {
  /// Information about the evaluation form.
  final EvaluationForm evaluationForm;

  DescribeEvaluationFormResponse({
    required this.evaluationForm,
  });

  factory DescribeEvaluationFormResponse.fromJson(Map<String, dynamic> json) {
    return DescribeEvaluationFormResponse(
      evaluationForm: EvaluationForm.fromJson(
          json['EvaluationForm'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationForm = this.evaluationForm;
    return {
      'EvaluationForm': evaluationForm,
    };
  }
}

class DescribeHoursOfOperationResponse {
  /// The hours of operation.
  final HoursOfOperation? hoursOfOperation;

  DescribeHoursOfOperationResponse({
    this.hoursOfOperation,
  });

  factory DescribeHoursOfOperationResponse.fromJson(Map<String, dynamic> json) {
    return DescribeHoursOfOperationResponse(
      hoursOfOperation: json['HoursOfOperation'] != null
          ? HoursOfOperation.fromJson(
              json['HoursOfOperation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final hoursOfOperation = this.hoursOfOperation;
    return {
      if (hoursOfOperation != null) 'HoursOfOperation': hoursOfOperation,
    };
  }
}

class DescribeInstanceAttributeResponse {
  /// The type of attribute.
  final Attribute? attribute;

  DescribeInstanceAttributeResponse({
    this.attribute,
  });

  factory DescribeInstanceAttributeResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeInstanceAttributeResponse(
      attribute: json['Attribute'] != null
          ? Attribute.fromJson(json['Attribute'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final attribute = this.attribute;
    return {
      if (attribute != null) 'Attribute': attribute,
    };
  }
}

class DescribeInstanceResponse {
  /// The name of the instance.
  final Instance? instance;

  DescribeInstanceResponse({
    this.instance,
  });

  factory DescribeInstanceResponse.fromJson(Map<String, dynamic> json) {
    return DescribeInstanceResponse(
      instance: json['Instance'] != null
          ? Instance.fromJson(json['Instance'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final instance = this.instance;
    return {
      if (instance != null) 'Instance': instance,
    };
  }
}

class DescribeInstanceStorageConfigResponse {
  /// A valid storage type.
  final InstanceStorageConfig? storageConfig;

  DescribeInstanceStorageConfigResponse({
    this.storageConfig,
  });

  factory DescribeInstanceStorageConfigResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeInstanceStorageConfigResponse(
      storageConfig: json['StorageConfig'] != null
          ? InstanceStorageConfig.fromJson(
              json['StorageConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final storageConfig = this.storageConfig;
    return {
      if (storageConfig != null) 'StorageConfig': storageConfig,
    };
  }
}

class DescribePhoneNumberResponse {
  /// Information about a phone number that's been claimed to your Amazon Connect
  /// instance or traffic distribution group.
  final ClaimedPhoneNumberSummary? claimedPhoneNumberSummary;

  DescribePhoneNumberResponse({
    this.claimedPhoneNumberSummary,
  });

  factory DescribePhoneNumberResponse.fromJson(Map<String, dynamic> json) {
    return DescribePhoneNumberResponse(
      claimedPhoneNumberSummary: json['ClaimedPhoneNumberSummary'] != null
          ? ClaimedPhoneNumberSummary.fromJson(
              json['ClaimedPhoneNumberSummary'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final claimedPhoneNumberSummary = this.claimedPhoneNumberSummary;
    return {
      if (claimedPhoneNumberSummary != null)
        'ClaimedPhoneNumberSummary': claimedPhoneNumberSummary,
    };
  }
}

class DescribePredefinedAttributeResponse {
  /// Information about the predefined attribute.
  final PredefinedAttribute? predefinedAttribute;

  DescribePredefinedAttributeResponse({
    this.predefinedAttribute,
  });

  factory DescribePredefinedAttributeResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribePredefinedAttributeResponse(
      predefinedAttribute: json['PredefinedAttribute'] != null
          ? PredefinedAttribute.fromJson(
              json['PredefinedAttribute'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final predefinedAttribute = this.predefinedAttribute;
    return {
      if (predefinedAttribute != null)
        'PredefinedAttribute': predefinedAttribute,
    };
  }
}

class DescribePromptResponse {
  /// Information about the prompt.
  final Prompt? prompt;

  DescribePromptResponse({
    this.prompt,
  });

  factory DescribePromptResponse.fromJson(Map<String, dynamic> json) {
    return DescribePromptResponse(
      prompt: json['Prompt'] != null
          ? Prompt.fromJson(json['Prompt'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final prompt = this.prompt;
    return {
      if (prompt != null) 'Prompt': prompt,
    };
  }
}

class DescribeQueueResponse {
  /// The name of the queue.
  final Queue? queue;

  DescribeQueueResponse({
    this.queue,
  });

  factory DescribeQueueResponse.fromJson(Map<String, dynamic> json) {
    return DescribeQueueResponse(
      queue: json['Queue'] != null
          ? Queue.fromJson(json['Queue'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final queue = this.queue;
    return {
      if (queue != null) 'Queue': queue,
    };
  }
}

class DescribeQuickConnectResponse {
  /// Information about the quick connect.
  final QuickConnect? quickConnect;

  DescribeQuickConnectResponse({
    this.quickConnect,
  });

  factory DescribeQuickConnectResponse.fromJson(Map<String, dynamic> json) {
    return DescribeQuickConnectResponse(
      quickConnect: json['QuickConnect'] != null
          ? QuickConnect.fromJson(json['QuickConnect'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final quickConnect = this.quickConnect;
    return {
      if (quickConnect != null) 'QuickConnect': quickConnect,
    };
  }
}

class DescribeRoutingProfileResponse {
  /// The routing profile.
  final RoutingProfile? routingProfile;

  DescribeRoutingProfileResponse({
    this.routingProfile,
  });

  factory DescribeRoutingProfileResponse.fromJson(Map<String, dynamic> json) {
    return DescribeRoutingProfileResponse(
      routingProfile: json['RoutingProfile'] != null
          ? RoutingProfile.fromJson(
              json['RoutingProfile'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final routingProfile = this.routingProfile;
    return {
      if (routingProfile != null) 'RoutingProfile': routingProfile,
    };
  }
}

class DescribeRuleResponse {
  /// Information about the rule.
  final Rule rule;

  DescribeRuleResponse({
    required this.rule,
  });

  factory DescribeRuleResponse.fromJson(Map<String, dynamic> json) {
    return DescribeRuleResponse(
      rule: Rule.fromJson(json['Rule'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final rule = this.rule;
    return {
      'Rule': rule,
    };
  }
}

class DescribeSecurityProfileResponse {
  /// The security profile.
  final SecurityProfile? securityProfile;

  DescribeSecurityProfileResponse({
    this.securityProfile,
  });

  factory DescribeSecurityProfileResponse.fromJson(Map<String, dynamic> json) {
    return DescribeSecurityProfileResponse(
      securityProfile: json['SecurityProfile'] != null
          ? SecurityProfile.fromJson(
              json['SecurityProfile'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final securityProfile = this.securityProfile;
    return {
      if (securityProfile != null) 'SecurityProfile': securityProfile,
    };
  }
}

class DescribeTrafficDistributionGroupResponse {
  /// Information about the traffic distribution group.
  final TrafficDistributionGroup? trafficDistributionGroup;

  DescribeTrafficDistributionGroupResponse({
    this.trafficDistributionGroup,
  });

  factory DescribeTrafficDistributionGroupResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeTrafficDistributionGroupResponse(
      trafficDistributionGroup: json['TrafficDistributionGroup'] != null
          ? TrafficDistributionGroup.fromJson(
              json['TrafficDistributionGroup'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final trafficDistributionGroup = this.trafficDistributionGroup;
    return {
      if (trafficDistributionGroup != null)
        'TrafficDistributionGroup': trafficDistributionGroup,
    };
  }
}

class DescribeUserHierarchyGroupResponse {
  /// Information about the hierarchy group.
  final HierarchyGroup? hierarchyGroup;

  DescribeUserHierarchyGroupResponse({
    this.hierarchyGroup,
  });

  factory DescribeUserHierarchyGroupResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeUserHierarchyGroupResponse(
      hierarchyGroup: json['HierarchyGroup'] != null
          ? HierarchyGroup.fromJson(
              json['HierarchyGroup'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final hierarchyGroup = this.hierarchyGroup;
    return {
      if (hierarchyGroup != null) 'HierarchyGroup': hierarchyGroup,
    };
  }
}

class DescribeUserHierarchyStructureResponse {
  /// Information about the hierarchy structure.
  final HierarchyStructure? hierarchyStructure;

  DescribeUserHierarchyStructureResponse({
    this.hierarchyStructure,
  });

  factory DescribeUserHierarchyStructureResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeUserHierarchyStructureResponse(
      hierarchyStructure: json['HierarchyStructure'] != null
          ? HierarchyStructure.fromJson(
              json['HierarchyStructure'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final hierarchyStructure = this.hierarchyStructure;
    return {
      if (hierarchyStructure != null) 'HierarchyStructure': hierarchyStructure,
    };
  }
}

class DescribeUserResponse {
  /// Information about the user account and configuration settings.
  final User? user;

  DescribeUserResponse({
    this.user,
  });

  factory DescribeUserResponse.fromJson(Map<String, dynamic> json) {
    return DescribeUserResponse(
      user: json['User'] != null
          ? User.fromJson(json['User'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final user = this.user;
    return {
      if (user != null) 'User': user,
    };
  }
}

class DescribeViewResponse {
  /// All view data is contained within the View object.
  final View? view;

  DescribeViewResponse({
    this.view,
  });

  factory DescribeViewResponse.fromJson(Map<String, dynamic> json) {
    return DescribeViewResponse(
      view: json['View'] != null
          ? View.fromJson(json['View'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final view = this.view;
    return {
      if (view != null) 'View': view,
    };
  }
}

class DescribeVocabularyResponse {
  /// A list of specific words that you want Contact Lens for Amazon Connect to
  /// recognize in your audio input. They are generally domain-specific words and
  /// phrases, words that Contact Lens is not recognizing, or proper nouns.
  final Vocabulary vocabulary;

  DescribeVocabularyResponse({
    required this.vocabulary,
  });

  factory DescribeVocabularyResponse.fromJson(Map<String, dynamic> json) {
    return DescribeVocabularyResponse(
      vocabulary:
          Vocabulary.fromJson(json['Vocabulary'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final vocabulary = this.vocabulary;
    return {
      'Vocabulary': vocabulary,
    };
  }
}

/// Information regarding the device.
class DeviceInfo {
  /// Operating system that the participant used for the call.
  final String? operatingSystem;

  /// Name of the platform that the participant used for the call.
  final String? platformName;

  /// Version of the platform that the participant used for the call.
  final String? platformVersion;

  DeviceInfo({
    this.operatingSystem,
    this.platformName,
    this.platformVersion,
  });

  factory DeviceInfo.fromJson(Map<String, dynamic> json) {
    return DeviceInfo(
      operatingSystem: json['OperatingSystem'] as String?,
      platformName: json['PlatformName'] as String?,
      platformVersion: json['PlatformVersion'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final operatingSystem = this.operatingSystem;
    final platformName = this.platformName;
    final platformVersion = this.platformVersion;
    return {
      if (operatingSystem != null) 'OperatingSystem': operatingSystem,
      if (platformName != null) 'PlatformName': platformName,
      if (platformVersion != null) 'PlatformVersion': platformVersion,
    };
  }
}

/// Contains information about the dimensions for a set of metrics.
class Dimensions {
  /// The channel used for grouping and filters.
  final Channel? channel;

  /// Information about the queue for which metrics are returned.
  final QueueReference? queue;
  final RoutingProfileReference? routingProfile;

  /// The expression of a step in a routing criteria.
  final String? routingStepExpression;

  Dimensions({
    this.channel,
    this.queue,
    this.routingProfile,
    this.routingStepExpression,
  });

  factory Dimensions.fromJson(Map<String, dynamic> json) {
    return Dimensions(
      channel: (json['Channel'] as String?)?.let(Channel.fromString),
      queue: json['Queue'] != null
          ? QueueReference.fromJson(json['Queue'] as Map<String, dynamic>)
          : null,
      routingProfile: json['RoutingProfile'] != null
          ? RoutingProfileReference.fromJson(
              json['RoutingProfile'] as Map<String, dynamic>)
          : null,
      routingStepExpression: json['RoutingStepExpression'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final channel = this.channel;
    final queue = this.queue;
    final routingProfile = this.routingProfile;
    final routingStepExpression = this.routingStepExpression;
    return {
      if (channel != null) 'Channel': channel.value,
      if (queue != null) 'Queue': queue,
      if (routingProfile != null) 'RoutingProfile': routingProfile,
      if (routingStepExpression != null)
        'RoutingStepExpression': routingStepExpression,
    };
  }
}

enum DirectoryType {
  saml('SAML'),
  connectManaged('CONNECT_MANAGED'),
  existingDirectory('EXISTING_DIRECTORY'),
  ;

  final String value;

  const DirectoryType(this.value);

  static DirectoryType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum DirectoryType'));
}

class DisassociateFlowResponse {
  DisassociateFlowResponse();

  factory DisassociateFlowResponse.fromJson(Map<String, dynamic> _) {
    return DisassociateFlowResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisassociateTrafficDistributionGroupUserResponse {
  DisassociateTrafficDistributionGroupUserResponse();

  factory DisassociateTrafficDistributionGroupUserResponse.fromJson(
      Map<String, dynamic> _) {
    return DisassociateTrafficDistributionGroupUserResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Information about the call disconnect experience.
class DisconnectDetails {
  /// Indicates the potential disconnection issues for a call. This field is not
  /// populated if the service does not detect potential issues.
  final String? potentialDisconnectIssue;

  DisconnectDetails({
    this.potentialDisconnectIssue,
  });

  factory DisconnectDetails.fromJson(Map<String, dynamic> json) {
    return DisconnectDetails(
      potentialDisconnectIssue: json['PotentialDisconnectIssue'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final potentialDisconnectIssue = this.potentialDisconnectIssue;
    return {
      if (potentialDisconnectIssue != null)
        'PotentialDisconnectIssue': potentialDisconnectIssue,
    };
  }
}

/// Contains details about why a contact was disconnected. Only Amazon Connect
/// outbound campaigns can provide this field.
class DisconnectReason {
  /// A code that indicates how the contact was terminated.
  final String? code;

  DisconnectReason({
    this.code,
  });

  Map<String, dynamic> toJson() {
    final code = this.code;
    return {
      if (code != null) 'Code': code,
    };
  }
}

class DismissUserContactResponse {
  DismissUserContactResponse();

  factory DismissUserContactResponse.fromJson(Map<String, dynamic> _) {
    return DismissUserContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Information about a traffic distribution.
class Distribution {
  /// The percentage of the traffic that is distributed, in increments of 10.
  final int percentage;

  /// The Amazon Web Services Region where the traffic is distributed.
  final String region;

  Distribution({
    required this.percentage,
    required this.region,
  });

  factory Distribution.fromJson(Map<String, dynamic> json) {
    return Distribution(
      percentage: json['Percentage'] as int,
      region: json['Region'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final percentage = this.percentage;
    final region = this.region;
    return {
      'Percentage': percentage,
      'Region': region,
    };
  }
}

/// Metadata used to download the attached file.
class DownloadUrlMetadata {
  /// A pre-signed URL that should be used to download the attached file.
  final String? url;

  /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601
  /// format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
  final String? urlExpiry;

  DownloadUrlMetadata({
    this.url,
    this.urlExpiry,
  });

  factory DownloadUrlMetadata.fromJson(Map<String, dynamic> json) {
    return DownloadUrlMetadata(
      url: json['Url'] as String?,
      urlExpiry: json['UrlExpiry'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final url = this.url;
    final urlExpiry = this.urlExpiry;
    return {
      if (url != null) 'Url': url,
      if (urlExpiry != null) 'UrlExpiry': urlExpiry,
    };
  }
}

/// Information about a reference when the <code>referenceType</code> is
/// <code>EMAIL</code>. Otherwise, null.
class EmailReference {
  /// Identifier of the email reference.
  final String? name;

  /// A valid email address.
  final String? value;

  EmailReference({
    this.name,
    this.value,
  });

  factory EmailReference.fromJson(Map<String, dynamic> json) {
    return EmailReference(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// An empty value.
class EmptyFieldValue {
  EmptyFieldValue();

  factory EmptyFieldValue.fromJson(Map<String, dynamic> _) {
    return EmptyFieldValue();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The encryption configuration.
class EncryptionConfig {
  /// The type of encryption.
  final EncryptionType encryptionType;

  /// The full ARN of the encryption key.
  /// <note>
  /// Be sure to provide the full ARN of the encryption key, not just the ID.
  ///
  /// Amazon Connect supports only KMS keys with the default key spec of <a
  /// href="https://docs.aws.amazon.com/kms/latest/developerguide/asymmetric-key-specs.html#key-spec-symmetric-default">
  /// <code>SYMMETRIC_DEFAULT</code> </a>.
  /// </note>
  final String keyId;

  EncryptionConfig({
    required this.encryptionType,
    required this.keyId,
  });

  factory EncryptionConfig.fromJson(Map<String, dynamic> json) {
    return EncryptionConfig(
      encryptionType:
          EncryptionType.fromString((json['EncryptionType'] as String)),
      keyId: json['KeyId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionType = this.encryptionType;
    final keyId = this.keyId;
    return {
      'EncryptionType': encryptionType.value,
      'KeyId': keyId,
    };
  }
}

enum EncryptionType {
  kms('KMS'),
  ;

  final String value;

  const EncryptionType(this.value);

  static EncryptionType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum EncryptionType'));
}

/// End associated tasks related to a case.
class EndAssociatedTasksActionDefinition {
  EndAssociatedTasksActionDefinition();

  factory EndAssociatedTasksActionDefinition.fromJson(Map<String, dynamic> _) {
    return EndAssociatedTasksActionDefinition();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Information about the endpoint.
class Endpoint {
  /// Address of the endpoint.
  final String? address;

  /// Type of the endpoint.
  final EndpointType? type;

  Endpoint({
    this.address,
    this.type,
  });

  Map<String, dynamic> toJson() {
    final address = this.address;
    final type = this.type;
    return {
      if (address != null) 'Address': address,
      if (type != null) 'Type': type.value,
    };
  }
}

enum EndpointType {
  telephoneNumber('TELEPHONE_NUMBER'),
  voip('VOIP'),
  contactFlow('CONTACT_FLOW'),
  ;

  final String value;

  const EndpointType(this.value);

  static EndpointType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum EndpointType'));
}

/// This API is in preview release for Amazon Connect and is subject to change.
///
/// List of errors for dataset association failures.
class ErrorResult {
  /// The error code.
  final String? errorCode;

  /// The corresponding error message for the error code.
  final String? errorMessage;

  ErrorResult({
    this.errorCode,
    this.errorMessage,
  });

  factory ErrorResult.fromJson(Map<String, dynamic> json) {
    return ErrorResult(
      errorCode: json['ErrorCode'] as String?,
      errorMessage: json['ErrorMessage'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final errorMessage = this.errorMessage;
    return {
      if (errorCode != null) 'ErrorCode': errorCode,
      if (errorMessage != null) 'ErrorMessage': errorMessage,
    };
  }
}

/// Information about a contact evaluation.
class Evaluation {
  /// A map of question identifiers to answer value.
  final Map<String, EvaluationAnswerOutput> answers;

  /// The timestamp for when the evaluation was created.
  final DateTime createdTime;

  /// The Amazon Resource Name (ARN) for the contact evaluation resource.
  final String evaluationArn;

  /// A unique identifier for the contact evaluation.
  final String evaluationId;

  /// The timestamp for when the evaluation was last updated.
  final DateTime lastModifiedTime;

  /// Metadata about the contact evaluation.
  final EvaluationMetadata metadata;

  /// A map of question identifiers to note value.
  final Map<String, EvaluationNote> notes;

  /// The status of the contact evaluation.
  final EvaluationStatus status;

  /// A map of item (section or question) identifiers to score value.
  final Map<String, EvaluationScore>? scores;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  Evaluation({
    required this.answers,
    required this.createdTime,
    required this.evaluationArn,
    required this.evaluationId,
    required this.lastModifiedTime,
    required this.metadata,
    required this.notes,
    required this.status,
    this.scores,
    this.tags,
  });

  factory Evaluation.fromJson(Map<String, dynamic> json) {
    return Evaluation(
      answers: (json['Answers'] as Map<String, dynamic>).map((k, e) => MapEntry(
          k, EvaluationAnswerOutput.fromJson(e as Map<String, dynamic>))),
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      evaluationArn: json['EvaluationArn'] as String,
      evaluationId: json['EvaluationId'] as String,
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      metadata:
          EvaluationMetadata.fromJson(json['Metadata'] as Map<String, dynamic>),
      notes: (json['Notes'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, EvaluationNote.fromJson(e as Map<String, dynamic>))),
      status: EvaluationStatus.fromString((json['Status'] as String)),
      scores: (json['Scores'] as Map<String, dynamic>?)?.map((k, e) =>
          MapEntry(k, EvaluationScore.fromJson(e as Map<String, dynamic>))),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final answers = this.answers;
    final createdTime = this.createdTime;
    final evaluationArn = this.evaluationArn;
    final evaluationId = this.evaluationId;
    final lastModifiedTime = this.lastModifiedTime;
    final metadata = this.metadata;
    final notes = this.notes;
    final status = this.status;
    final scores = this.scores;
    final tags = this.tags;
    return {
      'Answers': answers,
      'CreatedTime': unixTimestampToJson(createdTime),
      'EvaluationArn': evaluationArn,
      'EvaluationId': evaluationId,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'Metadata': metadata,
      'Notes': notes,
      'Status': status.value,
      if (scores != null) 'Scores': scores,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Information about answer data for a contact evaluation. Answer data must be
/// either string, numeric, or not applicable.
class EvaluationAnswerData {
  /// The flag to mark the question as not applicable.
  final bool? notApplicable;

  /// The numeric value for an answer in a contact evaluation.
  final double? numericValue;

  /// The string value for an answer in a contact evaluation.
  final String? stringValue;

  EvaluationAnswerData({
    this.notApplicable,
    this.numericValue,
    this.stringValue,
  });

  factory EvaluationAnswerData.fromJson(Map<String, dynamic> json) {
    return EvaluationAnswerData(
      notApplicable: json['NotApplicable'] as bool?,
      numericValue: json['NumericValue'] as double?,
      stringValue: json['StringValue'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final notApplicable = this.notApplicable;
    final numericValue = this.numericValue;
    final stringValue = this.stringValue;
    return {
      if (notApplicable != null) 'NotApplicable': notApplicable,
      if (numericValue != null) 'NumericValue': numericValue,
      if (stringValue != null) 'StringValue': stringValue,
    };
  }
}

/// Information about input answers for a contact evaluation.
class EvaluationAnswerInput {
  /// The value for an answer in a contact evaluation.
  final EvaluationAnswerData? value;

  EvaluationAnswerInput({
    this.value,
  });

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

/// Information about output answers for a contact evaluation.
class EvaluationAnswerOutput {
  /// The system suggested value for an answer in a contact evaluation.
  final EvaluationAnswerData? systemSuggestedValue;

  /// The value for an answer in a contact evaluation.
  final EvaluationAnswerData? value;

  EvaluationAnswerOutput({
    this.systemSuggestedValue,
    this.value,
  });

  factory EvaluationAnswerOutput.fromJson(Map<String, dynamic> json) {
    return EvaluationAnswerOutput(
      systemSuggestedValue: json['SystemSuggestedValue'] != null
          ? EvaluationAnswerData.fromJson(
              json['SystemSuggestedValue'] as Map<String, dynamic>)
          : null,
      value: json['Value'] != null
          ? EvaluationAnswerData.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final systemSuggestedValue = this.systemSuggestedValue;
    final value = this.value;
    return {
      if (systemSuggestedValue != null)
        'SystemSuggestedValue': systemSuggestedValue,
      if (value != null) 'Value': value,
    };
  }
}

/// Information about the evaluation form.
class EvaluationForm {
  /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
  final String createdBy;

  /// The timestamp for when the evaluation form was created.
  final DateTime createdTime;

  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// A version of the evaluation form.
  final int evaluationFormVersion;

  /// Items that are part of the evaluation form. The total number of sections and
  /// questions must not exceed 100 each. Questions must be contained in a
  /// section.
  final List<EvaluationFormItem> items;

  /// The Amazon Resource Name (ARN) of the user who last updated the evaluation
  /// form.
  final String lastModifiedBy;

  /// The timestamp for when the evaluation form was last updated.
  final DateTime lastModifiedTime;

  /// The flag indicating whether the evaluation form is locked for changes.
  final bool locked;

  /// The status of the evaluation form.
  final EvaluationFormVersionStatus status;

  /// A title of the evaluation form.
  final String title;

  /// The description of the evaluation form.
  final String? description;

  /// A scoring strategy of the evaluation form.
  final EvaluationFormScoringStrategy? scoringStrategy;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  EvaluationForm({
    required this.createdBy,
    required this.createdTime,
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.evaluationFormVersion,
    required this.items,
    required this.lastModifiedBy,
    required this.lastModifiedTime,
    required this.locked,
    required this.status,
    required this.title,
    this.description,
    this.scoringStrategy,
    this.tags,
  });

  factory EvaluationForm.fromJson(Map<String, dynamic> json) {
    return EvaluationForm(
      createdBy: json['CreatedBy'] as String,
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormVersion: json['EvaluationFormVersion'] as int,
      items: (json['Items'] as List)
          .nonNulls
          .map((e) => EvaluationFormItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      lastModifiedBy: json['LastModifiedBy'] as String,
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      locked: json['Locked'] as bool,
      status:
          EvaluationFormVersionStatus.fromString((json['Status'] as String)),
      title: json['Title'] as String,
      description: json['Description'] as String?,
      scoringStrategy: json['ScoringStrategy'] != null
          ? EvaluationFormScoringStrategy.fromJson(
              json['ScoringStrategy'] as Map<String, dynamic>)
          : null,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final createdBy = this.createdBy;
    final createdTime = this.createdTime;
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormVersion = this.evaluationFormVersion;
    final items = this.items;
    final lastModifiedBy = this.lastModifiedBy;
    final lastModifiedTime = this.lastModifiedTime;
    final locked = this.locked;
    final status = this.status;
    final title = this.title;
    final description = this.description;
    final scoringStrategy = this.scoringStrategy;
    final tags = this.tags;
    return {
      'CreatedBy': createdBy,
      'CreatedTime': unixTimestampToJson(createdTime),
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormVersion': evaluationFormVersion,
      'Items': items,
      'LastModifiedBy': lastModifiedBy,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'Locked': locked,
      'Status': status.value,
      'Title': title,
      if (description != null) 'Description': description,
      if (scoringStrategy != null) 'ScoringStrategy': scoringStrategy,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Information about an evaluation form used in a contact evaluation.
class EvaluationFormContent {
  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// A version of the evaluation form.
  final int evaluationFormVersion;

  /// Items that are part of the evaluation form. The total number of sections and
  /// questions must not exceed 100 each. Questions must be contained in a
  /// section.
  final List<EvaluationFormItem> items;

  /// A title of the evaluation form.
  final String title;

  /// The description of the evaluation form.
  final String? description;

  /// A scoring strategy of the evaluation form.
  final EvaluationFormScoringStrategy? scoringStrategy;

  EvaluationFormContent({
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.evaluationFormVersion,
    required this.items,
    required this.title,
    this.description,
    this.scoringStrategy,
  });

  factory EvaluationFormContent.fromJson(Map<String, dynamic> json) {
    return EvaluationFormContent(
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormVersion: json['EvaluationFormVersion'] as int,
      items: (json['Items'] as List)
          .nonNulls
          .map((e) => EvaluationFormItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      title: json['Title'] as String,
      description: json['Description'] as String?,
      scoringStrategy: json['ScoringStrategy'] != null
          ? EvaluationFormScoringStrategy.fromJson(
              json['ScoringStrategy'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormVersion = this.evaluationFormVersion;
    final items = this.items;
    final title = this.title;
    final description = this.description;
    final scoringStrategy = this.scoringStrategy;
    return {
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormVersion': evaluationFormVersion,
      'Items': items,
      'Title': title,
      if (description != null) 'Description': description,
      if (scoringStrategy != null) 'ScoringStrategy': scoringStrategy,
    };
  }
}

/// Information about an item from an evaluation form. The item must be either a
/// section or a question.
class EvaluationFormItem {
  /// The information of the question.
  final EvaluationFormQuestion? question;

  /// The information of the section.
  final EvaluationFormSection? section;

  EvaluationFormItem({
    this.question,
    this.section,
  });

  factory EvaluationFormItem.fromJson(Map<String, dynamic> json) {
    return EvaluationFormItem(
      question: json['Question'] != null
          ? EvaluationFormQuestion.fromJson(
              json['Question'] as Map<String, dynamic>)
          : null,
      section: json['Section'] != null
          ? EvaluationFormSection.fromJson(
              json['Section'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final question = this.question;
    final section = this.section;
    return {
      if (question != null) 'Question': question,
      if (section != null) 'Section': section,
    };
  }
}

/// Information about the automation configuration in numeric questions.
class EvaluationFormNumericQuestionAutomation {
  /// The property value of the automation.
  final NumericQuestionPropertyValueAutomation? propertyValue;

  EvaluationFormNumericQuestionAutomation({
    this.propertyValue,
  });

  factory EvaluationFormNumericQuestionAutomation.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormNumericQuestionAutomation(
      propertyValue: json['PropertyValue'] != null
          ? NumericQuestionPropertyValueAutomation.fromJson(
              json['PropertyValue'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final propertyValue = this.propertyValue;
    return {
      if (propertyValue != null) 'PropertyValue': propertyValue,
    };
  }
}

/// Information about the option range used for scoring in numeric questions.
class EvaluationFormNumericQuestionOption {
  /// The maximum answer value of the range option.
  final int maxValue;

  /// The minimum answer value of the range option.
  final int minValue;

  /// The flag to mark the option as automatic fail. If an automatic fail answer
  /// is provided, the overall evaluation gets a score of 0.
  final bool? automaticFail;

  /// The score assigned to answer values within the range option.
  final int? score;

  EvaluationFormNumericQuestionOption({
    required this.maxValue,
    required this.minValue,
    this.automaticFail,
    this.score,
  });

  factory EvaluationFormNumericQuestionOption.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormNumericQuestionOption(
      maxValue: json['MaxValue'] as int,
      minValue: json['MinValue'] as int,
      automaticFail: json['AutomaticFail'] as bool?,
      score: json['Score'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final maxValue = this.maxValue;
    final minValue = this.minValue;
    final automaticFail = this.automaticFail;
    final score = this.score;
    return {
      'MaxValue': maxValue,
      'MinValue': minValue,
      if (automaticFail != null) 'AutomaticFail': automaticFail,
      if (score != null) 'Score': score,
    };
  }
}

/// Information about properties for a numeric question in an evaluation form.
class EvaluationFormNumericQuestionProperties {
  /// The maximum answer value.
  final int maxValue;

  /// The minimum answer value.
  final int minValue;

  /// The automation properties of the numeric question.
  final EvaluationFormNumericQuestionAutomation? automation;

  /// The scoring options of the numeric question.
  final List<EvaluationFormNumericQuestionOption>? options;

  EvaluationFormNumericQuestionProperties({
    required this.maxValue,
    required this.minValue,
    this.automation,
    this.options,
  });

  factory EvaluationFormNumericQuestionProperties.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormNumericQuestionProperties(
      maxValue: json['MaxValue'] as int,
      minValue: json['MinValue'] as int,
      automation: json['Automation'] != null
          ? EvaluationFormNumericQuestionAutomation.fromJson(
              json['Automation'] as Map<String, dynamic>)
          : null,
      options: (json['Options'] as List?)
          ?.nonNulls
          .map((e) => EvaluationFormNumericQuestionOption.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final maxValue = this.maxValue;
    final minValue = this.minValue;
    final automation = this.automation;
    final options = this.options;
    return {
      'MaxValue': maxValue,
      'MinValue': minValue,
      if (automation != null) 'Automation': automation,
      if (options != null) 'Options': options,
    };
  }
}

/// Information about a question from an evaluation form.
class EvaluationFormQuestion {
  /// The type of the question.
  final EvaluationFormQuestionType questionType;

  /// The identifier of the question. An identifier must be unique within the
  /// evaluation form.
  final String refId;

  /// The title of the question.
  final String title;

  /// The instructions of the section.
  final String? instructions;

  /// The flag to enable not applicable answers to the question.
  final bool? notApplicableEnabled;

  /// The properties of the type of question. Text questions do not have to define
  /// question type properties.
  final EvaluationFormQuestionTypeProperties? questionTypeProperties;

  /// The scoring weight of the section.
  final double? weight;

  EvaluationFormQuestion({
    required this.questionType,
    required this.refId,
    required this.title,
    this.instructions,
    this.notApplicableEnabled,
    this.questionTypeProperties,
    this.weight,
  });

  factory EvaluationFormQuestion.fromJson(Map<String, dynamic> json) {
    return EvaluationFormQuestion(
      questionType: EvaluationFormQuestionType.fromString(
          (json['QuestionType'] as String)),
      refId: json['RefId'] as String,
      title: json['Title'] as String,
      instructions: json['Instructions'] as String?,
      notApplicableEnabled: json['NotApplicableEnabled'] as bool?,
      questionTypeProperties: json['QuestionTypeProperties'] != null
          ? EvaluationFormQuestionTypeProperties.fromJson(
              json['QuestionTypeProperties'] as Map<String, dynamic>)
          : null,
      weight: json['Weight'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final questionType = this.questionType;
    final refId = this.refId;
    final title = this.title;
    final instructions = this.instructions;
    final notApplicableEnabled = this.notApplicableEnabled;
    final questionTypeProperties = this.questionTypeProperties;
    final weight = this.weight;
    return {
      'QuestionType': questionType.value,
      'RefId': refId,
      'Title': title,
      if (instructions != null) 'Instructions': instructions,
      if (notApplicableEnabled != null)
        'NotApplicableEnabled': notApplicableEnabled,
      if (questionTypeProperties != null)
        'QuestionTypeProperties': questionTypeProperties,
      if (weight != null) 'Weight': weight,
    };
  }
}

enum EvaluationFormQuestionType {
  text('TEXT'),
  singleselect('SINGLESELECT'),
  numeric('NUMERIC'),
  ;

  final String value;

  const EvaluationFormQuestionType(this.value);

  static EvaluationFormQuestionType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum EvaluationFormQuestionType'));
}

/// Information about properties for a question in an evaluation form. The
/// question type properties must be either for a numeric question or a single
/// select question.
class EvaluationFormQuestionTypeProperties {
  /// The properties of the numeric question.
  final EvaluationFormNumericQuestionProperties? numeric;

  /// The properties of the numeric question.
  final EvaluationFormSingleSelectQuestionProperties? singleSelect;

  EvaluationFormQuestionTypeProperties({
    this.numeric,
    this.singleSelect,
  });

  factory EvaluationFormQuestionTypeProperties.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormQuestionTypeProperties(
      numeric: json['Numeric'] != null
          ? EvaluationFormNumericQuestionProperties.fromJson(
              json['Numeric'] as Map<String, dynamic>)
          : null,
      singleSelect: json['SingleSelect'] != null
          ? EvaluationFormSingleSelectQuestionProperties.fromJson(
              json['SingleSelect'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final numeric = this.numeric;
    final singleSelect = this.singleSelect;
    return {
      if (numeric != null) 'Numeric': numeric,
      if (singleSelect != null) 'SingleSelect': singleSelect,
    };
  }
}

enum EvaluationFormScoringMode {
  questionOnly('QUESTION_ONLY'),
  sectionOnly('SECTION_ONLY'),
  ;

  final String value;

  const EvaluationFormScoringMode(this.value);

  static EvaluationFormScoringMode fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum EvaluationFormScoringMode'));
}

enum EvaluationFormScoringStatus {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const EvaluationFormScoringStatus(this.value);

  static EvaluationFormScoringStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum EvaluationFormScoringStatus'));
}

/// Information about scoring strategy for an evaluation form.
class EvaluationFormScoringStrategy {
  /// The scoring mode of the evaluation form.
  final EvaluationFormScoringMode mode;

  /// The scoring status of the evaluation form.
  final EvaluationFormScoringStatus status;

  EvaluationFormScoringStrategy({
    required this.mode,
    required this.status,
  });

  factory EvaluationFormScoringStrategy.fromJson(Map<String, dynamic> json) {
    return EvaluationFormScoringStrategy(
      mode: EvaluationFormScoringMode.fromString((json['Mode'] as String)),
      status:
          EvaluationFormScoringStatus.fromString((json['Status'] as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final mode = this.mode;
    final status = this.status;
    return {
      'Mode': mode.value,
      'Status': status.value,
    };
  }
}

/// Information about a section from an evaluation form. A section can contain
/// sections and/or questions. Evaluation forms can only contain sections and
/// subsections (two level nesting).
class EvaluationFormSection {
  /// The items of the section.
  final List<EvaluationFormItem> items;

  /// The identifier of the section. An identifier must be unique within the
  /// evaluation form.
  final String refId;

  /// The title of the section.
  final String title;

  /// The instructions of the section.
  final String? instructions;

  /// The scoring weight of the section.
  final double? weight;

  EvaluationFormSection({
    required this.items,
    required this.refId,
    required this.title,
    this.instructions,
    this.weight,
  });

  factory EvaluationFormSection.fromJson(Map<String, dynamic> json) {
    return EvaluationFormSection(
      items: (json['Items'] as List)
          .nonNulls
          .map((e) => EvaluationFormItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      refId: json['RefId'] as String,
      title: json['Title'] as String,
      instructions: json['Instructions'] as String?,
      weight: json['Weight'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final items = this.items;
    final refId = this.refId;
    final title = this.title;
    final instructions = this.instructions;
    final weight = this.weight;
    return {
      'Items': items,
      'RefId': refId,
      'Title': title,
      if (instructions != null) 'Instructions': instructions,
      if (weight != null) 'Weight': weight,
    };
  }
}

/// Information about the automation configuration in single select questions.
/// Automation options are evaluated in order, and the first matched option is
/// applied. If no automation option matches, and there is a default option,
/// then the default option is applied.
class EvaluationFormSingleSelectQuestionAutomation {
  /// The automation options of the single select question.
  final List<EvaluationFormSingleSelectQuestionAutomationOption> options;

  /// The identifier of the default answer option, when none of the automation
  /// options match the criteria.
  final String? defaultOptionRefId;

  EvaluationFormSingleSelectQuestionAutomation({
    required this.options,
    this.defaultOptionRefId,
  });

  factory EvaluationFormSingleSelectQuestionAutomation.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormSingleSelectQuestionAutomation(
      options: (json['Options'] as List)
          .nonNulls
          .map((e) =>
              EvaluationFormSingleSelectQuestionAutomationOption.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      defaultOptionRefId: json['DefaultOptionRefId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final options = this.options;
    final defaultOptionRefId = this.defaultOptionRefId;
    return {
      'Options': options,
      if (defaultOptionRefId != null) 'DefaultOptionRefId': defaultOptionRefId,
    };
  }
}

/// Information about the automation option of a single select question.
class EvaluationFormSingleSelectQuestionAutomationOption {
  /// The automation option based on a rule category for the single select
  /// question.
  final SingleSelectQuestionRuleCategoryAutomation? ruleCategory;

  EvaluationFormSingleSelectQuestionAutomationOption({
    this.ruleCategory,
  });

  factory EvaluationFormSingleSelectQuestionAutomationOption.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormSingleSelectQuestionAutomationOption(
      ruleCategory: json['RuleCategory'] != null
          ? SingleSelectQuestionRuleCategoryAutomation.fromJson(
              json['RuleCategory'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final ruleCategory = this.ruleCategory;
    return {
      if (ruleCategory != null) 'RuleCategory': ruleCategory,
    };
  }
}

enum EvaluationFormSingleSelectQuestionDisplayMode {
  dropdown('DROPDOWN'),
  radio('RADIO'),
  ;

  final String value;

  const EvaluationFormSingleSelectQuestionDisplayMode(this.value);

  static EvaluationFormSingleSelectQuestionDisplayMode fromString(
          String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum EvaluationFormSingleSelectQuestionDisplayMode'));
}

/// Information about the automation configuration in single select questions.
class EvaluationFormSingleSelectQuestionOption {
  /// The identifier of the answer option. An identifier must be unique within the
  /// question.
  final String refId;

  /// The title of the answer option.
  final String text;

  /// The flag to mark the option as automatic fail. If an automatic fail answer
  /// is provided, the overall evaluation gets a score of 0.
  final bool? automaticFail;

  /// The score assigned to the answer option.
  final int? score;

  EvaluationFormSingleSelectQuestionOption({
    required this.refId,
    required this.text,
    this.automaticFail,
    this.score,
  });

  factory EvaluationFormSingleSelectQuestionOption.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormSingleSelectQuestionOption(
      refId: json['RefId'] as String,
      text: json['Text'] as String,
      automaticFail: json['AutomaticFail'] as bool?,
      score: json['Score'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final refId = this.refId;
    final text = this.text;
    final automaticFail = this.automaticFail;
    final score = this.score;
    return {
      'RefId': refId,
      'Text': text,
      if (automaticFail != null) 'AutomaticFail': automaticFail,
      if (score != null) 'Score': score,
    };
  }
}

/// Information about the options in single select questions.
class EvaluationFormSingleSelectQuestionProperties {
  /// The answer options of the single select question.
  final List<EvaluationFormSingleSelectQuestionOption> options;

  /// The display mode of the single select question.
  final EvaluationFormSingleSelectQuestionAutomation? automation;

  /// The display mode of the single select question.
  final EvaluationFormSingleSelectQuestionDisplayMode? displayAs;

  EvaluationFormSingleSelectQuestionProperties({
    required this.options,
    this.automation,
    this.displayAs,
  });

  factory EvaluationFormSingleSelectQuestionProperties.fromJson(
      Map<String, dynamic> json) {
    return EvaluationFormSingleSelectQuestionProperties(
      options: (json['Options'] as List)
          .nonNulls
          .map((e) => EvaluationFormSingleSelectQuestionOption.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      automation: json['Automation'] != null
          ? EvaluationFormSingleSelectQuestionAutomation.fromJson(
              json['Automation'] as Map<String, dynamic>)
          : null,
      displayAs: (json['DisplayAs'] as String?)
          ?.let(EvaluationFormSingleSelectQuestionDisplayMode.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final options = this.options;
    final automation = this.automation;
    final displayAs = this.displayAs;
    return {
      'Options': options,
      if (automation != null) 'Automation': automation,
      if (displayAs != null) 'DisplayAs': displayAs.value,
    };
  }
}

/// Summary information about an evaluation form.
class EvaluationFormSummary {
  /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
  final String createdBy;

  /// The timestamp for when the evaluation form was created.
  final DateTime createdTime;

  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// The Amazon Resource Name (ARN) of the user who last updated the evaluation
  /// form.
  final String lastModifiedBy;

  /// The timestamp for when the evaluation form was last updated.
  final DateTime lastModifiedTime;

  /// The version number of the latest evaluation form version.
  final int latestVersion;

  /// A title of the evaluation form.
  final String title;

  /// The version of the active evaluation form version.
  final int? activeVersion;

  /// The Amazon Resource Name (ARN) of the user who last activated the evaluation
  /// form.
  final String? lastActivatedBy;

  /// The timestamp for when the evaluation form was last activated.
  final DateTime? lastActivatedTime;

  EvaluationFormSummary({
    required this.createdBy,
    required this.createdTime,
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.lastModifiedBy,
    required this.lastModifiedTime,
    required this.latestVersion,
    required this.title,
    this.activeVersion,
    this.lastActivatedBy,
    this.lastActivatedTime,
  });

  factory EvaluationFormSummary.fromJson(Map<String, dynamic> json) {
    return EvaluationFormSummary(
      createdBy: json['CreatedBy'] as String,
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      lastModifiedBy: json['LastModifiedBy'] as String,
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      latestVersion: json['LatestVersion'] as int,
      title: json['Title'] as String,
      activeVersion: json['ActiveVersion'] as int?,
      lastActivatedBy: json['LastActivatedBy'] as String?,
      lastActivatedTime: timeStampFromJson(json['LastActivatedTime']),
    );
  }

  Map<String, dynamic> toJson() {
    final createdBy = this.createdBy;
    final createdTime = this.createdTime;
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final lastModifiedBy = this.lastModifiedBy;
    final lastModifiedTime = this.lastModifiedTime;
    final latestVersion = this.latestVersion;
    final title = this.title;
    final activeVersion = this.activeVersion;
    final lastActivatedBy = this.lastActivatedBy;
    final lastActivatedTime = this.lastActivatedTime;
    return {
      'CreatedBy': createdBy,
      'CreatedTime': unixTimestampToJson(createdTime),
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'LastModifiedBy': lastModifiedBy,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'LatestVersion': latestVersion,
      'Title': title,
      if (activeVersion != null) 'ActiveVersion': activeVersion,
      if (lastActivatedBy != null) 'LastActivatedBy': lastActivatedBy,
      if (lastActivatedTime != null)
        'LastActivatedTime': unixTimestampToJson(lastActivatedTime),
    };
  }
}

enum EvaluationFormVersionStatus {
  draft('DRAFT'),
  active('ACTIVE'),
  ;

  final String value;

  const EvaluationFormVersionStatus(this.value);

  static EvaluationFormVersionStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum EvaluationFormVersionStatus'));
}

/// Summary information about an evaluation form.
class EvaluationFormVersionSummary {
  /// The Amazon Resource Name (ARN) of the user who created the evaluation form.
  final String createdBy;

  /// The timestamp for when the evaluation form was created.
  final DateTime createdTime;

  /// The Amazon Resource Name (ARN) for the evaluation form resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// A version of the evaluation form.
  final int evaluationFormVersion;

  /// The Amazon Resource Name (ARN) of the user who last updated the evaluation
  /// form.
  final String lastModifiedBy;

  /// The timestamp for when the evaluation form was last updated.
  final DateTime lastModifiedTime;

  /// The flag indicating whether the evaluation form is locked for changes.
  final bool locked;

  /// The status of the evaluation form.
  final EvaluationFormVersionStatus status;

  EvaluationFormVersionSummary({
    required this.createdBy,
    required this.createdTime,
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.evaluationFormVersion,
    required this.lastModifiedBy,
    required this.lastModifiedTime,
    required this.locked,
    required this.status,
  });

  factory EvaluationFormVersionSummary.fromJson(Map<String, dynamic> json) {
    return EvaluationFormVersionSummary(
      createdBy: json['CreatedBy'] as String,
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormVersion: json['EvaluationFormVersion'] as int,
      lastModifiedBy: json['LastModifiedBy'] as String,
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      locked: json['Locked'] as bool,
      status:
          EvaluationFormVersionStatus.fromString((json['Status'] as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final createdBy = this.createdBy;
    final createdTime = this.createdTime;
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormVersion = this.evaluationFormVersion;
    final lastModifiedBy = this.lastModifiedBy;
    final lastModifiedTime = this.lastModifiedTime;
    final locked = this.locked;
    final status = this.status;
    return {
      'CreatedBy': createdBy,
      'CreatedTime': unixTimestampToJson(createdTime),
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormVersion': evaluationFormVersion,
      'LastModifiedBy': lastModifiedBy,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'Locked': locked,
      'Status': status.value,
    };
  }
}

/// Metadata information about a contact evaluation.
class EvaluationMetadata {
  /// The identifier of the contact in this instance of Amazon Connect.
  final String contactId;

  /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
  final String evaluatorArn;

  /// The identifier of the agent who performed the contact.
  final String? contactAgentId;

  /// The overall score of the contact evaluation.
  final EvaluationScore? score;

  EvaluationMetadata({
    required this.contactId,
    required this.evaluatorArn,
    this.contactAgentId,
    this.score,
  });

  factory EvaluationMetadata.fromJson(Map<String, dynamic> json) {
    return EvaluationMetadata(
      contactId: json['ContactId'] as String,
      evaluatorArn: json['EvaluatorArn'] as String,
      contactAgentId: json['ContactAgentId'] as String?,
      score: json['Score'] != null
          ? EvaluationScore.fromJson(json['Score'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contactId = this.contactId;
    final evaluatorArn = this.evaluatorArn;
    final contactAgentId = this.contactAgentId;
    final score = this.score;
    return {
      'ContactId': contactId,
      'EvaluatorArn': evaluatorArn,
      if (contactAgentId != null) 'ContactAgentId': contactAgentId,
      if (score != null) 'Score': score,
    };
  }
}

/// Information about notes for a contact evaluation.
class EvaluationNote {
  /// The note for an item (section or question) in a contact evaluation.
  /// <note>
  /// Even though a note in an evaluation can have up to 3072 chars, there is also
  /// a limit on the total number of chars for all the notes in the evaluation
  /// combined. Assuming there are N questions in the evaluation being submitted,
  /// then the max char limit for all notes combined is N x 1024.
  /// </note>
  final String? value;

  EvaluationNote({
    this.value,
  });

  factory EvaluationNote.fromJson(Map<String, dynamic> json) {
    return EvaluationNote(
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

/// Information about scores of a contact evaluation item (section or question).
class EvaluationScore {
  /// The flag that marks the item as automatic fail. If the item or a child item
  /// gets an automatic fail answer, this flag will be true.
  final bool? automaticFail;

  /// The flag to mark the item as not applicable for scoring.
  final bool? notApplicable;

  /// The score percentage for an item in a contact evaluation.
  final double? percentage;

  EvaluationScore({
    this.automaticFail,
    this.notApplicable,
    this.percentage,
  });

  factory EvaluationScore.fromJson(Map<String, dynamic> json) {
    return EvaluationScore(
      automaticFail: json['AutomaticFail'] as bool?,
      notApplicable: json['NotApplicable'] as bool?,
      percentage: json['Percentage'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final automaticFail = this.automaticFail;
    final notApplicable = this.notApplicable;
    final percentage = this.percentage;
    return {
      if (automaticFail != null) 'AutomaticFail': automaticFail,
      if (notApplicable != null) 'NotApplicable': notApplicable,
      if (percentage != null) 'Percentage': percentage,
    };
  }
}

enum EvaluationStatus {
  draft('DRAFT'),
  submitted('SUBMITTED'),
  ;

  final String value;

  const EvaluationStatus(this.value);

  static EvaluationStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum EvaluationStatus'));
}

/// Summary information about a contact evaluation.
class EvaluationSummary {
  /// The timestamp for when the evaluation was created.
  final DateTime createdTime;

  /// The Amazon Resource Name (ARN) for the contact evaluation resource.
  final String evaluationArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// A title of the evaluation form.
  final String evaluationFormTitle;

  /// A unique identifier for the contact evaluation.
  final String evaluationId;

  /// The Amazon Resource Name (ARN) of the user who last updated the evaluation.
  final String evaluatorArn;

  /// The timestamp for when the evaluation was last updated.
  final DateTime lastModifiedTime;

  /// The status of the contact evaluation.
  final EvaluationStatus status;

  /// The overall score of the contact evaluation.
  final EvaluationScore? score;

  EvaluationSummary({
    required this.createdTime,
    required this.evaluationArn,
    required this.evaluationFormId,
    required this.evaluationFormTitle,
    required this.evaluationId,
    required this.evaluatorArn,
    required this.lastModifiedTime,
    required this.status,
    this.score,
  });

  factory EvaluationSummary.fromJson(Map<String, dynamic> json) {
    return EvaluationSummary(
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      evaluationArn: json['EvaluationArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormTitle: json['EvaluationFormTitle'] as String,
      evaluationId: json['EvaluationId'] as String,
      evaluatorArn: json['EvaluatorArn'] as String,
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      status: EvaluationStatus.fromString((json['Status'] as String)),
      score: json['Score'] != null
          ? EvaluationScore.fromJson(json['Score'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final createdTime = this.createdTime;
    final evaluationArn = this.evaluationArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormTitle = this.evaluationFormTitle;
    final evaluationId = this.evaluationId;
    final evaluatorArn = this.evaluatorArn;
    final lastModifiedTime = this.lastModifiedTime;
    final status = this.status;
    final score = this.score;
    return {
      'CreatedTime': unixTimestampToJson(createdTime),
      'EvaluationArn': evaluationArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormTitle': evaluationFormTitle,
      'EvaluationId': evaluationId,
      'EvaluatorArn': evaluatorArn,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'Status': status.value,
      if (score != null) 'Score': score,
    };
  }
}

/// The EventBridge action definition.
class EventBridgeActionDefinition {
  /// The name.
  final String name;

  EventBridgeActionDefinition({
    required this.name,
  });

  factory EventBridgeActionDefinition.fromJson(Map<String, dynamic> json) {
    return EventBridgeActionDefinition(
      name: json['Name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      'Name': name,
    };
  }
}

enum EventSourceName {
  onPostCallAnalysisAvailable('OnPostCallAnalysisAvailable'),
  onRealTimeCallAnalysisAvailable('OnRealTimeCallAnalysisAvailable'),
  onRealTimeChatAnalysisAvailable('OnRealTimeChatAnalysisAvailable'),
  onPostChatAnalysisAvailable('OnPostChatAnalysisAvailable'),
  onZendeskTicketCreate('OnZendeskTicketCreate'),
  onZendeskTicketStatusUpdate('OnZendeskTicketStatusUpdate'),
  onSalesforceCaseCreate('OnSalesforceCaseCreate'),
  onContactEvaluationSubmit('OnContactEvaluationSubmit'),
  onMetricDataUpdate('OnMetricDataUpdate'),
  onCaseCreate('OnCaseCreate'),
  onCaseUpdate('OnCaseUpdate'),
  ;

  final String value;

  const EventSourceName(this.value);

  static EventSourceName fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum EventSourceName'));
}

/// An object to specify the expiration of a routing step.
class Expiry {
  /// The number of seconds to wait before expiring the routing step.
  final int? durationInSeconds;

  /// The timestamp indicating when the routing step expires.
  final DateTime? expiryTimestamp;

  Expiry({
    this.durationInSeconds,
    this.expiryTimestamp,
  });

  factory Expiry.fromJson(Map<String, dynamic> json) {
    return Expiry(
      durationInSeconds: json['DurationInSeconds'] as int?,
      expiryTimestamp: timeStampFromJson(json['ExpiryTimestamp']),
    );
  }

  Map<String, dynamic> toJson() {
    final durationInSeconds = this.durationInSeconds;
    final expiryTimestamp = this.expiryTimestamp;
    return {
      if (durationInSeconds != null) 'DurationInSeconds': durationInSeconds,
      if (expiryTimestamp != null)
        'ExpiryTimestamp': unixTimestampToJson(expiryTimestamp),
    };
  }
}

/// A tagged union to specify expression for a routing step.
class Expression {
  /// List of routing expressions which will be AND-ed together.
  final List<Expression>? andExpression;

  /// An object to specify the predefined attribute condition.
  final AttributeCondition? attributeCondition;

  /// List of routing expressions which will be OR-ed together.
  final List<Expression>? orExpression;

  Expression({
    this.andExpression,
    this.attributeCondition,
    this.orExpression,
  });

  factory Expression.fromJson(Map<String, dynamic> json) {
    return Expression(
      andExpression: (json['AndExpression'] as List?)
          ?.nonNulls
          .map((e) => Expression.fromJson(e as Map<String, dynamic>))
          .toList(),
      attributeCondition: json['AttributeCondition'] != null
          ? AttributeCondition.fromJson(
              json['AttributeCondition'] as Map<String, dynamic>)
          : null,
      orExpression: (json['OrExpression'] as List?)
          ?.nonNulls
          .map((e) => Expression.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final andExpression = this.andExpression;
    final attributeCondition = this.attributeCondition;
    final orExpression = this.orExpression;
    return {
      if (andExpression != null) 'AndExpression': andExpression,
      if (attributeCondition != null) 'AttributeCondition': attributeCondition,
      if (orExpression != null) 'OrExpression': orExpression,
    };
  }
}

/// Request for which contact failed to be generated.
class FailedRequest {
  /// Reason code for the failure.
  final FailureReasonCode? failureReasonCode;

  /// Why the request to create a contact failed.
  final String? failureReasonMessage;

  /// Request identifier provided in the API call in the ContactDataRequest to
  /// create a contact.
  final String? requestIdentifier;

  FailedRequest({
    this.failureReasonCode,
    this.failureReasonMessage,
    this.requestIdentifier,
  });

  factory FailedRequest.fromJson(Map<String, dynamic> json) {
    return FailedRequest(
      failureReasonCode: (json['FailureReasonCode'] as String?)
          ?.let(FailureReasonCode.fromString),
      failureReasonMessage: json['FailureReasonMessage'] as String?,
      requestIdentifier: json['RequestIdentifier'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final failureReasonCode = this.failureReasonCode;
    final failureReasonMessage = this.failureReasonMessage;
    final requestIdentifier = this.requestIdentifier;
    return {
      if (failureReasonCode != null)
        'FailureReasonCode': failureReasonCode.value,
      if (failureReasonMessage != null)
        'FailureReasonMessage': failureReasonMessage,
      if (requestIdentifier != null) 'RequestIdentifier': requestIdentifier,
    };
  }
}

enum FailureReasonCode {
  invalidAttributeKey('INVALID_ATTRIBUTE_KEY'),
  invalidCustomerEndpoint('INVALID_CUSTOMER_ENDPOINT'),
  invalidSystemEndpoint('INVALID_SYSTEM_ENDPOINT'),
  invalidQueue('INVALID_QUEUE'),
  missingCampaign('MISSING_CAMPAIGN'),
  missingCustomerEndpoint('MISSING_CUSTOMER_ENDPOINT'),
  missingQueueIdAndSystemEndpoint('MISSING_QUEUE_ID_AND_SYSTEM_ENDPOINT'),
  requestThrottled('REQUEST_THROTTLED'),
  idempotencyException('IDEMPOTENCY_EXCEPTION'),
  internalError('INTERNAL_ERROR'),
  ;

  final String value;

  const FailureReasonCode(this.value);

  static FailureReasonCode fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum FailureReasonCode'));
}

/// Object for case field values.
class FieldValue {
  /// Unique identifier of a field.
  final String id;

  /// Union of potential field value types.
  final FieldValueUnion value;

  FieldValue({
    required this.id,
    required this.value,
  });

  factory FieldValue.fromJson(Map<String, dynamic> json) {
    return FieldValue(
      id: json['Id'] as String,
      value: FieldValueUnion.fromJson(json['Value'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final value = this.value;
    return {
      'Id': id,
      'Value': value,
    };
  }
}

/// Object to store union of Field values.
class FieldValueUnion {
  /// A Boolean number value type.
  final bool? booleanValue;

  /// a Double number value type.
  final double? doubleValue;

  /// An empty value.
  final EmptyFieldValue? emptyValue;

  /// String value type.
  final String? stringValue;

  FieldValueUnion({
    this.booleanValue,
    this.doubleValue,
    this.emptyValue,
    this.stringValue,
  });

  factory FieldValueUnion.fromJson(Map<String, dynamic> json) {
    return FieldValueUnion(
      booleanValue: json['BooleanValue'] as bool?,
      doubleValue: json['DoubleValue'] as double?,
      emptyValue: json['EmptyValue'] != null
          ? EmptyFieldValue.fromJson(json['EmptyValue'] as Map<String, dynamic>)
          : null,
      stringValue: json['StringValue'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final booleanValue = this.booleanValue;
    final doubleValue = this.doubleValue;
    final emptyValue = this.emptyValue;
    final stringValue = this.stringValue;
    return {
      if (booleanValue != null) 'BooleanValue': booleanValue,
      if (doubleValue != null) 'DoubleValue': doubleValue,
      if (emptyValue != null) 'EmptyValue': emptyValue,
      if (stringValue != null) 'StringValue': stringValue,
    };
  }
}

enum FileStatusType {
  approved('APPROVED'),
  rejected('REJECTED'),
  processing('PROCESSING'),
  failed('FAILED'),
  ;

  final String value;

  const FileStatusType(this.value);

  static FileStatusType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum FileStatusType'));
}

enum FileUseCaseType {
  attachment('ATTACHMENT'),
  ;

  final String value;

  const FileUseCaseType(this.value);

  static FileUseCaseType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum FileUseCaseType'));
}

/// Contains the filter to apply when retrieving metrics with the <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_GetMetricDataV2.html">GetMetricDataV2</a>
/// API.
class FilterV2 {
  /// The key to use for filtering data. For example, <code>QUEUE</code>,
  /// <code>ROUTING_PROFILE, AGENT</code>, <code>CHANNEL</code>,
  /// <code>AGENT_HIERARCHY_LEVEL_ONE</code>,
  /// <code>AGENT_HIERARCHY_LEVEL_TWO</code>,
  /// <code>AGENT_HIERARCHY_LEVEL_THREE</code>,
  /// <code>AGENT_HIERARCHY_LEVEL_FOUR</code>,
  /// <code>AGENT_HIERARCHY_LEVEL_FIVE</code>. There must be at least 1 key and a
  /// maximum 5 keys.
  final String? filterKey;

  /// The identifiers to use for filtering data. For example, if you have a filter
  /// key of <code>QUEUE</code>, you would add queue IDs or ARNs in
  /// <code>FilterValues</code>.
  final List<String>? filterValues;

  FilterV2({
    this.filterKey,
    this.filterValues,
  });

  Map<String, dynamic> toJson() {
    final filterKey = this.filterKey;
    final filterValues = this.filterValues;
    return {
      if (filterKey != null) 'FilterKey': filterKey,
      if (filterValues != null) 'FilterValues': filterValues,
    };
  }
}

/// Contains the filter to apply when retrieving metrics.
class Filters {
  /// The channel to use to filter the metrics.
  final List<Channel>? channels;

  /// The queues to use to filter the metrics. You should specify at least one
  /// queue, and can specify up to 100 queues per request. The
  /// <code>GetCurrentMetricsData</code> API in particular requires a queue when
  /// you include a <code>Filter</code> in your request.
  final List<String>? queues;

  /// A list of up to 100 routing profile IDs or ARNs.
  final List<String>? routingProfiles;

  /// A list of expressions as a filter, in which an expression is an object of a
  /// step in a routing criteria.
  final List<String>? routingStepExpressions;

  Filters({
    this.channels,
    this.queues,
    this.routingProfiles,
    this.routingStepExpressions,
  });

  Map<String, dynamic> toJson() {
    final channels = this.channels;
    final queues = this.queues;
    final routingProfiles = this.routingProfiles;
    final routingStepExpressions = this.routingStepExpressions;
    return {
      if (channels != null) 'Channels': channels.map((e) => e.value).toList(),
      if (queues != null) 'Queues': queues,
      if (routingProfiles != null) 'RoutingProfiles': routingProfiles,
      if (routingStepExpressions != null)
        'RoutingStepExpressions': routingStepExpressions,
    };
  }
}

enum FlowAssociationResourceType {
  smsPhoneNumber('SMS_PHONE_NUMBER'),
  ;

  final String value;

  const FlowAssociationResourceType(this.value);

  static FlowAssociationResourceType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum FlowAssociationResourceType'));
}

/// Information about flow associations.
class FlowAssociationSummary {
  /// The identifier of the flow.
  final String? flowId;

  /// The identifier of the resource.
  final String? resourceId;

  /// The type of resource association.
  final ListFlowAssociationResourceType? resourceType;

  FlowAssociationSummary({
    this.flowId,
    this.resourceId,
    this.resourceType,
  });

  factory FlowAssociationSummary.fromJson(Map<String, dynamic> json) {
    return FlowAssociationSummary(
      flowId: json['FlowId'] as String?,
      resourceId: json['ResourceId'] as String?,
      resourceType: (json['ResourceType'] as String?)
          ?.let(ListFlowAssociationResourceType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final flowId = this.flowId;
    final resourceId = this.resourceId;
    final resourceType = this.resourceType;
    return {
      if (flowId != null) 'FlowId': flowId,
      if (resourceId != null) 'ResourceId': resourceId,
      if (resourceType != null) 'ResourceType': resourceType.value,
    };
  }
}

/// Response from GetAttachedFile API.
class GetAttachedFileResponse {
  /// The size of the attached file in bytes.
  final int fileSizeInBytes;

  /// The resource to which the attached file is (being) uploaded to. <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_connect-cases_CreateCase.html">Cases</a>
  /// are the only current supported resource.
  final String? associatedResourceArn;

  /// Represents the identity that created the file.
  final CreatedByInfo? createdBy;

  /// The time of Creation of the file resource as an ISO timestamp. It's
  /// specified in ISO 8601 format: <code>yyyy-MM-ddThh:mm:ss.SSSZ</code>. For
  /// example, <code>2024-05-03T02:41:28.172Z</code>.
  final String? creationTime;

  /// URL and expiry to be used when downloading the attached file.
  final DownloadUrlMetadata? downloadUrlMetadata;

  /// The unique identifier of the attached file resource (ARN).
  final String? fileArn;

  /// The unique identifier of the attached file resource.
  final String? fileId;

  /// A case-sensitive name of the attached file being uploaded.
  final String? fileName;

  /// The current status of the attached file.
  final FileStatusType? fileStatus;

  /// The use case for the file.
  final FileUseCaseType? fileUseCaseType;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, <code>{ "Tags": {"key1":"value1", "key2":"value2"} }</code>.
  final Map<String, String>? tags;

  GetAttachedFileResponse({
    required this.fileSizeInBytes,
    this.associatedResourceArn,
    this.createdBy,
    this.creationTime,
    this.downloadUrlMetadata,
    this.fileArn,
    this.fileId,
    this.fileName,
    this.fileStatus,
    this.fileUseCaseType,
    this.tags,
  });

  factory GetAttachedFileResponse.fromJson(Map<String, dynamic> json) {
    return GetAttachedFileResponse(
      fileSizeInBytes: json['FileSizeInBytes'] as int,
      associatedResourceArn: json['AssociatedResourceArn'] as String?,
      createdBy: json['CreatedBy'] != null
          ? CreatedByInfo.fromJson(json['CreatedBy'] as Map<String, dynamic>)
          : null,
      creationTime: json['CreationTime'] as String?,
      downloadUrlMetadata: json['DownloadUrlMetadata'] != null
          ? DownloadUrlMetadata.fromJson(
              json['DownloadUrlMetadata'] as Map<String, dynamic>)
          : null,
      fileArn: json['FileArn'] as String?,
      fileId: json['FileId'] as String?,
      fileName: json['FileName'] as String?,
      fileStatus:
          (json['FileStatus'] as String?)?.let(FileStatusType.fromString),
      fileUseCaseType:
          (json['FileUseCaseType'] as String?)?.let(FileUseCaseType.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final fileSizeInBytes = this.fileSizeInBytes;
    final associatedResourceArn = this.associatedResourceArn;
    final createdBy = this.createdBy;
    final creationTime = this.creationTime;
    final downloadUrlMetadata = this.downloadUrlMetadata;
    final fileArn = this.fileArn;
    final fileId = this.fileId;
    final fileName = this.fileName;
    final fileStatus = this.fileStatus;
    final fileUseCaseType = this.fileUseCaseType;
    final tags = this.tags;
    return {
      'FileSizeInBytes': fileSizeInBytes,
      if (associatedResourceArn != null)
        'AssociatedResourceArn': associatedResourceArn,
      if (createdBy != null) 'CreatedBy': createdBy,
      if (creationTime != null) 'CreationTime': creationTime,
      if (downloadUrlMetadata != null)
        'DownloadUrlMetadata': downloadUrlMetadata,
      if (fileArn != null) 'FileArn': fileArn,
      if (fileId != null) 'FileId': fileId,
      if (fileName != null) 'FileName': fileName,
      if (fileStatus != null) 'FileStatus': fileStatus.value,
      if (fileUseCaseType != null) 'FileUseCaseType': fileUseCaseType.value,
      if (tags != null) 'Tags': tags,
    };
  }
}

class GetContactAttributesResponse {
  /// Information about the attributes.
  final Map<String, String>? attributes;

  GetContactAttributesResponse({
    this.attributes,
  });

  factory GetContactAttributesResponse.fromJson(Map<String, dynamic> json) {
    return GetContactAttributesResponse(
      attributes: (json['Attributes'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final attributes = this.attributes;
    return {
      if (attributes != null) 'Attributes': attributes,
    };
  }
}

class GetCurrentMetricDataResponse {
  /// The total count of the result, regardless of the current page size.
  final int? approximateTotalCount;

  /// The time at which the metrics were retrieved and cached for pagination.
  final DateTime? dataSnapshotTime;

  /// Information about the real-time metrics.
  final List<CurrentMetricResult>? metricResults;

  /// If there are additional results, this is the token for the next set of
  /// results.
  ///
  /// The token expires after 5 minutes from the time it is created. Subsequent
  /// requests that use the token must use the same request parameters as the
  /// request that generated the token.
  final String? nextToken;

  GetCurrentMetricDataResponse({
    this.approximateTotalCount,
    this.dataSnapshotTime,
    this.metricResults,
    this.nextToken,
  });

  factory GetCurrentMetricDataResponse.fromJson(Map<String, dynamic> json) {
    return GetCurrentMetricDataResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      dataSnapshotTime: timeStampFromJson(json['DataSnapshotTime']),
      metricResults: (json['MetricResults'] as List?)
          ?.nonNulls
          .map((e) => CurrentMetricResult.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final dataSnapshotTime = this.dataSnapshotTime;
    final metricResults = this.metricResults;
    final nextToken = this.nextToken;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (dataSnapshotTime != null)
        'DataSnapshotTime': unixTimestampToJson(dataSnapshotTime),
      if (metricResults != null) 'MetricResults': metricResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class GetCurrentUserDataResponse {
  /// The total count of the result, regardless of the current page size.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// A list of the user data that is returned.
  final List<UserData>? userDataList;

  GetCurrentUserDataResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.userDataList,
  });

  factory GetCurrentUserDataResponse.fromJson(Map<String, dynamic> json) {
    return GetCurrentUserDataResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      userDataList: (json['UserDataList'] as List?)
          ?.nonNulls
          .map((e) => UserData.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final userDataList = this.userDataList;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (userDataList != null) 'UserDataList': userDataList,
    };
  }
}

class GetFederationTokenResponse {
  /// The credentials to use for federation.
  final Credentials? credentials;

  /// The URL to sign into the user's instance.
  final String? signInUrl;

  /// The Amazon Resource Name (ARN) of the user.
  final String? userArn;

  /// The identifier for the user. This can be the ID or the ARN of the user.
  final String? userId;

  GetFederationTokenResponse({
    this.credentials,
    this.signInUrl,
    this.userArn,
    this.userId,
  });

  factory GetFederationTokenResponse.fromJson(Map<String, dynamic> json) {
    return GetFederationTokenResponse(
      credentials: json['Credentials'] != null
          ? Credentials.fromJson(json['Credentials'] as Map<String, dynamic>)
          : null,
      signInUrl: json['SignInUrl'] as String?,
      userArn: json['UserArn'] as String?,
      userId: json['UserId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final credentials = this.credentials;
    final signInUrl = this.signInUrl;
    final userArn = this.userArn;
    final userId = this.userId;
    return {
      if (credentials != null) 'Credentials': credentials,
      if (signInUrl != null) 'SignInUrl': signInUrl,
      if (userArn != null) 'UserArn': userArn,
      if (userId != null) 'UserId': userId,
    };
  }
}

class GetFlowAssociationResponse {
  /// The identifier of the flow.
  final String? flowId;

  /// The identifier of the resource.
  final String? resourceId;

  /// A valid resource type.
  final FlowAssociationResourceType? resourceType;

  GetFlowAssociationResponse({
    this.flowId,
    this.resourceId,
    this.resourceType,
  });

  factory GetFlowAssociationResponse.fromJson(Map<String, dynamic> json) {
    return GetFlowAssociationResponse(
      flowId: json['FlowId'] as String?,
      resourceId: json['ResourceId'] as String?,
      resourceType: (json['ResourceType'] as String?)
          ?.let(FlowAssociationResourceType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final flowId = this.flowId;
    final resourceId = this.resourceId;
    final resourceType = this.resourceType;
    return {
      if (flowId != null) 'FlowId': flowId,
      if (resourceId != null) 'ResourceId': resourceId,
      if (resourceType != null) 'ResourceType': resourceType.value,
    };
  }
}

class GetMetricDataResponse {
  /// Information about the historical metrics.
  ///
  /// If no grouping is specified, a summary of metric data is returned.
  final List<HistoricalMetricResult>? metricResults;

  /// If there are additional results, this is the token for the next set of
  /// results.
  ///
  /// The token expires after 5 minutes from the time it is created. Subsequent
  /// requests that use the token must use the same request parameters as the
  /// request that generated the token.
  final String? nextToken;

  GetMetricDataResponse({
    this.metricResults,
    this.nextToken,
  });

  factory GetMetricDataResponse.fromJson(Map<String, dynamic> json) {
    return GetMetricDataResponse(
      metricResults: (json['MetricResults'] as List?)
          ?.nonNulls
          .map(
              (e) => HistoricalMetricResult.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final metricResults = this.metricResults;
    final nextToken = this.nextToken;
    return {
      if (metricResults != null) 'MetricResults': metricResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class GetMetricDataV2Response {
  /// Information about the metrics requested in the API request If no grouping is
  /// specified, a summary of metric data is returned.
  final List<MetricResultV2>? metricResults;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  GetMetricDataV2Response({
    this.metricResults,
    this.nextToken,
  });

  factory GetMetricDataV2Response.fromJson(Map<String, dynamic> json) {
    return GetMetricDataV2Response(
      metricResults: (json['MetricResults'] as List?)
          ?.nonNulls
          .map((e) => MetricResultV2.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final metricResults = this.metricResults;
    final nextToken = this.nextToken;
    return {
      if (metricResults != null) 'MetricResults': metricResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class GetPromptFileResponse {
  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// A generated URL to the prompt that can be given to an unauthorized user so
  /// they can access the prompt in S3.
  final String? promptPresignedUrl;

  GetPromptFileResponse({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.promptPresignedUrl,
  });

  factory GetPromptFileResponse.fromJson(Map<String, dynamic> json) {
    return GetPromptFileResponse(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      promptPresignedUrl: json['PromptPresignedUrl'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final promptPresignedUrl = this.promptPresignedUrl;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (promptPresignedUrl != null) 'PromptPresignedUrl': promptPresignedUrl,
    };
  }
}

class GetTaskTemplateResponse {
  /// The Amazon Resource Name (ARN).
  final String arn;

  /// A unique identifier for the task template.
  final String id;

  /// The name of the task template.
  final String name;

  /// Constraints that are applicable to the fields listed.
  final TaskTemplateConstraints? constraints;

  /// The identifier of the flow that runs by default when a task is created by
  /// referencing this template.
  final String? contactFlowId;

  /// The timestamp when the task template was created.
  final DateTime? createdTime;

  /// The default values for fields when a task is created by referencing this
  /// template.
  final TaskTemplateDefaults? defaults;

  /// The description of the task template.
  final String? description;

  /// Fields that are part of the template.
  final List<TaskTemplateField>? fields;

  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? instanceId;

  /// The timestamp when the task template was last modified.
  final DateTime? lastModifiedTime;

  /// Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task
  /// to refer to it. Tasks can only be created from <code>ACTIVE</code>
  /// templates. If a template is marked as <code>INACTIVE</code>, then a task
  /// that refers to this template cannot be created.
  final TaskTemplateStatus? status;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  GetTaskTemplateResponse({
    required this.arn,
    required this.id,
    required this.name,
    this.constraints,
    this.contactFlowId,
    this.createdTime,
    this.defaults,
    this.description,
    this.fields,
    this.instanceId,
    this.lastModifiedTime,
    this.status,
    this.tags,
  });

  factory GetTaskTemplateResponse.fromJson(Map<String, dynamic> json) {
    return GetTaskTemplateResponse(
      arn: json['Arn'] as String,
      id: json['Id'] as String,
      name: json['Name'] as String,
      constraints: json['Constraints'] != null
          ? TaskTemplateConstraints.fromJson(
              json['Constraints'] as Map<String, dynamic>)
          : null,
      contactFlowId: json['ContactFlowId'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      defaults: json['Defaults'] != null
          ? TaskTemplateDefaults.fromJson(
              json['Defaults'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      fields: (json['Fields'] as List?)
          ?.nonNulls
          .map((e) => TaskTemplateField.fromJson(e as Map<String, dynamic>))
          .toList(),
      instanceId: json['InstanceId'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      status: (json['Status'] as String?)?.let(TaskTemplateStatus.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final name = this.name;
    final constraints = this.constraints;
    final contactFlowId = this.contactFlowId;
    final createdTime = this.createdTime;
    final defaults = this.defaults;
    final description = this.description;
    final fields = this.fields;
    final instanceId = this.instanceId;
    final lastModifiedTime = this.lastModifiedTime;
    final status = this.status;
    final tags = this.tags;
    return {
      'Arn': arn,
      'Id': id,
      'Name': name,
      if (constraints != null) 'Constraints': constraints,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (defaults != null) 'Defaults': defaults,
      if (description != null) 'Description': description,
      if (fields != null) 'Fields': fields,
      if (instanceId != null) 'InstanceId': instanceId,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
    };
  }
}

class GetTrafficDistributionResponse {
  /// The distribution of agents between the instance and its replica(s).
  final AgentConfig? agentConfig;

  /// The Amazon Resource Name (ARN) of the traffic distribution group.
  final String? arn;

  /// The identifier of the traffic distribution group. This can be the ID or the
  /// ARN if the API is being called in the Region where the traffic distribution
  /// group was created. The ARN must be provided if the call is from the
  /// replicated Region.
  final String? id;

  /// The distribution that determines which Amazon Web Services Regions should be
  /// used to sign in agents in to both the instance and its replica(s).
  final SignInConfig? signInConfig;

  /// The distribution of traffic between the instance and its replicas.
  final TelephonyConfig? telephonyConfig;

  GetTrafficDistributionResponse({
    this.agentConfig,
    this.arn,
    this.id,
    this.signInConfig,
    this.telephonyConfig,
  });

  factory GetTrafficDistributionResponse.fromJson(Map<String, dynamic> json) {
    return GetTrafficDistributionResponse(
      agentConfig: json['AgentConfig'] != null
          ? AgentConfig.fromJson(json['AgentConfig'] as Map<String, dynamic>)
          : null,
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      signInConfig: json['SignInConfig'] != null
          ? SignInConfig.fromJson(json['SignInConfig'] as Map<String, dynamic>)
          : null,
      telephonyConfig: json['TelephonyConfig'] != null
          ? TelephonyConfig.fromJson(
              json['TelephonyConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final agentConfig = this.agentConfig;
    final arn = this.arn;
    final id = this.id;
    final signInConfig = this.signInConfig;
    final telephonyConfig = this.telephonyConfig;
    return {
      if (agentConfig != null) 'AgentConfig': agentConfig,
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (signInConfig != null) 'SignInConfig': signInConfig,
      if (telephonyConfig != null) 'TelephonyConfig': telephonyConfig,
    };
  }
}

enum Grouping {
  queue('QUEUE'),
  channel('CHANNEL'),
  routingProfile('ROUTING_PROFILE'),
  routingStepExpression('ROUTING_STEP_EXPRESSION'),
  ;

  final String value;

  const Grouping(this.value);

  static Grouping fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum Grouping'));
}

/// Contains information about a hierarchy group.
class HierarchyGroup {
  /// The Amazon Resource Name (ARN) of the hierarchy group.
  final String? arn;

  /// Information about the levels in the hierarchy group.
  final HierarchyPath? hierarchyPath;

  /// The identifier of the hierarchy group.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The identifier of the level in the hierarchy group.
  final String? levelId;

  /// The name of the hierarchy group.
  final String? name;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  HierarchyGroup({
    this.arn,
    this.hierarchyPath,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.levelId,
    this.name,
    this.tags,
  });

  factory HierarchyGroup.fromJson(Map<String, dynamic> json) {
    return HierarchyGroup(
      arn: json['Arn'] as String?,
      hierarchyPath: json['HierarchyPath'] != null
          ? HierarchyPath.fromJson(
              json['HierarchyPath'] as Map<String, dynamic>)
          : null,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      levelId: json['LevelId'] as String?,
      name: json['Name'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final hierarchyPath = this.hierarchyPath;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final levelId = this.levelId;
    final name = this.name;
    final tags = this.tags;
    return {
      if (arn != null) 'Arn': arn,
      if (hierarchyPath != null) 'HierarchyPath': hierarchyPath,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (levelId != null) 'LevelId': levelId,
      if (name != null) 'Name': name,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// A leaf node condition which can be used to specify a hierarchy group
/// condition.
class HierarchyGroupCondition {
  /// The type of hierarchy group match.
  final HierarchyGroupMatchType? hierarchyGroupMatchType;

  /// The value in the hierarchy group condition.
  final String? value;

  HierarchyGroupCondition({
    this.hierarchyGroupMatchType,
    this.value,
  });

  Map<String, dynamic> toJson() {
    final hierarchyGroupMatchType = this.hierarchyGroupMatchType;
    final value = this.value;
    return {
      if (hierarchyGroupMatchType != null)
        'HierarchyGroupMatchType': hierarchyGroupMatchType.value,
      if (value != null) 'Value': value,
    };
  }
}

enum HierarchyGroupMatchType {
  exact('EXACT'),
  withChildGroups('WITH_CHILD_GROUPS'),
  ;

  final String value;

  const HierarchyGroupMatchType(this.value);

  static HierarchyGroupMatchType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum HierarchyGroupMatchType'));
}

/// Contains summary information about a hierarchy group.
class HierarchyGroupSummary {
  /// The Amazon Resource Name (ARN) of the hierarchy group.
  final String? arn;

  /// The identifier of the hierarchy group.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the hierarchy group.
  final String? name;

  HierarchyGroupSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory HierarchyGroupSummary.fromJson(Map<String, dynamic> json) {
    return HierarchyGroupSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

/// Information about the hierarchy group.
class HierarchyGroupSummaryReference {
  /// The Amazon Resource Name (ARN) for the hierarchy group.
  final String? arn;

  /// The unique identifier for the hierarchy group.
  final String? id;

  HierarchyGroupSummaryReference({
    this.arn,
    this.id,
  });

  factory HierarchyGroupSummaryReference.fromJson(Map<String, dynamic> json) {
    return HierarchyGroupSummaryReference(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

/// Information about the agent hierarchy. Hierarchies can be configured with up
/// to five levels.
class HierarchyGroups {
  /// The group at level one of the agent hierarchy.
  final AgentHierarchyGroup? level1;

  /// The group at level two of the agent hierarchy.
  final AgentHierarchyGroup? level2;

  /// The group at level three of the agent hierarchy.
  final AgentHierarchyGroup? level3;

  /// The group at level four of the agent hierarchy.
  final AgentHierarchyGroup? level4;

  /// The group at level five of the agent hierarchy.
  final AgentHierarchyGroup? level5;

  HierarchyGroups({
    this.level1,
    this.level2,
    this.level3,
    this.level4,
    this.level5,
  });

  factory HierarchyGroups.fromJson(Map<String, dynamic> json) {
    return HierarchyGroups(
      level1: json['Level1'] != null
          ? AgentHierarchyGroup.fromJson(json['Level1'] as Map<String, dynamic>)
          : null,
      level2: json['Level2'] != null
          ? AgentHierarchyGroup.fromJson(json['Level2'] as Map<String, dynamic>)
          : null,
      level3: json['Level3'] != null
          ? AgentHierarchyGroup.fromJson(json['Level3'] as Map<String, dynamic>)
          : null,
      level4: json['Level4'] != null
          ? AgentHierarchyGroup.fromJson(json['Level4'] as Map<String, dynamic>)
          : null,
      level5: json['Level5'] != null
          ? AgentHierarchyGroup.fromJson(json['Level5'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final level1 = this.level1;
    final level2 = this.level2;
    final level3 = this.level3;
    final level4 = this.level4;
    final level5 = this.level5;
    return {
      if (level1 != null) 'Level1': level1,
      if (level2 != null) 'Level2': level2,
      if (level3 != null) 'Level3': level3,
      if (level4 != null) 'Level4': level4,
      if (level5 != null) 'Level5': level5,
    };
  }
}

/// Contains information about a hierarchy level.
class HierarchyLevel {
  /// The Amazon Resource Name (ARN) of the hierarchy level.
  final String? arn;

  /// The identifier of the hierarchy level.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the hierarchy level.
  final String? name;

  HierarchyLevel({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory HierarchyLevel.fromJson(Map<String, dynamic> json) {
    return HierarchyLevel(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

/// Contains information about the hierarchy level to update.
class HierarchyLevelUpdate {
  /// The name of the user hierarchy level. Must not be more than 50 characters.
  final String name;

  HierarchyLevelUpdate({
    required this.name,
  });

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      'Name': name,
    };
  }
}

/// Contains information about the levels of a hierarchy group.
class HierarchyPath {
  /// Information about level five.
  final HierarchyGroupSummary? levelFive;

  /// Information about level four.
  final HierarchyGroupSummary? levelFour;

  /// Information about level one.
  final HierarchyGroupSummary? levelOne;

  /// Information about level three.
  final HierarchyGroupSummary? levelThree;

  /// Information about level two.
  final HierarchyGroupSummary? levelTwo;

  HierarchyPath({
    this.levelFive,
    this.levelFour,
    this.levelOne,
    this.levelThree,
    this.levelTwo,
  });

  factory HierarchyPath.fromJson(Map<String, dynamic> json) {
    return HierarchyPath(
      levelFive: json['LevelFive'] != null
          ? HierarchyGroupSummary.fromJson(
              json['LevelFive'] as Map<String, dynamic>)
          : null,
      levelFour: json['LevelFour'] != null
          ? HierarchyGroupSummary.fromJson(
              json['LevelFour'] as Map<String, dynamic>)
          : null,
      levelOne: json['LevelOne'] != null
          ? HierarchyGroupSummary.fromJson(
              json['LevelOne'] as Map<String, dynamic>)
          : null,
      levelThree: json['LevelThree'] != null
          ? HierarchyGroupSummary.fromJson(
              json['LevelThree'] as Map<String, dynamic>)
          : null,
      levelTwo: json['LevelTwo'] != null
          ? HierarchyGroupSummary.fromJson(
              json['LevelTwo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final levelFive = this.levelFive;
    final levelFour = this.levelFour;
    final levelOne = this.levelOne;
    final levelThree = this.levelThree;
    final levelTwo = this.levelTwo;
    return {
      if (levelFive != null) 'LevelFive': levelFive,
      if (levelFour != null) 'LevelFour': levelFour,
      if (levelOne != null) 'LevelOne': levelOne,
      if (levelThree != null) 'LevelThree': levelThree,
      if (levelTwo != null) 'LevelTwo': levelTwo,
    };
  }
}

/// Information about the levels in the hierarchy group.
class HierarchyPathReference {
  /// Information about level five.
  final HierarchyGroupSummaryReference? levelFive;

  /// Information about level four.
  final HierarchyGroupSummaryReference? levelFour;

  /// Information about level one.
  final HierarchyGroupSummaryReference? levelOne;

  /// Information about level three.
  final HierarchyGroupSummaryReference? levelThree;

  /// Information about level two.
  final HierarchyGroupSummaryReference? levelTwo;

  HierarchyPathReference({
    this.levelFive,
    this.levelFour,
    this.levelOne,
    this.levelThree,
    this.levelTwo,
  });

  factory HierarchyPathReference.fromJson(Map<String, dynamic> json) {
    return HierarchyPathReference(
      levelFive: json['LevelFive'] != null
          ? HierarchyGroupSummaryReference.fromJson(
              json['LevelFive'] as Map<String, dynamic>)
          : null,
      levelFour: json['LevelFour'] != null
          ? HierarchyGroupSummaryReference.fromJson(
              json['LevelFour'] as Map<String, dynamic>)
          : null,
      levelOne: json['LevelOne'] != null
          ? HierarchyGroupSummaryReference.fromJson(
              json['LevelOne'] as Map<String, dynamic>)
          : null,
      levelThree: json['LevelThree'] != null
          ? HierarchyGroupSummaryReference.fromJson(
              json['LevelThree'] as Map<String, dynamic>)
          : null,
      levelTwo: json['LevelTwo'] != null
          ? HierarchyGroupSummaryReference.fromJson(
              json['LevelTwo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final levelFive = this.levelFive;
    final levelFour = this.levelFour;
    final levelOne = this.levelOne;
    final levelThree = this.levelThree;
    final levelTwo = this.levelTwo;
    return {
      if (levelFive != null) 'LevelFive': levelFive,
      if (levelFour != null) 'LevelFour': levelFour,
      if (levelOne != null) 'LevelOne': levelOne,
      if (levelThree != null) 'LevelThree': levelThree,
      if (levelTwo != null) 'LevelTwo': levelTwo,
    };
  }
}

/// Contains information about a hierarchy structure.
class HierarchyStructure {
  /// Information about level five.
  final HierarchyLevel? levelFive;

  /// Information about level four.
  final HierarchyLevel? levelFour;

  /// Information about level one.
  final HierarchyLevel? levelOne;

  /// Information about level three.
  final HierarchyLevel? levelThree;

  /// Information about level two.
  final HierarchyLevel? levelTwo;

  HierarchyStructure({
    this.levelFive,
    this.levelFour,
    this.levelOne,
    this.levelThree,
    this.levelTwo,
  });

  factory HierarchyStructure.fromJson(Map<String, dynamic> json) {
    return HierarchyStructure(
      levelFive: json['LevelFive'] != null
          ? HierarchyLevel.fromJson(json['LevelFive'] as Map<String, dynamic>)
          : null,
      levelFour: json['LevelFour'] != null
          ? HierarchyLevel.fromJson(json['LevelFour'] as Map<String, dynamic>)
          : null,
      levelOne: json['LevelOne'] != null
          ? HierarchyLevel.fromJson(json['LevelOne'] as Map<String, dynamic>)
          : null,
      levelThree: json['LevelThree'] != null
          ? HierarchyLevel.fromJson(json['LevelThree'] as Map<String, dynamic>)
          : null,
      levelTwo: json['LevelTwo'] != null
          ? HierarchyLevel.fromJson(json['LevelTwo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final levelFive = this.levelFive;
    final levelFour = this.levelFour;
    final levelOne = this.levelOne;
    final levelThree = this.levelThree;
    final levelTwo = this.levelTwo;
    return {
      if (levelFive != null) 'LevelFive': levelFive,
      if (levelFour != null) 'LevelFour': levelFour,
      if (levelOne != null) 'LevelOne': levelOne,
      if (levelThree != null) 'LevelThree': levelThree,
      if (levelTwo != null) 'LevelTwo': levelTwo,
    };
  }
}

/// Contains information about the level hierarchy to update.
class HierarchyStructureUpdate {
  /// The update for level five.
  final HierarchyLevelUpdate? levelFive;

  /// The update for level four.
  final HierarchyLevelUpdate? levelFour;

  /// The update for level one.
  final HierarchyLevelUpdate? levelOne;

  /// The update for level three.
  final HierarchyLevelUpdate? levelThree;

  /// The update for level two.
  final HierarchyLevelUpdate? levelTwo;

  HierarchyStructureUpdate({
    this.levelFive,
    this.levelFour,
    this.levelOne,
    this.levelThree,
    this.levelTwo,
  });

  Map<String, dynamic> toJson() {
    final levelFive = this.levelFive;
    final levelFour = this.levelFour;
    final levelOne = this.levelOne;
    final levelThree = this.levelThree;
    final levelTwo = this.levelTwo;
    return {
      if (levelFive != null) 'LevelFive': levelFive,
      if (levelFour != null) 'LevelFour': levelFour,
      if (levelOne != null) 'LevelOne': levelOne,
      if (levelThree != null) 'LevelThree': levelThree,
      if (levelTwo != null) 'LevelTwo': levelTwo,
    };
  }
}

/// Contains information about a historical metric. For a description of each
/// metric, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/historical-metrics-definitions.html">Historical
/// Metrics Definitions</a> in the <i>Amazon Connect Administrator Guide</i>.
class HistoricalMetric {
  /// The name of the metric.
  final HistoricalMetricName? name;

  /// The statistic for the metric.
  final Statistic? statistic;

  /// The threshold for the metric, used with service level metrics.
  final Threshold? threshold;

  /// The unit for the metric.
  final Unit? unit;

  HistoricalMetric({
    this.name,
    this.statistic,
    this.threshold,
    this.unit,
  });

  factory HistoricalMetric.fromJson(Map<String, dynamic> json) {
    return HistoricalMetric(
      name: (json['Name'] as String?)?.let(HistoricalMetricName.fromString),
      statistic: (json['Statistic'] as String?)?.let(Statistic.fromString),
      threshold: json['Threshold'] != null
          ? Threshold.fromJson(json['Threshold'] as Map<String, dynamic>)
          : null,
      unit: (json['Unit'] as String?)?.let(Unit.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final statistic = this.statistic;
    final threshold = this.threshold;
    final unit = this.unit;
    return {
      if (name != null) 'Name': name.value,
      if (statistic != null) 'Statistic': statistic.value,
      if (threshold != null) 'Threshold': threshold,
      if (unit != null) 'Unit': unit.value,
    };
  }
}

/// Contains the data for a historical metric.
class HistoricalMetricData {
  /// Information about the metric.
  final HistoricalMetric? metric;

  /// The value of the metric.
  final double? value;

  HistoricalMetricData({
    this.metric,
    this.value,
  });

  factory HistoricalMetricData.fromJson(Map<String, dynamic> json) {
    return HistoricalMetricData(
      metric: json['Metric'] != null
          ? HistoricalMetric.fromJson(json['Metric'] as Map<String, dynamic>)
          : null,
      value: json['Value'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final metric = this.metric;
    final value = this.value;
    return {
      if (metric != null) 'Metric': metric,
      if (value != null) 'Value': value,
    };
  }
}

/// The historical metric names.
enum HistoricalMetricName {
  contactsQueued('CONTACTS_QUEUED'),
  contactsHandled('CONTACTS_HANDLED'),
  contactsAbandoned('CONTACTS_ABANDONED'),
  contactsConsulted('CONTACTS_CONSULTED'),
  contactsAgentHungUpFirst('CONTACTS_AGENT_HUNG_UP_FIRST'),
  contactsHandledIncoming('CONTACTS_HANDLED_INCOMING'),
  contactsHandledOutbound('CONTACTS_HANDLED_OUTBOUND'),
  contactsHoldAbandons('CONTACTS_HOLD_ABANDONS'),
  contactsTransferredIn('CONTACTS_TRANSFERRED_IN'),
  contactsTransferredOut('CONTACTS_TRANSFERRED_OUT'),
  contactsTransferredInFromQueue('CONTACTS_TRANSFERRED_IN_FROM_QUEUE'),
  contactsTransferredOutFromQueue('CONTACTS_TRANSFERRED_OUT_FROM_QUEUE'),
  contactsMissed('CONTACTS_MISSED'),
  callbackContactsHandled('CALLBACK_CONTACTS_HANDLED'),
  apiContactsHandled('API_CONTACTS_HANDLED'),
  occupancy('OCCUPANCY'),
  handleTime('HANDLE_TIME'),
  afterContactWorkTime('AFTER_CONTACT_WORK_TIME'),
  queuedTime('QUEUED_TIME'),
  abandonTime('ABANDON_TIME'),
  queueAnswerTime('QUEUE_ANSWER_TIME'),
  holdTime('HOLD_TIME'),
  interactionTime('INTERACTION_TIME'),
  interactionAndHoldTime('INTERACTION_AND_HOLD_TIME'),
  serviceLevel('SERVICE_LEVEL'),
  ;

  final String value;

  const HistoricalMetricName(this.value);

  static HistoricalMetricName fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum HistoricalMetricName'));
}

/// Contains information about the historical metrics retrieved.
class HistoricalMetricResult {
  /// The set of metrics.
  final List<HistoricalMetricData>? collections;

  /// The dimension for the metrics.
  final Dimensions? dimensions;

  HistoricalMetricResult({
    this.collections,
    this.dimensions,
  });

  factory HistoricalMetricResult.fromJson(Map<String, dynamic> json) {
    return HistoricalMetricResult(
      collections: (json['Collections'] as List?)
          ?.nonNulls
          .map((e) => HistoricalMetricData.fromJson(e as Map<String, dynamic>))
          .toList(),
      dimensions: json['Dimensions'] != null
          ? Dimensions.fromJson(json['Dimensions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final collections = this.collections;
    final dimensions = this.dimensions;
    return {
      if (collections != null) 'Collections': collections,
      if (dimensions != null) 'Dimensions': dimensions,
    };
  }
}

/// Information about of the hours of operation.
class HoursOfOperation {
  /// Configuration information for the hours of operation.
  final List<HoursOfOperationConfig>? config;

  /// The description for the hours of operation.
  final String? description;

  /// The Amazon Resource Name (ARN) for the hours of operation.
  final String? hoursOfOperationArn;

  /// The identifier for the hours of operation.
  final String? hoursOfOperationId;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name for the hours of operation.
  final String? name;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  /// The time zone for the hours of operation.
  final String? timeZone;

  HoursOfOperation({
    this.config,
    this.description,
    this.hoursOfOperationArn,
    this.hoursOfOperationId,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.tags,
    this.timeZone,
  });

  factory HoursOfOperation.fromJson(Map<String, dynamic> json) {
    return HoursOfOperation(
      config: (json['Config'] as List?)
          ?.nonNulls
          .map(
              (e) => HoursOfOperationConfig.fromJson(e as Map<String, dynamic>))
          .toList(),
      description: json['Description'] as String?,
      hoursOfOperationArn: json['HoursOfOperationArn'] as String?,
      hoursOfOperationId: json['HoursOfOperationId'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      timeZone: json['TimeZone'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final config = this.config;
    final description = this.description;
    final hoursOfOperationArn = this.hoursOfOperationArn;
    final hoursOfOperationId = this.hoursOfOperationId;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final tags = this.tags;
    final timeZone = this.timeZone;
    return {
      if (config != null) 'Config': config,
      if (description != null) 'Description': description,
      if (hoursOfOperationArn != null)
        'HoursOfOperationArn': hoursOfOperationArn,
      if (hoursOfOperationId != null) 'HoursOfOperationId': hoursOfOperationId,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (tags != null) 'Tags': tags,
      if (timeZone != null) 'TimeZone': timeZone,
    };
  }
}

/// Contains information about the hours of operation.
class HoursOfOperationConfig {
  /// The day that the hours of operation applies to.
  final HoursOfOperationDays day;

  /// The end time that your contact center closes.
  final HoursOfOperationTimeSlice endTime;

  /// The start time that your contact center opens.
  final HoursOfOperationTimeSlice startTime;

  HoursOfOperationConfig({
    required this.day,
    required this.endTime,
    required this.startTime,
  });

  factory HoursOfOperationConfig.fromJson(Map<String, dynamic> json) {
    return HoursOfOperationConfig(
      day: HoursOfOperationDays.fromString((json['Day'] as String)),
      endTime: HoursOfOperationTimeSlice.fromJson(
          json['EndTime'] as Map<String, dynamic>),
      startTime: HoursOfOperationTimeSlice.fromJson(
          json['StartTime'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final day = this.day;
    final endTime = this.endTime;
    final startTime = this.startTime;
    return {
      'Day': day.value,
      'EndTime': endTime,
      'StartTime': startTime,
    };
  }
}

enum HoursOfOperationDays {
  sunday('SUNDAY'),
  monday('MONDAY'),
  tuesday('TUESDAY'),
  wednesday('WEDNESDAY'),
  thursday('THURSDAY'),
  friday('FRIDAY'),
  saturday('SATURDAY'),
  ;

  final String value;

  const HoursOfOperationDays(this.value);

  static HoursOfOperationDays fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum HoursOfOperationDays'));
}

/// The search criteria to be used to return hours of operations.
class HoursOfOperationSearchCriteria {
  /// A list of conditions which would be applied together with an AND condition.
  final List<HoursOfOperationSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an OR condition.
  final List<HoursOfOperationSearchCriteria>? orConditions;

  /// A leaf node condition which can be used to specify a string condition.
  /// <note>
  /// The currently supported values for <code>FieldName</code> are
  /// <code>name</code>, <code>description</code>, <code>timezone</code>, and
  /// <code>resourceID</code>.
  /// </note>
  final StringCondition? stringCondition;

  HoursOfOperationSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Filters to be applied to search results.
class HoursOfOperationSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  HoursOfOperationSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

/// Contains summary information about hours of operation for a contact center.
class HoursOfOperationSummary {
  /// The Amazon Resource Name (ARN) of the hours of operation.
  final String? arn;

  /// The identifier of the hours of operation.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the hours of operation.
  final String? name;

  HoursOfOperationSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory HoursOfOperationSummary.fromJson(Map<String, dynamic> json) {
    return HoursOfOperationSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

/// The start time or end time for an hours of operation.
class HoursOfOperationTimeSlice {
  /// The hours.
  final int hours;

  /// The minutes.
  final int minutes;

  HoursOfOperationTimeSlice({
    required this.hours,
    required this.minutes,
  });

  factory HoursOfOperationTimeSlice.fromJson(Map<String, dynamic> json) {
    return HoursOfOperationTimeSlice(
      hours: json['Hours'] as int,
      minutes: json['Minutes'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final hours = this.hours;
    final minutes = this.minutes;
    return {
      'Hours': hours,
      'Minutes': minutes,
    };
  }
}

class ImportPhoneNumberResponse {
  /// The Amazon Resource Name (ARN) of the phone number.
  final String? phoneNumberArn;

  /// A unique identifier for the phone number.
  final String? phoneNumberId;

  ImportPhoneNumberResponse({
    this.phoneNumberArn,
    this.phoneNumberId,
  });

  factory ImportPhoneNumberResponse.fromJson(Map<String, dynamic> json) {
    return ImportPhoneNumberResponse(
      phoneNumberArn: json['PhoneNumberArn'] as String?,
      phoneNumberId: json['PhoneNumberId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final phoneNumberArn = this.phoneNumberArn;
    final phoneNumberId = this.phoneNumberId;
    return {
      if (phoneNumberArn != null) 'PhoneNumberArn': phoneNumberArn,
      if (phoneNumberId != null) 'PhoneNumberId': phoneNumberId,
    };
  }
}

/// The Amazon Connect instance.
class Instance {
  /// The Amazon Resource Name (ARN) of the instance.
  final String? arn;

  /// When the instance was created.
  final DateTime? createdTime;

  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? id;

  /// The identity management type.
  final DirectoryType? identityManagementType;

  /// Whether inbound calls are enabled.
  final bool? inboundCallsEnabled;

  /// This URL allows contact center users to access the Amazon Connect admin
  /// website.
  final String? instanceAccessUrl;

  /// The alias of instance.
  final String? instanceAlias;

  /// The state of the instance.
  final InstanceStatus? instanceStatus;

  /// Whether outbound calls are enabled.
  final bool? outboundCallsEnabled;

  /// The service role of the instance.
  final String? serviceRole;

  /// Relevant details why the instance was not successfully created.
  final InstanceStatusReason? statusReason;

  /// The tags of an instance.
  final Map<String, String>? tags;

  Instance({
    this.arn,
    this.createdTime,
    this.id,
    this.identityManagementType,
    this.inboundCallsEnabled,
    this.instanceAccessUrl,
    this.instanceAlias,
    this.instanceStatus,
    this.outboundCallsEnabled,
    this.serviceRole,
    this.statusReason,
    this.tags,
  });

  factory Instance.fromJson(Map<String, dynamic> json) {
    return Instance(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      id: json['Id'] as String?,
      identityManagementType: (json['IdentityManagementType'] as String?)
          ?.let(DirectoryType.fromString),
      inboundCallsEnabled: json['InboundCallsEnabled'] as bool?,
      instanceAccessUrl: json['InstanceAccessUrl'] as String?,
      instanceAlias: json['InstanceAlias'] as String?,
      instanceStatus:
          (json['InstanceStatus'] as String?)?.let(InstanceStatus.fromString),
      outboundCallsEnabled: json['OutboundCallsEnabled'] as bool?,
      serviceRole: json['ServiceRole'] as String?,
      statusReason: json['StatusReason'] != null
          ? InstanceStatusReason.fromJson(
              json['StatusReason'] as Map<String, dynamic>)
          : null,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final id = this.id;
    final identityManagementType = this.identityManagementType;
    final inboundCallsEnabled = this.inboundCallsEnabled;
    final instanceAccessUrl = this.instanceAccessUrl;
    final instanceAlias = this.instanceAlias;
    final instanceStatus = this.instanceStatus;
    final outboundCallsEnabled = this.outboundCallsEnabled;
    final serviceRole = this.serviceRole;
    final statusReason = this.statusReason;
    final tags = this.tags;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (id != null) 'Id': id,
      if (identityManagementType != null)
        'IdentityManagementType': identityManagementType.value,
      if (inboundCallsEnabled != null)
        'InboundCallsEnabled': inboundCallsEnabled,
      if (instanceAccessUrl != null) 'InstanceAccessUrl': instanceAccessUrl,
      if (instanceAlias != null) 'InstanceAlias': instanceAlias,
      if (instanceStatus != null) 'InstanceStatus': instanceStatus.value,
      if (outboundCallsEnabled != null)
        'OutboundCallsEnabled': outboundCallsEnabled,
      if (serviceRole != null) 'ServiceRole': serviceRole,
      if (statusReason != null) 'StatusReason': statusReason,
      if (tags != null) 'Tags': tags,
    };
  }
}

enum InstanceAttributeType {
  inboundCalls('INBOUND_CALLS'),
  outboundCalls('OUTBOUND_CALLS'),
  contactflowLogs('CONTACTFLOW_LOGS'),
  contactLens('CONTACT_LENS'),
  autoResolveBestVoices('AUTO_RESOLVE_BEST_VOICES'),
  useCustomTtsVoices('USE_CUSTOM_TTS_VOICES'),
  earlyMedia('EARLY_MEDIA'),
  multiPartyConference('MULTI_PARTY_CONFERENCE'),
  highVolumeOutbound('HIGH_VOLUME_OUTBOUND'),
  enhancedContactMonitoring('ENHANCED_CONTACT_MONITORING'),
  enhancedChatMonitoring('ENHANCED_CHAT_MONITORING'),
  ;

  final String value;

  const InstanceAttributeType(this.value);

  static InstanceAttributeType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum InstanceAttributeType'));
}

enum InstanceStatus {
  creationInProgress('CREATION_IN_PROGRESS'),
  active('ACTIVE'),
  creationFailed('CREATION_FAILED'),
  ;

  final String value;

  const InstanceStatus(this.value);

  static InstanceStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum InstanceStatus'));
}

/// Relevant details why the instance was not successfully created.
class InstanceStatusReason {
  /// The message.
  final String? message;

  InstanceStatusReason({
    this.message,
  });

  factory InstanceStatusReason.fromJson(Map<String, dynamic> json) {
    return InstanceStatusReason(
      message: json['Message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    return {
      if (message != null) 'Message': message,
    };
  }
}

/// The storage configuration for the instance.
class InstanceStorageConfig {
  /// A valid storage type.
  final StorageType storageType;

  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  final String? associationId;

  /// The configuration of the Kinesis Firehose delivery stream.
  final KinesisFirehoseConfig? kinesisFirehoseConfig;

  /// The configuration of the Kinesis data stream.
  final KinesisStreamConfig? kinesisStreamConfig;

  /// The configuration of the Kinesis video stream.
  final KinesisVideoStreamConfig? kinesisVideoStreamConfig;

  /// The S3 bucket configuration.
  final S3Config? s3Config;

  InstanceStorageConfig({
    required this.storageType,
    this.associationId,
    this.kinesisFirehoseConfig,
    this.kinesisStreamConfig,
    this.kinesisVideoStreamConfig,
    this.s3Config,
  });

  factory InstanceStorageConfig.fromJson(Map<String, dynamic> json) {
    return InstanceStorageConfig(
      storageType: StorageType.fromString((json['StorageType'] as String)),
      associationId: json['AssociationId'] as String?,
      kinesisFirehoseConfig: json['KinesisFirehoseConfig'] != null
          ? KinesisFirehoseConfig.fromJson(
              json['KinesisFirehoseConfig'] as Map<String, dynamic>)
          : null,
      kinesisStreamConfig: json['KinesisStreamConfig'] != null
          ? KinesisStreamConfig.fromJson(
              json['KinesisStreamConfig'] as Map<String, dynamic>)
          : null,
      kinesisVideoStreamConfig: json['KinesisVideoStreamConfig'] != null
          ? KinesisVideoStreamConfig.fromJson(
              json['KinesisVideoStreamConfig'] as Map<String, dynamic>)
          : null,
      s3Config: json['S3Config'] != null
          ? S3Config.fromJson(json['S3Config'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final storageType = this.storageType;
    final associationId = this.associationId;
    final kinesisFirehoseConfig = this.kinesisFirehoseConfig;
    final kinesisStreamConfig = this.kinesisStreamConfig;
    final kinesisVideoStreamConfig = this.kinesisVideoStreamConfig;
    final s3Config = this.s3Config;
    return {
      'StorageType': storageType.value,
      if (associationId != null) 'AssociationId': associationId,
      if (kinesisFirehoseConfig != null)
        'KinesisFirehoseConfig': kinesisFirehoseConfig,
      if (kinesisStreamConfig != null)
        'KinesisStreamConfig': kinesisStreamConfig,
      if (kinesisVideoStreamConfig != null)
        'KinesisVideoStreamConfig': kinesisVideoStreamConfig,
      if (s3Config != null) 'S3Config': s3Config,
    };
  }
}

enum InstanceStorageResourceType {
  chatTranscripts('CHAT_TRANSCRIPTS'),
  callRecordings('CALL_RECORDINGS'),
  scheduledReports('SCHEDULED_REPORTS'),
  mediaStreams('MEDIA_STREAMS'),
  contactTraceRecords('CONTACT_TRACE_RECORDS'),
  agentEvents('AGENT_EVENTS'),
  realTimeContactAnalysisSegments('REAL_TIME_CONTACT_ANALYSIS_SEGMENTS'),
  attachments('ATTACHMENTS'),
  contactEvaluations('CONTACT_EVALUATIONS'),
  screenRecordings('SCREEN_RECORDINGS'),
  realTimeContactAnalysisChatSegments(
      'REAL_TIME_CONTACT_ANALYSIS_CHAT_SEGMENTS'),
  realTimeContactAnalysisVoiceSegments(
      'REAL_TIME_CONTACT_ANALYSIS_VOICE_SEGMENTS'),
  ;

  final String value;

  const InstanceStorageResourceType(this.value);

  static InstanceStorageResourceType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum InstanceStorageResourceType'));
}

/// Information about the instance.
class InstanceSummary {
  /// The Amazon Resource Name (ARN) of the instance.
  final String? arn;

  /// When the instance was created.
  final DateTime? createdTime;

  /// The identifier of the instance.
  final String? id;

  /// The identity management type of the instance.
  final DirectoryType? identityManagementType;

  /// Whether inbound calls are enabled.
  final bool? inboundCallsEnabled;

  /// This URL allows contact center users to access the Amazon Connect admin
  /// website.
  final String? instanceAccessUrl;

  /// The alias of the instance.
  final String? instanceAlias;

  /// The state of the instance.
  final InstanceStatus? instanceStatus;

  /// Whether outbound calls are enabled.
  final bool? outboundCallsEnabled;

  /// The service role of the instance.
  final String? serviceRole;

  InstanceSummary({
    this.arn,
    this.createdTime,
    this.id,
    this.identityManagementType,
    this.inboundCallsEnabled,
    this.instanceAccessUrl,
    this.instanceAlias,
    this.instanceStatus,
    this.outboundCallsEnabled,
    this.serviceRole,
  });

  factory InstanceSummary.fromJson(Map<String, dynamic> json) {
    return InstanceSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      id: json['Id'] as String?,
      identityManagementType: (json['IdentityManagementType'] as String?)
          ?.let(DirectoryType.fromString),
      inboundCallsEnabled: json['InboundCallsEnabled'] as bool?,
      instanceAccessUrl: json['InstanceAccessUrl'] as String?,
      instanceAlias: json['InstanceAlias'] as String?,
      instanceStatus:
          (json['InstanceStatus'] as String?)?.let(InstanceStatus.fromString),
      outboundCallsEnabled: json['OutboundCallsEnabled'] as bool?,
      serviceRole: json['ServiceRole'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final id = this.id;
    final identityManagementType = this.identityManagementType;
    final inboundCallsEnabled = this.inboundCallsEnabled;
    final instanceAccessUrl = this.instanceAccessUrl;
    final instanceAlias = this.instanceAlias;
    final instanceStatus = this.instanceStatus;
    final outboundCallsEnabled = this.outboundCallsEnabled;
    final serviceRole = this.serviceRole;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (id != null) 'Id': id,
      if (identityManagementType != null)
        'IdentityManagementType': identityManagementType.value,
      if (inboundCallsEnabled != null)
        'InboundCallsEnabled': inboundCallsEnabled,
      if (instanceAccessUrl != null) 'InstanceAccessUrl': instanceAccessUrl,
      if (instanceAlias != null) 'InstanceAlias': instanceAlias,
      if (instanceStatus != null) 'InstanceStatus': instanceStatus.value,
      if (outboundCallsEnabled != null)
        'OutboundCallsEnabled': outboundCallsEnabled,
      if (serviceRole != null) 'ServiceRole': serviceRole,
    };
  }
}

/// Contains summary information about the associated AppIntegrations.
class IntegrationAssociationSummary {
  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? instanceId;

  /// The Amazon Resource Name (ARN) for the AppIntegration.
  final String? integrationArn;

  /// The Amazon Resource Name (ARN) for the AppIntegration association.
  final String? integrationAssociationArn;

  /// The identifier for the AppIntegration association.
  final String? integrationAssociationId;

  /// The integration type.
  final IntegrationType? integrationType;

  /// The user-provided, friendly name for the external application.
  final String? sourceApplicationName;

  /// The URL for the external application.
  final String? sourceApplicationUrl;

  /// The name of the source.
  final SourceType? sourceType;

  IntegrationAssociationSummary({
    this.instanceId,
    this.integrationArn,
    this.integrationAssociationArn,
    this.integrationAssociationId,
    this.integrationType,
    this.sourceApplicationName,
    this.sourceApplicationUrl,
    this.sourceType,
  });

  factory IntegrationAssociationSummary.fromJson(Map<String, dynamic> json) {
    return IntegrationAssociationSummary(
      instanceId: json['InstanceId'] as String?,
      integrationArn: json['IntegrationArn'] as String?,
      integrationAssociationArn: json['IntegrationAssociationArn'] as String?,
      integrationAssociationId: json['IntegrationAssociationId'] as String?,
      integrationType:
          (json['IntegrationType'] as String?)?.let(IntegrationType.fromString),
      sourceApplicationName: json['SourceApplicationName'] as String?,
      sourceApplicationUrl: json['SourceApplicationUrl'] as String?,
      sourceType: (json['SourceType'] as String?)?.let(SourceType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final instanceId = this.instanceId;
    final integrationArn = this.integrationArn;
    final integrationAssociationArn = this.integrationAssociationArn;
    final integrationAssociationId = this.integrationAssociationId;
    final integrationType = this.integrationType;
    final sourceApplicationName = this.sourceApplicationName;
    final sourceApplicationUrl = this.sourceApplicationUrl;
    final sourceType = this.sourceType;
    return {
      if (instanceId != null) 'InstanceId': instanceId,
      if (integrationArn != null) 'IntegrationArn': integrationArn,
      if (integrationAssociationArn != null)
        'IntegrationAssociationArn': integrationAssociationArn,
      if (integrationAssociationId != null)
        'IntegrationAssociationId': integrationAssociationId,
      if (integrationType != null) 'IntegrationType': integrationType.value,
      if (sourceApplicationName != null)
        'SourceApplicationName': sourceApplicationName,
      if (sourceApplicationUrl != null)
        'SourceApplicationUrl': sourceApplicationUrl,
      if (sourceType != null) 'SourceType': sourceType.value,
    };
  }
}

enum IntegrationType {
  event('EVENT'),
  voiceId('VOICE_ID'),
  pinpointApp('PINPOINT_APP'),
  wisdomAssistant('WISDOM_ASSISTANT'),
  wisdomKnowledgeBase('WISDOM_KNOWLEDGE_BASE'),
  wisdomQuickResponses('WISDOM_QUICK_RESPONSES'),
  casesDomain('CASES_DOMAIN'),
  application('APPLICATION'),
  fileScanner('FILE_SCANNER'),
  ;

  final String value;

  const IntegrationType(this.value);

  static IntegrationType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum IntegrationType'));
}

/// Information about the interval period to use for returning results.
class IntervalDetails {
  /// <code>IntervalPeriod</code>: An aggregated grouping applied to request
  /// metrics. Valid <code>IntervalPeriod</code> values are:
  /// <code>FIFTEEN_MIN</code> | <code>THIRTY_MIN</code> | <code>HOUR</code> |
  /// <code>DAY</code> | <code>WEEK</code> | <code>TOTAL</code>.
  ///
  /// For example, if <code>IntervalPeriod</code> is selected
  /// <code>THIRTY_MIN</code>, <code>StartTime</code> and <code>EndTime</code>
  /// differs by 1 day, then Amazon Connect returns 48 results in the response.
  /// Each result is aggregated by the THIRTY_MIN period. By default Amazon
  /// Connect aggregates results based on the <code>TOTAL</code> interval period.
  ///
  /// The following list describes restrictions on <code>StartTime</code> and
  /// <code>EndTime</code> based on what <code>IntervalPeriod</code> is requested.
  ///
  /// <ul>
  /// <li>
  /// <code>FIFTEEN_MIN</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 3 days.
  /// </li>
  /// <li>
  /// <code>THIRTY_MIN</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 3 days.
  /// </li>
  /// <li>
  /// <code>HOUR</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 3 days.
  /// </li>
  /// <li>
  /// <code>DAY</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 35 days.
  /// </li>
  /// <li>
  /// <code>WEEK</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 35 days.
  /// </li>
  /// <li>
  /// <code>TOTAL</code>: The difference between <code>StartTime</code> and
  /// <code>EndTime</code> must be less than 35 days.
  /// </li>
  /// </ul>
  final IntervalPeriod? intervalPeriod;

  /// The timezone applied to requested metrics.
  final String? timeZone;

  IntervalDetails({
    this.intervalPeriod,
    this.timeZone,
  });

  Map<String, dynamic> toJson() {
    final intervalPeriod = this.intervalPeriod;
    final timeZone = this.timeZone;
    return {
      if (intervalPeriod != null) 'IntervalPeriod': intervalPeriod.value,
      if (timeZone != null) 'TimeZone': timeZone,
    };
  }
}

enum IntervalPeriod {
  fifteenMin('FIFTEEN_MIN'),
  thirtyMin('THIRTY_MIN'),
  hour('HOUR'),
  day('DAY'),
  week('WEEK'),
  total('TOTAL'),
  ;

  final String value;

  const IntervalPeriod(this.value);

  static IntervalPeriod fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum IntervalPeriod'));
}

/// A field that is invisible to an agent.
class InvisibleFieldInfo {
  /// Identifier of the invisible field.
  final TaskTemplateFieldIdentifier? id;

  InvisibleFieldInfo({
    this.id,
  });

  factory InvisibleFieldInfo.fromJson(Map<String, dynamic> json) {
    return InvisibleFieldInfo(
      id: json['Id'] != null
          ? TaskTemplateFieldIdentifier.fromJson(
              json['Id'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    return {
      if (id != null) 'Id': id,
    };
  }
}

/// Configuration information of a Kinesis Data Firehose delivery stream.
class KinesisFirehoseConfig {
  /// The Amazon Resource Name (ARN) of the delivery stream.
  final String firehoseArn;

  KinesisFirehoseConfig({
    required this.firehoseArn,
  });

  factory KinesisFirehoseConfig.fromJson(Map<String, dynamic> json) {
    return KinesisFirehoseConfig(
      firehoseArn: json['FirehoseArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final firehoseArn = this.firehoseArn;
    return {
      'FirehoseArn': firehoseArn,
    };
  }
}

/// Configuration information of a Kinesis data stream.
class KinesisStreamConfig {
  /// The Amazon Resource Name (ARN) of the data stream.
  final String streamArn;

  KinesisStreamConfig({
    required this.streamArn,
  });

  factory KinesisStreamConfig.fromJson(Map<String, dynamic> json) {
    return KinesisStreamConfig(
      streamArn: json['StreamArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final streamArn = this.streamArn;
    return {
      'StreamArn': streamArn,
    };
  }
}

/// Configuration information of a Kinesis video stream.
class KinesisVideoStreamConfig {
  /// The encryption configuration.
  final EncryptionConfig encryptionConfig;

  /// The prefix of the video stream.
  final String prefix;

  /// The number of hours data is retained in the stream. Kinesis Video Streams
  /// retains the data in a data store that is associated with the stream.
  ///
  /// The default value is 0, indicating that the stream does not persist data.
  final int retentionPeriodHours;

  KinesisVideoStreamConfig({
    required this.encryptionConfig,
    required this.prefix,
    required this.retentionPeriodHours,
  });

  factory KinesisVideoStreamConfig.fromJson(Map<String, dynamic> json) {
    return KinesisVideoStreamConfig(
      encryptionConfig: EncryptionConfig.fromJson(
          json['EncryptionConfig'] as Map<String, dynamic>),
      prefix: json['Prefix'] as String,
      retentionPeriodHours: json['RetentionPeriodHours'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionConfig = this.encryptionConfig;
    final prefix = this.prefix;
    final retentionPeriodHours = this.retentionPeriodHours;
    return {
      'EncryptionConfig': encryptionConfig,
      'Prefix': prefix,
      'RetentionPeriodHours': retentionPeriodHours,
    };
  }
}

/// Configuration information of an Amazon Lex bot.
class LexBot {
  /// The Amazon Web Services Region where the Amazon Lex bot was created.
  final String lexRegion;

  /// The name of the Amazon Lex bot.
  final String name;

  LexBot({
    required this.lexRegion,
    required this.name,
  });

  factory LexBot.fromJson(Map<String, dynamic> json) {
    return LexBot(
      lexRegion: json['LexRegion'] as String,
      name: json['Name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final lexRegion = this.lexRegion;
    final name = this.name;
    return {
      'LexRegion': lexRegion,
      'Name': name,
    };
  }
}

/// Configuration information of an Amazon Lex or Amazon Lex V2 bot.
class LexBotConfig {
  final LexBot? lexBot;

  /// Configuration information of an Amazon Lex V2 bot.
  final LexV2Bot? lexV2Bot;

  LexBotConfig({
    this.lexBot,
    this.lexV2Bot,
  });

  factory LexBotConfig.fromJson(Map<String, dynamic> json) {
    return LexBotConfig(
      lexBot: json['LexBot'] != null
          ? LexBot.fromJson(json['LexBot'] as Map<String, dynamic>)
          : null,
      lexV2Bot: json['LexV2Bot'] != null
          ? LexV2Bot.fromJson(json['LexV2Bot'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final lexBot = this.lexBot;
    final lexV2Bot = this.lexV2Bot;
    return {
      if (lexBot != null) 'LexBot': lexBot,
      if (lexV2Bot != null) 'LexV2Bot': lexV2Bot,
    };
  }
}

/// Configuration information of an Amazon Lex V2 bot.
class LexV2Bot {
  /// The Amazon Resource Name (ARN) of the Amazon Lex V2 bot.
  final String? aliasArn;

  LexV2Bot({
    this.aliasArn,
  });

  factory LexV2Bot.fromJson(Map<String, dynamic> json) {
    return LexV2Bot(
      aliasArn: json['AliasArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final aliasArn = this.aliasArn;
    return {
      if (aliasArn != null) 'AliasArn': aliasArn,
    };
  }
}

enum LexVersion {
  v1('V1'),
  v2('V2'),
  ;

  final String value;

  const LexVersion(this.value);

  static LexVersion fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum LexVersion'));
}

class ListAgentStatusResponse {
  /// A summary of agent statuses.
  final List<AgentStatusSummary>? agentStatusSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListAgentStatusResponse({
    this.agentStatusSummaryList,
    this.nextToken,
  });

  factory ListAgentStatusResponse.fromJson(Map<String, dynamic> json) {
    return ListAgentStatusResponse(
      agentStatusSummaryList: (json['AgentStatusSummaryList'] as List?)
          ?.nonNulls
          .map((e) => AgentStatusSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final agentStatusSummaryList = this.agentStatusSummaryList;
    final nextToken = this.nextToken;
    return {
      if (agentStatusSummaryList != null)
        'AgentStatusSummaryList': agentStatusSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListAnalyticsDataAssociationsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// An array of successful results: <code>DataSetId</code>,
  /// <code>TargetAccountId</code>, <code>ResourceShareId</code>,
  /// <code>ResourceShareArn</code>. This is a paginated API, so
  /// <code>nextToken</code> is given if there are more results to be returned.
  final List<AnalyticsDataAssociationResult>? results;

  ListAnalyticsDataAssociationsResponse({
    this.nextToken,
    this.results,
  });

  factory ListAnalyticsDataAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListAnalyticsDataAssociationsResponse(
      nextToken: json['NextToken'] as String?,
      results: (json['Results'] as List?)
          ?.nonNulls
          .map((e) => AnalyticsDataAssociationResult.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final results = this.results;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (results != null) 'Results': results,
    };
  }
}

class ListApprovedOriginsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// The approved origins.
  final List<String>? origins;

  ListApprovedOriginsResponse({
    this.nextToken,
    this.origins,
  });

  factory ListApprovedOriginsResponse.fromJson(Map<String, dynamic> json) {
    return ListApprovedOriginsResponse(
      nextToken: json['NextToken'] as String?,
      origins:
          (json['Origins'] as List?)?.nonNulls.map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final origins = this.origins;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (origins != null) 'Origins': origins,
    };
  }
}

class ListBotsResponse {
  /// The names and Amazon Web Services Regions of the Amazon Lex or Amazon Lex V2
  /// bots associated with the specified instance.
  final List<LexBotConfig>? lexBots;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListBotsResponse({
    this.lexBots,
    this.nextToken,
  });

  factory ListBotsResponse.fromJson(Map<String, dynamic> json) {
    return ListBotsResponse(
      lexBots: (json['LexBots'] as List?)
          ?.nonNulls
          .map((e) => LexBotConfig.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lexBots = this.lexBots;
    final nextToken = this.nextToken;
    return {
      if (lexBots != null) 'LexBots': lexBots,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListContactEvaluationsResponse {
  /// Provides details about a list of contact evaluations belonging to an
  /// instance.
  final List<EvaluationSummary> evaluationSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  /// <important>
  /// This is always returned as null in the response.
  /// </important>
  final String? nextToken;

  ListContactEvaluationsResponse({
    required this.evaluationSummaryList,
    this.nextToken,
  });

  factory ListContactEvaluationsResponse.fromJson(Map<String, dynamic> json) {
    return ListContactEvaluationsResponse(
      evaluationSummaryList: (json['EvaluationSummaryList'] as List)
          .nonNulls
          .map((e) => EvaluationSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationSummaryList = this.evaluationSummaryList;
    final nextToken = this.nextToken;
    return {
      'EvaluationSummaryList': evaluationSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListContactFlowModulesResponse {
  /// Information about the flow module.
  final List<ContactFlowModuleSummary>? contactFlowModulesSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListContactFlowModulesResponse({
    this.contactFlowModulesSummaryList,
    this.nextToken,
  });

  factory ListContactFlowModulesResponse.fromJson(Map<String, dynamic> json) {
    return ListContactFlowModulesResponse(
      contactFlowModulesSummaryList:
          (json['ContactFlowModulesSummaryList'] as List?)
              ?.nonNulls
              .map((e) =>
                  ContactFlowModuleSummary.fromJson(e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowModulesSummaryList = this.contactFlowModulesSummaryList;
    final nextToken = this.nextToken;
    return {
      if (contactFlowModulesSummaryList != null)
        'ContactFlowModulesSummaryList': contactFlowModulesSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListContactFlowsResponse {
  /// Information about the flows.
  final List<ContactFlowSummary>? contactFlowSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListContactFlowsResponse({
    this.contactFlowSummaryList,
    this.nextToken,
  });

  factory ListContactFlowsResponse.fromJson(Map<String, dynamic> json) {
    return ListContactFlowsResponse(
      contactFlowSummaryList: (json['ContactFlowSummaryList'] as List?)
          ?.nonNulls
          .map((e) => ContactFlowSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowSummaryList = this.contactFlowSummaryList;
    final nextToken = this.nextToken;
    return {
      if (contactFlowSummaryList != null)
        'ContactFlowSummaryList': contactFlowSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListContactReferencesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  /// <important>
  /// This is always returned as null in the response.
  /// </important>
  final String? nextToken;

  /// Information about the flows.
  final List<ReferenceSummary>? referenceSummaryList;

  ListContactReferencesResponse({
    this.nextToken,
    this.referenceSummaryList,
  });

  factory ListContactReferencesResponse.fromJson(Map<String, dynamic> json) {
    return ListContactReferencesResponse(
      nextToken: json['NextToken'] as String?,
      referenceSummaryList: (json['ReferenceSummaryList'] as List?)
          ?.nonNulls
          .map((e) => ReferenceSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final referenceSummaryList = this.referenceSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (referenceSummaryList != null)
        'ReferenceSummaryList': referenceSummaryList,
    };
  }
}

class ListDefaultVocabulariesResponse {
  /// A list of default vocabularies.
  final List<DefaultVocabulary> defaultVocabularyList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListDefaultVocabulariesResponse({
    required this.defaultVocabularyList,
    this.nextToken,
  });

  factory ListDefaultVocabulariesResponse.fromJson(Map<String, dynamic> json) {
    return ListDefaultVocabulariesResponse(
      defaultVocabularyList: (json['DefaultVocabularyList'] as List)
          .nonNulls
          .map((e) => DefaultVocabulary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultVocabularyList = this.defaultVocabularyList;
    final nextToken = this.nextToken;
    return {
      'DefaultVocabularyList': defaultVocabularyList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListEvaluationFormVersionsResponse {
  /// Provides details about a list of evaluation forms belonging to an instance.
  final List<EvaluationFormVersionSummary> evaluationFormVersionSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListEvaluationFormVersionsResponse({
    required this.evaluationFormVersionSummaryList,
    this.nextToken,
  });

  factory ListEvaluationFormVersionsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListEvaluationFormVersionsResponse(
      evaluationFormVersionSummaryList:
          (json['EvaluationFormVersionSummaryList'] as List)
              .nonNulls
              .map((e) => EvaluationFormVersionSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormVersionSummaryList =
        this.evaluationFormVersionSummaryList;
    final nextToken = this.nextToken;
    return {
      'EvaluationFormVersionSummaryList': evaluationFormVersionSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListEvaluationFormsResponse {
  /// Provides details about a list of evaluation forms belonging to an instance.
  final List<EvaluationFormSummary> evaluationFormSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListEvaluationFormsResponse({
    required this.evaluationFormSummaryList,
    this.nextToken,
  });

  factory ListEvaluationFormsResponse.fromJson(Map<String, dynamic> json) {
    return ListEvaluationFormsResponse(
      evaluationFormSummaryList: (json['EvaluationFormSummaryList'] as List)
          .nonNulls
          .map((e) => EvaluationFormSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormSummaryList = this.evaluationFormSummaryList;
    final nextToken = this.nextToken;
    return {
      'EvaluationFormSummaryList': evaluationFormSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

enum ListFlowAssociationResourceType {
  voicePhoneNumber('VOICE_PHONE_NUMBER'),
  ;

  final String value;

  const ListFlowAssociationResourceType(this.value);

  static ListFlowAssociationResourceType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ListFlowAssociationResourceType'));
}

class ListFlowAssociationsResponse {
  /// Summary of flow associations.
  final List<FlowAssociationSummary>? flowAssociationSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListFlowAssociationsResponse({
    this.flowAssociationSummaryList,
    this.nextToken,
  });

  factory ListFlowAssociationsResponse.fromJson(Map<String, dynamic> json) {
    return ListFlowAssociationsResponse(
      flowAssociationSummaryList: (json['FlowAssociationSummaryList'] as List?)
          ?.nonNulls
          .map(
              (e) => FlowAssociationSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final flowAssociationSummaryList = this.flowAssociationSummaryList;
    final nextToken = this.nextToken;
    return {
      if (flowAssociationSummaryList != null)
        'FlowAssociationSummaryList': flowAssociationSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListHoursOfOperationsResponse {
  /// Information about the hours of operation.
  final List<HoursOfOperationSummary>? hoursOfOperationSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListHoursOfOperationsResponse({
    this.hoursOfOperationSummaryList,
    this.nextToken,
  });

  factory ListHoursOfOperationsResponse.fromJson(Map<String, dynamic> json) {
    return ListHoursOfOperationsResponse(
      hoursOfOperationSummaryList:
          (json['HoursOfOperationSummaryList'] as List?)
              ?.nonNulls
              .map((e) =>
                  HoursOfOperationSummary.fromJson(e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hoursOfOperationSummaryList = this.hoursOfOperationSummaryList;
    final nextToken = this.nextToken;
    return {
      if (hoursOfOperationSummaryList != null)
        'HoursOfOperationSummaryList': hoursOfOperationSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListInstanceAttributesResponse {
  /// The attribute types.
  final List<Attribute>? attributes;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListInstanceAttributesResponse({
    this.attributes,
    this.nextToken,
  });

  factory ListInstanceAttributesResponse.fromJson(Map<String, dynamic> json) {
    return ListInstanceAttributesResponse(
      attributes: (json['Attributes'] as List?)
          ?.nonNulls
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attributes = this.attributes;
    final nextToken = this.nextToken;
    return {
      if (attributes != null) 'Attributes': attributes,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListInstanceStorageConfigsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// A valid storage type.
  final List<InstanceStorageConfig>? storageConfigs;

  ListInstanceStorageConfigsResponse({
    this.nextToken,
    this.storageConfigs,
  });

  factory ListInstanceStorageConfigsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListInstanceStorageConfigsResponse(
      nextToken: json['NextToken'] as String?,
      storageConfigs: (json['StorageConfigs'] as List?)
          ?.nonNulls
          .map((e) => InstanceStorageConfig.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final storageConfigs = this.storageConfigs;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (storageConfigs != null) 'StorageConfigs': storageConfigs,
    };
  }
}

class ListInstancesResponse {
  /// Information about the instances.
  final List<InstanceSummary>? instanceSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListInstancesResponse({
    this.instanceSummaryList,
    this.nextToken,
  });

  factory ListInstancesResponse.fromJson(Map<String, dynamic> json) {
    return ListInstancesResponse(
      instanceSummaryList: (json['InstanceSummaryList'] as List?)
          ?.nonNulls
          .map((e) => InstanceSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final instanceSummaryList = this.instanceSummaryList;
    final nextToken = this.nextToken;
    return {
      if (instanceSummaryList != null)
        'InstanceSummaryList': instanceSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListIntegrationAssociationsResponse {
  /// The associations.
  final List<IntegrationAssociationSummary>? integrationAssociationSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListIntegrationAssociationsResponse({
    this.integrationAssociationSummaryList,
    this.nextToken,
  });

  factory ListIntegrationAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListIntegrationAssociationsResponse(
      integrationAssociationSummaryList:
          (json['IntegrationAssociationSummaryList'] as List?)
              ?.nonNulls
              .map((e) => IntegrationAssociationSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final integrationAssociationSummaryList =
        this.integrationAssociationSummaryList;
    final nextToken = this.nextToken;
    return {
      if (integrationAssociationSummaryList != null)
        'IntegrationAssociationSummaryList': integrationAssociationSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListLambdaFunctionsResponse {
  /// The Lambdafunction ARNs associated with the specified instance.
  final List<String>? lambdaFunctions;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListLambdaFunctionsResponse({
    this.lambdaFunctions,
    this.nextToken,
  });

  factory ListLambdaFunctionsResponse.fromJson(Map<String, dynamic> json) {
    return ListLambdaFunctionsResponse(
      lambdaFunctions: (json['LambdaFunctions'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lambdaFunctions = this.lambdaFunctions;
    final nextToken = this.nextToken;
    return {
      if (lambdaFunctions != null) 'LambdaFunctions': lambdaFunctions,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListLexBotsResponse {
  /// The names and Amazon Web Services Regions of the Amazon Lex bots associated
  /// with the specified instance.
  final List<LexBot>? lexBots;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListLexBotsResponse({
    this.lexBots,
    this.nextToken,
  });

  factory ListLexBotsResponse.fromJson(Map<String, dynamic> json) {
    return ListLexBotsResponse(
      lexBots: (json['LexBots'] as List?)
          ?.nonNulls
          .map((e) => LexBot.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lexBots = this.lexBots;
    final nextToken = this.nextToken;
    return {
      if (lexBots != null) 'LexBots': lexBots,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListPhoneNumbersResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the phone numbers.
  final List<PhoneNumberSummary>? phoneNumberSummaryList;

  ListPhoneNumbersResponse({
    this.nextToken,
    this.phoneNumberSummaryList,
  });

  factory ListPhoneNumbersResponse.fromJson(Map<String, dynamic> json) {
    return ListPhoneNumbersResponse(
      nextToken: json['NextToken'] as String?,
      phoneNumberSummaryList: (json['PhoneNumberSummaryList'] as List?)
          ?.nonNulls
          .map((e) => PhoneNumberSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final phoneNumberSummaryList = this.phoneNumberSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (phoneNumberSummaryList != null)
        'PhoneNumberSummaryList': phoneNumberSummaryList,
    };
  }
}

/// Information about phone numbers that have been claimed to your Amazon
/// Connect instance or traffic distribution group.
class ListPhoneNumbersSummary {
  /// The identifier of the Amazon Connect instance that phone numbers are claimed
  /// to. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? instanceId;

  /// The phone number. Phone numbers are formatted <code>[+] [country code]
  /// [subscriber number including area code]</code>.
  final String? phoneNumber;

  /// The Amazon Resource Name (ARN) of the phone number.
  final String? phoneNumberArn;

  /// The ISO country code.
  final PhoneNumberCountryCode? phoneNumberCountryCode;

  /// The description of the phone number.
  final String? phoneNumberDescription;

  /// A unique identifier for the phone number.
  final String? phoneNumberId;

  /// The type of phone number.
  final PhoneNumberType? phoneNumberType;

  /// The claimed phone number ARN that was previously imported from the external
  /// service, such as Amazon Pinpoint. If it is from Amazon Pinpoint, it looks
  /// like the ARN of the phone number that was imported from Amazon Pinpoint.
  final String? sourcePhoneNumberArn;

  /// The Amazon Resource Name (ARN) for Amazon Connect instances or traffic
  /// distribution groups that phone number inbound traffic is routed through.
  final String? targetArn;

  ListPhoneNumbersSummary({
    this.instanceId,
    this.phoneNumber,
    this.phoneNumberArn,
    this.phoneNumberCountryCode,
    this.phoneNumberDescription,
    this.phoneNumberId,
    this.phoneNumberType,
    this.sourcePhoneNumberArn,
    this.targetArn,
  });

  factory ListPhoneNumbersSummary.fromJson(Map<String, dynamic> json) {
    return ListPhoneNumbersSummary(
      instanceId: json['InstanceId'] as String?,
      phoneNumber: json['PhoneNumber'] as String?,
      phoneNumberArn: json['PhoneNumberArn'] as String?,
      phoneNumberCountryCode: (json['PhoneNumberCountryCode'] as String?)
          ?.let(PhoneNumberCountryCode.fromString),
      phoneNumberDescription: json['PhoneNumberDescription'] as String?,
      phoneNumberId: json['PhoneNumberId'] as String?,
      phoneNumberType:
          (json['PhoneNumberType'] as String?)?.let(PhoneNumberType.fromString),
      sourcePhoneNumberArn: json['SourcePhoneNumberArn'] as String?,
      targetArn: json['TargetArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final instanceId = this.instanceId;
    final phoneNumber = this.phoneNumber;
    final phoneNumberArn = this.phoneNumberArn;
    final phoneNumberCountryCode = this.phoneNumberCountryCode;
    final phoneNumberDescription = this.phoneNumberDescription;
    final phoneNumberId = this.phoneNumberId;
    final phoneNumberType = this.phoneNumberType;
    final sourcePhoneNumberArn = this.sourcePhoneNumberArn;
    final targetArn = this.targetArn;
    return {
      if (instanceId != null) 'InstanceId': instanceId,
      if (phoneNumber != null) 'PhoneNumber': phoneNumber,
      if (phoneNumberArn != null) 'PhoneNumberArn': phoneNumberArn,
      if (phoneNumberCountryCode != null)
        'PhoneNumberCountryCode': phoneNumberCountryCode.value,
      if (phoneNumberDescription != null)
        'PhoneNumberDescription': phoneNumberDescription,
      if (phoneNumberId != null) 'PhoneNumberId': phoneNumberId,
      if (phoneNumberType != null) 'PhoneNumberType': phoneNumberType.value,
      if (sourcePhoneNumberArn != null)
        'SourcePhoneNumberArn': sourcePhoneNumberArn,
      if (targetArn != null) 'TargetArn': targetArn,
    };
  }
}

class ListPhoneNumbersV2Response {
  /// Information about phone numbers that have been claimed to your Amazon
  /// Connect instances or traffic distribution groups.
  final List<ListPhoneNumbersSummary>? listPhoneNumbersSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListPhoneNumbersV2Response({
    this.listPhoneNumbersSummaryList,
    this.nextToken,
  });

  factory ListPhoneNumbersV2Response.fromJson(Map<String, dynamic> json) {
    return ListPhoneNumbersV2Response(
      listPhoneNumbersSummaryList:
          (json['ListPhoneNumbersSummaryList'] as List?)
              ?.nonNulls
              .map((e) =>
                  ListPhoneNumbersSummary.fromJson(e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final listPhoneNumbersSummaryList = this.listPhoneNumbersSummaryList;
    final nextToken = this.nextToken;
    return {
      if (listPhoneNumbersSummaryList != null)
        'ListPhoneNumbersSummaryList': listPhoneNumbersSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListPredefinedAttributesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Summary of the predefined attributes.
  final List<PredefinedAttributeSummary>? predefinedAttributeSummaryList;

  ListPredefinedAttributesResponse({
    this.nextToken,
    this.predefinedAttributeSummaryList,
  });

  factory ListPredefinedAttributesResponse.fromJson(Map<String, dynamic> json) {
    return ListPredefinedAttributesResponse(
      nextToken: json['NextToken'] as String?,
      predefinedAttributeSummaryList: (json['PredefinedAttributeSummaryList']
              as List?)
          ?.nonNulls
          .map((e) =>
              PredefinedAttributeSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final predefinedAttributeSummaryList = this.predefinedAttributeSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (predefinedAttributeSummaryList != null)
        'PredefinedAttributeSummaryList': predefinedAttributeSummaryList,
    };
  }
}

class ListPromptsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the prompts.
  final List<PromptSummary>? promptSummaryList;

  ListPromptsResponse({
    this.nextToken,
    this.promptSummaryList,
  });

  factory ListPromptsResponse.fromJson(Map<String, dynamic> json) {
    return ListPromptsResponse(
      nextToken: json['NextToken'] as String?,
      promptSummaryList: (json['PromptSummaryList'] as List?)
          ?.nonNulls
          .map((e) => PromptSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final promptSummaryList = this.promptSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (promptSummaryList != null) 'PromptSummaryList': promptSummaryList,
    };
  }
}

class ListQueueQuickConnectsResponse {
  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the quick connects.
  final List<QuickConnectSummary>? quickConnectSummaryList;

  ListQueueQuickConnectsResponse({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.nextToken,
    this.quickConnectSummaryList,
  });

  factory ListQueueQuickConnectsResponse.fromJson(Map<String, dynamic> json) {
    return ListQueueQuickConnectsResponse(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      nextToken: json['NextToken'] as String?,
      quickConnectSummaryList: (json['QuickConnectSummaryList'] as List?)
          ?.nonNulls
          .map((e) => QuickConnectSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final nextToken = this.nextToken;
    final quickConnectSummaryList = this.quickConnectSummaryList;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (nextToken != null) 'NextToken': nextToken,
      if (quickConnectSummaryList != null)
        'QuickConnectSummaryList': quickConnectSummaryList,
    };
  }
}

class ListQueuesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the queues.
  final List<QueueSummary>? queueSummaryList;

  ListQueuesResponse({
    this.nextToken,
    this.queueSummaryList,
  });

  factory ListQueuesResponse.fromJson(Map<String, dynamic> json) {
    return ListQueuesResponse(
      nextToken: json['NextToken'] as String?,
      queueSummaryList: (json['QueueSummaryList'] as List?)
          ?.nonNulls
          .map((e) => QueueSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final queueSummaryList = this.queueSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (queueSummaryList != null) 'QueueSummaryList': queueSummaryList,
    };
  }
}

class ListQuickConnectsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the quick connects.
  final List<QuickConnectSummary>? quickConnectSummaryList;

  ListQuickConnectsResponse({
    this.nextToken,
    this.quickConnectSummaryList,
  });

  factory ListQuickConnectsResponse.fromJson(Map<String, dynamic> json) {
    return ListQuickConnectsResponse(
      nextToken: json['NextToken'] as String?,
      quickConnectSummaryList: (json['QuickConnectSummaryList'] as List?)
          ?.nonNulls
          .map((e) => QuickConnectSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final quickConnectSummaryList = this.quickConnectSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (quickConnectSummaryList != null)
        'QuickConnectSummaryList': quickConnectSummaryList,
    };
  }
}

class ListRealtimeContactAnalysisSegmentsV2Response {
  /// The channel of the contact. <code>Voice</code> will not be returned.
  final RealTimeContactAnalysisSupportedChannel channel;

  /// An analyzed transcript or category.
  final List<RealtimeContactAnalysisSegment> segments;

  /// Status of real-time contact analysis.
  final RealTimeContactAnalysisStatus status;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListRealtimeContactAnalysisSegmentsV2Response({
    required this.channel,
    required this.segments,
    required this.status,
    this.nextToken,
  });

  factory ListRealtimeContactAnalysisSegmentsV2Response.fromJson(
      Map<String, dynamic> json) {
    return ListRealtimeContactAnalysisSegmentsV2Response(
      channel: RealTimeContactAnalysisSupportedChannel.fromString(
          (json['Channel'] as String)),
      segments: (json['Segments'] as List)
          .nonNulls
          .map((e) => RealtimeContactAnalysisSegment.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      status:
          RealTimeContactAnalysisStatus.fromString((json['Status'] as String)),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final channel = this.channel;
    final segments = this.segments;
    final status = this.status;
    final nextToken = this.nextToken;
    return {
      'Channel': channel.value,
      'Segments': segments,
      'Status': status.value,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListRoutingProfileQueuesResponse {
  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the routing profiles.
  final List<RoutingProfileQueueConfigSummary>?
      routingProfileQueueConfigSummaryList;

  ListRoutingProfileQueuesResponse({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.nextToken,
    this.routingProfileQueueConfigSummaryList,
  });

  factory ListRoutingProfileQueuesResponse.fromJson(Map<String, dynamic> json) {
    return ListRoutingProfileQueuesResponse(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      nextToken: json['NextToken'] as String?,
      routingProfileQueueConfigSummaryList:
          (json['RoutingProfileQueueConfigSummaryList'] as List?)
              ?.nonNulls
              .map((e) => RoutingProfileQueueConfigSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final nextToken = this.nextToken;
    final routingProfileQueueConfigSummaryList =
        this.routingProfileQueueConfigSummaryList;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (nextToken != null) 'NextToken': nextToken,
      if (routingProfileQueueConfigSummaryList != null)
        'RoutingProfileQueueConfigSummaryList':
            routingProfileQueueConfigSummaryList,
    };
  }
}

class ListRoutingProfilesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the routing profiles.
  final List<RoutingProfileSummary>? routingProfileSummaryList;

  ListRoutingProfilesResponse({
    this.nextToken,
    this.routingProfileSummaryList,
  });

  factory ListRoutingProfilesResponse.fromJson(Map<String, dynamic> json) {
    return ListRoutingProfilesResponse(
      nextToken: json['NextToken'] as String?,
      routingProfileSummaryList: (json['RoutingProfileSummaryList'] as List?)
          ?.nonNulls
          .map((e) => RoutingProfileSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final routingProfileSummaryList = this.routingProfileSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (routingProfileSummaryList != null)
        'RoutingProfileSummaryList': routingProfileSummaryList,
    };
  }
}

class ListRulesResponse {
  /// Summary information about a rule.
  final List<RuleSummary> ruleSummaryList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListRulesResponse({
    required this.ruleSummaryList,
    this.nextToken,
  });

  factory ListRulesResponse.fromJson(Map<String, dynamic> json) {
    return ListRulesResponse(
      ruleSummaryList: (json['RuleSummaryList'] as List)
          .nonNulls
          .map((e) => RuleSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ruleSummaryList = this.ruleSummaryList;
    final nextToken = this.nextToken;
    return {
      'RuleSummaryList': ruleSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListSecurityKeysResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// The security keys.
  final List<SecurityKey>? securityKeys;

  ListSecurityKeysResponse({
    this.nextToken,
    this.securityKeys,
  });

  factory ListSecurityKeysResponse.fromJson(Map<String, dynamic> json) {
    return ListSecurityKeysResponse(
      nextToken: json['NextToken'] as String?,
      securityKeys: (json['SecurityKeys'] as List?)
          ?.nonNulls
          .map((e) => SecurityKey.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final securityKeys = this.securityKeys;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (securityKeys != null) 'SecurityKeys': securityKeys,
    };
  }
}

class ListSecurityProfileApplicationsResponse {
  /// A list of the third-party application's metadata.
  final List<Application>? applications;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  ListSecurityProfileApplicationsResponse({
    this.applications,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.nextToken,
  });

  factory ListSecurityProfileApplicationsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListSecurityProfileApplicationsResponse(
      applications: (json['Applications'] as List?)
          ?.nonNulls
          .map((e) => Application.fromJson(e as Map<String, dynamic>))
          .toList(),
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final applications = this.applications;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final nextToken = this.nextToken;
    return {
      if (applications != null) 'Applications': applications,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListSecurityProfilePermissionsResponse {
  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// The permissions granted to the security profile. For a complete list of
  /// valid permissions, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/security-profile-list.html">List
  /// of security profile permissions</a>.
  final List<String>? permissions;

  ListSecurityProfilePermissionsResponse({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.nextToken,
    this.permissions,
  });

  factory ListSecurityProfilePermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListSecurityProfilePermissionsResponse(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      nextToken: json['NextToken'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final nextToken = this.nextToken;
    final permissions = this.permissions;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (nextToken != null) 'NextToken': nextToken,
      if (permissions != null) 'Permissions': permissions,
    };
  }
}

class ListSecurityProfilesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the security profiles.
  final List<SecurityProfileSummary>? securityProfileSummaryList;

  ListSecurityProfilesResponse({
    this.nextToken,
    this.securityProfileSummaryList,
  });

  factory ListSecurityProfilesResponse.fromJson(Map<String, dynamic> json) {
    return ListSecurityProfilesResponse(
      nextToken: json['NextToken'] as String?,
      securityProfileSummaryList: (json['SecurityProfileSummaryList'] as List?)
          ?.nonNulls
          .map(
              (e) => SecurityProfileSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final securityProfileSummaryList = this.securityProfileSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (securityProfileSummaryList != null)
        'SecurityProfileSummaryList': securityProfileSummaryList,
    };
  }
}

class ListTagsForResourceResponse {
  /// Information about the tags.
  final Map<String, String>? tags;

  ListTagsForResourceResponse({
    this.tags,
  });

  factory ListTagsForResourceResponse.fromJson(Map<String, dynamic> json) {
    return ListTagsForResourceResponse(
      tags: (json['tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final tags = this.tags;
    return {
      if (tags != null) 'tags': tags,
    };
  }
}

class ListTaskTemplatesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  /// <important>
  /// This is always returned as a null in the response.
  /// </important>
  final String? nextToken;

  /// Provides details about a list of task templates belonging to an instance.
  final List<TaskTemplateMetadata>? taskTemplates;

  ListTaskTemplatesResponse({
    this.nextToken,
    this.taskTemplates,
  });

  factory ListTaskTemplatesResponse.fromJson(Map<String, dynamic> json) {
    return ListTaskTemplatesResponse(
      nextToken: json['NextToken'] as String?,
      taskTemplates: (json['TaskTemplates'] as List?)
          ?.nonNulls
          .map((e) => TaskTemplateMetadata.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final taskTemplates = this.taskTemplates;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (taskTemplates != null) 'TaskTemplates': taskTemplates,
    };
  }
}

class ListTrafficDistributionGroupUsersResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// A list of traffic distribution group users.
  final List<TrafficDistributionGroupUserSummary>?
      trafficDistributionGroupUserSummaryList;

  ListTrafficDistributionGroupUsersResponse({
    this.nextToken,
    this.trafficDistributionGroupUserSummaryList,
  });

  factory ListTrafficDistributionGroupUsersResponse.fromJson(
      Map<String, dynamic> json) {
    return ListTrafficDistributionGroupUsersResponse(
      nextToken: json['NextToken'] as String?,
      trafficDistributionGroupUserSummaryList:
          (json['TrafficDistributionGroupUserSummaryList'] as List?)
              ?.nonNulls
              .map((e) => TrafficDistributionGroupUserSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final trafficDistributionGroupUserSummaryList =
        this.trafficDistributionGroupUserSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (trafficDistributionGroupUserSummaryList != null)
        'TrafficDistributionGroupUserSummaryList':
            trafficDistributionGroupUserSummaryList,
    };
  }
}

class ListTrafficDistributionGroupsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// A list of traffic distribution groups.
  final List<TrafficDistributionGroupSummary>?
      trafficDistributionGroupSummaryList;

  ListTrafficDistributionGroupsResponse({
    this.nextToken,
    this.trafficDistributionGroupSummaryList,
  });

  factory ListTrafficDistributionGroupsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListTrafficDistributionGroupsResponse(
      nextToken: json['NextToken'] as String?,
      trafficDistributionGroupSummaryList:
          (json['TrafficDistributionGroupSummaryList'] as List?)
              ?.nonNulls
              .map((e) => TrafficDistributionGroupSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final trafficDistributionGroupSummaryList =
        this.trafficDistributionGroupSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (trafficDistributionGroupSummaryList != null)
        'TrafficDistributionGroupSummaryList':
            trafficDistributionGroupSummaryList,
    };
  }
}

class ListUseCasesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// The use cases.
  final List<UseCase>? useCaseSummaryList;

  ListUseCasesResponse({
    this.nextToken,
    this.useCaseSummaryList,
  });

  factory ListUseCasesResponse.fromJson(Map<String, dynamic> json) {
    return ListUseCasesResponse(
      nextToken: json['NextToken'] as String?,
      useCaseSummaryList: (json['UseCaseSummaryList'] as List?)
          ?.nonNulls
          .map((e) => UseCase.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final useCaseSummaryList = this.useCaseSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (useCaseSummaryList != null) 'UseCaseSummaryList': useCaseSummaryList,
    };
  }
}

class ListUserHierarchyGroupsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the hierarchy groups.
  final List<HierarchyGroupSummary>? userHierarchyGroupSummaryList;

  ListUserHierarchyGroupsResponse({
    this.nextToken,
    this.userHierarchyGroupSummaryList,
  });

  factory ListUserHierarchyGroupsResponse.fromJson(Map<String, dynamic> json) {
    return ListUserHierarchyGroupsResponse(
      nextToken: json['NextToken'] as String?,
      userHierarchyGroupSummaryList: (json['UserHierarchyGroupSummaryList']
              as List?)
          ?.nonNulls
          .map((e) => HierarchyGroupSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final userHierarchyGroupSummaryList = this.userHierarchyGroupSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (userHierarchyGroupSummaryList != null)
        'UserHierarchyGroupSummaryList': userHierarchyGroupSummaryList,
    };
  }
}

class ListUserProficienciesResponse {
  /// The region in which a user's proficiencies were last modified.
  final String? lastModifiedRegion;

  /// The last time that the user's proficiencies are were modified.
  final DateTime? lastModifiedTime;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the user proficiencies.
  final List<UserProficiency>? userProficiencyList;

  ListUserProficienciesResponse({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.nextToken,
    this.userProficiencyList,
  });

  factory ListUserProficienciesResponse.fromJson(Map<String, dynamic> json) {
    return ListUserProficienciesResponse(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      nextToken: json['NextToken'] as String?,
      userProficiencyList: (json['UserProficiencyList'] as List?)
          ?.nonNulls
          .map((e) => UserProficiency.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final nextToken = this.nextToken;
    final userProficiencyList = this.userProficiencyList;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (nextToken != null) 'NextToken': nextToken,
      if (userProficiencyList != null)
        'UserProficiencyList': userProficiencyList,
    };
  }
}

class ListUsersResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the users.
  final List<UserSummary>? userSummaryList;

  ListUsersResponse({
    this.nextToken,
    this.userSummaryList,
  });

  factory ListUsersResponse.fromJson(Map<String, dynamic> json) {
    return ListUsersResponse(
      nextToken: json['NextToken'] as String?,
      userSummaryList: (json['UserSummaryList'] as List?)
          ?.nonNulls
          .map((e) => UserSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final userSummaryList = this.userSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (userSummaryList != null) 'UserSummaryList': userSummaryList,
    };
  }
}

class ListViewVersionsResponse {
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  final String? nextToken;

  /// A list of view version summaries.
  final List<ViewVersionSummary>? viewVersionSummaryList;

  ListViewVersionsResponse({
    this.nextToken,
    this.viewVersionSummaryList,
  });

  factory ListViewVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListViewVersionsResponse(
      nextToken: json['NextToken'] as String?,
      viewVersionSummaryList: (json['ViewVersionSummaryList'] as List?)
          ?.nonNulls
          .map((e) => ViewVersionSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final viewVersionSummaryList = this.viewVersionSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (viewVersionSummaryList != null)
        'ViewVersionSummaryList': viewVersionSummaryList,
    };
  }
}

class ListViewsResponse {
  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  final String? nextToken;

  /// A list of view summaries.
  final List<ViewSummary>? viewsSummaryList;

  ListViewsResponse({
    this.nextToken,
    this.viewsSummaryList,
  });

  factory ListViewsResponse.fromJson(Map<String, dynamic> json) {
    return ListViewsResponse(
      nextToken: json['NextToken'] as String?,
      viewsSummaryList: (json['ViewsSummaryList'] as List?)
          ?.nonNulls
          .map((e) => ViewSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final viewsSummaryList = this.viewsSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (viewsSummaryList != null) 'ViewsSummaryList': viewsSummaryList,
    };
  }
}

/// Contains information about which channels are supported, and how many
/// contacts an agent can have on a channel simultaneously.
class MediaConcurrency {
  /// The channels that agents can handle in the Contact Control Panel (CCP).
  final Channel channel;

  /// The number of contacts an agent can have on a channel simultaneously.
  ///
  /// Valid Range for <code>VOICE</code>: Minimum value of 1. Maximum value of 1.
  ///
  /// Valid Range for <code>CHAT</code>: Minimum value of 1. Maximum value of 10.
  ///
  /// Valid Range for <code>TASK</code>: Minimum value of 1. Maximum value of 10.
  final int concurrency;

  /// Defines the cross-channel routing behavior for each channel that is enabled
  /// for this Routing Profile. For example, this allows you to offer an agent a
  /// different contact from another channel when they are currently working with
  /// a contact from a Voice channel.
  final CrossChannelBehavior? crossChannelBehavior;

  MediaConcurrency({
    required this.channel,
    required this.concurrency,
    this.crossChannelBehavior,
  });

  factory MediaConcurrency.fromJson(Map<String, dynamic> json) {
    return MediaConcurrency(
      channel: Channel.fromString((json['Channel'] as String)),
      concurrency: json['Concurrency'] as int,
      crossChannelBehavior: json['CrossChannelBehavior'] != null
          ? CrossChannelBehavior.fromJson(
              json['CrossChannelBehavior'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final channel = this.channel;
    final concurrency = this.concurrency;
    final crossChannelBehavior = this.crossChannelBehavior;
    return {
      'Channel': channel.value,
      'Concurrency': concurrency,
      if (crossChannelBehavior != null)
        'CrossChannelBehavior': crossChannelBehavior,
    };
  }
}

/// A set of endpoints used by clients to connect to the media service group for
/// an Amazon Chime SDK meeting.
class MediaPlacement {
  /// The audio fallback URL.
  final String? audioFallbackUrl;

  /// The audio host URL.
  final String? audioHostUrl;

  /// The event ingestion URL to which you send client meeting events.
  final String? eventIngestionUrl;

  /// The signaling URL.
  final String? signalingUrl;

  /// The turn control URL.
  final String? turnControlUrl;

  MediaPlacement({
    this.audioFallbackUrl,
    this.audioHostUrl,
    this.eventIngestionUrl,
    this.signalingUrl,
    this.turnControlUrl,
  });

  factory MediaPlacement.fromJson(Map<String, dynamic> json) {
    return MediaPlacement(
      audioFallbackUrl: json['AudioFallbackUrl'] as String?,
      audioHostUrl: json['AudioHostUrl'] as String?,
      eventIngestionUrl: json['EventIngestionUrl'] as String?,
      signalingUrl: json['SignalingUrl'] as String?,
      turnControlUrl: json['TurnControlUrl'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final audioFallbackUrl = this.audioFallbackUrl;
    final audioHostUrl = this.audioHostUrl;
    final eventIngestionUrl = this.eventIngestionUrl;
    final signalingUrl = this.signalingUrl;
    final turnControlUrl = this.turnControlUrl;
    return {
      if (audioFallbackUrl != null) 'AudioFallbackUrl': audioFallbackUrl,
      if (audioHostUrl != null) 'AudioHostUrl': audioHostUrl,
      if (eventIngestionUrl != null) 'EventIngestionUrl': eventIngestionUrl,
      if (signalingUrl != null) 'SignalingUrl': signalingUrl,
      if (turnControlUrl != null) 'TurnControlUrl': turnControlUrl,
    };
  }
}

/// A meeting created using the Amazon Chime SDK.
class Meeting {
  /// The media placement for the meeting.
  final MediaPlacement? mediaPlacement;

  /// The Amazon Web Services Region in which you create the meeting.
  final String? mediaRegion;

  /// The configuration settings of the features available to a meeting.
  final MeetingFeaturesConfiguration? meetingFeatures;

  /// The Amazon Chime SDK meeting ID.
  final String? meetingId;

  Meeting({
    this.mediaPlacement,
    this.mediaRegion,
    this.meetingFeatures,
    this.meetingId,
  });

  factory Meeting.fromJson(Map<String, dynamic> json) {
    return Meeting(
      mediaPlacement: json['MediaPlacement'] != null
          ? MediaPlacement.fromJson(
              json['MediaPlacement'] as Map<String, dynamic>)
          : null,
      mediaRegion: json['MediaRegion'] as String?,
      meetingFeatures: json['MeetingFeatures'] != null
          ? MeetingFeaturesConfiguration.fromJson(
              json['MeetingFeatures'] as Map<String, dynamic>)
          : null,
      meetingId: json['MeetingId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final mediaPlacement = this.mediaPlacement;
    final mediaRegion = this.mediaRegion;
    final meetingFeatures = this.meetingFeatures;
    final meetingId = this.meetingId;
    return {
      if (mediaPlacement != null) 'MediaPlacement': mediaPlacement,
      if (mediaRegion != null) 'MediaRegion': mediaRegion,
      if (meetingFeatures != null) 'MeetingFeatures': meetingFeatures,
      if (meetingId != null) 'MeetingId': meetingId,
    };
  }
}

enum MeetingFeatureStatus {
  available('AVAILABLE'),
  unavailable('UNAVAILABLE'),
  ;

  final String value;

  const MeetingFeatureStatus(this.value);

  static MeetingFeatureStatus fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum MeetingFeatureStatus'));
}

/// The configuration settings of the features available to a meeting.
class MeetingFeaturesConfiguration {
  /// The configuration settings for the audio features available to a meeting.
  final AudioFeatures? audio;

  MeetingFeaturesConfiguration({
    this.audio,
  });

  factory MeetingFeaturesConfiguration.fromJson(Map<String, dynamic> json) {
    return MeetingFeaturesConfiguration(
      audio: json['Audio'] != null
          ? AudioFeatures.fromJson(json['Audio'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final audio = this.audio;
    return {
      if (audio != null) 'Audio': audio,
    };
  }
}

/// Contains the name, thresholds, and metric filters.
class MetricDataV2 {
  /// The metric name, thresholds, and metric filters of the returned metric.
  final MetricV2? metric;

  /// The corresponding value of the metric returned in the response.
  final double? value;

  MetricDataV2({
    this.metric,
    this.value,
  });

  factory MetricDataV2.fromJson(Map<String, dynamic> json) {
    return MetricDataV2(
      metric: json['Metric'] != null
          ? MetricV2.fromJson(json['Metric'] as Map<String, dynamic>)
          : null,
      value: json['Value'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final metric = this.metric;
    final value = this.value;
    return {
      if (metric != null) 'Metric': metric,
      if (value != null) 'Value': value,
    };
  }
}

/// Contains information about the filter used when retrieving metrics.
/// <code>MetricFiltersV2</code> can be used on the following metrics:
/// <code>AVG_AGENT_CONNECTING_TIME</code>, <code>CONTACTS_CREATED</code>,
/// <code>CONTACTS_HANDLED</code>, <code>SUM_CONTACTS_DISCONNECTED</code>.
class MetricFilterV2 {
  /// The key to use for filtering data.
  ///
  /// Valid metric filter keys: <code>INITIATION_METHOD</code>,
  /// <code>DISCONNECT_REASON</code>. These are the same values as the
  /// <code>InitiationMethod</code> and <code>DisconnectReason</code> in the
  /// contact record. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/ctr-data-model.html#ctr-ContactTraceRecord">ContactTraceRecord</a>
  /// in the <i>Amazon Connect Administrator Guide</i>.
  final String? metricFilterKey;

  /// The values to use for filtering data.
  ///
  /// Valid metric filter values for <code>INITIATION_METHOD</code>:
  /// <code>INBOUND</code> | <code>OUTBOUND</code> | <code>TRANSFER</code> |
  /// <code>QUEUE_TRANSFER</code> | <code>CALLBACK</code> | <code>API</code>
  ///
  /// Valid metric filter values for <code>DISCONNECT_REASON</code>:
  /// <code>CUSTOMER_DISCONNECT</code> | <code>AGENT_DISCONNECT</code> |
  /// <code>THIRD_PARTY_DISCONNECT</code> | <code>TELECOM_PROBLEM</code> |
  /// <code>BARGED</code> | <code>CONTACT_FLOW_DISCONNECT</code> |
  /// <code>OTHER</code> | <code>EXPIRED</code> | <code>API</code>
  final List<String>? metricFilterValues;

  /// The flag to use to filter on requested metric filter values or to not filter
  /// on requested metric filter values. By default the negate is
  /// <code>false</code>, which indicates to filter on the requested metric
  /// filter.
  final bool? negate;

  MetricFilterV2({
    this.metricFilterKey,
    this.metricFilterValues,
    this.negate,
  });

  factory MetricFilterV2.fromJson(Map<String, dynamic> json) {
    return MetricFilterV2(
      metricFilterKey: json['MetricFilterKey'] as String?,
      metricFilterValues: (json['MetricFilterValues'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      negate: json['Negate'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final metricFilterKey = this.metricFilterKey;
    final metricFilterValues = this.metricFilterValues;
    final negate = this.negate;
    return {
      if (metricFilterKey != null) 'MetricFilterKey': metricFilterKey,
      if (metricFilterValues != null) 'MetricFilterValues': metricFilterValues,
      if (negate != null) 'Negate': negate,
    };
  }
}

/// The interval period with the start and end time for the metrics.
class MetricInterval {
  /// The timestamp, in UNIX Epoch time format. End time is based on the interval
  /// period selected. For example, If <code>IntervalPeriod</code> is selected
  /// <code>THIRTY_MIN</code>, <code>StartTime</code> and <code>EndTime</code> in
  /// the API request differs by 1 day, then 48 results are returned in the
  /// response. Each result is aggregated by the 30 minutes period, with each
  /// <code>StartTime</code> and <code>EndTime</code> differing by 30 minutes.
  final DateTime? endTime;

  /// The interval period provided in the API request.
  final IntervalPeriod? interval;

  /// The timestamp, in UNIX Epoch time format. Start time is based on the
  /// interval period selected.
  final DateTime? startTime;

  MetricInterval({
    this.endTime,
    this.interval,
    this.startTime,
  });

  factory MetricInterval.fromJson(Map<String, dynamic> json) {
    return MetricInterval(
      endTime: timeStampFromJson(json['EndTime']),
      interval: (json['Interval'] as String?)?.let(IntervalPeriod.fromString),
      startTime: timeStampFromJson(json['StartTime']),
    );
  }

  Map<String, dynamic> toJson() {
    final endTime = this.endTime;
    final interval = this.interval;
    final startTime = this.startTime;
    return {
      if (endTime != null) 'EndTime': unixTimestampToJson(endTime),
      if (interval != null) 'Interval': interval.value,
      if (startTime != null) 'StartTime': unixTimestampToJson(startTime),
    };
  }
}

/// Contains information about the metric results.
class MetricResultV2 {
  /// The set of metrics.
  final List<MetricDataV2>? collections;

  /// The dimension for the metrics.
  final Map<String, String>? dimensions;

  /// The interval period with the start and end time for the metrics.
  final MetricInterval? metricInterval;

  MetricResultV2({
    this.collections,
    this.dimensions,
    this.metricInterval,
  });

  factory MetricResultV2.fromJson(Map<String, dynamic> json) {
    return MetricResultV2(
      collections: (json['Collections'] as List?)
          ?.nonNulls
          .map((e) => MetricDataV2.fromJson(e as Map<String, dynamic>))
          .toList(),
      dimensions: (json['Dimensions'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      metricInterval: json['MetricInterval'] != null
          ? MetricInterval.fromJson(
              json['MetricInterval'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final collections = this.collections;
    final dimensions = this.dimensions;
    final metricInterval = this.metricInterval;
    return {
      if (collections != null) 'Collections': collections,
      if (dimensions != null) 'Dimensions': dimensions,
      if (metricInterval != null) 'MetricInterval': metricInterval,
    };
  }
}

/// Contains information about the metric.
class MetricV2 {
  /// Contains the filters to be used when returning data.
  final List<MetricFilterV2>? metricFilters;

  /// The name of the metric.
  /// <important>
  /// This parameter is required. The following Required = No is incorrect.
  /// </important>
  final String? name;

  /// Contains information about the threshold for service level metrics.
  final List<ThresholdV2>? threshold;

  MetricV2({
    this.metricFilters,
    this.name,
    this.threshold,
  });

  factory MetricV2.fromJson(Map<String, dynamic> json) {
    return MetricV2(
      metricFilters: (json['MetricFilters'] as List?)
          ?.nonNulls
          .map((e) => MetricFilterV2.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      threshold: (json['Threshold'] as List?)
          ?.nonNulls
          .map((e) => ThresholdV2.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final metricFilters = this.metricFilters;
    final name = this.name;
    final threshold = this.threshold;
    return {
      if (metricFilters != null) 'MetricFilters': metricFilters,
      if (name != null) 'Name': name,
      if (threshold != null) 'Threshold': threshold,
    };
  }
}

enum MonitorCapability {
  silentMonitor('SILENT_MONITOR'),
  barge('BARGE'),
  ;

  final String value;

  const MonitorCapability(this.value);

  static MonitorCapability fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum MonitorCapability'));
}

class MonitorContactResponse {
  /// The ARN of the contact.
  final String? contactArn;

  /// The identifier of the contact.
  final String? contactId;

  MonitorContactResponse({
    this.contactArn,
    this.contactId,
  });

  factory MonitorContactResponse.fromJson(Map<String, dynamic> json) {
    return MonitorContactResponse(
      contactArn: json['ContactArn'] as String?,
      contactId: json['ContactId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactArn = this.contactArn;
    final contactId = this.contactId;
    return {
      if (contactArn != null) 'ContactArn': contactArn,
      if (contactId != null) 'ContactId': contactId,
    };
  }
}

/// Payload of chat properties to apply when starting a new contact.
class NewSessionDetails {
  /// A custom key-value pair using an attribute map. The attributes are standard
  /// Amazon Connect attributes. They can be accessed in flows just like any other
  /// contact attributes.
  ///
  /// There can be up to 32,768 UTF-8 bytes across all key-value pairs per
  /// contact. Attribute keys can include only alphanumeric, dash, and underscore
  /// characters.
  final Map<String, String>? attributes;
  final ParticipantDetails? participantDetails;
  final ChatStreamingConfiguration? streamingConfiguration;

  /// The supported chat message content types. Supported types are
  /// <code>text/plain</code>, <code>text/markdown</code>,
  /// <code>application/json</code>,
  /// <code>application/vnd.amazonaws.connect.message.interactive</code>, and
  /// <code>application/vnd.amazonaws.connect.message.interactive.response</code>.
  ///
  /// Content types must always contain <code> text/plain</code>. You can then put
  /// any other supported type in the list. For example, all the following lists
  /// are valid because they contain <code>text/plain</code>: <code>[text/plain,
  /// text/markdown, application/json]</code>, <code> [text/markdown,
  /// text/plain]</code>, <code>[text/plain, application/json,
  /// application/vnd.amazonaws.connect.message.interactive.response]</code>.
  final List<String>? supportedMessagingContentTypes;

  NewSessionDetails({
    this.attributes,
    this.participantDetails,
    this.streamingConfiguration,
    this.supportedMessagingContentTypes,
  });

  Map<String, dynamic> toJson() {
    final attributes = this.attributes;
    final participantDetails = this.participantDetails;
    final streamingConfiguration = this.streamingConfiguration;
    final supportedMessagingContentTypes = this.supportedMessagingContentTypes;
    return {
      if (attributes != null) 'Attributes': attributes,
      if (participantDetails != null) 'ParticipantDetails': participantDetails,
      if (streamingConfiguration != null)
        'StreamingConfiguration': streamingConfiguration,
      if (supportedMessagingContentTypes != null)
        'SupportedMessagingContentTypes': supportedMessagingContentTypes,
    };
  }
}

enum NotificationContentType {
  plainText('PLAIN_TEXT'),
  ;

  final String value;

  const NotificationContentType(this.value);

  static NotificationContentType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum NotificationContentType'));
}

enum NotificationDeliveryType {
  email('EMAIL'),
  ;

  final String value;

  const NotificationDeliveryType(this.value);

  static NotificationDeliveryType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum NotificationDeliveryType'));
}

/// The type of notification recipient.
class NotificationRecipientType {
  /// A list of user IDs.
  final List<String>? userIds;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }. Amazon Connect
  /// users with the specified tags will be notified.
  final Map<String, String>? userTags;

  NotificationRecipientType({
    this.userIds,
    this.userTags,
  });

  factory NotificationRecipientType.fromJson(Map<String, dynamic> json) {
    return NotificationRecipientType(
      userIds:
          (json['UserIds'] as List?)?.nonNulls.map((e) => e as String).toList(),
      userTags: (json['UserTags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final userIds = this.userIds;
    final userTags = this.userTags;
    return {
      if (userIds != null) 'UserIds': userIds,
      if (userTags != null) 'UserTags': userTags,
    };
  }
}

/// Information about a reference when the <code>referenceType</code> is
/// <code>NUMBER</code>. Otherwise, null.
class NumberReference {
  /// Identifier of the number reference.
  final String? name;

  /// A valid number.
  final String? value;

  NumberReference({
    this.name,
    this.value,
  });

  factory NumberReference.fromJson(Map<String, dynamic> json) {
    return NumberReference(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

enum NumericQuestionPropertyAutomationLabel {
  overallCustomerSentimentScore('OVERALL_CUSTOMER_SENTIMENT_SCORE'),
  overallAgentSentimentScore('OVERALL_AGENT_SENTIMENT_SCORE'),
  nonTalkTime('NON_TALK_TIME'),
  nonTalkTimePercentage('NON_TALK_TIME_PERCENTAGE'),
  numberOfInterruptions('NUMBER_OF_INTERRUPTIONS'),
  contactDuration('CONTACT_DURATION'),
  agentInteractionDuration('AGENT_INTERACTION_DURATION'),
  customerHoldTime('CUSTOMER_HOLD_TIME'),
  ;

  final String value;

  const NumericQuestionPropertyAutomationLabel(this.value);

  static NumericQuestionPropertyAutomationLabel fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum NumericQuestionPropertyAutomationLabel'));
}

/// Information about the property value used in automation of a numeric
/// questions. Label values are associated with minimum and maximum values for
/// the numeric question.
///
/// <ul>
/// <li>
/// Sentiment scores have a minimum value of -5 and maximum value of 5.
/// </li>
/// <li>
/// Duration labels, such as <code>NON_TALK_TIME</code>,
/// <code>CONTACT_DURATION</code>, <code>AGENT_INTERACTION_DURATION</code>,
/// <code>CUSTOMER_HOLD_TIME</code> have a minimum value of 0 and maximum value
/// of 28800.
/// </li>
/// <li>
/// Percentages have a minimum value of 0 and maximum value of 100.
/// </li>
/// <li>
/// <code>NUMBER_OF_INTERRUPTIONS</code> has a minimum value of 0 and maximum
/// value of 1000.
/// </li>
/// </ul>
class NumericQuestionPropertyValueAutomation {
  /// The property label of the automation.
  final NumericQuestionPropertyAutomationLabel label;

  NumericQuestionPropertyValueAutomation({
    required this.label,
  });

  factory NumericQuestionPropertyValueAutomation.fromJson(
      Map<String, dynamic> json) {
    return NumericQuestionPropertyValueAutomation(
      label: NumericQuestionPropertyAutomationLabel.fromString(
          (json['Label'] as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final label = this.label;
    return {
      'Label': label.value,
    };
  }
}

/// The outbound caller ID name, number, and outbound whisper flow.
class OutboundCallerConfig {
  /// The caller ID name.
  final String? outboundCallerIdName;

  /// The caller ID number.
  final String? outboundCallerIdNumberId;

  /// The outbound whisper flow to be used during an outbound call.
  final String? outboundFlowId;

  OutboundCallerConfig({
    this.outboundCallerIdName,
    this.outboundCallerIdNumberId,
    this.outboundFlowId,
  });

  factory OutboundCallerConfig.fromJson(Map<String, dynamic> json) {
    return OutboundCallerConfig(
      outboundCallerIdName: json['OutboundCallerIdName'] as String?,
      outboundCallerIdNumberId: json['OutboundCallerIdNumberId'] as String?,
      outboundFlowId: json['OutboundFlowId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final outboundCallerIdName = this.outboundCallerIdName;
    final outboundCallerIdNumberId = this.outboundCallerIdNumberId;
    final outboundFlowId = this.outboundFlowId;
    return {
      if (outboundCallerIdName != null)
        'OutboundCallerIdName': outboundCallerIdName,
      if (outboundCallerIdNumberId != null)
        'OutboundCallerIdNumberId': outboundCallerIdNumberId,
      if (outboundFlowId != null) 'OutboundFlowId': outboundFlowId,
    };
  }
}

/// The configuration for the allowed capabilities for participants present over
/// the call.
class ParticipantCapabilities {
  /// The configuration having the video sharing capabilities for participants
  /// over the call.
  final VideoCapability? video;

  ParticipantCapabilities({
    this.video,
  });

  factory ParticipantCapabilities.fromJson(Map<String, dynamic> json) {
    return ParticipantCapabilities(
      video: (json['Video'] as String?)?.let(VideoCapability.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final video = this.video;
    return {
      if (video != null) 'Video': video.value,
    };
  }
}

/// The customer's details.
class ParticipantDetails {
  /// Display name of the participant.
  final String displayName;

  ParticipantDetails({
    required this.displayName,
  });

  Map<String, dynamic> toJson() {
    final displayName = this.displayName;
    return {
      'DisplayName': displayName,
    };
  }
}

/// The details to add for the participant.
class ParticipantDetailsToAdd {
  /// The display name of the participant.
  final String? displayName;

  /// The role of the participant being added.
  final ParticipantRole? participantRole;

  ParticipantDetailsToAdd({
    this.displayName,
    this.participantRole,
  });

  Map<String, dynamic> toJson() {
    final displayName = this.displayName;
    final participantRole = this.participantRole;
    return {
      if (displayName != null) 'DisplayName': displayName,
      if (participantRole != null) 'ParticipantRole': participantRole.value,
    };
  }
}

enum ParticipantRole {
  agent('AGENT'),
  customer('CUSTOMER'),
  system('SYSTEM'),
  customBot('CUSTOM_BOT'),
  supervisor('SUPERVISOR'),
  ;

  final String value;

  const ParticipantRole(this.value);

  static ParticipantRole fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ParticipantRole'));
}

enum ParticipantTimerAction {
  unset('Unset'),
  ;

  final String value;

  const ParticipantTimerAction(this.value);

  static ParticipantTimerAction fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ParticipantTimerAction'));
}

/// Configuration information for the timer. After the timer configuration is
/// set, it persists for the duration of the chat. It persists across new
/// contacts in the chain, for example, transfer contacts.
///
/// For more information about how chat timeouts work, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html">Set
/// up chat timeouts for human participants</a>.
class ParticipantTimerConfiguration {
  /// The role of the participant in the chat conversation.
  final TimerEligibleParticipantRoles participantRole;

  /// The type of timer. <code>IDLE</code> indicates the timer applies for
  /// considering a human chat participant as idle.
  /// <code>DISCONNECT_NONCUSTOMER</code> indicates the timer applies to
  /// automatically disconnecting a chat participant due to idleness.
  final ParticipantTimerType timerType;

  /// The value of the timer. Either the timer action (Unset to delete the timer),
  /// or the duration of the timer in minutes. Only one value can be set.
  final ParticipantTimerValue timerValue;

  ParticipantTimerConfiguration({
    required this.participantRole,
    required this.timerType,
    required this.timerValue,
  });

  Map<String, dynamic> toJson() {
    final participantRole = this.participantRole;
    final timerType = this.timerType;
    final timerValue = this.timerValue;
    return {
      'ParticipantRole': participantRole.value,
      'TimerType': timerType.value,
      'TimerValue': timerValue,
    };
  }
}

enum ParticipantTimerType {
  idle('IDLE'),
  disconnectNoncustomer('DISCONNECT_NONCUSTOMER'),
  ;

  final String value;

  const ParticipantTimerType(this.value);

  static ParticipantTimerType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum ParticipantTimerType'));
}

/// The value of the timer. Either the timer action (<code>Unset</code> to
/// delete the timer), or the duration of the timer in minutes. Only one value
/// can be set.
///
/// For more information about how chat timeouts work, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/setup-chat-timeouts.html">Set
/// up chat timeouts for human participants</a>.
class ParticipantTimerValue {
  /// The timer action. Currently only one value is allowed: <code>Unset</code>.
  /// It deletes a timer.
  final ParticipantTimerAction? participantTimerAction;

  /// The duration of a timer, in minutes.
  final int? participantTimerDurationInMinutes;

  ParticipantTimerValue({
    this.participantTimerAction,
    this.participantTimerDurationInMinutes,
  });

  Map<String, dynamic> toJson() {
    final participantTimerAction = this.participantTimerAction;
    final participantTimerDurationInMinutes =
        this.participantTimerDurationInMinutes;
    return {
      if (participantTimerAction != null)
        'ParticipantTimerAction': participantTimerAction.value,
      if (participantTimerDurationInMinutes != null)
        'ParticipantTimerDurationInMinutes': participantTimerDurationInMinutes,
    };
  }
}

/// The credentials used by the participant.
class ParticipantTokenCredentials {
  /// The expiration of the token. It's specified in ISO 8601 format:
  /// yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
  final String? expiry;

  /// The token used by the chat participant to call <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a>.
  /// The participant token is valid for the lifetime of a chat participant.
  final String? participantToken;

  ParticipantTokenCredentials({
    this.expiry,
    this.participantToken,
  });

  factory ParticipantTokenCredentials.fromJson(Map<String, dynamic> json) {
    return ParticipantTokenCredentials(
      expiry: json['Expiry'] as String?,
      participantToken: json['ParticipantToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final expiry = this.expiry;
    final participantToken = this.participantToken;
    return {
      if (expiry != null) 'Expiry': expiry,
      if (participantToken != null) 'ParticipantToken': participantToken,
    };
  }
}

class PauseContactResponse {
  PauseContactResponse();

  factory PauseContactResponse.fromJson(Map<String, dynamic> _) {
    return PauseContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Enable persistent chats. For more information about enabling persistent
/// chat, and for example use cases and how to configure for them, see <a
/// href="https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html">Enable
/// persistent chat</a>.
class PersistentChat {
  /// The contactId that is used for rehydration depends on the rehydration type.
  /// RehydrationType is required for persistent chat.
  ///
  /// <ul>
  /// <li>
  /// <code>ENTIRE_PAST_SESSION</code>: Rehydrates a chat from the most recently
  /// terminated past chat contact of the specified past ended chat session. To
  /// use this type, provide the <code>initialContactId</code> of the past ended
  /// chat session in the <code>sourceContactId</code> field. In this type, Amazon
  /// Connect determines the most recent chat contact on the specified chat
  /// session that has ended, and uses it to start a persistent chat.
  /// </li>
  /// <li>
  /// <code>FROM_SEGMENT</code>: Rehydrates a chat from the past chat contact that
  /// is specified in the <code>sourceContactId</code> field.
  /// </li>
  /// </ul>
  /// The actual contactId used for rehydration is provided in the response of
  /// this API.
  final RehydrationType? rehydrationType;

  /// The contactId from which a persistent chat session must be started.
  final String? sourceContactId;

  PersistentChat({
    this.rehydrationType,
    this.sourceContactId,
  });

  Map<String, dynamic> toJson() {
    final rehydrationType = this.rehydrationType;
    final sourceContactId = this.sourceContactId;
    return {
      if (rehydrationType != null) 'RehydrationType': rehydrationType.value,
      if (sourceContactId != null) 'SourceContactId': sourceContactId,
    };
  }
}

enum PhoneNumberCountryCode {
  af('AF'),
  al('AL'),
  dz('DZ'),
  as('AS'),
  ad('AD'),
  ao('AO'),
  ai('AI'),
  aq('AQ'),
  ag('AG'),
  ar('AR'),
  am('AM'),
  aw('AW'),
  au('AU'),
  at('AT'),
  az('AZ'),
  bs('BS'),
  bh('BH'),
  bd('BD'),
  bb('BB'),
  by('BY'),
  be('BE'),
  bz('BZ'),
  bj('BJ'),
  bm('BM'),
  bt('BT'),
  bo('BO'),
  ba('BA'),
  bw('BW'),
  br('BR'),
  io('IO'),
  vg('VG'),
  bn('BN'),
  bg('BG'),
  bf('BF'),
  bi('BI'),
  kh('KH'),
  cm('CM'),
  ca('CA'),
  cv('CV'),
  ky('KY'),
  cf('CF'),
  td('TD'),
  cl('CL'),
  cn('CN'),
  cx('CX'),
  cc('CC'),
  co('CO'),
  km('KM'),
  ck('CK'),
  cr('CR'),
  hr('HR'),
  cu('CU'),
  cw('CW'),
  cy('CY'),
  cz('CZ'),
  cd('CD'),
  dk('DK'),
  dj('DJ'),
  dm('DM'),
  $do('DO'),
  tl('TL'),
  ec('EC'),
  eg('EG'),
  sv('SV'),
  gq('GQ'),
  er('ER'),
  ee('EE'),
  et('ET'),
  fk('FK'),
  fo('FO'),
  fj('FJ'),
  fi('FI'),
  fr('FR'),
  pf('PF'),
  ga('GA'),
  gm('GM'),
  ge('GE'),
  de('DE'),
  gh('GH'),
  gi('GI'),
  gr('GR'),
  gl('GL'),
  gd('GD'),
  gu('GU'),
  gt('GT'),
  gg('GG'),
  gn('GN'),
  gw('GW'),
  gy('GY'),
  ht('HT'),
  hn('HN'),
  hk('HK'),
  hu('HU'),
  $is('IS'),
  $in('IN'),
  id('ID'),
  ir('IR'),
  iq('IQ'),
  ie('IE'),
  im('IM'),
  il('IL'),
  it('IT'),
  ci('CI'),
  jm('JM'),
  jp('JP'),
  je('JE'),
  jo('JO'),
  kz('KZ'),
  ke('KE'),
  ki('KI'),
  kw('KW'),
  kg('KG'),
  la('LA'),
  lv('LV'),
  lb('LB'),
  ls('LS'),
  lr('LR'),
  ly('LY'),
  li('LI'),
  lt('LT'),
  lu('LU'),
  mo('MO'),
  mk('MK'),
  mg('MG'),
  mw('MW'),
  my('MY'),
  mv('MV'),
  ml('ML'),
  mt('MT'),
  mh('MH'),
  mr('MR'),
  mu('MU'),
  yt('YT'),
  mx('MX'),
  fm('FM'),
  md('MD'),
  mc('MC'),
  mn('MN'),
  me('ME'),
  ms('MS'),
  ma('MA'),
  mz('MZ'),
  mm('MM'),
  na('NA'),
  nr('NR'),
  np('NP'),
  nl('NL'),
  an('AN'),
  nc('NC'),
  nz('NZ'),
  ni('NI'),
  ne('NE'),
  ng('NG'),
  nu('NU'),
  kp('KP'),
  mp('MP'),
  no('NO'),
  om('OM'),
  pk('PK'),
  pw('PW'),
  pa('PA'),
  pg('PG'),
  py('PY'),
  pe('PE'),
  ph('PH'),
  pn('PN'),
  pl('PL'),
  pt('PT'),
  pr('PR'),
  qa('QA'),
  cg('CG'),
  re('RE'),
  ro('RO'),
  ru('RU'),
  rw('RW'),
  bl('BL'),
  sh('SH'),
  kn('KN'),
  lc('LC'),
  mf('MF'),
  pm('PM'),
  vc('VC'),
  ws('WS'),
  sm('SM'),
  st('ST'),
  sa('SA'),
  sn('SN'),
  rs('RS'),
  sc('SC'),
  sl('SL'),
  sg('SG'),
  sx('SX'),
  sk('SK'),
  si('SI'),
  sb('SB'),
  so('SO'),
  za('ZA'),
  kr('KR'),
  es('ES'),
  lk('LK'),
  sd('SD'),
  sr('SR'),
  sj('SJ'),
  sz('SZ'),
  se('SE'),
  ch('CH'),
  sy('SY'),
  tw('TW'),
  tj('TJ'),
  tz('TZ'),
  th('TH'),
  tg('TG'),
  tk('TK'),
  to('TO'),
  tt('TT'),
  tn('TN'),
  tr('TR'),
  tm('TM'),
  tc('TC'),
  tv('TV'),
  vi('VI'),
  ug('UG'),
  ua('UA'),
  ae('AE'),
  gb('GB'),
  us('US'),
  uy('UY'),
  uz('UZ'),
  vu('VU'),
  va('VA'),
  ve('VE'),
  vn('VN'),
  wf('WF'),
  eh('EH'),
  ye('YE'),
  zm('ZM'),
  zw('ZW'),
  ;

  final String value;

  const PhoneNumberCountryCode(this.value);

  static PhoneNumberCountryCode fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum PhoneNumberCountryCode'));
}

/// Contains information about a phone number for a quick connect.
class PhoneNumberQuickConnectConfig {
  /// The phone number in E.164 format.
  final String phoneNumber;

  PhoneNumberQuickConnectConfig({
    required this.phoneNumber,
  });

  factory PhoneNumberQuickConnectConfig.fromJson(Map<String, dynamic> json) {
    return PhoneNumberQuickConnectConfig(
      phoneNumber: json['PhoneNumber'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final phoneNumber = this.phoneNumber;
    return {
      'PhoneNumber': phoneNumber,
    };
  }
}

/// The status of the phone number.
///
/// <ul>
/// <li>
/// <code>CLAIMED</code> means the previous <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>
/// or <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>
/// operation succeeded.
/// </li>
/// <li>
/// <code>IN_PROGRESS</code> means a <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>,
/// <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>,
/// or <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumberMetadata.html">UpdatePhoneNumberMetadata</a>
/// operation is still in progress and has not yet completed. You can call <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DescribePhoneNumber.html">DescribePhoneNumber</a>
/// at a later time to verify if the previous operation has completed.
/// </li>
/// <li>
/// <code>FAILED</code> indicates that the previous <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_ClaimPhoneNumber.html">ClaimPhoneNumber</a>
/// or <a
/// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdatePhoneNumber.html">UpdatePhoneNumber</a>
/// operation has failed. It will include a message indicating the failure
/// reason. A common reason for a failure may be that the <code>TargetArn</code>
/// value you are claiming or updating a phone number to has reached its limit
/// of total claimed numbers. If you received a <code>FAILED</code> status from
/// a <code>ClaimPhoneNumber</code> API call, you have one day to retry claiming
/// the phone number before the number is released back to the inventory for
/// other customers to claim.
/// </li>
/// </ul>
class PhoneNumberStatus {
  /// The status message.
  final String? message;

  /// The status.
  final PhoneNumberWorkflowStatus? status;

  PhoneNumberStatus({
    this.message,
    this.status,
  });

  factory PhoneNumberStatus.fromJson(Map<String, dynamic> json) {
    return PhoneNumberStatus(
      message: json['Message'] as String?,
      status: (json['Status'] as String?)
          ?.let(PhoneNumberWorkflowStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final status = this.status;
    return {
      if (message != null) 'Message': message,
      if (status != null) 'Status': status.value,
    };
  }
}

/// Contains summary information about a phone number for a contact center.
class PhoneNumberSummary {
  /// The Amazon Resource Name (ARN) of the phone number.
  final String? arn;

  /// The identifier of the phone number.
  final String? id;

  /// The phone number.
  final String? phoneNumber;

  /// The ISO country code.
  final PhoneNumberCountryCode? phoneNumberCountryCode;

  /// The type of phone number.
  final PhoneNumberType? phoneNumberType;

  PhoneNumberSummary({
    this.arn,
    this.id,
    this.phoneNumber,
    this.phoneNumberCountryCode,
    this.phoneNumberType,
  });

  factory PhoneNumberSummary.fromJson(Map<String, dynamic> json) {
    return PhoneNumberSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      phoneNumber: json['PhoneNumber'] as String?,
      phoneNumberCountryCode: (json['PhoneNumberCountryCode'] as String?)
          ?.let(PhoneNumberCountryCode.fromString),
      phoneNumberType:
          (json['PhoneNumberType'] as String?)?.let(PhoneNumberType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final phoneNumber = this.phoneNumber;
    final phoneNumberCountryCode = this.phoneNumberCountryCode;
    final phoneNumberType = this.phoneNumberType;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (phoneNumber != null) 'PhoneNumber': phoneNumber,
      if (phoneNumberCountryCode != null)
        'PhoneNumberCountryCode': phoneNumberCountryCode.value,
      if (phoneNumberType != null) 'PhoneNumberType': phoneNumberType.value,
    };
  }
}

enum PhoneNumberType {
  tollFree('TOLL_FREE'),
  did('DID'),
  uifn('UIFN'),
  shared('SHARED'),
  thirdPartyTf('THIRD_PARTY_TF'),
  thirdPartyDid('THIRD_PARTY_DID'),
  shortCode('SHORT_CODE'),
  ;

  final String value;

  const PhoneNumberType(this.value);

  static PhoneNumberType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum PhoneNumberType'));
}

enum PhoneNumberWorkflowStatus {
  claimed('CLAIMED'),
  inProgress('IN_PROGRESS'),
  failed('FAILED'),
  ;

  final String value;

  const PhoneNumberWorkflowStatus(this.value);

  static PhoneNumberWorkflowStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum PhoneNumberWorkflowStatus'));
}

enum PhoneType {
  softPhone('SOFT_PHONE'),
  deskPhone('DESK_PHONE'),
  ;

  final String value;

  const PhoneType(this.value);

  static PhoneType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum PhoneType'));
}

/// Information about a predefined attribute.
class PredefinedAttribute {
  /// Last modified region.
  final String? lastModifiedRegion;

  /// Last modified time.
  final DateTime? lastModifiedTime;

  /// The name of the predefined attribute.
  final String? name;

  /// The values of the predefined attribute.
  final PredefinedAttributeValues? values;

  PredefinedAttribute({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.values,
  });

  factory PredefinedAttribute.fromJson(Map<String, dynamic> json) {
    return PredefinedAttribute(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      values: json['Values'] != null
          ? PredefinedAttributeValues.fromJson(
              json['Values'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final values = this.values;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (values != null) 'Values': values,
    };
  }
}

/// The search criteria to be used to return predefined attributes.
class PredefinedAttributeSearchCriteria {
  /// A list of conditions which would be applied together with an
  /// <code>AND</code> condition.
  final List<PredefinedAttributeSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an <code>OR</code>
  /// condition.
  final List<PredefinedAttributeSearchCriteria>? orConditions;
  final StringCondition? stringCondition;

  PredefinedAttributeSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Summary of a predefined attribute.
class PredefinedAttributeSummary {
  /// Last modified region.
  final String? lastModifiedRegion;

  /// Last modified time.
  final DateTime? lastModifiedTime;

  /// The name of the predefined attribute.
  final String? name;

  PredefinedAttributeSummary({
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory PredefinedAttributeSummary.fromJson(Map<String, dynamic> json) {
    return PredefinedAttributeSummary(
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

/// Information about values of a predefined attribute.
class PredefinedAttributeValues {
  /// Predefined attribute values of type string list.
  final List<String>? stringList;

  PredefinedAttributeValues({
    this.stringList,
  });

  factory PredefinedAttributeValues.fromJson(Map<String, dynamic> json) {
    return PredefinedAttributeValues(
      stringList: (json['StringList'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final stringList = this.stringList;
    return {
      if (stringList != null) 'StringList': stringList,
    };
  }
}

/// Information about a prompt.
class Prompt {
  /// The description of the prompt.
  final String? description;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the prompt.
  final String? name;

  /// The Amazon Resource Name (ARN) of the prompt.
  final String? promptARN;

  /// A unique identifier for the prompt.
  final String? promptId;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  Prompt({
    this.description,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.promptARN,
    this.promptId,
    this.tags,
  });

  factory Prompt.fromJson(Map<String, dynamic> json) {
    return Prompt(
      description: json['Description'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      promptARN: json['PromptARN'] as String?,
      promptId: json['PromptId'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final promptARN = this.promptARN;
    final promptId = this.promptId;
    final tags = this.tags;
    return {
      if (description != null) 'Description': description,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (promptARN != null) 'PromptARN': promptARN,
      if (promptId != null) 'PromptId': promptId,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// The search criteria to be used to return prompts.
class PromptSearchCriteria {
  /// A list of conditions which would be applied together with an AND condition.
  final List<PromptSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an OR condition.
  final List<PromptSearchCriteria>? orConditions;

  /// A leaf node condition which can be used to specify a string condition.
  /// <note>
  /// The currently supported values for <code>FieldName</code> are
  /// <code>name</code>, <code>description</code>, and <code>resourceID</code>.
  /// </note>
  final StringCondition? stringCondition;

  PromptSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Filters to be applied to search results.
class PromptSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  PromptSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

/// Contains information about the prompt.
class PromptSummary {
  /// The Amazon Resource Name (ARN) of the prompt.
  final String? arn;

  /// The identifier of the prompt.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the prompt.
  final String? name;

  PromptSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory PromptSummary.fromJson(Map<String, dynamic> json) {
    return PromptSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

class PutUserStatusResponse {
  PutUserStatusResponse();

  factory PutUserStatusResponse.fromJson(Map<String, dynamic> _) {
    return PutUserStatusResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Information about the quality of the participant's media connection.
class QualityMetrics {
  /// Information about the quality of Agent media connection.
  final AgentQualityMetrics? agent;

  /// Information about the quality of Customer media connection.
  final CustomerQualityMetrics? customer;

  QualityMetrics({
    this.agent,
    this.customer,
  });

  factory QualityMetrics.fromJson(Map<String, dynamic> json) {
    return QualityMetrics(
      agent: json['Agent'] != null
          ? AgentQualityMetrics.fromJson(json['Agent'] as Map<String, dynamic>)
          : null,
      customer: json['Customer'] != null
          ? CustomerQualityMetrics.fromJson(
              json['Customer'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final agent = this.agent;
    final customer = this.customer;
    return {
      if (agent != null) 'Agent': agent,
      if (customer != null) 'Customer': customer,
    };
  }
}

/// Contains information about a queue.
class Queue {
  /// The description of the queue.
  final String? description;

  /// The identifier for the hours of operation.
  final String? hoursOfOperationId;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The maximum number of contacts that can be in the queue before it is
  /// considered full.
  final int? maxContacts;

  /// The name of the queue.
  final String? name;

  /// The outbound caller ID name, number, and outbound whisper flow.
  final OutboundCallerConfig? outboundCallerConfig;

  /// The Amazon Resource Name (ARN) for the queue.
  final String? queueArn;

  /// The identifier for the queue.
  final String? queueId;

  /// The status of the queue.
  final QueueStatus? status;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  Queue({
    this.description,
    this.hoursOfOperationId,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.maxContacts,
    this.name,
    this.outboundCallerConfig,
    this.queueArn,
    this.queueId,
    this.status,
    this.tags,
  });

  factory Queue.fromJson(Map<String, dynamic> json) {
    return Queue(
      description: json['Description'] as String?,
      hoursOfOperationId: json['HoursOfOperationId'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      maxContacts: json['MaxContacts'] as int?,
      name: json['Name'] as String?,
      outboundCallerConfig: json['OutboundCallerConfig'] != null
          ? OutboundCallerConfig.fromJson(
              json['OutboundCallerConfig'] as Map<String, dynamic>)
          : null,
      queueArn: json['QueueArn'] as String?,
      queueId: json['QueueId'] as String?,
      status: (json['Status'] as String?)?.let(QueueStatus.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final hoursOfOperationId = this.hoursOfOperationId;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final maxContacts = this.maxContacts;
    final name = this.name;
    final outboundCallerConfig = this.outboundCallerConfig;
    final queueArn = this.queueArn;
    final queueId = this.queueId;
    final status = this.status;
    final tags = this.tags;
    return {
      if (description != null) 'Description': description,
      if (hoursOfOperationId != null) 'HoursOfOperationId': hoursOfOperationId,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (maxContacts != null) 'MaxContacts': maxContacts,
      if (name != null) 'Name': name,
      if (outboundCallerConfig != null)
        'OutboundCallerConfig': outboundCallerConfig,
      if (queueArn != null) 'QueueArn': queueArn,
      if (queueId != null) 'QueueId': queueId,
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// If this contact was queued, this contains information about the queue.
class QueueInfo {
  /// The timestamp when the contact was added to the queue.
  final DateTime? enqueueTimestamp;

  /// The unique identifier for the queue.
  final String? id;

  QueueInfo({
    this.enqueueTimestamp,
    this.id,
  });

  factory QueueInfo.fromJson(Map<String, dynamic> json) {
    return QueueInfo(
      enqueueTimestamp: timeStampFromJson(json['EnqueueTimestamp']),
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final enqueueTimestamp = this.enqueueTimestamp;
    final id = this.id;
    return {
      if (enqueueTimestamp != null)
        'EnqueueTimestamp': unixTimestampToJson(enqueueTimestamp),
      if (id != null) 'Id': id,
    };
  }
}

/// Contains information about a queue for a quick connect. The flow must be of
/// type Transfer to Queue.
class QueueQuickConnectConfig {
  /// The identifier of the flow.
  final String contactFlowId;

  /// The identifier for the queue.
  final String queueId;

  QueueQuickConnectConfig({
    required this.contactFlowId,
    required this.queueId,
  });

  factory QueueQuickConnectConfig.fromJson(Map<String, dynamic> json) {
    return QueueQuickConnectConfig(
      contactFlowId: json['ContactFlowId'] as String,
      queueId: json['QueueId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowId = this.contactFlowId;
    final queueId = this.queueId;
    return {
      'ContactFlowId': contactFlowId,
      'QueueId': queueId,
    };
  }
}

/// Contains information about a queue resource for which metrics are returned.
class QueueReference {
  /// The Amazon Resource Name (ARN) of the queue.
  final String? arn;

  /// The identifier of the queue.
  final String? id;

  QueueReference({
    this.arn,
    this.id,
  });

  factory QueueReference.fromJson(Map<String, dynamic> json) {
    return QueueReference(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

/// The search criteria to be used to return queues.
/// <note>
/// The <code>name</code> and <code>description</code> fields support "contains"
/// queries with a minimum of 2 characters and a maximum of 25 characters. Any
/// queries with character lengths outside of this range will throw invalid
/// results.
/// </note>
class QueueSearchCriteria {
  /// A list of conditions which would be applied together with an AND condition.
  final List<QueueSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an OR condition.
  final List<QueueSearchCriteria>? orConditions;

  /// The type of queue.
  final SearchableQueueType? queueTypeCondition;

  /// A leaf node condition which can be used to specify a string condition.
  /// <note>
  /// The currently supported values for <code>FieldName</code> are
  /// <code>name</code>, <code>description</code>, and <code>resourceID</code>.
  /// </note>
  final StringCondition? stringCondition;

  QueueSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.queueTypeCondition,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final queueTypeCondition = this.queueTypeCondition;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (queueTypeCondition != null)
        'QueueTypeCondition': queueTypeCondition.value,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Filters to be applied to search results.
class QueueSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  QueueSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

enum QueueStatus {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const QueueStatus(this.value);

  static QueueStatus fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum QueueStatus'));
}

/// Contains summary information about a queue.
class QueueSummary {
  /// The Amazon Resource Name (ARN) of the queue.
  final String? arn;

  /// The identifier of the queue.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the queue.
  final String? name;

  /// The type of queue.
  final QueueType? queueType;

  QueueSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.queueType,
  });

  factory QueueSummary.fromJson(Map<String, dynamic> json) {
    return QueueSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      queueType: (json['QueueType'] as String?)?.let(QueueType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final queueType = this.queueType;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (queueType != null) 'QueueType': queueType.value,
    };
  }
}

enum QueueType {
  standard('STANDARD'),
  agent('AGENT'),
  ;

  final String value;

  const QueueType(this.value);

  static QueueType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum QueueType'));
}

/// Contains information about a quick connect.
class QuickConnect {
  /// The description.
  final String? description;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the quick connect.
  final String? name;

  /// The Amazon Resource Name (ARN) of the quick connect.
  final String? quickConnectARN;

  /// Contains information about the quick connect.
  final QuickConnectConfig? quickConnectConfig;

  /// The identifier for the quick connect.
  final String? quickConnectId;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  QuickConnect({
    this.description,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.quickConnectARN,
    this.quickConnectConfig,
    this.quickConnectId,
    this.tags,
  });

  factory QuickConnect.fromJson(Map<String, dynamic> json) {
    return QuickConnect(
      description: json['Description'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      quickConnectARN: json['QuickConnectARN'] as String?,
      quickConnectConfig: json['QuickConnectConfig'] != null
          ? QuickConnectConfig.fromJson(
              json['QuickConnectConfig'] as Map<String, dynamic>)
          : null,
      quickConnectId: json['QuickConnectId'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final quickConnectARN = this.quickConnectARN;
    final quickConnectConfig = this.quickConnectConfig;
    final quickConnectId = this.quickConnectId;
    final tags = this.tags;
    return {
      if (description != null) 'Description': description,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (quickConnectARN != null) 'QuickConnectARN': quickConnectARN,
      if (quickConnectConfig != null) 'QuickConnectConfig': quickConnectConfig,
      if (quickConnectId != null) 'QuickConnectId': quickConnectId,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Contains configuration settings for a quick connect.
class QuickConnectConfig {
  /// The type of quick connect. In the Amazon Connect admin website, when you
  /// create a quick connect, you are prompted to assign one of the following
  /// types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
  final QuickConnectType quickConnectType;

  /// The phone configuration. This is required only if QuickConnectType is
  /// PHONE_NUMBER.
  final PhoneNumberQuickConnectConfig? phoneConfig;

  /// The queue configuration. This is required only if QuickConnectType is QUEUE.
  final QueueQuickConnectConfig? queueConfig;

  /// The user configuration. This is required only if QuickConnectType is USER.
  final UserQuickConnectConfig? userConfig;

  QuickConnectConfig({
    required this.quickConnectType,
    this.phoneConfig,
    this.queueConfig,
    this.userConfig,
  });

  factory QuickConnectConfig.fromJson(Map<String, dynamic> json) {
    return QuickConnectConfig(
      quickConnectType:
          QuickConnectType.fromString((json['QuickConnectType'] as String)),
      phoneConfig: json['PhoneConfig'] != null
          ? PhoneNumberQuickConnectConfig.fromJson(
              json['PhoneConfig'] as Map<String, dynamic>)
          : null,
      queueConfig: json['QueueConfig'] != null
          ? QueueQuickConnectConfig.fromJson(
              json['QueueConfig'] as Map<String, dynamic>)
          : null,
      userConfig: json['UserConfig'] != null
          ? UserQuickConnectConfig.fromJson(
              json['UserConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final quickConnectType = this.quickConnectType;
    final phoneConfig = this.phoneConfig;
    final queueConfig = this.queueConfig;
    final userConfig = this.userConfig;
    return {
      'QuickConnectType': quickConnectType.value,
      if (phoneConfig != null) 'PhoneConfig': phoneConfig,
      if (queueConfig != null) 'QueueConfig': queueConfig,
      if (userConfig != null) 'UserConfig': userConfig,
    };
  }
}

/// The search criteria to be used to return quick connects.
class QuickConnectSearchCriteria {
  /// A list of conditions which would be applied together with an AND condition.
  final List<QuickConnectSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an OR condition.
  final List<QuickConnectSearchCriteria>? orConditions;

  /// A leaf node condition which can be used to specify a string condition.
  /// <note>
  /// The currently supported values for <code>FieldName</code> are
  /// <code>name</code>, <code>description</code>, and <code>resourceID</code>.
  /// </note>
  final StringCondition? stringCondition;

  QuickConnectSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Filters to be applied to search results.
class QuickConnectSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  QuickConnectSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

/// Contains summary information about a quick connect.
class QuickConnectSummary {
  /// The Amazon Resource Name (ARN) of the quick connect.
  final String? arn;

  /// The identifier for the quick connect.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the quick connect.
  final String? name;

  /// The type of quick connect. In the Amazon Connect admin website, when you
  /// create a quick connect, you are prompted to assign one of the following
  /// types: Agent (USER), External (PHONE_NUMBER), or Queue (QUEUE).
  final QuickConnectType? quickConnectType;

  QuickConnectSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
    this.quickConnectType,
  });

  factory QuickConnectSummary.fromJson(Map<String, dynamic> json) {
    return QuickConnectSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      quickConnectType: (json['QuickConnectType'] as String?)
          ?.let(QuickConnectType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final quickConnectType = this.quickConnectType;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (quickConnectType != null) 'QuickConnectType': quickConnectType.value,
    };
  }
}

enum QuickConnectType {
  user('USER'),
  queue('QUEUE'),
  phoneNumber('PHONE_NUMBER'),
  ;

  final String value;

  const QuickConnectType(this.value);

  static QuickConnectType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum QuickConnectType'));
}

/// Indicates a field that is read-only to an agent.
class ReadOnlyFieldInfo {
  /// Identifier of the read-only field.
  final TaskTemplateFieldIdentifier? id;

  ReadOnlyFieldInfo({
    this.id,
  });

  factory ReadOnlyFieldInfo.fromJson(Map<String, dynamic> json) {
    return ReadOnlyFieldInfo(
      id: json['Id'] != null
          ? TaskTemplateFieldIdentifier.fromJson(
              json['Id'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    return {
      if (id != null) 'Id': id,
    };
  }
}

/// Object that describes attached file.
class RealTimeContactAnalysisAttachment {
  /// A unique identifier for the attachment.
  final String attachmentId;

  /// A case-sensitive name of the attachment being uploaded. Can be redacted.
  final String attachmentName;

  /// Describes the MIME file type of the attachment. For a list of supported file
  /// types, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html">Feature
  /// specifications</a> in the <i>Amazon Connect Administrator Guide</i>.
  final String? contentType;

  /// Status of the attachment.
  final ArtifactStatus? status;

  RealTimeContactAnalysisAttachment({
    required this.attachmentId,
    required this.attachmentName,
    this.contentType,
    this.status,
  });

  factory RealTimeContactAnalysisAttachment.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisAttachment(
      attachmentId: json['AttachmentId'] as String,
      attachmentName: json['AttachmentName'] as String,
      contentType: json['ContentType'] as String?,
      status: (json['Status'] as String?)?.let(ArtifactStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final attachmentId = this.attachmentId;
    final attachmentName = this.attachmentName;
    final contentType = this.contentType;
    final status = this.status;
    return {
      'AttachmentId': attachmentId,
      'AttachmentName': attachmentName,
      if (contentType != null) 'ContentType': contentType,
      if (status != null) 'Status': status.value,
    };
  }
}

/// Provides information about the category rule that was matched.
class RealTimeContactAnalysisCategoryDetails {
  /// List of PointOfInterest - objects describing a single match of a rule.
  final List<RealTimeContactAnalysisPointOfInterest> pointsOfInterest;

  RealTimeContactAnalysisCategoryDetails({
    required this.pointsOfInterest,
  });

  factory RealTimeContactAnalysisCategoryDetails.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisCategoryDetails(
      pointsOfInterest: (json['PointsOfInterest'] as List)
          .nonNulls
          .map((e) => RealTimeContactAnalysisPointOfInterest.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final pointsOfInterest = this.pointsOfInterest;
    return {
      'PointsOfInterest': pointsOfInterest,
    };
  }
}

/// Begin and end offsets for a part of text.
class RealTimeContactAnalysisCharacterInterval {
  /// The beginning of the character interval.
  final int beginOffsetChar;

  /// The end of the character interval.
  final int endOffsetChar;

  RealTimeContactAnalysisCharacterInterval({
    required this.beginOffsetChar,
    required this.endOffsetChar,
  });

  factory RealTimeContactAnalysisCharacterInterval.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisCharacterInterval(
      beginOffsetChar: json['BeginOffsetChar'] as int,
      endOffsetChar: json['EndOffsetChar'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final beginOffsetChar = this.beginOffsetChar;
    final endOffsetChar = this.endOffsetChar;
    return {
      'BeginOffsetChar': beginOffsetChar,
      'EndOffsetChar': endOffsetChar,
    };
  }
}

/// Potential issues that are detected based on an artificial intelligence
/// analysis of each turn in the conversation.
class RealTimeContactAnalysisIssueDetected {
  /// List of the transcript items (segments) that are associated with a given
  /// issue.
  final List<RealTimeContactAnalysisTranscriptItemWithContent> transcriptItems;

  RealTimeContactAnalysisIssueDetected({
    required this.transcriptItems,
  });

  factory RealTimeContactAnalysisIssueDetected.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisIssueDetected(
      transcriptItems: (json['TranscriptItems'] as List)
          .nonNulls
          .map((e) => RealTimeContactAnalysisTranscriptItemWithContent.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final transcriptItems = this.transcriptItems;
    return {
      'TranscriptItems': transcriptItems,
    };
  }
}

enum RealTimeContactAnalysisOutputType {
  raw('Raw'),
  redacted('Redacted'),
  ;

  final String value;

  const RealTimeContactAnalysisOutputType(this.value);

  static RealTimeContactAnalysisOutputType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RealTimeContactAnalysisOutputType'));
}

/// The section of the contact transcript segment that category rule was
/// detected.
class RealTimeContactAnalysisPointOfInterest {
  /// List of the transcript items (segments) that are associated with a given
  /// point of interest.
  final List<RealTimeContactAnalysisTranscriptItemWithCharacterOffsets>?
      transcriptItems;

  RealTimeContactAnalysisPointOfInterest({
    this.transcriptItems,
  });

  factory RealTimeContactAnalysisPointOfInterest.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisPointOfInterest(
      transcriptItems: (json['TranscriptItems'] as List?)
          ?.nonNulls
          .map((e) => RealTimeContactAnalysisTranscriptItemWithCharacterOffsets
              .fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final transcriptItems = this.transcriptItems;
    return {
      if (transcriptItems != null) 'TranscriptItems': transcriptItems,
    };
  }
}

/// Segment containing list of attachments.
class RealTimeContactAnalysisSegmentAttachments {
  /// List of objects describing an individual attachment.
  final List<RealTimeContactAnalysisAttachment> attachments;

  /// The identifier of the segment.
  final String id;

  /// The identifier of the participant.
  final String participantId;

  /// The role of the participant. For example, is it a customer, agent, or
  /// system.
  final ParticipantRole participantRole;

  /// Field describing the time of the event. It can have different
  /// representations of time.
  final RealTimeContactAnalysisTimeData time;

  /// The display name of the participant. Can be redacted.
  final String? displayName;

  RealTimeContactAnalysisSegmentAttachments({
    required this.attachments,
    required this.id,
    required this.participantId,
    required this.participantRole,
    required this.time,
    this.displayName,
  });

  factory RealTimeContactAnalysisSegmentAttachments.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisSegmentAttachments(
      attachments: (json['Attachments'] as List)
          .nonNulls
          .map((e) => RealTimeContactAnalysisAttachment.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      id: json['Id'] as String,
      participantId: json['ParticipantId'] as String,
      participantRole:
          ParticipantRole.fromString((json['ParticipantRole'] as String)),
      time: RealTimeContactAnalysisTimeData.fromJson(
          json['Time'] as Map<String, dynamic>),
      displayName: json['DisplayName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachments = this.attachments;
    final id = this.id;
    final participantId = this.participantId;
    final participantRole = this.participantRole;
    final time = this.time;
    final displayName = this.displayName;
    return {
      'Attachments': attachments,
      'Id': id,
      'ParticipantId': participantId,
      'ParticipantRole': participantRole.value,
      'Time': time,
      if (displayName != null) 'DisplayName': displayName,
    };
  }
}

/// The matched category rules.
class RealTimeContactAnalysisSegmentCategories {
  /// Map between the name of the matched rule and
  /// RealTimeContactAnalysisCategoryDetails.
  final Map<String, RealTimeContactAnalysisCategoryDetails> matchedDetails;

  RealTimeContactAnalysisSegmentCategories({
    required this.matchedDetails,
  });

  factory RealTimeContactAnalysisSegmentCategories.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisSegmentCategories(
      matchedDetails: (json['MatchedDetails'] as Map<String, dynamic>).map(
          (k, e) => MapEntry(
              k,
              RealTimeContactAnalysisCategoryDetails.fromJson(
                  e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final matchedDetails = this.matchedDetails;
    return {
      'MatchedDetails': matchedDetails,
    };
  }
}

/// Segment type describing a contact event.
class RealTimeContactAnalysisSegmentEvent {
  /// Type of the event. For example,
  /// <code>application/vnd.amazonaws.connect.event.participant.left</code>.
  final String eventType;

  /// The identifier of the contact event.
  final String id;

  /// Field describing the time of the event. It can have different
  /// representations of time.
  final RealTimeContactAnalysisTimeData time;

  /// The display name of the participant. Can be redacted.
  final String? displayName;

  /// The identifier of the participant.
  final String? participantId;

  /// The role of the participant. For example, is it a customer, agent, or
  /// system.
  final ParticipantRole? participantRole;

  RealTimeContactAnalysisSegmentEvent({
    required this.eventType,
    required this.id,
    required this.time,
    this.displayName,
    this.participantId,
    this.participantRole,
  });

  factory RealTimeContactAnalysisSegmentEvent.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisSegmentEvent(
      eventType: json['EventType'] as String,
      id: json['Id'] as String,
      time: RealTimeContactAnalysisTimeData.fromJson(
          json['Time'] as Map<String, dynamic>),
      displayName: json['DisplayName'] as String?,
      participantId: json['ParticipantId'] as String?,
      participantRole:
          (json['ParticipantRole'] as String?)?.let(ParticipantRole.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final eventType = this.eventType;
    final id = this.id;
    final time = this.time;
    final displayName = this.displayName;
    final participantId = this.participantId;
    final participantRole = this.participantRole;
    return {
      'EventType': eventType,
      'Id': id,
      'Time': time,
      if (displayName != null) 'DisplayName': displayName,
      if (participantId != null) 'ParticipantId': participantId,
      if (participantRole != null) 'ParticipantRole': participantRole.value,
    };
  }
}

/// Segment type containing a list of detected issues.
class RealTimeContactAnalysisSegmentIssues {
  /// List of the issues detected.
  final List<RealTimeContactAnalysisIssueDetected> issuesDetected;

  RealTimeContactAnalysisSegmentIssues({
    required this.issuesDetected,
  });

  factory RealTimeContactAnalysisSegmentIssues.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisSegmentIssues(
      issuesDetected: (json['IssuesDetected'] as List)
          .nonNulls
          .map((e) => RealTimeContactAnalysisIssueDetected.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final issuesDetected = this.issuesDetected;
    return {
      'IssuesDetected': issuesDetected,
    };
  }
}

/// The analyzed transcript segment.
class RealTimeContactAnalysisSegmentTranscript {
  /// The content of the transcript. Can be redacted.
  final String content;

  /// The identifier of the transcript.
  final String id;

  /// The identifier of the participant.
  final String participantId;

  /// The role of the participant. For example, is it a customer, agent, or
  /// system.
  final ParticipantRole participantRole;

  /// Field describing the time of the event. It can have different
  /// representations of time.
  final RealTimeContactAnalysisTimeData time;

  /// The type of content of the item. For example, <code>text/plain</code>.
  final String? contentType;

  /// The display name of the participant.
  final String? displayName;

  /// Object describing redaction that was applied to the transcript. If
  /// transcript has the field it means part of the transcript was redacted.
  final RealTimeContactAnalysisTranscriptItemRedaction? redaction;

  /// The sentiment detected for this piece of transcript.
  final RealTimeContactAnalysisSentimentLabel? sentiment;

  RealTimeContactAnalysisSegmentTranscript({
    required this.content,
    required this.id,
    required this.participantId,
    required this.participantRole,
    required this.time,
    this.contentType,
    this.displayName,
    this.redaction,
    this.sentiment,
  });

  factory RealTimeContactAnalysisSegmentTranscript.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisSegmentTranscript(
      content: json['Content'] as String,
      id: json['Id'] as String,
      participantId: json['ParticipantId'] as String,
      participantRole:
          ParticipantRole.fromString((json['ParticipantRole'] as String)),
      time: RealTimeContactAnalysisTimeData.fromJson(
          json['Time'] as Map<String, dynamic>),
      contentType: json['ContentType'] as String?,
      displayName: json['DisplayName'] as String?,
      redaction: json['Redaction'] != null
          ? RealTimeContactAnalysisTranscriptItemRedaction.fromJson(
              json['Redaction'] as Map<String, dynamic>)
          : null,
      sentiment: (json['Sentiment'] as String?)
          ?.let(RealTimeContactAnalysisSentimentLabel.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final content = this.content;
    final id = this.id;
    final participantId = this.participantId;
    final participantRole = this.participantRole;
    final time = this.time;
    final contentType = this.contentType;
    final displayName = this.displayName;
    final redaction = this.redaction;
    final sentiment = this.sentiment;
    return {
      'Content': content,
      'Id': id,
      'ParticipantId': participantId,
      'ParticipantRole': participantRole.value,
      'Time': time,
      if (contentType != null) 'ContentType': contentType,
      if (displayName != null) 'DisplayName': displayName,
      if (redaction != null) 'Redaction': redaction,
      if (sentiment != null) 'Sentiment': sentiment.value,
    };
  }
}

enum RealTimeContactAnalysisSegmentType {
  transcript('Transcript'),
  categories('Categories'),
  issues('Issues'),
  event('Event'),
  attachments('Attachments'),
  ;

  final String value;

  const RealTimeContactAnalysisSegmentType(this.value);

  static RealTimeContactAnalysisSegmentType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RealTimeContactAnalysisSegmentType'));
}

enum RealTimeContactAnalysisSentimentLabel {
  positive('POSITIVE'),
  negative('NEGATIVE'),
  neutral('NEUTRAL'),
  ;

  final String value;

  const RealTimeContactAnalysisSentimentLabel(this.value);

  static RealTimeContactAnalysisSentimentLabel fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RealTimeContactAnalysisSentimentLabel'));
}

enum RealTimeContactAnalysisStatus {
  inProgress('IN_PROGRESS'),
  failed('FAILED'),
  completed('COMPLETED'),
  ;

  final String value;

  const RealTimeContactAnalysisStatus(this.value);

  static RealTimeContactAnalysisStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RealTimeContactAnalysisStatus'));
}

enum RealTimeContactAnalysisSupportedChannel {
  voice('VOICE'),
  chat('CHAT'),
  ;

  final String value;

  const RealTimeContactAnalysisSupportedChannel(this.value);

  static RealTimeContactAnalysisSupportedChannel fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RealTimeContactAnalysisSupportedChannel'));
}

/// Object describing time with which the segment is associated. It can have
/// different representations of time. Currently supported: absoluteTime
class RealTimeContactAnalysisTimeData {
  /// Time represented in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example,
  /// 2019-11-08T02:41:28.172Z.
  final DateTime? absoluteTime;

  RealTimeContactAnalysisTimeData({
    this.absoluteTime,
  });

  factory RealTimeContactAnalysisTimeData.fromJson(Map<String, dynamic> json) {
    return RealTimeContactAnalysisTimeData(
      absoluteTime: timeStampFromJson(json['AbsoluteTime']),
    );
  }

  Map<String, dynamic> toJson() {
    final absoluteTime = this.absoluteTime;
    return {
      if (absoluteTime != null) 'AbsoluteTime': iso8601ToJson(absoluteTime),
    };
  }
}

/// Object describing redaction applied to the segment.
class RealTimeContactAnalysisTranscriptItemRedaction {
  /// List of character intervals each describing a part of the text that was
  /// redacted. For <code>OutputType.Raw</code>, part of the original text that
  /// contains data that can be redacted. For <code> OutputType.Redacted</code>,
  /// part of the string with redaction tag.
  final List<RealTimeContactAnalysisCharacterInterval>? characterOffsets;

  RealTimeContactAnalysisTranscriptItemRedaction({
    this.characterOffsets,
  });

  factory RealTimeContactAnalysisTranscriptItemRedaction.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisTranscriptItemRedaction(
      characterOffsets: (json['CharacterOffsets'] as List?)
          ?.nonNulls
          .map((e) => RealTimeContactAnalysisCharacterInterval.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final characterOffsets = this.characterOffsets;
    return {
      if (characterOffsets != null) 'CharacterOffsets': characterOffsets,
    };
  }
}

/// Transcript representation containing Id and list of character intervals that
/// are associated with analysis data. For example, this object within a
/// <code>RealTimeContactAnalysisPointOfInterest</code> in
/// <code>Category.MatchedDetails</code> would have character interval
/// describing part of the text that matched category.
class RealTimeContactAnalysisTranscriptItemWithCharacterOffsets {
  /// Transcript identifier. Matches the identifier from one of the
  /// TranscriptSegments.
  final String id;

  /// List of character intervals within transcript content/text.
  final RealTimeContactAnalysisCharacterInterval? characterOffsets;

  RealTimeContactAnalysisTranscriptItemWithCharacterOffsets({
    required this.id,
    this.characterOffsets,
  });

  factory RealTimeContactAnalysisTranscriptItemWithCharacterOffsets.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisTranscriptItemWithCharacterOffsets(
      id: json['Id'] as String,
      characterOffsets: json['CharacterOffsets'] != null
          ? RealTimeContactAnalysisCharacterInterval.fromJson(
              json['CharacterOffsets'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final characterOffsets = this.characterOffsets;
    return {
      'Id': id,
      if (characterOffsets != null) 'CharacterOffsets': characterOffsets,
    };
  }
}

/// Transcript representation containing Id, Content and list of character
/// intervals that are associated with analysis data. For example, this object
/// within an issue detected would describe both content that contains
/// identified issue and intervals where that content is taken from.
class RealTimeContactAnalysisTranscriptItemWithContent {
  /// Transcript identifier. Matches the identifier from one of the
  /// TranscriptSegments.
  final String id;
  final RealTimeContactAnalysisCharacterInterval? characterOffsets;

  /// Part of the transcript content that contains identified issue. Can be
  /// redacted
  final String? content;

  RealTimeContactAnalysisTranscriptItemWithContent({
    required this.id,
    this.characterOffsets,
    this.content,
  });

  factory RealTimeContactAnalysisTranscriptItemWithContent.fromJson(
      Map<String, dynamic> json) {
    return RealTimeContactAnalysisTranscriptItemWithContent(
      id: json['Id'] as String,
      characterOffsets: json['CharacterOffsets'] != null
          ? RealTimeContactAnalysisCharacterInterval.fromJson(
              json['CharacterOffsets'] as Map<String, dynamic>)
          : null,
      content: json['Content'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final characterOffsets = this.characterOffsets;
    final content = this.content;
    return {
      'Id': id,
      if (characterOffsets != null) 'CharacterOffsets': characterOffsets,
      if (content != null) 'Content': content,
    };
  }
}

/// An analyzed segment for a real-time analysis session.
class RealtimeContactAnalysisSegment {
  /// The analyzed attachments.
  final RealTimeContactAnalysisSegmentAttachments? attachments;
  final RealTimeContactAnalysisSegmentCategories? categories;
  final RealTimeContactAnalysisSegmentEvent? event;
  final RealTimeContactAnalysisSegmentIssues? issues;
  final RealTimeContactAnalysisSegmentTranscript? transcript;

  RealtimeContactAnalysisSegment({
    this.attachments,
    this.categories,
    this.event,
    this.issues,
    this.transcript,
  });

  factory RealtimeContactAnalysisSegment.fromJson(Map<String, dynamic> json) {
    return RealtimeContactAnalysisSegment(
      attachments: json['Attachments'] != null
          ? RealTimeContactAnalysisSegmentAttachments.fromJson(
              json['Attachments'] as Map<String, dynamic>)
          : null,
      categories: json['Categories'] != null
          ? RealTimeContactAnalysisSegmentCategories.fromJson(
              json['Categories'] as Map<String, dynamic>)
          : null,
      event: json['Event'] != null
          ? RealTimeContactAnalysisSegmentEvent.fromJson(
              json['Event'] as Map<String, dynamic>)
          : null,
      issues: json['Issues'] != null
          ? RealTimeContactAnalysisSegmentIssues.fromJson(
              json['Issues'] as Map<String, dynamic>)
          : null,
      transcript: json['Transcript'] != null
          ? RealTimeContactAnalysisSegmentTranscript.fromJson(
              json['Transcript'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final attachments = this.attachments;
    final categories = this.categories;
    final event = this.event;
    final issues = this.issues;
    final transcript = this.transcript;
    return {
      if (attachments != null) 'Attachments': attachments,
      if (categories != null) 'Categories': categories,
      if (event != null) 'Event': event,
      if (issues != null) 'Issues': issues,
      if (transcript != null) 'Transcript': transcript,
    };
  }
}

/// Well-formed data on a contact, used by agents to complete a contact request.
/// You can have up to 4,096 UTF-8 bytes across all references for a contact.
class Reference {
  /// The type of the reference. <code>DATE</code> must be of type Epoch
  /// timestamp.
  final ReferenceType type;

  /// A valid value for the reference. For example, for a URL reference, a
  /// formatted URL that is displayed to an agent in the Contact Control Panel
  /// (CCP).
  final String value;

  Reference({
    required this.type,
    required this.value,
  });

  factory Reference.fromJson(Map<String, dynamic> json) {
    return Reference(
      type: ReferenceType.fromString((json['Type'] as String)),
      value: json['Value'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    final value = this.value;
    return {
      'Type': type.value,
      'Value': value,
    };
  }
}

enum ReferenceStatus {
  approved('APPROVED'),
  rejected('REJECTED'),
  ;

  final String value;

  const ReferenceStatus(this.value);

  static ReferenceStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ReferenceStatus'));
}

/// Contains summary information about a reference.
/// <code>ReferenceSummary</code> contains only one non null field between the
/// URL and attachment based on the reference type.
class ReferenceSummary {
  /// Information about the reference when the <code>referenceType</code> is
  /// <code>ATTACHMENT</code>. Otherwise, null.
  final AttachmentReference? attachment;

  /// Information about a reference when the <code>referenceType</code> is
  /// <code>DATE</code>. Otherwise, null.
  final DateReference? date;

  /// Information about a reference when the <code>referenceType</code> is
  /// <code>EMAIL</code>. Otherwise, null.
  final EmailReference? email;

  /// Information about a reference when the <code>referenceType</code> is
  /// <code>NUMBER</code>. Otherwise, null.
  final NumberReference? number;

  /// Information about a reference when the <code>referenceType</code> is
  /// <code>STRING</code>. Otherwise, null.
  final StringReference? string;

  /// Information about the reference when the <code>referenceType</code> is
  /// <code>URL</code>. Otherwise, null.
  final UrlReference? url;

  ReferenceSummary({
    this.attachment,
    this.date,
    this.email,
    this.number,
    this.string,
    this.url,
  });

  factory ReferenceSummary.fromJson(Map<String, dynamic> json) {
    return ReferenceSummary(
      attachment: json['Attachment'] != null
          ? AttachmentReference.fromJson(
              json['Attachment'] as Map<String, dynamic>)
          : null,
      date: json['Date'] != null
          ? DateReference.fromJson(json['Date'] as Map<String, dynamic>)
          : null,
      email: json['Email'] != null
          ? EmailReference.fromJson(json['Email'] as Map<String, dynamic>)
          : null,
      number: json['Number'] != null
          ? NumberReference.fromJson(json['Number'] as Map<String, dynamic>)
          : null,
      string: json['String'] != null
          ? StringReference.fromJson(json['String'] as Map<String, dynamic>)
          : null,
      url: json['Url'] != null
          ? UrlReference.fromJson(json['Url'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final attachment = this.attachment;
    final date = this.date;
    final email = this.email;
    final number = this.number;
    final string = this.string;
    final url = this.url;
    return {
      if (attachment != null) 'Attachment': attachment,
      if (date != null) 'Date': date,
      if (email != null) 'Email': email,
      if (number != null) 'Number': number,
      if (string != null) 'String': string,
      if (url != null) 'Url': url,
    };
  }
}

enum ReferenceType {
  url('URL'),
  attachment('ATTACHMENT'),
  number('NUMBER'),
  string('STRING'),
  date('DATE'),
  email('EMAIL'),
  ;

  final String value;

  const ReferenceType(this.value);

  static ReferenceType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ReferenceType'));
}

enum RehydrationType {
  entirePastSession('ENTIRE_PAST_SESSION'),
  fromSegment('FROM_SEGMENT'),
  ;

  final String value;

  const RehydrationType(this.value);

  static RehydrationType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum RehydrationType'));
}

class ReplicateInstanceResponse {
  /// The Amazon Resource Name (ARN) of the replicated instance.
  final String? arn;

  /// The identifier of the replicated instance. You can find the
  /// <code>instanceId</code> in the ARN of the instance. The replicated instance
  /// has the same identifier as the instance it was replicated from.
  final String? id;

  ReplicateInstanceResponse({
    this.arn,
    this.id,
  });

  factory ReplicateInstanceResponse.fromJson(Map<String, dynamic> json) {
    return ReplicateInstanceResponse(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

/// Information about a required field.
class RequiredFieldInfo {
  /// The unique identifier for the field.
  final TaskTemplateFieldIdentifier? id;

  RequiredFieldInfo({
    this.id,
  });

  factory RequiredFieldInfo.fromJson(Map<String, dynamic> json) {
    return RequiredFieldInfo(
      id: json['Id'] != null
          ? TaskTemplateFieldIdentifier.fromJson(
              json['Id'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    return {
      if (id != null) 'Id': id,
    };
  }
}

/// The search criteria to be used to search tags.
class ResourceTagsSearchCriteria {
  /// The search criteria to be used to return tags.
  final TagSearchCondition? tagSearchCondition;

  ResourceTagsSearchCriteria({
    this.tagSearchCondition,
  });

  Map<String, dynamic> toJson() {
    final tagSearchCondition = this.tagSearchCondition;
    return {
      if (tagSearchCondition != null) 'TagSearchCondition': tagSearchCondition,
    };
  }
}

class ResumeContactRecordingResponse {
  ResumeContactRecordingResponse();

  factory ResumeContactRecordingResponse.fromJson(Map<String, dynamic> _) {
    return ResumeContactRecordingResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class ResumeContactResponse {
  ResumeContactResponse();

  factory ResumeContactResponse.fromJson(Map<String, dynamic> _) {
    return ResumeContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Latest routing criteria on the contact.
class RoutingCriteria {
  /// The timestamp indicating when the routing criteria is set to active. A
  /// routing criteria is activated when contact is transferred to a queue.
  /// ActivationTimestamp will be set on routing criteria for contacts in agent
  /// queue even though Routing criteria is never activated for contacts in agent
  /// queue.
  final DateTime? activationTimestamp;

  /// Information about the index of the routing criteria.
  final int? index;

  /// List of routing steps. When Amazon Connect does not find an available agent
  /// meeting the requirements in a step for a given step duration, the routing
  /// criteria will move on to the next step sequentially until a join is
  /// completed with an agent. When all steps are exhausted, the contact will be
  /// offered to any agent in the queue.
  final List<Step>? steps;

  RoutingCriteria({
    this.activationTimestamp,
    this.index,
    this.steps,
  });

  factory RoutingCriteria.fromJson(Map<String, dynamic> json) {
    return RoutingCriteria(
      activationTimestamp: timeStampFromJson(json['ActivationTimestamp']),
      index: json['Index'] as int?,
      steps: (json['Steps'] as List?)
          ?.nonNulls
          .map((e) => Step.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final activationTimestamp = this.activationTimestamp;
    final index = this.index;
    final steps = this.steps;
    return {
      if (activationTimestamp != null)
        'ActivationTimestamp': unixTimestampToJson(activationTimestamp),
      if (index != null) 'Index': index,
      if (steps != null) 'Steps': steps,
    };
  }
}

enum RoutingCriteriaStepStatus {
  active('ACTIVE'),
  inactive('INACTIVE'),
  joined('JOINED'),
  expired('EXPIRED'),
  ;

  final String value;

  const RoutingCriteriaStepStatus(this.value);

  static RoutingCriteriaStepStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RoutingCriteriaStepStatus'));
}

/// Contains information about a routing profile.
class RoutingProfile {
  /// Whether agents with this routing profile will have their routing order
  /// calculated based on <i>time since their last inbound contact</i> or
  /// <i>longest idle time</i>.
  final AgentAvailabilityTimer? agentAvailabilityTimer;

  /// The IDs of the associated queue.
  final List<String>? associatedQueueIds;

  /// The identifier of the default outbound queue for this routing profile.
  final String? defaultOutboundQueueId;

  /// The description of the routing profile.
  final String? description;

  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? instanceId;

  /// Whether this a default routing profile.
  final bool? isDefault;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The channels agents can handle in the Contact Control Panel (CCP) for this
  /// routing profile.
  final List<MediaConcurrency>? mediaConcurrencies;

  /// The name of the routing profile.
  final String? name;

  /// The number of associated queues in routing profile.
  final int? numberOfAssociatedQueues;

  /// The number of associated users in routing profile.
  final int? numberOfAssociatedUsers;

  /// The Amazon Resource Name (ARN) of the routing profile.
  final String? routingProfileArn;

  /// The identifier of the routing profile.
  final String? routingProfileId;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  RoutingProfile({
    this.agentAvailabilityTimer,
    this.associatedQueueIds,
    this.defaultOutboundQueueId,
    this.description,
    this.instanceId,
    this.isDefault,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.mediaConcurrencies,
    this.name,
    this.numberOfAssociatedQueues,
    this.numberOfAssociatedUsers,
    this.routingProfileArn,
    this.routingProfileId,
    this.tags,
  });

  factory RoutingProfile.fromJson(Map<String, dynamic> json) {
    return RoutingProfile(
      agentAvailabilityTimer: (json['AgentAvailabilityTimer'] as String?)
          ?.let(AgentAvailabilityTimer.fromString),
      associatedQueueIds: (json['AssociatedQueueIds'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      defaultOutboundQueueId: json['DefaultOutboundQueueId'] as String?,
      description: json['Description'] as String?,
      instanceId: json['InstanceId'] as String?,
      isDefault: json['IsDefault'] as bool?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      mediaConcurrencies: (json['MediaConcurrencies'] as List?)
          ?.nonNulls
          .map((e) => MediaConcurrency.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      numberOfAssociatedQueues: json['NumberOfAssociatedQueues'] as int?,
      numberOfAssociatedUsers: json['NumberOfAssociatedUsers'] as int?,
      routingProfileArn: json['RoutingProfileArn'] as String?,
      routingProfileId: json['RoutingProfileId'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final agentAvailabilityTimer = this.agentAvailabilityTimer;
    final associatedQueueIds = this.associatedQueueIds;
    final defaultOutboundQueueId = this.defaultOutboundQueueId;
    final description = this.description;
    final instanceId = this.instanceId;
    final isDefault = this.isDefault;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final mediaConcurrencies = this.mediaConcurrencies;
    final name = this.name;
    final numberOfAssociatedQueues = this.numberOfAssociatedQueues;
    final numberOfAssociatedUsers = this.numberOfAssociatedUsers;
    final routingProfileArn = this.routingProfileArn;
    final routingProfileId = this.routingProfileId;
    final tags = this.tags;
    return {
      if (agentAvailabilityTimer != null)
        'AgentAvailabilityTimer': agentAvailabilityTimer.value,
      if (associatedQueueIds != null) 'AssociatedQueueIds': associatedQueueIds,
      if (defaultOutboundQueueId != null)
        'DefaultOutboundQueueId': defaultOutboundQueueId,
      if (description != null) 'Description': description,
      if (instanceId != null) 'InstanceId': instanceId,
      if (isDefault != null) 'IsDefault': isDefault,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (mediaConcurrencies != null) 'MediaConcurrencies': mediaConcurrencies,
      if (name != null) 'Name': name,
      if (numberOfAssociatedQueues != null)
        'NumberOfAssociatedQueues': numberOfAssociatedQueues,
      if (numberOfAssociatedUsers != null)
        'NumberOfAssociatedUsers': numberOfAssociatedUsers,
      if (routingProfileArn != null) 'RoutingProfileArn': routingProfileArn,
      if (routingProfileId != null) 'RoutingProfileId': routingProfileId,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Contains information about the queue and channel for which priority and
/// delay can be set.
class RoutingProfileQueueConfig {
  /// The delay, in seconds, a contact should be in the queue before they are
  /// routed to an available agent. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues:
  /// priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.
  final int delay;

  /// The order in which contacts are to be handled for the queue. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues:
  /// priority and delay</a>.
  final int priority;

  /// Contains information about a queue resource.
  final RoutingProfileQueueReference queueReference;

  RoutingProfileQueueConfig({
    required this.delay,
    required this.priority,
    required this.queueReference,
  });

  Map<String, dynamic> toJson() {
    final delay = this.delay;
    final priority = this.priority;
    final queueReference = this.queueReference;
    return {
      'Delay': delay,
      'Priority': priority,
      'QueueReference': queueReference,
    };
  }
}

/// Contains summary information about a routing profile queue.
class RoutingProfileQueueConfigSummary {
  /// The channels this queue supports.
  final Channel channel;

  /// The delay, in seconds, that a contact should be in the queue before they are
  /// routed to an available agent. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues:
  /// priority and delay</a> in the <i>Amazon Connect Administrator Guide</i>.
  final int delay;

  /// The order in which contacts are to be handled for the queue. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/concepts-routing-profiles-priority.html">Queues:
  /// priority and delay</a>.
  final int priority;

  /// The Amazon Resource Name (ARN) of the queue.
  final String queueArn;

  /// The identifier for the queue.
  final String queueId;

  /// The name of the queue.
  final String queueName;

  RoutingProfileQueueConfigSummary({
    required this.channel,
    required this.delay,
    required this.priority,
    required this.queueArn,
    required this.queueId,
    required this.queueName,
  });

  factory RoutingProfileQueueConfigSummary.fromJson(Map<String, dynamic> json) {
    return RoutingProfileQueueConfigSummary(
      channel: Channel.fromString((json['Channel'] as String)),
      delay: json['Delay'] as int,
      priority: json['Priority'] as int,
      queueArn: json['QueueArn'] as String,
      queueId: json['QueueId'] as String,
      queueName: json['QueueName'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final channel = this.channel;
    final delay = this.delay;
    final priority = this.priority;
    final queueArn = this.queueArn;
    final queueId = this.queueId;
    final queueName = this.queueName;
    return {
      'Channel': channel.value,
      'Delay': delay,
      'Priority': priority,
      'QueueArn': queueArn,
      'QueueId': queueId,
      'QueueName': queueName,
    };
  }
}

/// Contains the channel and queue identifier for a routing profile.
class RoutingProfileQueueReference {
  /// The channels agents can handle in the Contact Control Panel (CCP) for this
  /// routing profile.
  final Channel channel;

  /// The identifier for the queue.
  final String queueId;

  RoutingProfileQueueReference({
    required this.channel,
    required this.queueId,
  });

  Map<String, dynamic> toJson() {
    final channel = this.channel;
    final queueId = this.queueId;
    return {
      'Channel': channel.value,
      'QueueId': queueId,
    };
  }
}

/// Information about the routing profile assigned to the user.
class RoutingProfileReference {
  /// The Amazon Resource Name (ARN) of the routing profile.
  final String? arn;

  /// The identifier of the routing profile.
  final String? id;

  RoutingProfileReference({
    this.arn,
    this.id,
  });

  factory RoutingProfileReference.fromJson(Map<String, dynamic> json) {
    return RoutingProfileReference(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

/// The search criteria to be used to return routing profiles.
/// <note>
/// The <code>name</code> and <code>description</code> fields support "contains"
/// queries with a minimum of 2 characters and a maximum of 25 characters. Any
/// queries with character lengths outside of this range will throw invalid
/// results.
/// </note>
class RoutingProfileSearchCriteria {
  /// A list of conditions which would be applied together with an AND condition.
  final List<RoutingProfileSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an OR condition.
  final List<RoutingProfileSearchCriteria>? orConditions;

  /// A leaf node condition which can be used to specify a string condition.
  /// <note>
  /// The currently supported values for <code>FieldName</code> are
  /// <code>associatedQueueIds</code>, <code>name</code>,
  /// <code>description</code>, and <code>resourceID</code>.
  /// </note>
  final StringCondition? stringCondition;

  RoutingProfileSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Filters to be applied to search results.
class RoutingProfileSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  RoutingProfileSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

/// Contains summary information about a routing profile.
class RoutingProfileSummary {
  /// The Amazon Resource Name (ARN) of the routing profile.
  final String? arn;

  /// The identifier of the routing profile.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the routing profile.
  final String? name;

  RoutingProfileSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory RoutingProfileSummary.fromJson(Map<String, dynamic> json) {
    return RoutingProfileSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

/// Information about a rule.
class Rule {
  /// A list of actions to be run when the rule is triggered.
  final List<RuleAction> actions;

  /// The timestamp for when the rule was created.
  final DateTime createdTime;

  /// The conditions of the rule.
  final String function;

  /// The Amazon Resource Name (ARN) of the user who last updated the rule.
  final String lastUpdatedBy;

  /// The timestamp for the when the rule was last updated.
  final DateTime lastUpdatedTime;

  /// The name of the rule.
  final String name;

  /// The publish status of the rule.
  final RulePublishStatus publishStatus;

  /// The Amazon Resource Name (ARN) of the rule.
  final String ruleArn;

  /// A unique identifier for the rule.
  final String ruleId;

  /// The event source to trigger the rule.
  final RuleTriggerEventSource triggerEventSource;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  Rule({
    required this.actions,
    required this.createdTime,
    required this.function,
    required this.lastUpdatedBy,
    required this.lastUpdatedTime,
    required this.name,
    required this.publishStatus,
    required this.ruleArn,
    required this.ruleId,
    required this.triggerEventSource,
    this.tags,
  });

  factory Rule.fromJson(Map<String, dynamic> json) {
    return Rule(
      actions: (json['Actions'] as List)
          .nonNulls
          .map((e) => RuleAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      function: json['Function'] as String,
      lastUpdatedBy: json['LastUpdatedBy'] as String,
      lastUpdatedTime:
          nonNullableTimeStampFromJson(json['LastUpdatedTime'] as Object),
      name: json['Name'] as String,
      publishStatus:
          RulePublishStatus.fromString((json['PublishStatus'] as String)),
      ruleArn: json['RuleArn'] as String,
      ruleId: json['RuleId'] as String,
      triggerEventSource: RuleTriggerEventSource.fromJson(
          json['TriggerEventSource'] as Map<String, dynamic>),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final createdTime = this.createdTime;
    final function = this.function;
    final lastUpdatedBy = this.lastUpdatedBy;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final publishStatus = this.publishStatus;
    final ruleArn = this.ruleArn;
    final ruleId = this.ruleId;
    final triggerEventSource = this.triggerEventSource;
    final tags = this.tags;
    return {
      'Actions': actions,
      'CreatedTime': unixTimestampToJson(createdTime),
      'Function': function,
      'LastUpdatedBy': lastUpdatedBy,
      'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      'Name': name,
      'PublishStatus': publishStatus.value,
      'RuleArn': ruleArn,
      'RuleId': ruleId,
      'TriggerEventSource': triggerEventSource,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Information about the action to be performed when a rule is triggered.
class RuleAction {
  /// The type of action that creates a rule.
  final ActionType actionType;

  /// Information about the contact category action.
  ///
  /// Supported only for <code>TriggerEventSource</code> values:
  /// <code>OnPostCallAnalysisAvailable</code> |
  /// <code>OnRealTimeCallAnalysisAvailable</code> |
  /// <code>OnRealTimeChatAnalysisAvailable</code> |
  /// <code>OnPostChatAnalysisAvailable</code> |
  /// <code>OnZendeskTicketCreate</code> |
  /// <code>OnZendeskTicketStatusUpdate</code> |
  /// <code>OnSalesforceCaseCreate</code>
  final AssignContactCategoryActionDefinition? assignContactCategoryAction;

  /// Information about the create case action.
  ///
  /// Supported only for <code>TriggerEventSource</code> values:
  /// <code>OnPostCallAnalysisAvailable</code> |
  /// <code>OnPostChatAnalysisAvailable</code>.
  final CreateCaseActionDefinition? createCaseAction;

  /// Information about the end associated tasks action.
  ///
  /// Supported only for <code>TriggerEventSource</code> values:
  /// <code>OnCaseUpdate</code>.
  final EndAssociatedTasksActionDefinition? endAssociatedTasksAction;

  /// Information about the EventBridge action.
  ///
  /// Supported only for <code>TriggerEventSource</code> values:
  /// <code>OnPostCallAnalysisAvailable</code> |
  /// <code>OnRealTimeCallAnalysisAvailable</code> |
  /// <code>OnRealTimeChatAnalysisAvailable</code> |
  /// <code>OnPostChatAnalysisAvailable</code> |
  /// <code>OnContactEvaluationSubmit</code> | <code>OnMetricDataUpdate</code>
  final EventBridgeActionDefinition? eventBridgeAction;

  /// Information about the send notification action.
  ///
  /// Supported only for <code>TriggerEventSource</code> values:
  /// <code>OnPostCallAnalysisAvailable</code> |
  /// <code>OnRealTimeCallAnalysisAvailable</code> |
  /// <code>OnRealTimeChatAnalysisAvailable</code> |
  /// <code>OnPostChatAnalysisAvailable</code> |
  /// <code>OnContactEvaluationSubmit</code> | <code>OnMetricDataUpdate</code>
  final SendNotificationActionDefinition? sendNotificationAction;

  /// Information about the submit automated evaluation action.
  final SubmitAutoEvaluationActionDefinition? submitAutoEvaluationAction;

  /// Information about the task action. This field is required if
  /// <code>TriggerEventSource</code> is one of the following values:
  /// <code>OnZendeskTicketCreate</code> |
  /// <code>OnZendeskTicketStatusUpdate</code> |
  /// <code>OnSalesforceCaseCreate</code>
  final TaskActionDefinition? taskAction;

  /// Information about the update case action.
  ///
  /// Supported only for <code>TriggerEventSource</code> values:
  /// <code>OnCaseCreate</code> | <code>OnCaseUpdate</code>.
  final UpdateCaseActionDefinition? updateCaseAction;

  RuleAction({
    required this.actionType,
    this.assignContactCategoryAction,
    this.createCaseAction,
    this.endAssociatedTasksAction,
    this.eventBridgeAction,
    this.sendNotificationAction,
    this.submitAutoEvaluationAction,
    this.taskAction,
    this.updateCaseAction,
  });

  factory RuleAction.fromJson(Map<String, dynamic> json) {
    return RuleAction(
      actionType: ActionType.fromString((json['ActionType'] as String)),
      assignContactCategoryAction: json['AssignContactCategoryAction'] != null
          ? AssignContactCategoryActionDefinition.fromJson(
              json['AssignContactCategoryAction'] as Map<String, dynamic>)
          : null,
      createCaseAction: json['CreateCaseAction'] != null
          ? CreateCaseActionDefinition.fromJson(
              json['CreateCaseAction'] as Map<String, dynamic>)
          : null,
      endAssociatedTasksAction: json['EndAssociatedTasksAction'] != null
          ? EndAssociatedTasksActionDefinition.fromJson(
              json['EndAssociatedTasksAction'] as Map<String, dynamic>)
          : null,
      eventBridgeAction: json['EventBridgeAction'] != null
          ? EventBridgeActionDefinition.fromJson(
              json['EventBridgeAction'] as Map<String, dynamic>)
          : null,
      sendNotificationAction: json['SendNotificationAction'] != null
          ? SendNotificationActionDefinition.fromJson(
              json['SendNotificationAction'] as Map<String, dynamic>)
          : null,
      submitAutoEvaluationAction: json['SubmitAutoEvaluationAction'] != null
          ? SubmitAutoEvaluationActionDefinition.fromJson(
              json['SubmitAutoEvaluationAction'] as Map<String, dynamic>)
          : null,
      taskAction: json['TaskAction'] != null
          ? TaskActionDefinition.fromJson(
              json['TaskAction'] as Map<String, dynamic>)
          : null,
      updateCaseAction: json['UpdateCaseAction'] != null
          ? UpdateCaseActionDefinition.fromJson(
              json['UpdateCaseAction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final actionType = this.actionType;
    final assignContactCategoryAction = this.assignContactCategoryAction;
    final createCaseAction = this.createCaseAction;
    final endAssociatedTasksAction = this.endAssociatedTasksAction;
    final eventBridgeAction = this.eventBridgeAction;
    final sendNotificationAction = this.sendNotificationAction;
    final submitAutoEvaluationAction = this.submitAutoEvaluationAction;
    final taskAction = this.taskAction;
    final updateCaseAction = this.updateCaseAction;
    return {
      'ActionType': actionType.value,
      if (assignContactCategoryAction != null)
        'AssignContactCategoryAction': assignContactCategoryAction,
      if (createCaseAction != null) 'CreateCaseAction': createCaseAction,
      if (endAssociatedTasksAction != null)
        'EndAssociatedTasksAction': endAssociatedTasksAction,
      if (eventBridgeAction != null) 'EventBridgeAction': eventBridgeAction,
      if (sendNotificationAction != null)
        'SendNotificationAction': sendNotificationAction,
      if (submitAutoEvaluationAction != null)
        'SubmitAutoEvaluationAction': submitAutoEvaluationAction,
      if (taskAction != null) 'TaskAction': taskAction,
      if (updateCaseAction != null) 'UpdateCaseAction': updateCaseAction,
    };
  }
}

enum RulePublishStatus {
  draft('DRAFT'),
  published('PUBLISHED'),
  ;

  final String value;

  const RulePublishStatus(this.value);

  static RulePublishStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum RulePublishStatus'));
}

/// A list of <code>ActionTypes</code> associated with a rule.
class RuleSummary {
  /// A list of ActionTypes associated with a rule.
  final List<ActionSummary> actionSummaries;

  /// The timestamp for when the rule was created.
  final DateTime createdTime;

  /// The name of the event source.
  final EventSourceName eventSourceName;

  /// The timestamp for when the rule was last updated.
  final DateTime lastUpdatedTime;

  /// The name of the rule.
  final String name;

  /// The publish status of the rule.
  final RulePublishStatus publishStatus;

  /// The Amazon Resource Name (ARN) of the rule.
  final String ruleArn;

  /// A unique identifier for the rule.
  final String ruleId;

  RuleSummary({
    required this.actionSummaries,
    required this.createdTime,
    required this.eventSourceName,
    required this.lastUpdatedTime,
    required this.name,
    required this.publishStatus,
    required this.ruleArn,
    required this.ruleId,
  });

  factory RuleSummary.fromJson(Map<String, dynamic> json) {
    return RuleSummary(
      actionSummaries: (json['ActionSummaries'] as List)
          .nonNulls
          .map((e) => ActionSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      eventSourceName:
          EventSourceName.fromString((json['EventSourceName'] as String)),
      lastUpdatedTime:
          nonNullableTimeStampFromJson(json['LastUpdatedTime'] as Object),
      name: json['Name'] as String,
      publishStatus:
          RulePublishStatus.fromString((json['PublishStatus'] as String)),
      ruleArn: json['RuleArn'] as String,
      ruleId: json['RuleId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final actionSummaries = this.actionSummaries;
    final createdTime = this.createdTime;
    final eventSourceName = this.eventSourceName;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final publishStatus = this.publishStatus;
    final ruleArn = this.ruleArn;
    final ruleId = this.ruleId;
    return {
      'ActionSummaries': actionSummaries,
      'CreatedTime': unixTimestampToJson(createdTime),
      'EventSourceName': eventSourceName.value,
      'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      'Name': name,
      'PublishStatus': publishStatus.value,
      'RuleArn': ruleArn,
      'RuleId': ruleId,
    };
  }
}

/// The name of the event source. This field is required if
/// <code>TriggerEventSource</code> is one of the following values:
/// <code>OnZendeskTicketCreate</code> |
/// <code>OnZendeskTicketStatusUpdate</code> |
/// <code>OnSalesforceCaseCreate</code> | <code>OnContactEvaluationSubmit</code>
/// | <code>OnMetricDataUpdate</code>.
class RuleTriggerEventSource {
  /// The name of the event source.
  final EventSourceName eventSourceName;

  /// The identifier for the integration association.
  final String? integrationAssociationId;

  RuleTriggerEventSource({
    required this.eventSourceName,
    this.integrationAssociationId,
  });

  factory RuleTriggerEventSource.fromJson(Map<String, dynamic> json) {
    return RuleTriggerEventSource(
      eventSourceName:
          EventSourceName.fromString((json['EventSourceName'] as String)),
      integrationAssociationId: json['IntegrationAssociationId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final eventSourceName = this.eventSourceName;
    final integrationAssociationId = this.integrationAssociationId;
    return {
      'EventSourceName': eventSourceName.value,
      if (integrationAssociationId != null)
        'IntegrationAssociationId': integrationAssociationId,
    };
  }
}

/// Information about the Amazon Simple Storage Service (Amazon S3) storage
/// type.
class S3Config {
  /// The S3 bucket name.
  final String bucketName;

  /// The S3 bucket prefix.
  final String bucketPrefix;

  /// The Amazon S3 encryption configuration.
  final EncryptionConfig? encryptionConfig;

  S3Config({
    required this.bucketName,
    required this.bucketPrefix,
    this.encryptionConfig,
  });

  factory S3Config.fromJson(Map<String, dynamic> json) {
    return S3Config(
      bucketName: json['BucketName'] as String,
      bucketPrefix: json['BucketPrefix'] as String,
      encryptionConfig: json['EncryptionConfig'] != null
          ? EncryptionConfig.fromJson(
              json['EncryptionConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final bucketName = this.bucketName;
    final bucketPrefix = this.bucketPrefix;
    final encryptionConfig = this.encryptionConfig;
    return {
      'BucketName': bucketName,
      'BucketPrefix': bucketPrefix,
      if (encryptionConfig != null) 'EncryptionConfig': encryptionConfig,
    };
  }
}

class SearchAvailablePhoneNumbersResponse {
  /// A list of available phone numbers that you can claim to your Amazon Connect
  /// instance or traffic distribution group.
  final List<AvailableNumberSummary>? availableNumbersList;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  SearchAvailablePhoneNumbersResponse({
    this.availableNumbersList,
    this.nextToken,
  });

  factory SearchAvailablePhoneNumbersResponse.fromJson(
      Map<String, dynamic> json) {
    return SearchAvailablePhoneNumbersResponse(
      availableNumbersList: (json['AvailableNumbersList'] as List?)
          ?.nonNulls
          .map(
              (e) => AvailableNumberSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final availableNumbersList = this.availableNumbersList;
    final nextToken = this.nextToken;
    return {
      if (availableNumbersList != null)
        'AvailableNumbersList': availableNumbersList,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class SearchContactFlowModulesResponse {
  /// The total number of contact flows which matched your search query.
  final int? approximateTotalCount;

  /// The search criteria to be used to return contact flow modules.
  final List<ContactFlowModule>? contactFlowModules;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  SearchContactFlowModulesResponse({
    this.approximateTotalCount,
    this.contactFlowModules,
    this.nextToken,
  });

  factory SearchContactFlowModulesResponse.fromJson(Map<String, dynamic> json) {
    return SearchContactFlowModulesResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      contactFlowModules: (json['ContactFlowModules'] as List?)
          ?.nonNulls
          .map((e) => ContactFlowModule.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final contactFlowModules = this.contactFlowModules;
    final nextToken = this.nextToken;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (contactFlowModules != null) 'ContactFlowModules': contactFlowModules,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class SearchContactFlowsResponse {
  /// The total number of contact flows which matched your search query.
  final int? approximateTotalCount;

  /// Information about the contact flows.
  final List<ContactFlow>? contactFlows;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  SearchContactFlowsResponse({
    this.approximateTotalCount,
    this.contactFlows,
    this.nextToken,
  });

  factory SearchContactFlowsResponse.fromJson(Map<String, dynamic> json) {
    return SearchContactFlowsResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      contactFlows: (json['ContactFlows'] as List?)
          ?.nonNulls
          .map((e) => ContactFlow.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final contactFlows = this.contactFlows;
    final nextToken = this.nextToken;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (contactFlows != null) 'ContactFlows': contactFlows,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

enum SearchContactsMatchType {
  matchAll('MATCH_ALL'),
  matchAny('MATCH_ANY'),
  ;

  final String value;

  const SearchContactsMatchType(this.value);

  static SearchContactsMatchType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum SearchContactsMatchType'));
}

class SearchContactsResponse {
  /// Information about the contacts.
  final List<ContactSearchSummary> contacts;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// The total number of contacts which matched your search query.
  final int? totalCount;

  SearchContactsResponse({
    required this.contacts,
    this.nextToken,
    this.totalCount,
  });

  factory SearchContactsResponse.fromJson(Map<String, dynamic> json) {
    return SearchContactsResponse(
      contacts: (json['Contacts'] as List)
          .nonNulls
          .map((e) => ContactSearchSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      totalCount: json['TotalCount'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final contacts = this.contacts;
    final nextToken = this.nextToken;
    final totalCount = this.totalCount;
    return {
      'Contacts': contacts,
      if (nextToken != null) 'NextToken': nextToken,
      if (totalCount != null) 'TotalCount': totalCount,
    };
  }
}

/// A structure of time range that you want to search results.
class SearchContactsTimeRange {
  /// The end time of the time range.
  final DateTime endTime;

  /// The start time of the time range.
  final DateTime startTime;

  /// The type of timestamp to search.
  final SearchContactsTimeRangeType type;

  SearchContactsTimeRange({
    required this.endTime,
    required this.startTime,
    required this.type,
  });

  Map<String, dynamic> toJson() {
    final endTime = this.endTime;
    final startTime = this.startTime;
    final type = this.type;
    return {
      'EndTime': unixTimestampToJson(endTime),
      'StartTime': unixTimestampToJson(startTime),
      'Type': type.value,
    };
  }
}

enum SearchContactsTimeRangeType {
  initiationTimestamp('INITIATION_TIMESTAMP'),
  scheduledTimestamp('SCHEDULED_TIMESTAMP'),
  connectedToAgentTimestamp('CONNECTED_TO_AGENT_TIMESTAMP'),
  disconnectTimestamp('DISCONNECT_TIMESTAMP'),
  ;

  final String value;

  const SearchContactsTimeRangeType(this.value);

  static SearchContactsTimeRangeType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum SearchContactsTimeRangeType'));
}

/// A structure of search criteria to be used to return contacts.
class SearchCriteria {
  /// The agent hierarchy groups of the agent at the time of handling the contact.
  final AgentHierarchyGroups? agentHierarchyGroups;

  /// The identifiers of agents who handled the contacts.
  final List<String>? agentIds;

  /// The list of channels associated with contacts.
  final List<Channel>? channels;

  /// Search criteria based on analysis outputs from Amazon Connect Contact Lens.
  final ContactAnalysis? contactAnalysis;

  /// The list of initiation methods associated with contacts.
  final List<ContactInitiationMethod>? initiationMethods;

  /// The list of queue IDs associated with contacts.
  final List<String>? queueIds;

  /// The search criteria based on user-defined contact attributes that have been
  /// configured for contact search. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/search-custom-attributes.html">Search
  /// by customer contact attributes</a> in the <i>Amazon Connect Administrator
  /// Guide</i>.
  /// <important>
  /// To use <code>SearchableContactAttributes</code> in a search request, the
  /// <code>GetContactAttributes</code> action is required to perform an API
  /// request. For more information, see <a
  /// href="https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-actions-as-permissions">https://docs.aws.amazon.com/service-authorization/latest/reference/list_amazonconnect.html#amazonconnect-actions-as-permissions</a>Actions
  /// defined by Amazon Connect.
  /// </important>
  final SearchableContactAttributes? searchableContactAttributes;

  SearchCriteria({
    this.agentHierarchyGroups,
    this.agentIds,
    this.channels,
    this.contactAnalysis,
    this.initiationMethods,
    this.queueIds,
    this.searchableContactAttributes,
  });

  Map<String, dynamic> toJson() {
    final agentHierarchyGroups = this.agentHierarchyGroups;
    final agentIds = this.agentIds;
    final channels = this.channels;
    final contactAnalysis = this.contactAnalysis;
    final initiationMethods = this.initiationMethods;
    final queueIds = this.queueIds;
    final searchableContactAttributes = this.searchableContactAttributes;
    return {
      if (agentHierarchyGroups != null)
        'AgentHierarchyGroups': agentHierarchyGroups,
      if (agentIds != null) 'AgentIds': agentIds,
      if (channels != null) 'Channels': channels.map((e) => e.value).toList(),
      if (contactAnalysis != null) 'ContactAnalysis': contactAnalysis,
      if (initiationMethods != null)
        'InitiationMethods': initiationMethods.map((e) => e.value).toList(),
      if (queueIds != null) 'QueueIds': queueIds,
      if (searchableContactAttributes != null)
        'SearchableContactAttributes': searchableContactAttributes,
    };
  }
}

class SearchHoursOfOperationsResponse {
  /// The total number of hours of operations which matched your search query.
  final int? approximateTotalCount;

  /// Information about the hours of operations.
  final List<HoursOfOperation>? hoursOfOperations;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  SearchHoursOfOperationsResponse({
    this.approximateTotalCount,
    this.hoursOfOperations,
    this.nextToken,
  });

  factory SearchHoursOfOperationsResponse.fromJson(Map<String, dynamic> json) {
    return SearchHoursOfOperationsResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      hoursOfOperations: (json['HoursOfOperations'] as List?)
          ?.nonNulls
          .map((e) => HoursOfOperation.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final hoursOfOperations = this.hoursOfOperations;
    final nextToken = this.nextToken;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (hoursOfOperations != null) 'HoursOfOperations': hoursOfOperations,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class SearchPredefinedAttributesResponse {
  /// The approximate number of predefined attributes which matched your search
  /// query.
  final int? approximateTotalCount;

  /// The token for the next set of results. Use the value returned in the
  /// previous response in the next request to retrieve the next set of results.
  final String? nextToken;

  /// Predefined attributes matched by the search criteria.
  final List<PredefinedAttribute>? predefinedAttributes;

  SearchPredefinedAttributesResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.predefinedAttributes,
  });

  factory SearchPredefinedAttributesResponse.fromJson(
      Map<String, dynamic> json) {
    return SearchPredefinedAttributesResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      predefinedAttributes: (json['PredefinedAttributes'] as List?)
          ?.nonNulls
          .map((e) => PredefinedAttribute.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final predefinedAttributes = this.predefinedAttributes;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (predefinedAttributes != null)
        'PredefinedAttributes': predefinedAttributes,
    };
  }
}

class SearchPromptsResponse {
  /// The total number of quick connects which matched your search query.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the prompts.
  final List<Prompt>? prompts;

  SearchPromptsResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.prompts,
  });

  factory SearchPromptsResponse.fromJson(Map<String, dynamic> json) {
    return SearchPromptsResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      prompts: (json['Prompts'] as List?)
          ?.nonNulls
          .map((e) => Prompt.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final prompts = this.prompts;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (prompts != null) 'Prompts': prompts,
    };
  }
}

class SearchQueuesResponse {
  /// The total number of queues which matched your search query.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the queues.
  final List<Queue>? queues;

  SearchQueuesResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.queues,
  });

  factory SearchQueuesResponse.fromJson(Map<String, dynamic> json) {
    return SearchQueuesResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      queues: (json['Queues'] as List?)
          ?.nonNulls
          .map((e) => Queue.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final queues = this.queues;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (queues != null) 'Queues': queues,
    };
  }
}

class SearchQuickConnectsResponse {
  /// The total number of quick connects which matched your search query.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the quick connects.
  final List<QuickConnect>? quickConnects;

  SearchQuickConnectsResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.quickConnects,
  });

  factory SearchQuickConnectsResponse.fromJson(Map<String, dynamic> json) {
    return SearchQuickConnectsResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      quickConnects: (json['QuickConnects'] as List?)
          ?.nonNulls
          .map((e) => QuickConnect.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final quickConnects = this.quickConnects;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (quickConnects != null) 'QuickConnects': quickConnects,
    };
  }
}

class SearchResourceTagsResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// A list of tags used in the Amazon Connect instance.
  final List<TagSet>? tags;

  SearchResourceTagsResponse({
    this.nextToken,
    this.tags,
  });

  factory SearchResourceTagsResponse.fromJson(Map<String, dynamic> json) {
    return SearchResourceTagsResponse(
      nextToken: json['NextToken'] as String?,
      tags: (json['Tags'] as List?)
          ?.nonNulls
          .map((e) => TagSet.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final tags = this.tags;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (tags != null) 'Tags': tags,
    };
  }
}

class SearchRoutingProfilesResponse {
  /// The total number of routing profiles which matched your search query.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the routing profiles.
  final List<RoutingProfile>? routingProfiles;

  SearchRoutingProfilesResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.routingProfiles,
  });

  factory SearchRoutingProfilesResponse.fromJson(Map<String, dynamic> json) {
    return SearchRoutingProfilesResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      routingProfiles: (json['RoutingProfiles'] as List?)
          ?.nonNulls
          .map((e) => RoutingProfile.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final routingProfiles = this.routingProfiles;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (routingProfiles != null) 'RoutingProfiles': routingProfiles,
    };
  }
}

class SearchSecurityProfilesResponse {
  /// The total number of security profiles which matched your search query.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the security profiles.
  final List<SecurityProfileSearchSummary>? securityProfiles;

  SearchSecurityProfilesResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.securityProfiles,
  });

  factory SearchSecurityProfilesResponse.fromJson(Map<String, dynamic> json) {
    return SearchSecurityProfilesResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      securityProfiles: (json['SecurityProfiles'] as List?)
          ?.nonNulls
          .map((e) =>
              SecurityProfileSearchSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final securityProfiles = this.securityProfiles;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (securityProfiles != null) 'SecurityProfiles': securityProfiles,
    };
  }
}

class SearchUsersResponse {
  /// The total number of users who matched your search query.
  final int? approximateTotalCount;

  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// Information about the users.
  final List<UserSearchSummary>? users;

  SearchUsersResponse({
    this.approximateTotalCount,
    this.nextToken,
    this.users,
  });

  factory SearchUsersResponse.fromJson(Map<String, dynamic> json) {
    return SearchUsersResponse(
      approximateTotalCount: json['ApproximateTotalCount'] as int?,
      nextToken: json['NextToken'] as String?,
      users: (json['Users'] as List?)
          ?.nonNulls
          .map((e) => UserSearchSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final approximateTotalCount = this.approximateTotalCount;
    final nextToken = this.nextToken;
    final users = this.users;
    return {
      if (approximateTotalCount != null)
        'ApproximateTotalCount': approximateTotalCount,
      if (nextToken != null) 'NextToken': nextToken,
      if (users != null) 'Users': users,
    };
  }
}

class SearchVocabulariesResponse {
  /// If there are additional results, this is the token for the next set of
  /// results.
  final String? nextToken;

  /// The list of the available custom vocabularies.
  final List<VocabularySummary>? vocabularySummaryList;

  SearchVocabulariesResponse({
    this.nextToken,
    this.vocabularySummaryList,
  });

  factory SearchVocabulariesResponse.fromJson(Map<String, dynamic> json) {
    return SearchVocabulariesResponse(
      nextToken: json['NextToken'] as String?,
      vocabularySummaryList: (json['VocabularySummaryList'] as List?)
          ?.nonNulls
          .map((e) => VocabularySummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final vocabularySummaryList = this.vocabularySummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (vocabularySummaryList != null)
        'VocabularySummaryList': vocabularySummaryList,
    };
  }
}

/// A structure that defines search criteria based on user-defined contact
/// attributes that are configured for contact search.
class SearchableContactAttributes {
  /// The list of criteria based on user-defined contact attributes that are
  /// configured for contact search.
  final List<SearchableContactAttributesCriteria> criteria;

  /// The match type combining search criteria using multiple searchable contact
  /// attributes.
  final SearchContactsMatchType? matchType;

  SearchableContactAttributes({
    required this.criteria,
    this.matchType,
  });

  Map<String, dynamic> toJson() {
    final criteria = this.criteria;
    final matchType = this.matchType;
    return {
      'Criteria': criteria,
      if (matchType != null) 'MatchType': matchType.value,
    };
  }
}

/// The search criteria based on user-defned contact attribute key and values to
/// search on.
class SearchableContactAttributesCriteria {
  /// The key containing a searchable user-defined contact attribute.
  final String key;

  /// The list of values to search for within a user-defined contact attribute.
  final List<String> values;

  SearchableContactAttributesCriteria({
    required this.key,
    required this.values,
  });

  Map<String, dynamic> toJson() {
    final key = this.key;
    final values = this.values;
    return {
      'Key': key,
      'Values': values,
    };
  }
}

enum SearchableQueueType {
  standard('STANDARD'),
  ;

  final String value;

  const SearchableQueueType(this.value);

  static SearchableQueueType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum SearchableQueueType'));
}

/// Configuration information of the security key.
class SecurityKey {
  /// The existing association identifier that uniquely identifies the resource
  /// type and storage config for the given instance ID.
  final String? associationId;

  /// When the security key was created.
  final DateTime? creationTime;

  /// The key of the security key.
  final String? key;

  SecurityKey({
    this.associationId,
    this.creationTime,
    this.key,
  });

  factory SecurityKey.fromJson(Map<String, dynamic> json) {
    return SecurityKey(
      associationId: json['AssociationId'] as String?,
      creationTime: timeStampFromJson(json['CreationTime']),
      key: json['Key'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationId = this.associationId;
    final creationTime = this.creationTime;
    final key = this.key;
    return {
      if (associationId != null) 'AssociationId': associationId,
      if (creationTime != null)
        'CreationTime': unixTimestampToJson(creationTime),
      if (key != null) 'Key': key,
    };
  }
}

/// Contains information about a security profile.
class SecurityProfile {
  /// The identifier of the hierarchy group that a security profile uses to
  /// restrict access to resources in Amazon Connect.
  final String? allowedAccessControlHierarchyGroupId;

  /// The list of tags that a security profile uses to restrict access to
  /// resources in Amazon Connect.
  final Map<String, String>? allowedAccessControlTags;

  /// The Amazon Resource Name (ARN) for the secruity profile.
  final String? arn;

  /// The description of the security profile.
  final String? description;

  /// The list of resources that a security profile applies hierarchy restrictions
  /// to in Amazon Connect. Following are acceptable ResourceNames:
  /// <code>User</code>.
  final List<String>? hierarchyRestrictedResources;

  /// The identifier for the security profile.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The organization resource identifier for the security profile.
  final String? organizationResourceId;

  /// The name for the security profile.
  final String? securityProfileName;

  /// The list of resources that a security profile applies tag restrictions to in
  /// Amazon Connect.
  final List<String>? tagRestrictedResources;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  SecurityProfile({
    this.allowedAccessControlHierarchyGroupId,
    this.allowedAccessControlTags,
    this.arn,
    this.description,
    this.hierarchyRestrictedResources,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.organizationResourceId,
    this.securityProfileName,
    this.tagRestrictedResources,
    this.tags,
  });

  factory SecurityProfile.fromJson(Map<String, dynamic> json) {
    return SecurityProfile(
      allowedAccessControlHierarchyGroupId:
          json['AllowedAccessControlHierarchyGroupId'] as String?,
      allowedAccessControlTags:
          (json['AllowedAccessControlTags'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      hierarchyRestrictedResources:
          (json['HierarchyRestrictedResources'] as List?)
              ?.nonNulls
              .map((e) => e as String)
              .toList(),
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      organizationResourceId: json['OrganizationResourceId'] as String?,
      securityProfileName: json['SecurityProfileName'] as String?,
      tagRestrictedResources: (json['TagRestrictedResources'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final allowedAccessControlHierarchyGroupId =
        this.allowedAccessControlHierarchyGroupId;
    final allowedAccessControlTags = this.allowedAccessControlTags;
    final arn = this.arn;
    final description = this.description;
    final hierarchyRestrictedResources = this.hierarchyRestrictedResources;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final organizationResourceId = this.organizationResourceId;
    final securityProfileName = this.securityProfileName;
    final tagRestrictedResources = this.tagRestrictedResources;
    final tags = this.tags;
    return {
      if (allowedAccessControlHierarchyGroupId != null)
        'AllowedAccessControlHierarchyGroupId':
            allowedAccessControlHierarchyGroupId,
      if (allowedAccessControlTags != null)
        'AllowedAccessControlTags': allowedAccessControlTags,
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (hierarchyRestrictedResources != null)
        'HierarchyRestrictedResources': hierarchyRestrictedResources,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (organizationResourceId != null)
        'OrganizationResourceId': organizationResourceId,
      if (securityProfileName != null)
        'SecurityProfileName': securityProfileName,
      if (tagRestrictedResources != null)
        'TagRestrictedResources': tagRestrictedResources,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// The search criteria to be used to return security profiles.
/// <note>
/// The <code>name</code> field support "contains" queries with a minimum of 2
/// characters and maximum of 25 characters. Any queries with character lengths
/// outside of this range will throw invalid results.
/// </note>
class SecurityProfileSearchCriteria {
  /// A list of conditions which would be applied together with an AND condition.
  final List<SecurityProfileSearchCriteria>? andConditions;

  /// A list of conditions which would be applied together with an OR condition.
  final List<SecurityProfileSearchCriteria>? orConditions;
  final StringCondition? stringCondition;

  SecurityProfileSearchCriteria({
    this.andConditions,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Information about the returned security profiles.
class SecurityProfileSearchSummary {
  /// The Amazon Resource Name (ARN) of the security profile.
  final String? arn;

  /// The description of the security profile.
  final String? description;

  /// The identifier of the security profile.
  final String? id;

  /// The organization resource identifier.
  final String? organizationResourceId;

  /// The name of the security profile.
  final String? securityProfileName;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  SecurityProfileSearchSummary({
    this.arn,
    this.description,
    this.id,
    this.organizationResourceId,
    this.securityProfileName,
    this.tags,
  });

  factory SecurityProfileSearchSummary.fromJson(Map<String, dynamic> json) {
    return SecurityProfileSearchSummary(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      organizationResourceId: json['OrganizationResourceId'] as String?,
      securityProfileName: json['SecurityProfileName'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final id = this.id;
    final organizationResourceId = this.organizationResourceId;
    final securityProfileName = this.securityProfileName;
    final tags = this.tags;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (organizationResourceId != null)
        'OrganizationResourceId': organizationResourceId,
      if (securityProfileName != null)
        'SecurityProfileName': securityProfileName,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Contains information about a security profile.
class SecurityProfileSummary {
  /// The Amazon Resource Name (ARN) of the security profile.
  final String? arn;

  /// The identifier of the security profile.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the security profile.
  final String? name;

  SecurityProfileSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.name,
  });

  factory SecurityProfileSummary.fromJson(Map<String, dynamic> json) {
    return SecurityProfileSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
    };
  }
}

/// Filters to be applied to search results.
class SecurityProfilesSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  SecurityProfilesSearchFilter({
    this.tagFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
    };
  }
}

/// A value for a segment attribute. This is structured as a map where the key
/// is <code>valueString</code> and the value is a string.
class SegmentAttributeValue {
  /// The value of a segment attribute.
  final String? valueString;

  SegmentAttributeValue({
    this.valueString,
  });

  factory SegmentAttributeValue.fromJson(Map<String, dynamic> json) {
    return SegmentAttributeValue(
      valueString: json['ValueString'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final valueString = this.valueString;
    return {
      if (valueString != null) 'ValueString': valueString,
    };
  }
}

class SendChatIntegrationEventResponse {
  /// Identifier of chat contact used to handle integration event. This may be
  /// null if the integration event is not valid without an already existing chat
  /// contact.
  final String? initialContactId;

  /// Whether handling the integration event resulted in creating a new chat or
  /// acting on existing chat.
  final bool? newChatCreated;

  SendChatIntegrationEventResponse({
    this.initialContactId,
    this.newChatCreated,
  });

  factory SendChatIntegrationEventResponse.fromJson(Map<String, dynamic> json) {
    return SendChatIntegrationEventResponse(
      initialContactId: json['InitialContactId'] as String?,
      newChatCreated: json['NewChatCreated'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final initialContactId = this.initialContactId;
    final newChatCreated = this.newChatCreated;
    return {
      if (initialContactId != null) 'InitialContactId': initialContactId,
      if (newChatCreated != null) 'NewChatCreated': newChatCreated,
    };
  }
}

/// Information about the send notification action.
class SendNotificationActionDefinition {
  /// Notification content. Supports variable injection. For more information, see
  /// <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath
  /// reference</a> in the <i>Amazon Connect Administrators Guide</i>.
  final String content;

  /// Content type format.
  final NotificationContentType contentType;

  /// Notification delivery method.
  final NotificationDeliveryType deliveryMethod;

  /// Notification recipient.
  final NotificationRecipientType recipient;

  /// The subject of the email if the delivery method is <code>EMAIL</code>.
  /// Supports variable injection. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath
  /// reference</a> in the <i>Amazon Connect Administrators Guide</i>.
  final String? subject;

  SendNotificationActionDefinition({
    required this.content,
    required this.contentType,
    required this.deliveryMethod,
    required this.recipient,
    this.subject,
  });

  factory SendNotificationActionDefinition.fromJson(Map<String, dynamic> json) {
    return SendNotificationActionDefinition(
      content: json['Content'] as String,
      contentType:
          NotificationContentType.fromString((json['ContentType'] as String)),
      deliveryMethod: NotificationDeliveryType.fromString(
          (json['DeliveryMethod'] as String)),
      recipient: NotificationRecipientType.fromJson(
          json['Recipient'] as Map<String, dynamic>),
      subject: json['Subject'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final content = this.content;
    final contentType = this.contentType;
    final deliveryMethod = this.deliveryMethod;
    final recipient = this.recipient;
    final subject = this.subject;
    return {
      'Content': content,
      'ContentType': contentType.value,
      'DeliveryMethod': deliveryMethod.value,
      'Recipient': recipient,
      if (subject != null) 'Subject': subject,
    };
  }
}

/// The distribution that determines which Amazon Web Services Regions should be
/// used to sign in agents in to both the instance and its replica(s).
class SignInConfig {
  /// Information about traffic distributions.
  final List<SignInDistribution> distributions;

  SignInConfig({
    required this.distributions,
  });

  factory SignInConfig.fromJson(Map<String, dynamic> json) {
    return SignInConfig(
      distributions: (json['Distributions'] as List)
          .nonNulls
          .map((e) => SignInDistribution.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final distributions = this.distributions;
    return {
      'Distributions': distributions,
    };
  }
}

/// The distribution of sign in traffic between the instance and its replica(s).
class SignInDistribution {
  /// Whether sign in distribution is enabled.
  final bool enabled;

  /// The Amazon Web Services Region of the sign in distribution.
  final String region;

  SignInDistribution({
    required this.enabled,
    required this.region,
  });

  factory SignInDistribution.fromJson(Map<String, dynamic> json) {
    return SignInDistribution(
      enabled: json['Enabled'] as bool,
      region: json['Region'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final region = this.region;
    return {
      'Enabled': enabled,
      'Region': region,
    };
  }
}

/// Information about the automation option based on a rule category for a
/// single select question.
class SingleSelectQuestionRuleCategoryAutomation {
  /// The category name, as defined in Rules.
  final String category;

  /// The condition to apply for the automation option. If the condition is
  /// <code>PRESENT</code>, then the option is applied when the contact data
  /// includes the category. Similarly, if the condition is
  /// <code>NOT_PRESENT</code>, then the option is applied when the contact data
  /// does not include the category.
  final SingleSelectQuestionRuleCategoryAutomationCondition condition;

  /// The identifier of the answer option.
  final String optionRefId;

  SingleSelectQuestionRuleCategoryAutomation({
    required this.category,
    required this.condition,
    required this.optionRefId,
  });

  factory SingleSelectQuestionRuleCategoryAutomation.fromJson(
      Map<String, dynamic> json) {
    return SingleSelectQuestionRuleCategoryAutomation(
      category: json['Category'] as String,
      condition: SingleSelectQuestionRuleCategoryAutomationCondition.fromString(
          (json['Condition'] as String)),
      optionRefId: json['OptionRefId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final condition = this.condition;
    final optionRefId = this.optionRefId;
    return {
      'Category': category,
      'Condition': condition.value,
      'OptionRefId': optionRefId,
    };
  }
}

enum SingleSelectQuestionRuleCategoryAutomationCondition {
  present('PRESENT'),
  notPresent('NOT_PRESENT'),
  ;

  final String value;

  const SingleSelectQuestionRuleCategoryAutomationCondition(this.value);

  static SingleSelectQuestionRuleCategoryAutomationCondition fromString(
          String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum SingleSelectQuestionRuleCategoryAutomationCondition'));
}

/// A structure that defineds the field name to sort by and a sort order.
class Sort {
  /// The name of the field on which to sort.
  final SortableFieldName fieldName;

  /// An ascending or descending sort.
  final SortOrder order;

  Sort({
    required this.fieldName,
    required this.order,
  });

  Map<String, dynamic> toJson() {
    final fieldName = this.fieldName;
    final order = this.order;
    return {
      'FieldName': fieldName.value,
      'Order': order.value,
    };
  }
}

enum SortOrder {
  ascending('ASCENDING'),
  descending('DESCENDING'),
  ;

  final String value;

  const SortOrder(this.value);

  static SortOrder fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum SortOrder'));
}

enum SortableFieldName {
  initiationTimestamp('INITIATION_TIMESTAMP'),
  scheduledTimestamp('SCHEDULED_TIMESTAMP'),
  connectedToAgentTimestamp('CONNECTED_TO_AGENT_TIMESTAMP'),
  disconnectTimestamp('DISCONNECT_TIMESTAMP'),
  initiationMethod('INITIATION_METHOD'),
  channel('CHANNEL'),
  ;

  final String value;

  const SortableFieldName(this.value);

  static SortableFieldName fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum SortableFieldName'));
}

enum SourceType {
  salesforce('SALESFORCE'),
  zendesk('ZENDESK'),
  cases('CASES'),
  ;

  final String value;

  const SourceType(this.value);

  static SourceType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum SourceType'));
}

/// Response from StartAttachedFileUpload API.
class StartAttachedFileUploadResponse {
  /// Represents the identity that created the file.
  final CreatedByInfo? createdBy;

  /// The time of Creation of the file resource as an ISO timestamp. It's
  /// specified in ISO 8601 format: <code>yyyy-MM-ddThh:mm:ss.SSSZ</code>. For
  /// example, <code>2024-05-03T02:41:28.172Z</code>.
  final String? creationTime;

  /// The unique identifier of the attached file resource (ARN).
  final String? fileArn;

  /// The unique identifier of the attached file resource.
  final String? fileId;

  /// The current status of the attached file.
  final FileStatusType? fileStatus;

  /// Information to be used while uploading the attached file.
  final UploadUrlMetadata? uploadUrlMetadata;

  StartAttachedFileUploadResponse({
    this.createdBy,
    this.creationTime,
    this.fileArn,
    this.fileId,
    this.fileStatus,
    this.uploadUrlMetadata,
  });

  factory StartAttachedFileUploadResponse.fromJson(Map<String, dynamic> json) {
    return StartAttachedFileUploadResponse(
      createdBy: json['CreatedBy'] != null
          ? CreatedByInfo.fromJson(json['CreatedBy'] as Map<String, dynamic>)
          : null,
      creationTime: json['CreationTime'] as String?,
      fileArn: json['FileArn'] as String?,
      fileId: json['FileId'] as String?,
      fileStatus:
          (json['FileStatus'] as String?)?.let(FileStatusType.fromString),
      uploadUrlMetadata: json['UploadUrlMetadata'] != null
          ? UploadUrlMetadata.fromJson(
              json['UploadUrlMetadata'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final createdBy = this.createdBy;
    final creationTime = this.creationTime;
    final fileArn = this.fileArn;
    final fileId = this.fileId;
    final fileStatus = this.fileStatus;
    final uploadUrlMetadata = this.uploadUrlMetadata;
    return {
      if (createdBy != null) 'CreatedBy': createdBy,
      if (creationTime != null) 'CreationTime': creationTime,
      if (fileArn != null) 'FileArn': fileArn,
      if (fileId != null) 'FileId': fileId,
      if (fileStatus != null) 'FileStatus': fileStatus.value,
      if (uploadUrlMetadata != null) 'UploadUrlMetadata': uploadUrlMetadata,
    };
  }
}

class StartChatContactResponse {
  /// The identifier of this contact within the Amazon Connect instance.
  final String? contactId;

  /// The contactId from which a persistent chat session is started. This field is
  /// populated only for persistent chats.
  final String? continuedFromContactId;

  /// The identifier for a chat participant. The participantId for a chat
  /// participant is the same throughout the chat lifecycle.
  final String? participantId;

  /// The token used by the chat participant to call <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a>.
  /// The participant token is valid for the lifetime of a chat participant.
  final String? participantToken;

  StartChatContactResponse({
    this.contactId,
    this.continuedFromContactId,
    this.participantId,
    this.participantToken,
  });

  factory StartChatContactResponse.fromJson(Map<String, dynamic> json) {
    return StartChatContactResponse(
      contactId: json['ContactId'] as String?,
      continuedFromContactId: json['ContinuedFromContactId'] as String?,
      participantId: json['ParticipantId'] as String?,
      participantToken: json['ParticipantToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactId = this.contactId;
    final continuedFromContactId = this.continuedFromContactId;
    final participantId = this.participantId;
    final participantToken = this.participantToken;
    return {
      if (contactId != null) 'ContactId': contactId,
      if (continuedFromContactId != null)
        'ContinuedFromContactId': continuedFromContactId,
      if (participantId != null) 'ParticipantId': participantId,
      if (participantToken != null) 'ParticipantToken': participantToken,
    };
  }
}

class StartContactEvaluationResponse {
  /// The Amazon Resource Name (ARN) for the contact evaluation resource.
  final String evaluationArn;

  /// A unique identifier for the contact evaluation.
  final String evaluationId;

  StartContactEvaluationResponse({
    required this.evaluationArn,
    required this.evaluationId,
  });

  factory StartContactEvaluationResponse.fromJson(Map<String, dynamic> json) {
    return StartContactEvaluationResponse(
      evaluationArn: json['EvaluationArn'] as String,
      evaluationId: json['EvaluationId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationArn = this.evaluationArn;
    final evaluationId = this.evaluationId;
    return {
      'EvaluationArn': evaluationArn,
      'EvaluationId': evaluationId,
    };
  }
}

class StartContactRecordingResponse {
  StartContactRecordingResponse();

  factory StartContactRecordingResponse.fromJson(Map<String, dynamic> _) {
    return StartContactRecordingResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class StartContactStreamingResponse {
  /// The identifier of the streaming configuration enabled.
  final String streamingId;

  StartContactStreamingResponse({
    required this.streamingId,
  });

  factory StartContactStreamingResponse.fromJson(Map<String, dynamic> json) {
    return StartContactStreamingResponse(
      streamingId: json['StreamingId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final streamingId = this.streamingId;
    return {
      'StreamingId': streamingId,
    };
  }
}

class StartOutboundVoiceContactResponse {
  /// The identifier of this contact within the Amazon Connect instance.
  final String? contactId;

  StartOutboundVoiceContactResponse({
    this.contactId,
  });

  factory StartOutboundVoiceContactResponse.fromJson(
      Map<String, dynamic> json) {
    return StartOutboundVoiceContactResponse(
      contactId: json['ContactId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactId = this.contactId;
    return {
      if (contactId != null) 'ContactId': contactId,
    };
  }
}

class StartTaskContactResponse {
  /// The identifier of this contact within the Amazon Connect instance.
  final String? contactId;

  StartTaskContactResponse({
    this.contactId,
  });

  factory StartTaskContactResponse.fromJson(Map<String, dynamic> json) {
    return StartTaskContactResponse(
      contactId: json['ContactId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactId = this.contactId;
    return {
      if (contactId != null) 'ContactId': contactId,
    };
  }
}

class StartWebRTCContactResponse {
  /// Information required for the client application (mobile application or
  /// website) to connect to the call.
  final ConnectionData? connectionData;

  /// The identifier of the contact in this instance of Amazon Connect.
  final String? contactId;

  /// The identifier for a contact participant. The <code>ParticipantId</code> for
  /// a contact participant is the same throughout the contact lifecycle.
  final String? participantId;

  /// The token used by the contact participant to call the <a
  /// href="https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_CreateParticipantConnection.html">CreateParticipantConnection</a>
  /// API. The participant token is valid for the lifetime of a contact
  /// participant.
  final String? participantToken;

  StartWebRTCContactResponse({
    this.connectionData,
    this.contactId,
    this.participantId,
    this.participantToken,
  });

  factory StartWebRTCContactResponse.fromJson(Map<String, dynamic> json) {
    return StartWebRTCContactResponse(
      connectionData: json['ConnectionData'] != null
          ? ConnectionData.fromJson(
              json['ConnectionData'] as Map<String, dynamic>)
          : null,
      contactId: json['ContactId'] as String?,
      participantId: json['ParticipantId'] as String?,
      participantToken: json['ParticipantToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final connectionData = this.connectionData;
    final contactId = this.contactId;
    final participantId = this.participantId;
    final participantToken = this.participantToken;
    return {
      if (connectionData != null) 'ConnectionData': connectionData,
      if (contactId != null) 'ContactId': contactId,
      if (participantId != null) 'ParticipantId': participantId,
      if (participantToken != null) 'ParticipantToken': participantToken,
    };
  }
}

enum Statistic {
  sum('SUM'),
  max('MAX'),
  avg('AVG'),
  ;

  final String value;

  const Statistic(this.value);

  static Statistic fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum Statistic'));
}

/// Step signifies the criteria to be used for routing to an agent
class Step {
  /// An object to specify the expiration of a routing step.
  final Expiry? expiry;

  /// A tagged union to specify expression for a routing step.
  final Expression? expression;

  /// Represents status of the Routing step.
  final RoutingCriteriaStepStatus? status;

  Step({
    this.expiry,
    this.expression,
    this.status,
  });

  factory Step.fromJson(Map<String, dynamic> json) {
    return Step(
      expiry: json['Expiry'] != null
          ? Expiry.fromJson(json['Expiry'] as Map<String, dynamic>)
          : null,
      expression: json['Expression'] != null
          ? Expression.fromJson(json['Expression'] as Map<String, dynamic>)
          : null,
      status: (json['Status'] as String?)
          ?.let(RoutingCriteriaStepStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final expiry = this.expiry;
    final expression = this.expression;
    final status = this.status;
    return {
      if (expiry != null) 'Expiry': expiry,
      if (expression != null) 'Expression': expression,
      if (status != null) 'Status': status.value,
    };
  }
}

class StopContactRecordingResponse {
  StopContactRecordingResponse();

  factory StopContactRecordingResponse.fromJson(Map<String, dynamic> _) {
    return StopContactRecordingResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class StopContactResponse {
  StopContactResponse();

  factory StopContactResponse.fromJson(Map<String, dynamic> _) {
    return StopContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class StopContactStreamingResponse {
  StopContactStreamingResponse();

  factory StopContactStreamingResponse.fromJson(Map<String, dynamic> _) {
    return StopContactStreamingResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

enum StorageType {
  s3('S3'),
  kinesisVideoStream('KINESIS_VIDEO_STREAM'),
  kinesisStream('KINESIS_STREAM'),
  kinesisFirehose('KINESIS_FIREHOSE'),
  ;

  final String value;

  const StorageType(this.value);

  static StorageType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum StorageType'));
}

enum StringComparisonType {
  startsWith('STARTS_WITH'),
  contains('CONTAINS'),
  exact('EXACT'),
  ;

  final String value;

  const StringComparisonType(this.value);

  static StringComparisonType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum StringComparisonType'));
}

/// A leaf node condition which can be used to specify a string condition.
/// <note>
/// The currently supported values for <code>FieldName</code> are
/// <code>name</code> and <code>description</code>.
/// </note>
class StringCondition {
  /// The type of comparison to be made when evaluating the string condition.
  final StringComparisonType? comparisonType;

  /// The name of the field in the string condition.
  final String? fieldName;

  /// The value of the string.
  final String? value;

  StringCondition({
    this.comparisonType,
    this.fieldName,
    this.value,
  });

  Map<String, dynamic> toJson() {
    final comparisonType = this.comparisonType;
    final fieldName = this.fieldName;
    final value = this.value;
    return {
      if (comparisonType != null) 'ComparisonType': comparisonType.value,
      if (fieldName != null) 'FieldName': fieldName,
      if (value != null) 'Value': value,
    };
  }
}

/// Information about a reference when the <code>referenceType</code> is
/// <code>STRING</code>. Otherwise, null.
class StringReference {
  /// Identifier of the string reference.
  final String? name;

  /// A valid string.
  final String? value;

  StringReference({
    this.name,
    this.value,
  });

  factory StringReference.fromJson(Map<String, dynamic> json) {
    return StringReference(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// Information about the submit automated evaluation action.
class SubmitAutoEvaluationActionDefinition {
  /// The identifier of the auto-evaluation enabled form.
  final String evaluationFormId;

  SubmitAutoEvaluationActionDefinition({
    required this.evaluationFormId,
  });

  factory SubmitAutoEvaluationActionDefinition.fromJson(
      Map<String, dynamic> json) {
    return SubmitAutoEvaluationActionDefinition(
      evaluationFormId: json['EvaluationFormId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormId = this.evaluationFormId;
    return {
      'EvaluationFormId': evaluationFormId,
    };
  }
}

class SubmitContactEvaluationResponse {
  /// The Amazon Resource Name (ARN) for the contact evaluation resource.
  final String evaluationArn;

  /// A unique identifier for the contact evaluation.
  final String evaluationId;

  SubmitContactEvaluationResponse({
    required this.evaluationArn,
    required this.evaluationId,
  });

  factory SubmitContactEvaluationResponse.fromJson(Map<String, dynamic> json) {
    return SubmitContactEvaluationResponse(
      evaluationArn: json['EvaluationArn'] as String,
      evaluationId: json['EvaluationId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationArn = this.evaluationArn;
    final evaluationId = this.evaluationId;
    return {
      'EvaluationArn': evaluationArn,
      'EvaluationId': evaluationId,
    };
  }
}

/// Request for which contact was successfully created.
class SuccessfulRequest {
  /// The contactId of the contact that was created successfully.
  final String? contactId;

  /// Request identifier provided in the API call in the ContactDataRequest to
  /// create a contact.
  final String? requestIdentifier;

  SuccessfulRequest({
    this.contactId,
    this.requestIdentifier,
  });

  factory SuccessfulRequest.fromJson(Map<String, dynamic> json) {
    return SuccessfulRequest(
      contactId: json['ContactId'] as String?,
      requestIdentifier: json['RequestIdentifier'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactId = this.contactId;
    final requestIdentifier = this.requestIdentifier;
    return {
      if (contactId != null) 'ContactId': contactId,
      if (requestIdentifier != null) 'RequestIdentifier': requestIdentifier,
    };
  }
}

class SuspendContactRecordingResponse {
  SuspendContactRecordingResponse();

  factory SuspendContactRecordingResponse.fromJson(Map<String, dynamic> _) {
    return SuspendContactRecordingResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// A leaf node condition which can be used to specify a tag condition, for
/// example, <code>HAVE BPO = 123</code>.
class TagCondition {
  /// The tag key in the tag condition.
  final String? tagKey;

  /// The tag value in the tag condition.
  final String? tagValue;

  TagCondition({
    this.tagKey,
    this.tagValue,
  });

  Map<String, dynamic> toJson() {
    final tagKey = this.tagKey;
    final tagValue = this.tagValue;
    return {
      if (tagKey != null) 'TagKey': tagKey,
      if (tagValue != null) 'TagValue': tagValue,
    };
  }
}

class TagContactResponse {
  TagContactResponse();

  factory TagContactResponse.fromJson(Map<String, dynamic> _) {
    return TagContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The search criteria to be used to return tags.
class TagSearchCondition {
  /// The tag key used in the tag search condition.
  final String? tagKey;

  /// The type of comparison to be made when evaluating the tag key in tag search
  /// condition.
  final StringComparisonType? tagKeyComparisonType;

  /// The tag value used in the tag search condition.
  final String? tagValue;

  /// The type of comparison to be made when evaluating the tag value in tag
  /// search condition.
  final StringComparisonType? tagValueComparisonType;

  TagSearchCondition({
    this.tagKey,
    this.tagKeyComparisonType,
    this.tagValue,
    this.tagValueComparisonType,
  });

  Map<String, dynamic> toJson() {
    final tagKey = this.tagKey;
    final tagKeyComparisonType = this.tagKeyComparisonType;
    final tagValue = this.tagValue;
    final tagValueComparisonType = this.tagValueComparisonType;
    return {
      if (tagKey != null) 'tagKey': tagKey,
      if (tagKeyComparisonType != null)
        'tagKeyComparisonType': tagKeyComparisonType.value,
      if (tagValue != null) 'tagValue': tagValue,
      if (tagValueComparisonType != null)
        'tagValueComparisonType': tagValueComparisonType.value,
    };
  }
}

/// A tag set contains tag key and tag value.
class TagSet {
  /// The tag key in the tagSet.
  final String? key;

  /// The tag value in the tagSet.
  final String? value;

  TagSet({
    this.key,
    this.value,
  });

  factory TagSet.fromJson(Map<String, dynamic> json) {
    return TagSet(
      key: json['key'] as String?,
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      if (key != null) 'key': key,
      if (value != null) 'value': value,
    };
  }
}

/// Information about the task action.
class TaskActionDefinition {
  /// The identifier of the flow.
  final String contactFlowId;

  /// The name. Supports variable injection. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath
  /// reference</a> in the <i>Amazon Connect Administrators Guide</i>.
  final String name;

  /// The description. Supports variable injection. For more information, see <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/contact-lens-variable-injection.html">JSONPath
  /// reference</a> in the <i>Amazon Connect Administrators Guide</i>.
  final String? description;

  /// Information about the reference when the <code>referenceType</code> is
  /// <code>URL</code>. Otherwise, null. (Supports variable injection in the
  /// <code>Value</code> field.)
  final Map<String, Reference>? references;

  TaskActionDefinition({
    required this.contactFlowId,
    required this.name,
    this.description,
    this.references,
  });

  factory TaskActionDefinition.fromJson(Map<String, dynamic> json) {
    return TaskActionDefinition(
      contactFlowId: json['ContactFlowId'] as String,
      name: json['Name'] as String,
      description: json['Description'] as String?,
      references: (json['References'] as Map<String, dynamic>?)?.map(
          (k, e) => MapEntry(k, Reference.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowId = this.contactFlowId;
    final name = this.name;
    final description = this.description;
    final references = this.references;
    return {
      'ContactFlowId': contactFlowId,
      'Name': name,
      if (description != null) 'Description': description,
      if (references != null) 'References': references,
    };
  }
}

/// Describes constraints that apply to the template fields.
class TaskTemplateConstraints {
  /// Lists the fields that are invisible to agents.
  final List<InvisibleFieldInfo>? invisibleFields;

  /// Lists the fields that are read-only to agents, and cannot be edited.
  final List<ReadOnlyFieldInfo>? readOnlyFields;

  /// Lists the fields that are required to be filled by agents.
  final List<RequiredFieldInfo>? requiredFields;

  TaskTemplateConstraints({
    this.invisibleFields,
    this.readOnlyFields,
    this.requiredFields,
  });

  factory TaskTemplateConstraints.fromJson(Map<String, dynamic> json) {
    return TaskTemplateConstraints(
      invisibleFields: (json['InvisibleFields'] as List?)
          ?.nonNulls
          .map((e) => InvisibleFieldInfo.fromJson(e as Map<String, dynamic>))
          .toList(),
      readOnlyFields: (json['ReadOnlyFields'] as List?)
          ?.nonNulls
          .map((e) => ReadOnlyFieldInfo.fromJson(e as Map<String, dynamic>))
          .toList(),
      requiredFields: (json['RequiredFields'] as List?)
          ?.nonNulls
          .map((e) => RequiredFieldInfo.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final invisibleFields = this.invisibleFields;
    final readOnlyFields = this.readOnlyFields;
    final requiredFields = this.requiredFields;
    return {
      if (invisibleFields != null) 'InvisibleFields': invisibleFields,
      if (readOnlyFields != null) 'ReadOnlyFields': readOnlyFields,
      if (requiredFields != null) 'RequiredFields': requiredFields,
    };
  }
}

/// Describes a default field and its corresponding value.
class TaskTemplateDefaultFieldValue {
  /// Default value for the field.
  final String? defaultValue;

  /// Identifier of a field.
  final TaskTemplateFieldIdentifier? id;

  TaskTemplateDefaultFieldValue({
    this.defaultValue,
    this.id,
  });

  factory TaskTemplateDefaultFieldValue.fromJson(Map<String, dynamic> json) {
    return TaskTemplateDefaultFieldValue(
      defaultValue: json['DefaultValue'] as String?,
      id: json['Id'] != null
          ? TaskTemplateFieldIdentifier.fromJson(
              json['Id'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    final id = this.id;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (id != null) 'Id': id,
    };
  }
}

/// Describes default values for fields on a template.
class TaskTemplateDefaults {
  /// Default value for the field.
  final List<TaskTemplateDefaultFieldValue>? defaultFieldValues;

  TaskTemplateDefaults({
    this.defaultFieldValues,
  });

  factory TaskTemplateDefaults.fromJson(Map<String, dynamic> json) {
    return TaskTemplateDefaults(
      defaultFieldValues: (json['DefaultFieldValues'] as List?)
          ?.nonNulls
          .map((e) =>
              TaskTemplateDefaultFieldValue.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final defaultFieldValues = this.defaultFieldValues;
    return {
      if (defaultFieldValues != null) 'DefaultFieldValues': defaultFieldValues,
    };
  }
}

/// Describes a single task template field.
class TaskTemplateField {
  /// The unique identifier for the field.
  final TaskTemplateFieldIdentifier id;

  /// The description of the field.
  final String? description;

  /// A list of options for a single select field.
  final List<String>? singleSelectOptions;

  /// Indicates the type of field.
  final TaskTemplateFieldType? type;

  TaskTemplateField({
    required this.id,
    this.description,
    this.singleSelectOptions,
    this.type,
  });

  factory TaskTemplateField.fromJson(Map<String, dynamic> json) {
    return TaskTemplateField(
      id: TaskTemplateFieldIdentifier.fromJson(
          json['Id'] as Map<String, dynamic>),
      description: json['Description'] as String?,
      singleSelectOptions: (json['SingleSelectOptions'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      type: (json['Type'] as String?)?.let(TaskTemplateFieldType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final description = this.description;
    final singleSelectOptions = this.singleSelectOptions;
    final type = this.type;
    return {
      'Id': id,
      if (description != null) 'Description': description,
      if (singleSelectOptions != null)
        'SingleSelectOptions': singleSelectOptions,
      if (type != null) 'Type': type.value,
    };
  }
}

/// The identifier of the task template field.
class TaskTemplateFieldIdentifier {
  /// The name of the task template field.
  final String? name;

  TaskTemplateFieldIdentifier({
    this.name,
  });

  factory TaskTemplateFieldIdentifier.fromJson(Map<String, dynamic> json) {
    return TaskTemplateFieldIdentifier(
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      if (name != null) 'Name': name,
    };
  }
}

enum TaskTemplateFieldType {
  name('NAME'),
  description('DESCRIPTION'),
  scheduledTime('SCHEDULED_TIME'),
  quickConnect('QUICK_CONNECT'),
  url('URL'),
  number('NUMBER'),
  text('TEXT'),
  textArea('TEXT_AREA'),
  dateTime('DATE_TIME'),
  boolean('BOOLEAN'),
  singleSelect('SINGLE_SELECT'),
  email('EMAIL'),
  ;

  final String value;

  const TaskTemplateFieldType(this.value);

  static TaskTemplateFieldType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum TaskTemplateFieldType'));
}

/// Contains summary information about the task template.
class TaskTemplateMetadata {
  /// The Amazon Resource Name (ARN) of the task template.
  final String? arn;

  /// The timestamp when the task template was created.
  final DateTime? createdTime;

  /// The description of the task template.
  final String? description;

  /// A unique identifier for the task template.
  final String? id;

  /// The timestamp when the task template was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the task template.
  final String? name;

  /// Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task
  /// to refer to it. Tasks can only be created from <code>ACTIVE</code>
  /// templates. If a template is marked as <code>INACTIVE</code>, then a task
  /// that refers to this template cannot be created.
  final TaskTemplateStatus? status;

  TaskTemplateMetadata({
    this.arn,
    this.createdTime,
    this.description,
    this.id,
    this.lastModifiedTime,
    this.name,
    this.status,
  });

  factory TaskTemplateMetadata.fromJson(Map<String, dynamic> json) {
    return TaskTemplateMetadata(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      status: (json['Status'] as String?)?.let(TaskTemplateStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final description = this.description;
    final id = this.id;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
    };
  }
}

enum TaskTemplateStatus {
  active('ACTIVE'),
  inactive('INACTIVE'),
  ;

  final String value;

  const TaskTemplateStatus(this.value);

  static TaskTemplateStatus fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum TaskTemplateStatus'));
}

/// The distribution of traffic between the instance and its replicas.
class TelephonyConfig {
  /// Information about traffic distributions.
  final List<Distribution> distributions;

  TelephonyConfig({
    required this.distributions,
  });

  factory TelephonyConfig.fromJson(Map<String, dynamic> json) {
    return TelephonyConfig(
      distributions: (json['Distributions'] as List)
          .nonNulls
          .map((e) => Distribution.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final distributions = this.distributions;
    return {
      'Distributions': distributions,
    };
  }
}

/// Contains information about the threshold for service level metrics.
class Threshold {
  /// The type of comparison. Only "less than" (LT) comparisons are supported.
  final Comparison? comparison;

  /// The threshold value to compare.
  final double? thresholdValue;

  Threshold({
    this.comparison,
    this.thresholdValue,
  });

  factory Threshold.fromJson(Map<String, dynamic> json) {
    return Threshold(
      comparison: (json['Comparison'] as String?)?.let(Comparison.fromString),
      thresholdValue: json['ThresholdValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final comparison = this.comparison;
    final thresholdValue = this.thresholdValue;
    return {
      if (comparison != null) 'Comparison': comparison.value,
      if (thresholdValue != null) 'ThresholdValue': thresholdValue,
    };
  }
}

/// Contains information about the threshold for service level metrics.
class ThresholdV2 {
  /// The type of comparison. Only "less than" (LT) comparisons are supported.
  final String? comparison;

  /// The threshold value to compare.
  final double? thresholdValue;

  ThresholdV2({
    this.comparison,
    this.thresholdValue,
  });

  factory ThresholdV2.fromJson(Map<String, dynamic> json) {
    return ThresholdV2(
      comparison: json['Comparison'] as String?,
      thresholdValue: json['ThresholdValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final comparison = this.comparison;
    final thresholdValue = this.thresholdValue;
    return {
      if (comparison != null) 'Comparison': comparison,
      if (thresholdValue != null) 'ThresholdValue': thresholdValue,
    };
  }
}

enum TimerEligibleParticipantRoles {
  customer('CUSTOMER'),
  agent('AGENT'),
  ;

  final String value;

  const TimerEligibleParticipantRoles(this.value);

  static TimerEligibleParticipantRoles fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum TimerEligibleParticipantRoles'));
}

/// Information about a traffic distribution group.
class TrafficDistributionGroup {
  /// The Amazon Resource Name (ARN) of the traffic distribution group.
  final String? arn;

  /// The description of the traffic distribution group.
  final String? description;

  /// The identifier of the traffic distribution group. This can be the ID or the
  /// ARN if the API is being called in the Region where the traffic distribution
  /// group was created. The ARN must be provided if the call is from the
  /// replicated Region.
  final String? id;

  /// The Amazon Resource Name (ARN).
  final String? instanceArn;

  /// Whether this is the default traffic distribution group created during
  /// instance replication. The default traffic distribution group cannot be
  /// deleted by the <code>DeleteTrafficDistributionGroup</code> API. The default
  /// traffic distribution group is deleted as part of the process for deleting a
  /// replica.
  /// <note>
  /// The <code>SignInConfig</code> distribution is available only on a default
  /// <code>TrafficDistributionGroup</code> (see the <code>IsDefault</code>
  /// parameter in the <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_TrafficDistributionGroup.html">TrafficDistributionGroup</a>
  /// data type). If you call <code>UpdateTrafficDistribution</code> with a
  /// modified <code>SignInConfig</code> and a non-default
  /// <code>TrafficDistributionGroup</code>, an
  /// <code>InvalidRequestException</code> is returned.
  /// </note>
  final bool? isDefault;

  /// The name of the traffic distribution group.
  final String? name;

  /// The status of the traffic distribution group.
  ///
  /// <ul>
  /// <li>
  /// <code>CREATION_IN_PROGRESS</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a>
  /// operation is still in progress and has not yet completed.
  /// </li>
  /// <li>
  /// <code>ACTIVE</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a>
  /// operation has succeeded.
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code> indicates that the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a>
  /// operation has failed.
  /// </li>
  /// <li>
  /// <code>PENDING_DELETION</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a>
  /// operation is still in progress and has not yet completed.
  /// </li>
  /// <li>
  /// <code>DELETION_FAILED</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a>
  /// operation has failed.
  /// </li>
  /// <li>
  /// <code>UPDATE_IN_PROGRESS</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistribution.html">UpdateTrafficDistribution</a>
  /// operation is still in progress and has not yet completed.
  /// </li>
  /// </ul>
  final TrafficDistributionGroupStatus? status;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  TrafficDistributionGroup({
    this.arn,
    this.description,
    this.id,
    this.instanceArn,
    this.isDefault,
    this.name,
    this.status,
    this.tags,
  });

  factory TrafficDistributionGroup.fromJson(Map<String, dynamic> json) {
    return TrafficDistributionGroup(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      instanceArn: json['InstanceArn'] as String?,
      isDefault: json['IsDefault'] as bool?,
      name: json['Name'] as String?,
      status: (json['Status'] as String?)
          ?.let(TrafficDistributionGroupStatus.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final id = this.id;
    final instanceArn = this.instanceArn;
    final isDefault = this.isDefault;
    final name = this.name;
    final status = this.status;
    final tags = this.tags;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (instanceArn != null) 'InstanceArn': instanceArn,
      if (isDefault != null) 'IsDefault': isDefault,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
    };
  }
}

enum TrafficDistributionGroupStatus {
  creationInProgress('CREATION_IN_PROGRESS'),
  active('ACTIVE'),
  creationFailed('CREATION_FAILED'),
  pendingDeletion('PENDING_DELETION'),
  deletionFailed('DELETION_FAILED'),
  updateInProgress('UPDATE_IN_PROGRESS'),
  ;

  final String value;

  const TrafficDistributionGroupStatus(this.value);

  static TrafficDistributionGroupStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum TrafficDistributionGroupStatus'));
}

/// Information about traffic distribution groups.
class TrafficDistributionGroupSummary {
  /// The Amazon Resource Name (ARN) of the traffic distribution group.
  final String? arn;

  /// The identifier of the traffic distribution group. This can be the ID or the
  /// ARN if the API is being called in the Region where the traffic distribution
  /// group was created. The ARN must be provided if the call is from the
  /// replicated Region.
  final String? id;

  /// The Amazon Resource Name (ARN) of the traffic distribution group.
  final String? instanceArn;

  /// Whether this is the default traffic distribution group created during
  /// instance replication. The default traffic distribution group cannot be
  /// deleted by the <code>DeleteTrafficDistributionGroup</code> API. The default
  /// traffic distribution group is deleted as part of the process for deleting a
  /// replica.
  final bool? isDefault;

  /// The name of the traffic distribution group.
  final String? name;

  /// The status of the traffic distribution group.
  ///
  /// <ul>
  /// <li>
  /// <code>CREATION_IN_PROGRESS</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a>
  /// operation is still in progress and has not yet completed.
  /// </li>
  /// <li>
  /// <code>ACTIVE</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a>
  /// operation has succeeded.
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code> indicates that the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_CreateTrafficDistributionGroup.html">CreateTrafficDistributionGroup</a>
  /// operation has failed.
  /// </li>
  /// <li>
  /// <code>PENDING_DELETION</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a>
  /// operation is still in progress and has not yet completed.
  /// </li>
  /// <li>
  /// <code>DELETION_FAILED</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_DeleteTrafficDistributionGroup.html">DeleteTrafficDistributionGroup</a>
  /// operation has failed.
  /// </li>
  /// <li>
  /// <code>UPDATE_IN_PROGRESS</code> means the previous <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_UpdateTrafficDistributionGroup.html">UpdateTrafficDistributionGroup</a>
  /// operation is still in progress and has not yet completed.
  /// </li>
  /// </ul>
  final TrafficDistributionGroupStatus? status;

  TrafficDistributionGroupSummary({
    this.arn,
    this.id,
    this.instanceArn,
    this.isDefault,
    this.name,
    this.status,
  });

  factory TrafficDistributionGroupSummary.fromJson(Map<String, dynamic> json) {
    return TrafficDistributionGroupSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      instanceArn: json['InstanceArn'] as String?,
      isDefault: json['IsDefault'] as bool?,
      name: json['Name'] as String?,
      status: (json['Status'] as String?)
          ?.let(TrafficDistributionGroupStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final instanceArn = this.instanceArn;
    final isDefault = this.isDefault;
    final name = this.name;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (instanceArn != null) 'InstanceArn': instanceArn,
      if (isDefault != null) 'IsDefault': isDefault,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
    };
  }
}

/// Summary information about a traffic distribution group user.
class TrafficDistributionGroupUserSummary {
  /// The identifier for the user. This can be the ID or the ARN of the user.
  final String? userId;

  TrafficDistributionGroupUserSummary({
    this.userId,
  });

  factory TrafficDistributionGroupUserSummary.fromJson(
      Map<String, dynamic> json) {
    return TrafficDistributionGroupUserSummary(
      userId: json['UserId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final userId = this.userId;
    return {
      if (userId != null) 'UserId': userId,
    };
  }
}

enum TrafficType {
  general('GENERAL'),
  campaign('CAMPAIGN'),
  ;

  final String value;

  const TrafficType(this.value);

  static TrafficType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum TrafficType'));
}

/// A structure that defines search criteria and matching logic to search for
/// contacts by matching text with transcripts analyzed by Amazon Connect
/// Contact Lens.
class Transcript {
  /// The list of search criteria based on Contact Lens conversational analytics
  /// transcript.
  final List<TranscriptCriteria> criteria;

  /// The match type combining search criteria using multiple transcript criteria.
  final SearchContactsMatchType? matchType;

  Transcript({
    required this.criteria,
    this.matchType,
  });

  Map<String, dynamic> toJson() {
    final criteria = this.criteria;
    final matchType = this.matchType;
    return {
      'Criteria': criteria,
      if (matchType != null) 'MatchType': matchType.value,
    };
  }
}

/// A structure that defines search criteria base on words or phrases,
/// participants in the Contact Lens conversational analytics transcript.
class TranscriptCriteria {
  /// The match type combining search criteria using multiple search texts in a
  /// transcript criteria.
  final SearchContactsMatchType matchType;

  /// The participant role in a transcript
  final ParticipantRole participantRole;

  /// The words or phrases used to search within a transcript.
  final List<String> searchText;

  TranscriptCriteria({
    required this.matchType,
    required this.participantRole,
    required this.searchText,
  });

  Map<String, dynamic> toJson() {
    final matchType = this.matchType;
    final participantRole = this.participantRole;
    final searchText = this.searchText;
    return {
      'MatchType': matchType.value,
      'ParticipantRole': participantRole.value,
      'SearchText': searchText,
    };
  }
}

class TransferContactResponse {
  /// The Amazon Resource Name (ARN) of the contact.
  final String? contactArn;

  /// The identifier of the contact in this instance of Amazon Connect.
  final String? contactId;

  TransferContactResponse({
    this.contactArn,
    this.contactId,
  });

  factory TransferContactResponse.fromJson(Map<String, dynamic> json) {
    return TransferContactResponse(
      contactArn: json['ContactArn'] as String?,
      contactId: json['ContactId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contactArn = this.contactArn;
    final contactId = this.contactId;
    return {
      if (contactArn != null) 'ContactArn': contactArn,
      if (contactId != null) 'ContactId': contactId,
    };
  }
}

enum Unit {
  seconds('SECONDS'),
  count('COUNT'),
  percent('PERCENT'),
  ;

  final String value;

  const Unit(this.value);

  static Unit fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception('$value is not known in enum Unit'));
}

class UntagContactResponse {
  UntagContactResponse();

  factory UntagContactResponse.fromJson(Map<String, dynamic> _) {
    return UntagContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The <code>UpdateCase</code> action definition.
class UpdateCaseActionDefinition {
  /// An array of objects with <code>Field ID</code> and Value data.
  final List<FieldValue> fields;

  UpdateCaseActionDefinition({
    required this.fields,
  });

  factory UpdateCaseActionDefinition.fromJson(Map<String, dynamic> json) {
    return UpdateCaseActionDefinition(
      fields: (json['Fields'] as List)
          .nonNulls
          .map((e) => FieldValue.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final fields = this.fields;
    return {
      'Fields': fields,
    };
  }
}

class UpdateContactAttributesResponse {
  UpdateContactAttributesResponse();

  factory UpdateContactAttributesResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactAttributesResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactEvaluationResponse {
  /// The Amazon Resource Name (ARN) for the contact evaluation resource.
  final String evaluationArn;

  /// A unique identifier for the contact evaluation.
  final String evaluationId;

  UpdateContactEvaluationResponse({
    required this.evaluationArn,
    required this.evaluationId,
  });

  factory UpdateContactEvaluationResponse.fromJson(Map<String, dynamic> json) {
    return UpdateContactEvaluationResponse(
      evaluationArn: json['EvaluationArn'] as String,
      evaluationId: json['EvaluationId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationArn = this.evaluationArn;
    final evaluationId = this.evaluationId;
    return {
      'EvaluationArn': evaluationArn,
      'EvaluationId': evaluationId,
    };
  }
}

class UpdateContactFlowContentResponse {
  UpdateContactFlowContentResponse();

  factory UpdateContactFlowContentResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactFlowContentResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactFlowMetadataResponse {
  UpdateContactFlowMetadataResponse();

  factory UpdateContactFlowMetadataResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactFlowMetadataResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactFlowModuleContentResponse {
  UpdateContactFlowModuleContentResponse();

  factory UpdateContactFlowModuleContentResponse.fromJson(
      Map<String, dynamic> _) {
    return UpdateContactFlowModuleContentResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactFlowModuleMetadataResponse {
  UpdateContactFlowModuleMetadataResponse();

  factory UpdateContactFlowModuleMetadataResponse.fromJson(
      Map<String, dynamic> _) {
    return UpdateContactFlowModuleMetadataResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactFlowNameResponse {
  UpdateContactFlowNameResponse();

  factory UpdateContactFlowNameResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactFlowNameResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactResponse {
  UpdateContactResponse();

  factory UpdateContactResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactRoutingDataResponse {
  UpdateContactRoutingDataResponse();

  factory UpdateContactRoutingDataResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactRoutingDataResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateContactScheduleResponse {
  UpdateContactScheduleResponse();

  factory UpdateContactScheduleResponse.fromJson(Map<String, dynamic> _) {
    return UpdateContactScheduleResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateEvaluationFormResponse {
  /// The Amazon Resource Name (ARN) for the contact evaluation resource.
  final String evaluationFormArn;

  /// The unique identifier for the evaluation form.
  final String evaluationFormId;

  /// The version of the updated evaluation form resource.
  final int evaluationFormVersion;

  UpdateEvaluationFormResponse({
    required this.evaluationFormArn,
    required this.evaluationFormId,
    required this.evaluationFormVersion,
  });

  factory UpdateEvaluationFormResponse.fromJson(Map<String, dynamic> json) {
    return UpdateEvaluationFormResponse(
      evaluationFormArn: json['EvaluationFormArn'] as String,
      evaluationFormId: json['EvaluationFormId'] as String,
      evaluationFormVersion: json['EvaluationFormVersion'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final evaluationFormArn = this.evaluationFormArn;
    final evaluationFormId = this.evaluationFormId;
    final evaluationFormVersion = this.evaluationFormVersion;
    return {
      'EvaluationFormArn': evaluationFormArn,
      'EvaluationFormId': evaluationFormId,
      'EvaluationFormVersion': evaluationFormVersion,
    };
  }
}

/// Configuration information for the chat participant role.
class UpdateParticipantRoleConfigChannelInfo {
  /// Configuration information for the chat participant role.
  final ChatParticipantRoleConfig? chat;

  UpdateParticipantRoleConfigChannelInfo({
    this.chat,
  });

  Map<String, dynamic> toJson() {
    final chat = this.chat;
    return {
      if (chat != null) 'Chat': chat,
    };
  }
}

class UpdateParticipantRoleConfigResponse {
  UpdateParticipantRoleConfigResponse();

  factory UpdateParticipantRoleConfigResponse.fromJson(Map<String, dynamic> _) {
    return UpdateParticipantRoleConfigResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdatePhoneNumberResponse {
  /// The Amazon Resource Name (ARN) of the phone number.
  final String? phoneNumberArn;

  /// A unique identifier for the phone number.
  final String? phoneNumberId;

  UpdatePhoneNumberResponse({
    this.phoneNumberArn,
    this.phoneNumberId,
  });

  factory UpdatePhoneNumberResponse.fromJson(Map<String, dynamic> json) {
    return UpdatePhoneNumberResponse(
      phoneNumberArn: json['PhoneNumberArn'] as String?,
      phoneNumberId: json['PhoneNumberId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final phoneNumberArn = this.phoneNumberArn;
    final phoneNumberId = this.phoneNumberId;
    return {
      if (phoneNumberArn != null) 'PhoneNumberArn': phoneNumberArn,
      if (phoneNumberId != null) 'PhoneNumberId': phoneNumberId,
    };
  }
}

class UpdatePromptResponse {
  /// The Amazon Resource Name (ARN) of the prompt.
  final String? promptARN;

  /// A unique identifier for the prompt.
  final String? promptId;

  UpdatePromptResponse({
    this.promptARN,
    this.promptId,
  });

  factory UpdatePromptResponse.fromJson(Map<String, dynamic> json) {
    return UpdatePromptResponse(
      promptARN: json['PromptARN'] as String?,
      promptId: json['PromptId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final promptARN = this.promptARN;
    final promptId = this.promptId;
    return {
      if (promptARN != null) 'PromptARN': promptARN,
      if (promptId != null) 'PromptId': promptId,
    };
  }
}

class UpdateTaskTemplateResponse {
  /// The Amazon Resource Name (ARN) for the task template resource.
  final String? arn;

  /// Constraints that are applicable to the fields listed.
  final TaskTemplateConstraints? constraints;

  /// The identifier of the flow that runs by default when a task is created by
  /// referencing this template.
  final String? contactFlowId;

  /// The timestamp when the task template was created.
  final DateTime? createdTime;

  /// The default values for fields when a task is created by referencing this
  /// template.
  final TaskTemplateDefaults? defaults;

  /// The description of the task template.
  final String? description;

  /// Fields that are part of the template.
  final List<TaskTemplateField>? fields;

  /// The identifier of the task template resource.
  final String? id;

  /// The identifier of the Amazon Connect instance. You can <a
  /// href="https://docs.aws.amazon.com/connect/latest/adminguide/find-instance-arn.html">find
  /// the instance ID</a> in the Amazon Resource Name (ARN) of the instance.
  final String? instanceId;

  /// The timestamp when the task template was last modified.
  final DateTime? lastModifiedTime;

  /// The name of the task template.
  final String? name;

  /// Marks a template as <code>ACTIVE</code> or <code>INACTIVE</code> for a task
  /// to refer to it. Tasks can only be created from <code>ACTIVE</code>
  /// templates. If a template is marked as <code>INACTIVE</code>, then a task
  /// that refers to this template cannot be created.
  final TaskTemplateStatus? status;

  UpdateTaskTemplateResponse({
    this.arn,
    this.constraints,
    this.contactFlowId,
    this.createdTime,
    this.defaults,
    this.description,
    this.fields,
    this.id,
    this.instanceId,
    this.lastModifiedTime,
    this.name,
    this.status,
  });

  factory UpdateTaskTemplateResponse.fromJson(Map<String, dynamic> json) {
    return UpdateTaskTemplateResponse(
      arn: json['Arn'] as String?,
      constraints: json['Constraints'] != null
          ? TaskTemplateConstraints.fromJson(
              json['Constraints'] as Map<String, dynamic>)
          : null,
      contactFlowId: json['ContactFlowId'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      defaults: json['Defaults'] != null
          ? TaskTemplateDefaults.fromJson(
              json['Defaults'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      fields: (json['Fields'] as List?)
          ?.nonNulls
          .map((e) => TaskTemplateField.fromJson(e as Map<String, dynamic>))
          .toList(),
      id: json['Id'] as String?,
      instanceId: json['InstanceId'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      status: (json['Status'] as String?)?.let(TaskTemplateStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final constraints = this.constraints;
    final contactFlowId = this.contactFlowId;
    final createdTime = this.createdTime;
    final defaults = this.defaults;
    final description = this.description;
    final fields = this.fields;
    final id = this.id;
    final instanceId = this.instanceId;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (constraints != null) 'Constraints': constraints,
      if (contactFlowId != null) 'ContactFlowId': contactFlowId,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (defaults != null) 'Defaults': defaults,
      if (description != null) 'Description': description,
      if (fields != null) 'Fields': fields,
      if (id != null) 'Id': id,
      if (instanceId != null) 'InstanceId': instanceId,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
    };
  }
}

class UpdateTrafficDistributionResponse {
  UpdateTrafficDistributionResponse();

  factory UpdateTrafficDistributionResponse.fromJson(Map<String, dynamic> _) {
    return UpdateTrafficDistributionResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateViewContentResponse {
  /// A view resource object. Contains metadata and content necessary to render
  /// the view.
  final View? view;

  UpdateViewContentResponse({
    this.view,
  });

  factory UpdateViewContentResponse.fromJson(Map<String, dynamic> json) {
    return UpdateViewContentResponse(
      view: json['View'] != null
          ? View.fromJson(json['View'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final view = this.view;
    return {
      if (view != null) 'View': view,
    };
  }
}

class UpdateViewMetadataResponse {
  UpdateViewMetadataResponse();

  factory UpdateViewMetadataResponse.fromJson(Map<String, dynamic> _) {
    return UpdateViewMetadataResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Fields required when uploading an attached file.
class UploadUrlMetadata {
  /// A map of headers that should be provided when uploading the attached file.
  final Map<String, String>? headersToInclude;

  /// A pre-signed S3 URL that should be used for uploading the attached file.
  final String? url;

  /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601
  /// format: <code>yyyy-MM-ddThh:mm:ss.SSSZ</code>. For example,
  /// <code>2019-11-08T02:41:28.172Z</code>.
  final String? urlExpiry;

  UploadUrlMetadata({
    this.headersToInclude,
    this.url,
    this.urlExpiry,
  });

  factory UploadUrlMetadata.fromJson(Map<String, dynamic> json) {
    return UploadUrlMetadata(
      headersToInclude: (json['HeadersToInclude'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      url: json['Url'] as String?,
      urlExpiry: json['UrlExpiry'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final headersToInclude = this.headersToInclude;
    final url = this.url;
    final urlExpiry = this.urlExpiry;
    return {
      if (headersToInclude != null) 'HeadersToInclude': headersToInclude,
      if (url != null) 'Url': url,
      if (urlExpiry != null) 'UrlExpiry': urlExpiry,
    };
  }
}

/// The URL reference.
class UrlReference {
  /// Identifier of the URL reference.
  final String? name;

  /// A valid URL.
  final String? value;

  UrlReference({
    this.name,
    this.value,
  });

  factory UrlReference.fromJson(Map<String, dynamic> json) {
    return UrlReference(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// Contains the use case.
class UseCase {
  /// The Amazon Resource Name (ARN) for the use case.
  final String? useCaseArn;

  /// The identifier for the use case.
  final String? useCaseId;

  /// The type of use case to associate to the integration association. Each
  /// integration association can have only one of each use case type.
  final UseCaseType? useCaseType;

  UseCase({
    this.useCaseArn,
    this.useCaseId,
    this.useCaseType,
  });

  factory UseCase.fromJson(Map<String, dynamic> json) {
    return UseCase(
      useCaseArn: json['UseCaseArn'] as String?,
      useCaseId: json['UseCaseId'] as String?,
      useCaseType:
          (json['UseCaseType'] as String?)?.let(UseCaseType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final useCaseArn = this.useCaseArn;
    final useCaseId = this.useCaseId;
    final useCaseType = this.useCaseType;
    return {
      if (useCaseArn != null) 'UseCaseArn': useCaseArn,
      if (useCaseId != null) 'UseCaseId': useCaseId,
      if (useCaseType != null) 'UseCaseType': useCaseType.value,
    };
  }
}

enum UseCaseType {
  rulesEvaluation('RULES_EVALUATION'),
  connectCampaigns('CONNECT_CAMPAIGNS'),
  ;

  final String value;

  const UseCaseType(this.value);

  static UseCaseType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum UseCaseType'));
}

/// Contains information about a user account for an Amazon Connect instance.
class User {
  /// The Amazon Resource Name (ARN) of the user account.
  final String? arn;

  /// The identifier of the user account in the directory used for identity
  /// management.
  final String? directoryUserId;

  /// The identifier of the hierarchy group for the user.
  final String? hierarchyGroupId;

  /// The identifier of the user account.
  final String? id;

  /// Information about the user identity.
  final UserIdentityInfo? identityInfo;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// Information about the phone configuration for the user.
  final UserPhoneConfig? phoneConfig;

  /// The identifier of the routing profile for the user.
  final String? routingProfileId;

  /// The identifiers of the security profiles for the user.
  final List<String>? securityProfileIds;

  /// The tags.
  final Map<String, String>? tags;

  /// The user name assigned to the user account.
  final String? username;

  User({
    this.arn,
    this.directoryUserId,
    this.hierarchyGroupId,
    this.id,
    this.identityInfo,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.phoneConfig,
    this.routingProfileId,
    this.securityProfileIds,
    this.tags,
    this.username,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      arn: json['Arn'] as String?,
      directoryUserId: json['DirectoryUserId'] as String?,
      hierarchyGroupId: json['HierarchyGroupId'] as String?,
      id: json['Id'] as String?,
      identityInfo: json['IdentityInfo'] != null
          ? UserIdentityInfo.fromJson(
              json['IdentityInfo'] as Map<String, dynamic>)
          : null,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      phoneConfig: json['PhoneConfig'] != null
          ? UserPhoneConfig.fromJson(
              json['PhoneConfig'] as Map<String, dynamic>)
          : null,
      routingProfileId: json['RoutingProfileId'] as String?,
      securityProfileIds: (json['SecurityProfileIds'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      username: json['Username'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final directoryUserId = this.directoryUserId;
    final hierarchyGroupId = this.hierarchyGroupId;
    final id = this.id;
    final identityInfo = this.identityInfo;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final phoneConfig = this.phoneConfig;
    final routingProfileId = this.routingProfileId;
    final securityProfileIds = this.securityProfileIds;
    final tags = this.tags;
    final username = this.username;
    return {
      if (arn != null) 'Arn': arn,
      if (directoryUserId != null) 'DirectoryUserId': directoryUserId,
      if (hierarchyGroupId != null) 'HierarchyGroupId': hierarchyGroupId,
      if (id != null) 'Id': id,
      if (identityInfo != null) 'IdentityInfo': identityInfo,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (phoneConfig != null) 'PhoneConfig': phoneConfig,
      if (routingProfileId != null) 'RoutingProfileId': routingProfileId,
      if (securityProfileIds != null) 'SecurityProfileIds': securityProfileIds,
      if (tags != null) 'Tags': tags,
      if (username != null) 'Username': username,
    };
  }
}

/// Data for a user.
class UserData {
  /// A map of active slots by channel. The key is a channel name. The value is an
  /// integer: the number of active slots.
  final Map<Channel, int>? activeSlotsByChannel;

  /// A map of available slots by channel. The key is a channel name. The value is
  /// an integer: the available number of slots.
  final Map<Channel, int>? availableSlotsByChannel;

  /// A list of contact reference information.
  final List<AgentContactReference>? contacts;

  /// Contains information about the levels of a hierarchy group assigned to a
  /// user.
  final HierarchyPathReference? hierarchyPath;

  /// A map of maximum slots by channel. The key is a channel name. The value is
  /// an integer: the maximum number of slots. This is calculated from <a
  /// href="https://docs.aws.amazon.com/connect/latest/APIReference/API_MediaConcurrency.html">MediaConcurrency</a>
  /// of the <code>RoutingProfile</code> assigned to the agent.
  final Map<Channel, int>? maxSlotsByChannel;

  /// The Next status of the agent.
  final String? nextStatus;

  /// Information about the routing profile that is assigned to the user.
  final RoutingProfileReference? routingProfile;

  /// The status of the agent that they manually set in their Contact Control
  /// Panel (CCP), or that the supervisor manually changes in the real-time
  /// metrics report.
  final AgentStatusReference? status;

  /// Information about the user for the data that is returned. It contains the
  /// <code>resourceId</code> and ARN of the user.
  final UserReference? user;

  UserData({
    this.activeSlotsByChannel,
    this.availableSlotsByChannel,
    this.contacts,
    this.hierarchyPath,
    this.maxSlotsByChannel,
    this.nextStatus,
    this.routingProfile,
    this.status,
    this.user,
  });

  factory UserData.fromJson(Map<String, dynamic> json) {
    return UserData(
      activeSlotsByChannel:
          (json['ActiveSlotsByChannel'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(Channel.fromString(k), e as int)),
      availableSlotsByChannel:
          (json['AvailableSlotsByChannel'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(Channel.fromString(k), e as int)),
      contacts: (json['Contacts'] as List?)
          ?.nonNulls
          .map((e) => AgentContactReference.fromJson(e as Map<String, dynamic>))
          .toList(),
      hierarchyPath: json['HierarchyPath'] != null
          ? HierarchyPathReference.fromJson(
              json['HierarchyPath'] as Map<String, dynamic>)
          : null,
      maxSlotsByChannel: (json['MaxSlotsByChannel'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(Channel.fromString(k), e as int)),
      nextStatus: json['NextStatus'] as String?,
      routingProfile: json['RoutingProfile'] != null
          ? RoutingProfileReference.fromJson(
              json['RoutingProfile'] as Map<String, dynamic>)
          : null,
      status: json['Status'] != null
          ? AgentStatusReference.fromJson(
              json['Status'] as Map<String, dynamic>)
          : null,
      user: json['User'] != null
          ? UserReference.fromJson(json['User'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final activeSlotsByChannel = this.activeSlotsByChannel;
    final availableSlotsByChannel = this.availableSlotsByChannel;
    final contacts = this.contacts;
    final hierarchyPath = this.hierarchyPath;
    final maxSlotsByChannel = this.maxSlotsByChannel;
    final nextStatus = this.nextStatus;
    final routingProfile = this.routingProfile;
    final status = this.status;
    final user = this.user;
    return {
      if (activeSlotsByChannel != null)
        'ActiveSlotsByChannel':
            activeSlotsByChannel.map((k, e) => MapEntry(k.value, e)),
      if (availableSlotsByChannel != null)
        'AvailableSlotsByChannel':
            availableSlotsByChannel.map((k, e) => MapEntry(k.value, e)),
      if (contacts != null) 'Contacts': contacts,
      if (hierarchyPath != null) 'HierarchyPath': hierarchyPath,
      if (maxSlotsByChannel != null)
        'MaxSlotsByChannel':
            maxSlotsByChannel.map((k, e) => MapEntry(k.value, e)),
      if (nextStatus != null) 'NextStatus': nextStatus,
      if (routingProfile != null) 'RoutingProfile': routingProfile,
      if (status != null) 'Status': status,
      if (user != null) 'User': user,
    };
  }
}

/// A filter for the user data.
class UserDataFilters {
  /// A list of up to 100 agent IDs or ARNs.
  final List<String>? agents;

  /// A filter for the user data based on the contact information that is
  /// associated to the user. It contains a list of contact states.
  final ContactFilter? contactFilter;

  /// A list of up to 100 queues or ARNs.
  final List<String>? queues;

  /// A list of up to 100 routing profile IDs or ARNs.
  final List<String>? routingProfiles;

  /// A UserHierarchyGroup ID or ARN.
  final List<String>? userHierarchyGroups;

  UserDataFilters({
    this.agents,
    this.contactFilter,
    this.queues,
    this.routingProfiles,
    this.userHierarchyGroups,
  });

  Map<String, dynamic> toJson() {
    final agents = this.agents;
    final contactFilter = this.contactFilter;
    final queues = this.queues;
    final routingProfiles = this.routingProfiles;
    final userHierarchyGroups = this.userHierarchyGroups;
    return {
      if (agents != null) 'Agents': agents,
      if (contactFilter != null) 'ContactFilter': contactFilter,
      if (queues != null) 'Queues': queues,
      if (routingProfiles != null) 'RoutingProfiles': routingProfiles,
      if (userHierarchyGroups != null)
        'UserHierarchyGroups': userHierarchyGroups,
    };
  }
}

/// Contains information about the identity of a user.
/// <note>
/// For Amazon Connect instances that are created with the
/// <code>EXISTING_DIRECTORY</code> identity management type,
/// <code>FirstName</code>, <code>LastName</code>, and <code>Email</code> cannot
/// be updated from within Amazon Connect because they are managed by the
/// directory.
/// </note>
class UserIdentityInfo {
  /// The email address. If you are using SAML for identity management and include
  /// this parameter, an error is returned.
  final String? email;

  /// The first name. This is required if you are using Amazon Connect or SAML for
  /// identity management.
  final String? firstName;

  /// The last name. This is required if you are using Amazon Connect or SAML for
  /// identity management.
  final String? lastName;

  /// The user's mobile number.
  final String? mobile;

  /// The user's secondary email address. If you provide a secondary email, the
  /// user receives email notifications - other than password reset notifications
  /// - to this email address instead of to their primary email address.
  ///
  /// Pattern:
  /// <code>(?=^.{0,265}$)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}</code>
  final String? secondaryEmail;

  UserIdentityInfo({
    this.email,
    this.firstName,
    this.lastName,
    this.mobile,
    this.secondaryEmail,
  });

  factory UserIdentityInfo.fromJson(Map<String, dynamic> json) {
    return UserIdentityInfo(
      email: json['Email'] as String?,
      firstName: json['FirstName'] as String?,
      lastName: json['LastName'] as String?,
      mobile: json['Mobile'] as String?,
      secondaryEmail: json['SecondaryEmail'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final email = this.email;
    final firstName = this.firstName;
    final lastName = this.lastName;
    final mobile = this.mobile;
    final secondaryEmail = this.secondaryEmail;
    return {
      if (email != null) 'Email': email,
      if (firstName != null) 'FirstName': firstName,
      if (lastName != null) 'LastName': lastName,
      if (mobile != null) 'Mobile': mobile,
      if (secondaryEmail != null) 'SecondaryEmail': secondaryEmail,
    };
  }
}

/// The user's first name and last name.
class UserIdentityInfoLite {
  /// The user's first name.
  final String? firstName;

  /// The user's last name.
  final String? lastName;

  UserIdentityInfoLite({
    this.firstName,
    this.lastName,
  });

  factory UserIdentityInfoLite.fromJson(Map<String, dynamic> json) {
    return UserIdentityInfoLite(
      firstName: json['FirstName'] as String?,
      lastName: json['LastName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final firstName = this.firstName;
    final lastName = this.lastName;
    return {
      if (firstName != null) 'FirstName': firstName,
      if (lastName != null) 'LastName': lastName,
    };
  }
}

/// Contains information about the phone configuration settings for a user.
class UserPhoneConfig {
  /// The phone type.
  final PhoneType phoneType;

  /// The After Call Work (ACW) timeout setting, in seconds. This parameter has a
  /// minimum value of 0 and a maximum value of 2,000,000 seconds (24 days). Enter
  /// 0 if you don't want to allocate a specific amount of ACW time. It
  /// essentially means an indefinite amount of time. When the conversation ends,
  /// ACW starts; the agent must choose Close contact to end ACW.
  /// <note>
  /// When returned by a <code>SearchUsers</code> call,
  /// <code>AfterContactWorkTimeLimit</code> is returned in milliseconds.
  /// </note>
  final int? afterContactWorkTimeLimit;

  /// The Auto accept setting.
  final bool? autoAccept;

  /// The phone number for the user's desk phone.
  final String? deskPhoneNumber;

  UserPhoneConfig({
    required this.phoneType,
    this.afterContactWorkTimeLimit,
    this.autoAccept,
    this.deskPhoneNumber,
  });

  factory UserPhoneConfig.fromJson(Map<String, dynamic> json) {
    return UserPhoneConfig(
      phoneType: PhoneType.fromString((json['PhoneType'] as String)),
      afterContactWorkTimeLimit: json['AfterContactWorkTimeLimit'] as int?,
      autoAccept: json['AutoAccept'] as bool?,
      deskPhoneNumber: json['DeskPhoneNumber'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final phoneType = this.phoneType;
    final afterContactWorkTimeLimit = this.afterContactWorkTimeLimit;
    final autoAccept = this.autoAccept;
    final deskPhoneNumber = this.deskPhoneNumber;
    return {
      'PhoneType': phoneType.value,
      if (afterContactWorkTimeLimit != null)
        'AfterContactWorkTimeLimit': afterContactWorkTimeLimit,
      if (autoAccept != null) 'AutoAccept': autoAccept,
      if (deskPhoneNumber != null) 'DeskPhoneNumber': deskPhoneNumber,
    };
  }
}

/// Information about proficiency of a user.
class UserProficiency {
  /// The name of user's proficiency. You must use name of predefined attribute
  /// present in the Amazon Connect instance.
  final String attributeName;

  /// The value of user's proficiency. You must use value of predefined attribute
  /// present in the Amazon Connect instance.
  final String attributeValue;

  /// The level of the proficiency. The valid values are 1, 2, 3, 4 and 5.
  final double level;

  UserProficiency({
    required this.attributeName,
    required this.attributeValue,
    required this.level,
  });

  factory UserProficiency.fromJson(Map<String, dynamic> json) {
    return UserProficiency(
      attributeName: json['AttributeName'] as String,
      attributeValue: json['AttributeValue'] as String,
      level: json['Level'] as double,
    );
  }

  Map<String, dynamic> toJson() {
    final attributeName = this.attributeName;
    final attributeValue = this.attributeValue;
    final level = this.level;
    return {
      'AttributeName': attributeName,
      'AttributeValue': attributeValue,
      'Level': level,
    };
  }
}

/// Information about proficiency to be disassociated from the user.
class UserProficiencyDisassociate {
  /// The name of user's proficiency.
  final String attributeName;

  /// The value of user's proficiency.
  final String attributeValue;

  UserProficiencyDisassociate({
    required this.attributeName,
    required this.attributeValue,
  });

  Map<String, dynamic> toJson() {
    final attributeName = this.attributeName;
    final attributeValue = this.attributeValue;
    return {
      'AttributeName': attributeName,
      'AttributeValue': attributeValue,
    };
  }
}

/// Contains information about the quick connect configuration settings for a
/// user. The contact flow must be of type Transfer to Agent.
class UserQuickConnectConfig {
  /// The identifier of the flow.
  final String contactFlowId;

  /// The identifier of the user.
  final String userId;

  UserQuickConnectConfig({
    required this.contactFlowId,
    required this.userId,
  });

  factory UserQuickConnectConfig.fromJson(Map<String, dynamic> json) {
    return UserQuickConnectConfig(
      contactFlowId: json['ContactFlowId'] as String,
      userId: json['UserId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final contactFlowId = this.contactFlowId;
    final userId = this.userId;
    return {
      'ContactFlowId': contactFlowId,
      'UserId': userId,
    };
  }
}

/// Information about the user.
class UserReference {
  /// The Amazon Resource Name (ARN) for the user.
  final String? arn;

  /// The unique identifier for the user.
  final String? id;

  UserReference({
    this.arn,
    this.id,
  });

  factory UserReference.fromJson(Map<String, dynamic> json) {
    return UserReference(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
    };
  }
}

/// The search criteria to be used to return users.
/// <note>
/// The <code>name</code> and <code>description</code> fields support "contains"
/// queries with a minimum of 2 characters and a maximum of 25 characters. Any
/// queries with character lengths outside of this range will throw invalid
/// results.
/// </note>
class UserSearchCriteria {
  /// A list of conditions which would be applied together with an
  /// <code>AND</code> condition.
  final List<UserSearchCriteria>? andConditions;

  /// A leaf node condition which can be used to specify a hierarchy group
  /// condition.
  final HierarchyGroupCondition? hierarchyGroupCondition;

  /// A list of conditions which would be applied together with an <code>OR</code>
  /// condition.
  final List<UserSearchCriteria>? orConditions;

  /// A leaf node condition which can be used to specify a string condition.
  ///
  /// The currently supported values for <code>FieldName</code> are
  /// <code>Username</code>, <code>FirstName</code>, <code>LastName</code>,
  /// <code>RoutingProfileId</code>, <code>SecurityProfileId</code>,
  /// <code>ResourceId</code>.
  final StringCondition? stringCondition;

  UserSearchCriteria({
    this.andConditions,
    this.hierarchyGroupCondition,
    this.orConditions,
    this.stringCondition,
  });

  Map<String, dynamic> toJson() {
    final andConditions = this.andConditions;
    final hierarchyGroupCondition = this.hierarchyGroupCondition;
    final orConditions = this.orConditions;
    final stringCondition = this.stringCondition;
    return {
      if (andConditions != null) 'AndConditions': andConditions,
      if (hierarchyGroupCondition != null)
        'HierarchyGroupCondition': hierarchyGroupCondition,
      if (orConditions != null) 'OrConditions': orConditions,
      if (stringCondition != null) 'StringCondition': stringCondition,
    };
  }
}

/// Filters to be applied to search results.
class UserSearchFilter {
  final ControlPlaneTagFilter? tagFilter;

  /// An object that can be used to specify Tag conditions or Hierarchy Group
  /// conditions inside the SearchFilter.
  ///
  /// This accepts an <code>OR</code> of <code>AND</code> (List of List) input
  /// where:
  ///
  /// <ul>
  /// <li>
  /// The top level list specifies conditions that need to be applied with
  /// <code>OR</code> operator.
  /// </li>
  /// <li>
  /// The inner list specifies conditions that need to be applied with
  /// <code>AND</code> operator.
  /// </li>
  /// </ul> <note>
  /// Only one field can be populated. This object can’t be used along with
  /// TagFilter. Request can either contain TagFilter or UserAttributeFilter if
  /// SearchFilter is specified, combination of both is not supported and such
  /// request will throw AccessDeniedException.
  /// </note>
  final ControlPlaneUserAttributeFilter? userAttributeFilter;

  UserSearchFilter({
    this.tagFilter,
    this.userAttributeFilter,
  });

  Map<String, dynamic> toJson() {
    final tagFilter = this.tagFilter;
    final userAttributeFilter = this.userAttributeFilter;
    return {
      if (tagFilter != null) 'TagFilter': tagFilter,
      if (userAttributeFilter != null)
        'UserAttributeFilter': userAttributeFilter,
    };
  }
}

/// Information about the returned users.
class UserSearchSummary {
  /// The Amazon Resource Name (ARN) of the user.
  final String? arn;

  /// The directory identifier of the user.
  final String? directoryUserId;

  /// The identifier of the user's hierarchy group.
  final String? hierarchyGroupId;

  /// The identifier of the user's summary.
  final String? id;

  /// The user's first name and last name.
  final UserIdentityInfoLite? identityInfo;
  final UserPhoneConfig? phoneConfig;

  /// The identifier of the user's routing profile.
  final String? routingProfileId;

  /// The identifiers of the user's security profiles.
  final List<String>? securityProfileIds;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  /// The name of the user.
  final String? username;

  UserSearchSummary({
    this.arn,
    this.directoryUserId,
    this.hierarchyGroupId,
    this.id,
    this.identityInfo,
    this.phoneConfig,
    this.routingProfileId,
    this.securityProfileIds,
    this.tags,
    this.username,
  });

  factory UserSearchSummary.fromJson(Map<String, dynamic> json) {
    return UserSearchSummary(
      arn: json['Arn'] as String?,
      directoryUserId: json['DirectoryUserId'] as String?,
      hierarchyGroupId: json['HierarchyGroupId'] as String?,
      id: json['Id'] as String?,
      identityInfo: json['IdentityInfo'] != null
          ? UserIdentityInfoLite.fromJson(
              json['IdentityInfo'] as Map<String, dynamic>)
          : null,
      phoneConfig: json['PhoneConfig'] != null
          ? UserPhoneConfig.fromJson(
              json['PhoneConfig'] as Map<String, dynamic>)
          : null,
      routingProfileId: json['RoutingProfileId'] as String?,
      securityProfileIds: (json['SecurityProfileIds'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      username: json['Username'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final directoryUserId = this.directoryUserId;
    final hierarchyGroupId = this.hierarchyGroupId;
    final id = this.id;
    final identityInfo = this.identityInfo;
    final phoneConfig = this.phoneConfig;
    final routingProfileId = this.routingProfileId;
    final securityProfileIds = this.securityProfileIds;
    final tags = this.tags;
    final username = this.username;
    return {
      if (arn != null) 'Arn': arn,
      if (directoryUserId != null) 'DirectoryUserId': directoryUserId,
      if (hierarchyGroupId != null) 'HierarchyGroupId': hierarchyGroupId,
      if (id != null) 'Id': id,
      if (identityInfo != null) 'IdentityInfo': identityInfo,
      if (phoneConfig != null) 'PhoneConfig': phoneConfig,
      if (routingProfileId != null) 'RoutingProfileId': routingProfileId,
      if (securityProfileIds != null) 'SecurityProfileIds': securityProfileIds,
      if (tags != null) 'Tags': tags,
      if (username != null) 'Username': username,
    };
  }
}

/// Contains summary information about a user.
class UserSummary {
  /// The Amazon Resource Name (ARN) of the user account.
  final String? arn;

  /// The identifier of the user account.
  final String? id;

  /// The Amazon Web Services Region where this resource was last modified.
  final String? lastModifiedRegion;

  /// The timestamp when this resource was last modified.
  final DateTime? lastModifiedTime;

  /// The Amazon Connect user name of the user account.
  final String? username;

  UserSummary({
    this.arn,
    this.id,
    this.lastModifiedRegion,
    this.lastModifiedTime,
    this.username,
  });

  factory UserSummary.fromJson(Map<String, dynamic> json) {
    return UserSummary(
      arn: json['Arn'] as String?,
      id: json['Id'] as String?,
      lastModifiedRegion: json['LastModifiedRegion'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      username: json['Username'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final lastModifiedRegion = this.lastModifiedRegion;
    final lastModifiedTime = this.lastModifiedTime;
    final username = this.username;
    return {
      if (arn != null) 'Arn': arn,
      if (id != null) 'Id': id,
      if (lastModifiedRegion != null) 'LastModifiedRegion': lastModifiedRegion,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (username != null) 'Username': username,
    };
  }
}

enum VideoCapability {
  send('SEND'),
  ;

  final String value;

  const VideoCapability(this.value);

  static VideoCapability fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum VideoCapability'));
}

/// A view resource object. Contains metadata and content necessary to render
/// the view.
class View {
  /// The Amazon Resource Name (ARN) of the view.
  final String? arn;

  /// View content containing all content necessary to render a view except for
  /// runtime input data.
  final ViewContent? content;

  /// The timestamp of when the view was created.
  final DateTime? createdTime;

  /// The description of the view.
  final String? description;

  /// The identifier of the view.
  final String? id;

  /// Latest timestamp of the <code>UpdateViewContent</code> or
  /// <code>CreateViewVersion</code> operations.
  final DateTime? lastModifiedTime;

  /// The name of the view.
  final String? name;

  /// Indicates the view status as either <code>SAVED</code> or
  /// <code>PUBLISHED</code>. The <code>PUBLISHED</code> status will initiate
  /// validation on the content.
  final ViewStatus? status;

  /// The tags associated with the view resource (not specific to view version).
  final Map<String, String>? tags;

  /// The type of the view - <code>CUSTOMER_MANAGED</code>.
  final ViewType? type;

  /// Current version of the view.
  final int? version;

  /// The description of the version.
  final String? versionDescription;

  /// Indicates the checksum value of the latest published view content.
  final String? viewContentSha256;

  View({
    this.arn,
    this.content,
    this.createdTime,
    this.description,
    this.id,
    this.lastModifiedTime,
    this.name,
    this.status,
    this.tags,
    this.type,
    this.version,
    this.versionDescription,
    this.viewContentSha256,
  });

  factory View.fromJson(Map<String, dynamic> json) {
    return View(
      arn: json['Arn'] as String?,
      content: json['Content'] != null
          ? ViewContent.fromJson(json['Content'] as Map<String, dynamic>)
          : null,
      createdTime: timeStampFromJson(json['CreatedTime']),
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      lastModifiedTime: timeStampFromJson(json['LastModifiedTime']),
      name: json['Name'] as String?,
      status: (json['Status'] as String?)?.let(ViewStatus.fromString),
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      type: (json['Type'] as String?)?.let(ViewType.fromString),
      version: json['Version'] as int?,
      versionDescription: json['VersionDescription'] as String?,
      viewContentSha256: json['ViewContentSha256'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final content = this.content;
    final createdTime = this.createdTime;
    final description = this.description;
    final id = this.id;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final status = this.status;
    final tags = this.tags;
    final type = this.type;
    final version = this.version;
    final versionDescription = this.versionDescription;
    final viewContentSha256 = this.viewContentSha256;
    return {
      if (arn != null) 'Arn': arn,
      if (content != null) 'Content': content,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (lastModifiedTime != null)
        'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
      if (tags != null) 'Tags': tags,
      if (type != null) 'Type': type.value,
      if (version != null) 'Version': version,
      if (versionDescription != null) 'VersionDescription': versionDescription,
      if (viewContentSha256 != null) 'ViewContentSha256': viewContentSha256,
    };
  }
}

/// View content containing all content necessary to render a view except for
/// runtime input data.
class ViewContent {
  /// A list of possible actions from the view.
  final List<String>? actions;

  /// The data schema matching data that the view template must be provided to
  /// render.
  final String? inputSchema;

  /// The view template representing the structure of the view.
  final String? template;

  ViewContent({
    this.actions,
    this.inputSchema,
    this.template,
  });

  factory ViewContent.fromJson(Map<String, dynamic> json) {
    return ViewContent(
      actions:
          (json['Actions'] as List?)?.nonNulls.map((e) => e as String).toList(),
      inputSchema: json['InputSchema'] as String?,
      template: json['Template'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final inputSchema = this.inputSchema;
    final template = this.template;
    return {
      if (actions != null) 'Actions': actions,
      if (inputSchema != null) 'InputSchema': inputSchema,
      if (template != null) 'Template': template,
    };
  }
}

/// View content containing all content necessary to render a view except for
/// runtime input data and the runtime input schema, which is auto-generated by
/// this operation.
class ViewInputContent {
  /// A list of possible actions from the view.
  final List<String>? actions;

  /// The view template representing the structure of the view.
  final String? template;

  ViewInputContent({
    this.actions,
    this.template,
  });

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final template = this.template;
    return {
      if (actions != null) 'Actions': actions,
      if (template != null) 'Template': template,
    };
  }
}

enum ViewStatus {
  published('PUBLISHED'),
  saved('SAVED'),
  ;

  final String value;

  const ViewStatus(this.value);

  static ViewStatus fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum ViewStatus'));
}

/// A summary of a view's metadata.
class ViewSummary {
  /// The Amazon Resource Name (ARN) of the view.
  final String? arn;

  /// The description of the view.
  final String? description;

  /// The identifier of the view.
  final String? id;

  /// The name of the view.
  final String? name;

  /// Indicates the view status as either <code>SAVED</code> or
  /// <code>PUBLISHED</code>. The <code>PUBLISHED</code> status will initiate
  /// validation on the content.
  final ViewStatus? status;

  /// The type of the view.
  final ViewType? type;

  ViewSummary({
    this.arn,
    this.description,
    this.id,
    this.name,
    this.status,
    this.type,
  });

  factory ViewSummary.fromJson(Map<String, dynamic> json) {
    return ViewSummary(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      status: (json['Status'] as String?)?.let(ViewStatus.fromString),
      type: (json['Type'] as String?)?.let(ViewType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final status = this.status;
    final type = this.type;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.value,
      if (type != null) 'Type': type.value,
    };
  }
}

enum ViewType {
  customerManaged('CUSTOMER_MANAGED'),
  awsManaged('AWS_MANAGED'),
  ;

  final String value;

  const ViewType(this.value);

  static ViewType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum ViewType'));
}

/// A summary of a view version's metadata.
class ViewVersionSummary {
  /// The Amazon Resource Name (ARN) of the view version.
  final String? arn;

  /// The description of the view version.
  final String? description;

  /// The identifier of the view version.
  final String? id;

  /// The name of the view version.
  final String? name;

  /// The type of the view version.
  final ViewType? type;

  /// The sequentially incremented version of the view version.
  final int? version;

  /// The description of the view version.
  final String? versionDescription;

  ViewVersionSummary({
    this.arn,
    this.description,
    this.id,
    this.name,
    this.type,
    this.version,
    this.versionDescription,
  });

  factory ViewVersionSummary.fromJson(Map<String, dynamic> json) {
    return ViewVersionSummary(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      type: (json['Type'] as String?)?.let(ViewType.fromString),
      version: json['Version'] as int?,
      versionDescription: json['VersionDescription'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final type = this.type;
    final version = this.version;
    final versionDescription = this.versionDescription;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (type != null) 'Type': type.value,
      if (version != null) 'Version': version,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
  }
}

/// Contains information about a custom vocabulary.
class Vocabulary {
  /// The Amazon Resource Name (ARN) of the custom vocabulary.
  final String arn;

  /// The identifier of the custom vocabulary.
  final String id;

  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  final VocabularyLanguageCode languageCode;

  /// The timestamp when the custom vocabulary was last modified.
  final DateTime lastModifiedTime;

  /// A unique name of the custom vocabulary.
  final String name;

  /// The current state of the custom vocabulary.
  final VocabularyState state;

  /// The content of the custom vocabulary in plain-text format with a table of
  /// values. Each row in the table represents a word or a phrase, described with
  /// <code>Phrase</code>, <code>IPA</code>, <code>SoundsLike</code>, and
  /// <code>DisplayAs</code> fields. Separate the fields with TAB characters. For
  /// more information, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html#create-vocabulary-table">Create
  /// a custom vocabulary using a table</a>.
  final String? content;

  /// The reason why the custom vocabulary was not created.
  final String? failureReason;

  /// The tags used to organize, track, or control access for this resource. For
  /// example, { "Tags": {"key1":"value1", "key2":"value2"} }.
  final Map<String, String>? tags;

  Vocabulary({
    required this.arn,
    required this.id,
    required this.languageCode,
    required this.lastModifiedTime,
    required this.name,
    required this.state,
    this.content,
    this.failureReason,
    this.tags,
  });

  factory Vocabulary.fromJson(Map<String, dynamic> json) {
    return Vocabulary(
      arn: json['Arn'] as String,
      id: json['Id'] as String,
      languageCode:
          VocabularyLanguageCode.fromString((json['LanguageCode'] as String)),
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      name: json['Name'] as String,
      state: VocabularyState.fromString((json['State'] as String)),
      content: json['Content'] as String?,
      failureReason: json['FailureReason'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final languageCode = this.languageCode;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final state = this.state;
    final content = this.content;
    final failureReason = this.failureReason;
    final tags = this.tags;
    return {
      'Arn': arn,
      'Id': id,
      'LanguageCode': languageCode.value,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'Name': name,
      'State': state.value,
      if (content != null) 'Content': content,
      if (failureReason != null) 'FailureReason': failureReason,
      if (tags != null) 'Tags': tags,
    };
  }
}

enum VocabularyLanguageCode {
  arAe('ar-AE'),
  deCh('de-CH'),
  deDe('de-DE'),
  enAb('en-AB'),
  enAu('en-AU'),
  enGb('en-GB'),
  enIe('en-IE'),
  enIn('en-IN'),
  enUs('en-US'),
  enWl('en-WL'),
  esEs('es-ES'),
  esUs('es-US'),
  frCa('fr-CA'),
  frFr('fr-FR'),
  hiIn('hi-IN'),
  itIt('it-IT'),
  jaJp('ja-JP'),
  koKr('ko-KR'),
  ptBr('pt-BR'),
  ptPt('pt-PT'),
  zhCn('zh-CN'),
  enNz('en-NZ'),
  enZa('en-ZA'),
  ;

  final String value;

  const VocabularyLanguageCode(this.value);

  static VocabularyLanguageCode fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum VocabularyLanguageCode'));
}

enum VocabularyState {
  creationInProgress('CREATION_IN_PROGRESS'),
  active('ACTIVE'),
  creationFailed('CREATION_FAILED'),
  deleteInProgress('DELETE_IN_PROGRESS'),
  ;

  final String value;

  const VocabularyState(this.value);

  static VocabularyState fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum VocabularyState'));
}

/// Contains summary information about the custom vocabulary.
class VocabularySummary {
  /// The Amazon Resource Name (ARN) of the custom vocabulary.
  final String arn;

  /// The identifier of the custom vocabulary.
  final String id;

  /// The language code of the vocabulary entries. For a list of languages and
  /// their corresponding language codes, see <a
  /// href="https://docs.aws.amazon.com/transcribe/latest/dg/transcribe-whatis.html">What
  /// is Amazon Transcribe?</a>
  final VocabularyLanguageCode languageCode;

  /// The timestamp when the custom vocabulary was last modified.
  final DateTime lastModifiedTime;

  /// A unique name of the custom vocabulary.
  final String name;

  /// The current state of the custom vocabulary.
  final VocabularyState state;

  /// The reason why the custom vocabulary was not created.
  final String? failureReason;

  VocabularySummary({
    required this.arn,
    required this.id,
    required this.languageCode,
    required this.lastModifiedTime,
    required this.name,
    required this.state,
    this.failureReason,
  });

  factory VocabularySummary.fromJson(Map<String, dynamic> json) {
    return VocabularySummary(
      arn: json['Arn'] as String,
      id: json['Id'] as String,
      languageCode:
          VocabularyLanguageCode.fromString((json['LanguageCode'] as String)),
      lastModifiedTime:
          nonNullableTimeStampFromJson(json['LastModifiedTime'] as Object),
      name: json['Name'] as String,
      state: VocabularyState.fromString((json['State'] as String)),
      failureReason: json['FailureReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final id = this.id;
    final languageCode = this.languageCode;
    final lastModifiedTime = this.lastModifiedTime;
    final name = this.name;
    final state = this.state;
    final failureReason = this.failureReason;
    return {
      'Arn': arn,
      'Id': id,
      'LanguageCode': languageCode.value,
      'LastModifiedTime': unixTimestampToJson(lastModifiedTime),
      'Name': name,
      'State': state.value,
      if (failureReason != null) 'FailureReason': failureReason,
    };
  }
}

/// Contains information about the recording configuration settings.
class VoiceRecordingConfiguration {
  /// Identifies which track is being recorded.
  final VoiceRecordingTrack? voiceRecordingTrack;

  VoiceRecordingConfiguration({
    this.voiceRecordingTrack,
  });

  Map<String, dynamic> toJson() {
    final voiceRecordingTrack = this.voiceRecordingTrack;
    return {
      if (voiceRecordingTrack != null)
        'VoiceRecordingTrack': voiceRecordingTrack.value,
    };
  }
}

enum VoiceRecordingTrack {
  fromAgent('FROM_AGENT'),
  toAgent('TO_AGENT'),
  all('ALL'),
  ;

  final String value;

  const VoiceRecordingTrack(this.value);

  static VoiceRecordingTrack fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum VoiceRecordingTrack'));
}

/// Information about Amazon Connect Wisdom.
class WisdomInfo {
  /// The Amazon Resource Name (ARN) of the Wisdom session.
  final String? sessionArn;

  WisdomInfo({
    this.sessionArn,
  });

  factory WisdomInfo.fromJson(Map<String, dynamic> json) {
    return WisdomInfo(
      sessionArn: json['SessionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final sessionArn = this.sessionArn;
    return {
      if (sessionArn != null) 'SessionArn': sessionArn,
    };
  }
}

class AccessDeniedException extends _s.GenericAwsException {
  AccessDeniedException({String? type, String? message})
      : super(type: type, code: 'AccessDeniedException', message: message);
}

class ConflictException extends _s.GenericAwsException {
  ConflictException({String? type, String? message})
      : super(type: type, code: 'ConflictException', message: message);
}

class ContactFlowNotPublishedException extends _s.GenericAwsException {
  ContactFlowNotPublishedException({String? type, String? message})
      : super(
            type: type,
            code: 'ContactFlowNotPublishedException',
            message: message);
}

class ContactNotFoundException extends _s.GenericAwsException {
  ContactNotFoundException({String? type, String? message})
      : super(type: type, code: 'ContactNotFoundException', message: message);
}

class DestinationNotAllowedException extends _s.GenericAwsException {
  DestinationNotAllowedException({String? type, String? message})
      : super(
            type: type,
            code: 'DestinationNotAllowedException',
            message: message);
}

class DuplicateResourceException extends _s.GenericAwsException {
  DuplicateResourceException({String? type, String? message})
      : super(type: type, code: 'DuplicateResourceException', message: message);
}

class IdempotencyException extends _s.GenericAwsException {
  IdempotencyException({String? type, String? message})
      : super(type: type, code: 'IdempotencyException', message: message);
}

class InternalServiceException extends _s.GenericAwsException {
  InternalServiceException({String? type, String? message})
      : super(type: type, code: 'InternalServiceException', message: message);
}

class InvalidContactFlowException extends _s.GenericAwsException {
  InvalidContactFlowException({String? type, String? message})
      : super(
            type: type, code: 'InvalidContactFlowException', message: message);
}

class InvalidContactFlowModuleException extends _s.GenericAwsException {
  InvalidContactFlowModuleException({String? type, String? message})
      : super(
            type: type,
            code: 'InvalidContactFlowModuleException',
            message: message);
}

class InvalidParameterException extends _s.GenericAwsException {
  InvalidParameterException({String? type, String? message})
      : super(type: type, code: 'InvalidParameterException', message: message);
}

class InvalidRequestException extends _s.GenericAwsException {
  InvalidRequestException({String? type, String? message})
      : super(type: type, code: 'InvalidRequestException', message: message);
}

class LimitExceededException extends _s.GenericAwsException {
  LimitExceededException({String? type, String? message})
      : super(type: type, code: 'LimitExceededException', message: message);
}

class MaximumResultReturnedException extends _s.GenericAwsException {
  MaximumResultReturnedException({String? type, String? message})
      : super(
            type: type,
            code: 'MaximumResultReturnedException',
            message: message);
}

class OutboundContactNotPermittedException extends _s.GenericAwsException {
  OutboundContactNotPermittedException({String? type, String? message})
      : super(
            type: type,
            code: 'OutboundContactNotPermittedException',
            message: message);
}

class OutputTypeNotFoundException extends _s.GenericAwsException {
  OutputTypeNotFoundException({String? type, String? message})
      : super(
            type: type, code: 'OutputTypeNotFoundException', message: message);
}

class PropertyValidationException extends _s.GenericAwsException {
  PropertyValidationException({String? type, String? message})
      : super(
            type: type, code: 'PropertyValidationException', message: message);
}

class ResourceConflictException extends _s.GenericAwsException {
  ResourceConflictException({String? type, String? message})
      : super(type: type, code: 'ResourceConflictException', message: message);
}

class ResourceInUseException extends _s.GenericAwsException {
  ResourceInUseException({String? type, String? message})
      : super(type: type, code: 'ResourceInUseException', message: message);
}

class ResourceNotFoundException extends _s.GenericAwsException {
  ResourceNotFoundException({String? type, String? message})
      : super(type: type, code: 'ResourceNotFoundException', message: message);
}

class ResourceNotReadyException extends _s.GenericAwsException {
  ResourceNotReadyException({String? type, String? message})
      : super(type: type, code: 'ResourceNotReadyException', message: message);
}

class ServiceQuotaExceededException extends _s.GenericAwsException {
  ServiceQuotaExceededException({String? type, String? message})
      : super(
            type: type,
            code: 'ServiceQuotaExceededException',
            message: message);
}

class ThrottlingException extends _s.GenericAwsException {
  ThrottlingException({String? type, String? message})
      : super(type: type, code: 'ThrottlingException', message: message);
}

class TooManyRequestsException extends _s.GenericAwsException {
  TooManyRequestsException({String? type, String? message})
      : super(type: type, code: 'TooManyRequestsException', message: message);
}

class UserNotFoundException extends _s.GenericAwsException {
  UserNotFoundException({String? type, String? message})
      : super(type: type, code: 'UserNotFoundException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'AccessDeniedException': (type, message) =>
      AccessDeniedException(type: type, message: message),
  'ConflictException': (type, message) =>
      ConflictException(type: type, message: message),
  'ContactFlowNotPublishedException': (type, message) =>
      ContactFlowNotPublishedException(type: type, message: message),
  'ContactNotFoundException': (type, message) =>
      ContactNotFoundException(type: type, message: message),
  'DestinationNotAllowedException': (type, message) =>
      DestinationNotAllowedException(type: type, message: message),
  'DuplicateResourceException': (type, message) =>
      DuplicateResourceException(type: type, message: message),
  'IdempotencyException': (type, message) =>
      IdempotencyException(type: type, message: message),
  'InternalServiceException': (type, message) =>
      InternalServiceException(type: type, message: message),
  'InvalidContactFlowException': (type, message) =>
      InvalidContactFlowException(type: type, message: message),
  'InvalidContactFlowModuleException': (type, message) =>
      InvalidContactFlowModuleException(type: type, message: message),
  'InvalidParameterException': (type, message) =>
      InvalidParameterException(type: type, message: message),
  'InvalidRequestException': (type, message) =>
      InvalidRequestException(type: type, message: message),
  'LimitExceededException': (type, message) =>
      LimitExceededException(type: type, message: message),
  'MaximumResultReturnedException': (type, message) =>
      MaximumResultReturnedException(type: type, message: message),
  'OutboundContactNotPermittedException': (type, message) =>
      OutboundContactNotPermittedException(type: type, message: message),
  'OutputTypeNotFoundException': (type, message) =>
      OutputTypeNotFoundException(type: type, message: message),
  'PropertyValidationException': (type, message) =>
      PropertyValidationException(type: type, message: message),
  'ResourceConflictException': (type, message) =>
      ResourceConflictException(type: type, message: message),
  'ResourceInUseException': (type, message) =>
      ResourceInUseException(type: type, message: message),
  'ResourceNotFoundException': (type, message) =>
      ResourceNotFoundException(type: type, message: message),
  'ResourceNotReadyException': (type, message) =>
      ResourceNotReadyException(type: type, message: message),
  'ServiceQuotaExceededException': (type, message) =>
      ServiceQuotaExceededException(type: type, message: message),
  'ThrottlingException': (type, message) =>
      ThrottlingException(type: type, message: message),
  'TooManyRequestsException': (type, message) =>
      TooManyRequestsException(type: type, message: message),
  'UserNotFoundException': (type, message) =>
      UserNotFoundException(type: type, message: message),
};
