// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        nonNullableTimeStampFromJson,
        timeStampFromJson;

export '../../shared/shared.dart' show AwsClientCredentials;

/// Security Hub provides you with a comprehensive view of your security state
/// in Amazon Web Services and helps you assess your Amazon Web Services
/// environment against security industry standards and best practices.
///
/// Security Hub collects security data across Amazon Web Services accounts,
/// Amazon Web Services, and supported third-party products and helps you
/// analyze your security trends and identify the highest priority security
/// issues.
///
/// To help you manage the security state of your organization, Security Hub
/// supports multiple security standards. These include the Amazon Web Services
/// Foundational Security Best Practices (FSBP) standard developed by Amazon Web
/// Services, and external compliance frameworks such as the Center for Internet
/// Security (CIS), the Payment Card Industry Data Security Standard (PCI DSS),
/// and the National Institute of Standards and Technology (NIST). Each standard
/// includes several security controls, each of which represents a security best
/// practice. Security Hub runs checks against security controls and generates
/// control findings to help you assess your compliance against security best
/// practices.
///
/// In addition to generating control findings, Security Hub also receives
/// findings from other Amazon Web Services, such as Amazon GuardDuty and Amazon
/// Inspector, and supported third-party products. This gives you a single pane
/// of glass into a variety of security-related issues. You can also send
/// Security Hub findings to other Amazon Web Services and supported third-party
/// products.
///
/// Security Hub offers automation features that help you triage and remediate
/// security issues. For example, you can use automation rules to automatically
/// update critical findings when a security check fails. You can also leverage
/// the integration with Amazon EventBridge to trigger automatic responses to
/// specific findings.
///
/// This guide, the <i>Security Hub API Reference</i>, provides information
/// about the Security Hub API. This includes supported resources, HTTP methods,
/// parameters, and schemas. If you're new to Security Hub, you might find it
/// helpful to also review the <a
/// href="https://docs.aws.amazon.com/securityhub/latest/userguide/what-is-securityhub.html">
/// <i>Security Hub User Guide</i> </a>. The user guide explains key concepts
/// and provides procedures that demonstrate how to use Security Hub features.
/// It also provides information about topics such as integrating Security Hub
/// with other Amazon Web Services.
///
/// In addition to interacting with Security Hub by making calls to the Security
/// Hub API, you can use a current version of an Amazon Web Services command
/// line tool or SDK. Amazon Web Services provides tools and SDKs that consist
/// of libraries and sample code for various languages and platforms, such as
/// PowerShell, Java, Go, Python, C++, and .NET. These tools and SDKs provide
/// convenient, programmatic access to Security Hub and other Amazon Web
/// Services . They also handle tasks such as signing requests, managing errors,
/// and retrying requests automatically. For information about installing and
/// using the Amazon Web Services tools and SDKs, see <a
/// href="http://aws.amazon.com/developer/tools/">Tools to Build on Amazon Web
/// Services</a>.
///
/// With the exception of operations that are related to central configuration,
/// Security Hub API requests are executed only in the Amazon Web Services
/// Region that is currently active or in the specific Amazon Web Services
/// Region that you specify in your request. Any configuration or settings
/// change that results from the operation is applied only to that Region. To
/// make the same change in other Regions, call the same API operation in each
/// Region in which you want to apply the change. When you use central
/// configuration, API requests for enabling Security Hub, standards, and
/// controls are executed in the home Region and all linked Regions. For a list
/// of central configuration operations, see the <a
/// href="https://docs.aws.amazon.com/securityhub/latest/userguide/central-configuration-intro.html#central-configuration-concepts">Central
/// configuration terms and concepts</a> section of the <i>Security Hub User
/// Guide</i>.
///
/// The following throttling limits apply to Security Hub API operations.
///
/// <ul>
/// <li>
/// <code>BatchEnableStandards</code> - <code>RateLimit</code> of 1 request per
/// second. <code>BurstLimit</code> of 1 request per second.
/// </li>
/// <li>
/// <code>GetFindings</code> - <code>RateLimit</code> of 3 requests per second.
/// <code>BurstLimit</code> of 6 requests per second.
/// </li>
/// <li>
/// <code>BatchImportFindings</code> - <code>RateLimit</code> of 10 requests per
/// second. <code>BurstLimit</code> of 30 requests per second.
/// </li>
/// <li>
/// <code>BatchUpdateFindings</code> - <code>RateLimit</code> of 10 requests per
/// second. <code>BurstLimit</code> of 30 requests per second.
/// </li>
/// <li>
/// <code>UpdateStandardsControl</code> - <code>RateLimit</code> of 1 request
/// per second. <code>BurstLimit</code> of 5 requests per second.
/// </li>
/// <li>
/// All other operations - <code>RateLimit</code> of 10 requests per second.
/// <code>BurstLimit</code> of 30 requests per second.
/// </li>
/// </ul>
class SecurityHub {
  final _s.RestJsonProtocol _protocol;
  SecurityHub({
    required String region,
    _s.AwsClientCredentials? credentials,
    _s.AwsClientCredentialsProvider? credentialsProvider,
    _s.Client? client,
    String? endpointUrl,
  }) : _protocol = _s.RestJsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'securityhub',
            signingName: 'securityhub',
          ),
          region: region,
          credentials: credentials,
          credentialsProvider: credentialsProvider,
          endpointUrl: endpointUrl,
        );

  /// Closes the internal HTTP client if none was provided at creation.
  /// If a client was passed as a constructor argument, this becomes a noop.
  ///
  /// It's important to close all clients when it's done being used; failing to
  /// do so can cause the Dart process to hang.
  void close() {
    _protocol.close();
  }

  /// Accepts the invitation to be a member account and be monitored by the
  /// Security Hub administrator account that the invitation was sent from.
  ///
  /// This operation is only used by member accounts that are not added through
  /// Organizations.
  ///
  /// When the member account accepts the invitation, permission is granted to
  /// the administrator account to view findings generated in the member
  /// account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [administratorId] :
  /// The account ID of the Security Hub administrator account that sent the
  /// invitation.
  ///
  /// Parameter [invitationId] :
  /// The identifier of the invitation sent from the Security Hub administrator
  /// account.
  Future<void> acceptAdministratorInvitation({
    required String administratorId,
    required String invitationId,
  }) async {
    final $payload = <String, dynamic>{
      'AdministratorId': administratorId,
      'InvitationId': invitationId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/administrator',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This method is deprecated. Instead, use
  /// <code>AcceptAdministratorInvitation</code>.
  ///
  /// The Security Hub console continues to use <code>AcceptInvitation</code>.
  /// It will eventually change to use
  /// <code>AcceptAdministratorInvitation</code>. Any IAM policies that
  /// specifically control access to this function must continue to use
  /// <code>AcceptInvitation</code>. You should also add
  /// <code>AcceptAdministratorInvitation</code> to your policies to ensure that
  /// the correct permissions are in place after the console begins to use
  /// <code>AcceptAdministratorInvitation</code>.
  ///
  /// Accepts the invitation to be a member account and be monitored by the
  /// Security Hub administrator account that the invitation was sent from.
  ///
  /// This operation is only used by member accounts that are not added through
  /// Organizations.
  ///
  /// When the member account accepts the invitation, permission is granted to
  /// the administrator account to view findings generated in the member
  /// account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [invitationId] :
  /// The identifier of the invitation sent from the Security Hub administrator
  /// account.
  ///
  /// Parameter [masterId] :
  /// The account ID of the Security Hub administrator account that sent the
  /// invitation.
  @Deprecated(
      'This API has been deprecated, use AcceptAdministratorInvitation API instead.')
  Future<void> acceptInvitation({
    required String invitationId,
    required String masterId,
  }) async {
    final $payload = <String, dynamic>{
      'InvitationId': invitationId,
      'MasterId': masterId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/master',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes one or more automation rules.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [automationRulesArns] :
  /// A list of Amazon Resource Names (ARNs) for the rules that are to be
  /// deleted.
  Future<BatchDeleteAutomationRulesResponse> batchDeleteAutomationRules({
    required List<String> automationRulesArns,
  }) async {
    final $payload = <String, dynamic>{
      'AutomationRulesArns': automationRulesArns,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/automationrules/delete',
      exceptionFnMap: _exceptionFns,
    );
    return BatchDeleteAutomationRulesResponse.fromJson(response);
  }

  /// Disables the standards specified by the provided
  /// <code>StandardsSubscriptionArns</code>.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards.html">Security
  /// Standards</a> section of the <i>Security Hub User Guide</i>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [standardsSubscriptionArns] :
  /// The ARNs of the standards subscriptions to disable.
  Future<BatchDisableStandardsResponse> batchDisableStandards({
    required List<String> standardsSubscriptionArns,
  }) async {
    final $payload = <String, dynamic>{
      'StandardsSubscriptionArns': standardsSubscriptionArns,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/standards/deregister',
      exceptionFnMap: _exceptionFns,
    );
    return BatchDisableStandardsResponse.fromJson(response);
  }

  /// Enables the standards specified by the provided <code>StandardsArn</code>.
  /// To obtain the ARN for a standard, use the <code>DescribeStandards</code>
  /// operation.
  ///
  /// For more information, see the <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards.html">Security
  /// Standards</a> section of the <i>Security Hub User Guide</i>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [standardsSubscriptionRequests] :
  /// The list of standards checks to enable.
  Future<BatchEnableStandardsResponse> batchEnableStandards({
    required List<StandardsSubscriptionRequest> standardsSubscriptionRequests,
  }) async {
    final $payload = <String, dynamic>{
      'StandardsSubscriptionRequests': standardsSubscriptionRequests,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/standards/register',
      exceptionFnMap: _exceptionFns,
    );
    return BatchEnableStandardsResponse.fromJson(response);
  }

  /// Retrieves a list of details for automation rules based on rule Amazon
  /// Resource Names (ARNs).
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [automationRulesArns] :
  /// A list of rule ARNs to get details for.
  Future<BatchGetAutomationRulesResponse> batchGetAutomationRules({
    required List<String> automationRulesArns,
  }) async {
    final $payload = <String, dynamic>{
      'AutomationRulesArns': automationRulesArns,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/automationrules/get',
      exceptionFnMap: _exceptionFns,
    );
    return BatchGetAutomationRulesResponse.fromJson(response);
  }

  /// Returns associations between an Security Hub configuration and a batch of
  /// target accounts, organizational units, or the root. Only the Security Hub
  /// delegated administrator can invoke this operation from the home Region. A
  /// configuration can refer to a configuration policy or to a self-managed
  /// configuration.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [configurationPolicyAssociationIdentifiers] :
  /// Specifies one or more target account IDs, organizational unit (OU) IDs, or
  /// the root ID to retrieve associations for.
  Future<BatchGetConfigurationPolicyAssociationsResponse>
      batchGetConfigurationPolicyAssociations({
    required List<ConfigurationPolicyAssociation>
        configurationPolicyAssociationIdentifiers,
  }) async {
    final $payload = <String, dynamic>{
      'ConfigurationPolicyAssociationIdentifiers':
          configurationPolicyAssociationIdentifiers,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/configurationPolicyAssociation/batchget',
      exceptionFnMap: _exceptionFns,
    );
    return BatchGetConfigurationPolicyAssociationsResponse.fromJson(response);
  }

  /// Provides details about a batch of security controls for the current Amazon
  /// Web Services account and Amazon Web Services Region.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [securityControlIds] :
  /// A list of security controls (identified with
  /// <code>SecurityControlId</code>, <code>SecurityControlArn</code>, or a mix
  /// of both parameters). The security control ID or Amazon Resource Name (ARN)
  /// is the same across standards.
  Future<BatchGetSecurityControlsResponse> batchGetSecurityControls({
    required List<String> securityControlIds,
  }) async {
    final $payload = <String, dynamic>{
      'SecurityControlIds': securityControlIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/securityControls/batchGet',
      exceptionFnMap: _exceptionFns,
    );
    return BatchGetSecurityControlsResponse.fromJson(response);
  }

  /// For a batch of security controls and standards, identifies whether each
  /// control is currently enabled or disabled in a standard.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [standardsControlAssociationIds] :
  /// An array with one or more objects that includes a security control
  /// (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) and the
  /// Amazon Resource Name (ARN) of a standard. This field is used to query the
  /// enablement status of a control in a specified standard. The security
  /// control ID or ARN is the same across standards.
  Future<BatchGetStandardsControlAssociationsResponse>
      batchGetStandardsControlAssociations({
    required List<StandardsControlAssociationId> standardsControlAssociationIds,
  }) async {
    final $payload = <String, dynamic>{
      'StandardsControlAssociationIds': standardsControlAssociationIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/associations/batchGet',
      exceptionFnMap: _exceptionFns,
    );
    return BatchGetStandardsControlAssociationsResponse.fromJson(response);
  }

  /// Imports security findings generated by a finding provider into Security
  /// Hub. This action is requested by the finding provider to import its
  /// findings into Security Hub.
  ///
  /// <code>BatchImportFindings</code> must be called by one of the following:
  ///
  /// <ul>
  /// <li>
  /// The Amazon Web Services account that is associated with a finding if you
  /// are using the <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-custom-providers.html#securityhub-custom-providers-bfi-reqs">default
  /// product ARN</a> or are a partner sending findings from within a customer's
  /// Amazon Web Services account. In these cases, the identifier of the account
  /// that you are calling <code>BatchImportFindings</code> from needs to be the
  /// same as the <code>AwsAccountId</code> attribute for the finding.
  /// </li>
  /// <li>
  /// An Amazon Web Services account that Security Hub has allow-listed for an
  /// official partner integration. In this case, you can call
  /// <code>BatchImportFindings</code> from the allow-listed account and send
  /// findings from different customer accounts in the same batch.
  /// </li>
  /// </ul>
  /// The maximum allowed size for a finding is 240 Kb. An error is returned for
  /// any finding larger than 240 Kb.
  ///
  /// After a finding is created, <code>BatchImportFindings</code> cannot be
  /// used to update the following finding fields and objects, which Security
  /// Hub customers use to manage their investigation workflow.
  ///
  /// <ul>
  /// <li>
  /// <code>Note</code>
  /// </li>
  /// <li>
  /// <code>UserDefinedFields</code>
  /// </li>
  /// <li>
  /// <code>VerificationState</code>
  /// </li>
  /// <li>
  /// <code>Workflow</code>
  /// </li>
  /// </ul>
  /// Finding providers also should not use <code>BatchImportFindings</code> to
  /// update the following attributes.
  ///
  /// <ul>
  /// <li>
  /// <code>Confidence</code>
  /// </li>
  /// <li>
  /// <code>Criticality</code>
  /// </li>
  /// <li>
  /// <code>RelatedFindings</code>
  /// </li>
  /// <li>
  /// <code>Severity</code>
  /// </li>
  /// <li>
  /// <code>Types</code>
  /// </li>
  /// </ul>
  /// Instead, finding providers use <code>FindingProviderFields</code> to
  /// provide values for these attributes.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [findings] :
  /// A list of findings to import. To successfully import a finding, it must
  /// follow the <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html">Amazon
  /// Web Services Security Finding Format</a>. Maximum of 100 findings per
  /// request.
  Future<BatchImportFindingsResponse> batchImportFindings({
    required List<AwsSecurityFinding> findings,
  }) async {
    final $payload = <String, dynamic>{
      'Findings': findings,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/findings/import',
      exceptionFnMap: _exceptionFns,
    );
    return BatchImportFindingsResponse.fromJson(response);
  }

  /// Updates one or more automation rules based on rule Amazon Resource Names
  /// (ARNs) and input parameters.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [updateAutomationRulesRequestItems] :
  /// An array of ARNs for the rules that are to be updated. Optionally, you can
  /// also include <code>RuleStatus</code> and <code>RuleOrder</code>.
  Future<BatchUpdateAutomationRulesResponse> batchUpdateAutomationRules({
    required List<UpdateAutomationRulesRequestItem>
        updateAutomationRulesRequestItems,
  }) async {
    final $payload = <String, dynamic>{
      'UpdateAutomationRulesRequestItems': updateAutomationRulesRequestItems,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/automationrules/update',
      exceptionFnMap: _exceptionFns,
    );
    return BatchUpdateAutomationRulesResponse.fromJson(response);
  }

  /// Used by Security Hub customers to update information about their
  /// investigation into a finding. Requested by administrator accounts or
  /// member accounts. Administrator accounts can update findings for their
  /// account and their member accounts. Member accounts can update findings for
  /// their account.
  ///
  /// Updates from <code>BatchUpdateFindings</code> do not affect the value of
  /// <code>UpdatedAt</code> for a finding.
  ///
  /// Administrator and member accounts can use <code>BatchUpdateFindings</code>
  /// to update the following finding fields and objects.
  ///
  /// <ul>
  /// <li>
  /// <code>Confidence</code>
  /// </li>
  /// <li>
  /// <code>Criticality</code>
  /// </li>
  /// <li>
  /// <code>Note</code>
  /// </li>
  /// <li>
  /// <code>RelatedFindings</code>
  /// </li>
  /// <li>
  /// <code>Severity</code>
  /// </li>
  /// <li>
  /// <code>Types</code>
  /// </li>
  /// <li>
  /// <code>UserDefinedFields</code>
  /// </li>
  /// <li>
  /// <code>VerificationState</code>
  /// </li>
  /// <li>
  /// <code>Workflow</code>
  /// </li>
  /// </ul>
  /// You can configure IAM policies to restrict access to fields and field
  /// values. For example, you might not want member accounts to be able to
  /// suppress findings or change the finding severity. See <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/finding-update-batchupdatefindings.html#batchupdatefindings-configure-access">Configuring
  /// access to BatchUpdateFindings</a> in the <i>Security Hub User Guide</i>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [findingIdentifiers] :
  /// The list of findings to update. <code>BatchUpdateFindings</code> can be
  /// used to update up to 100 findings at a time.
  ///
  /// For each finding, the list provides the finding identifier and the ARN of
  /// the finding provider.
  ///
  /// Parameter [confidence] :
  /// The updated value for the finding confidence. Confidence is defined as the
  /// likelihood that a finding accurately identifies the behavior or issue that
  /// it was intended to identify.
  ///
  /// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
  /// zero percent confidence and 100 means 100 percent confidence.
  ///
  /// Parameter [criticality] :
  /// The updated value for the level of importance assigned to the resources
  /// associated with the findings.
  ///
  /// A score of 0 means that the underlying resources have no criticality, and
  /// a score of 100 is reserved for the most critical resources.
  ///
  /// Parameter [relatedFindings] :
  /// A list of findings that are related to the updated findings.
  ///
  /// Parameter [severity] :
  /// Used to update the finding severity.
  ///
  /// Parameter [types] :
  /// One or more finding types in the format of namespace/category/classifier
  /// that classify a finding.
  ///
  /// Valid namespace values are as follows.
  ///
  /// <ul>
  /// <li>
  /// Software and Configuration Checks
  /// </li>
  /// <li>
  /// TTPs
  /// </li>
  /// <li>
  /// Effects
  /// </li>
  /// <li>
  /// Unusual Behaviors
  /// </li>
  /// <li>
  /// Sensitive Data Identifications
  /// </li>
  /// </ul>
  ///
  /// Parameter [userDefinedFields] :
  /// A list of name/value string pairs associated with the finding. These are
  /// custom, user-defined fields added to a finding.
  ///
  /// Parameter [verificationState] :
  /// Indicates the veracity of a finding.
  ///
  /// The available values for <code>VerificationState</code> are as follows.
  ///
  /// <ul>
  /// <li>
  /// <code>UNKNOWN</code> – The default disposition of a security finding
  /// </li>
  /// <li>
  /// <code>TRUE_POSITIVE</code> – The security finding is confirmed
  /// </li>
  /// <li>
  /// <code>FALSE_POSITIVE</code> – The security finding was determined to be a
  /// false alarm
  /// </li>
  /// <li>
  /// <code>BENIGN_POSITIVE</code> – A special case of
  /// <code>TRUE_POSITIVE</code> where the finding doesn't pose any threat, is
  /// expected, or both
  /// </li>
  /// </ul>
  ///
  /// Parameter [workflow] :
  /// Used to update the workflow status of a finding.
  ///
  /// The workflow status indicates the progress of the investigation into the
  /// finding.
  Future<BatchUpdateFindingsResponse> batchUpdateFindings({
    required List<AwsSecurityFindingIdentifier> findingIdentifiers,
    int? confidence,
    int? criticality,
    NoteUpdate? note,
    List<RelatedFinding>? relatedFindings,
    SeverityUpdate? severity,
    List<String>? types,
    Map<String, String>? userDefinedFields,
    VerificationState? verificationState,
    WorkflowUpdate? workflow,
  }) async {
    _s.validateNumRange(
      'confidence',
      confidence,
      0,
      100,
    );
    _s.validateNumRange(
      'criticality',
      criticality,
      0,
      100,
    );
    final $payload = <String, dynamic>{
      'FindingIdentifiers': findingIdentifiers,
      if (confidence != null) 'Confidence': confidence,
      if (criticality != null) 'Criticality': criticality,
      if (note != null) 'Note': note,
      if (relatedFindings != null) 'RelatedFindings': relatedFindings,
      if (severity != null) 'Severity': severity,
      if (types != null) 'Types': types,
      if (userDefinedFields != null) 'UserDefinedFields': userDefinedFields,
      if (verificationState != null)
        'VerificationState': verificationState.toValue(),
      if (workflow != null) 'Workflow': workflow,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/findings/batchupdate',
      exceptionFnMap: _exceptionFns,
    );
    return BatchUpdateFindingsResponse.fromJson(response);
  }

  /// For a batch of security controls and standards, this operation updates the
  /// enablement status of a control in a standard.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [standardsControlAssociationUpdates] :
  /// Updates the enablement status of a security control in a specified
  /// standard.
  Future<BatchUpdateStandardsControlAssociationsResponse>
      batchUpdateStandardsControlAssociations({
    required List<StandardsControlAssociationUpdate>
        standardsControlAssociationUpdates,
  }) async {
    final $payload = <String, dynamic>{
      'StandardsControlAssociationUpdates': standardsControlAssociationUpdates,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/associations',
      exceptionFnMap: _exceptionFns,
    );
    return BatchUpdateStandardsControlAssociationsResponse.fromJson(response);
  }

  /// Creates a custom action target in Security Hub.
  ///
  /// You can use custom actions on findings and insights in Security Hub to
  /// trigger target actions in Amazon CloudWatch Events.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [description] :
  /// The description for the custom action target.
  ///
  /// Parameter [id] :
  /// The ID for the custom action target. Can contain up to 20 alphanumeric
  /// characters.
  ///
  /// Parameter [name] :
  /// The name of the custom action target. Can contain up to 20 characters.
  Future<CreateActionTargetResponse> createActionTarget({
    required String description,
    required String id,
    required String name,
  }) async {
    final $payload = <String, dynamic>{
      'Description': description,
      'Id': id,
      'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/actionTargets',
      exceptionFnMap: _exceptionFns,
    );
    return CreateActionTargetResponse.fromJson(response);
  }

  /// Creates an automation rule based on input parameters.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [actions] :
  /// One or more actions to update finding fields if a finding matches the
  /// conditions specified in <code>Criteria</code>.
  ///
  /// Parameter [criteria] :
  /// A set of ASFF finding field attributes and corresponding expected values
  /// that Security Hub uses to filter findings. If a rule is enabled and a
  /// finding matches the conditions specified in this parameter, Security Hub
  /// applies the rule action to the finding.
  ///
  /// Parameter [description] :
  /// A description of the rule.
  ///
  /// Parameter [ruleName] :
  /// The name of the rule.
  ///
  /// Parameter [ruleOrder] :
  /// An integer ranging from 1 to 1000 that represents the order in which the
  /// rule action is applied to findings. Security Hub applies rules with lower
  /// values for this parameter first.
  ///
  /// Parameter [isTerminal] :
  /// Specifies whether a rule is the last to be applied with respect to a
  /// finding that matches the rule criteria. This is useful when a finding
  /// matches the criteria for multiple rules, and each rule has different
  /// actions. If a rule is terminal, Security Hub applies the rule action to a
  /// finding that matches the rule criteria and doesn't evaluate other rules
  /// for the finding. By default, a rule isn't terminal.
  ///
  /// Parameter [ruleStatus] :
  /// Whether the rule is active after it is created. If this parameter is equal
  /// to <code>ENABLED</code>, Security Hub starts applying the rule to findings
  /// and finding updates after the rule is created. To change the value of this
  /// parameter after creating a rule, use <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateAutomationRules.html">
  /// <code>BatchUpdateAutomationRules</code> </a>.
  ///
  /// Parameter [tags] :
  /// User-defined tags associated with an automation rule.
  Future<CreateAutomationRuleResponse> createAutomationRule({
    required List<AutomationRulesAction> actions,
    required AutomationRulesFindingFilters criteria,
    required String description,
    required String ruleName,
    required int ruleOrder,
    bool? isTerminal,
    RuleStatus? ruleStatus,
    Map<String, String>? tags,
  }) async {
    _s.validateNumRange(
      'ruleOrder',
      ruleOrder,
      1,
      1000,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'Actions': actions,
      'Criteria': criteria,
      'Description': description,
      'RuleName': ruleName,
      'RuleOrder': ruleOrder,
      if (isTerminal != null) 'IsTerminal': isTerminal,
      if (ruleStatus != null) 'RuleStatus': ruleStatus.toValue(),
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/automationrules/create',
      exceptionFnMap: _exceptionFns,
    );
    return CreateAutomationRuleResponse.fromJson(response);
  }

  /// Creates a configuration policy with the defined configuration. Only the
  /// Security Hub delegated administrator can invoke this operation from the
  /// home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [configurationPolicy] :
  /// An object that defines how Security Hub is configured. It includes whether
  /// Security Hub is enabled or disabled, a list of enabled security standards,
  /// a list of enabled or disabled security controls, and a list of custom
  /// parameter values for specified controls. If you provide a list of security
  /// controls that are enabled in the configuration policy, Security Hub
  /// disables all other controls (including newly released controls). If you
  /// provide a list of security controls that are disabled in the configuration
  /// policy, Security Hub enables all other controls (including newly released
  /// controls).
  ///
  /// Parameter [name] :
  /// The name of the configuration policy. Alphanumeric characters and the
  /// following ASCII characters are permitted: <code>-, ., !, *, /</code>.
  ///
  /// Parameter [description] :
  /// The description of the configuration policy.
  ///
  /// Parameter [tags] :
  /// User-defined tags associated with a configuration policy. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/tagging-resources.html">Tagging
  /// Security Hub resources</a> in the <i>Security Hub user guide</i>.
  Future<CreateConfigurationPolicyResponse> createConfigurationPolicy({
    required Policy configurationPolicy,
    required String name,
    String? description,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'ConfigurationPolicy': configurationPolicy,
      'Name': name,
      if (description != null) 'Description': description,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/configurationPolicy/create',
      exceptionFnMap: _exceptionFns,
    );
    return CreateConfigurationPolicyResponse.fromJson(response);
  }

  /// Used to enable finding aggregation. Must be called from the aggregation
  /// Region.
  ///
  /// For more details about cross-Region replication, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/finding-aggregation.html">Configuring
  /// finding aggregation</a> in the <i>Security Hub User Guide</i>.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [regionLinkingMode] :
  /// Indicates whether to aggregate findings from all of the available Regions
  /// in the current partition. Also determines whether to automatically
  /// aggregate findings from new Regions as Security Hub supports them and you
  /// opt into them.
  ///
  /// The selected option also determines how to use the Regions provided in the
  /// Regions list.
  ///
  /// The options are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_REGIONS</code> - Indicates to aggregate findings from all of the
  /// Regions where Security Hub is enabled. When you choose this option,
  /// Security Hub also automatically aggregates findings from new Regions as
  /// Security Hub supports them and you opt into them.
  /// </li>
  /// <li>
  /// <code>ALL_REGIONS_EXCEPT_SPECIFIED</code> - Indicates to aggregate
  /// findings from all of the Regions where Security Hub is enabled, except for
  /// the Regions listed in the <code>Regions</code> parameter. When you choose
  /// this option, Security Hub also automatically aggregates findings from new
  /// Regions as Security Hub supports them and you opt into them.
  /// </li>
  /// <li>
  /// <code>SPECIFIED_REGIONS</code> - Indicates to aggregate findings only from
  /// the Regions listed in the <code>Regions</code> parameter. Security Hub
  /// does not automatically aggregate findings from new Regions.
  /// </li>
  /// </ul>
  ///
  /// Parameter [regions] :
  /// If <code>RegionLinkingMode</code> is
  /// <code>ALL_REGIONS_EXCEPT_SPECIFIED</code>, then this is a space-separated
  /// list of Regions that do not aggregate findings to the aggregation Region.
  ///
  /// If <code>RegionLinkingMode</code> is <code>SPECIFIED_REGIONS</code>, then
  /// this is a space-separated list of Regions that do aggregate findings to
  /// the aggregation Region.
  Future<CreateFindingAggregatorResponse> createFindingAggregator({
    required String regionLinkingMode,
    List<String>? regions,
  }) async {
    final $payload = <String, dynamic>{
      'RegionLinkingMode': regionLinkingMode,
      if (regions != null) 'Regions': regions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/findingAggregator/create',
      exceptionFnMap: _exceptionFns,
    );
    return CreateFindingAggregatorResponse.fromJson(response);
  }

  /// Creates a custom insight in Security Hub. An insight is a consolidation of
  /// findings that relate to a security issue that requires attention or
  /// remediation.
  ///
  /// To group the related findings in the insight, use the
  /// <code>GroupByAttribute</code>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [filters] :
  /// One or more attributes used to filter the findings included in the
  /// insight. The insight only includes findings that match the criteria
  /// defined in the filters.
  ///
  /// Parameter [groupByAttribute] :
  /// The attribute used to group the findings for the insight. The grouping
  /// attribute identifies the type of item that the insight applies to. For
  /// example, if an insight is grouped by resource identifier, then the insight
  /// produces a list of resource identifiers.
  ///
  /// Parameter [name] :
  /// The name of the custom insight to create.
  Future<CreateInsightResponse> createInsight({
    required AwsSecurityFindingFilters filters,
    required String groupByAttribute,
    required String name,
  }) async {
    final $payload = <String, dynamic>{
      'Filters': filters,
      'GroupByAttribute': groupByAttribute,
      'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/insights',
      exceptionFnMap: _exceptionFns,
    );
    return CreateInsightResponse.fromJson(response);
  }

  /// Creates a member association in Security Hub between the specified
  /// accounts and the account used to make the request, which is the
  /// administrator account. If you are integrated with Organizations, then the
  /// administrator account is designated by the organization management
  /// account.
  ///
  /// <code>CreateMembers</code> is always used to add accounts that are not
  /// organization members.
  ///
  /// For accounts that are managed using Organizations,
  /// <code>CreateMembers</code> is only used in the following cases:
  ///
  /// <ul>
  /// <li>
  /// Security Hub is not configured to automatically add new organization
  /// accounts.
  /// </li>
  /// <li>
  /// The account was disassociated or deleted in Security Hub.
  /// </li>
  /// </ul>
  /// This action can only be used by an account that has Security Hub enabled.
  /// To enable Security Hub, you can use the <code>EnableSecurityHub</code>
  /// operation.
  ///
  /// For accounts that are not organization members, you create the account
  /// association and then send an invitation to the member account. To send the
  /// invitation, you use the <code>InviteMembers</code> operation. If the
  /// account owner accepts the invitation, the account becomes a member account
  /// in Security Hub.
  ///
  /// Accounts that are managed using Organizations do not receive an
  /// invitation. They automatically become a member account in Security Hub.
  ///
  /// <ul>
  /// <li>
  /// If the organization account does not have Security Hub enabled, then
  /// Security Hub and the default standards are automatically enabled. Note
  /// that Security Hub cannot be enabled automatically for the organization
  /// management account. The organization management account must enable
  /// Security Hub before the administrator account enables it as a member
  /// account.
  /// </li>
  /// <li>
  /// For organization accounts that already have Security Hub enabled, Security
  /// Hub does not make any other changes to those accounts. It does not change
  /// their enabled standards or controls.
  /// </li>
  /// </ul>
  /// A permissions policy is added that permits the administrator account to
  /// view the findings generated in the member account.
  ///
  /// To remove the association between the administrator and member accounts,
  /// use the <code>DisassociateFromMasterAccount</code> or
  /// <code>DisassociateMembers</code> operation.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceConflictException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [accountDetails] :
  /// The list of accounts to associate with the Security Hub administrator
  /// account. For each account, the list includes the account ID and optionally
  /// the email address.
  Future<CreateMembersResponse> createMembers({
    required List<AccountDetails> accountDetails,
  }) async {
    final $payload = <String, dynamic>{
      'AccountDetails': accountDetails,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/members',
      exceptionFnMap: _exceptionFns,
    );
    return CreateMembersResponse.fromJson(response);
  }

  /// Declines invitations to become a member account.
  ///
  /// A prospective member account uses this operation to decline an invitation
  /// to become a member.
  ///
  /// This operation is only called by member accounts that aren't part of an
  /// organization. Organization accounts don't receive invitations.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [accountIds] :
  /// The list of prospective member account IDs for which to decline an
  /// invitation.
  Future<DeclineInvitationsResponse> declineInvitations({
    required List<String> accountIds,
  }) async {
    final $payload = <String, dynamic>{
      'AccountIds': accountIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/invitations/decline',
      exceptionFnMap: _exceptionFns,
    );
    return DeclineInvitationsResponse.fromJson(response);
  }

  /// Deletes a custom action target from Security Hub.
  ///
  /// Deleting a custom action target does not affect any findings or insights
  /// that were already sent to Amazon CloudWatch Events using the custom
  /// action.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [actionTargetArn] :
  /// The Amazon Resource Name (ARN) of the custom action target to delete.
  Future<DeleteActionTargetResponse> deleteActionTarget({
    required String actionTargetArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/actionTargets/${actionTargetArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteActionTargetResponse.fromJson(response);
  }

  /// Deletes a configuration policy. Only the Security Hub delegated
  /// administrator can invoke this operation from the home Region. For the
  /// deletion to succeed, you must first disassociate a configuration policy
  /// from target accounts, organizational units, or the root by invoking the
  /// <code>StartConfigurationPolicyDisassociation</code> operation.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [identifier] :
  /// The Amazon Resource Name (ARN) or universally unique identifier (UUID) of
  /// the configuration policy.
  Future<void> deleteConfigurationPolicy({
    required String identifier,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/configurationPolicy/${Uri.encodeComponent(identifier)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a finding aggregator. When you delete the finding aggregator, you
  /// stop finding aggregation.
  ///
  /// When you stop finding aggregation, findings that were already aggregated
  /// to the aggregation Region are still visible from the aggregation Region.
  /// New findings and finding updates are not aggregated.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [findingAggregatorArn] :
  /// The ARN of the finding aggregator to delete. To obtain the ARN, use
  /// <code>ListFindingAggregators</code>.
  Future<void> deleteFindingAggregator({
    required String findingAggregatorArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/findingAggregator/delete/${findingAggregatorArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes the insight specified by the <code>InsightArn</code>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [insightArn] :
  /// The ARN of the insight to delete.
  Future<DeleteInsightResponse> deleteInsight({
    required String insightArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/insights/${insightArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteInsightResponse.fromJson(response);
  }

  /// Deletes invitations received by the Amazon Web Services account to become
  /// a member account.
  ///
  /// A Security Hub administrator account can use this operation to delete
  /// invitations sent to one or more member accounts.
  ///
  /// This operation is only used to delete invitations that are sent to member
  /// accounts that aren't part of an organization. Organization accounts don't
  /// receive invitations.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [accountIds] :
  /// The list of member account IDs that received the invitations you want to
  /// delete.
  Future<DeleteInvitationsResponse> deleteInvitations({
    required List<String> accountIds,
  }) async {
    final $payload = <String, dynamic>{
      'AccountIds': accountIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/invitations/delete',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteInvitationsResponse.fromJson(response);
  }

  /// Deletes the specified member accounts from Security Hub.
  ///
  /// You can invoke this API only to delete accounts that became members
  /// through invitation. You can't invoke this API to delete accounts that
  /// belong to an Organizations organization.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [accountIds] :
  /// The list of account IDs for the member accounts to delete.
  Future<DeleteMembersResponse> deleteMembers({
    required List<String> accountIds,
  }) async {
    final $payload = <String, dynamic>{
      'AccountIds': accountIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/members/delete',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteMembersResponse.fromJson(response);
  }

  /// Returns a list of the custom action targets in Security Hub in your
  /// account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [actionTargetArns] :
  /// A list of custom action target ARNs for the custom action targets to
  /// retrieve.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>DescribeActionTargets</code> operation, set the value of this
  /// parameter to <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  Future<DescribeActionTargetsResponse> describeActionTargets({
    List<String>? actionTargetArns,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (actionTargetArns != null) 'ActionTargetArns': actionTargetArns,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/actionTargets/get',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeActionTargetsResponse.fromJson(response);
  }

  /// Returns details about the Hub resource in your account, including the
  /// <code>HubArn</code> and the time when you enabled Security Hub.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [hubArn] :
  /// The ARN of the Hub resource to retrieve.
  Future<DescribeHubResponse> describeHub({
    String? hubArn,
  }) async {
    final $query = <String, List<String>>{
      if (hubArn != null) 'HubArn': [hubArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeHubResponse.fromJson(response);
  }

  /// Returns information about the way your organization is configured in
  /// Security Hub. Only the Security Hub administrator account can invoke this
  /// operation.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  Future<DescribeOrganizationConfigurationResponse>
      describeOrganizationConfiguration() async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/organization/configuration',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeOrganizationConfigurationResponse.fromJson(response);
  }

  /// Returns information about product integrations in Security Hub.
  ///
  /// You can optionally provide an integration ARN. If you provide an
  /// integration ARN, then the results only include that integration.
  ///
  /// If you do not provide an integration ARN, then the results include all of
  /// the available product integrations.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>DescribeProducts</code> operation, set the value of this parameter
  /// to <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  ///
  /// Parameter [productArn] :
  /// The ARN of the integration to return.
  Future<DescribeProductsResponse> describeProducts({
    int? maxResults,
    String? nextToken,
    String? productArn,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
      if (productArn != null) 'ProductArn': [productArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/products',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeProductsResponse.fromJson(response);
  }

  /// Returns a list of the available standards in Security Hub.
  ///
  /// For each standard, the results include the standard ARN, the name, and a
  /// description.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of standards to return.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>DescribeStandards</code> operation, set the value of this parameter
  /// to <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  Future<DescribeStandardsResponse> describeStandards({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/standards',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeStandardsResponse.fromJson(response);
  }

  /// Returns a list of security standards controls.
  ///
  /// For each control, the results include information about whether it is
  /// currently enabled, the severity, and a link to remediation information.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [standardsSubscriptionArn] :
  /// The ARN of a resource that represents your subscription to a supported
  /// standard. To get the subscription ARNs of the standards you have enabled,
  /// use the <code>GetEnabledStandards</code> operation.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of security standard controls to return.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>DescribeStandardsControls</code> operation, set the value of this
  /// parameter to <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  Future<DescribeStandardsControlsResponse> describeStandardsControls({
    required String standardsSubscriptionArn,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/standards/controls/${standardsSubscriptionArn.split('/').map(Uri.encodeComponent).join('/')}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeStandardsControlsResponse.fromJson(response);
  }

  /// Disables the integration of the specified product with Security Hub. After
  /// the integration is disabled, findings from that product are no longer sent
  /// to Security Hub.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [productSubscriptionArn] :
  /// The ARN of the integrated product to disable the integration for.
  Future<void> disableImportFindingsForProduct({
    required String productSubscriptionArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/productSubscriptions/${productSubscriptionArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disables a Security Hub administrator account. Can only be called by the
  /// organization management account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [adminAccountId] :
  /// The Amazon Web Services account identifier of the Security Hub
  /// administrator account.
  Future<void> disableOrganizationAdminAccount({
    required String adminAccountId,
  }) async {
    final $payload = <String, dynamic>{
      'AdminAccountId': adminAccountId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/organization/admin/disable',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disables Security Hub in your account only in the current Amazon Web
  /// Services Region. To disable Security Hub in all Regions, you must submit
  /// one request per Region where you have enabled Security Hub.
  ///
  /// You can't disable Security Hub in an account that is currently the
  /// Security Hub administrator.
  ///
  /// When you disable Security Hub, your existing findings and insights and any
  /// Security Hub configuration settings are deleted after 90 days and cannot
  /// be recovered. Any standards that were enabled are disabled, and your
  /// administrator and member account associations are removed.
  ///
  /// If you want to save your existing findings, you must export them before
  /// you disable Security Hub.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  Future<void> disableSecurityHub() async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/accounts',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disassociates the current Security Hub member account from the associated
  /// administrator account.
  ///
  /// This operation is only used by accounts that are not part of an
  /// organization. For organization accounts, only the administrator account
  /// can disassociate a member account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  Future<void> disassociateFromAdministratorAccount() async {
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri: '/administrator/disassociate',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// This method is deprecated. Instead, use
  /// <code>DisassociateFromAdministratorAccount</code>.
  ///
  /// The Security Hub console continues to use
  /// <code>DisassociateFromMasterAccount</code>. It will eventually change to
  /// use <code>DisassociateFromAdministratorAccount</code>. Any IAM policies
  /// that specifically control access to this function must continue to use
  /// <code>DisassociateFromMasterAccount</code>. You should also add
  /// <code>DisassociateFromAdministratorAccount</code> to your policies to
  /// ensure that the correct permissions are in place after the console begins
  /// to use <code>DisassociateFromAdministratorAccount</code>.
  ///
  /// Disassociates the current Security Hub member account from the associated
  /// administrator account.
  ///
  /// This operation is only used by accounts that are not part of an
  /// organization. For organization accounts, only the administrator account
  /// can disassociate a member account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  @Deprecated(
      'This API has been deprecated, use DisassociateFromAdministratorAccount API instead.')
  Future<void> disassociateFromMasterAccount() async {
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri: '/master/disassociate',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Disassociates the specified member accounts from the associated
  /// administrator account.
  ///
  /// Can be used to disassociate both accounts that are managed using
  /// Organizations and accounts that were invited manually.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [accountIds] :
  /// The account IDs of the member accounts to disassociate from the
  /// administrator account.
  Future<void> disassociateMembers({
    required List<String> accountIds,
  }) async {
    final $payload = <String, dynamic>{
      'AccountIds': accountIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/members/disassociate',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Enables the integration of a partner product with Security Hub. Integrated
  /// products send findings to Security Hub.
  ///
  /// When you enable a product integration, a permissions policy that grants
  /// permission for the product to send findings to Security Hub is applied.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceConflictException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [productArn] :
  /// The ARN of the product to enable the integration for.
  Future<EnableImportFindingsForProductResponse>
      enableImportFindingsForProduct({
    required String productArn,
  }) async {
    final $payload = <String, dynamic>{
      'ProductArn': productArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/productSubscriptions',
      exceptionFnMap: _exceptionFns,
    );
    return EnableImportFindingsForProductResponse.fromJson(response);
  }

  /// Designates the Security Hub administrator account for an organization. Can
  /// only be called by the organization management account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [adminAccountId] :
  /// The Amazon Web Services account identifier of the account to designate as
  /// the Security Hub administrator account.
  Future<void> enableOrganizationAdminAccount({
    required String adminAccountId,
  }) async {
    final $payload = <String, dynamic>{
      'AdminAccountId': adminAccountId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/organization/admin/enable',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Enables Security Hub for your account in the current Region or the Region
  /// you specify in the request.
  ///
  /// When you enable Security Hub, you grant to Security Hub the permissions
  /// necessary to gather findings from other services that are integrated with
  /// Security Hub.
  ///
  /// When you use the <code>EnableSecurityHub</code> operation to enable
  /// Security Hub, you also automatically enable the following standards:
  ///
  /// <ul>
  /// <li>
  /// Center for Internet Security (CIS) Amazon Web Services Foundations
  /// Benchmark v1.2.0
  /// </li>
  /// <li>
  /// Amazon Web Services Foundational Security Best Practices
  /// </li>
  /// </ul>
  /// Other standards are not automatically enabled.
  ///
  /// To opt out of automatically enabled standards, set
  /// <code>EnableDefaultStandards</code> to <code>false</code>.
  ///
  /// After you enable Security Hub, to enable a standard, use the
  /// <code>BatchEnableStandards</code> operation. To disable a standard, use
  /// the <code>BatchDisableStandards</code> operation.
  ///
  /// To learn more, see the <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-settingup.html">setup
  /// information</a> in the <i>Security Hub User Guide</i>.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceConflictException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [controlFindingGenerator] :
  /// This field, used when enabling Security Hub, specifies whether the calling
  /// account has consolidated control findings turned on. If the value for this
  /// field is set to <code>SECURITY_CONTROL</code>, Security Hub generates a
  /// single finding for a control check even when the check applies to multiple
  /// enabled standards.
  ///
  /// If the value for this field is set to <code>STANDARD_CONTROL</code>,
  /// Security Hub generates separate findings for a control check when the
  /// check applies to multiple enabled standards.
  ///
  /// The value for this field in a member account matches the value in the
  /// administrator account. For accounts that aren't part of an organization,
  /// the default value of this field is <code>SECURITY_CONTROL</code> if you
  /// enabled Security Hub on or after February 23, 2023.
  ///
  /// Parameter [enableDefaultStandards] :
  /// Whether to enable the security standards that Security Hub has designated
  /// as automatically enabled. If you do not provide a value for
  /// <code>EnableDefaultStandards</code>, it is set to <code>true</code>. To
  /// not enable the automatically enabled standards, set
  /// <code>EnableDefaultStandards</code> to <code>false</code>.
  ///
  /// Parameter [tags] :
  /// The tags to add to the hub resource when you enable Security Hub.
  Future<void> enableSecurityHub({
    ControlFindingGenerator? controlFindingGenerator,
    bool? enableDefaultStandards,
    Map<String, String>? tags,
  }) async {
    final $payload = <String, dynamic>{
      if (controlFindingGenerator != null)
        'ControlFindingGenerator': controlFindingGenerator.toValue(),
      if (enableDefaultStandards != null)
        'EnableDefaultStandards': enableDefaultStandards,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/accounts',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Provides the details for the Security Hub administrator account for the
  /// current member account.
  ///
  /// Can be used by both member accounts that are managed using Organizations
  /// and accounts that were invited manually.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  Future<GetAdministratorAccountResponse> getAdministratorAccount() async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/administrator',
      exceptionFnMap: _exceptionFns,
    );
    return GetAdministratorAccountResponse.fromJson(response);
  }

  /// Provides information about a configuration policy. Only the Security Hub
  /// delegated administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [identifier] :
  /// The Amazon Resource Name (ARN) or universally unique identifier (UUID) of
  /// the configuration policy.
  Future<GetConfigurationPolicyResponse> getConfigurationPolicy({
    required String identifier,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/configurationPolicy/get/${Uri.encodeComponent(identifier)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetConfigurationPolicyResponse.fromJson(response);
  }

  /// Returns the association between a configuration and a target account,
  /// organizational unit, or the root. The configuration can be a configuration
  /// policy or self-managed behavior. Only the Security Hub delegated
  /// administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [target] :
  /// The target account ID, organizational unit ID, or the root ID to retrieve
  /// the association for.
  Future<GetConfigurationPolicyAssociationResponse>
      getConfigurationPolicyAssociation({
    required Target target,
  }) async {
    final $payload = <String, dynamic>{
      'Target': target,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/configurationPolicyAssociation/get',
      exceptionFnMap: _exceptionFns,
    );
    return GetConfigurationPolicyAssociationResponse.fromJson(response);
  }

  /// Returns a list of the standards that are currently enabled.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return in the response.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>GetEnabledStandards</code> operation, set the value of this
  /// parameter to <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  ///
  /// Parameter [standardsSubscriptionArns] :
  /// The list of the standards subscription ARNs for the standards to retrieve.
  Future<GetEnabledStandardsResponse> getEnabledStandards({
    int? maxResults,
    String? nextToken,
    List<String>? standardsSubscriptionArns,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (standardsSubscriptionArns != null)
        'StandardsSubscriptionArns': standardsSubscriptionArns,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/standards/get',
      exceptionFnMap: _exceptionFns,
    );
    return GetEnabledStandardsResponse.fromJson(response);
  }

  /// Returns the current finding aggregation configuration.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [findingAggregatorArn] :
  /// The ARN of the finding aggregator to return details for. To obtain the
  /// ARN, use <code>ListFindingAggregators</code>.
  Future<GetFindingAggregatorResponse> getFindingAggregator({
    required String findingAggregatorArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/findingAggregator/get/${findingAggregatorArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
    return GetFindingAggregatorResponse.fromJson(response);
  }

  /// Returns history for a Security Hub finding in the last 90 days. The
  /// history includes changes made to any fields in the Amazon Web Services
  /// Security Finding Format (ASFF).
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [endTime] :
  /// An ISO 8601-formatted timestamp that indicates the end time of the
  /// requested finding history.
  ///
  /// If you provide values for both <code>StartTime</code> and
  /// <code>EndTime</code>, Security Hub returns finding history for the
  /// specified time period. If you provide a value for <code>StartTime</code>
  /// but not for <code>EndTime</code>, Security Hub returns finding history
  /// from the <code>StartTime</code> to the time at which the API is called. If
  /// you provide a value for <code>EndTime</code> but not for
  /// <code>StartTime</code>, Security Hub returns finding history from the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_AwsSecurityFindingFilters.html#securityhub-Type-AwsSecurityFindingFilters-CreatedAt">CreatedAt</a>
  /// timestamp of the finding to the <code>EndTime</code>. If you provide
  /// neither <code>StartTime</code> nor <code>EndTime</code>, Security Hub
  /// returns finding history from the CreatedAt timestamp of the finding to the
  /// time at which the API is called. In all of these scenarios, the response
  /// is limited to 100 results, and the maximum time period is limited to 90
  /// days.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>.
  /// The time-secfrac after seconds is limited to a maximum of 9 digits. The
  /// offset is bounded by +/-18:00. Here are valid timestamp formats with
  /// examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned. If you don’t provide it,
  /// Security Hub returns up to 100 results of finding history.
  ///
  /// Parameter [nextToken] :
  /// A token for pagination purposes. Provide <code>NULL</code> as the initial
  /// value. In subsequent requests, provide the token included in the response
  /// to get up to an additional 100 results of finding history. If you don’t
  /// provide <code>NextToken</code>, Security Hub returns up to 100 results of
  /// finding history for each request.
  ///
  /// Parameter [startTime] :
  /// A timestamp that indicates the start time of the requested finding
  /// history.
  ///
  /// If you provide values for both <code>StartTime</code> and
  /// <code>EndTime</code>, Security Hub returns finding history for the
  /// specified time period. If you provide a value for <code>StartTime</code>
  /// but not for <code>EndTime</code>, Security Hub returns finding history
  /// from the <code>StartTime</code> to the time at which the API is called. If
  /// you provide a value for <code>EndTime</code> but not for
  /// <code>StartTime</code>, Security Hub returns finding history from the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_AwsSecurityFindingFilters.html#securityhub-Type-AwsSecurityFindingFilters-CreatedAt">CreatedAt</a>
  /// timestamp of the finding to the <code>EndTime</code>. If you provide
  /// neither <code>StartTime</code> nor <code>EndTime</code>, Security Hub
  /// returns finding history from the CreatedAt timestamp of the finding to the
  /// time at which the API is called. In all of these scenarios, the response
  /// is limited to 100 results, and the maximum time period is limited to 90
  /// days.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>.
  /// The time-secfrac after seconds is limited to a maximum of 9 digits. The
  /// offset is bounded by +/-18:00. Here are valid timestamp formats with
  /// examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  Future<GetFindingHistoryResponse> getFindingHistory({
    required AwsSecurityFindingIdentifier findingIdentifier,
    DateTime? endTime,
    int? maxResults,
    String? nextToken,
    DateTime? startTime,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'FindingIdentifier': findingIdentifier,
      if (endTime != null) 'EndTime': iso8601ToJson(endTime),
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (startTime != null) 'StartTime': iso8601ToJson(startTime),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/findingHistory/get',
      exceptionFnMap: _exceptionFns,
    );
    return GetFindingHistoryResponse.fromJson(response);
  }

  /// Returns a list of findings that match the specified criteria.
  ///
  /// If finding aggregation is enabled, then when you call
  /// <code>GetFindings</code> from the aggregation Region, the results include
  /// all of the matching findings from both the aggregation Region and the
  /// linked Regions.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [filters] :
  /// The finding attributes used to define a condition to filter the returned
  /// findings.
  ///
  /// You can filter by up to 10 finding attributes. For each attribute, you can
  /// provide up to 20 filter values.
  ///
  /// Note that in the available filter fields, <code>WorkflowState</code> is
  /// deprecated. To search for a finding based on its workflow status, use
  /// <code>WorkflowStatus</code>.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of findings to return.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>GetFindings</code> operation, set the value of this parameter to
  /// <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  ///
  /// Parameter [sortCriteria] :
  /// The finding attributes used to sort the list of returned findings.
  Future<GetFindingsResponse> getFindings({
    AwsSecurityFindingFilters? filters,
    int? maxResults,
    String? nextToken,
    List<SortCriterion>? sortCriteria,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
      if (sortCriteria != null) 'SortCriteria': sortCriteria,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/findings',
      exceptionFnMap: _exceptionFns,
    );
    return GetFindingsResponse.fromJson(response);
  }

  /// Lists the results of the Security Hub insight specified by the insight
  /// ARN.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [insightArn] :
  /// The ARN of the insight for which to return results.
  Future<GetInsightResultsResponse> getInsightResults({
    required String insightArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/insights/results/${insightArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
    return GetInsightResultsResponse.fromJson(response);
  }

  /// Lists and describes insights for the specified insight ARNs.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [insightArns] :
  /// The ARNs of the insights to describe. If you do not provide any insight
  /// ARNs, then <code>GetInsights</code> returns all of your custom insights.
  /// It does not return any managed insights.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of items to return in the response.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>GetInsights</code> operation, set the value of this parameter to
  /// <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  Future<GetInsightsResponse> getInsights({
    List<String>? insightArns,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (insightArns != null) 'InsightArns': insightArns,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/insights/get',
      exceptionFnMap: _exceptionFns,
    );
    return GetInsightsResponse.fromJson(response);
  }

  /// Returns the count of all Security Hub membership invitations that were
  /// sent to the current member account, not including the currently accepted
  /// invitation.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  Future<GetInvitationsCountResponse> getInvitationsCount() async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/invitations/count',
      exceptionFnMap: _exceptionFns,
    );
    return GetInvitationsCountResponse.fromJson(response);
  }

  /// This method is deprecated. Instead, use
  /// <code>GetAdministratorAccount</code>.
  ///
  /// The Security Hub console continues to use <code>GetMasterAccount</code>.
  /// It will eventually change to use <code>GetAdministratorAccount</code>. Any
  /// IAM policies that specifically control access to this function must
  /// continue to use <code>GetMasterAccount</code>. You should also add
  /// <code>GetAdministratorAccount</code> to your policies to ensure that the
  /// correct permissions are in place after the console begins to use
  /// <code>GetAdministratorAccount</code>.
  ///
  /// Provides the details for the Security Hub administrator account for the
  /// current member account.
  ///
  /// Can be used by both member accounts that are managed using Organizations
  /// and accounts that were invited manually.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  @Deprecated(
      'This API has been deprecated, use GetAdministratorAccount API instead.')
  Future<GetMasterAccountResponse> getMasterAccount() async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/master',
      exceptionFnMap: _exceptionFns,
    );
    return GetMasterAccountResponse.fromJson(response);
  }

  /// Returns the details for the Security Hub member accounts for the specified
  /// account IDs.
  ///
  /// An administrator account can be either the delegated Security Hub
  /// administrator account for an organization or an administrator account that
  /// enabled Security Hub manually.
  ///
  /// The results include both member accounts that are managed using
  /// Organizations and accounts that were invited manually.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [accountIds] :
  /// The list of account IDs for the Security Hub member accounts to return the
  /// details for.
  Future<GetMembersResponse> getMembers({
    required List<String> accountIds,
  }) async {
    final $payload = <String, dynamic>{
      'AccountIds': accountIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/members/get',
      exceptionFnMap: _exceptionFns,
    );
    return GetMembersResponse.fromJson(response);
  }

  /// Retrieves the definition of a security control. The definition includes
  /// the control title, description, Region availability, parameter
  /// definitions, and other details.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [securityControlId] :
  /// The ID of the security control to retrieve the definition for. This field
  /// doesn’t accept an Amazon Resource Name (ARN).
  Future<GetSecurityControlDefinitionResponse> getSecurityControlDefinition({
    required String securityControlId,
  }) async {
    final $query = <String, List<String>>{
      'SecurityControlId': [securityControlId],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/securityControl/definition',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetSecurityControlDefinitionResponse.fromJson(response);
  }

  /// Invites other Amazon Web Services accounts to become member accounts for
  /// the Security Hub administrator account that the invitation is sent from.
  ///
  /// This operation is only used to invite accounts that do not belong to an
  /// organization. Organization accounts do not receive invitations.
  ///
  /// Before you can use this action to invite a member, you must first use the
  /// <code>CreateMembers</code> action to create the member account in Security
  /// Hub.
  ///
  /// When the account owner enables Security Hub and accepts the invitation to
  /// become a member account, the administrator account can view the findings
  /// generated from the member account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [accountIds] :
  /// The list of account IDs of the Amazon Web Services accounts to invite to
  /// Security Hub as members.
  Future<InviteMembersResponse> inviteMembers({
    required List<String> accountIds,
  }) async {
    final $payload = <String, dynamic>{
      'AccountIds': accountIds,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/members/invite',
      exceptionFnMap: _exceptionFns,
    );
    return InviteMembersResponse.fromJson(response);
  }

  /// A list of automation rules and their metadata for the calling account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of rules to return in the response. This currently
  /// ranges from 1 to 100.
  ///
  /// Parameter [nextToken] :
  /// A token to specify where to start paginating the response. This is the
  /// <code>NextToken</code> from a previously truncated response. On your first
  /// call to the <code>ListAutomationRules</code> API, set the value of this
  /// parameter to <code>NULL</code>.
  Future<ListAutomationRulesResponse> listAutomationRules({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/automationrules/list',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListAutomationRulesResponse.fromJson(response);
  }

  /// Lists the configuration policies that the Security Hub delegated
  /// administrator has created for your organization. Only the delegated
  /// administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that's returned by
  /// <code>ListConfigurationPolicies</code> in each page of the response. When
  /// this parameter is used, <code>ListConfigurationPolicies</code> returns the
  /// specified number of results in a single page and a <code>NextToken</code>
  /// response element. You can see the remaining results of the initial request
  /// by sending another <code>ListConfigurationPolicies</code> request with the
  /// returned <code>NextToken</code> value. A valid range for
  /// <code>MaxResults</code> is between 1 and 100.
  ///
  /// Parameter [nextToken] :
  /// The NextToken value that's returned from a previous paginated
  /// <code>ListConfigurationPolicies</code> request where
  /// <code>MaxResults</code> was used but the results exceeded the value of
  /// that parameter. Pagination continues from the <code>MaxResults</code> was
  /// used but the results exceeded the value of that parameter. Pagination
  /// continues from the end of the previous response that returned the
  /// <code>NextToken</code> value. This value is <code>null</code> when there
  /// are no more results to return.
  Future<ListConfigurationPoliciesResponse> listConfigurationPolicies({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/configurationPolicy/list',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListConfigurationPoliciesResponse.fromJson(response);
  }

  /// Provides information about the associations for your configuration
  /// policies and self-managed behavior. Only the Security Hub delegated
  /// administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [filters] :
  /// Options for filtering the <code>ListConfigurationPolicyAssociations</code>
  /// response. You can filter by the Amazon Resource Name (ARN) or universally
  /// unique identifier (UUID) of a configuration, <code>AssociationType</code>,
  /// or <code>AssociationStatus</code>.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that's returned by
  /// <code>ListConfigurationPolicies</code> in each page of the response. When
  /// this parameter is used, <code>ListConfigurationPolicyAssociations</code>
  /// returns the specified number of results in a single page and a
  /// <code>NextToken</code> response element. You can see the remaining results
  /// of the initial request by sending another
  /// <code>ListConfigurationPolicyAssociations</code> request with the returned
  /// <code>NextToken</code> value. A valid range for <code>MaxResults</code> is
  /// between 1 and 100.
  ///
  /// Parameter [nextToken] :
  /// The <code>NextToken</code> value that's returned from a previous paginated
  /// <code>ListConfigurationPolicyAssociations</code> request where
  /// <code>MaxResults</code> was used but the results exceeded the value of
  /// that parameter. Pagination continues from the end of the previous response
  /// that returned the <code>NextToken</code> value. This value is
  /// <code>null</code> when there are no more results to return.
  Future<ListConfigurationPolicyAssociationsResponse>
      listConfigurationPolicyAssociations({
    AssociationFilters? filters,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      if (filters != null) 'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/configurationPolicyAssociation/list',
      exceptionFnMap: _exceptionFns,
    );
    return ListConfigurationPolicyAssociationsResponse.fromJson(response);
  }

  /// Lists all findings-generating solutions (products) that you are subscribed
  /// to receive findings from in Security Hub.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of items to return in the response.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>ListEnabledProductsForImport</code> operation, set the value of this
  /// parameter to <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  Future<ListEnabledProductsForImportResponse> listEnabledProductsForImport({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/productSubscriptions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListEnabledProductsForImportResponse.fromJson(response);
  }

  /// If finding aggregation is enabled, then
  /// <code>ListFindingAggregators</code> returns the ARN of the finding
  /// aggregator. You can run this operation from any Region.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return. This operation currently only
  /// returns a single result.
  ///
  /// Parameter [nextToken] :
  /// The token returned with the previous set of results. Identifies the next
  /// set of results to return.
  Future<ListFindingAggregatorsResponse> listFindingAggregators({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/findingAggregator/list',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListFindingAggregatorsResponse.fromJson(response);
  }

  /// Lists all Security Hub membership invitations that were sent to the
  /// current Amazon Web Services account.
  ///
  /// This operation is only used by accounts that are managed by invitation.
  /// Accounts that are managed using the integration with Organizations do not
  /// receive invitations.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of items to return in the response.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>ListInvitations</code> operation, set the value of this parameter to
  /// <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  Future<ListInvitationsResponse> listInvitations({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      50,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/invitations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListInvitationsResponse.fromJson(response);
  }

  /// Lists details about all member accounts for the current Security Hub
  /// administrator account.
  ///
  /// The results include both member accounts that belong to an organization
  /// and member accounts that were invited manually.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of items to return in the response.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>ListMembers</code> operation, set the value of this parameter to
  /// <code>NULL</code>.
  ///
  /// For subsequent calls to the operation, to continue listing data, set the
  /// value of this parameter to the value returned from the previous response.
  ///
  /// Parameter [onlyAssociated] :
  /// Specifies which member accounts to include in the response based on their
  /// relationship status with the administrator account. The default value is
  /// <code>TRUE</code>.
  ///
  /// If <code>OnlyAssociated</code> is set to <code>TRUE</code>, the response
  /// includes member accounts whose relationship status with the administrator
  /// account is set to <code>ENABLED</code>.
  ///
  /// If <code>OnlyAssociated</code> is set to <code>FALSE</code>, the response
  /// includes all existing member accounts.
  Future<ListMembersResponse> listMembers({
    int? maxResults,
    String? nextToken,
    bool? onlyAssociated,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      50,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
      if (onlyAssociated != null) 'OnlyAssociated': [onlyAssociated.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/members',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListMembersResponse.fromJson(response);
  }

  /// Lists the Security Hub administrator accounts. Can only be called by the
  /// organization management account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of items to return in the response.
  ///
  /// Parameter [nextToken] :
  /// The token that is required for pagination. On your first call to the
  /// <code>ListOrganizationAdminAccounts</code> operation, set the value of
  /// this parameter to <code>NULL</code>. For subsequent calls to the
  /// operation, to continue listing data, set the value of this parameter to
  /// the value returned from the previous response.
  Future<ListOrganizationAdminAccountsResponse> listOrganizationAdminAccounts({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/organization/admin',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListOrganizationAdminAccountsResponse.fromJson(response);
  }

  /// Lists all of the security controls that apply to a specified standard.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  ///
  /// Parameter [maxResults] :
  /// An optional parameter that limits the total results of the API response to
  /// the specified number. If this parameter isn't provided in the request, the
  /// results include the first 25 security controls that apply to the specified
  /// standard. The results also include a <code>NextToken</code> parameter that
  /// you can use in a subsequent API call to get the next 25 controls. This
  /// repeats until all controls for the standard are returned.
  ///
  /// Parameter [nextToken] :
  /// Optional pagination parameter.
  ///
  /// Parameter [standardsArn] :
  /// The Amazon Resource Name (ARN) of the standard that you want to view
  /// controls for.
  Future<ListSecurityControlDefinitionsResponse>
      listSecurityControlDefinitions({
    int? maxResults,
    String? nextToken,
    String? standardsArn,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
      if (standardsArn != null) 'StandardsArn': [standardsArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/securityControls/definitions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListSecurityControlDefinitionsResponse.fromJson(response);
  }

  /// Specifies whether a control is currently enabled or disabled in each
  /// enabled standard in the calling account.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [securityControlId] :
  /// The identifier of the control (identified with
  /// <code>SecurityControlId</code>, <code>SecurityControlArn</code>, or a mix
  /// of both parameters) that you want to determine the enablement status of in
  /// each enabled standard.
  ///
  /// Parameter [maxResults] :
  /// An optional parameter that limits the total results of the API response to
  /// the specified number. If this parameter isn't provided in the request, the
  /// results include the first 25 standard and control associations. The
  /// results also include a <code>NextToken</code> parameter that you can use
  /// in a subsequent API call to get the next 25 associations. This repeats
  /// until all associations for the specified control are returned. The number
  /// of results is limited by the number of supported Security Hub standards
  /// that you've enabled in the calling account.
  ///
  /// Parameter [nextToken] :
  /// Optional pagination parameter.
  Future<ListStandardsControlAssociationsResponse>
      listStandardsControlAssociations({
    required String securityControlId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      'SecurityControlId': [securityControlId],
      if (maxResults != null) 'MaxResults': [maxResults.toString()],
      if (nextToken != null) 'NextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/associations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListStandardsControlAssociationsResponse.fromJson(response);
  }

  /// Returns a list of tags associated with a resource.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the resource to retrieve tags for.
  Future<ListTagsForResourceResponse> listTagsForResource({
    required String resourceArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/tags/${Uri.encodeComponent(resourceArn)}',
      exceptionFnMap: _exceptionFns,
    );
    return ListTagsForResourceResponse.fromJson(response);
  }

  /// Associates a target account, organizational unit, or the root with a
  /// specified configuration. The target can be associated with a configuration
  /// policy or self-managed behavior. Only the Security Hub delegated
  /// administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [configurationPolicyIdentifier] :
  /// The Amazon Resource Name (ARN) of a configuration policy, the universally
  /// unique identifier (UUID) of a configuration policy, or a value of
  /// <code>SELF_MANAGED_SECURITY_HUB</code> for a self-managed configuration.
  ///
  /// Parameter [target] :
  /// The identifier of the target account, organizational unit, or the root to
  /// associate with the specified configuration.
  Future<StartConfigurationPolicyAssociationResponse>
      startConfigurationPolicyAssociation({
    required String configurationPolicyIdentifier,
    required Target target,
  }) async {
    final $payload = <String, dynamic>{
      'ConfigurationPolicyIdentifier': configurationPolicyIdentifier,
      'Target': target,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/configurationPolicyAssociation/associate',
      exceptionFnMap: _exceptionFns,
    );
    return StartConfigurationPolicyAssociationResponse.fromJson(response);
  }

  /// Disassociates a target account, organizational unit, or the root from a
  /// specified configuration. When you disassociate a configuration from its
  /// target, the target inherits the configuration of the closest parent. If
  /// there’s no configuration to inherit, the target retains its settings but
  /// becomes a self-managed account. A target can be disassociated from a
  /// configuration policy or self-managed behavior. Only the Security Hub
  /// delegated administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [configurationPolicyIdentifier] :
  /// The Amazon Resource Name (ARN) of a configuration policy, the universally
  /// unique identifier (UUID) of a configuration policy, or a value of
  /// <code>SELF_MANAGED_SECURITY_HUB</code> for a self-managed configuration.
  ///
  /// Parameter [target] :
  /// The identifier of the target account, organizational unit, or the root to
  /// disassociate from the specified configuration.
  Future<void> startConfigurationPolicyDisassociation({
    required String configurationPolicyIdentifier,
    Target? target,
  }) async {
    final $payload = <String, dynamic>{
      'ConfigurationPolicyIdentifier': configurationPolicyIdentifier,
      if (target != null) 'Target': target,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/configurationPolicyAssociation/disassociate',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Adds one or more tags to a resource.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the resource to apply the tags to.
  ///
  /// Parameter [tags] :
  /// The tags to add to the resource. You can add up to 50 tags at a time. The
  /// tag keys can be no longer than 128 characters. The tag values can be no
  /// longer than 256 characters.
  Future<void> tagResource({
    required String resourceArn,
    required Map<String, String> tags,
  }) async {
    final $payload = <String, dynamic>{
      'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/tags/${Uri.encodeComponent(resourceArn)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Removes one or more tags from a resource.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the resource to remove the tags from.
  ///
  /// Parameter [tagKeys] :
  /// The tag keys associated with the tags to remove from the resource. You can
  /// remove up to 50 tags at a time.
  Future<void> untagResource({
    required String resourceArn,
    required List<String> tagKeys,
  }) async {
    final $query = <String, List<String>>{
      'tagKeys': tagKeys,
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/tags/${Uri.encodeComponent(resourceArn)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the name and description of a custom action target in Security
  /// Hub.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [actionTargetArn] :
  /// The ARN of the custom action target to update.
  ///
  /// Parameter [description] :
  /// The updated description for the custom action target.
  ///
  /// Parameter [name] :
  /// The updated name of the custom action target.
  Future<void> updateActionTarget({
    required String actionTargetArn,
    String? description,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri:
          '/actionTargets/${actionTargetArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates a configuration policy. Only the Security Hub delegated
  /// administrator can invoke this operation from the home Region.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidAccessException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [identifier] :
  /// The Amazon Resource Name (ARN) or universally unique identifier (UUID) of
  /// the configuration policy.
  ///
  /// Parameter [configurationPolicy] :
  /// An object that defines how Security Hub is configured. It includes whether
  /// Security Hub is enabled or disabled, a list of enabled security standards,
  /// a list of enabled or disabled security controls, and a list of custom
  /// parameter values for specified controls. If you provide a list of security
  /// controls that are enabled in the configuration policy, Security Hub
  /// disables all other controls (including newly released controls). If you
  /// provide a list of security controls that are disabled in the configuration
  /// policy, Security Hub enables all other controls (including newly released
  /// controls).
  ///
  /// When updating a configuration policy, provide a complete list of standards
  /// that you want to enable and a complete list of controls that you want to
  /// enable or disable. The updated configuration replaces the current
  /// configuration.
  ///
  /// Parameter [description] :
  /// The description of the configuration policy.
  ///
  /// Parameter [name] :
  /// The name of the configuration policy. Alphanumeric characters and the
  /// following ASCII characters are permitted: <code>-, ., !, *, /</code>.
  ///
  /// Parameter [updatedReason] :
  /// The reason for updating the configuration policy.
  Future<UpdateConfigurationPolicyResponse> updateConfigurationPolicy({
    required String identifier,
    Policy? configurationPolicy,
    String? description,
    String? name,
    String? updatedReason,
  }) async {
    final $payload = <String, dynamic>{
      if (configurationPolicy != null)
        'ConfigurationPolicy': configurationPolicy,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (updatedReason != null) 'UpdatedReason': updatedReason,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/configurationPolicy/${Uri.encodeComponent(identifier)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateConfigurationPolicyResponse.fromJson(response);
  }

  /// Updates the finding aggregation configuration. Used to update the Region
  /// linking mode and the list of included or excluded Regions. You cannot use
  /// <code>UpdateFindingAggregator</code> to change the aggregation Region.
  ///
  /// You must run <code>UpdateFindingAggregator</code> from the current
  /// aggregation Region.
  ///
  /// May throw [InternalException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidInputException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [findingAggregatorArn] :
  /// The ARN of the finding aggregator. To obtain the ARN, use
  /// <code>ListFindingAggregators</code>.
  ///
  /// Parameter [regionLinkingMode] :
  /// Indicates whether to aggregate findings from all of the available Regions
  /// in the current partition. Also determines whether to automatically
  /// aggregate findings from new Regions as Security Hub supports them and you
  /// opt into them.
  ///
  /// The selected option also determines how to use the Regions provided in the
  /// Regions list.
  ///
  /// The options are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_REGIONS</code> - Indicates to aggregate findings from all of the
  /// Regions where Security Hub is enabled. When you choose this option,
  /// Security Hub also automatically aggregates findings from new Regions as
  /// Security Hub supports them and you opt into them.
  /// </li>
  /// <li>
  /// <code>ALL_REGIONS_EXCEPT_SPECIFIED</code> - Indicates to aggregate
  /// findings from all of the Regions where Security Hub is enabled, except for
  /// the Regions listed in the <code>Regions</code> parameter. When you choose
  /// this option, Security Hub also automatically aggregates findings from new
  /// Regions as Security Hub supports them and you opt into them.
  /// </li>
  /// <li>
  /// <code>SPECIFIED_REGIONS</code> - Indicates to aggregate findings only from
  /// the Regions listed in the <code>Regions</code> parameter. Security Hub
  /// does not automatically aggregate findings from new Regions.
  /// </li>
  /// </ul>
  ///
  /// Parameter [regions] :
  /// If <code>RegionLinkingMode</code> is
  /// <code>ALL_REGIONS_EXCEPT_SPECIFIED</code>, then this is a space-separated
  /// list of Regions that do not aggregate findings to the aggregation Region.
  ///
  /// If <code>RegionLinkingMode</code> is <code>SPECIFIED_REGIONS</code>, then
  /// this is a space-separated list of Regions that do aggregate findings to
  /// the aggregation Region.
  Future<UpdateFindingAggregatorResponse> updateFindingAggregator({
    required String findingAggregatorArn,
    required String regionLinkingMode,
    List<String>? regions,
  }) async {
    final $payload = <String, dynamic>{
      'FindingAggregatorArn': findingAggregatorArn,
      'RegionLinkingMode': regionLinkingMode,
      if (regions != null) 'Regions': regions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/findingAggregator/update',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateFindingAggregatorResponse.fromJson(response);
  }

  /// <code>UpdateFindings</code> is a deprecated operation. Instead of
  /// <code>UpdateFindings</code>, use the <code>BatchUpdateFindings</code>
  /// operation.
  ///
  /// Updates the <code>Note</code> and <code>RecordState</code> of the Security
  /// Hub-aggregated findings that the filter attributes specify. Any member
  /// account that can view the finding also sees the update to the finding.
  ///
  /// Finding updates made with <code>UpdateFindings</code> might not be
  /// persisted if the same finding is later updated by the finding provider
  /// through the <code>BatchImportFindings</code> operation.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [filters] :
  /// A collection of attributes that specify which findings you want to update.
  ///
  /// Parameter [note] :
  /// The updated note for the finding.
  ///
  /// Parameter [recordState] :
  /// The updated record state for the finding.
  Future<void> updateFindings({
    required AwsSecurityFindingFilters filters,
    NoteUpdate? note,
    RecordState? recordState,
  }) async {
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (note != null) 'Note': note,
      if (recordState != null) 'RecordState': recordState.toValue(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/findings',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the Security Hub insight identified by the specified insight ARN.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [insightArn] :
  /// The ARN of the insight that you want to update.
  ///
  /// Parameter [filters] :
  /// The updated filters that define this insight.
  ///
  /// Parameter [groupByAttribute] :
  /// The updated <code>GroupBy</code> attribute that defines this insight.
  ///
  /// Parameter [name] :
  /// The updated name for the insight.
  Future<void> updateInsight({
    required String insightArn,
    AwsSecurityFindingFilters? filters,
    String? groupByAttribute,
    String? name,
  }) async {
    final $payload = <String, dynamic>{
      if (filters != null) 'Filters': filters,
      if (groupByAttribute != null) 'GroupByAttribute': groupByAttribute,
      if (name != null) 'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri:
          '/insights/${insightArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the configuration of your organization in Security Hub. Only the
  /// Security Hub administrator account can invoke this operation.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceConflictException].
  ///
  /// Parameter [autoEnable] :
  /// Whether to automatically enable Security Hub in new member accounts when
  /// they join the organization.
  ///
  /// If set to <code>true</code>, then Security Hub is automatically enabled in
  /// new accounts. If set to <code>false</code>, then Security Hub isn't
  /// enabled in new accounts automatically. The default value is
  /// <code>false</code>.
  ///
  /// If the <code>ConfigurationType</code> of your organization is set to
  /// <code>CENTRAL</code>, then this field is set to <code>false</code> and
  /// can't be changed in the home Region and linked Regions. However, in that
  /// case, the delegated administrator can create a configuration policy in
  /// which Security Hub is enabled and associate the policy with new
  /// organization accounts.
  ///
  /// Parameter [autoEnableStandards] :
  /// Whether to automatically enable Security Hub <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-enable-disable.html">default
  /// standards</a> in new member accounts when they join the organization.
  ///
  /// The default value of this parameter is equal to <code>DEFAULT</code>.
  ///
  /// If equal to <code>DEFAULT</code>, then Security Hub default standards are
  /// automatically enabled for new member accounts. If equal to
  /// <code>NONE</code>, then default standards are not automatically enabled
  /// for new member accounts.
  ///
  /// If the <code>ConfigurationType</code> of your organization is set to
  /// <code>CENTRAL</code>, then this field is set to <code>NONE</code> and
  /// can't be changed in the home Region and linked Regions. However, in that
  /// case, the delegated administrator can create a configuration policy in
  /// which specific security standards are enabled and associate the policy
  /// with new organization accounts.
  Future<void> updateOrganizationConfiguration({
    required bool autoEnable,
    AutoEnableStandards? autoEnableStandards,
    OrganizationConfiguration? organizationConfiguration,
  }) async {
    final $payload = <String, dynamic>{
      'AutoEnable': autoEnable,
      if (autoEnableStandards != null)
        'AutoEnableStandards': autoEnableStandards.toValue(),
      if (organizationConfiguration != null)
        'OrganizationConfiguration': organizationConfiguration,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/organization/configuration',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the properties of a security control.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceInUseException].
  ///
  /// Parameter [parameters] :
  /// An object that specifies which security control parameters to update.
  ///
  /// Parameter [securityControlId] :
  /// The Amazon Resource Name (ARN) or ID of the control to update.
  ///
  /// Parameter [lastUpdateReason] :
  /// The most recent reason for updating the properties of the security
  /// control. This field accepts alphanumeric characters in addition to white
  /// spaces, dashes, and underscores.
  Future<void> updateSecurityControl({
    required Map<String, ParameterConfiguration> parameters,
    required String securityControlId,
    String? lastUpdateReason,
  }) async {
    final $payload = <String, dynamic>{
      'Parameters': parameters,
      'SecurityControlId': securityControlId,
      if (lastUpdateReason != null) 'LastUpdateReason': lastUpdateReason,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/securityControl/update',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates configuration options for Security Hub.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [autoEnableControls] :
  /// Whether to automatically enable new controls when they are added to
  /// standards that are enabled.
  ///
  /// By default, this is set to <code>true</code>, and new controls are enabled
  /// automatically. To not automatically enable new controls, set this to
  /// <code>false</code>.
  ///
  /// Parameter [controlFindingGenerator] :
  /// Updates whether the calling account has consolidated control findings
  /// turned on. If the value for this field is set to
  /// <code>SECURITY_CONTROL</code>, Security Hub generates a single finding for
  /// a control check even when the check applies to multiple enabled standards.
  ///
  /// If the value for this field is set to <code>STANDARD_CONTROL</code>,
  /// Security Hub generates separate findings for a control check when the
  /// check applies to multiple enabled standards.
  ///
  /// For accounts that are part of an organization, this value can only be
  /// updated in the administrator account.
  Future<void> updateSecurityHubConfiguration({
    bool? autoEnableControls,
    ControlFindingGenerator? controlFindingGenerator,
  }) async {
    final $payload = <String, dynamic>{
      if (autoEnableControls != null) 'AutoEnableControls': autoEnableControls,
      if (controlFindingGenerator != null)
        'ControlFindingGenerator': controlFindingGenerator.toValue(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri: '/accounts',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Used to control whether an individual security standard control is enabled
  /// or disabled.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [InvalidAccessException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [standardsControlArn] :
  /// The ARN of the security standard control to enable or disable.
  ///
  /// Parameter [controlStatus] :
  /// The updated status of the security standard control.
  ///
  /// Parameter [disabledReason] :
  /// A description of the reason why you are disabling a security standard
  /// control. If you are disabling a control, then this is required.
  Future<void> updateStandardsControl({
    required String standardsControlArn,
    ControlStatus? controlStatus,
    String? disabledReason,
  }) async {
    final $payload = <String, dynamic>{
      if (controlStatus != null) 'ControlStatus': controlStatus.toValue(),
      if (disabledReason != null) 'DisabledReason': disabledReason,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PATCH',
      requestUri:
          '/standards/control/${standardsControlArn.split('/').map(Uri.encodeComponent).join('/')}',
      exceptionFnMap: _exceptionFns,
    );
  }
}

class AcceptAdministratorInvitationResponse {
  AcceptAdministratorInvitationResponse();

  factory AcceptAdministratorInvitationResponse.fromJson(
      Map<String, dynamic> _) {
    return AcceptAdministratorInvitationResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class AcceptInvitationResponse {
  AcceptInvitationResponse();

  factory AcceptInvitationResponse.fromJson(Map<String, dynamic> _) {
    return AcceptInvitationResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The details of an Amazon Web Services account.
class AccountDetails {
  /// The ID of an Amazon Web Services account.
  final String accountId;

  /// The email of an Amazon Web Services account.
  final String? email;

  AccountDetails({
    required this.accountId,
    this.email,
  });

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final email = this.email;
    return {
      'AccountId': accountId,
      if (email != null) 'Email': email,
    };
  }
}

/// Provides details about one of the following actions that affects or that was
/// taken on a resource:
///
/// <ul>
/// <li>
/// A remote IP address issued an Amazon Web Services API call
/// </li>
/// <li>
/// A DNS request was received
/// </li>
/// <li>
/// A remote IP address attempted to connect to an EC2 instance
/// </li>
/// <li>
/// A remote IP address attempted a port probe on an EC2 instance
/// </li>
/// </ul>
class Action {
  /// The type of action that was detected. The possible action types are:
  ///
  /// <ul>
  /// <li>
  /// <code>NETWORK_CONNECTION</code>
  /// </li>
  /// <li>
  /// <code>AWS_API_CALL</code>
  /// </li>
  /// <li>
  /// <code>DNS_REQUEST</code>
  /// </li>
  /// <li>
  /// <code>PORT_PROBE</code>
  /// </li>
  /// </ul>
  final String? actionType;

  /// Included if <code>ActionType</code> is <code>AWS_API_CALL</code>. Provides
  /// details about the API call that was detected.
  final AwsApiCallAction? awsApiCallAction;

  /// Included if <code>ActionType</code> is <code>DNS_REQUEST</code>. Provides
  /// details about the DNS request that was detected.
  final DnsRequestAction? dnsRequestAction;

  /// Included if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>.
  /// Provides details about the network connection that was detected.
  final NetworkConnectionAction? networkConnectionAction;

  /// Included if <code>ActionType</code> is <code>PORT_PROBE</code>. Provides
  /// details about the port probe that was detected.
  final PortProbeAction? portProbeAction;

  Action({
    this.actionType,
    this.awsApiCallAction,
    this.dnsRequestAction,
    this.networkConnectionAction,
    this.portProbeAction,
  });

  factory Action.fromJson(Map<String, dynamic> json) {
    return Action(
      actionType: json['ActionType'] as String?,
      awsApiCallAction: json['AwsApiCallAction'] != null
          ? AwsApiCallAction.fromJson(
              json['AwsApiCallAction'] as Map<String, dynamic>)
          : null,
      dnsRequestAction: json['DnsRequestAction'] != null
          ? DnsRequestAction.fromJson(
              json['DnsRequestAction'] as Map<String, dynamic>)
          : null,
      networkConnectionAction: json['NetworkConnectionAction'] != null
          ? NetworkConnectionAction.fromJson(
              json['NetworkConnectionAction'] as Map<String, dynamic>)
          : null,
      portProbeAction: json['PortProbeAction'] != null
          ? PortProbeAction.fromJson(
              json['PortProbeAction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final actionType = this.actionType;
    final awsApiCallAction = this.awsApiCallAction;
    final dnsRequestAction = this.dnsRequestAction;
    final networkConnectionAction = this.networkConnectionAction;
    final portProbeAction = this.portProbeAction;
    return {
      if (actionType != null) 'ActionType': actionType,
      if (awsApiCallAction != null) 'AwsApiCallAction': awsApiCallAction,
      if (dnsRequestAction != null) 'DnsRequestAction': dnsRequestAction,
      if (networkConnectionAction != null)
        'NetworkConnectionAction': networkConnectionAction,
      if (portProbeAction != null) 'PortProbeAction': portProbeAction,
    };
  }
}

/// Provides information about the IP address where the scanned port is located.
class ActionLocalIpDetails {
  /// The IP address.
  final String? ipAddressV4;

  ActionLocalIpDetails({
    this.ipAddressV4,
  });

  factory ActionLocalIpDetails.fromJson(Map<String, dynamic> json) {
    return ActionLocalIpDetails(
      ipAddressV4: json['IpAddressV4'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipAddressV4 = this.ipAddressV4;
    return {
      if (ipAddressV4 != null) 'IpAddressV4': ipAddressV4,
    };
  }
}

/// For <code>NetworkConnectionAction</code> and <code>PortProbeDetails</code>,
/// <code>LocalPortDetails</code> provides information about the local port that
/// was involved in the action.
class ActionLocalPortDetails {
  /// The number of the port.
  final int? port;

  /// The port name of the local connection.
  ///
  /// Length Constraints: 128.
  final String? portName;

  ActionLocalPortDetails({
    this.port,
    this.portName,
  });

  factory ActionLocalPortDetails.fromJson(Map<String, dynamic> json) {
    return ActionLocalPortDetails(
      port: json['Port'] as int?,
      portName: json['PortName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final port = this.port;
    final portName = this.portName;
    return {
      if (port != null) 'Port': port,
      if (portName != null) 'PortName': portName,
    };
  }
}

/// For <code>AwsApiAction</code>, <code>NetworkConnectionAction</code>, and
/// <code>PortProbeAction</code>, <code>RemoteIpDetails</code> provides
/// information about the remote IP address that was involved in the action.
class ActionRemoteIpDetails {
  /// The city where the remote IP address is located.
  final City? city;

  /// The country where the remote IP address is located.
  final Country? country;

  /// The coordinates of the location of the remote IP address.
  final GeoLocation? geoLocation;

  /// The IP address.
  final String? ipAddressV4;

  /// The internet service provider (ISP) organization associated with the remote
  /// IP address.
  final IpOrganizationDetails? organization;

  ActionRemoteIpDetails({
    this.city,
    this.country,
    this.geoLocation,
    this.ipAddressV4,
    this.organization,
  });

  factory ActionRemoteIpDetails.fromJson(Map<String, dynamic> json) {
    return ActionRemoteIpDetails(
      city: json['City'] != null
          ? City.fromJson(json['City'] as Map<String, dynamic>)
          : null,
      country: json['Country'] != null
          ? Country.fromJson(json['Country'] as Map<String, dynamic>)
          : null,
      geoLocation: json['GeoLocation'] != null
          ? GeoLocation.fromJson(json['GeoLocation'] as Map<String, dynamic>)
          : null,
      ipAddressV4: json['IpAddressV4'] as String?,
      organization: json['Organization'] != null
          ? IpOrganizationDetails.fromJson(
              json['Organization'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final city = this.city;
    final country = this.country;
    final geoLocation = this.geoLocation;
    final ipAddressV4 = this.ipAddressV4;
    final organization = this.organization;
    return {
      if (city != null) 'City': city,
      if (country != null) 'Country': country,
      if (geoLocation != null) 'GeoLocation': geoLocation,
      if (ipAddressV4 != null) 'IpAddressV4': ipAddressV4,
      if (organization != null) 'Organization': organization,
    };
  }
}

/// Provides information about the remote port that was involved in an attempted
/// network connection.
class ActionRemotePortDetails {
  /// The number of the port.
  final int? port;

  /// The port name of the remote connection.
  ///
  /// Length Constraints: 128.
  final String? portName;

  ActionRemotePortDetails({
    this.port,
    this.portName,
  });

  factory ActionRemotePortDetails.fromJson(Map<String, dynamic> json) {
    return ActionRemotePortDetails(
      port: json['Port'] as int?,
      portName: json['PortName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final port = this.port;
    final portName = this.portName;
    return {
      if (port != null) 'Port': port,
      if (portName != null) 'PortName': portName,
    };
  }
}

/// An <code>ActionTarget</code> object.
class ActionTarget {
  /// The ARN for the target action.
  final String actionTargetArn;

  /// The description of the target action.
  final String description;

  /// The name of the action target.
  final String name;

  ActionTarget({
    required this.actionTargetArn,
    required this.description,
    required this.name,
  });

  factory ActionTarget.fromJson(Map<String, dynamic> json) {
    return ActionTarget(
      actionTargetArn: json['ActionTargetArn'] as String,
      description: json['Description'] as String,
      name: json['Name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final actionTargetArn = this.actionTargetArn;
    final description = this.description;
    final name = this.name;
    return {
      'ActionTargetArn': actionTargetArn,
      'Description': description,
      'Name': name,
    };
  }
}

/// An adjustment to the CVSS metric.
class Adjustment {
  /// The metric to adjust.
  final String? metric;

  /// The reason for the adjustment.
  final String? reason;

  Adjustment({
    this.metric,
    this.reason,
  });

  factory Adjustment.fromJson(Map<String, dynamic> json) {
    return Adjustment(
      metric: json['Metric'] as String?,
      reason: json['Reason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final metric = this.metric;
    final reason = this.reason;
    return {
      if (metric != null) 'Metric': metric,
      if (reason != null) 'Reason': reason,
    };
  }
}

/// Represents a Security Hub administrator account designated by an
/// organization management account.
class AdminAccount {
  /// The Amazon Web Services account identifier of the Security Hub administrator
  /// account.
  final String? accountId;

  /// The current status of the Security Hub administrator account. Indicates
  /// whether the account is currently enabled as a Security Hub administrator.
  final AdminStatus? status;

  AdminAccount({
    this.accountId,
    this.status,
  });

  factory AdminAccount.fromJson(Map<String, dynamic> json) {
    return AdminAccount(
      accountId: json['AccountId'] as String?,
      status: (json['Status'] as String?)?.toAdminStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final status = this.status;
    return {
      if (accountId != null) 'AccountId': accountId,
      if (status != null) 'Status': status.toValue(),
    };
  }
}

enum AdminStatus {
  enabled,
  disableInProgress,
}

extension AdminStatusValueExtension on AdminStatus {
  String toValue() {
    switch (this) {
      case AdminStatus.enabled:
        return 'ENABLED';
      case AdminStatus.disableInProgress:
        return 'DISABLE_IN_PROGRESS';
    }
  }
}

extension AdminStatusFromString on String {
  AdminStatus toAdminStatus() {
    switch (this) {
      case 'ENABLED':
        return AdminStatus.enabled;
      case 'DISABLE_IN_PROGRESS':
        return AdminStatus.disableInProgress;
    }
    throw Exception('$this is not known in enum AdminStatus');
  }
}

/// Information about an enabled security standard in which a security control
/// is enabled.
class AssociatedStandard {
  /// The unique identifier of a standard in which a control is enabled. This
  /// field consists of the resource portion of the Amazon Resource Name (ARN)
  /// returned for a standard in the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_DescribeStandards.html">DescribeStandards</a>
  /// API response.
  final String? standardsId;

  AssociatedStandard({
    this.standardsId,
  });

  factory AssociatedStandard.fromJson(Map<String, dynamic> json) {
    return AssociatedStandard(
      standardsId: json['StandardsId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final standardsId = this.standardsId;
    return {
      if (standardsId != null) 'StandardsId': standardsId,
    };
  }
}

/// Options for filtering the <code>ListConfigurationPolicyAssociations</code>
/// response. You can filter by the Amazon Resource Name (ARN) or universally
/// unique identifier (UUID) of a configuration policy,
/// <code>AssociationType</code>, or <code>AssociationStatus</code>.
class AssociationFilters {
  /// The current status of the association between a target and a configuration
  /// policy.
  final ConfigurationPolicyAssociationStatus? associationStatus;

  /// Indicates whether the association between a target and a configuration was
  /// directly applied by the Security Hub delegated administrator or inherited
  /// from a parent.
  final AssociationType? associationType;

  /// The ARN or UUID of the configuration policy.
  final String? configurationPolicyId;

  AssociationFilters({
    this.associationStatus,
    this.associationType,
    this.configurationPolicyId,
  });

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final associationType = this.associationType;
    final configurationPolicyId = this.configurationPolicyId;
    return {
      if (associationStatus != null)
        'AssociationStatus': associationStatus.toValue(),
      if (associationType != null) 'AssociationType': associationType.toValue(),
      if (configurationPolicyId != null)
        'ConfigurationPolicyId': configurationPolicyId,
    };
  }
}

/// The associations between a route table and one or more subnets or a gateway.
class AssociationSetDetails {
  /// The state of the association between a route table and a subnet or gateway.
  final AssociationStateDetails? associationState;

  /// The ID of the internet gateway or virtual private gateway.
  final String? gatewayId;

  /// Indicates whether this is the main route table.
  final bool? main;

  /// The ID of the association.
  final String? routeTableAssociationId;

  /// The ID of the route table.
  final String? routeTableId;

  /// The ID of the subnet. A subnet ID is not returned for an implicit
  /// association.
  final String? subnetId;

  AssociationSetDetails({
    this.associationState,
    this.gatewayId,
    this.main,
    this.routeTableAssociationId,
    this.routeTableId,
    this.subnetId,
  });

  factory AssociationSetDetails.fromJson(Map<String, dynamic> json) {
    return AssociationSetDetails(
      associationState: json['AssociationState'] != null
          ? AssociationStateDetails.fromJson(
              json['AssociationState'] as Map<String, dynamic>)
          : null,
      gatewayId: json['GatewayId'] as String?,
      main: json['Main'] as bool?,
      routeTableAssociationId: json['RouteTableAssociationId'] as String?,
      routeTableId: json['RouteTableId'] as String?,
      subnetId: json['SubnetId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationState = this.associationState;
    final gatewayId = this.gatewayId;
    final main = this.main;
    final routeTableAssociationId = this.routeTableAssociationId;
    final routeTableId = this.routeTableId;
    final subnetId = this.subnetId;
    return {
      if (associationState != null) 'AssociationState': associationState,
      if (gatewayId != null) 'GatewayId': gatewayId,
      if (main != null) 'Main': main,
      if (routeTableAssociationId != null)
        'RouteTableAssociationId': routeTableAssociationId,
      if (routeTableId != null) 'RouteTableId': routeTableId,
      if (subnetId != null) 'SubnetId': subnetId,
    };
  }
}

/// Describes the state of an association between a route table and a subnet or
/// gateway.
class AssociationStateDetails {
  /// The state of the association.
  final String? state;

  /// The status message, if applicable.
  final String? statusMessage;

  AssociationStateDetails({
    this.state,
    this.statusMessage,
  });

  factory AssociationStateDetails.fromJson(Map<String, dynamic> json) {
    return AssociationStateDetails(
      state: json['State'] as String?,
      statusMessage: json['StatusMessage'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final state = this.state;
    final statusMessage = this.statusMessage;
    return {
      if (state != null) 'State': state,
      if (statusMessage != null) 'StatusMessage': statusMessage,
    };
  }
}

enum AssociationStatus {
  enabled,
  disabled,
}

extension AssociationStatusValueExtension on AssociationStatus {
  String toValue() {
    switch (this) {
      case AssociationStatus.enabled:
        return 'ENABLED';
      case AssociationStatus.disabled:
        return 'DISABLED';
    }
  }
}

extension AssociationStatusFromString on String {
  AssociationStatus toAssociationStatus() {
    switch (this) {
      case 'ENABLED':
        return AssociationStatus.enabled;
      case 'DISABLED':
        return AssociationStatus.disabled;
    }
    throw Exception('$this is not known in enum AssociationStatus');
  }
}

enum AssociationType {
  inherited,
  applied,
}

extension AssociationTypeValueExtension on AssociationType {
  String toValue() {
    switch (this) {
      case AssociationType.inherited:
        return 'INHERITED';
      case AssociationType.applied:
        return 'APPLIED';
    }
  }
}

extension AssociationTypeFromString on String {
  AssociationType toAssociationType() {
    switch (this) {
      case 'INHERITED':
        return AssociationType.inherited;
      case 'APPLIED':
        return AssociationType.applied;
    }
    throw Exception('$this is not known in enum AssociationType');
  }
}

enum AutoEnableStandards {
  none,
  $default,
}

extension AutoEnableStandardsValueExtension on AutoEnableStandards {
  String toValue() {
    switch (this) {
      case AutoEnableStandards.none:
        return 'NONE';
      case AutoEnableStandards.$default:
        return 'DEFAULT';
    }
  }
}

extension AutoEnableStandardsFromString on String {
  AutoEnableStandards toAutoEnableStandards() {
    switch (this) {
      case 'NONE':
        return AutoEnableStandards.none;
      case 'DEFAULT':
        return AutoEnableStandards.$default;
    }
    throw Exception('$this is not known in enum AutoEnableStandards');
  }
}

/// One or more actions to update finding fields if a finding matches the
/// defined criteria of the rule.
class AutomationRulesAction {
  /// Specifies that the automation rule action is an update to a finding field.
  final AutomationRulesFindingFieldsUpdate? findingFieldsUpdate;

  /// Specifies that the rule action should update the <code>Types</code> finding
  /// field. The <code>Types</code> finding field classifies findings in the
  /// format of namespace/category/classifier. For more information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format-type-taxonomy.html">Types
  /// taxonomy for ASFF</a> in the <i>Security Hub User Guide</i>.
  final AutomationRulesActionType? type;

  AutomationRulesAction({
    this.findingFieldsUpdate,
    this.type,
  });

  factory AutomationRulesAction.fromJson(Map<String, dynamic> json) {
    return AutomationRulesAction(
      findingFieldsUpdate: json['FindingFieldsUpdate'] != null
          ? AutomationRulesFindingFieldsUpdate.fromJson(
              json['FindingFieldsUpdate'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toAutomationRulesActionType(),
    );
  }

  Map<String, dynamic> toJson() {
    final findingFieldsUpdate = this.findingFieldsUpdate;
    final type = this.type;
    return {
      if (findingFieldsUpdate != null)
        'FindingFieldsUpdate': findingFieldsUpdate,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum AutomationRulesActionType {
  findingFieldsUpdate,
}

extension AutomationRulesActionTypeValueExtension on AutomationRulesActionType {
  String toValue() {
    switch (this) {
      case AutomationRulesActionType.findingFieldsUpdate:
        return 'FINDING_FIELDS_UPDATE';
    }
  }
}

extension AutomationRulesActionTypeFromString on String {
  AutomationRulesActionType toAutomationRulesActionType() {
    switch (this) {
      case 'FINDING_FIELDS_UPDATE':
        return AutomationRulesActionType.findingFieldsUpdate;
    }
    throw Exception('$this is not known in enum AutomationRulesActionType');
  }
}

/// Defines the configuration of an automation rule.
class AutomationRulesConfig {
  /// One or more actions to update finding fields if a finding matches the
  /// defined criteria of the rule.
  final List<AutomationRulesAction>? actions;

  /// A timestamp that indicates when the rule was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final DateTime? createdAt;

  /// The principal that created a rule.
  final String? createdBy;

  /// A set of <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html">Amazon
  /// Web Services Security Finding Format</a> finding field attributes and
  /// corresponding expected values that Security Hub uses to filter findings. If
  /// a rule is enabled and a finding matches the conditions specified in this
  /// parameter, Security Hub applies the rule action to the finding.
  final AutomationRulesFindingFilters? criteria;

  /// A description of the rule.
  final String? description;

  /// Specifies whether a rule is the last to be applied with respect to a finding
  /// that matches the rule criteria. This is useful when a finding matches the
  /// criteria for multiple rules, and each rule has different actions. If a rule
  /// is terminal, Security Hub applies the rule action to a finding that matches
  /// the rule criteria and doesn't evaluate other rules for the finding. By
  /// default, a rule isn't terminal.
  final bool? isTerminal;

  /// The Amazon Resource Name (ARN) of a rule.
  final String? ruleArn;

  /// The name of the rule.
  final String? ruleName;

  /// An integer ranging from 1 to 1000 that represents the order in which the
  /// rule action is applied to findings. Security Hub applies rules with lower
  /// values for this parameter first.
  final int? ruleOrder;

  /// Whether the rule is active after it is created. If this parameter is equal
  /// to <code>ENABLED</code>, Security Hub starts applying the rule to findings
  /// and finding updates after the rule is created.
  final RuleStatus? ruleStatus;

  /// A timestamp that indicates when the rule was most recently updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final DateTime? updatedAt;

  AutomationRulesConfig({
    this.actions,
    this.createdAt,
    this.createdBy,
    this.criteria,
    this.description,
    this.isTerminal,
    this.ruleArn,
    this.ruleName,
    this.ruleOrder,
    this.ruleStatus,
    this.updatedAt,
  });

  factory AutomationRulesConfig.fromJson(Map<String, dynamic> json) {
    return AutomationRulesConfig(
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => AutomationRulesAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: timeStampFromJson(json['CreatedAt']),
      createdBy: json['CreatedBy'] as String?,
      criteria: json['Criteria'] != null
          ? AutomationRulesFindingFilters.fromJson(
              json['Criteria'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      isTerminal: json['IsTerminal'] as bool?,
      ruleArn: json['RuleArn'] as String?,
      ruleName: json['RuleName'] as String?,
      ruleOrder: json['RuleOrder'] as int?,
      ruleStatus: (json['RuleStatus'] as String?)?.toRuleStatus(),
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final createdAt = this.createdAt;
    final createdBy = this.createdBy;
    final criteria = this.criteria;
    final description = this.description;
    final isTerminal = this.isTerminal;
    final ruleArn = this.ruleArn;
    final ruleName = this.ruleName;
    final ruleOrder = this.ruleOrder;
    final ruleStatus = this.ruleStatus;
    final updatedAt = this.updatedAt;
    return {
      if (actions != null) 'Actions': actions,
      if (createdAt != null) 'CreatedAt': iso8601ToJson(createdAt),
      if (createdBy != null) 'CreatedBy': createdBy,
      if (criteria != null) 'Criteria': criteria,
      if (description != null) 'Description': description,
      if (isTerminal != null) 'IsTerminal': isTerminal,
      if (ruleArn != null) 'RuleArn': ruleArn,
      if (ruleName != null) 'RuleName': ruleName,
      if (ruleOrder != null) 'RuleOrder': ruleOrder,
      if (ruleStatus != null) 'RuleStatus': ruleStatus.toValue(),
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

/// Identifies the finding fields that the automation rule action updates when a
/// finding matches the defined criteria.
class AutomationRulesFindingFieldsUpdate {
  /// The rule action updates the <code>Confidence</code> field of a finding.
  final int? confidence;

  /// The rule action updates the <code>Criticality</code> field of a finding.
  final int? criticality;
  final NoteUpdate? note;

  /// The rule action updates the <code>RelatedFindings</code> field of a finding.
  final List<RelatedFinding>? relatedFindings;
  final SeverityUpdate? severity;

  /// The rule action updates the <code>Types</code> field of a finding.
  final List<String>? types;

  /// The rule action updates the <code>UserDefinedFields</code> field of a
  /// finding.
  final Map<String, String>? userDefinedFields;

  /// The rule action updates the <code>VerificationState</code> field of a
  /// finding.
  final VerificationState? verificationState;
  final WorkflowUpdate? workflow;

  AutomationRulesFindingFieldsUpdate({
    this.confidence,
    this.criticality,
    this.note,
    this.relatedFindings,
    this.severity,
    this.types,
    this.userDefinedFields,
    this.verificationState,
    this.workflow,
  });

  factory AutomationRulesFindingFieldsUpdate.fromJson(
      Map<String, dynamic> json) {
    return AutomationRulesFindingFieldsUpdate(
      confidence: json['Confidence'] as int?,
      criticality: json['Criticality'] as int?,
      note: json['Note'] != null
          ? NoteUpdate.fromJson(json['Note'] as Map<String, dynamic>)
          : null,
      relatedFindings: (json['RelatedFindings'] as List?)
          ?.whereNotNull()
          .map((e) => RelatedFinding.fromJson(e as Map<String, dynamic>))
          .toList(),
      severity: json['Severity'] != null
          ? SeverityUpdate.fromJson(json['Severity'] as Map<String, dynamic>)
          : null,
      types: (json['Types'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      userDefinedFields: (json['UserDefinedFields'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      verificationState:
          (json['VerificationState'] as String?)?.toVerificationState(),
      workflow: json['Workflow'] != null
          ? WorkflowUpdate.fromJson(json['Workflow'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final confidence = this.confidence;
    final criticality = this.criticality;
    final note = this.note;
    final relatedFindings = this.relatedFindings;
    final severity = this.severity;
    final types = this.types;
    final userDefinedFields = this.userDefinedFields;
    final verificationState = this.verificationState;
    final workflow = this.workflow;
    return {
      if (confidence != null) 'Confidence': confidence,
      if (criticality != null) 'Criticality': criticality,
      if (note != null) 'Note': note,
      if (relatedFindings != null) 'RelatedFindings': relatedFindings,
      if (severity != null) 'Severity': severity,
      if (types != null) 'Types': types,
      if (userDefinedFields != null) 'UserDefinedFields': userDefinedFields,
      if (verificationState != null)
        'VerificationState': verificationState.toValue(),
      if (workflow != null) 'Workflow': workflow,
    };
  }
}

/// The criteria that determine which findings a rule applies to.
class AutomationRulesFindingFilters {
  /// The Amazon Web Services account ID in which a finding was generated.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 100 items.
  final List<StringFilter>? awsAccountId;

  /// The name of the Amazon Web Services account in which a finding was
  /// generated.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? awsAccountName;

  /// The name of the company for the product that generated the finding. For
  /// control-based findings, the company is Amazon Web Services.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? companyName;

  /// The unique identifier of a standard in which a control is enabled. This
  /// field consists of the resource portion of the Amazon Resource Name (ARN)
  /// returned for a standard in the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_DescribeStandards.html">DescribeStandards</a>
  /// API response.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? complianceAssociatedStandardsId;

  /// The security control ID for which a finding was generated. Security control
  /// IDs are the same across standards.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? complianceSecurityControlId;

  /// The result of a security check. This field is only used for findings
  /// generated from controls.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? complianceStatus;

  /// The likelihood that a finding accurately identifies the behavior or issue
  /// that it was intended to identify. <code>Confidence</code> is scored on a
  /// 0–100 basis using a ratio scale. A value of <code>0</code> means 0 percent
  /// confidence, and a value of <code>100</code> means 100 percent confidence.
  /// For example, a data exfiltration detection based on a statistical deviation
  /// of network traffic has low confidence because an actual exfiltration hasn't
  /// been verified. For more information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/asff-top-level-attributes.html#asff-confidence">Confidence</a>
  /// in the <i>Security Hub User Guide</i>.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<NumberFilter>? confidence;

  /// A timestamp that indicates when this finding record was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<DateFilter>? createdAt;

  /// The level of importance that is assigned to the resources that are
  /// associated with a finding. <code>Criticality</code> is scored on a 0–100
  /// basis, using a ratio scale that supports only full integers. A score of
  /// <code>0</code> means that the underlying resources have no criticality, and
  /// a score of <code>100</code> is reserved for the most critical resources. For
  /// more information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/asff-top-level-attributes.html#asff-criticality">Criticality</a>
  /// in the <i>Security Hub User Guide</i>.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<NumberFilter>? criticality;

  /// A finding's description.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? description;

  /// A timestamp that indicates when the potential security issue captured by a
  /// finding was first observed by the security findings product.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<DateFilter>? firstObservedAt;

  /// The identifier for the solution-specific component that generated a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 100 items.
  final List<StringFilter>? generatorId;

  /// The product-specific identifier for a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? id;

  /// A timestamp that indicates when the potential security issue captured by a
  /// finding was most recently observed by the security findings product.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<DateFilter>? lastObservedAt;

  /// The text of a user-defined note that's added to a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? noteText;

  /// The timestamp of when the note was updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<DateFilter>? noteUpdatedAt;

  /// The principal that created a note.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? noteUpdatedBy;

  /// The Amazon Resource Name (ARN) for a third-party product that generated a
  /// finding in Security Hub.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? productArn;

  /// Provides the name of the product that generated the finding. For
  /// control-based findings, the product name is Security Hub.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? productName;

  /// Provides the current state of a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? recordState;

  /// The product-generated identifier for a related finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? relatedFindingsId;

  /// The ARN for the product that generated a related finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? relatedFindingsProductArn;

  /// The Amazon Resource Name (ARN) of the application that is related to a
  /// finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? resourceApplicationArn;

  /// The name of the application that is related to a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? resourceApplicationName;

  /// Custom fields and values about the resource that a finding pertains to.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<MapFilter>? resourceDetailsOther;

  /// The identifier for the given resource type. For Amazon Web Services
  /// resources that are identified by Amazon Resource Names (ARNs), this is the
  /// ARN. For Amazon Web Services resources that lack ARNs, this is the
  /// identifier as defined by the Amazon Web Service that created the resource.
  /// For non-Amazon Web Services resources, this is a unique identifier that is
  /// associated with the resource.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 100 items.
  final List<StringFilter>? resourceId;

  /// The partition in which the resource that the finding pertains to is located.
  /// A partition is a group of Amazon Web Services Regions. Each Amazon Web
  /// Services account is scoped to one partition.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? resourcePartition;

  /// The Amazon Web Services Region where the resource that a finding pertains to
  /// is located.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? resourceRegion;

  /// A list of Amazon Web Services tags associated with a resource at the time
  /// the finding was processed.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<MapFilter>? resourceTags;

  /// The type of resource that the finding pertains to.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? resourceType;

  /// The severity value of the finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? severityLabel;

  /// Provides a URL that links to a page about the current finding in the finding
  /// product.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? sourceUrl;

  /// A finding's title.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 100 items.
  final List<StringFilter>? title;

  /// One or more finding types in the format of namespace/category/classifier
  /// that classify a finding. For a list of namespaces, classifiers, and
  /// categories, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format-type-taxonomy.html">Types
  /// taxonomy for ASFF</a> in the <i>Security Hub User Guide</i>.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? type;

  /// A timestamp that indicates when the finding record was most recently
  /// updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<DateFilter>? updatedAt;

  /// A list of user-defined name and value string pairs added to a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<MapFilter>? userDefinedFields;

  /// Provides the veracity of a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? verificationState;

  /// Provides information about the status of the investigation into a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 20 items.
  final List<StringFilter>? workflowStatus;

  AutomationRulesFindingFilters({
    this.awsAccountId,
    this.awsAccountName,
    this.companyName,
    this.complianceAssociatedStandardsId,
    this.complianceSecurityControlId,
    this.complianceStatus,
    this.confidence,
    this.createdAt,
    this.criticality,
    this.description,
    this.firstObservedAt,
    this.generatorId,
    this.id,
    this.lastObservedAt,
    this.noteText,
    this.noteUpdatedAt,
    this.noteUpdatedBy,
    this.productArn,
    this.productName,
    this.recordState,
    this.relatedFindingsId,
    this.relatedFindingsProductArn,
    this.resourceApplicationArn,
    this.resourceApplicationName,
    this.resourceDetailsOther,
    this.resourceId,
    this.resourcePartition,
    this.resourceRegion,
    this.resourceTags,
    this.resourceType,
    this.severityLabel,
    this.sourceUrl,
    this.title,
    this.type,
    this.updatedAt,
    this.userDefinedFields,
    this.verificationState,
    this.workflowStatus,
  });

  factory AutomationRulesFindingFilters.fromJson(Map<String, dynamic> json) {
    return AutomationRulesFindingFilters(
      awsAccountId: (json['AwsAccountId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      awsAccountName: (json['AwsAccountName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      companyName: (json['CompanyName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      complianceAssociatedStandardsId:
          (json['ComplianceAssociatedStandardsId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      complianceSecurityControlId:
          (json['ComplianceSecurityControlId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      complianceStatus: (json['ComplianceStatus'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      confidence: (json['Confidence'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: (json['CreatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      criticality: (json['Criticality'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      description: (json['Description'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      firstObservedAt: (json['FirstObservedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      generatorId: (json['GeneratorId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      id: (json['Id'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      lastObservedAt: (json['LastObservedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      noteText: (json['NoteText'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      noteUpdatedAt: (json['NoteUpdatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      noteUpdatedBy: (json['NoteUpdatedBy'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      productArn: (json['ProductArn'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      productName: (json['ProductName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      recordState: (json['RecordState'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      relatedFindingsId: (json['RelatedFindingsId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      relatedFindingsProductArn: (json['RelatedFindingsProductArn'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceApplicationArn: (json['ResourceApplicationArn'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceApplicationName: (json['ResourceApplicationName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceDetailsOther: (json['ResourceDetailsOther'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceId: (json['ResourceId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourcePartition: (json['ResourcePartition'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceRegion: (json['ResourceRegion'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceTags: (json['ResourceTags'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceType: (json['ResourceType'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      severityLabel: (json['SeverityLabel'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      sourceUrl: (json['SourceUrl'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      title: (json['Title'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      type: (json['Type'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      updatedAt: (json['UpdatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      userDefinedFields: (json['UserDefinedFields'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      verificationState: (json['VerificationState'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      workflowStatus: (json['WorkflowStatus'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final awsAccountName = this.awsAccountName;
    final companyName = this.companyName;
    final complianceAssociatedStandardsId =
        this.complianceAssociatedStandardsId;
    final complianceSecurityControlId = this.complianceSecurityControlId;
    final complianceStatus = this.complianceStatus;
    final confidence = this.confidence;
    final createdAt = this.createdAt;
    final criticality = this.criticality;
    final description = this.description;
    final firstObservedAt = this.firstObservedAt;
    final generatorId = this.generatorId;
    final id = this.id;
    final lastObservedAt = this.lastObservedAt;
    final noteText = this.noteText;
    final noteUpdatedAt = this.noteUpdatedAt;
    final noteUpdatedBy = this.noteUpdatedBy;
    final productArn = this.productArn;
    final productName = this.productName;
    final recordState = this.recordState;
    final relatedFindingsId = this.relatedFindingsId;
    final relatedFindingsProductArn = this.relatedFindingsProductArn;
    final resourceApplicationArn = this.resourceApplicationArn;
    final resourceApplicationName = this.resourceApplicationName;
    final resourceDetailsOther = this.resourceDetailsOther;
    final resourceId = this.resourceId;
    final resourcePartition = this.resourcePartition;
    final resourceRegion = this.resourceRegion;
    final resourceTags = this.resourceTags;
    final resourceType = this.resourceType;
    final severityLabel = this.severityLabel;
    final sourceUrl = this.sourceUrl;
    final title = this.title;
    final type = this.type;
    final updatedAt = this.updatedAt;
    final userDefinedFields = this.userDefinedFields;
    final verificationState = this.verificationState;
    final workflowStatus = this.workflowStatus;
    return {
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (awsAccountName != null) 'AwsAccountName': awsAccountName,
      if (companyName != null) 'CompanyName': companyName,
      if (complianceAssociatedStandardsId != null)
        'ComplianceAssociatedStandardsId': complianceAssociatedStandardsId,
      if (complianceSecurityControlId != null)
        'ComplianceSecurityControlId': complianceSecurityControlId,
      if (complianceStatus != null) 'ComplianceStatus': complianceStatus,
      if (confidence != null) 'Confidence': confidence,
      if (createdAt != null) 'CreatedAt': createdAt,
      if (criticality != null) 'Criticality': criticality,
      if (description != null) 'Description': description,
      if (firstObservedAt != null) 'FirstObservedAt': firstObservedAt,
      if (generatorId != null) 'GeneratorId': generatorId,
      if (id != null) 'Id': id,
      if (lastObservedAt != null) 'LastObservedAt': lastObservedAt,
      if (noteText != null) 'NoteText': noteText,
      if (noteUpdatedAt != null) 'NoteUpdatedAt': noteUpdatedAt,
      if (noteUpdatedBy != null) 'NoteUpdatedBy': noteUpdatedBy,
      if (productArn != null) 'ProductArn': productArn,
      if (productName != null) 'ProductName': productName,
      if (recordState != null) 'RecordState': recordState,
      if (relatedFindingsId != null) 'RelatedFindingsId': relatedFindingsId,
      if (relatedFindingsProductArn != null)
        'RelatedFindingsProductArn': relatedFindingsProductArn,
      if (resourceApplicationArn != null)
        'ResourceApplicationArn': resourceApplicationArn,
      if (resourceApplicationName != null)
        'ResourceApplicationName': resourceApplicationName,
      if (resourceDetailsOther != null)
        'ResourceDetailsOther': resourceDetailsOther,
      if (resourceId != null) 'ResourceId': resourceId,
      if (resourcePartition != null) 'ResourcePartition': resourcePartition,
      if (resourceRegion != null) 'ResourceRegion': resourceRegion,
      if (resourceTags != null) 'ResourceTags': resourceTags,
      if (resourceType != null) 'ResourceType': resourceType,
      if (severityLabel != null) 'SeverityLabel': severityLabel,
      if (sourceUrl != null) 'SourceUrl': sourceUrl,
      if (title != null) 'Title': title,
      if (type != null) 'Type': type,
      if (updatedAt != null) 'UpdatedAt': updatedAt,
      if (userDefinedFields != null) 'UserDefinedFields': userDefinedFields,
      if (verificationState != null) 'VerificationState': verificationState,
      if (workflowStatus != null) 'WorkflowStatus': workflowStatus,
    };
  }
}

/// Metadata for automation rules in the calling account. The response includes
/// rules with a <code>RuleStatus</code> of <code>ENABLED</code> and
/// <code>DISABLED</code>.
class AutomationRulesMetadata {
  /// A timestamp that indicates when the rule was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final DateTime? createdAt;

  /// The principal that created a rule.
  final String? createdBy;

  /// A description of the rule.
  final String? description;

  /// Specifies whether a rule is the last to be applied with respect to a finding
  /// that matches the rule criteria. This is useful when a finding matches the
  /// criteria for multiple rules, and each rule has different actions. If a rule
  /// is terminal, Security Hub applies the rule action to a finding that matches
  /// the rule criteria and doesn't evaluate other rules for the finding. By
  /// default, a rule isn't terminal.
  final bool? isTerminal;

  /// The Amazon Resource Name (ARN) for the rule.
  final String? ruleArn;

  /// The name of the rule.
  final String? ruleName;

  /// An integer ranging from 1 to 1000 that represents the order in which the
  /// rule action is applied to findings. Security Hub applies rules with lower
  /// values for this parameter first.
  final int? ruleOrder;

  /// Whether the rule is active after it is created. If this parameter is equal
  /// to <code>ENABLED</code>, Security Hub starts applying the rule to findings
  /// and finding updates after the rule is created. To change the value of this
  /// parameter after creating a rule, use <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateAutomationRules.html">
  /// <code>BatchUpdateAutomationRules</code> </a>.
  final RuleStatus? ruleStatus;

  /// A timestamp that indicates when the rule was most recently updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final DateTime? updatedAt;

  AutomationRulesMetadata({
    this.createdAt,
    this.createdBy,
    this.description,
    this.isTerminal,
    this.ruleArn,
    this.ruleName,
    this.ruleOrder,
    this.ruleStatus,
    this.updatedAt,
  });

  factory AutomationRulesMetadata.fromJson(Map<String, dynamic> json) {
    return AutomationRulesMetadata(
      createdAt: timeStampFromJson(json['CreatedAt']),
      createdBy: json['CreatedBy'] as String?,
      description: json['Description'] as String?,
      isTerminal: json['IsTerminal'] as bool?,
      ruleArn: json['RuleArn'] as String?,
      ruleName: json['RuleName'] as String?,
      ruleOrder: json['RuleOrder'] as int?,
      ruleStatus: (json['RuleStatus'] as String?)?.toRuleStatus(),
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final createdAt = this.createdAt;
    final createdBy = this.createdBy;
    final description = this.description;
    final isTerminal = this.isTerminal;
    final ruleArn = this.ruleArn;
    final ruleName = this.ruleName;
    final ruleOrder = this.ruleOrder;
    final ruleStatus = this.ruleStatus;
    final updatedAt = this.updatedAt;
    return {
      if (createdAt != null) 'CreatedAt': iso8601ToJson(createdAt),
      if (createdBy != null) 'CreatedBy': createdBy,
      if (description != null) 'Description': description,
      if (isTerminal != null) 'IsTerminal': isTerminal,
      if (ruleArn != null) 'RuleArn': ruleArn,
      if (ruleName != null) 'RuleName': ruleName,
      if (ruleOrder != null) 'RuleOrder': ruleOrder,
      if (ruleStatus != null) 'RuleStatus': ruleStatus.toValue(),
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

/// Information about an Availability Zone.
class AvailabilityZone {
  /// The ID of the subnet. You can specify one subnet per Availability Zone.
  final String? subnetId;

  /// The name of the Availability Zone.
  final String? zoneName;

  AvailabilityZone({
    this.subnetId,
    this.zoneName,
  });

  factory AvailabilityZone.fromJson(Map<String, dynamic> json) {
    return AvailabilityZone(
      subnetId: json['SubnetId'] as String?,
      zoneName: json['ZoneName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final subnetId = this.subnetId;
    final zoneName = this.zoneName;
    return {
      if (subnetId != null) 'SubnetId': subnetId,
      if (zoneName != null) 'ZoneName': zoneName,
    };
  }
}

/// Provides details about an Amazon MQ message broker. A message broker allows
/// software applications and components to communicate using various
/// programming languages, operating systems, and formal messaging protocols.
class AwsAmazonMqBrokerDetails {
  /// The authentication strategy used to secure the broker. The default is
  /// <code>SIMPLE</code>.
  final String? authenticationStrategy;

  /// Whether automatically upgrade new minor versions for brokers, as new
  /// versions are released and supported by Amazon MQ. Automatic upgrades occur
  /// during the scheduled maintenance window of the broker or after a manual
  /// broker reboot.
  final bool? autoMinorVersionUpgrade;

  /// The Amazon Resource Name (ARN) of the broker.
  final String? brokerArn;

  /// The unique ID that Amazon MQ generates for the broker.
  final String? brokerId;

  /// The broker's name.
  final String? brokerName;

  /// The broker's deployment mode.
  final String? deploymentMode;

  /// Encryption options for the broker. Doesn’t apply to RabbitMQ brokers.
  final AwsAmazonMqBrokerEncryptionOptionsDetails? encryptionOptions;

  /// The type of broker engine.
  final String? engineType;

  /// The version of the broker engine.
  final String? engineVersion;

  /// The broker's instance type.
  final String? hostInstanceType;

  /// The metadata of the Lightweight Directory Access Protocol (LDAP) server used
  /// to authenticate and authorize connections to the broker. This is an optional
  /// failover server.
  final AwsAmazonMqBrokerLdapServerMetadataDetails? ldapServerMetadata;

  /// Turns on Amazon CloudWatch logging for brokers.
  final AwsAmazonMqBrokerLogsDetails? logs;

  /// The scheduled time period (UTC) during which Amazon MQ begins to apply
  /// pending updates or patches to the broker.
  final AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails?
      maintenanceWindowStartTime;

  /// Permits connections from applications outside of the VPC that hosts the
  /// broker's subnets.
  final bool? publiclyAccessible;

  /// The list of rules (one minimum, 125 maximum) that authorize connections to
  /// brokers.
  final List<String>? securityGroups;

  /// The broker's storage type.
  final String? storageType;

  /// The list of groups that define which subnets and IP ranges the broker can
  /// use from different Availability Zones.
  final List<String>? subnetIds;

  /// The list of all broker usernames for the specified broker. Doesn't apply to
  /// RabbitMQ brokers.
  final List<AwsAmazonMqBrokerUsersDetails>? users;

  AwsAmazonMqBrokerDetails({
    this.authenticationStrategy,
    this.autoMinorVersionUpgrade,
    this.brokerArn,
    this.brokerId,
    this.brokerName,
    this.deploymentMode,
    this.encryptionOptions,
    this.engineType,
    this.engineVersion,
    this.hostInstanceType,
    this.ldapServerMetadata,
    this.logs,
    this.maintenanceWindowStartTime,
    this.publiclyAccessible,
    this.securityGroups,
    this.storageType,
    this.subnetIds,
    this.users,
  });

  factory AwsAmazonMqBrokerDetails.fromJson(Map<String, dynamic> json) {
    return AwsAmazonMqBrokerDetails(
      authenticationStrategy: json['AuthenticationStrategy'] as String?,
      autoMinorVersionUpgrade: json['AutoMinorVersionUpgrade'] as bool?,
      brokerArn: json['BrokerArn'] as String?,
      brokerId: json['BrokerId'] as String?,
      brokerName: json['BrokerName'] as String?,
      deploymentMode: json['DeploymentMode'] as String?,
      encryptionOptions: json['EncryptionOptions'] != null
          ? AwsAmazonMqBrokerEncryptionOptionsDetails.fromJson(
              json['EncryptionOptions'] as Map<String, dynamic>)
          : null,
      engineType: json['EngineType'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      hostInstanceType: json['HostInstanceType'] as String?,
      ldapServerMetadata: json['LdapServerMetadata'] != null
          ? AwsAmazonMqBrokerLdapServerMetadataDetails.fromJson(
              json['LdapServerMetadata'] as Map<String, dynamic>)
          : null,
      logs: json['Logs'] != null
          ? AwsAmazonMqBrokerLogsDetails.fromJson(
              json['Logs'] as Map<String, dynamic>)
          : null,
      maintenanceWindowStartTime: json['MaintenanceWindowStartTime'] != null
          ? AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails.fromJson(
              json['MaintenanceWindowStartTime'] as Map<String, dynamic>)
          : null,
      publiclyAccessible: json['PubliclyAccessible'] as bool?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      storageType: json['StorageType'] as String?,
      subnetIds: (json['SubnetIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      users: (json['Users'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsAmazonMqBrokerUsersDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final authenticationStrategy = this.authenticationStrategy;
    final autoMinorVersionUpgrade = this.autoMinorVersionUpgrade;
    final brokerArn = this.brokerArn;
    final brokerId = this.brokerId;
    final brokerName = this.brokerName;
    final deploymentMode = this.deploymentMode;
    final encryptionOptions = this.encryptionOptions;
    final engineType = this.engineType;
    final engineVersion = this.engineVersion;
    final hostInstanceType = this.hostInstanceType;
    final ldapServerMetadata = this.ldapServerMetadata;
    final logs = this.logs;
    final maintenanceWindowStartTime = this.maintenanceWindowStartTime;
    final publiclyAccessible = this.publiclyAccessible;
    final securityGroups = this.securityGroups;
    final storageType = this.storageType;
    final subnetIds = this.subnetIds;
    final users = this.users;
    return {
      if (authenticationStrategy != null)
        'AuthenticationStrategy': authenticationStrategy,
      if (autoMinorVersionUpgrade != null)
        'AutoMinorVersionUpgrade': autoMinorVersionUpgrade,
      if (brokerArn != null) 'BrokerArn': brokerArn,
      if (brokerId != null) 'BrokerId': brokerId,
      if (brokerName != null) 'BrokerName': brokerName,
      if (deploymentMode != null) 'DeploymentMode': deploymentMode,
      if (encryptionOptions != null) 'EncryptionOptions': encryptionOptions,
      if (engineType != null) 'EngineType': engineType,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (hostInstanceType != null) 'HostInstanceType': hostInstanceType,
      if (ldapServerMetadata != null) 'LdapServerMetadata': ldapServerMetadata,
      if (logs != null) 'Logs': logs,
      if (maintenanceWindowStartTime != null)
        'MaintenanceWindowStartTime': maintenanceWindowStartTime,
      if (publiclyAccessible != null) 'PubliclyAccessible': publiclyAccessible,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (storageType != null) 'StorageType': storageType,
      if (subnetIds != null) 'SubnetIds': subnetIds,
      if (users != null) 'Users': users,
    };
  }
}

/// Provides details about broker encryption options.
class AwsAmazonMqBrokerEncryptionOptionsDetails {
  /// The KMS key that’s used to encrypt your data at rest. If not provided,
  /// Amazon MQ will use a default KMS key to encrypt your data.
  final String? kmsKeyId;

  /// Specifies that an KMS key should be used for at-rest encryption. Set to
  /// <code>true</code> by default if no value is provided (for example, for
  /// RabbitMQ brokers).
  final bool? useAwsOwnedKey;

  AwsAmazonMqBrokerEncryptionOptionsDetails({
    this.kmsKeyId,
    this.useAwsOwnedKey,
  });

  factory AwsAmazonMqBrokerEncryptionOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAmazonMqBrokerEncryptionOptionsDetails(
      kmsKeyId: json['KmsKeyId'] as String?,
      useAwsOwnedKey: json['UseAwsOwnedKey'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final kmsKeyId = this.kmsKeyId;
    final useAwsOwnedKey = this.useAwsOwnedKey;
    return {
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (useAwsOwnedKey != null) 'UseAwsOwnedKey': useAwsOwnedKey,
    };
  }
}

/// The metadata of the Lightweight Directory Access Protocol (LDAP) server used
/// to authenticate and authorize connections to the broker. This is an optional
/// failover server.
class AwsAmazonMqBrokerLdapServerMetadataDetails {
  /// Specifies the location of the LDAP server, such as Amazon Web Services
  /// Directory Service for Microsoft Active Directory.
  final List<String>? hosts;

  /// The distinguished name of the node in the directory information tree (DIT)
  /// to search for roles or groups.
  final String? roleBase;

  /// The group name attribute in a role entry whose value is the name of that
  /// role.
  final String? roleName;

  /// The LDAP search filter used to find roles within the <code>roleBase</code>.
  final String? roleSearchMatching;

  /// The directory search scope for the role. If set to <code>true</code>, the
  /// scope is to search the entire subtree.
  final bool? roleSearchSubtree;

  /// A username for the service account, which is an account in your LDAP server
  /// that has access to initiate a connection.
  final String? serviceAccountUsername;

  /// Selects a particular subtree of the directory information tree (DIT) to
  /// search for user entries.
  final String? userBase;

  /// The name of the LDAP attribute in the user's directory entry for the user's
  /// group membership.
  final String? userRoleName;

  /// The LDAP search filter used to find users within the <code>userBase</code>.
  final String? userSearchMatching;

  /// The directory search scope for the user. If set to true, the scope is to
  /// search the entire subtree.
  final bool? userSearchSubtree;

  AwsAmazonMqBrokerLdapServerMetadataDetails({
    this.hosts,
    this.roleBase,
    this.roleName,
    this.roleSearchMatching,
    this.roleSearchSubtree,
    this.serviceAccountUsername,
    this.userBase,
    this.userRoleName,
    this.userSearchMatching,
    this.userSearchSubtree,
  });

  factory AwsAmazonMqBrokerLdapServerMetadataDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAmazonMqBrokerLdapServerMetadataDetails(
      hosts: (json['Hosts'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      roleBase: json['RoleBase'] as String?,
      roleName: json['RoleName'] as String?,
      roleSearchMatching: json['RoleSearchMatching'] as String?,
      roleSearchSubtree: json['RoleSearchSubtree'] as bool?,
      serviceAccountUsername: json['ServiceAccountUsername'] as String?,
      userBase: json['UserBase'] as String?,
      userRoleName: json['UserRoleName'] as String?,
      userSearchMatching: json['UserSearchMatching'] as String?,
      userSearchSubtree: json['UserSearchSubtree'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final hosts = this.hosts;
    final roleBase = this.roleBase;
    final roleName = this.roleName;
    final roleSearchMatching = this.roleSearchMatching;
    final roleSearchSubtree = this.roleSearchSubtree;
    final serviceAccountUsername = this.serviceAccountUsername;
    final userBase = this.userBase;
    final userRoleName = this.userRoleName;
    final userSearchMatching = this.userSearchMatching;
    final userSearchSubtree = this.userSearchSubtree;
    return {
      if (hosts != null) 'Hosts': hosts,
      if (roleBase != null) 'RoleBase': roleBase,
      if (roleName != null) 'RoleName': roleName,
      if (roleSearchMatching != null) 'RoleSearchMatching': roleSearchMatching,
      if (roleSearchSubtree != null) 'RoleSearchSubtree': roleSearchSubtree,
      if (serviceAccountUsername != null)
        'ServiceAccountUsername': serviceAccountUsername,
      if (userBase != null) 'UserBase': userBase,
      if (userRoleName != null) 'UserRoleName': userRoleName,
      if (userSearchMatching != null) 'UserSearchMatching': userSearchMatching,
      if (userSearchSubtree != null) 'UserSearchSubtree': userSearchSubtree,
    };
  }
}

/// Provides information about logs to be activated for the specified broker.
class AwsAmazonMqBrokerLogsDetails {
  /// Activates audit logging. Every user management action made using JMX or the
  /// ActiveMQ Web Console is logged. Doesn't apply to RabbitMQ brokers.
  final bool? audit;

  /// The location of the CloudWatch Logs log group where audit logs are sent.
  final String? auditLogGroup;

  /// Activates general logging.
  final bool? general;

  /// The location of the CloudWatch Logs log group where general logs are sent.
  final String? generalLogGroup;

  /// The list of information about logs that are to be turned on for the
  /// specified broker.
  final AwsAmazonMqBrokerLogsPendingDetails? pending;

  AwsAmazonMqBrokerLogsDetails({
    this.audit,
    this.auditLogGroup,
    this.general,
    this.generalLogGroup,
    this.pending,
  });

  factory AwsAmazonMqBrokerLogsDetails.fromJson(Map<String, dynamic> json) {
    return AwsAmazonMqBrokerLogsDetails(
      audit: json['Audit'] as bool?,
      auditLogGroup: json['AuditLogGroup'] as String?,
      general: json['General'] as bool?,
      generalLogGroup: json['GeneralLogGroup'] as String?,
      pending: json['Pending'] != null
          ? AwsAmazonMqBrokerLogsPendingDetails.fromJson(
              json['Pending'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final audit = this.audit;
    final auditLogGroup = this.auditLogGroup;
    final general = this.general;
    final generalLogGroup = this.generalLogGroup;
    final pending = this.pending;
    return {
      if (audit != null) 'Audit': audit,
      if (auditLogGroup != null) 'AuditLogGroup': auditLogGroup,
      if (general != null) 'General': general,
      if (generalLogGroup != null) 'GeneralLogGroup': generalLogGroup,
      if (pending != null) 'Pending': pending,
    };
  }
}

/// Provides information about logs to be activated for the specified broker.
class AwsAmazonMqBrokerLogsPendingDetails {
  /// Activates audit logging. Every user management action made using JMX or the
  /// ActiveMQ Web Console is logged. Doesn't apply to RabbitMQ brokers.
  final bool? audit;

  /// Activates general logging.
  final bool? general;

  AwsAmazonMqBrokerLogsPendingDetails({
    this.audit,
    this.general,
  });

  factory AwsAmazonMqBrokerLogsPendingDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAmazonMqBrokerLogsPendingDetails(
      audit: json['Audit'] as bool?,
      general: json['General'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final audit = this.audit;
    final general = this.general;
    return {
      if (audit != null) 'Audit': audit,
      if (general != null) 'General': general,
    };
  }
}

/// The scheduled time period (UTC) during which Amazon MQ begins to apply
/// pending updates or patches to the broker.
class AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails {
  /// The day of the week on which the maintenance window falls.
  final String? dayOfWeek;

  /// The time, in 24-hour format, on which the maintenance window falls.
  final String? timeOfDay;

  /// The time zone in either the Country/City format or the UTC offset format.
  /// UTC is the default format.
  final String? timeZone;

  AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails({
    this.dayOfWeek,
    this.timeOfDay,
    this.timeZone,
  });

  factory AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAmazonMqBrokerMaintenanceWindowStartTimeDetails(
      dayOfWeek: json['DayOfWeek'] as String?,
      timeOfDay: json['TimeOfDay'] as String?,
      timeZone: json['TimeZone'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dayOfWeek = this.dayOfWeek;
    final timeOfDay = this.timeOfDay;
    final timeZone = this.timeZone;
    return {
      if (dayOfWeek != null) 'DayOfWeek': dayOfWeek,
      if (timeOfDay != null) 'TimeOfDay': timeOfDay,
      if (timeZone != null) 'TimeZone': timeZone,
    };
  }
}

/// Provides details about the broker usernames for the specified broker.
/// Doesn't apply to RabbitMQ brokers.
class AwsAmazonMqBrokerUsersDetails {
  /// The type of change pending for the broker user.
  final String? pendingChange;

  /// The username of the broker user.
  final String? username;

  AwsAmazonMqBrokerUsersDetails({
    this.pendingChange,
    this.username,
  });

  factory AwsAmazonMqBrokerUsersDetails.fromJson(Map<String, dynamic> json) {
    return AwsAmazonMqBrokerUsersDetails(
      pendingChange: json['PendingChange'] as String?,
      username: json['Username'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final pendingChange = this.pendingChange;
    final username = this.username;
    return {
      if (pendingChange != null) 'PendingChange': pendingChange,
      if (username != null) 'Username': username,
    };
  }
}

/// Provided if <code>ActionType</code> is <code>AWS_API_CALL</code>. It
/// provides details about the API call that was detected.
class AwsApiCallAction {
  /// Identifies the resources that were affected by the API call.
  final Map<String, String>? affectedResources;

  /// The name of the API method that was issued.
  ///
  /// Length Constraints: 128.
  final String? api;

  /// Indicates whether the API call originated from a remote IP address
  /// (<code>remoteip</code>) or from a DNS domain (<code>domain</code>).
  final String? callerType;

  /// Provided if <code>CallerType</code> is <code>domain</code>. Provides
  /// information about the DNS domain that the API call originated from.
  final AwsApiCallActionDomainDetails? domainDetails;

  /// A timestamp that indicates when the API call was first observed.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? firstSeen;

  /// A timestamp that indicates when the API call was most recently observed.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastSeen;

  /// Provided if <code>CallerType</code> is <code>remoteIp</code>. Provides
  /// information about the remote IP address that the API call originated from.
  final ActionRemoteIpDetails? remoteIpDetails;

  /// The name of the Amazon Web Services service that the API method belongs to.
  ///
  /// Length Constraints: 128.
  final String? serviceName;

  AwsApiCallAction({
    this.affectedResources,
    this.api,
    this.callerType,
    this.domainDetails,
    this.firstSeen,
    this.lastSeen,
    this.remoteIpDetails,
    this.serviceName,
  });

  factory AwsApiCallAction.fromJson(Map<String, dynamic> json) {
    return AwsApiCallAction(
      affectedResources: (json['AffectedResources'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      api: json['Api'] as String?,
      callerType: json['CallerType'] as String?,
      domainDetails: json['DomainDetails'] != null
          ? AwsApiCallActionDomainDetails.fromJson(
              json['DomainDetails'] as Map<String, dynamic>)
          : null,
      firstSeen: json['FirstSeen'] as String?,
      lastSeen: json['LastSeen'] as String?,
      remoteIpDetails: json['RemoteIpDetails'] != null
          ? ActionRemoteIpDetails.fromJson(
              json['RemoteIpDetails'] as Map<String, dynamic>)
          : null,
      serviceName: json['ServiceName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final affectedResources = this.affectedResources;
    final api = this.api;
    final callerType = this.callerType;
    final domainDetails = this.domainDetails;
    final firstSeen = this.firstSeen;
    final lastSeen = this.lastSeen;
    final remoteIpDetails = this.remoteIpDetails;
    final serviceName = this.serviceName;
    return {
      if (affectedResources != null) 'AffectedResources': affectedResources,
      if (api != null) 'Api': api,
      if (callerType != null) 'CallerType': callerType,
      if (domainDetails != null) 'DomainDetails': domainDetails,
      if (firstSeen != null) 'FirstSeen': firstSeen,
      if (lastSeen != null) 'LastSeen': lastSeen,
      if (remoteIpDetails != null) 'RemoteIpDetails': remoteIpDetails,
      if (serviceName != null) 'ServiceName': serviceName,
    };
  }
}

/// Provided if <code>CallerType</code> is <code>domain</code>. It provides
/// information about the DNS domain that issued the API call.
class AwsApiCallActionDomainDetails {
  /// The name of the DNS domain that issued the API call.
  ///
  /// Length Constraints: 128.
  final String? domain;

  AwsApiCallActionDomainDetails({
    this.domain,
  });

  factory AwsApiCallActionDomainDetails.fromJson(Map<String, dynamic> json) {
    return AwsApiCallActionDomainDetails(
      domain: json['Domain'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final domain = this.domain;
    return {
      if (domain != null) 'Domain': domain,
    };
  }
}

/// Contains information about settings for logging access for the stage.
class AwsApiGatewayAccessLogSettings {
  /// The ARN of the CloudWatch Logs log group that receives the access logs.
  final String? destinationArn;

  /// A single-line format of the access logs of data, as specified by selected
  /// <code>$context</code> variables. The format must include at least
  /// <code>$context.requestId</code>.
  final String? format;

  AwsApiGatewayAccessLogSettings({
    this.destinationArn,
    this.format,
  });

  factory AwsApiGatewayAccessLogSettings.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayAccessLogSettings(
      destinationArn: json['DestinationArn'] as String?,
      format: json['Format'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destinationArn = this.destinationArn;
    final format = this.format;
    return {
      if (destinationArn != null) 'DestinationArn': destinationArn,
      if (format != null) 'Format': format,
    };
  }
}

/// Contains information about settings for canary deployment in the stage.
class AwsApiGatewayCanarySettings {
  /// The deployment identifier for the canary deployment.
  final String? deploymentId;

  /// The percentage of traffic that is diverted to a canary deployment.
  final double? percentTraffic;

  /// Stage variables that are overridden in the canary release deployment. The
  /// variables include new stage variables that are introduced in the canary.
  ///
  /// Each variable is represented as a string-to-string map between the stage
  /// variable name and the variable value.
  final Map<String, String>? stageVariableOverrides;

  /// Indicates whether the canary deployment uses the stage cache.
  final bool? useStageCache;

  AwsApiGatewayCanarySettings({
    this.deploymentId,
    this.percentTraffic,
    this.stageVariableOverrides,
    this.useStageCache,
  });

  factory AwsApiGatewayCanarySettings.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayCanarySettings(
      deploymentId: json['DeploymentId'] as String?,
      percentTraffic: json['PercentTraffic'] as double?,
      stageVariableOverrides:
          (json['StageVariableOverrides'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
      useStageCache: json['UseStageCache'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final deploymentId = this.deploymentId;
    final percentTraffic = this.percentTraffic;
    final stageVariableOverrides = this.stageVariableOverrides;
    final useStageCache = this.useStageCache;
    return {
      if (deploymentId != null) 'DeploymentId': deploymentId,
      if (percentTraffic != null) 'PercentTraffic': percentTraffic,
      if (stageVariableOverrides != null)
        'StageVariableOverrides': stageVariableOverrides,
      if (useStageCache != null) 'UseStageCache': useStageCache,
    };
  }
}

/// Contains information about the endpoints for the API.
class AwsApiGatewayEndpointConfiguration {
  /// A list of endpoint types for the REST API.
  ///
  /// For an edge-optimized API, the endpoint type is <code>EDGE</code>. For a
  /// Regional API, the endpoint type is <code>REGIONAL</code>. For a private API,
  /// the endpoint type is <code>PRIVATE</code>.
  final List<String>? types;

  AwsApiGatewayEndpointConfiguration({
    this.types,
  });

  factory AwsApiGatewayEndpointConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AwsApiGatewayEndpointConfiguration(
      types: (json['Types'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final types = this.types;
    return {
      if (types != null) 'Types': types,
    };
  }
}

/// Defines settings for a method for the stage.
class AwsApiGatewayMethodSettings {
  /// Indicates whether the cached responses are encrypted.
  final bool? cacheDataEncrypted;

  /// Specifies the time to live (TTL), in seconds, for cached responses. The
  /// higher the TTL, the longer the response is cached.
  final int? cacheTtlInSeconds;

  /// Indicates whether responses are cached and returned for requests. For
  /// responses to be cached, a cache cluster must be enabled on the stage.
  final bool? cachingEnabled;

  /// Indicates whether data trace logging is enabled for the method. Data trace
  /// logging affects the log entries that are pushed to CloudWatch Logs.
  final bool? dataTraceEnabled;

  /// The HTTP method. You can use an asterisk (*) as a wildcard to apply method
  /// settings to multiple methods.
  final String? httpMethod;

  /// The logging level for this method. The logging level affects the log entries
  /// that are pushed to CloudWatch Logs.
  ///
  /// If the logging level is <code>ERROR</code>, then the logs only include
  /// error-level entries.
  ///
  /// If the logging level is <code>INFO</code>, then the logs include both
  /// <code>ERROR</code> events and extra informational events.
  ///
  /// Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code>
  final String? loggingLevel;

  /// Indicates whether CloudWatch metrics are enabled for the method.
  final bool? metricsEnabled;

  /// Indicates whether authorization is required for a cache invalidation
  /// request.
  final bool? requireAuthorizationForCacheControl;

  /// The resource path for this method. Forward slashes (/) are encoded as ~1 .
  /// The initial slash must include a forward slash.
  ///
  /// For example, the path value <code>/resource/subresource</code> must be
  /// encoded as <code>/~1resource~1subresource</code>.
  ///
  /// To specify the root path, use only a slash (/). You can use an asterisk (*)
  /// as a wildcard to apply method settings to multiple methods.
  final String? resourcePath;

  /// The throttling burst limit for the method.
  final int? throttlingBurstLimit;

  /// The throttling rate limit for the method.
  final double? throttlingRateLimit;

  /// Indicates how to handle unauthorized requests for cache invalidation.
  ///
  /// Valid values: <code>FAIL_WITH_403</code> |
  /// <code>SUCCEED_WITH_RESPONSE_HEADER</code> |
  /// <code>SUCCEED_WITHOUT_RESPONSE_HEADER</code>
  final String? unauthorizedCacheControlHeaderStrategy;

  AwsApiGatewayMethodSettings({
    this.cacheDataEncrypted,
    this.cacheTtlInSeconds,
    this.cachingEnabled,
    this.dataTraceEnabled,
    this.httpMethod,
    this.loggingLevel,
    this.metricsEnabled,
    this.requireAuthorizationForCacheControl,
    this.resourcePath,
    this.throttlingBurstLimit,
    this.throttlingRateLimit,
    this.unauthorizedCacheControlHeaderStrategy,
  });

  factory AwsApiGatewayMethodSettings.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayMethodSettings(
      cacheDataEncrypted: json['CacheDataEncrypted'] as bool?,
      cacheTtlInSeconds: json['CacheTtlInSeconds'] as int?,
      cachingEnabled: json['CachingEnabled'] as bool?,
      dataTraceEnabled: json['DataTraceEnabled'] as bool?,
      httpMethod: json['HttpMethod'] as String?,
      loggingLevel: json['LoggingLevel'] as String?,
      metricsEnabled: json['MetricsEnabled'] as bool?,
      requireAuthorizationForCacheControl:
          json['RequireAuthorizationForCacheControl'] as bool?,
      resourcePath: json['ResourcePath'] as String?,
      throttlingBurstLimit: json['ThrottlingBurstLimit'] as int?,
      throttlingRateLimit: json['ThrottlingRateLimit'] as double?,
      unauthorizedCacheControlHeaderStrategy:
          json['UnauthorizedCacheControlHeaderStrategy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cacheDataEncrypted = this.cacheDataEncrypted;
    final cacheTtlInSeconds = this.cacheTtlInSeconds;
    final cachingEnabled = this.cachingEnabled;
    final dataTraceEnabled = this.dataTraceEnabled;
    final httpMethod = this.httpMethod;
    final loggingLevel = this.loggingLevel;
    final metricsEnabled = this.metricsEnabled;
    final requireAuthorizationForCacheControl =
        this.requireAuthorizationForCacheControl;
    final resourcePath = this.resourcePath;
    final throttlingBurstLimit = this.throttlingBurstLimit;
    final throttlingRateLimit = this.throttlingRateLimit;
    final unauthorizedCacheControlHeaderStrategy =
        this.unauthorizedCacheControlHeaderStrategy;
    return {
      if (cacheDataEncrypted != null) 'CacheDataEncrypted': cacheDataEncrypted,
      if (cacheTtlInSeconds != null) 'CacheTtlInSeconds': cacheTtlInSeconds,
      if (cachingEnabled != null) 'CachingEnabled': cachingEnabled,
      if (dataTraceEnabled != null) 'DataTraceEnabled': dataTraceEnabled,
      if (httpMethod != null) 'HttpMethod': httpMethod,
      if (loggingLevel != null) 'LoggingLevel': loggingLevel,
      if (metricsEnabled != null) 'MetricsEnabled': metricsEnabled,
      if (requireAuthorizationForCacheControl != null)
        'RequireAuthorizationForCacheControl':
            requireAuthorizationForCacheControl,
      if (resourcePath != null) 'ResourcePath': resourcePath,
      if (throttlingBurstLimit != null)
        'ThrottlingBurstLimit': throttlingBurstLimit,
      if (throttlingRateLimit != null)
        'ThrottlingRateLimit': throttlingRateLimit,
      if (unauthorizedCacheControlHeaderStrategy != null)
        'UnauthorizedCacheControlHeaderStrategy':
            unauthorizedCacheControlHeaderStrategy,
    };
  }
}

/// Contains information about a REST API in version 1 of Amazon API Gateway.
class AwsApiGatewayRestApiDetails {
  /// The source of the API key for metering requests according to a usage plan.
  ///
  /// <code>HEADER</code> indicates whether to read the API key from the X-API-Key
  /// header of a request.
  ///
  /// <code>AUTHORIZER</code> indicates whether to read the API key from the
  /// <code>UsageIdentifierKey</code> from a custom authorizer.
  final String? apiKeySource;

  /// The list of binary media types supported by the REST API.
  final List<String>? binaryMediaTypes;

  /// Indicates when the API was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdDate;

  /// A description of the REST API.
  final String? description;

  /// The endpoint configuration of the REST API.
  final AwsApiGatewayEndpointConfiguration? endpointConfiguration;

  /// The identifier of the REST API.
  final String? id;

  /// The minimum size in bytes of a payload before compression is enabled.
  ///
  /// If <code>null</code>, then compression is disabled.
  ///
  /// If 0, then all payloads are compressed.
  final int? minimumCompressionSize;

  /// The name of the REST API.
  final String? name;

  /// The version identifier for the REST API.
  final String? version;

  AwsApiGatewayRestApiDetails({
    this.apiKeySource,
    this.binaryMediaTypes,
    this.createdDate,
    this.description,
    this.endpointConfiguration,
    this.id,
    this.minimumCompressionSize,
    this.name,
    this.version,
  });

  factory AwsApiGatewayRestApiDetails.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayRestApiDetails(
      apiKeySource: json['ApiKeySource'] as String?,
      binaryMediaTypes: (json['BinaryMediaTypes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      createdDate: json['CreatedDate'] as String?,
      description: json['Description'] as String?,
      endpointConfiguration: json['EndpointConfiguration'] != null
          ? AwsApiGatewayEndpointConfiguration.fromJson(
              json['EndpointConfiguration'] as Map<String, dynamic>)
          : null,
      id: json['Id'] as String?,
      minimumCompressionSize: json['MinimumCompressionSize'] as int?,
      name: json['Name'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final apiKeySource = this.apiKeySource;
    final binaryMediaTypes = this.binaryMediaTypes;
    final createdDate = this.createdDate;
    final description = this.description;
    final endpointConfiguration = this.endpointConfiguration;
    final id = this.id;
    final minimumCompressionSize = this.minimumCompressionSize;
    final name = this.name;
    final version = this.version;
    return {
      if (apiKeySource != null) 'ApiKeySource': apiKeySource,
      if (binaryMediaTypes != null) 'BinaryMediaTypes': binaryMediaTypes,
      if (createdDate != null) 'CreatedDate': createdDate,
      if (description != null) 'Description': description,
      if (endpointConfiguration != null)
        'EndpointConfiguration': endpointConfiguration,
      if (id != null) 'Id': id,
      if (minimumCompressionSize != null)
        'MinimumCompressionSize': minimumCompressionSize,
      if (name != null) 'Name': name,
      if (version != null) 'Version': version,
    };
  }
}

/// Provides information about a version 1 Amazon API Gateway stage.
class AwsApiGatewayStageDetails {
  /// Settings for logging access for the stage.
  final AwsApiGatewayAccessLogSettings? accessLogSettings;

  /// Indicates whether a cache cluster is enabled for the stage.
  final bool? cacheClusterEnabled;

  /// If a cache cluster is enabled, the size of the cache cluster.
  final String? cacheClusterSize;

  /// If a cache cluster is enabled, the status of the cache cluster.
  final String? cacheClusterStatus;

  /// Information about settings for canary deployment in the stage.
  final AwsApiGatewayCanarySettings? canarySettings;

  /// The identifier of the client certificate for the stage.
  final String? clientCertificateId;

  /// Indicates when the stage was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdDate;

  /// The identifier of the deployment that the stage points to.
  final String? deploymentId;

  /// A description of the stage.
  final String? description;

  /// The version of the API documentation that is associated with the stage.
  final String? documentationVersion;

  /// Indicates when the stage was most recently updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastUpdatedDate;

  /// Defines the method settings for the stage.
  final List<AwsApiGatewayMethodSettings>? methodSettings;

  /// The name of the stage.
  final String? stageName;

  /// Indicates whether active tracing with X-Ray is enabled for the stage.
  final bool? tracingEnabled;

  /// A map that defines the stage variables for the stage.
  ///
  /// Variable names can have alphanumeric and underscore characters.
  ///
  /// Variable values can contain the following characters:
  ///
  /// <ul>
  /// <li>
  /// Uppercase and lowercase letters
  /// </li>
  /// <li>
  /// Numbers
  /// </li>
  /// <li>
  /// Special characters -._~:/?#&amp;=,
  /// </li>
  /// </ul>
  final Map<String, String>? variables;

  /// The ARN of the web ACL associated with the stage.
  final String? webAclArn;

  AwsApiGatewayStageDetails({
    this.accessLogSettings,
    this.cacheClusterEnabled,
    this.cacheClusterSize,
    this.cacheClusterStatus,
    this.canarySettings,
    this.clientCertificateId,
    this.createdDate,
    this.deploymentId,
    this.description,
    this.documentationVersion,
    this.lastUpdatedDate,
    this.methodSettings,
    this.stageName,
    this.tracingEnabled,
    this.variables,
    this.webAclArn,
  });

  factory AwsApiGatewayStageDetails.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayStageDetails(
      accessLogSettings: json['AccessLogSettings'] != null
          ? AwsApiGatewayAccessLogSettings.fromJson(
              json['AccessLogSettings'] as Map<String, dynamic>)
          : null,
      cacheClusterEnabled: json['CacheClusterEnabled'] as bool?,
      cacheClusterSize: json['CacheClusterSize'] as String?,
      cacheClusterStatus: json['CacheClusterStatus'] as String?,
      canarySettings: json['CanarySettings'] != null
          ? AwsApiGatewayCanarySettings.fromJson(
              json['CanarySettings'] as Map<String, dynamic>)
          : null,
      clientCertificateId: json['ClientCertificateId'] as String?,
      createdDate: json['CreatedDate'] as String?,
      deploymentId: json['DeploymentId'] as String?,
      description: json['Description'] as String?,
      documentationVersion: json['DocumentationVersion'] as String?,
      lastUpdatedDate: json['LastUpdatedDate'] as String?,
      methodSettings: (json['MethodSettings'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsApiGatewayMethodSettings.fromJson(e as Map<String, dynamic>))
          .toList(),
      stageName: json['StageName'] as String?,
      tracingEnabled: json['TracingEnabled'] as bool?,
      variables: (json['Variables'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      webAclArn: json['WebAclArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accessLogSettings = this.accessLogSettings;
    final cacheClusterEnabled = this.cacheClusterEnabled;
    final cacheClusterSize = this.cacheClusterSize;
    final cacheClusterStatus = this.cacheClusterStatus;
    final canarySettings = this.canarySettings;
    final clientCertificateId = this.clientCertificateId;
    final createdDate = this.createdDate;
    final deploymentId = this.deploymentId;
    final description = this.description;
    final documentationVersion = this.documentationVersion;
    final lastUpdatedDate = this.lastUpdatedDate;
    final methodSettings = this.methodSettings;
    final stageName = this.stageName;
    final tracingEnabled = this.tracingEnabled;
    final variables = this.variables;
    final webAclArn = this.webAclArn;
    return {
      if (accessLogSettings != null) 'AccessLogSettings': accessLogSettings,
      if (cacheClusterEnabled != null)
        'CacheClusterEnabled': cacheClusterEnabled,
      if (cacheClusterSize != null) 'CacheClusterSize': cacheClusterSize,
      if (cacheClusterStatus != null) 'CacheClusterStatus': cacheClusterStatus,
      if (canarySettings != null) 'CanarySettings': canarySettings,
      if (clientCertificateId != null)
        'ClientCertificateId': clientCertificateId,
      if (createdDate != null) 'CreatedDate': createdDate,
      if (deploymentId != null) 'DeploymentId': deploymentId,
      if (description != null) 'Description': description,
      if (documentationVersion != null)
        'DocumentationVersion': documentationVersion,
      if (lastUpdatedDate != null) 'LastUpdatedDate': lastUpdatedDate,
      if (methodSettings != null) 'MethodSettings': methodSettings,
      if (stageName != null) 'StageName': stageName,
      if (tracingEnabled != null) 'TracingEnabled': tracingEnabled,
      if (variables != null) 'Variables': variables,
      if (webAclArn != null) 'WebAclArn': webAclArn,
    };
  }
}

/// Contains information about a version 2 API in Amazon API Gateway.
class AwsApiGatewayV2ApiDetails {
  /// The URI of the API.
  ///
  /// Uses the format <code>
  /// <i>&lt;api-id&gt;</i>.execute-api.<i>&lt;region&gt;</i>.amazonaws.com</code>
  ///
  /// The stage name is typically appended to the URI to form a complete path to a
  /// deployed API stage.
  final String? apiEndpoint;

  /// The identifier of the API.
  final String? apiId;

  /// An API key selection expression. Supported only for WebSocket APIs.
  final String? apiKeySelectionExpression;

  /// A cross-origin resource sharing (CORS) configuration. Supported only for
  /// HTTP APIs.
  final AwsCorsConfiguration? corsConfiguration;

  /// Indicates when the API was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdDate;

  /// A description of the API.
  final String? description;

  /// The name of the API.
  final String? name;

  /// The API protocol for the API.
  ///
  /// Valid values: <code>WEBSOCKET</code> | <code>HTTP</code>
  final String? protocolType;

  /// The route selection expression for the API.
  ///
  /// For HTTP APIs, must be <code>${request.method} ${request.path}</code>. This
  /// is the default value for HTTP APIs.
  ///
  /// For WebSocket APIs, there is no default value.
  final String? routeSelectionExpression;

  /// The version identifier for the API.
  final String? version;

  AwsApiGatewayV2ApiDetails({
    this.apiEndpoint,
    this.apiId,
    this.apiKeySelectionExpression,
    this.corsConfiguration,
    this.createdDate,
    this.description,
    this.name,
    this.protocolType,
    this.routeSelectionExpression,
    this.version,
  });

  factory AwsApiGatewayV2ApiDetails.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayV2ApiDetails(
      apiEndpoint: json['ApiEndpoint'] as String?,
      apiId: json['ApiId'] as String?,
      apiKeySelectionExpression: json['ApiKeySelectionExpression'] as String?,
      corsConfiguration: json['CorsConfiguration'] != null
          ? AwsCorsConfiguration.fromJson(
              json['CorsConfiguration'] as Map<String, dynamic>)
          : null,
      createdDate: json['CreatedDate'] as String?,
      description: json['Description'] as String?,
      name: json['Name'] as String?,
      protocolType: json['ProtocolType'] as String?,
      routeSelectionExpression: json['RouteSelectionExpression'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final apiEndpoint = this.apiEndpoint;
    final apiId = this.apiId;
    final apiKeySelectionExpression = this.apiKeySelectionExpression;
    final corsConfiguration = this.corsConfiguration;
    final createdDate = this.createdDate;
    final description = this.description;
    final name = this.name;
    final protocolType = this.protocolType;
    final routeSelectionExpression = this.routeSelectionExpression;
    final version = this.version;
    return {
      if (apiEndpoint != null) 'ApiEndpoint': apiEndpoint,
      if (apiId != null) 'ApiId': apiId,
      if (apiKeySelectionExpression != null)
        'ApiKeySelectionExpression': apiKeySelectionExpression,
      if (corsConfiguration != null) 'CorsConfiguration': corsConfiguration,
      if (createdDate != null) 'CreatedDate': createdDate,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (protocolType != null) 'ProtocolType': protocolType,
      if (routeSelectionExpression != null)
        'RouteSelectionExpression': routeSelectionExpression,
      if (version != null) 'Version': version,
    };
  }
}

/// Contains route settings for a stage.
class AwsApiGatewayV2RouteSettings {
  /// Indicates whether data trace logging is enabled. Data trace logging affects
  /// the log entries that are pushed to CloudWatch Logs. Supported only for
  /// WebSocket APIs.
  final bool? dataTraceEnabled;

  /// Indicates whether detailed metrics are enabled.
  final bool? detailedMetricsEnabled;

  /// The logging level. The logging level affects the log entries that are pushed
  /// to CloudWatch Logs. Supported only for WebSocket APIs.
  ///
  /// If the logging level is <code>ERROR</code>, then the logs only include
  /// error-level entries.
  ///
  /// If the logging level is <code>INFO</code>, then the logs include both
  /// <code>ERROR</code> events and extra informational events.
  ///
  /// Valid values: <code>OFF</code> | <code>ERROR</code> | <code>INFO</code>
  final String? loggingLevel;

  /// The throttling burst limit.
  final int? throttlingBurstLimit;

  /// The throttling rate limit.
  final double? throttlingRateLimit;

  AwsApiGatewayV2RouteSettings({
    this.dataTraceEnabled,
    this.detailedMetricsEnabled,
    this.loggingLevel,
    this.throttlingBurstLimit,
    this.throttlingRateLimit,
  });

  factory AwsApiGatewayV2RouteSettings.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayV2RouteSettings(
      dataTraceEnabled: json['DataTraceEnabled'] as bool?,
      detailedMetricsEnabled: json['DetailedMetricsEnabled'] as bool?,
      loggingLevel: json['LoggingLevel'] as String?,
      throttlingBurstLimit: json['ThrottlingBurstLimit'] as int?,
      throttlingRateLimit: json['ThrottlingRateLimit'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataTraceEnabled = this.dataTraceEnabled;
    final detailedMetricsEnabled = this.detailedMetricsEnabled;
    final loggingLevel = this.loggingLevel;
    final throttlingBurstLimit = this.throttlingBurstLimit;
    final throttlingRateLimit = this.throttlingRateLimit;
    return {
      if (dataTraceEnabled != null) 'DataTraceEnabled': dataTraceEnabled,
      if (detailedMetricsEnabled != null)
        'DetailedMetricsEnabled': detailedMetricsEnabled,
      if (loggingLevel != null) 'LoggingLevel': loggingLevel,
      if (throttlingBurstLimit != null)
        'ThrottlingBurstLimit': throttlingBurstLimit,
      if (throttlingRateLimit != null)
        'ThrottlingRateLimit': throttlingRateLimit,
    };
  }
}

/// Contains information about a version 2 stage for Amazon API Gateway.
class AwsApiGatewayV2StageDetails {
  /// Information about settings for logging access for the stage.
  final AwsApiGatewayAccessLogSettings? accessLogSettings;

  /// Indicates whether the stage is managed by API Gateway.
  final bool? apiGatewayManaged;

  /// Indicates whether updates to an API automatically trigger a new deployment.
  final bool? autoDeploy;

  /// The identifier of a client certificate for a stage. Supported only for
  /// WebSocket API calls.
  final String? clientCertificateId;

  /// Indicates when the stage was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdDate;

  /// Default route settings for the stage.
  final AwsApiGatewayV2RouteSettings? defaultRouteSettings;

  /// The identifier of the deployment that the stage is associated with.
  final String? deploymentId;

  /// The description of the stage.
  final String? description;

  /// The status of the last deployment of a stage. Supported only if the stage
  /// has automatic deployment enabled.
  final String? lastDeploymentStatusMessage;

  /// Indicates when the stage was most recently updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastUpdatedDate;

  /// The route settings for the stage.
  final AwsApiGatewayV2RouteSettings? routeSettings;

  /// The name of the stage.
  final String? stageName;

  /// A map that defines the stage variables for the stage.
  ///
  /// Variable names can have alphanumeric and underscore characters.
  ///
  /// Variable values can contain the following characters:
  ///
  /// <ul>
  /// <li>
  /// Uppercase and lowercase letters
  /// </li>
  /// <li>
  /// Numbers
  /// </li>
  /// <li>
  /// Special characters -._~:/?#&amp;=,
  /// </li>
  /// </ul>
  final Map<String, String>? stageVariables;

  AwsApiGatewayV2StageDetails({
    this.accessLogSettings,
    this.apiGatewayManaged,
    this.autoDeploy,
    this.clientCertificateId,
    this.createdDate,
    this.defaultRouteSettings,
    this.deploymentId,
    this.description,
    this.lastDeploymentStatusMessage,
    this.lastUpdatedDate,
    this.routeSettings,
    this.stageName,
    this.stageVariables,
  });

  factory AwsApiGatewayV2StageDetails.fromJson(Map<String, dynamic> json) {
    return AwsApiGatewayV2StageDetails(
      accessLogSettings: json['AccessLogSettings'] != null
          ? AwsApiGatewayAccessLogSettings.fromJson(
              json['AccessLogSettings'] as Map<String, dynamic>)
          : null,
      apiGatewayManaged: json['ApiGatewayManaged'] as bool?,
      autoDeploy: json['AutoDeploy'] as bool?,
      clientCertificateId: json['ClientCertificateId'] as String?,
      createdDate: json['CreatedDate'] as String?,
      defaultRouteSettings: json['DefaultRouteSettings'] != null
          ? AwsApiGatewayV2RouteSettings.fromJson(
              json['DefaultRouteSettings'] as Map<String, dynamic>)
          : null,
      deploymentId: json['DeploymentId'] as String?,
      description: json['Description'] as String?,
      lastDeploymentStatusMessage:
          json['LastDeploymentStatusMessage'] as String?,
      lastUpdatedDate: json['LastUpdatedDate'] as String?,
      routeSettings: json['RouteSettings'] != null
          ? AwsApiGatewayV2RouteSettings.fromJson(
              json['RouteSettings'] as Map<String, dynamic>)
          : null,
      stageName: json['StageName'] as String?,
      stageVariables: (json['StageVariables'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final accessLogSettings = this.accessLogSettings;
    final apiGatewayManaged = this.apiGatewayManaged;
    final autoDeploy = this.autoDeploy;
    final clientCertificateId = this.clientCertificateId;
    final createdDate = this.createdDate;
    final defaultRouteSettings = this.defaultRouteSettings;
    final deploymentId = this.deploymentId;
    final description = this.description;
    final lastDeploymentStatusMessage = this.lastDeploymentStatusMessage;
    final lastUpdatedDate = this.lastUpdatedDate;
    final routeSettings = this.routeSettings;
    final stageName = this.stageName;
    final stageVariables = this.stageVariables;
    return {
      if (accessLogSettings != null) 'AccessLogSettings': accessLogSettings,
      if (apiGatewayManaged != null) 'ApiGatewayManaged': apiGatewayManaged,
      if (autoDeploy != null) 'AutoDeploy': autoDeploy,
      if (clientCertificateId != null)
        'ClientCertificateId': clientCertificateId,
      if (createdDate != null) 'CreatedDate': createdDate,
      if (defaultRouteSettings != null)
        'DefaultRouteSettings': defaultRouteSettings,
      if (deploymentId != null) 'DeploymentId': deploymentId,
      if (description != null) 'Description': description,
      if (lastDeploymentStatusMessage != null)
        'LastDeploymentStatusMessage': lastDeploymentStatusMessage,
      if (lastUpdatedDate != null) 'LastUpdatedDate': lastUpdatedDate,
      if (routeSettings != null) 'RouteSettings': routeSettings,
      if (stageName != null) 'StageName': stageName,
      if (stageVariables != null) 'StageVariables': stageVariables,
    };
  }
}

/// A list of additional authentication providers for the GraphqlApi API.
class AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails {
  /// The type of security configuration for your GraphQL API: API key, Identity
  /// and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user
  /// pools, or Lambda.
  final String? authenticationType;

  /// The configuration for Lambda function authorization.
  final AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?
      lambdaAuthorizerConfig;

  /// The OpenID Connect configuration.
  final AwsAppSyncGraphQlApiOpenIdConnectConfigDetails? openIdConnectConfig;

  /// The Amazon Cognito user pools configuration.
  final AwsAppSyncGraphQlApiUserPoolConfigDetails? userPoolConfig;

  AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails({
    this.authenticationType,
    this.lambdaAuthorizerConfig,
    this.openIdConnectConfig,
    this.userPoolConfig,
  });

  factory AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails(
      authenticationType: json['AuthenticationType'] as String?,
      lambdaAuthorizerConfig: json['LambdaAuthorizerConfig'] != null
          ? AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.fromJson(
              json['LambdaAuthorizerConfig'] as Map<String, dynamic>)
          : null,
      openIdConnectConfig: json['OpenIdConnectConfig'] != null
          ? AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.fromJson(
              json['OpenIdConnectConfig'] as Map<String, dynamic>)
          : null,
      userPoolConfig: json['UserPoolConfig'] != null
          ? AwsAppSyncGraphQlApiUserPoolConfigDetails.fromJson(
              json['UserPoolConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final authenticationType = this.authenticationType;
    final lambdaAuthorizerConfig = this.lambdaAuthorizerConfig;
    final openIdConnectConfig = this.openIdConnectConfig;
    final userPoolConfig = this.userPoolConfig;
    return {
      if (authenticationType != null) 'AuthenticationType': authenticationType,
      if (lambdaAuthorizerConfig != null)
        'LambdaAuthorizerConfig': lambdaAuthorizerConfig,
      if (openIdConnectConfig != null)
        'OpenIdConnectConfig': openIdConnectConfig,
      if (userPoolConfig != null) 'UserPoolConfig': userPoolConfig,
    };
  }
}

/// Provides details about an AppSync Graph QL API, which lets you query
/// multiple databases, microservices, and APIs from a single GraphQL endpoint.
class AwsAppSyncGraphQlApiDetails {
  /// A list of additional authentication providers for the GraphQL API.
  final List<AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails>?
      additionalAuthenticationProviders;

  /// The unique identifier for the API.
  final String? apiId;

  /// The Amazon Resource Name (ARN) of the API.
  final String? arn;

  /// The type of security configuration for your GraphQL API: API key, Identity
  /// and Access Management (IAM), OpenID Connect (OIDC), Amazon Cognito user
  /// pools, or Lambda.
  final String? authenticationType;

  /// The unique identifier for the API.
  final String? id;

  /// Specifies the configuration for Lambda function authorization.
  final AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails?
      lambdaAuthorizerConfig;

  /// The Amazon CloudWatch Logs configuration.
  final AwsAppSyncGraphQlApiLogConfigDetails? logConfig;

  /// The API name.
  final String? name;

  /// Specifies the authorization configuration for using an OpenID Connect
  /// compliant service with an AppSync GraphQL API endpoint.
  final AwsAppSyncGraphQlApiOpenIdConnectConfigDetails? openIdConnectConfig;

  /// The Amazon Cognito user pools configuration.
  final AwsAppSyncGraphQlApiUserPoolConfigDetails? userPoolConfig;

  /// The Amazon Resource Name (ARN) of the WAF web access control list (web ACL)
  /// associated with this GraphQL API, if one exists.
  final String? wafWebAclArn;

  /// Indicates whether to use X-Ray tracing for the GraphQL API.
  final bool? xrayEnabled;

  AwsAppSyncGraphQlApiDetails({
    this.additionalAuthenticationProviders,
    this.apiId,
    this.arn,
    this.authenticationType,
    this.id,
    this.lambdaAuthorizerConfig,
    this.logConfig,
    this.name,
    this.openIdConnectConfig,
    this.userPoolConfig,
    this.wafWebAclArn,
    this.xrayEnabled,
  });

  factory AwsAppSyncGraphQlApiDetails.fromJson(Map<String, dynamic> json) {
    return AwsAppSyncGraphQlApiDetails(
      additionalAuthenticationProviders:
          (json['AdditionalAuthenticationProviders'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  AwsAppSyncGraphQlApiAdditionalAuthenticationProvidersDetails
                      .fromJson(e as Map<String, dynamic>))
              .toList(),
      apiId: json['ApiId'] as String?,
      arn: json['Arn'] as String?,
      authenticationType: json['AuthenticationType'] as String?,
      id: json['Id'] as String?,
      lambdaAuthorizerConfig: json['LambdaAuthorizerConfig'] != null
          ? AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.fromJson(
              json['LambdaAuthorizerConfig'] as Map<String, dynamic>)
          : null,
      logConfig: json['LogConfig'] != null
          ? AwsAppSyncGraphQlApiLogConfigDetails.fromJson(
              json['LogConfig'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      openIdConnectConfig: json['OpenIdConnectConfig'] != null
          ? AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.fromJson(
              json['OpenIdConnectConfig'] as Map<String, dynamic>)
          : null,
      userPoolConfig: json['UserPoolConfig'] != null
          ? AwsAppSyncGraphQlApiUserPoolConfigDetails.fromJson(
              json['UserPoolConfig'] as Map<String, dynamic>)
          : null,
      wafWebAclArn: json['WafWebAclArn'] as String?,
      xrayEnabled: json['XrayEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final additionalAuthenticationProviders =
        this.additionalAuthenticationProviders;
    final apiId = this.apiId;
    final arn = this.arn;
    final authenticationType = this.authenticationType;
    final id = this.id;
    final lambdaAuthorizerConfig = this.lambdaAuthorizerConfig;
    final logConfig = this.logConfig;
    final name = this.name;
    final openIdConnectConfig = this.openIdConnectConfig;
    final userPoolConfig = this.userPoolConfig;
    final wafWebAclArn = this.wafWebAclArn;
    final xrayEnabled = this.xrayEnabled;
    return {
      if (additionalAuthenticationProviders != null)
        'AdditionalAuthenticationProviders': additionalAuthenticationProviders,
      if (apiId != null) 'ApiId': apiId,
      if (arn != null) 'Arn': arn,
      if (authenticationType != null) 'AuthenticationType': authenticationType,
      if (id != null) 'Id': id,
      if (lambdaAuthorizerConfig != null)
        'LambdaAuthorizerConfig': lambdaAuthorizerConfig,
      if (logConfig != null) 'LogConfig': logConfig,
      if (name != null) 'Name': name,
      if (openIdConnectConfig != null)
        'OpenIdConnectConfig': openIdConnectConfig,
      if (userPoolConfig != null) 'UserPoolConfig': userPoolConfig,
      if (wafWebAclArn != null) 'WafWebAclArn': wafWebAclArn,
      if (xrayEnabled != null) 'XrayEnabled': xrayEnabled,
    };
  }
}

/// Specifies the authorization configuration for using an Lambda function with
/// your AppSync GraphQL API endpoint.
class AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails {
  /// The number of seconds a response should be cached for. The default is 5
  /// minutes (300 seconds).
  final int? authorizerResultTtlInSeconds;

  /// The Amazon Resource Name (ARN) of the Lambda function to be called for
  /// authorization. This can be a standard Lambda ARN, a version ARN (.../v3), or
  /// an alias ARN.
  final String? authorizerUri;

  /// A regular expression for validation of tokens before the Lambda function is
  /// called.
  final String? identityValidationExpression;

  AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails({
    this.authorizerResultTtlInSeconds,
    this.authorizerUri,
    this.identityValidationExpression,
  });

  factory AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAppSyncGraphQlApiLambdaAuthorizerConfigDetails(
      authorizerResultTtlInSeconds:
          json['AuthorizerResultTtlInSeconds'] as int?,
      authorizerUri: json['AuthorizerUri'] as String?,
      identityValidationExpression:
          json['IdentityValidationExpression'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final authorizerResultTtlInSeconds = this.authorizerResultTtlInSeconds;
    final authorizerUri = this.authorizerUri;
    final identityValidationExpression = this.identityValidationExpression;
    return {
      if (authorizerResultTtlInSeconds != null)
        'AuthorizerResultTtlInSeconds': authorizerResultTtlInSeconds,
      if (authorizerUri != null) 'AuthorizerUri': authorizerUri,
      if (identityValidationExpression != null)
        'IdentityValidationExpression': identityValidationExpression,
    };
  }
}

/// Specifies the logging configuration when writing GraphQL operations and
/// tracing to Amazon CloudWatch for an AppSync GraphQL API.
class AwsAppSyncGraphQlApiLogConfigDetails {
  /// The Amazon Resource Name (ARN) of the service role that AppSync assumes to
  /// publish to CloudWatch Logs in your account.
  final String? cloudWatchLogsRoleArn;

  /// Set to <code>TRUE</code> to exclude sections that contain information such
  /// as headers, context, and evaluated mapping templates, regardless of logging
  /// level.
  final bool? excludeVerboseContent;

  /// The field logging level.
  final String? fieldLogLevel;

  AwsAppSyncGraphQlApiLogConfigDetails({
    this.cloudWatchLogsRoleArn,
    this.excludeVerboseContent,
    this.fieldLogLevel,
  });

  factory AwsAppSyncGraphQlApiLogConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAppSyncGraphQlApiLogConfigDetails(
      cloudWatchLogsRoleArn: json['CloudWatchLogsRoleArn'] as String?,
      excludeVerboseContent: json['ExcludeVerboseContent'] as bool?,
      fieldLogLevel: json['FieldLogLevel'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsRoleArn = this.cloudWatchLogsRoleArn;
    final excludeVerboseContent = this.excludeVerboseContent;
    final fieldLogLevel = this.fieldLogLevel;
    return {
      if (cloudWatchLogsRoleArn != null)
        'CloudWatchLogsRoleArn': cloudWatchLogsRoleArn,
      if (excludeVerboseContent != null)
        'ExcludeVerboseContent': excludeVerboseContent,
      if (fieldLogLevel != null) 'FieldLogLevel': fieldLogLevel,
    };
  }
}

/// Specifies the authorization configuration for using an OpenID Connect
/// compliant service with your AppSync GraphQL API endpoint.
class AwsAppSyncGraphQlApiOpenIdConnectConfigDetails {
  /// The number of milliseconds that a token is valid after being authenticated.
  final int? authTtL;

  /// The client identifier of the relying party at the OpenID identity provider.
  /// This identifier is typically obtained when the relying party is registered
  /// with the OpenID identity provider. You can specify a regular expression so
  /// that AppSync can validate against multiple client identifiers at a time.
  final String? clientId;

  /// The number of milliseconds that a token is valid after it's issued to a
  /// user.
  final int? iatTtL;

  /// The issuer for the OIDC configuration. The issuer returned by discovery must
  /// exactly match the value of <code>iss</code> in the ID token.
  final String? issuer;

  AwsAppSyncGraphQlApiOpenIdConnectConfigDetails({
    this.authTtL,
    this.clientId,
    this.iatTtL,
    this.issuer,
  });

  factory AwsAppSyncGraphQlApiOpenIdConnectConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAppSyncGraphQlApiOpenIdConnectConfigDetails(
      authTtL: json['AuthTtL'] as int?,
      clientId: json['ClientId'] as String?,
      iatTtL: json['IatTtL'] as int?,
      issuer: json['Issuer'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final authTtL = this.authTtL;
    final clientId = this.clientId;
    final iatTtL = this.iatTtL;
    final issuer = this.issuer;
    return {
      if (authTtL != null) 'AuthTtL': authTtL,
      if (clientId != null) 'ClientId': clientId,
      if (iatTtL != null) 'IatTtL': iatTtL,
      if (issuer != null) 'Issuer': issuer,
    };
  }
}

/// Specifies the authorization configuration for using Amazon Cognito user
/// pools with your AppSync GraphQL API endpoint.
class AwsAppSyncGraphQlApiUserPoolConfigDetails {
  /// A regular expression for validating the incoming Amazon Cognito user pools
  /// app client ID. If this value isn't set, no filtering is applied.
  final String? appIdClientRegex;

  /// The Amazon Web Services Region in which the user pool was created.
  final String? awsRegion;

  /// The action that you want your GraphQL API to take when a request that uses
  /// Amazon Cognito user pools authentication doesn't match the Amazon Cognito
  /// user pools configuration.
  final String? defaultAction;

  /// The user pool ID.
  final String? userPoolId;

  AwsAppSyncGraphQlApiUserPoolConfigDetails({
    this.appIdClientRegex,
    this.awsRegion,
    this.defaultAction,
    this.userPoolId,
  });

  factory AwsAppSyncGraphQlApiUserPoolConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAppSyncGraphQlApiUserPoolConfigDetails(
      appIdClientRegex: json['AppIdClientRegex'] as String?,
      awsRegion: json['AwsRegion'] as String?,
      defaultAction: json['DefaultAction'] as String?,
      userPoolId: json['UserPoolId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final appIdClientRegex = this.appIdClientRegex;
    final awsRegion = this.awsRegion;
    final defaultAction = this.defaultAction;
    final userPoolId = this.userPoolId;
    return {
      if (appIdClientRegex != null) 'AppIdClientRegex': appIdClientRegex,
      if (awsRegion != null) 'AwsRegion': awsRegion,
      if (defaultAction != null) 'DefaultAction': defaultAction,
      if (userPoolId != null) 'UserPoolId': userPoolId,
    };
  }
}

/// The configuration of the workgroup, which includes the location in Amazon
/// Simple Storage Service (Amazon S3) where query results are stored, the
/// encryption option, if any, used for query results, whether Amazon CloudWatch
/// metrics are enabled for the workgroup, and the limit for the amount of bytes
/// scanned (cutoff) per query, if it is specified.
class AwsAthenaWorkGroupConfigurationDetails {
  /// The location in Amazon S3 where query and calculation results are stored and
  /// the encryption option, if any, used for query and calculation results. These
  /// are known as client-side settings. If workgroup settings override
  /// client-side settings, then the query uses the workgroup settings.
  final AwsAthenaWorkGroupConfigurationResultConfigurationDetails?
      resultConfiguration;

  AwsAthenaWorkGroupConfigurationDetails({
    this.resultConfiguration,
  });

  factory AwsAthenaWorkGroupConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAthenaWorkGroupConfigurationDetails(
      resultConfiguration: json['ResultConfiguration'] != null
          ? AwsAthenaWorkGroupConfigurationResultConfigurationDetails.fromJson(
              json['ResultConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final resultConfiguration = this.resultConfiguration;
    return {
      if (resultConfiguration != null)
        'ResultConfiguration': resultConfiguration,
    };
  }
}

/// The location in Amazon Simple Storage Service (Amazon S3) where query and
/// calculation results are stored and the encryption option, if any, used for
/// query and calculation results. These are known as client-side settings. If
/// workgroup settings override client-side settings, then the query uses the
/// workgroup settings.
class AwsAthenaWorkGroupConfigurationResultConfigurationDetails {
  /// Specifies the method used to encrypt the user’s data stores in the Athena
  /// workgroup.
  final AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails?
      encryptionConfiguration;

  AwsAthenaWorkGroupConfigurationResultConfigurationDetails({
    this.encryptionConfiguration,
  });

  factory AwsAthenaWorkGroupConfigurationResultConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAthenaWorkGroupConfigurationResultConfigurationDetails(
      encryptionConfiguration: json['EncryptionConfiguration'] != null
          ? AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails
              .fromJson(json['EncryptionConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionConfiguration = this.encryptionConfiguration;
    return {
      if (encryptionConfiguration != null)
        'EncryptionConfiguration': encryptionConfiguration,
    };
  }
}

/// Specifies the method used to encrypt the user’s data stores in the Athena
/// workgroup.
class AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails {
  /// Indicates whether Amazon Simple Storage Service (Amazon S3) server-side
  /// encryption with Amazon S3 managed keys (SSE_S3), server-side encryption with
  /// KMS keys (SSE_KMS), or client-side encryption with KMS customer managed keys
  /// (CSE_KMS) is used.
  final String? encryptionOption;

  /// For <code>SSE_KMS</code> and <code>CSE_KMS</code>, this is the KMS key
  /// Amazon Resource Name (ARN) or ID.
  final String? kmsKey;

  AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails({
    this.encryptionOption,
    this.kmsKey,
  });

  factory AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAthenaWorkGroupConfigurationResultConfigurationEncryptionConfigurationDetails(
      encryptionOption: json['EncryptionOption'] as String?,
      kmsKey: json['KmsKey'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionOption = this.encryptionOption;
    final kmsKey = this.kmsKey;
    return {
      if (encryptionOption != null) 'EncryptionOption': encryptionOption,
      if (kmsKey != null) 'KmsKey': kmsKey,
    };
  }
}

/// Provides information about an Amazon Athena workgroup.
class AwsAthenaWorkGroupDetails {
  /// The configuration of the workgroup, which includes the location in Amazon
  /// Simple Storage Service (Amazon S3) where query results are stored, the
  /// encryption option, if any, used for query results, whether Amazon CloudWatch
  /// metrics are enabled for the workgroup, and the limit for the amount of bytes
  /// scanned (cutoff) per query, if it is specified.
  final AwsAthenaWorkGroupConfigurationDetails? configuration;

  /// The workgroup description.
  final String? description;

  /// The workgroup name.
  final String? name;

  /// Whether the workgroup is enabled or disabled.
  final String? state;

  AwsAthenaWorkGroupDetails({
    this.configuration,
    this.description,
    this.name,
    this.state,
  });

  factory AwsAthenaWorkGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsAthenaWorkGroupDetails(
      configuration: json['Configuration'] != null
          ? AwsAthenaWorkGroupConfigurationDetails.fromJson(
              json['Configuration'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      name: json['Name'] as String?,
      state: json['State'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final configuration = this.configuration;
    final description = this.description;
    final name = this.name;
    final state = this.state;
    return {
      if (configuration != null) 'Configuration': configuration,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (state != null) 'State': state,
    };
  }
}

/// An Availability Zone for the automatic scaling group.
class AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails {
  /// The name of the Availability Zone.
  final String? value;

  AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails({
    this.value,
  });

  factory AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails(
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

/// Provides details about an auto scaling group.
class AwsAutoScalingAutoScalingGroupDetails {
  /// The list of Availability Zones for the automatic scaling group.
  final List<AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails>?
      availabilityZones;

  /// Indicates whether capacity rebalancing is enabled.
  final bool? capacityRebalance;

  /// Indicates when the auto scaling group was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdTime;

  /// The amount of time, in seconds, that Amazon EC2 Auto Scaling waits before it
  /// checks the health status of an EC2 instance that has come into service.
  final int? healthCheckGracePeriod;

  /// The service to use for the health checks. Valid values are <code>EC2</code>
  /// or <code>ELB</code>.
  final String? healthCheckType;

  /// The name of the launch configuration.
  final String? launchConfigurationName;

  /// The launch template to use.
  final AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification?
      launchTemplate;

  /// The list of load balancers associated with the group.
  final List<String>? loadBalancerNames;

  /// The mixed instances policy for the automatic scaling group.
  final AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails?
      mixedInstancesPolicy;

  AwsAutoScalingAutoScalingGroupDetails({
    this.availabilityZones,
    this.capacityRebalance,
    this.createdTime,
    this.healthCheckGracePeriod,
    this.healthCheckType,
    this.launchConfigurationName,
    this.launchTemplate,
    this.loadBalancerNames,
    this.mixedInstancesPolicy,
  });

  factory AwsAutoScalingAutoScalingGroupDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupDetails(
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => AwsAutoScalingAutoScalingGroupAvailabilityZonesListDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      capacityRebalance: json['CapacityRebalance'] as bool?,
      createdTime: json['CreatedTime'] as String?,
      healthCheckGracePeriod: json['HealthCheckGracePeriod'] as int?,
      healthCheckType: json['HealthCheckType'] as String?,
      launchConfigurationName: json['LaunchConfigurationName'] as String?,
      launchTemplate: json['LaunchTemplate'] != null
          ? AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification
              .fromJson(json['LaunchTemplate'] as Map<String, dynamic>)
          : null,
      loadBalancerNames: (json['LoadBalancerNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      mixedInstancesPolicy: json['MixedInstancesPolicy'] != null
          ? AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails.fromJson(
              json['MixedInstancesPolicy'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZones = this.availabilityZones;
    final capacityRebalance = this.capacityRebalance;
    final createdTime = this.createdTime;
    final healthCheckGracePeriod = this.healthCheckGracePeriod;
    final healthCheckType = this.healthCheckType;
    final launchConfigurationName = this.launchConfigurationName;
    final launchTemplate = this.launchTemplate;
    final loadBalancerNames = this.loadBalancerNames;
    final mixedInstancesPolicy = this.mixedInstancesPolicy;
    return {
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (capacityRebalance != null) 'CapacityRebalance': capacityRebalance,
      if (createdTime != null) 'CreatedTime': createdTime,
      if (healthCheckGracePeriod != null)
        'HealthCheckGracePeriod': healthCheckGracePeriod,
      if (healthCheckType != null) 'HealthCheckType': healthCheckType,
      if (launchConfigurationName != null)
        'LaunchConfigurationName': launchConfigurationName,
      if (launchTemplate != null) 'LaunchTemplate': launchTemplate,
      if (loadBalancerNames != null) 'LoadBalancerNames': loadBalancerNames,
      if (mixedInstancesPolicy != null)
        'MixedInstancesPolicy': mixedInstancesPolicy,
    };
  }
}

/// Details about the launch template to use.
class AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification {
  /// The identifier of the launch template. You must specify either
  /// <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.
  final String? launchTemplateId;

  /// The name of the launch template. You must specify either
  /// <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.
  final String? launchTemplateName;

  /// Identifies the version of the launch template. You can specify a version
  /// identifier, or use the values <code>$Latest</code> or <code>$Default</code>.
  final String? version;

  AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification({
    this.launchTemplateId,
    this.launchTemplateName,
    this.version,
  });

  factory AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupLaunchTemplateLaunchTemplateSpecification(
      launchTemplateId: json['LaunchTemplateId'] as String?,
      launchTemplateName: json['LaunchTemplateName'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final launchTemplateId = this.launchTemplateId;
    final launchTemplateName = this.launchTemplateName;
    final version = this.version;
    return {
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
      if (version != null) 'Version': version,
    };
  }
}

/// The mixed instances policy for the automatic scaling group.
class AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails {
  /// The instances distribution. The instances distribution specifies the
  /// distribution of On-Demand Instances and Spot Instances, the maximum price to
  /// pay for Spot Instances, and how the Auto Scaling group allocates instance
  /// types to fulfill On-Demand and Spot capacity.
  final AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails?
      instancesDistribution;

  /// The launch template to use and the instance types (overrides) to use to
  /// provision EC2 instances to fulfill On-Demand and Spot capacities.
  final AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails?
      launchTemplate;

  AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails({
    this.instancesDistribution,
    this.launchTemplate,
  });

  factory AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupMixedInstancesPolicyDetails(
      instancesDistribution: json['InstancesDistribution'] != null
          ? AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails
              .fromJson(json['InstancesDistribution'] as Map<String, dynamic>)
          : null,
      launchTemplate: json['LaunchTemplate'] != null
          ? AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails
              .fromJson(json['LaunchTemplate'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final instancesDistribution = this.instancesDistribution;
    final launchTemplate = this.launchTemplate;
    return {
      if (instancesDistribution != null)
        'InstancesDistribution': instancesDistribution,
      if (launchTemplate != null) 'LaunchTemplate': launchTemplate,
    };
  }
}

/// Information about the instances distribution.
class AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails {
  /// How to allocate instance types to fulfill On-Demand capacity. The valid
  /// value is <code>prioritized</code>.
  final String? onDemandAllocationStrategy;

  /// The minimum amount of the Auto Scaling group's capacity that must be
  /// fulfilled by On-Demand Instances.
  final int? onDemandBaseCapacity;

  /// The percentage of On-Demand Instances and Spot Instances for additional
  /// capacity beyond <code>OnDemandBaseCapacity</code>.
  final int? onDemandPercentageAboveBaseCapacity;

  /// How to allocate instances across Spot Instance pools. Valid values are as
  /// follows:
  ///
  /// <ul>
  /// <li>
  /// <code>lowest-price</code>
  /// </li>
  /// <li>
  /// <code>capacity-optimized</code>
  /// </li>
  /// <li>
  /// <code>capacity-optimized-prioritized</code>
  /// </li>
  /// </ul>
  final String? spotAllocationStrategy;

  /// The number of Spot Instance pools across which to allocate your Spot
  /// Instances.
  final int? spotInstancePools;

  /// The maximum price per unit hour that you are willing to pay for a Spot
  /// Instance.
  final String? spotMaxPrice;

  AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails({
    this.onDemandAllocationStrategy,
    this.onDemandBaseCapacity,
    this.onDemandPercentageAboveBaseCapacity,
    this.spotAllocationStrategy,
    this.spotInstancePools,
    this.spotMaxPrice,
  });

  factory AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupMixedInstancesPolicyInstancesDistributionDetails(
      onDemandAllocationStrategy: json['OnDemandAllocationStrategy'] as String?,
      onDemandBaseCapacity: json['OnDemandBaseCapacity'] as int?,
      onDemandPercentageAboveBaseCapacity:
          json['OnDemandPercentageAboveBaseCapacity'] as int?,
      spotAllocationStrategy: json['SpotAllocationStrategy'] as String?,
      spotInstancePools: json['SpotInstancePools'] as int?,
      spotMaxPrice: json['SpotMaxPrice'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final onDemandAllocationStrategy = this.onDemandAllocationStrategy;
    final onDemandBaseCapacity = this.onDemandBaseCapacity;
    final onDemandPercentageAboveBaseCapacity =
        this.onDemandPercentageAboveBaseCapacity;
    final spotAllocationStrategy = this.spotAllocationStrategy;
    final spotInstancePools = this.spotInstancePools;
    final spotMaxPrice = this.spotMaxPrice;
    return {
      if (onDemandAllocationStrategy != null)
        'OnDemandAllocationStrategy': onDemandAllocationStrategy,
      if (onDemandBaseCapacity != null)
        'OnDemandBaseCapacity': onDemandBaseCapacity,
      if (onDemandPercentageAboveBaseCapacity != null)
        'OnDemandPercentageAboveBaseCapacity':
            onDemandPercentageAboveBaseCapacity,
      if (spotAllocationStrategy != null)
        'SpotAllocationStrategy': spotAllocationStrategy,
      if (spotInstancePools != null) 'SpotInstancePools': spotInstancePools,
      if (spotMaxPrice != null) 'SpotMaxPrice': spotMaxPrice,
    };
  }
}

/// Describes a launch template and overrides for a mixed instances policy.
class AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails {
  /// The launch template to use for a mixed instances policy.
  final AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification?
      launchTemplateSpecification;

  /// Property values to use to override the values in the launch template.
  final List<
          AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails>?
      overrides;

  AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails({
    this.launchTemplateSpecification,
    this.overrides,
  });

  factory AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateDetails(
      launchTemplateSpecification: json['LaunchTemplateSpecification'] != null
          ? AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
              .fromJson(
                  json['LaunchTemplateSpecification'] as Map<String, dynamic>)
          : null,
      overrides: (json['Overrides'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final launchTemplateSpecification = this.launchTemplateSpecification;
    final overrides = this.overrides;
    return {
      if (launchTemplateSpecification != null)
        'LaunchTemplateSpecification': launchTemplateSpecification,
      if (overrides != null) 'Overrides': overrides,
    };
  }
}

/// Details about the launch template to use for a mixed instances policy.
class AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
  /// The identifier of the launch template. You must specify either
  /// <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.
  final String? launchTemplateId;

  /// The name of the launch template. You must specify either
  /// <code>LaunchTemplateId</code> or <code>LaunchTemplateName</code>.
  final String? launchTemplateName;

  /// Identifies the version of the launch template. You can specify a version
  /// identifier, or use the values <code>$Latest</code> or <code>$Default</code>.
  final String? version;

  AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification({
    this.launchTemplateId,
    this.launchTemplateName,
    this.version,
  });

  factory AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification(
      launchTemplateId: json['LaunchTemplateId'] as String?,
      launchTemplateName: json['LaunchTemplateName'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final launchTemplateId = this.launchTemplateId;
    final launchTemplateName = this.launchTemplateName;
    final version = this.version;
    return {
      if (launchTemplateId != null) 'LaunchTemplateId': launchTemplateId,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
      if (version != null) 'Version': version,
    };
  }
}

/// Property values to use to override the values in the launch template.
class AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails {
  /// The instance type. For example, <code>m3.xlarge</code>.
  final String? instanceType;

  /// The number of capacity units provided by the specified instance type in
  /// terms of virtual CPUs, memory, storage, throughput, or other relative
  /// performance characteristic.
  final String? weightedCapacity;

  AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails({
    this.instanceType,
    this.weightedCapacity,
  });

  factory AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingAutoScalingGroupMixedInstancesPolicyLaunchTemplateOverridesListDetails(
      instanceType: json['InstanceType'] as String?,
      weightedCapacity: json['WeightedCapacity'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final instanceType = this.instanceType;
    final weightedCapacity = this.weightedCapacity;
    return {
      if (instanceType != null) 'InstanceType': instanceType,
      if (weightedCapacity != null) 'WeightedCapacity': weightedCapacity,
    };
  }
}

/// A block device for the instance.
class AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails {
  /// The device name that is exposed to the EC2 instance. For example,
  /// <code>/dev/sdh</code> or <code>xvdh</code>.
  final String? deviceName;

  /// Parameters that are used to automatically set up Amazon EBS volumes when an
  /// instance is launched.
  final AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails? ebs;

  /// Whether to suppress the device that is included in the block device mapping
  /// of the Amazon Machine Image (AMI).
  ///
  /// If <code>NoDevice</code> is <code>true</code>, then you cannot specify
  /// <code>Ebs</code>.&gt;
  final bool? noDevice;

  /// The name of the virtual device (for example, <code>ephemeral0</code>).
  ///
  /// You can provide either <code>VirtualName</code> or <code>Ebs</code>, but not
  /// both.
  final String? virtualName;

  AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails({
    this.deviceName,
    this.ebs,
    this.noDevice,
    this.virtualName,
  });

  factory AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails(
      deviceName: json['DeviceName'] as String?,
      ebs: json['Ebs'] != null
          ? AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails
              .fromJson(json['Ebs'] as Map<String, dynamic>)
          : null,
      noDevice: json['NoDevice'] as bool?,
      virtualName: json['VirtualName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deviceName = this.deviceName;
    final ebs = this.ebs;
    final noDevice = this.noDevice;
    final virtualName = this.virtualName;
    return {
      if (deviceName != null) 'DeviceName': deviceName,
      if (ebs != null) 'Ebs': ebs,
      if (noDevice != null) 'NoDevice': noDevice,
      if (virtualName != null) 'VirtualName': virtualName,
    };
  }
}

/// Parameters that are used to automatically set up EBS volumes when an
/// instance is launched.
class AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails {
  /// Whether to delete the volume when the instance is terminated.
  final bool? deleteOnTermination;

  /// Whether to encrypt the volume.
  final bool? encrypted;

  /// The number of input/output (I/O) operations per second (IOPS) to provision
  /// for the volume.
  ///
  /// Only supported for <code>gp3</code> or <code>io1</code> volumes. Required
  /// for <code>io1</code> volumes. Not used with <code>standard</code>,
  /// <code>gp2</code>, <code>st1</code>, or <code>sc1</code> volumes.
  final int? iops;

  /// The snapshot ID of the volume to use.
  ///
  /// You must specify either <code>VolumeSize</code> or <code>SnapshotId</code>.
  final String? snapshotId;

  /// The volume size, in GiBs. The following are the supported volumes sizes for
  /// each volume type:
  ///
  /// <ul>
  /// <li>
  /// gp2 and gp3: 1-16,384
  /// </li>
  /// <li>
  /// io1: 4-16,384
  /// </li>
  /// <li>
  /// st1 and sc1: 125-16,384
  /// </li>
  /// <li>
  /// standard: 1-1,024
  /// </li>
  /// </ul>
  /// You must specify either <code>SnapshotId</code> or <code>VolumeSize</code>.
  /// If you specify both <code>SnapshotId</code> and <code>VolumeSize</code>, the
  /// volume size must be equal or greater than the size of the snapshot.
  final int? volumeSize;

  /// The volume type. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>gp2</code>
  /// </li>
  /// <li>
  /// <code>gp3</code>
  /// </li>
  /// <li>
  /// <code>io1</code>
  /// </li>
  /// <li>
  /// <code>sc1</code>
  /// </li>
  /// <li>
  /// <code>st1</code>
  /// </li>
  /// <li>
  /// <code>standard</code>
  /// </li>
  /// </ul>
  final String? volumeType;

  AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails({
    this.deleteOnTermination,
    this.encrypted,
    this.iops,
    this.snapshotId,
    this.volumeSize,
    this.volumeType,
  });

  factory AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingLaunchConfigurationBlockDeviceMappingsEbsDetails(
      deleteOnTermination: json['DeleteOnTermination'] as bool?,
      encrypted: json['Encrypted'] as bool?,
      iops: json['Iops'] as int?,
      snapshotId: json['SnapshotId'] as String?,
      volumeSize: json['VolumeSize'] as int?,
      volumeType: json['VolumeType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deleteOnTermination = this.deleteOnTermination;
    final encrypted = this.encrypted;
    final iops = this.iops;
    final snapshotId = this.snapshotId;
    final volumeSize = this.volumeSize;
    final volumeType = this.volumeType;
    return {
      if (deleteOnTermination != null)
        'DeleteOnTermination': deleteOnTermination,
      if (encrypted != null) 'Encrypted': encrypted,
      if (iops != null) 'Iops': iops,
      if (snapshotId != null) 'SnapshotId': snapshotId,
      if (volumeSize != null) 'VolumeSize': volumeSize,
      if (volumeType != null) 'VolumeType': volumeType,
    };
  }
}

/// Details about a launch configuration.
class AwsAutoScalingLaunchConfigurationDetails {
  /// For Auto Scaling groups that run in a VPC, specifies whether to assign a
  /// public IP address to the group's instances.
  final bool? associatePublicIpAddress;

  /// Specifies the block devices for the instance.
  final List<AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails>?
      blockDeviceMappings;

  /// The identifier of a ClassicLink-enabled VPC that EC2-Classic instances are
  /// linked to.
  final String? classicLinkVpcId;

  /// The identifiers of one or more security groups for the VPC that is specified
  /// in <code>ClassicLinkVPCId</code>.
  final List<String>? classicLinkVpcSecurityGroups;

  /// The creation date and time for the launch configuration.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdTime;

  /// Whether the launch configuration is optimized for Amazon EBS I/O.
  final bool? ebsOptimized;

  /// The name or the ARN of the instance profile associated with the IAM role for
  /// the instance. The instance profile contains the IAM role.
  final String? iamInstanceProfile;

  /// The identifier of the Amazon Machine Image (AMI) that is used to launch EC2
  /// instances.
  final String? imageId;

  /// Indicates the type of monitoring for instances in the group.
  final AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails?
      instanceMonitoring;

  /// The instance type for the instances.
  final String? instanceType;

  /// The identifier of the kernel associated with the AMI.
  final String? kernelId;

  /// The name of the key pair.
  final String? keyName;

  /// The name of the launch configuration.
  final String? launchConfigurationName;

  /// The metadata options for the instances.
  final AwsAutoScalingLaunchConfigurationMetadataOptions? metadataOptions;

  /// The tenancy of the instance. An instance with <code>dedicated</code> tenancy
  /// runs on isolated, single-tenant hardware and can only be launched into a
  /// VPC.
  final String? placementTenancy;

  /// The identifier of the RAM disk associated with the AMI.
  final String? ramdiskId;

  /// The security groups to assign to the instances in the Auto Scaling group.
  final List<String>? securityGroups;

  /// The maximum hourly price to be paid for any Spot Instance that is launched
  /// to fulfill the request.
  final String? spotPrice;

  /// The user data to make available to the launched EC2 instances. Must be
  /// base64-encoded text.
  final String? userData;

  AwsAutoScalingLaunchConfigurationDetails({
    this.associatePublicIpAddress,
    this.blockDeviceMappings,
    this.classicLinkVpcId,
    this.classicLinkVpcSecurityGroups,
    this.createdTime,
    this.ebsOptimized,
    this.iamInstanceProfile,
    this.imageId,
    this.instanceMonitoring,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.launchConfigurationName,
    this.metadataOptions,
    this.placementTenancy,
    this.ramdiskId,
    this.securityGroups,
    this.spotPrice,
    this.userData,
  });

  factory AwsAutoScalingLaunchConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingLaunchConfigurationDetails(
      associatePublicIpAddress: json['AssociatePublicIpAddress'] as bool?,
      blockDeviceMappings: (json['BlockDeviceMappings'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsAutoScalingLaunchConfigurationBlockDeviceMappingsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      classicLinkVpcId: json['ClassicLinkVpcId'] as String?,
      classicLinkVpcSecurityGroups:
          (json['ClassicLinkVpcSecurityGroups'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      createdTime: json['CreatedTime'] as String?,
      ebsOptimized: json['EbsOptimized'] as bool?,
      iamInstanceProfile: json['IamInstanceProfile'] as String?,
      imageId: json['ImageId'] as String?,
      instanceMonitoring: json['InstanceMonitoring'] != null
          ? AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails.fromJson(
              json['InstanceMonitoring'] as Map<String, dynamic>)
          : null,
      instanceType: json['InstanceType'] as String?,
      kernelId: json['KernelId'] as String?,
      keyName: json['KeyName'] as String?,
      launchConfigurationName: json['LaunchConfigurationName'] as String?,
      metadataOptions: json['MetadataOptions'] != null
          ? AwsAutoScalingLaunchConfigurationMetadataOptions.fromJson(
              json['MetadataOptions'] as Map<String, dynamic>)
          : null,
      placementTenancy: json['PlacementTenancy'] as String?,
      ramdiskId: json['RamdiskId'] as String?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      spotPrice: json['SpotPrice'] as String?,
      userData: json['UserData'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associatePublicIpAddress = this.associatePublicIpAddress;
    final blockDeviceMappings = this.blockDeviceMappings;
    final classicLinkVpcId = this.classicLinkVpcId;
    final classicLinkVpcSecurityGroups = this.classicLinkVpcSecurityGroups;
    final createdTime = this.createdTime;
    final ebsOptimized = this.ebsOptimized;
    final iamInstanceProfile = this.iamInstanceProfile;
    final imageId = this.imageId;
    final instanceMonitoring = this.instanceMonitoring;
    final instanceType = this.instanceType;
    final kernelId = this.kernelId;
    final keyName = this.keyName;
    final launchConfigurationName = this.launchConfigurationName;
    final metadataOptions = this.metadataOptions;
    final placementTenancy = this.placementTenancy;
    final ramdiskId = this.ramdiskId;
    final securityGroups = this.securityGroups;
    final spotPrice = this.spotPrice;
    final userData = this.userData;
    return {
      if (associatePublicIpAddress != null)
        'AssociatePublicIpAddress': associatePublicIpAddress,
      if (blockDeviceMappings != null)
        'BlockDeviceMappings': blockDeviceMappings,
      if (classicLinkVpcId != null) 'ClassicLinkVpcId': classicLinkVpcId,
      if (classicLinkVpcSecurityGroups != null)
        'ClassicLinkVpcSecurityGroups': classicLinkVpcSecurityGroups,
      if (createdTime != null) 'CreatedTime': createdTime,
      if (ebsOptimized != null) 'EbsOptimized': ebsOptimized,
      if (iamInstanceProfile != null) 'IamInstanceProfile': iamInstanceProfile,
      if (imageId != null) 'ImageId': imageId,
      if (instanceMonitoring != null) 'InstanceMonitoring': instanceMonitoring,
      if (instanceType != null) 'InstanceType': instanceType,
      if (kernelId != null) 'KernelId': kernelId,
      if (keyName != null) 'KeyName': keyName,
      if (launchConfigurationName != null)
        'LaunchConfigurationName': launchConfigurationName,
      if (metadataOptions != null) 'MetadataOptions': metadataOptions,
      if (placementTenancy != null) 'PlacementTenancy': placementTenancy,
      if (ramdiskId != null) 'RamdiskId': ramdiskId,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (spotPrice != null) 'SpotPrice': spotPrice,
      if (userData != null) 'UserData': userData,
    };
  }
}

/// Information about the type of monitoring for instances in the group.
class AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails {
  /// If set to <code>true</code>, then instances in the group launch with
  /// detailed monitoring.
  ///
  /// If set to <code>false</code>, then instances in the group launch with basic
  /// monitoring.
  final bool? enabled;

  AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails({
    this.enabled,
  });

  factory AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingLaunchConfigurationInstanceMonitoringDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// The metadata options for the instances.
class AwsAutoScalingLaunchConfigurationMetadataOptions {
  /// Enables or disables the HTTP metadata endpoint on your instances. By
  /// default, the metadata endpoint is enabled.
  final String? httpEndpoint;

  /// The HTTP <code>PUT</code> response hop limit for instance metadata requests.
  /// The larger the number, the further instance metadata requests can travel.
  final int? httpPutResponseHopLimit;

  /// Indicates whether token usage is <code>required</code> or
  /// <code>optional</code> for metadata requests. By default, token usage is
  /// <code>optional</code>.
  final String? httpTokens;

  AwsAutoScalingLaunchConfigurationMetadataOptions({
    this.httpEndpoint,
    this.httpPutResponseHopLimit,
    this.httpTokens,
  });

  factory AwsAutoScalingLaunchConfigurationMetadataOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsAutoScalingLaunchConfigurationMetadataOptions(
      httpEndpoint: json['HttpEndpoint'] as String?,
      httpPutResponseHopLimit: json['HttpPutResponseHopLimit'] as int?,
      httpTokens: json['HttpTokens'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final httpEndpoint = this.httpEndpoint;
    final httpPutResponseHopLimit = this.httpPutResponseHopLimit;
    final httpTokens = this.httpTokens;
    return {
      if (httpEndpoint != null) 'HttpEndpoint': httpEndpoint,
      if (httpPutResponseHopLimit != null)
        'HttpPutResponseHopLimit': httpPutResponseHopLimit,
      if (httpTokens != null) 'HttpTokens': httpTokens,
    };
  }
}

/// Provides a list of backup options for each resource type.
class AwsBackupBackupPlanAdvancedBackupSettingsDetails {
  /// Specifies the backup option for a selected resource. This option is only
  /// available for Windows Volume Shadow Copy Service (VSS) backup jobs. Valid
  /// values are as follows:
  ///
  /// <ul>
  /// <li>
  /// Set to <code>WindowsVSS: enabled</code> to enable the WindowsVSS backup
  /// option and create a Windows VSS backup.
  /// </li>
  /// <li>
  /// Set to <code>WindowsVSS: disabled</code> to create a regular backup. The
  /// <code>WindowsVSS</code> option is not enabled by default.
  /// </li>
  /// </ul>
  final Map<String, String>? backupOptions;

  /// The name of a resource type. The only supported resource type is Amazon EC2
  /// instances with Windows VSS.
  ///
  /// The only valid value is <code>EC2</code>.
  final String? resourceType;

  AwsBackupBackupPlanAdvancedBackupSettingsDetails({
    this.backupOptions,
    this.resourceType,
  });

  factory AwsBackupBackupPlanAdvancedBackupSettingsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupBackupPlanAdvancedBackupSettingsDetails(
      backupOptions: (json['BackupOptions'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      resourceType: json['ResourceType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final backupOptions = this.backupOptions;
    final resourceType = this.resourceType;
    return {
      if (backupOptions != null) 'BackupOptions': backupOptions,
      if (resourceType != null) 'ResourceType': resourceType,
    };
  }
}

/// Provides details about an Backup backup plan and an array of
/// <code>BackupRule</code> objects, each of which specifies a backup rule.
class AwsBackupBackupPlanBackupPlanDetails {
  /// A list of backup options for each resource type.
  final List<AwsBackupBackupPlanAdvancedBackupSettingsDetails>?
      advancedBackupSettings;

  /// The display name of a backup plan.
  final String? backupPlanName;

  /// An array of <code>BackupRule</code> objects, each of which specifies a
  /// scheduled task that is used to back up a selection of resources.
  final List<AwsBackupBackupPlanRuleDetails>? backupPlanRule;

  AwsBackupBackupPlanBackupPlanDetails({
    this.advancedBackupSettings,
    this.backupPlanName,
    this.backupPlanRule,
  });

  factory AwsBackupBackupPlanBackupPlanDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupBackupPlanBackupPlanDetails(
      advancedBackupSettings: (json['AdvancedBackupSettings'] as List?)
          ?.whereNotNull()
          .map((e) => AwsBackupBackupPlanAdvancedBackupSettingsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      backupPlanName: json['BackupPlanName'] as String?,
      backupPlanRule: (json['BackupPlanRule'] as List?)
          ?.whereNotNull()
          .map((e) => AwsBackupBackupPlanRuleDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final advancedBackupSettings = this.advancedBackupSettings;
    final backupPlanName = this.backupPlanName;
    final backupPlanRule = this.backupPlanRule;
    return {
      if (advancedBackupSettings != null)
        'AdvancedBackupSettings': advancedBackupSettings,
      if (backupPlanName != null) 'BackupPlanName': backupPlanName,
      if (backupPlanRule != null) 'BackupPlanRule': backupPlanRule,
    };
  }
}

/// Provides details about an Backup backup plan and an array of
/// <code>BackupRule</code> objects, each of which specifies a backup rule.
class AwsBackupBackupPlanDetails {
  /// Uniquely identifies the backup plan to be associated with the selection of
  /// resources.
  final AwsBackupBackupPlanBackupPlanDetails? backupPlan;

  /// An Amazon Resource Name (ARN) that uniquely identifies the backup plan.
  final String? backupPlanArn;

  /// A unique ID for the backup plan.
  final String? backupPlanId;

  /// Unique, randomly generated, Unicode, UTF-8 encoded strings. Version IDs
  /// cannot be edited.
  final String? versionId;

  AwsBackupBackupPlanDetails({
    this.backupPlan,
    this.backupPlanArn,
    this.backupPlanId,
    this.versionId,
  });

  factory AwsBackupBackupPlanDetails.fromJson(Map<String, dynamic> json) {
    return AwsBackupBackupPlanDetails(
      backupPlan: json['BackupPlan'] != null
          ? AwsBackupBackupPlanBackupPlanDetails.fromJson(
              json['BackupPlan'] as Map<String, dynamic>)
          : null,
      backupPlanArn: json['BackupPlanArn'] as String?,
      backupPlanId: json['BackupPlanId'] as String?,
      versionId: json['VersionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final backupPlan = this.backupPlan;
    final backupPlanArn = this.backupPlanArn;
    final backupPlanId = this.backupPlanId;
    final versionId = this.versionId;
    return {
      if (backupPlan != null) 'BackupPlan': backupPlan,
      if (backupPlanArn != null) 'BackupPlanArn': backupPlanArn,
      if (backupPlanId != null) 'BackupPlanId': backupPlanId,
      if (versionId != null) 'VersionId': versionId,
    };
  }
}

/// Provides lifecycle details for the backup plan. A lifecycle defines when a
/// backup is transitioned to cold storage and when it expires.
class AwsBackupBackupPlanLifecycleDetails {
  /// Specifies the number of days after creation that a recovery point is
  /// deleted. Must be greater than 90 days plus
  /// <code>MoveToColdStorageAfterDays</code>.
  final int? deleteAfterDays;

  /// Specifies the number of days after creation that a recovery point is moved
  /// to cold storage.
  final int? moveToColdStorageAfterDays;

  AwsBackupBackupPlanLifecycleDetails({
    this.deleteAfterDays,
    this.moveToColdStorageAfterDays,
  });

  factory AwsBackupBackupPlanLifecycleDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupBackupPlanLifecycleDetails(
      deleteAfterDays: json['DeleteAfterDays'] as int?,
      moveToColdStorageAfterDays: json['MoveToColdStorageAfterDays'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final deleteAfterDays = this.deleteAfterDays;
    final moveToColdStorageAfterDays = this.moveToColdStorageAfterDays;
    return {
      if (deleteAfterDays != null) 'DeleteAfterDays': deleteAfterDays,
      if (moveToColdStorageAfterDays != null)
        'MoveToColdStorageAfterDays': moveToColdStorageAfterDays,
    };
  }
}

/// An array of <code>CopyAction</code> objects, each of which contains details
/// of the copy operation.
class AwsBackupBackupPlanRuleCopyActionsDetails {
  /// An Amazon Resource Name (ARN) that uniquely identifies the destination
  /// backup vault for the copied backup.
  final String? destinationBackupVaultArn;

  /// Defines when a protected resource is transitioned to cold storage and when
  /// it expires. Backup transitions and expires backups automatically according
  /// to the lifecycle that you define. If you do not specify a lifecycle, Backup
  /// applies the lifecycle policy of the source backup to the destination backup.
  ///
  /// Backups transitioned to cold storage must be stored in cold storage for a
  /// minimum of 90 days.
  final AwsBackupBackupPlanLifecycleDetails? lifecycle;

  AwsBackupBackupPlanRuleCopyActionsDetails({
    this.destinationBackupVaultArn,
    this.lifecycle,
  });

  factory AwsBackupBackupPlanRuleCopyActionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupBackupPlanRuleCopyActionsDetails(
      destinationBackupVaultArn: json['DestinationBackupVaultArn'] as String?,
      lifecycle: json['Lifecycle'] != null
          ? AwsBackupBackupPlanLifecycleDetails.fromJson(
              json['Lifecycle'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final destinationBackupVaultArn = this.destinationBackupVaultArn;
    final lifecycle = this.lifecycle;
    return {
      if (destinationBackupVaultArn != null)
        'DestinationBackupVaultArn': destinationBackupVaultArn,
      if (lifecycle != null) 'Lifecycle': lifecycle,
    };
  }
}

/// Provides details about an array of <code>BackupRule</code> objects, each of
/// which specifies a scheduled task that is used to back up a selection of
/// resources.
class AwsBackupBackupPlanRuleDetails {
  /// A value in minutes after a backup job is successfully started before it must
  /// be completed, or it is canceled by Backup.
  final int? completionWindowMinutes;

  /// An array of <code>CopyAction</code> objects, each of which contains details
  /// of the copy operation.
  final List<AwsBackupBackupPlanRuleCopyActionsDetails>? copyActions;

  /// Specifies whether Backup creates continuous backups capable of point-in-time
  /// restore (PITR).
  final bool? enableContinuousBackup;

  /// Defines when a protected resource is transitioned to cold storage and when
  /// it expires. Backup transitions and expires backups automatically according
  /// to the lifecycle that you define. If you do not specify a lifecycle, Backup
  /// applies the lifecycle policy of the source backup to the destination backup.
  ///
  /// Backups transitioned to cold storage must be stored in cold storage for a
  /// minimum of 90 days.
  final AwsBackupBackupPlanLifecycleDetails? lifecycle;

  /// Uniquely identifies a rule that is used to schedule the backup of a
  /// selection of resources.
  final String? ruleId;

  /// A display name for a backup rule. Must contain 1 to 50 alphanumeric or '-_.'
  /// characters.
  final String? ruleName;

  /// A cron expression in UTC specifying when Backup initiates a backup job.
  final String? scheduleExpression;

  /// A value in minutes after a backup is scheduled before a job will be canceled
  /// if it doesn't start successfully.
  final int? startWindowMinutes;

  /// The name of a logical container where backups are stored. Backup vaults are
  /// identified by names that are unique to the Amazon Web Services account used
  /// to create them and the Amazon Web Services Region where they are created.
  /// They consist of letters, numbers, and hyphens.
  final String? targetBackupVault;

  AwsBackupBackupPlanRuleDetails({
    this.completionWindowMinutes,
    this.copyActions,
    this.enableContinuousBackup,
    this.lifecycle,
    this.ruleId,
    this.ruleName,
    this.scheduleExpression,
    this.startWindowMinutes,
    this.targetBackupVault,
  });

  factory AwsBackupBackupPlanRuleDetails.fromJson(Map<String, dynamic> json) {
    return AwsBackupBackupPlanRuleDetails(
      completionWindowMinutes: json['CompletionWindowMinutes'] as int?,
      copyActions: (json['CopyActions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsBackupBackupPlanRuleCopyActionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      enableContinuousBackup: json['EnableContinuousBackup'] as bool?,
      lifecycle: json['Lifecycle'] != null
          ? AwsBackupBackupPlanLifecycleDetails.fromJson(
              json['Lifecycle'] as Map<String, dynamic>)
          : null,
      ruleId: json['RuleId'] as String?,
      ruleName: json['RuleName'] as String?,
      scheduleExpression: json['ScheduleExpression'] as String?,
      startWindowMinutes: json['StartWindowMinutes'] as int?,
      targetBackupVault: json['TargetBackupVault'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final completionWindowMinutes = this.completionWindowMinutes;
    final copyActions = this.copyActions;
    final enableContinuousBackup = this.enableContinuousBackup;
    final lifecycle = this.lifecycle;
    final ruleId = this.ruleId;
    final ruleName = this.ruleName;
    final scheduleExpression = this.scheduleExpression;
    final startWindowMinutes = this.startWindowMinutes;
    final targetBackupVault = this.targetBackupVault;
    return {
      if (completionWindowMinutes != null)
        'CompletionWindowMinutes': completionWindowMinutes,
      if (copyActions != null) 'CopyActions': copyActions,
      if (enableContinuousBackup != null)
        'EnableContinuousBackup': enableContinuousBackup,
      if (lifecycle != null) 'Lifecycle': lifecycle,
      if (ruleId != null) 'RuleId': ruleId,
      if (ruleName != null) 'RuleName': ruleName,
      if (scheduleExpression != null) 'ScheduleExpression': scheduleExpression,
      if (startWindowMinutes != null) 'StartWindowMinutes': startWindowMinutes,
      if (targetBackupVault != null) 'TargetBackupVault': targetBackupVault,
    };
  }
}

/// Provides details about an Backup backup vault. In Backup, a backup vault is
/// a container that stores and organizes your backups.
class AwsBackupBackupVaultDetails {
  /// A resource-based policy that is used to manage access permissions on the
  /// target backup vault.
  final String? accessPolicy;

  /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
  final String? backupVaultArn;

  /// The name of a logical container where backups are stored. Backup vaults are
  /// identified by names that are unique to the Amazon Web Services account used
  /// to create them and the Amazon Web Services Region where they are created.
  /// They consist of lowercase letters, numbers, and hyphens.
  final String? backupVaultName;

  /// The unique ARN associated with the server-side encryption key. You can
  /// specify a key to encrypt your backups from services that support full Backup
  /// management. If you do not specify a key, Backup creates an KMS key for you
  /// by default.
  final String? encryptionKeyArn;

  /// The Amazon SNS event notifications for the specified backup vault.
  final AwsBackupBackupVaultNotificationsDetails? notifications;

  AwsBackupBackupVaultDetails({
    this.accessPolicy,
    this.backupVaultArn,
    this.backupVaultName,
    this.encryptionKeyArn,
    this.notifications,
  });

  factory AwsBackupBackupVaultDetails.fromJson(Map<String, dynamic> json) {
    return AwsBackupBackupVaultDetails(
      accessPolicy: json['AccessPolicy'] as String?,
      backupVaultArn: json['BackupVaultArn'] as String?,
      backupVaultName: json['BackupVaultName'] as String?,
      encryptionKeyArn: json['EncryptionKeyArn'] as String?,
      notifications: json['Notifications'] != null
          ? AwsBackupBackupVaultNotificationsDetails.fromJson(
              json['Notifications'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessPolicy = this.accessPolicy;
    final backupVaultArn = this.backupVaultArn;
    final backupVaultName = this.backupVaultName;
    final encryptionKeyArn = this.encryptionKeyArn;
    final notifications = this.notifications;
    return {
      if (accessPolicy != null) 'AccessPolicy': accessPolicy,
      if (backupVaultArn != null) 'BackupVaultArn': backupVaultArn,
      if (backupVaultName != null) 'BackupVaultName': backupVaultName,
      if (encryptionKeyArn != null) 'EncryptionKeyArn': encryptionKeyArn,
      if (notifications != null) 'Notifications': notifications,
    };
  }
}

/// Provides details about the Amazon SNS event notifications for the specified
/// backup vault.
class AwsBackupBackupVaultNotificationsDetails {
  /// An array of events that indicate the status of jobs to back up resources to
  /// the backup vault. The following events are supported:
  ///
  /// <ul>
  /// <li>
  /// <code>BACKUP_JOB_STARTED | BACKUP_JOB_COMPLETED</code>
  /// </li>
  /// <li>
  /// <code>COPY_JOB_STARTED | COPY_JOB_SUCCESSFUL | COPY_JOB_FAILED</code>
  /// </li>
  /// <li>
  /// <code>RESTORE_JOB_STARTED | RESTORE_JOB_COMPLETED |
  /// RECOVERY_POINT_MODIFIED</code>
  /// </li>
  /// <li>
  /// <code>S3_BACKUP_OBJECT_FAILED | S3_RESTORE_OBJECT_FAILED</code>
  /// </li>
  /// </ul>
  final List<String>? backupVaultEvents;

  /// The Amazon Resource Name (ARN) that uniquely identifies the Amazon SNS topic
  /// for a backup vault's events.
  final String? snsTopicArn;

  AwsBackupBackupVaultNotificationsDetails({
    this.backupVaultEvents,
    this.snsTopicArn,
  });

  factory AwsBackupBackupVaultNotificationsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupBackupVaultNotificationsDetails(
      backupVaultEvents: (json['BackupVaultEvents'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      snsTopicArn: json['SnsTopicArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final backupVaultEvents = this.backupVaultEvents;
    final snsTopicArn = this.snsTopicArn;
    return {
      if (backupVaultEvents != null) 'BackupVaultEvents': backupVaultEvents,
      if (snsTopicArn != null) 'SnsTopicArn': snsTopicArn,
    };
  }
}

/// Specifies how long in days before a recovery point transitions to cold
/// storage or is deleted.
class AwsBackupRecoveryPointCalculatedLifecycleDetails {
  /// Specifies the number of days after creation that a recovery point is
  /// deleted. Must be greater than 90 days plus
  /// <code>MoveToColdStorageAfterDays</code>.
  final String? deleteAt;

  /// Specifies the number of days after creation that a recovery point is moved
  /// to cold storage.
  final String? moveToColdStorageAt;

  AwsBackupRecoveryPointCalculatedLifecycleDetails({
    this.deleteAt,
    this.moveToColdStorageAt,
  });

  factory AwsBackupRecoveryPointCalculatedLifecycleDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupRecoveryPointCalculatedLifecycleDetails(
      deleteAt: json['DeleteAt'] as String?,
      moveToColdStorageAt: json['MoveToColdStorageAt'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deleteAt = this.deleteAt;
    final moveToColdStorageAt = this.moveToColdStorageAt;
    return {
      if (deleteAt != null) 'DeleteAt': deleteAt,
      if (moveToColdStorageAt != null)
        'MoveToColdStorageAt': moveToColdStorageAt,
    };
  }
}

/// Contains information about the backup plan and rule that Backup used to
/// initiate the recovery point backup.
class AwsBackupRecoveryPointCreatedByDetails {
  /// An Amazon Resource Name (ARN) that uniquely identifies a backup plan.
  final String? backupPlanArn;

  /// Uniquely identifies a backup plan.
  final String? backupPlanId;

  /// Unique, randomly generated, Unicode, UTF-8 encoded strings that are at most
  /// 1,024 bytes long. Version IDs cannot be edited.
  final String? backupPlanVersion;

  /// Uniquely identifies a rule used to schedule the backup of a selection of
  /// resources.
  final String? backupRuleId;

  AwsBackupRecoveryPointCreatedByDetails({
    this.backupPlanArn,
    this.backupPlanId,
    this.backupPlanVersion,
    this.backupRuleId,
  });

  factory AwsBackupRecoveryPointCreatedByDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupRecoveryPointCreatedByDetails(
      backupPlanArn: json['BackupPlanArn'] as String?,
      backupPlanId: json['BackupPlanId'] as String?,
      backupPlanVersion: json['BackupPlanVersion'] as String?,
      backupRuleId: json['BackupRuleId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final backupPlanArn = this.backupPlanArn;
    final backupPlanId = this.backupPlanId;
    final backupPlanVersion = this.backupPlanVersion;
    final backupRuleId = this.backupRuleId;
    return {
      if (backupPlanArn != null) 'BackupPlanArn': backupPlanArn,
      if (backupPlanId != null) 'BackupPlanId': backupPlanId,
      if (backupPlanVersion != null) 'BackupPlanVersion': backupPlanVersion,
      if (backupRuleId != null) 'BackupRuleId': backupRuleId,
    };
  }
}

/// Contains detailed information about the recovery points stored in an Backup
/// backup vault. A backup, or recovery point, represents the content of a
/// resource at a specified time.
class AwsBackupRecoveryPointDetails {
  /// The size, in bytes, of a backup.
  final int? backupSizeInBytes;

  /// An Amazon Resource Name (ARN) that uniquely identifies a backup vault.
  final String? backupVaultArn;

  /// The name of a logical container where backups are stored. Backup vaults are
  /// identified by names that are unique to the Amazon Web Services account used
  /// to create them and the Amazon Web Services Region where they are created.
  /// They consist of lowercase letters, numbers, and hyphens.
  final String? backupVaultName;

  /// A <code>CalculatedLifecycle</code> object containing <code>DeleteAt</code>
  /// and <code>MoveToColdStorageAt</code> timestamps.
  final AwsBackupRecoveryPointCalculatedLifecycleDetails? calculatedLifecycle;

  /// The date and time that a job to create a recovery point is completed, in
  /// Unix format and UTC. The value of <code>CompletionDate</code> is accurate to
  /// milliseconds. For example, the value 1516925490.087 represents Friday,
  /// January 26, 2018 12:11:30.087 AM.
  final String? completionDate;

  /// Contains identifying information about the creation of a recovery point,
  /// including the <code>BackupPlanArn</code>, <code>BackupPlanId</code>,
  /// <code>BackupPlanVersion</code>, and <code>BackupRuleId</code> of the backup
  /// plan that is used to create it.
  final AwsBackupRecoveryPointCreatedByDetails? createdBy;

  /// The date and time a recovery point is created, in Unix format and UTC. The
  /// value of <code>CreationDate</code> is accurate to milliseconds. For example,
  /// the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087
  /// AM.
  final String? creationDate;

  /// The ARN for the server-side encryption key that is used to protect your
  /// backups.
  final String? encryptionKeyArn;

  /// Specifies the IAM role ARN used to create the target recovery point
  final String? iamRoleArn;

  /// A Boolean value that is returned as <code>TRUE</code> if the specified
  /// recovery point is encrypted, or <code>FALSE</code> if the recovery point is
  /// not encrypted.
  final bool? isEncrypted;

  /// The date and time that a recovery point was last restored, in Unix format
  /// and UTC. The value of <code>LastRestoreTime</code> is accurate to
  /// milliseconds. For example, the value 1516925490.087 represents Friday,
  /// January 26, 2018 12:11:30.087 AM.
  final String? lastRestoreTime;

  /// The lifecycle defines when a protected resource is transitioned to cold
  /// storage and when it expires. Backup transitions and expires backups
  /// automatically according to the lifecycle that you define
  final AwsBackupRecoveryPointLifecycleDetails? lifecycle;

  /// An ARN that uniquely identifies a recovery point.
  final String? recoveryPointArn;

  /// An ARN that uniquely identifies a resource. The format of the ARN depends on
  /// the resource type.
  final String? resourceArn;

  /// The type of Amazon Web Services resource saved as a recovery point, such as
  /// an Amazon EBS volume or an Amazon RDS database.
  final String? resourceType;

  /// The ARN for the backup vault where the recovery point was originally copied
  /// from. If the recovery point is restored to the same account, this value will
  /// be null.
  final String? sourceBackupVaultArn;

  /// A status code specifying the state of the recovery point. Valid values are
  /// as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>COMPLETED</code>
  /// </li>
  /// <li>
  /// <code>DELETING</code>
  /// </li>
  /// <li>
  /// <code>EXPIRED</code>
  /// </li>
  /// <li>
  /// <code>PARTIAL</code>
  /// </li>
  /// </ul>
  final String? status;

  /// A message explaining the reason of the recovery point deletion failure.
  final String? statusMessage;

  /// Specifies the storage class of the recovery point. Valid values are as
  /// follows:
  ///
  /// <ul>
  /// <li>
  /// <code>COLD</code>
  /// </li>
  /// <li>
  /// <code>DELETED</code>
  /// </li>
  /// <li>
  /// <code>WARM</code>
  /// </li>
  /// </ul>
  final String? storageClass;

  AwsBackupRecoveryPointDetails({
    this.backupSizeInBytes,
    this.backupVaultArn,
    this.backupVaultName,
    this.calculatedLifecycle,
    this.completionDate,
    this.createdBy,
    this.creationDate,
    this.encryptionKeyArn,
    this.iamRoleArn,
    this.isEncrypted,
    this.lastRestoreTime,
    this.lifecycle,
    this.recoveryPointArn,
    this.resourceArn,
    this.resourceType,
    this.sourceBackupVaultArn,
    this.status,
    this.statusMessage,
    this.storageClass,
  });

  factory AwsBackupRecoveryPointDetails.fromJson(Map<String, dynamic> json) {
    return AwsBackupRecoveryPointDetails(
      backupSizeInBytes: json['BackupSizeInBytes'] as int?,
      backupVaultArn: json['BackupVaultArn'] as String?,
      backupVaultName: json['BackupVaultName'] as String?,
      calculatedLifecycle: json['CalculatedLifecycle'] != null
          ? AwsBackupRecoveryPointCalculatedLifecycleDetails.fromJson(
              json['CalculatedLifecycle'] as Map<String, dynamic>)
          : null,
      completionDate: json['CompletionDate'] as String?,
      createdBy: json['CreatedBy'] != null
          ? AwsBackupRecoveryPointCreatedByDetails.fromJson(
              json['CreatedBy'] as Map<String, dynamic>)
          : null,
      creationDate: json['CreationDate'] as String?,
      encryptionKeyArn: json['EncryptionKeyArn'] as String?,
      iamRoleArn: json['IamRoleArn'] as String?,
      isEncrypted: json['IsEncrypted'] as bool?,
      lastRestoreTime: json['LastRestoreTime'] as String?,
      lifecycle: json['Lifecycle'] != null
          ? AwsBackupRecoveryPointLifecycleDetails.fromJson(
              json['Lifecycle'] as Map<String, dynamic>)
          : null,
      recoveryPointArn: json['RecoveryPointArn'] as String?,
      resourceArn: json['ResourceArn'] as String?,
      resourceType: json['ResourceType'] as String?,
      sourceBackupVaultArn: json['SourceBackupVaultArn'] as String?,
      status: json['Status'] as String?,
      statusMessage: json['StatusMessage'] as String?,
      storageClass: json['StorageClass'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final backupSizeInBytes = this.backupSizeInBytes;
    final backupVaultArn = this.backupVaultArn;
    final backupVaultName = this.backupVaultName;
    final calculatedLifecycle = this.calculatedLifecycle;
    final completionDate = this.completionDate;
    final createdBy = this.createdBy;
    final creationDate = this.creationDate;
    final encryptionKeyArn = this.encryptionKeyArn;
    final iamRoleArn = this.iamRoleArn;
    final isEncrypted = this.isEncrypted;
    final lastRestoreTime = this.lastRestoreTime;
    final lifecycle = this.lifecycle;
    final recoveryPointArn = this.recoveryPointArn;
    final resourceArn = this.resourceArn;
    final resourceType = this.resourceType;
    final sourceBackupVaultArn = this.sourceBackupVaultArn;
    final status = this.status;
    final statusMessage = this.statusMessage;
    final storageClass = this.storageClass;
    return {
      if (backupSizeInBytes != null) 'BackupSizeInBytes': backupSizeInBytes,
      if (backupVaultArn != null) 'BackupVaultArn': backupVaultArn,
      if (backupVaultName != null) 'BackupVaultName': backupVaultName,
      if (calculatedLifecycle != null)
        'CalculatedLifecycle': calculatedLifecycle,
      if (completionDate != null) 'CompletionDate': completionDate,
      if (createdBy != null) 'CreatedBy': createdBy,
      if (creationDate != null) 'CreationDate': creationDate,
      if (encryptionKeyArn != null) 'EncryptionKeyArn': encryptionKeyArn,
      if (iamRoleArn != null) 'IamRoleArn': iamRoleArn,
      if (isEncrypted != null) 'IsEncrypted': isEncrypted,
      if (lastRestoreTime != null) 'LastRestoreTime': lastRestoreTime,
      if (lifecycle != null) 'Lifecycle': lifecycle,
      if (recoveryPointArn != null) 'RecoveryPointArn': recoveryPointArn,
      if (resourceArn != null) 'ResourceArn': resourceArn,
      if (resourceType != null) 'ResourceType': resourceType,
      if (sourceBackupVaultArn != null)
        'SourceBackupVaultArn': sourceBackupVaultArn,
      if (status != null) 'Status': status,
      if (statusMessage != null) 'StatusMessage': statusMessage,
      if (storageClass != null) 'StorageClass': storageClass,
    };
  }
}

/// Contains an array of Transition objects specifying how long in days before a
/// recovery point transitions to cold storage or is deleted.
class AwsBackupRecoveryPointLifecycleDetails {
  /// Specifies the number of days after creation that a recovery point is
  /// deleted. Must be greater than 90 days plus
  /// <code>MoveToColdStorageAfterDays</code>.
  final int? deleteAfterDays;

  /// Specifies the number of days after creation that a recovery point is moved
  /// to cold storage.
  final int? moveToColdStorageAfterDays;

  AwsBackupRecoveryPointLifecycleDetails({
    this.deleteAfterDays,
    this.moveToColdStorageAfterDays,
  });

  factory AwsBackupRecoveryPointLifecycleDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsBackupRecoveryPointLifecycleDetails(
      deleteAfterDays: json['DeleteAfterDays'] as int?,
      moveToColdStorageAfterDays: json['MoveToColdStorageAfterDays'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final deleteAfterDays = this.deleteAfterDays;
    final moveToColdStorageAfterDays = this.moveToColdStorageAfterDays;
    return {
      if (deleteAfterDays != null) 'DeleteAfterDays': deleteAfterDays,
      if (moveToColdStorageAfterDays != null)
        'MoveToColdStorageAfterDays': moveToColdStorageAfterDays,
    };
  }
}

/// Provides details about an Certificate Manager certificate.
class AwsCertificateManagerCertificateDetails {
  /// The ARN of the private certificate authority (CA) that will be used to issue
  /// the certificate.
  final String? certificateAuthorityArn;

  /// Indicates when the certificate was requested.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdAt;

  /// The fully qualified domain name (FQDN), such as www.example.com, that is
  /// secured by the certificate.
  final String? domainName;

  /// Contains information about the initial validation of each domain name that
  /// occurs as a result of the <code>RequestCertificate</code> request.
  ///
  /// Only provided if the certificate type is <code>AMAZON_ISSUED</code>.
  final List<AwsCertificateManagerCertificateDomainValidationOption>?
      domainValidationOptions;

  /// Contains a list of Extended Key Usage X.509 v3 extension objects. Each
  /// object specifies a purpose for which the certificate public key can be used
  /// and consists of a name and an object identifier (OID).
  final List<AwsCertificateManagerCertificateExtendedKeyUsage>?
      extendedKeyUsages;

  /// For a failed certificate request, the reason for the failure.
  ///
  /// Valid values: <code>NO_AVAILABLE_CONTACTS</code> |
  /// <code>ADDITIONAL_VERIFICATION_REQUIRED</code> |
  /// <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> |
  /// <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> |
  /// <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> |
  /// <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> |
  /// <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> |
  /// <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> |
  /// <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> |
  /// <code>SLR_NOT_FOUND</code> | <code>OTHER</code>
  final String? failureReason;

  /// Indicates when the certificate was imported. Provided if the certificate
  /// type is <code>IMPORTED</code>.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? importedAt;

  /// The list of ARNs for the Amazon Web Services resources that use the
  /// certificate.
  final List<String>? inUseBy;

  /// Indicates when the certificate was issued. Provided if the certificate type
  /// is <code>AMAZON_ISSUED</code>.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? issuedAt;

  /// The name of the certificate authority that issued and signed the
  /// certificate.
  final String? issuer;

  /// The algorithm that was used to generate the public-private key pair.
  ///
  /// Valid values: <code>RSA_2048</code> | <code>RSA_1024</code> |<code>
  /// RSA_4096</code> | <code>EC_prime256v1</code> | <code>EC_secp384r1</code> |
  /// <code>EC_secp521r1</code>
  final String? keyAlgorithm;

  /// A list of key usage X.509 v3 extension objects.
  final List<AwsCertificateManagerCertificateKeyUsage>? keyUsages;

  /// The time after which the certificate becomes invalid.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? notAfter;

  /// The time before which the certificate is not valid.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? notBefore;

  /// Provides a value that specifies whether to add the certificate to a
  /// transparency log.
  final AwsCertificateManagerCertificateOptions? options;

  /// Whether the certificate is eligible for renewal.
  ///
  /// Valid values: <code>ELIGIBLE</code> | <code>INELIGIBLE</code>
  final String? renewalEligibility;

  /// Information about the status of the Certificate Manager managed renewal for
  /// the certificate. Provided only when the certificate type is
  /// <code>AMAZON_ISSUED</code>.
  final AwsCertificateManagerCertificateRenewalSummary? renewalSummary;

  /// The serial number of the certificate.
  final String? serial;

  /// The algorithm that was used to sign the certificate.
  final String? signatureAlgorithm;

  /// The status of the certificate.
  ///
  /// Valid values: <code>PENDING_VALIDATION</code> | <code>ISSUED</code> |
  /// <code>INACTIVE</code> | <code>EXPIRED</code> |
  /// <code>VALIDATION_TIMED_OUT</code> | <code>REVOKED</code> |
  /// <code>FAILED</code>
  final String? status;

  /// The name of the entity that is associated with the public key contained in
  /// the certificate.
  final String? subject;

  /// One or more domain names (subject alternative names) included in the
  /// certificate. This list contains the domain names that are bound to the
  /// public key that is contained in the certificate.
  ///
  /// The subject alternative names include the canonical domain name (CN) of the
  /// certificate and additional domain names that can be used to connect to the
  /// website.
  final List<String>? subjectAlternativeNames;

  /// The source of the certificate. For certificates that Certificate Manager
  /// provides, <code>Type</code> is <code>AMAZON_ISSUED</code>. For certificates
  /// that are imported with <code>ImportCertificate</code>, <code>Type</code> is
  /// <code>IMPORTED</code>.
  ///
  /// Valid values: <code>IMPORTED</code> | <code>AMAZON_ISSUED</code> |
  /// <code>PRIVATE</code>
  final String? type;

  AwsCertificateManagerCertificateDetails({
    this.certificateAuthorityArn,
    this.createdAt,
    this.domainName,
    this.domainValidationOptions,
    this.extendedKeyUsages,
    this.failureReason,
    this.importedAt,
    this.inUseBy,
    this.issuedAt,
    this.issuer,
    this.keyAlgorithm,
    this.keyUsages,
    this.notAfter,
    this.notBefore,
    this.options,
    this.renewalEligibility,
    this.renewalSummary,
    this.serial,
    this.signatureAlgorithm,
    this.status,
    this.subject,
    this.subjectAlternativeNames,
    this.type,
  });

  factory AwsCertificateManagerCertificateDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateDetails(
      certificateAuthorityArn: json['CertificateAuthorityArn'] as String?,
      createdAt: json['CreatedAt'] as String?,
      domainName: json['DomainName'] as String?,
      domainValidationOptions: (json['DomainValidationOptions'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsCertificateManagerCertificateDomainValidationOption.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      extendedKeyUsages: (json['ExtendedKeyUsages'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCertificateManagerCertificateExtendedKeyUsage.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      failureReason: json['FailureReason'] as String?,
      importedAt: json['ImportedAt'] as String?,
      inUseBy: (json['InUseBy'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      issuedAt: json['IssuedAt'] as String?,
      issuer: json['Issuer'] as String?,
      keyAlgorithm: json['KeyAlgorithm'] as String?,
      keyUsages: (json['KeyUsages'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCertificateManagerCertificateKeyUsage.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      notAfter: json['NotAfter'] as String?,
      notBefore: json['NotBefore'] as String?,
      options: json['Options'] != null
          ? AwsCertificateManagerCertificateOptions.fromJson(
              json['Options'] as Map<String, dynamic>)
          : null,
      renewalEligibility: json['RenewalEligibility'] as String?,
      renewalSummary: json['RenewalSummary'] != null
          ? AwsCertificateManagerCertificateRenewalSummary.fromJson(
              json['RenewalSummary'] as Map<String, dynamic>)
          : null,
      serial: json['Serial'] as String?,
      signatureAlgorithm: json['SignatureAlgorithm'] as String?,
      status: json['Status'] as String?,
      subject: json['Subject'] as String?,
      subjectAlternativeNames: (json['SubjectAlternativeNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final certificateAuthorityArn = this.certificateAuthorityArn;
    final createdAt = this.createdAt;
    final domainName = this.domainName;
    final domainValidationOptions = this.domainValidationOptions;
    final extendedKeyUsages = this.extendedKeyUsages;
    final failureReason = this.failureReason;
    final importedAt = this.importedAt;
    final inUseBy = this.inUseBy;
    final issuedAt = this.issuedAt;
    final issuer = this.issuer;
    final keyAlgorithm = this.keyAlgorithm;
    final keyUsages = this.keyUsages;
    final notAfter = this.notAfter;
    final notBefore = this.notBefore;
    final options = this.options;
    final renewalEligibility = this.renewalEligibility;
    final renewalSummary = this.renewalSummary;
    final serial = this.serial;
    final signatureAlgorithm = this.signatureAlgorithm;
    final status = this.status;
    final subject = this.subject;
    final subjectAlternativeNames = this.subjectAlternativeNames;
    final type = this.type;
    return {
      if (certificateAuthorityArn != null)
        'CertificateAuthorityArn': certificateAuthorityArn,
      if (createdAt != null) 'CreatedAt': createdAt,
      if (domainName != null) 'DomainName': domainName,
      if (domainValidationOptions != null)
        'DomainValidationOptions': domainValidationOptions,
      if (extendedKeyUsages != null) 'ExtendedKeyUsages': extendedKeyUsages,
      if (failureReason != null) 'FailureReason': failureReason,
      if (importedAt != null) 'ImportedAt': importedAt,
      if (inUseBy != null) 'InUseBy': inUseBy,
      if (issuedAt != null) 'IssuedAt': issuedAt,
      if (issuer != null) 'Issuer': issuer,
      if (keyAlgorithm != null) 'KeyAlgorithm': keyAlgorithm,
      if (keyUsages != null) 'KeyUsages': keyUsages,
      if (notAfter != null) 'NotAfter': notAfter,
      if (notBefore != null) 'NotBefore': notBefore,
      if (options != null) 'Options': options,
      if (renewalEligibility != null) 'RenewalEligibility': renewalEligibility,
      if (renewalSummary != null) 'RenewalSummary': renewalSummary,
      if (serial != null) 'Serial': serial,
      if (signatureAlgorithm != null) 'SignatureAlgorithm': signatureAlgorithm,
      if (status != null) 'Status': status,
      if (subject != null) 'Subject': subject,
      if (subjectAlternativeNames != null)
        'SubjectAlternativeNames': subjectAlternativeNames,
      if (type != null) 'Type': type,
    };
  }
}

/// Contains information about one of the following:
///
/// <ul>
/// <li>
/// The initial validation of each domain name that occurs as a result of the
/// <code>RequestCertificate</code> request
/// </li>
/// <li>
/// The validation of each domain name in the certificate, as it pertains to
/// Certificate Manager managed renewal
/// </li>
/// </ul>
class AwsCertificateManagerCertificateDomainValidationOption {
  /// A fully qualified domain name (FQDN) in the certificate.
  final String? domainName;

  /// The CNAME record that is added to the DNS database for domain validation.
  final AwsCertificateManagerCertificateResourceRecord? resourceRecord;

  /// The domain name that Certificate Manager uses to send domain validation
  /// emails.
  final String? validationDomain;

  /// A list of email addresses that Certificate Manager uses to send domain
  /// validation emails.
  final List<String>? validationEmails;

  /// The method used to validate the domain name.
  final String? validationMethod;

  /// The validation status of the domain name.
  final String? validationStatus;

  AwsCertificateManagerCertificateDomainValidationOption({
    this.domainName,
    this.resourceRecord,
    this.validationDomain,
    this.validationEmails,
    this.validationMethod,
    this.validationStatus,
  });

  factory AwsCertificateManagerCertificateDomainValidationOption.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateDomainValidationOption(
      domainName: json['DomainName'] as String?,
      resourceRecord: json['ResourceRecord'] != null
          ? AwsCertificateManagerCertificateResourceRecord.fromJson(
              json['ResourceRecord'] as Map<String, dynamic>)
          : null,
      validationDomain: json['ValidationDomain'] as String?,
      validationEmails: (json['ValidationEmails'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      validationMethod: json['ValidationMethod'] as String?,
      validationStatus: json['ValidationStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final domainName = this.domainName;
    final resourceRecord = this.resourceRecord;
    final validationDomain = this.validationDomain;
    final validationEmails = this.validationEmails;
    final validationMethod = this.validationMethod;
    final validationStatus = this.validationStatus;
    return {
      if (domainName != null) 'DomainName': domainName,
      if (resourceRecord != null) 'ResourceRecord': resourceRecord,
      if (validationDomain != null) 'ValidationDomain': validationDomain,
      if (validationEmails != null) 'ValidationEmails': validationEmails,
      if (validationMethod != null) 'ValidationMethod': validationMethod,
      if (validationStatus != null) 'ValidationStatus': validationStatus,
    };
  }
}

/// Contains information about an extended key usage X.509 v3 extension object.
class AwsCertificateManagerCertificateExtendedKeyUsage {
  /// The name of an extension value. Indicates the purpose for which the
  /// certificate public key can be used.
  final String? name;

  /// An object identifier (OID) for the extension value.
  ///
  /// The format is numbers separated by periods.
  final String? oId;

  AwsCertificateManagerCertificateExtendedKeyUsage({
    this.name,
    this.oId,
  });

  factory AwsCertificateManagerCertificateExtendedKeyUsage.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateExtendedKeyUsage(
      name: json['Name'] as String?,
      oId: json['OId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final oId = this.oId;
    return {
      if (name != null) 'Name': name,
      if (oId != null) 'OId': oId,
    };
  }
}

/// Contains information about a key usage X.509 v3 extension object.
class AwsCertificateManagerCertificateKeyUsage {
  /// The key usage extension name.
  final String? name;

  AwsCertificateManagerCertificateKeyUsage({
    this.name,
  });

  factory AwsCertificateManagerCertificateKeyUsage.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateKeyUsage(
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      if (name != null) 'Name': name,
    };
  }
}

/// Contains other options for the certificate.
class AwsCertificateManagerCertificateOptions {
  /// Whether to add the certificate to a transparency log.
  ///
  /// Valid values: <code>DISABLED</code> | <code>ENABLED</code>
  final String? certificateTransparencyLoggingPreference;

  AwsCertificateManagerCertificateOptions({
    this.certificateTransparencyLoggingPreference,
  });

  factory AwsCertificateManagerCertificateOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateOptions(
      certificateTransparencyLoggingPreference:
          json['CertificateTransparencyLoggingPreference'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final certificateTransparencyLoggingPreference =
        this.certificateTransparencyLoggingPreference;
    return {
      if (certificateTransparencyLoggingPreference != null)
        'CertificateTransparencyLoggingPreference':
            certificateTransparencyLoggingPreference,
    };
  }
}

/// Contains information about the Certificate Manager managed renewal for an
/// <code>AMAZON_ISSUED</code> certificate.
class AwsCertificateManagerCertificateRenewalSummary {
  /// Information about the validation of each domain name in the certificate, as
  /// it pertains to Certificate Manager managed renewal. Provided only when the
  /// certificate type is <code>AMAZON_ISSUED</code>.
  final List<AwsCertificateManagerCertificateDomainValidationOption>?
      domainValidationOptions;

  /// The status of the Certificate Manager managed renewal of the certificate.
  ///
  /// Valid values: <code>PENDING_AUTO_RENEWAL</code> |
  /// <code>PENDING_VALIDATION</code> | <code>SUCCESS</code> | <code>FAILED</code>
  final String? renewalStatus;

  /// The reason that a renewal request was unsuccessful. This attribute is used
  /// only when <code>RenewalStatus</code> is <code>FAILED</code>.
  ///
  /// Valid values: <code>NO_AVAILABLE_CONTACTS</code> |
  /// <code>ADDITIONAL_VERIFICATION_REQUIRED</code> |
  /// <code>DOMAIN_NOT_ALLOWED</code> | <code>INVALID_PUBLIC_DOMAIN</code> |
  /// <code>DOMAIN_VALIDATION_DENIED</code> | <code>CAA_ERROR</code> |
  /// <code>PCA_LIMIT_EXCEEDED</code> | <code>PCA_INVALID_ARN</code> |
  /// <code>PCA_INVALID_STATE</code> | <code>PCA_REQUEST_FAILED</code> |
  /// <code>PCA_NAME_CONSTRAINTS_VALIDATION</code> |
  /// <code>PCA_RESOURCE_NOT_FOUND</code> | <code>PCA_INVALID_ARGS</code> |
  /// <code>PCA_INVALID_DURATION</code> | <code>PCA_ACCESS_DENIED</code> |
  /// <code>SLR_NOT_FOUND</code> | <code>OTHER</code>
  final String? renewalStatusReason;

  /// Indicates when the renewal summary was last updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? updatedAt;

  AwsCertificateManagerCertificateRenewalSummary({
    this.domainValidationOptions,
    this.renewalStatus,
    this.renewalStatusReason,
    this.updatedAt,
  });

  factory AwsCertificateManagerCertificateRenewalSummary.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateRenewalSummary(
      domainValidationOptions: (json['DomainValidationOptions'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsCertificateManagerCertificateDomainValidationOption.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      renewalStatus: json['RenewalStatus'] as String?,
      renewalStatusReason: json['RenewalStatusReason'] as String?,
      updatedAt: json['UpdatedAt'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final domainValidationOptions = this.domainValidationOptions;
    final renewalStatus = this.renewalStatus;
    final renewalStatusReason = this.renewalStatusReason;
    final updatedAt = this.updatedAt;
    return {
      if (domainValidationOptions != null)
        'DomainValidationOptions': domainValidationOptions,
      if (renewalStatus != null) 'RenewalStatus': renewalStatus,
      if (renewalStatusReason != null)
        'RenewalStatusReason': renewalStatusReason,
      if (updatedAt != null) 'UpdatedAt': updatedAt,
    };
  }
}

/// Provides details about the CNAME record that is added to the DNS database
/// for domain validation.
class AwsCertificateManagerCertificateResourceRecord {
  /// The name of the resource.
  final String? name;

  /// The type of resource.
  final String? type;

  /// The value of the resource.
  final String? value;

  AwsCertificateManagerCertificateResourceRecord({
    this.name,
    this.type,
    this.value,
  });

  factory AwsCertificateManagerCertificateResourceRecord.fromJson(
      Map<String, dynamic> json) {
    return AwsCertificateManagerCertificateResourceRecord(
      name: json['Name'] as String?,
      type: json['Type'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final type = this.type;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (type != null) 'Type': type,
      if (value != null) 'Value': value,
    };
  }
}

/// Nests a stack as a resource in a top-level template. Nested stacks are
/// stacks created as resources for another stack.
class AwsCloudFormationStackDetails {
  /// The capabilities allowed in the stack.
  final List<String>? capabilities;

  /// The time at which the stack was created.
  final String? creationTime;

  /// A user-defined description associated with the stack.
  final String? description;

  /// Boolean to enable or disable rollback on stack creation failures.
  final bool? disableRollback;

  /// Information about whether a stack's actual configuration differs, or has
  /// drifted, from its expected configuration, as defined in the stack template
  /// and any values specified as template parameters.
  final AwsCloudFormationStackDriftInformationDetails? driftInformation;

  /// Whether termination protection is enabled for the stack.
  final bool? enableTerminationProtection;

  /// The time the nested stack was last updated. This field will only be returned
  /// if the stack has been updated at least once.
  final String? lastUpdatedTime;

  /// The Amazon Resource Names (ARNs) of the Amazon SNS topic to which
  /// stack-related events are published.
  final List<String>? notificationArns;

  /// A list of output structures.
  final List<AwsCloudFormationStackOutputsDetails>? outputs;

  /// The ARN of an IAM role that's associated with the stack.
  final String? roleArn;

  /// Unique identifier of the stack.
  final String? stackId;

  /// The name associated with the stack.
  final String? stackName;

  /// Current status of the stack.
  final String? stackStatus;

  /// Success or failure message associated with the stack status.
  final String? stackStatusReason;

  /// The length of time, in minutes, that CloudFormation waits for the nested
  /// stack to reach the <code>CREATE_COMPLETE</code> state.
  final int? timeoutInMinutes;

  AwsCloudFormationStackDetails({
    this.capabilities,
    this.creationTime,
    this.description,
    this.disableRollback,
    this.driftInformation,
    this.enableTerminationProtection,
    this.lastUpdatedTime,
    this.notificationArns,
    this.outputs,
    this.roleArn,
    this.stackId,
    this.stackName,
    this.stackStatus,
    this.stackStatusReason,
    this.timeoutInMinutes,
  });

  factory AwsCloudFormationStackDetails.fromJson(Map<String, dynamic> json) {
    return AwsCloudFormationStackDetails(
      capabilities: (json['Capabilities'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      creationTime: json['CreationTime'] as String?,
      description: json['Description'] as String?,
      disableRollback: json['DisableRollback'] as bool?,
      driftInformation: json['DriftInformation'] != null
          ? AwsCloudFormationStackDriftInformationDetails.fromJson(
              json['DriftInformation'] as Map<String, dynamic>)
          : null,
      enableTerminationProtection: json['EnableTerminationProtection'] as bool?,
      lastUpdatedTime: json['LastUpdatedTime'] as String?,
      notificationArns: (json['NotificationArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      outputs: (json['Outputs'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCloudFormationStackOutputsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      roleArn: json['RoleArn'] as String?,
      stackId: json['StackId'] as String?,
      stackName: json['StackName'] as String?,
      stackStatus: json['StackStatus'] as String?,
      stackStatusReason: json['StackStatusReason'] as String?,
      timeoutInMinutes: json['TimeoutInMinutes'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final capabilities = this.capabilities;
    final creationTime = this.creationTime;
    final description = this.description;
    final disableRollback = this.disableRollback;
    final driftInformation = this.driftInformation;
    final enableTerminationProtection = this.enableTerminationProtection;
    final lastUpdatedTime = this.lastUpdatedTime;
    final notificationArns = this.notificationArns;
    final outputs = this.outputs;
    final roleArn = this.roleArn;
    final stackId = this.stackId;
    final stackName = this.stackName;
    final stackStatus = this.stackStatus;
    final stackStatusReason = this.stackStatusReason;
    final timeoutInMinutes = this.timeoutInMinutes;
    return {
      if (capabilities != null) 'Capabilities': capabilities,
      if (creationTime != null) 'CreationTime': creationTime,
      if (description != null) 'Description': description,
      if (disableRollback != null) 'DisableRollback': disableRollback,
      if (driftInformation != null) 'DriftInformation': driftInformation,
      if (enableTerminationProtection != null)
        'EnableTerminationProtection': enableTerminationProtection,
      if (lastUpdatedTime != null) 'LastUpdatedTime': lastUpdatedTime,
      if (notificationArns != null) 'NotificationArns': notificationArns,
      if (outputs != null) 'Outputs': outputs,
      if (roleArn != null) 'RoleArn': roleArn,
      if (stackId != null) 'StackId': stackId,
      if (stackName != null) 'StackName': stackName,
      if (stackStatus != null) 'StackStatus': stackStatus,
      if (stackStatusReason != null) 'StackStatusReason': stackStatusReason,
      if (timeoutInMinutes != null) 'TimeoutInMinutes': timeoutInMinutes,
    };
  }
}

/// Provides information about the stack's conformity to its expected template
/// configuration.
class AwsCloudFormationStackDriftInformationDetails {
  /// Status of the stack's actual configuration compared to its expected template
  /// configuration.
  final String? stackDriftStatus;

  AwsCloudFormationStackDriftInformationDetails({
    this.stackDriftStatus,
  });

  factory AwsCloudFormationStackDriftInformationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFormationStackDriftInformationDetails(
      stackDriftStatus: json['StackDriftStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final stackDriftStatus = this.stackDriftStatus;
    return {
      if (stackDriftStatus != null) 'StackDriftStatus': stackDriftStatus,
    };
  }
}

/// Provides information about the CloudFormation stack output.
class AwsCloudFormationStackOutputsDetails {
  /// A user-defined description associated with the output.
  final String? description;

  /// The key associated with the output.
  final String? outputKey;

  /// The value associated with the output.
  final String? outputValue;

  AwsCloudFormationStackOutputsDetails({
    this.description,
    this.outputKey,
    this.outputValue,
  });

  factory AwsCloudFormationStackOutputsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFormationStackOutputsDetails(
      description: json['Description'] as String?,
      outputKey: json['OutputKey'] as String?,
      outputValue: json['OutputValue'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final outputKey = this.outputKey;
    final outputValue = this.outputValue;
    return {
      if (description != null) 'Description': description,
      if (outputKey != null) 'OutputKey': outputKey,
      if (outputValue != null) 'OutputValue': outputValue,
    };
  }
}

/// Information about a cache behavior for the distribution.
class AwsCloudFrontDistributionCacheBehavior {
  /// The protocol that viewers can use to access the files in an origin. You can
  /// specify the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>allow-all</code> - Viewers can use HTTP or HTTPS.
  /// </li>
  /// <li>
  /// <code>redirect-to-https</code> - CloudFront responds to HTTP requests with
  /// an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer
  /// then uses the new URL to resubmit.
  /// </li>
  /// <li>
  /// <code>https-only</code> - CloudFront responds to HTTP request with an HTTP
  /// status code of 403 (Forbidden).
  /// </li>
  /// </ul>
  final String? viewerProtocolPolicy;

  AwsCloudFrontDistributionCacheBehavior({
    this.viewerProtocolPolicy,
  });

  factory AwsCloudFrontDistributionCacheBehavior.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionCacheBehavior(
      viewerProtocolPolicy: json['ViewerProtocolPolicy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final viewerProtocolPolicy = this.viewerProtocolPolicy;
    return {
      if (viewerProtocolPolicy != null)
        'ViewerProtocolPolicy': viewerProtocolPolicy,
    };
  }
}

/// Provides information about caching for the CloudFront distribution.
class AwsCloudFrontDistributionCacheBehaviors {
  /// The cache behaviors for the distribution.
  final List<AwsCloudFrontDistributionCacheBehavior>? items;

  AwsCloudFrontDistributionCacheBehaviors({
    this.items,
  });

  factory AwsCloudFrontDistributionCacheBehaviors.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionCacheBehaviors(
      items: (json['Items'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCloudFrontDistributionCacheBehavior.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final items = this.items;
    return {
      if (items != null) 'Items': items,
    };
  }
}

/// Contains information about the default cache configuration for the
/// CloudFront distribution.
class AwsCloudFrontDistributionDefaultCacheBehavior {
  /// The protocol that viewers can use to access the files in an origin. You can
  /// specify the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>allow-all</code> - Viewers can use HTTP or HTTPS.
  /// </li>
  /// <li>
  /// <code>redirect-to-https</code> - CloudFront responds to HTTP requests with
  /// an HTTP status code of 301 (Moved Permanently) and the HTTPS URL. The viewer
  /// then uses the new URL to resubmit.
  /// </li>
  /// <li>
  /// <code>https-only</code> - CloudFront responds to HTTP request with an HTTP
  /// status code of 403 (Forbidden).
  /// </li>
  /// </ul>
  final String? viewerProtocolPolicy;

  AwsCloudFrontDistributionDefaultCacheBehavior({
    this.viewerProtocolPolicy,
  });

  factory AwsCloudFrontDistributionDefaultCacheBehavior.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionDefaultCacheBehavior(
      viewerProtocolPolicy: json['ViewerProtocolPolicy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final viewerProtocolPolicy = this.viewerProtocolPolicy;
    return {
      if (viewerProtocolPolicy != null)
        'ViewerProtocolPolicy': viewerProtocolPolicy,
    };
  }
}

/// A CloudFront distribution configuration.
class AwsCloudFrontDistributionDetails {
  /// Provides information about the cache configuration for the distribution.
  final AwsCloudFrontDistributionCacheBehaviors? cacheBehaviors;

  /// The default cache behavior for the configuration.
  final AwsCloudFrontDistributionDefaultCacheBehavior? defaultCacheBehavior;

  /// The object that CloudFront sends in response to requests from the origin
  /// (for example, index.html) when a viewer requests the root URL for the
  /// distribution (http://www.example.com) instead of an object in your
  /// distribution (http://www.example.com/product-description.html).
  final String? defaultRootObject;

  /// The domain name corresponding to the distribution.
  final String? domainName;

  /// The entity tag is a hash of the object.
  final String? eTag;

  /// Indicates when that the distribution was last modified.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastModifiedTime;

  /// A complex type that controls whether access logs are written for the
  /// distribution.
  final AwsCloudFrontDistributionLogging? logging;

  /// Provides information about the origin groups in the distribution.
  final AwsCloudFrontDistributionOriginGroups? originGroups;

  /// A complex type that contains information about origins for this
  /// distribution.
  final AwsCloudFrontDistributionOrigins? origins;

  /// Indicates the current status of the distribution.
  final String? status;

  /// Provides information about the TLS/SSL configuration that the distribution
  /// uses to communicate with viewers.
  final AwsCloudFrontDistributionViewerCertificate? viewerCertificate;

  /// A unique identifier that specifies the WAF web ACL, if any, to associate
  /// with this distribution.
  final String? webAclId;

  AwsCloudFrontDistributionDetails({
    this.cacheBehaviors,
    this.defaultCacheBehavior,
    this.defaultRootObject,
    this.domainName,
    this.eTag,
    this.lastModifiedTime,
    this.logging,
    this.originGroups,
    this.origins,
    this.status,
    this.viewerCertificate,
    this.webAclId,
  });

  factory AwsCloudFrontDistributionDetails.fromJson(Map<String, dynamic> json) {
    return AwsCloudFrontDistributionDetails(
      cacheBehaviors: json['CacheBehaviors'] != null
          ? AwsCloudFrontDistributionCacheBehaviors.fromJson(
              json['CacheBehaviors'] as Map<String, dynamic>)
          : null,
      defaultCacheBehavior: json['DefaultCacheBehavior'] != null
          ? AwsCloudFrontDistributionDefaultCacheBehavior.fromJson(
              json['DefaultCacheBehavior'] as Map<String, dynamic>)
          : null,
      defaultRootObject: json['DefaultRootObject'] as String?,
      domainName: json['DomainName'] as String?,
      eTag: json['ETag'] as String?,
      lastModifiedTime: json['LastModifiedTime'] as String?,
      logging: json['Logging'] != null
          ? AwsCloudFrontDistributionLogging.fromJson(
              json['Logging'] as Map<String, dynamic>)
          : null,
      originGroups: json['OriginGroups'] != null
          ? AwsCloudFrontDistributionOriginGroups.fromJson(
              json['OriginGroups'] as Map<String, dynamic>)
          : null,
      origins: json['Origins'] != null
          ? AwsCloudFrontDistributionOrigins.fromJson(
              json['Origins'] as Map<String, dynamic>)
          : null,
      status: json['Status'] as String?,
      viewerCertificate: json['ViewerCertificate'] != null
          ? AwsCloudFrontDistributionViewerCertificate.fromJson(
              json['ViewerCertificate'] as Map<String, dynamic>)
          : null,
      webAclId: json['WebAclId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cacheBehaviors = this.cacheBehaviors;
    final defaultCacheBehavior = this.defaultCacheBehavior;
    final defaultRootObject = this.defaultRootObject;
    final domainName = this.domainName;
    final eTag = this.eTag;
    final lastModifiedTime = this.lastModifiedTime;
    final logging = this.logging;
    final originGroups = this.originGroups;
    final origins = this.origins;
    final status = this.status;
    final viewerCertificate = this.viewerCertificate;
    final webAclId = this.webAclId;
    return {
      if (cacheBehaviors != null) 'CacheBehaviors': cacheBehaviors,
      if (defaultCacheBehavior != null)
        'DefaultCacheBehavior': defaultCacheBehavior,
      if (defaultRootObject != null) 'DefaultRootObject': defaultRootObject,
      if (domainName != null) 'DomainName': domainName,
      if (eTag != null) 'ETag': eTag,
      if (lastModifiedTime != null) 'LastModifiedTime': lastModifiedTime,
      if (logging != null) 'Logging': logging,
      if (originGroups != null) 'OriginGroups': originGroups,
      if (origins != null) 'Origins': origins,
      if (status != null) 'Status': status,
      if (viewerCertificate != null) 'ViewerCertificate': viewerCertificate,
      if (webAclId != null) 'WebAclId': webAclId,
    };
  }
}

/// A complex type that controls whether access logs are written for the
/// CloudFront distribution.
class AwsCloudFrontDistributionLogging {
  /// The S3 bucket to store the access logs in.
  final String? bucket;

  /// With this field, you can enable or disable the selected distribution.
  final bool? enabled;

  /// Specifies whether you want CloudFront to include cookies in access logs.
  final bool? includeCookies;

  /// An optional string that you want CloudFront to use as a prefix to the access
  /// log filenames for this distribution.
  final String? prefix;

  AwsCloudFrontDistributionLogging({
    this.bucket,
    this.enabled,
    this.includeCookies,
    this.prefix,
  });

  factory AwsCloudFrontDistributionLogging.fromJson(Map<String, dynamic> json) {
    return AwsCloudFrontDistributionLogging(
      bucket: json['Bucket'] as String?,
      enabled: json['Enabled'] as bool?,
      includeCookies: json['IncludeCookies'] as bool?,
      prefix: json['Prefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final bucket = this.bucket;
    final enabled = this.enabled;
    final includeCookies = this.includeCookies;
    final prefix = this.prefix;
    return {
      if (bucket != null) 'Bucket': bucket,
      if (enabled != null) 'Enabled': enabled,
      if (includeCookies != null) 'IncludeCookies': includeCookies,
      if (prefix != null) 'Prefix': prefix,
    };
  }
}

/// A custom origin. A custom origin is any origin that is not an Amazon S3
/// bucket, with one exception. An Amazon S3 bucket that is <a
/// href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">configured
/// with static website hosting</a> is a custom origin.
class AwsCloudFrontDistributionOriginCustomOriginConfig {
  /// The HTTP port that CloudFront uses to connect to the origin.
  final int? httpPort;

  /// The HTTPS port that CloudFront uses to connect to the origin.
  final int? httpsPort;

  /// Specifies how long, in seconds, CloudFront persists its connection to the
  /// origin.
  final int? originKeepaliveTimeout;

  /// Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to
  /// the origin.
  final String? originProtocolPolicy;

  /// Specifies how long, in seconds, CloudFront waits for a response from the
  /// origin.
  final int? originReadTimeout;

  /// Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting
  /// to your origin over HTTPS.
  final AwsCloudFrontDistributionOriginSslProtocols? originSslProtocols;

  AwsCloudFrontDistributionOriginCustomOriginConfig({
    this.httpPort,
    this.httpsPort,
    this.originKeepaliveTimeout,
    this.originProtocolPolicy,
    this.originReadTimeout,
    this.originSslProtocols,
  });

  factory AwsCloudFrontDistributionOriginCustomOriginConfig.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginCustomOriginConfig(
      httpPort: json['HttpPort'] as int?,
      httpsPort: json['HttpsPort'] as int?,
      originKeepaliveTimeout: json['OriginKeepaliveTimeout'] as int?,
      originProtocolPolicy: json['OriginProtocolPolicy'] as String?,
      originReadTimeout: json['OriginReadTimeout'] as int?,
      originSslProtocols: json['OriginSslProtocols'] != null
          ? AwsCloudFrontDistributionOriginSslProtocols.fromJson(
              json['OriginSslProtocols'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final httpPort = this.httpPort;
    final httpsPort = this.httpsPort;
    final originKeepaliveTimeout = this.originKeepaliveTimeout;
    final originProtocolPolicy = this.originProtocolPolicy;
    final originReadTimeout = this.originReadTimeout;
    final originSslProtocols = this.originSslProtocols;
    return {
      if (httpPort != null) 'HttpPort': httpPort,
      if (httpsPort != null) 'HttpsPort': httpsPort,
      if (originKeepaliveTimeout != null)
        'OriginKeepaliveTimeout': originKeepaliveTimeout,
      if (originProtocolPolicy != null)
        'OriginProtocolPolicy': originProtocolPolicy,
      if (originReadTimeout != null) 'OriginReadTimeout': originReadTimeout,
      if (originSslProtocols != null) 'OriginSslProtocols': originSslProtocols,
    };
  }
}

/// Information about an origin group for the CloudFront distribution.
class AwsCloudFrontDistributionOriginGroup {
  /// Provides the criteria for an origin group to fail over.
  final AwsCloudFrontDistributionOriginGroupFailover? failoverCriteria;

  AwsCloudFrontDistributionOriginGroup({
    this.failoverCriteria,
  });

  factory AwsCloudFrontDistributionOriginGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginGroup(
      failoverCriteria: json['FailoverCriteria'] != null
          ? AwsCloudFrontDistributionOriginGroupFailover.fromJson(
              json['FailoverCriteria'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final failoverCriteria = this.failoverCriteria;
    return {
      if (failoverCriteria != null) 'FailoverCriteria': failoverCriteria,
    };
  }
}

/// Provides information about when an origin group fails over.
class AwsCloudFrontDistributionOriginGroupFailover {
  /// Information about the status codes that cause an origin group to fail over.
  final AwsCloudFrontDistributionOriginGroupFailoverStatusCodes? statusCodes;

  AwsCloudFrontDistributionOriginGroupFailover({
    this.statusCodes,
  });

  factory AwsCloudFrontDistributionOriginGroupFailover.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginGroupFailover(
      statusCodes: json['StatusCodes'] != null
          ? AwsCloudFrontDistributionOriginGroupFailoverStatusCodes.fromJson(
              json['StatusCodes'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final statusCodes = this.statusCodes;
    return {
      if (statusCodes != null) 'StatusCodes': statusCodes,
    };
  }
}

/// The status codes that cause an origin group to fail over.
class AwsCloudFrontDistributionOriginGroupFailoverStatusCodes {
  /// The list of status code values that can cause a failover to the next origin.
  final List<int>? items;

  /// The number of status codes that can cause a failover.
  final int? quantity;

  AwsCloudFrontDistributionOriginGroupFailoverStatusCodes({
    this.items,
    this.quantity,
  });

  factory AwsCloudFrontDistributionOriginGroupFailoverStatusCodes.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginGroupFailoverStatusCodes(
      items: (json['Items'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      quantity: json['Quantity'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final items = this.items;
    final quantity = this.quantity;
    return {
      if (items != null) 'Items': items,
      if (quantity != null) 'Quantity': quantity,
    };
  }
}

/// Provides information about origin groups that are associated with the
/// CloudFront distribution.
class AwsCloudFrontDistributionOriginGroups {
  /// The list of origin groups.
  final List<AwsCloudFrontDistributionOriginGroup>? items;

  AwsCloudFrontDistributionOriginGroups({
    this.items,
  });

  factory AwsCloudFrontDistributionOriginGroups.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginGroups(
      items: (json['Items'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCloudFrontDistributionOriginGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final items = this.items;
    return {
      if (items != null) 'Items': items,
    };
  }
}

/// A complex type that describes the Amazon S3 bucket, HTTP server (for
/// example, a web server), Elemental MediaStore, or other server from which
/// CloudFront gets your files.
class AwsCloudFrontDistributionOriginItem {
  /// An origin that is not an Amazon S3 bucket, with one exception. If the Amazon
  /// S3 bucket is configured with static website hosting, use this attribute. If
  /// the Amazon S3 bucket is not configured with static website hosting, use the
  /// <code>S3OriginConfig</code> type instead.
  final AwsCloudFrontDistributionOriginCustomOriginConfig? customOriginConfig;

  /// Amazon S3 origins: The DNS name of the S3 bucket from which you want
  /// CloudFront to get objects for this origin.
  final String? domainName;

  /// A unique identifier for the origin or origin group.
  final String? id;

  /// An optional element that causes CloudFront to request your content from a
  /// directory in your Amazon S3 bucket or your custom origin.
  final String? originPath;

  /// An origin that is an S3 bucket that is not configured with static website
  /// hosting.
  final AwsCloudFrontDistributionOriginS3OriginConfig? s3OriginConfig;

  AwsCloudFrontDistributionOriginItem({
    this.customOriginConfig,
    this.domainName,
    this.id,
    this.originPath,
    this.s3OriginConfig,
  });

  factory AwsCloudFrontDistributionOriginItem.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginItem(
      customOriginConfig: json['CustomOriginConfig'] != null
          ? AwsCloudFrontDistributionOriginCustomOriginConfig.fromJson(
              json['CustomOriginConfig'] as Map<String, dynamic>)
          : null,
      domainName: json['DomainName'] as String?,
      id: json['Id'] as String?,
      originPath: json['OriginPath'] as String?,
      s3OriginConfig: json['S3OriginConfig'] != null
          ? AwsCloudFrontDistributionOriginS3OriginConfig.fromJson(
              json['S3OriginConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customOriginConfig = this.customOriginConfig;
    final domainName = this.domainName;
    final id = this.id;
    final originPath = this.originPath;
    final s3OriginConfig = this.s3OriginConfig;
    return {
      if (customOriginConfig != null) 'CustomOriginConfig': customOriginConfig,
      if (domainName != null) 'DomainName': domainName,
      if (id != null) 'Id': id,
      if (originPath != null) 'OriginPath': originPath,
      if (s3OriginConfig != null) 'S3OriginConfig': s3OriginConfig,
    };
  }
}

/// Information about an origin that is an Amazon S3 bucket that is not
/// configured with static website hosting.
class AwsCloudFrontDistributionOriginS3OriginConfig {
  /// The CloudFront origin access identity to associate with the origin.
  final String? originAccessIdentity;

  AwsCloudFrontDistributionOriginS3OriginConfig({
    this.originAccessIdentity,
  });

  factory AwsCloudFrontDistributionOriginS3OriginConfig.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginS3OriginConfig(
      originAccessIdentity: json['OriginAccessIdentity'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final originAccessIdentity = this.originAccessIdentity;
    return {
      if (originAccessIdentity != null)
        'OriginAccessIdentity': originAccessIdentity,
    };
  }
}

/// A complex type that contains information about the SSL/TLS protocols that
/// CloudFront can use when establishing an HTTPS connection with your origin.
class AwsCloudFrontDistributionOriginSslProtocols {
  /// A list that contains allowed SSL/TLS protocols for this distribution.
  final List<String>? items;

  /// The number of SSL/TLS protocols that you want to allow CloudFront to use
  /// when establishing an HTTPS connection with this origin.
  final int? quantity;

  AwsCloudFrontDistributionOriginSslProtocols({
    this.items,
    this.quantity,
  });

  factory AwsCloudFrontDistributionOriginSslProtocols.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOriginSslProtocols(
      items: (json['Items'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      quantity: json['Quantity'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final items = this.items;
    final quantity = this.quantity;
    return {
      if (items != null) 'Items': items,
      if (quantity != null) 'Quantity': quantity,
    };
  }
}

/// A complex type that contains information about origins and origin groups for
/// this CloudFront distribution.
class AwsCloudFrontDistributionOrigins {
  /// A complex type that contains origins or origin groups for this distribution.
  final List<AwsCloudFrontDistributionOriginItem>? items;

  AwsCloudFrontDistributionOrigins({
    this.items,
  });

  factory AwsCloudFrontDistributionOrigins.fromJson(Map<String, dynamic> json) {
    return AwsCloudFrontDistributionOrigins(
      items: (json['Items'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCloudFrontDistributionOriginItem.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final items = this.items;
    return {
      if (items != null) 'Items': items,
    };
  }
}

/// Provides information about the TLS/SSL configuration that the CloudFront
/// distribution uses to communicate with viewers.
class AwsCloudFrontDistributionViewerCertificate {
  /// The ARN of the ACM certificate. Used if the certificate is stored in ACM. If
  /// you provide an ACM certificate ARN, you must also provide
  /// <code>MinimumCertificateVersion</code> and <code>SslSupportMethod</code>.
  final String? acmCertificateArn;

  /// The identifier of the certificate. Note that in CloudFront, this attribute
  /// is deprecated.
  final String? certificate;

  /// The source of the certificate identified by <code>Certificate</code>. Note
  /// that in CloudFront, this attribute is deprecated.
  final String? certificateSource;

  /// Whether the distribution uses the CloudFront domain name. If set to
  /// <code>false</code>, then you provide either <code>AcmCertificateArn</code>
  /// or <code>IamCertificateId</code>.
  final bool? cloudFrontDefaultCertificate;

  /// The identifier of the IAM certificate. Used if the certificate is stored in
  /// IAM. If you provide <code>IamCertificateId</code>, then you also must
  /// provide <code>MinimumProtocolVersion</code> and
  /// <code>SslSupportMethod</code>.
  final String? iamCertificateId;

  /// The security policy that CloudFront uses for HTTPS connections with viewers.
  /// If <code>SslSupportMethod</code> is <code>sni-only</code>, then
  /// <code>MinimumProtocolVersion</code> must be <code>TLSv1</code> or higher.
  final String? minimumProtocolVersion;

  /// The viewers that the distribution accepts HTTPS connections from.
  final String? sslSupportMethod;

  AwsCloudFrontDistributionViewerCertificate({
    this.acmCertificateArn,
    this.certificate,
    this.certificateSource,
    this.cloudFrontDefaultCertificate,
    this.iamCertificateId,
    this.minimumProtocolVersion,
    this.sslSupportMethod,
  });

  factory AwsCloudFrontDistributionViewerCertificate.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudFrontDistributionViewerCertificate(
      acmCertificateArn: json['AcmCertificateArn'] as String?,
      certificate: json['Certificate'] as String?,
      certificateSource: json['CertificateSource'] as String?,
      cloudFrontDefaultCertificate:
          json['CloudFrontDefaultCertificate'] as bool?,
      iamCertificateId: json['IamCertificateId'] as String?,
      minimumProtocolVersion: json['MinimumProtocolVersion'] as String?,
      sslSupportMethod: json['SslSupportMethod'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final acmCertificateArn = this.acmCertificateArn;
    final certificate = this.certificate;
    final certificateSource = this.certificateSource;
    final cloudFrontDefaultCertificate = this.cloudFrontDefaultCertificate;
    final iamCertificateId = this.iamCertificateId;
    final minimumProtocolVersion = this.minimumProtocolVersion;
    final sslSupportMethod = this.sslSupportMethod;
    return {
      if (acmCertificateArn != null) 'AcmCertificateArn': acmCertificateArn,
      if (certificate != null) 'Certificate': certificate,
      if (certificateSource != null) 'CertificateSource': certificateSource,
      if (cloudFrontDefaultCertificate != null)
        'CloudFrontDefaultCertificate': cloudFrontDefaultCertificate,
      if (iamCertificateId != null) 'IamCertificateId': iamCertificateId,
      if (minimumProtocolVersion != null)
        'MinimumProtocolVersion': minimumProtocolVersion,
      if (sslSupportMethod != null) 'SslSupportMethod': sslSupportMethod,
    };
  }
}

/// Provides details about a CloudTrail trail.
class AwsCloudTrailTrailDetails {
  /// The ARN of the log group that CloudTrail logs are delivered to.
  final String? cloudWatchLogsLogGroupArn;

  /// The ARN of the role that the CloudWatch Events endpoint assumes when it
  /// writes to the log group.
  final String? cloudWatchLogsRoleArn;

  /// Indicates whether the trail has custom event selectors.
  final bool? hasCustomEventSelectors;

  /// The Region where the trail was created.
  final String? homeRegion;

  /// Indicates whether the trail publishes events from global services such as
  /// IAM to the log files.
  final bool? includeGlobalServiceEvents;

  /// Indicates whether the trail applies only to the current Region or to all
  /// Regions.
  final bool? isMultiRegionTrail;

  /// Whether the trail is created for all accounts in an organization in
  /// Organizations, or only for the current Amazon Web Services account.
  final bool? isOrganizationTrail;

  /// The KMS key ID to use to encrypt the logs.
  final String? kmsKeyId;

  /// Indicates whether CloudTrail log file validation is enabled.
  final bool? logFileValidationEnabled;

  /// The name of the trail.
  final String? name;

  /// The name of the S3 bucket where the log files are published.
  final String? s3BucketName;

  /// The S3 key prefix. The key prefix is added after the name of the S3 bucket
  /// where the log files are published.
  final String? s3KeyPrefix;

  /// The ARN of the SNS topic that is used for notifications of log file
  /// delivery.
  final String? snsTopicArn;

  /// The name of the SNS topic that is used for notifications of log file
  /// delivery.
  final String? snsTopicName;

  /// The ARN of the trail.
  final String? trailArn;

  AwsCloudTrailTrailDetails({
    this.cloudWatchLogsLogGroupArn,
    this.cloudWatchLogsRoleArn,
    this.hasCustomEventSelectors,
    this.homeRegion,
    this.includeGlobalServiceEvents,
    this.isMultiRegionTrail,
    this.isOrganizationTrail,
    this.kmsKeyId,
    this.logFileValidationEnabled,
    this.name,
    this.s3BucketName,
    this.s3KeyPrefix,
    this.snsTopicArn,
    this.snsTopicName,
    this.trailArn,
  });

  factory AwsCloudTrailTrailDetails.fromJson(Map<String, dynamic> json) {
    return AwsCloudTrailTrailDetails(
      cloudWatchLogsLogGroupArn: json['CloudWatchLogsLogGroupArn'] as String?,
      cloudWatchLogsRoleArn: json['CloudWatchLogsRoleArn'] as String?,
      hasCustomEventSelectors: json['HasCustomEventSelectors'] as bool?,
      homeRegion: json['HomeRegion'] as String?,
      includeGlobalServiceEvents: json['IncludeGlobalServiceEvents'] as bool?,
      isMultiRegionTrail: json['IsMultiRegionTrail'] as bool?,
      isOrganizationTrail: json['IsOrganizationTrail'] as bool?,
      kmsKeyId: json['KmsKeyId'] as String?,
      logFileValidationEnabled: json['LogFileValidationEnabled'] as bool?,
      name: json['Name'] as String?,
      s3BucketName: json['S3BucketName'] as String?,
      s3KeyPrefix: json['S3KeyPrefix'] as String?,
      snsTopicArn: json['SnsTopicArn'] as String?,
      snsTopicName: json['SnsTopicName'] as String?,
      trailArn: json['TrailArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsLogGroupArn = this.cloudWatchLogsLogGroupArn;
    final cloudWatchLogsRoleArn = this.cloudWatchLogsRoleArn;
    final hasCustomEventSelectors = this.hasCustomEventSelectors;
    final homeRegion = this.homeRegion;
    final includeGlobalServiceEvents = this.includeGlobalServiceEvents;
    final isMultiRegionTrail = this.isMultiRegionTrail;
    final isOrganizationTrail = this.isOrganizationTrail;
    final kmsKeyId = this.kmsKeyId;
    final logFileValidationEnabled = this.logFileValidationEnabled;
    final name = this.name;
    final s3BucketName = this.s3BucketName;
    final s3KeyPrefix = this.s3KeyPrefix;
    final snsTopicArn = this.snsTopicArn;
    final snsTopicName = this.snsTopicName;
    final trailArn = this.trailArn;
    return {
      if (cloudWatchLogsLogGroupArn != null)
        'CloudWatchLogsLogGroupArn': cloudWatchLogsLogGroupArn,
      if (cloudWatchLogsRoleArn != null)
        'CloudWatchLogsRoleArn': cloudWatchLogsRoleArn,
      if (hasCustomEventSelectors != null)
        'HasCustomEventSelectors': hasCustomEventSelectors,
      if (homeRegion != null) 'HomeRegion': homeRegion,
      if (includeGlobalServiceEvents != null)
        'IncludeGlobalServiceEvents': includeGlobalServiceEvents,
      if (isMultiRegionTrail != null) 'IsMultiRegionTrail': isMultiRegionTrail,
      if (isOrganizationTrail != null)
        'IsOrganizationTrail': isOrganizationTrail,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (logFileValidationEnabled != null)
        'LogFileValidationEnabled': logFileValidationEnabled,
      if (name != null) 'Name': name,
      if (s3BucketName != null) 'S3BucketName': s3BucketName,
      if (s3KeyPrefix != null) 'S3KeyPrefix': s3KeyPrefix,
      if (snsTopicArn != null) 'SnsTopicArn': snsTopicArn,
      if (snsTopicName != null) 'SnsTopicName': snsTopicName,
      if (trailArn != null) 'TrailArn': trailArn,
    };
  }
}

/// Specifies an alarm and associates it with the specified metric or metric
/// math expression.
class AwsCloudWatchAlarmDetails {
  /// Indicates whether actions should be executed during any changes to the alarm
  /// state.
  final bool? actionsEnabled;

  /// The list of actions, specified as Amazon Resource Names (ARNs) to execute
  /// when this alarm transitions into an <code>ALARM</code> state from any other
  /// state.
  final List<String>? alarmActions;

  /// The ARN of the alarm.
  final String? alarmArn;

  /// The time stamp of the last update to the alarm configuration.
  final String? alarmConfigurationUpdatedTimestamp;

  /// The description of the alarm.
  final String? alarmDescription;

  /// The name of the alarm. If you don't specify a name, CloudFront generates a
  /// unique physical ID and uses that ID for the alarm name.
  final String? alarmName;

  /// The arithmetic operation to use when comparing the specified statistic and
  /// threshold. The specified statistic value is used as the first operand.
  final String? comparisonOperator;

  /// The number of datapoints that must be breaching to trigger the alarm.
  final int? datapointsToAlarm;

  /// The dimensions for the metric associated with the alarm.
  final List<AwsCloudWatchAlarmDimensionsDetails>? dimensions;

  /// Used only for alarms based on percentiles. If <code>ignore</code>, the alarm
  /// state does not change during periods with too few data points to be
  /// statistically significant. If <code>evaluate</code> or this parameter is not
  /// used, the alarm is always evaluated and possibly changes state no matter how
  /// many data points are available.
  final String? evaluateLowSampleCountPercentile;

  /// The number of periods over which data is compared to the specified
  /// threshold.
  final int? evaluationPeriods;

  /// The percentile statistic for the metric associated with the alarm.
  final String? extendedStatistic;

  /// The actions to execute when this alarm transitions to the
  /// <code>INSUFFICIENT_DATA</code> state from any other state. Each action is
  /// specified as an ARN.
  final List<String>? insufficientDataActions;

  /// The name of the metric associated with the alarm. This is required for an
  /// alarm based on a metric. For an alarm based on a math expression, you use
  /// <code>Metrics</code> instead and you can't specify <code>MetricName</code>.
  final String? metricName;

  /// The namespace of the metric associated with the alarm. This is required for
  /// an alarm based on a metric. For an alarm based on a math expression, you
  /// can't specify <code>Namespace</code> and you use <code>Metrics</code>
  /// instead.
  final String? namespace;

  /// The actions to execute when this alarm transitions to the <code>OK</code>
  /// state from any other state. Each action is specified as an ARN.
  final List<String>? okActions;

  /// The period, in seconds, over which the statistic is applied. This is
  /// required for an alarm based on a metric.
  final int? period;

  /// The statistic for the metric associated with the alarm, other than
  /// percentile. For percentile statistics, use <code>ExtendedStatistic</code>.
  ///
  /// For an alarm based on a metric, you must specify either
  /// <code>Statistic</code> or <code>ExtendedStatistic</code> but not both.
  ///
  /// For an alarm based on a math expression, you can't specify
  /// <code>Statistic</code>. Instead, you use <code>Metrics</code>.
  final String? statistic;

  /// The value to compare with the specified statistic.
  final double? threshold;

  /// n an alarm based on an anomaly detection model, this is the ID of the
  /// <code>ANOMALY_DETECTION_BAND</code> function used as the threshold for the
  /// alarm.
  final String? thresholdMetricId;

  /// Sets how this alarm is to handle missing data points.
  final String? treatMissingData;

  /// The unit of the metric associated with the alarm.
  final String? unit;

  AwsCloudWatchAlarmDetails({
    this.actionsEnabled,
    this.alarmActions,
    this.alarmArn,
    this.alarmConfigurationUpdatedTimestamp,
    this.alarmDescription,
    this.alarmName,
    this.comparisonOperator,
    this.datapointsToAlarm,
    this.dimensions,
    this.evaluateLowSampleCountPercentile,
    this.evaluationPeriods,
    this.extendedStatistic,
    this.insufficientDataActions,
    this.metricName,
    this.namespace,
    this.okActions,
    this.period,
    this.statistic,
    this.threshold,
    this.thresholdMetricId,
    this.treatMissingData,
    this.unit,
  });

  factory AwsCloudWatchAlarmDetails.fromJson(Map<String, dynamic> json) {
    return AwsCloudWatchAlarmDetails(
      actionsEnabled: json['ActionsEnabled'] as bool?,
      alarmActions: (json['AlarmActions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      alarmArn: json['AlarmArn'] as String?,
      alarmConfigurationUpdatedTimestamp:
          json['AlarmConfigurationUpdatedTimestamp'] as String?,
      alarmDescription: json['AlarmDescription'] as String?,
      alarmName: json['AlarmName'] as String?,
      comparisonOperator: json['ComparisonOperator'] as String?,
      datapointsToAlarm: json['DatapointsToAlarm'] as int?,
      dimensions: (json['Dimensions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCloudWatchAlarmDimensionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      evaluateLowSampleCountPercentile:
          json['EvaluateLowSampleCountPercentile'] as String?,
      evaluationPeriods: json['EvaluationPeriods'] as int?,
      extendedStatistic: json['ExtendedStatistic'] as String?,
      insufficientDataActions: (json['InsufficientDataActions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      metricName: json['MetricName'] as String?,
      namespace: json['Namespace'] as String?,
      okActions: (json['OkActions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      period: json['Period'] as int?,
      statistic: json['Statistic'] as String?,
      threshold: json['Threshold'] as double?,
      thresholdMetricId: json['ThresholdMetricId'] as String?,
      treatMissingData: json['TreatMissingData'] as String?,
      unit: json['Unit'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final actionsEnabled = this.actionsEnabled;
    final alarmActions = this.alarmActions;
    final alarmArn = this.alarmArn;
    final alarmConfigurationUpdatedTimestamp =
        this.alarmConfigurationUpdatedTimestamp;
    final alarmDescription = this.alarmDescription;
    final alarmName = this.alarmName;
    final comparisonOperator = this.comparisonOperator;
    final datapointsToAlarm = this.datapointsToAlarm;
    final dimensions = this.dimensions;
    final evaluateLowSampleCountPercentile =
        this.evaluateLowSampleCountPercentile;
    final evaluationPeriods = this.evaluationPeriods;
    final extendedStatistic = this.extendedStatistic;
    final insufficientDataActions = this.insufficientDataActions;
    final metricName = this.metricName;
    final namespace = this.namespace;
    final okActions = this.okActions;
    final period = this.period;
    final statistic = this.statistic;
    final threshold = this.threshold;
    final thresholdMetricId = this.thresholdMetricId;
    final treatMissingData = this.treatMissingData;
    final unit = this.unit;
    return {
      if (actionsEnabled != null) 'ActionsEnabled': actionsEnabled,
      if (alarmActions != null) 'AlarmActions': alarmActions,
      if (alarmArn != null) 'AlarmArn': alarmArn,
      if (alarmConfigurationUpdatedTimestamp != null)
        'AlarmConfigurationUpdatedTimestamp':
            alarmConfigurationUpdatedTimestamp,
      if (alarmDescription != null) 'AlarmDescription': alarmDescription,
      if (alarmName != null) 'AlarmName': alarmName,
      if (comparisonOperator != null) 'ComparisonOperator': comparisonOperator,
      if (datapointsToAlarm != null) 'DatapointsToAlarm': datapointsToAlarm,
      if (dimensions != null) 'Dimensions': dimensions,
      if (evaluateLowSampleCountPercentile != null)
        'EvaluateLowSampleCountPercentile': evaluateLowSampleCountPercentile,
      if (evaluationPeriods != null) 'EvaluationPeriods': evaluationPeriods,
      if (extendedStatistic != null) 'ExtendedStatistic': extendedStatistic,
      if (insufficientDataActions != null)
        'InsufficientDataActions': insufficientDataActions,
      if (metricName != null) 'MetricName': metricName,
      if (namespace != null) 'Namespace': namespace,
      if (okActions != null) 'OkActions': okActions,
      if (period != null) 'Period': period,
      if (statistic != null) 'Statistic': statistic,
      if (threshold != null) 'Threshold': threshold,
      if (thresholdMetricId != null) 'ThresholdMetricId': thresholdMetricId,
      if (treatMissingData != null) 'TreatMissingData': treatMissingData,
      if (unit != null) 'Unit': unit,
    };
  }
}

/// Details about the dimensions for the metric associated with the alarm.
class AwsCloudWatchAlarmDimensionsDetails {
  /// The name of a dimension.
  final String? name;

  /// The value of a dimension.
  final String? value;

  AwsCloudWatchAlarmDimensionsDetails({
    this.name,
    this.value,
  });

  factory AwsCloudWatchAlarmDimensionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCloudWatchAlarmDimensionsDetails(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// Information about the build artifacts for the CodeBuild project.
class AwsCodeBuildProjectArtifactsDetails {
  /// An identifier for the artifact definition.
  final String? artifactIdentifier;

  /// Indicates whether to disable encryption on the artifact. Only valid when
  /// <code>Type</code> is <code>S3</code>.
  final bool? encryptionDisabled;

  /// Only used when <code>Type</code> is <code>S3</code>. The name of the S3
  /// bucket where the artifact is located.
  final String? location;

  /// Only used when Type is S3. The name of the artifact. Used with
  /// <code>NamepaceType</code> and <code>Path</code> to determine the pattern for
  /// storing the artifact.
  final String? name;

  /// Only used when <code>Type</code> is <code>S3</code>. The value to use for
  /// the namespace. Used with <code>Name</code> and <code>Path</code> to
  /// determine the pattern for storing the artifact.
  final String? namespaceType;

  /// Whether the name specified in the buildspec file overrides the artifact
  /// name.
  final bool? overrideArtifactName;

  /// Only used when <code>Type</code> is <code>S3</code>. The type of output
  /// artifact to create.
  final String? packaging;

  /// Only used when <code>Type</code> is <code>S3</code>. The path to the
  /// artifact. Used with <code>Name</code> and <code>NamespaceType</code> to
  /// determine the pattern for storing the artifact.
  final String? path;

  /// The type of build artifact.
  final String? type;

  AwsCodeBuildProjectArtifactsDetails({
    this.artifactIdentifier,
    this.encryptionDisabled,
    this.location,
    this.name,
    this.namespaceType,
    this.overrideArtifactName,
    this.packaging,
    this.path,
    this.type,
  });

  factory AwsCodeBuildProjectArtifactsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCodeBuildProjectArtifactsDetails(
      artifactIdentifier: json['ArtifactIdentifier'] as String?,
      encryptionDisabled: json['EncryptionDisabled'] as bool?,
      location: json['Location'] as String?,
      name: json['Name'] as String?,
      namespaceType: json['NamespaceType'] as String?,
      overrideArtifactName: json['OverrideArtifactName'] as bool?,
      packaging: json['Packaging'] as String?,
      path: json['Path'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final artifactIdentifier = this.artifactIdentifier;
    final encryptionDisabled = this.encryptionDisabled;
    final location = this.location;
    final name = this.name;
    final namespaceType = this.namespaceType;
    final overrideArtifactName = this.overrideArtifactName;
    final packaging = this.packaging;
    final path = this.path;
    final type = this.type;
    return {
      if (artifactIdentifier != null) 'ArtifactIdentifier': artifactIdentifier,
      if (encryptionDisabled != null) 'EncryptionDisabled': encryptionDisabled,
      if (location != null) 'Location': location,
      if (name != null) 'Name': name,
      if (namespaceType != null) 'NamespaceType': namespaceType,
      if (overrideArtifactName != null)
        'OverrideArtifactName': overrideArtifactName,
      if (packaging != null) 'Packaging': packaging,
      if (path != null) 'Path': path,
      if (type != null) 'Type': type,
    };
  }
}

/// Information about an CodeBuild project.
class AwsCodeBuildProjectDetails {
  /// Information about the build artifacts for the CodeBuild project.
  final List<AwsCodeBuildProjectArtifactsDetails>? artifacts;

  /// The KMS key used to encrypt the build output artifacts.
  ///
  /// You can specify either the ARN of the KMS key or, if available, the KMS key
  /// alias (using the format alias/alias-name).
  final String? encryptionKey;

  /// Information about the build environment for this build project.
  final AwsCodeBuildProjectEnvironment? environment;

  /// Information about logs for the build project.
  final AwsCodeBuildProjectLogsConfigDetails? logsConfig;

  /// The name of the build project.
  final String? name;

  /// Information about the secondary artifacts for the CodeBuild project.
  final List<AwsCodeBuildProjectArtifactsDetails>? secondaryArtifacts;

  /// The ARN of the IAM role that enables CodeBuild to interact with dependent
  /// Amazon Web Services services on behalf of the Amazon Web Services account.
  final String? serviceRole;

  /// Information about the build input source code for this build project.
  final AwsCodeBuildProjectSource? source;

  /// Information about the VPC configuration that CodeBuild accesses.
  final AwsCodeBuildProjectVpcConfig? vpcConfig;

  AwsCodeBuildProjectDetails({
    this.artifacts,
    this.encryptionKey,
    this.environment,
    this.logsConfig,
    this.name,
    this.secondaryArtifacts,
    this.serviceRole,
    this.source,
    this.vpcConfig,
  });

  factory AwsCodeBuildProjectDetails.fromJson(Map<String, dynamic> json) {
    return AwsCodeBuildProjectDetails(
      artifacts: (json['Artifacts'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCodeBuildProjectArtifactsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      encryptionKey: json['EncryptionKey'] as String?,
      environment: json['Environment'] != null
          ? AwsCodeBuildProjectEnvironment.fromJson(
              json['Environment'] as Map<String, dynamic>)
          : null,
      logsConfig: json['LogsConfig'] != null
          ? AwsCodeBuildProjectLogsConfigDetails.fromJson(
              json['LogsConfig'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      secondaryArtifacts: (json['SecondaryArtifacts'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCodeBuildProjectArtifactsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      serviceRole: json['ServiceRole'] as String?,
      source: json['Source'] != null
          ? AwsCodeBuildProjectSource.fromJson(
              json['Source'] as Map<String, dynamic>)
          : null,
      vpcConfig: json['VpcConfig'] != null
          ? AwsCodeBuildProjectVpcConfig.fromJson(
              json['VpcConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final artifacts = this.artifacts;
    final encryptionKey = this.encryptionKey;
    final environment = this.environment;
    final logsConfig = this.logsConfig;
    final name = this.name;
    final secondaryArtifacts = this.secondaryArtifacts;
    final serviceRole = this.serviceRole;
    final source = this.source;
    final vpcConfig = this.vpcConfig;
    return {
      if (artifacts != null) 'Artifacts': artifacts,
      if (encryptionKey != null) 'EncryptionKey': encryptionKey,
      if (environment != null) 'Environment': environment,
      if (logsConfig != null) 'LogsConfig': logsConfig,
      if (name != null) 'Name': name,
      if (secondaryArtifacts != null) 'SecondaryArtifacts': secondaryArtifacts,
      if (serviceRole != null) 'ServiceRole': serviceRole,
      if (source != null) 'Source': source,
      if (vpcConfig != null) 'VpcConfig': vpcConfig,
    };
  }
}

/// Information about the build environment for this build project.
class AwsCodeBuildProjectEnvironment {
  /// The certificate to use with this build project.
  final String? certificate;

  /// A set of environment variables to make available to builds for the build
  /// project.
  final List<AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails>?
      environmentVariables;

  /// The type of credentials CodeBuild uses to pull images in your build.
  ///
  /// Valid values:
  ///
  /// <ul>
  /// <li>
  /// <code>CODEBUILD</code> specifies that CodeBuild uses its own credentials.
  /// This requires that you modify your ECR repository policy to trust the
  /// CodeBuild service principal.
  /// </li>
  /// <li>
  /// <code>SERVICE_ROLE</code> specifies that CodeBuild uses your build project's
  /// service role.
  /// </li>
  /// </ul>
  /// When you use a cross-account or private registry image, you must use
  /// <code>SERVICE_ROLE</code> credentials. When you use an CodeBuild curated
  /// image, you must use <code>CODEBUILD</code> credentials.
  final String? imagePullCredentialsType;

  /// Whether to allow the Docker daemon to run inside a Docker container. Set to
  /// <code>true</code> if the build project is used to build Docker images.
  final bool? privilegedMode;

  /// The credentials for access to a private registry.
  final AwsCodeBuildProjectEnvironmentRegistryCredential? registryCredential;

  /// The type of build environment to use for related builds.
  ///
  /// The environment type <code>ARM_CONTAINER</code> is available only in Regions
  /// US East (N. Virginia), US East (Ohio), US West (Oregon), Europe (Ireland),
  /// Asia Pacific (Mumbai), Asia Pacific (Tokyo), Asia Pacific (Sydney), and
  /// Europe (Frankfurt).
  ///
  /// The environment type <code>LINUX_CONTAINER</code> with compute type
  /// build.general1.2xlarge is available only in Regions US East (N. Virginia),
  /// US East (N. Virginia), US West (Oregon), Canada (Central), Europe (Ireland),
  /// Europe (London), Europe (Frankfurt), Asia Pacific (Tokyo), Asia Pacific
  /// (Seoul), Asia Pacific (Singapore), Asia Pacific (Sydney), China (Beijing),
  /// and China (Ningxia).
  ///
  /// The environment type <code>LINUX_GPU_CONTAINER</code> is available only in
  /// Regions US East (N. Virginia), US East (N. Virginia), US West (Oregon),
  /// Canada (Central), Europe (Ireland), Europe (London), Europe (Frankfurt),
  /// Asia Pacific (Tokyo), Asia Pacific (Seoul), Asia Pacific (Singapore), Asia
  /// Pacific (Sydney), China (Beijing), and China (Ningxia).
  ///
  /// Valid values: <code>WINDOWS_CONTAINER</code> | <code>LINUX_CONTAINER</code>
  /// | <code>LINUX_GPU_CONTAINER</code> | <code>ARM_CONTAINER</code>
  final String? type;

  AwsCodeBuildProjectEnvironment({
    this.certificate,
    this.environmentVariables,
    this.imagePullCredentialsType,
    this.privilegedMode,
    this.registryCredential,
    this.type,
  });

  factory AwsCodeBuildProjectEnvironment.fromJson(Map<String, dynamic> json) {
    return AwsCodeBuildProjectEnvironment(
      certificate: json['Certificate'] as String?,
      environmentVariables: (json['EnvironmentVariables'] as List?)
          ?.whereNotNull()
          .map((e) => AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      imagePullCredentialsType: json['ImagePullCredentialsType'] as String?,
      privilegedMode: json['PrivilegedMode'] as bool?,
      registryCredential: json['RegistryCredential'] != null
          ? AwsCodeBuildProjectEnvironmentRegistryCredential.fromJson(
              json['RegistryCredential'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final certificate = this.certificate;
    final environmentVariables = this.environmentVariables;
    final imagePullCredentialsType = this.imagePullCredentialsType;
    final privilegedMode = this.privilegedMode;
    final registryCredential = this.registryCredential;
    final type = this.type;
    return {
      if (certificate != null) 'Certificate': certificate,
      if (environmentVariables != null)
        'EnvironmentVariables': environmentVariables,
      if (imagePullCredentialsType != null)
        'ImagePullCredentialsType': imagePullCredentialsType,
      if (privilegedMode != null) 'PrivilegedMode': privilegedMode,
      if (registryCredential != null) 'RegistryCredential': registryCredential,
      if (type != null) 'Type': type,
    };
  }
}

/// Information about an environment variable that is available to builds for
/// the build project.
class AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails {
  /// The name of the environment variable.
  final String? name;

  /// The type of environment variable.
  final String? type;

  /// The value of the environment variable.
  final String? value;

  AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails({
    this.name,
    this.type,
    this.value,
  });

  factory AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCodeBuildProjectEnvironmentEnvironmentVariablesDetails(
      name: json['Name'] as String?,
      type: json['Type'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final type = this.type;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (type != null) 'Type': type,
      if (value != null) 'Value': value,
    };
  }
}

/// The credentials for access to a private registry.
class AwsCodeBuildProjectEnvironmentRegistryCredential {
  /// The ARN or name of credentials created using Secrets Manager.
  /// <note>
  /// The credential can use the name of the credentials only if they exist in
  /// your current Amazon Web Services Region.
  /// </note>
  final String? credential;

  /// The service that created the credentials to access a private Docker
  /// registry.
  ///
  /// The valid value,<code> SECRETS_MANAGER</code>, is for Secrets Manager.
  final String? credentialProvider;

  AwsCodeBuildProjectEnvironmentRegistryCredential({
    this.credential,
    this.credentialProvider,
  });

  factory AwsCodeBuildProjectEnvironmentRegistryCredential.fromJson(
      Map<String, dynamic> json) {
    return AwsCodeBuildProjectEnvironmentRegistryCredential(
      credential: json['Credential'] as String?,
      credentialProvider: json['CredentialProvider'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final credential = this.credential;
    final credentialProvider = this.credentialProvider;
    return {
      if (credential != null) 'Credential': credential,
      if (credentialProvider != null) 'CredentialProvider': credentialProvider,
    };
  }
}

/// Information about CloudWatch Logs for the build project.
class AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails {
  /// The group name of the logs in CloudWatch Logs.
  final String? groupName;

  /// The current status of the logs in CloudWatch Logs for a build project.
  final String? status;

  /// The prefix of the stream name of the CloudWatch Logs.
  final String? streamName;

  AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails({
    this.groupName,
    this.status,
    this.streamName,
  });

  factory AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails(
      groupName: json['GroupName'] as String?,
      status: json['Status'] as String?,
      streamName: json['StreamName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupName = this.groupName;
    final status = this.status;
    final streamName = this.streamName;
    return {
      if (groupName != null) 'GroupName': groupName,
      if (status != null) 'Status': status,
      if (streamName != null) 'StreamName': streamName,
    };
  }
}

/// Information about logs for the build project.
class AwsCodeBuildProjectLogsConfigDetails {
  /// Information about CloudWatch Logs for the build project.
  final AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails? cloudWatchLogs;

  /// Information about logs built to an S3 bucket for a build project.
  final AwsCodeBuildProjectLogsConfigS3LogsDetails? s3Logs;

  AwsCodeBuildProjectLogsConfigDetails({
    this.cloudWatchLogs,
    this.s3Logs,
  });

  factory AwsCodeBuildProjectLogsConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCodeBuildProjectLogsConfigDetails(
      cloudWatchLogs: json['CloudWatchLogs'] != null
          ? AwsCodeBuildProjectLogsConfigCloudWatchLogsDetails.fromJson(
              json['CloudWatchLogs'] as Map<String, dynamic>)
          : null,
      s3Logs: json['S3Logs'] != null
          ? AwsCodeBuildProjectLogsConfigS3LogsDetails.fromJson(
              json['S3Logs'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogs = this.cloudWatchLogs;
    final s3Logs = this.s3Logs;
    return {
      if (cloudWatchLogs != null) 'CloudWatchLogs': cloudWatchLogs,
      if (s3Logs != null) 'S3Logs': s3Logs,
    };
  }
}

/// Information about logs built to an S3 bucket for a build project.
class AwsCodeBuildProjectLogsConfigS3LogsDetails {
  /// Whether to disable encryption of the S3 build log output.
  final bool? encryptionDisabled;

  /// The ARN of the S3 bucket and the path prefix for S3 logs.
  final String? location;

  /// The current status of the S3 build logs.
  final String? status;

  AwsCodeBuildProjectLogsConfigS3LogsDetails({
    this.encryptionDisabled,
    this.location,
    this.status,
  });

  factory AwsCodeBuildProjectLogsConfigS3LogsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsCodeBuildProjectLogsConfigS3LogsDetails(
      encryptionDisabled: json['EncryptionDisabled'] as bool?,
      location: json['Location'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionDisabled = this.encryptionDisabled;
    final location = this.location;
    final status = this.status;
    return {
      if (encryptionDisabled != null) 'EncryptionDisabled': encryptionDisabled,
      if (location != null) 'Location': location,
      if (status != null) 'Status': status,
    };
  }
}

/// Information about the build input source code for this build project.
class AwsCodeBuildProjectSource {
  /// Information about the Git clone depth for the build project.
  final int? gitCloneDepth;

  /// Whether to ignore SSL warnings while connecting to the project source code.
  final bool? insecureSsl;

  /// Information about the location of the source code to be built.
  ///
  /// Valid values include:
  ///
  /// <ul>
  /// <li>
  /// For source code settings that are specified in the source action of a
  /// pipeline in CodePipeline, location should not be specified. If it is
  /// specified, CodePipeline ignores it. This is because CodePipeline uses the
  /// settings in a pipeline's source action instead of this value.
  /// </li>
  /// <li>
  /// For source code in an CodeCommit repository, the HTTPS clone URL to the
  /// repository that contains the source code and the build spec file (for
  /// example,
  /// <code>https://git-codecommit.region-ID.amazonaws.com/v1/repos/repo-name</code>
  /// ).
  /// </li>
  /// <li>
  /// For source code in an S3 input bucket, one of the following.
  ///
  /// <ul>
  /// <li>
  /// The path to the ZIP file that contains the source code (for example,
  /// <code>bucket-name/path/to/object-name.zip</code>).
  /// </li>
  /// <li>
  /// The path to the folder that contains the source code (for example,
  /// <code>bucket-name/path/to/source-code/folder/</code>).
  /// </li>
  /// </ul> </li>
  /// <li>
  /// For source code in a GitHub repository, the HTTPS clone URL to the
  /// repository that contains the source and the build spec file.
  /// </li>
  /// <li>
  /// For source code in a Bitbucket repository, the HTTPS clone URL to the
  /// repository that contains the source and the build spec file.
  /// </li>
  /// </ul>
  final String? location;

  /// The type of repository that contains the source code to be built. Valid
  /// values are:
  ///
  /// <ul>
  /// <li>
  /// <code>BITBUCKET</code> - The source code is in a Bitbucket repository.
  /// </li>
  /// <li>
  /// <code>CODECOMMIT</code> - The source code is in an CodeCommit repository.
  /// </li>
  /// <li>
  /// <code>CODEPIPELINE</code> - The source code settings are specified in the
  /// source action of a pipeline in CodePipeline.
  /// </li>
  /// <li>
  /// <code>GITHUB</code> - The source code is in a GitHub repository.
  /// </li>
  /// <li>
  /// <code>GITHUB_ENTERPRISE</code> - The source code is in a GitHub Enterprise
  /// repository.
  /// </li>
  /// <li>
  /// <code>NO_SOURCE</code> - The project does not have input source code.
  /// </li>
  /// <li>
  /// <code>S3</code> - The source code is in an S3 input bucket.
  /// </li>
  /// </ul>
  final String? type;

  AwsCodeBuildProjectSource({
    this.gitCloneDepth,
    this.insecureSsl,
    this.location,
    this.type,
  });

  factory AwsCodeBuildProjectSource.fromJson(Map<String, dynamic> json) {
    return AwsCodeBuildProjectSource(
      gitCloneDepth: json['GitCloneDepth'] as int?,
      insecureSsl: json['InsecureSsl'] as bool?,
      location: json['Location'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final gitCloneDepth = this.gitCloneDepth;
    final insecureSsl = this.insecureSsl;
    final location = this.location;
    final type = this.type;
    return {
      if (gitCloneDepth != null) 'GitCloneDepth': gitCloneDepth,
      if (insecureSsl != null) 'InsecureSsl': insecureSsl,
      if (location != null) 'Location': location,
      if (type != null) 'Type': type,
    };
  }
}

/// Information about the VPC configuration that CodeBuild accesses.
class AwsCodeBuildProjectVpcConfig {
  /// A list of one or more security group IDs in your VPC.
  final List<String>? securityGroupIds;

  /// A list of one or more subnet IDs in your VPC.
  final List<String>? subnets;

  /// The ID of the VPC.
  final String? vpcId;

  AwsCodeBuildProjectVpcConfig({
    this.securityGroupIds,
    this.subnets,
    this.vpcId,
  });

  factory AwsCodeBuildProjectVpcConfig.fromJson(Map<String, dynamic> json) {
    return AwsCodeBuildProjectVpcConfig(
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnets: (json['Subnets'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final securityGroupIds = this.securityGroupIds;
    final subnets = this.subnets;
    final vpcId = this.vpcId;
    return {
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (subnets != null) 'Subnets': subnets,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Contains the cross-origin resource sharing (CORS) configuration for the API.
/// CORS is only supported for HTTP APIs.
class AwsCorsConfiguration {
  /// Indicates whether the CORS request includes credentials.
  final bool? allowCredentials;

  /// The allowed headers for CORS requests.
  final List<String>? allowHeaders;

  /// The allowed methods for CORS requests.
  final List<String>? allowMethods;

  /// The allowed origins for CORS requests.
  final List<String>? allowOrigins;

  /// The exposed headers for CORS requests.
  final List<String>? exposeHeaders;

  /// The number of seconds for which the browser caches preflight request
  /// results.
  final int? maxAge;

  AwsCorsConfiguration({
    this.allowCredentials,
    this.allowHeaders,
    this.allowMethods,
    this.allowOrigins,
    this.exposeHeaders,
    this.maxAge,
  });

  factory AwsCorsConfiguration.fromJson(Map<String, dynamic> json) {
    return AwsCorsConfiguration(
      allowCredentials: json['AllowCredentials'] as bool?,
      allowHeaders: (json['AllowHeaders'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      allowMethods: (json['AllowMethods'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      allowOrigins: (json['AllowOrigins'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      exposeHeaders: (json['ExposeHeaders'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      maxAge: json['MaxAge'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final allowCredentials = this.allowCredentials;
    final allowHeaders = this.allowHeaders;
    final allowMethods = this.allowMethods;
    final allowOrigins = this.allowOrigins;
    final exposeHeaders = this.exposeHeaders;
    final maxAge = this.maxAge;
    return {
      if (allowCredentials != null) 'AllowCredentials': allowCredentials,
      if (allowHeaders != null) 'AllowHeaders': allowHeaders,
      if (allowMethods != null) 'AllowMethods': allowMethods,
      if (allowOrigins != null) 'AllowOrigins': allowOrigins,
      if (exposeHeaders != null) 'ExposeHeaders': exposeHeaders,
      if (maxAge != null) 'MaxAge': maxAge,
    };
  }
}

/// Provides details about an Database Migration Service (DMS) endpoint. An
/// endpoint provides connection, data store type, and location information
/// about your data store.
class AwsDmsEndpointDetails {
  /// The Amazon Resource Name (ARN) for the SSL certificate that encrypts
  /// connections between the DMS endpoint and the replication instance.
  final String? certificateArn;

  /// The name of the endpoint database.
  final String? databaseName;

  /// The Amazon Resource Name (ARN) of the endpoint.
  final String? endpointArn;

  /// The database endpoint identifier.
  final String? endpointIdentifier;

  /// The type of endpoint. Valid values are source and target.
  final String? endpointType;

  /// The type of engine for the endpoint, depending on the
  /// <code>EndpointType</code> value.
  final String? engineName;

  /// A value that can be used for cross-account validation.
  final String? externalId;

  /// Additional attributes associated with the connection.
  final String? extraConnectionAttributes;

  /// An DMS key identifier that is used to encrypt the connection parameters for
  /// the endpoint. If you don't specify a value for the <code>KmsKeyId</code>
  /// parameter, then DMS uses your default encryption key. KMS creates the
  /// default encryption key for your Amazon Web Services account. Your Amazon Web
  /// Services account has a different default encryption key for each Amazon Web
  /// Services Region.
  final String? kmsKeyId;

  /// The port used to access the endpoint.
  final int? port;

  /// The name of the server where the endpoint database resides.
  final String? serverName;

  /// The SSL mode used to connect to the endpoint. The default is none.
  final String? sslMode;

  /// The user name to be used to log in to the endpoint database.
  final String? username;

  AwsDmsEndpointDetails({
    this.certificateArn,
    this.databaseName,
    this.endpointArn,
    this.endpointIdentifier,
    this.endpointType,
    this.engineName,
    this.externalId,
    this.extraConnectionAttributes,
    this.kmsKeyId,
    this.port,
    this.serverName,
    this.sslMode,
    this.username,
  });

  factory AwsDmsEndpointDetails.fromJson(Map<String, dynamic> json) {
    return AwsDmsEndpointDetails(
      certificateArn: json['CertificateArn'] as String?,
      databaseName: json['DatabaseName'] as String?,
      endpointArn: json['EndpointArn'] as String?,
      endpointIdentifier: json['EndpointIdentifier'] as String?,
      endpointType: json['EndpointType'] as String?,
      engineName: json['EngineName'] as String?,
      externalId: json['ExternalId'] as String?,
      extraConnectionAttributes: json['ExtraConnectionAttributes'] as String?,
      kmsKeyId: json['KmsKeyId'] as String?,
      port: json['Port'] as int?,
      serverName: json['ServerName'] as String?,
      sslMode: json['SslMode'] as String?,
      username: json['Username'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final certificateArn = this.certificateArn;
    final databaseName = this.databaseName;
    final endpointArn = this.endpointArn;
    final endpointIdentifier = this.endpointIdentifier;
    final endpointType = this.endpointType;
    final engineName = this.engineName;
    final externalId = this.externalId;
    final extraConnectionAttributes = this.extraConnectionAttributes;
    final kmsKeyId = this.kmsKeyId;
    final port = this.port;
    final serverName = this.serverName;
    final sslMode = this.sslMode;
    final username = this.username;
    return {
      if (certificateArn != null) 'CertificateArn': certificateArn,
      if (databaseName != null) 'DatabaseName': databaseName,
      if (endpointArn != null) 'EndpointArn': endpointArn,
      if (endpointIdentifier != null) 'EndpointIdentifier': endpointIdentifier,
      if (endpointType != null) 'EndpointType': endpointType,
      if (engineName != null) 'EngineName': engineName,
      if (externalId != null) 'ExternalId': externalId,
      if (extraConnectionAttributes != null)
        'ExtraConnectionAttributes': extraConnectionAttributes,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (port != null) 'Port': port,
      if (serverName != null) 'ServerName': serverName,
      if (sslMode != null) 'SslMode': sslMode,
      if (username != null) 'Username': username,
    };
  }
}

/// Provides details about an Database Migration Service (DMS) replication
/// instance. DMS uses a replication instance to connect to your source data
/// store, read the source data, and format the data for consumption by the
/// target data store.
class AwsDmsReplicationInstanceDetails {
  /// The amount of storage (in gigabytes) that is allocated for the replication
  /// instance.
  final int? allocatedStorage;

  /// Indicates whether minor engine upgrades are applied automatically to the
  /// replication instance during the maintenance window.
  final bool? autoMinorVersionUpgrade;

  /// The Availability Zone that the replication instance is created in. The
  /// default value is a random, system-chosen Availability Zone in the endpoint's
  /// Amazon Web Services Region, such as <code>us-east-1d</code>.
  final String? availabilityZone;

  /// The engine version number of the replication instance. If an engine version
  /// number is not specified when a replication instance is created, the default
  /// is the latest engine version available.
  final String? engineVersion;

  /// An KMS key identifier that is used to encrypt the data on the replication
  /// instance. If you don't specify a value for the <code>KmsKeyId</code>
  /// parameter, DMS uses your default encryption key. KMS creates the default
  /// encryption key for your Amazon Web Services account. Your Amazon Web
  /// Services account has a different default encryption key for each Amazon Web
  /// Services Region.
  final String? kmsKeyId;

  /// Specifies whether the replication instance is deployed across multiple
  /// Availability Zones (AZs). You can't set the <code>AvailabilityZone</code>
  /// parameter if the <code>MultiAZ</code> parameter is set to <code>true</code>.
  final bool? multiAZ;

  /// The maintenance window times for the replication instance. Upgrades to the
  /// replication instance are performed during this time.
  final String? preferredMaintenanceWindow;

  /// Specifies the accessibility options for the replication instance. A value of
  /// <code>true</code> represents an instance with a public IP address. A value
  /// of <code>false</code> represents an instance with a private IP address. The
  /// default value is <code>true</code>.
  final bool? publiclyAccessible;

  /// The compute and memory capacity of the replication instance as defined for
  /// the specified replication instance class.
  final String? replicationInstanceClass;

  /// The replication instance identifier.
  final String? replicationInstanceIdentifier;

  /// The subnet group for the replication instance.
  final AwsDmsReplicationInstanceReplicationSubnetGroupDetails?
      replicationSubnetGroup;

  /// The virtual private cloud (VPC) security group for the replication instance.
  final List<AwsDmsReplicationInstanceVpcSecurityGroupsDetails>?
      vpcSecurityGroups;

  AwsDmsReplicationInstanceDetails({
    this.allocatedStorage,
    this.autoMinorVersionUpgrade,
    this.availabilityZone,
    this.engineVersion,
    this.kmsKeyId,
    this.multiAZ,
    this.preferredMaintenanceWindow,
    this.publiclyAccessible,
    this.replicationInstanceClass,
    this.replicationInstanceIdentifier,
    this.replicationSubnetGroup,
    this.vpcSecurityGroups,
  });

  factory AwsDmsReplicationInstanceDetails.fromJson(Map<String, dynamic> json) {
    return AwsDmsReplicationInstanceDetails(
      allocatedStorage: json['AllocatedStorage'] as int?,
      autoMinorVersionUpgrade: json['AutoMinorVersionUpgrade'] as bool?,
      availabilityZone: json['AvailabilityZone'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      kmsKeyId: json['KmsKeyId'] as String?,
      multiAZ: json['MultiAZ'] as bool?,
      preferredMaintenanceWindow: json['PreferredMaintenanceWindow'] as String?,
      publiclyAccessible: json['PubliclyAccessible'] as bool?,
      replicationInstanceClass: json['ReplicationInstanceClass'] as String?,
      replicationInstanceIdentifier:
          json['ReplicationInstanceIdentifier'] as String?,
      replicationSubnetGroup: json['ReplicationSubnetGroup'] != null
          ? AwsDmsReplicationInstanceReplicationSubnetGroupDetails.fromJson(
              json['ReplicationSubnetGroup'] as Map<String, dynamic>)
          : null,
      vpcSecurityGroups: (json['VpcSecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsDmsReplicationInstanceVpcSecurityGroupsDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final allocatedStorage = this.allocatedStorage;
    final autoMinorVersionUpgrade = this.autoMinorVersionUpgrade;
    final availabilityZone = this.availabilityZone;
    final engineVersion = this.engineVersion;
    final kmsKeyId = this.kmsKeyId;
    final multiAZ = this.multiAZ;
    final preferredMaintenanceWindow = this.preferredMaintenanceWindow;
    final publiclyAccessible = this.publiclyAccessible;
    final replicationInstanceClass = this.replicationInstanceClass;
    final replicationInstanceIdentifier = this.replicationInstanceIdentifier;
    final replicationSubnetGroup = this.replicationSubnetGroup;
    final vpcSecurityGroups = this.vpcSecurityGroups;
    return {
      if (allocatedStorage != null) 'AllocatedStorage': allocatedStorage,
      if (autoMinorVersionUpgrade != null)
        'AutoMinorVersionUpgrade': autoMinorVersionUpgrade,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (multiAZ != null) 'MultiAZ': multiAZ,
      if (preferredMaintenanceWindow != null)
        'PreferredMaintenanceWindow': preferredMaintenanceWindow,
      if (publiclyAccessible != null) 'PubliclyAccessible': publiclyAccessible,
      if (replicationInstanceClass != null)
        'ReplicationInstanceClass': replicationInstanceClass,
      if (replicationInstanceIdentifier != null)
        'ReplicationInstanceIdentifier': replicationInstanceIdentifier,
      if (replicationSubnetGroup != null)
        'ReplicationSubnetGroup': replicationSubnetGroup,
      if (vpcSecurityGroups != null) 'VpcSecurityGroups': vpcSecurityGroups,
    };
  }
}

/// Provides details about the replication subnet group.
class AwsDmsReplicationInstanceReplicationSubnetGroupDetails {
  /// The identifier of the replication subnet group.
  final String? replicationSubnetGroupIdentifier;

  AwsDmsReplicationInstanceReplicationSubnetGroupDetails({
    this.replicationSubnetGroupIdentifier,
  });

  factory AwsDmsReplicationInstanceReplicationSubnetGroupDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsDmsReplicationInstanceReplicationSubnetGroupDetails(
      replicationSubnetGroupIdentifier:
          json['ReplicationSubnetGroupIdentifier'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final replicationSubnetGroupIdentifier =
        this.replicationSubnetGroupIdentifier;
    return {
      if (replicationSubnetGroupIdentifier != null)
        'ReplicationSubnetGroupIdentifier': replicationSubnetGroupIdentifier,
    };
  }
}

/// Provides details about the virtual private cloud (VPC) security group that’s
/// associated with the replication instance.
class AwsDmsReplicationInstanceVpcSecurityGroupsDetails {
  /// The identifier of the VPC security group that’s associated with the
  /// replication instance.
  final String? vpcSecurityGroupId;

  AwsDmsReplicationInstanceVpcSecurityGroupsDetails({
    this.vpcSecurityGroupId,
  });

  factory AwsDmsReplicationInstanceVpcSecurityGroupsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsDmsReplicationInstanceVpcSecurityGroupsDetails(
      vpcSecurityGroupId: json['VpcSecurityGroupId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final vpcSecurityGroupId = this.vpcSecurityGroupId;
    return {
      if (vpcSecurityGroupId != null) 'VpcSecurityGroupId': vpcSecurityGroupId,
    };
  }
}

/// Provides details about an Database Migration Service (DMS) replication task.
/// A replication task moves a set of data from the source endpoint to the
/// target endpoint.
class AwsDmsReplicationTaskDetails {
  /// Indicates when you want a change data capture (CDC) operation to start.
  /// <code>CCdcStartPosition</code> or <code>CCdcStartTime</code> specifies when
  /// you want a CDC operation to start. Only a value for one of these fields is
  /// included.
  final String? cdcStartPosition;

  /// Indicates the start time for a CDC operation. <code>CdcStartPosition</code>
  /// or <code>CCdcStartTime</code> specifies when you want a CDC operation to
  /// start. Only a value for one of these fields is included.
  final String? cdcStartTime;

  /// Indicates when you want a CDC operation to stop. The value can be either
  /// server time or commit time.
  final String? cdcStopPosition;

  /// The identifier of the replication task.
  final String? id;

  /// The migration type.
  final String? migrationType;

  /// The Amazon Resource Name (ARN) of a replication instance.
  final String? replicationInstanceArn;

  /// The user-defined replication task identifier or name.
  final String? replicationTaskIdentifier;

  /// The settings for the replication task.
  final String? replicationTaskSettings;

  /// A display name for the resource identifier at the end of the
  /// <code>EndpointArn</code> response parameter. If you don't specify a
  /// <code>ResourceIdentifier</code> value, DMS generates a default identifier
  /// value for the end of <code>EndpointArn</code>.
  final String? resourceIdentifier;

  /// The ARN of the source endpoint.
  final String? sourceEndpointArn;

  /// The table mappings for the replication task, in JSON format.
  final String? tableMappings;

  /// The ARN of the target endpoint.
  final String? targetEndpointArn;

  /// Supplemental information that the task requires to migrate the data for
  /// certain source and target endpoints.
  final String? taskData;

  AwsDmsReplicationTaskDetails({
    this.cdcStartPosition,
    this.cdcStartTime,
    this.cdcStopPosition,
    this.id,
    this.migrationType,
    this.replicationInstanceArn,
    this.replicationTaskIdentifier,
    this.replicationTaskSettings,
    this.resourceIdentifier,
    this.sourceEndpointArn,
    this.tableMappings,
    this.targetEndpointArn,
    this.taskData,
  });

  factory AwsDmsReplicationTaskDetails.fromJson(Map<String, dynamic> json) {
    return AwsDmsReplicationTaskDetails(
      cdcStartPosition: json['CdcStartPosition'] as String?,
      cdcStartTime: json['CdcStartTime'] as String?,
      cdcStopPosition: json['CdcStopPosition'] as String?,
      id: json['Id'] as String?,
      migrationType: json['MigrationType'] as String?,
      replicationInstanceArn: json['ReplicationInstanceArn'] as String?,
      replicationTaskIdentifier: json['ReplicationTaskIdentifier'] as String?,
      replicationTaskSettings: json['ReplicationTaskSettings'] as String?,
      resourceIdentifier: json['ResourceIdentifier'] as String?,
      sourceEndpointArn: json['SourceEndpointArn'] as String?,
      tableMappings: json['TableMappings'] as String?,
      targetEndpointArn: json['TargetEndpointArn'] as String?,
      taskData: json['TaskData'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cdcStartPosition = this.cdcStartPosition;
    final cdcStartTime = this.cdcStartTime;
    final cdcStopPosition = this.cdcStopPosition;
    final id = this.id;
    final migrationType = this.migrationType;
    final replicationInstanceArn = this.replicationInstanceArn;
    final replicationTaskIdentifier = this.replicationTaskIdentifier;
    final replicationTaskSettings = this.replicationTaskSettings;
    final resourceIdentifier = this.resourceIdentifier;
    final sourceEndpointArn = this.sourceEndpointArn;
    final tableMappings = this.tableMappings;
    final targetEndpointArn = this.targetEndpointArn;
    final taskData = this.taskData;
    return {
      if (cdcStartPosition != null) 'CdcStartPosition': cdcStartPosition,
      if (cdcStartTime != null) 'CdcStartTime': cdcStartTime,
      if (cdcStopPosition != null) 'CdcStopPosition': cdcStopPosition,
      if (id != null) 'Id': id,
      if (migrationType != null) 'MigrationType': migrationType,
      if (replicationInstanceArn != null)
        'ReplicationInstanceArn': replicationInstanceArn,
      if (replicationTaskIdentifier != null)
        'ReplicationTaskIdentifier': replicationTaskIdentifier,
      if (replicationTaskSettings != null)
        'ReplicationTaskSettings': replicationTaskSettings,
      if (resourceIdentifier != null) 'ResourceIdentifier': resourceIdentifier,
      if (sourceEndpointArn != null) 'SourceEndpointArn': sourceEndpointArn,
      if (tableMappings != null) 'TableMappings': tableMappings,
      if (targetEndpointArn != null) 'TargetEndpointArn': targetEndpointArn,
      if (taskData != null) 'TaskData': taskData,
    };
  }
}

/// Contains a definition of an attribute for the table.
class AwsDynamoDbTableAttributeDefinition {
  /// The name of the attribute.
  final String? attributeName;

  /// The type of the attribute.
  final String? attributeType;

  AwsDynamoDbTableAttributeDefinition({
    this.attributeName,
    this.attributeType,
  });

  factory AwsDynamoDbTableAttributeDefinition.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableAttributeDefinition(
      attributeName: json['AttributeName'] as String?,
      attributeType: json['AttributeType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attributeName = this.attributeName;
    final attributeType = this.attributeType;
    return {
      if (attributeName != null) 'AttributeName': attributeName,
      if (attributeType != null) 'AttributeType': attributeType,
    };
  }
}

/// Provides information about the billing for read/write capacity on the table.
class AwsDynamoDbTableBillingModeSummary {
  /// The method used to charge for read and write throughput and to manage
  /// capacity.
  final String? billingMode;

  /// If the billing mode is <code>PAY_PER_REQUEST</code>, indicates when the
  /// billing mode was set to that value.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastUpdateToPayPerRequestDateTime;

  AwsDynamoDbTableBillingModeSummary({
    this.billingMode,
    this.lastUpdateToPayPerRequestDateTime,
  });

  factory AwsDynamoDbTableBillingModeSummary.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableBillingModeSummary(
      billingMode: json['BillingMode'] as String?,
      lastUpdateToPayPerRequestDateTime:
          json['LastUpdateToPayPerRequestDateTime'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final billingMode = this.billingMode;
    final lastUpdateToPayPerRequestDateTime =
        this.lastUpdateToPayPerRequestDateTime;
    return {
      if (billingMode != null) 'BillingMode': billingMode,
      if (lastUpdateToPayPerRequestDateTime != null)
        'LastUpdateToPayPerRequestDateTime': lastUpdateToPayPerRequestDateTime,
    };
  }
}

/// Provides details about a DynamoDB table.
class AwsDynamoDbTableDetails {
  /// A list of attribute definitions for the table.
  final List<AwsDynamoDbTableAttributeDefinition>? attributeDefinitions;

  /// Information about the billing for read/write capacity on the table.
  final AwsDynamoDbTableBillingModeSummary? billingModeSummary;

  /// Indicates when the table was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? creationDateTime;

  /// Indicates whether deletion protection is to be enabled (true) or disabled
  /// (false) on the table.
  final bool? deletionProtectionEnabled;

  /// List of global secondary indexes for the table.
  final List<AwsDynamoDbTableGlobalSecondaryIndex>? globalSecondaryIndexes;

  /// The version of global tables being used.
  final String? globalTableVersion;

  /// The number of items in the table.
  final int? itemCount;

  /// The primary key structure for the table.
  final List<AwsDynamoDbTableKeySchema>? keySchema;

  /// The ARN of the latest stream for the table.
  final String? latestStreamArn;

  /// The label of the latest stream. The label is not a unique identifier.
  final String? latestStreamLabel;

  /// The list of local secondary indexes for the table.
  final List<AwsDynamoDbTableLocalSecondaryIndex>? localSecondaryIndexes;

  /// Information about the provisioned throughput for the table.
  final AwsDynamoDbTableProvisionedThroughput? provisionedThroughput;

  /// The list of replicas of this table.
  final List<AwsDynamoDbTableReplica>? replicas;

  /// Information about the restore for the table.
  final AwsDynamoDbTableRestoreSummary? restoreSummary;

  /// Information about the server-side encryption for the table.
  final AwsDynamoDbTableSseDescription? sseDescription;

  /// The current DynamoDB Streams configuration for the table.
  final AwsDynamoDbTableStreamSpecification? streamSpecification;

  /// The identifier of the table.
  final String? tableId;

  /// The name of the table.
  final String? tableName;

  /// The total size of the table in bytes.
  final int? tableSizeBytes;

  /// The current status of the table. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ACTIVE</code>
  /// </li>
  /// <li>
  /// <code>ARCHIVED</code>
  /// </li>
  /// <li>
  /// <code>ARCHIVING</code>
  /// </li>
  /// <li>
  /// <code>CREATING</code>
  /// </li>
  /// <li>
  /// <code>DELETING</code>
  /// </li>
  /// <li>
  /// <code>INACCESSIBLE_ENCRYPTION_CREDENTIALS</code>
  /// </li>
  /// <li>
  /// <code>UPDATING</code>
  /// </li>
  /// </ul>
  final String? tableStatus;

  AwsDynamoDbTableDetails({
    this.attributeDefinitions,
    this.billingModeSummary,
    this.creationDateTime,
    this.deletionProtectionEnabled,
    this.globalSecondaryIndexes,
    this.globalTableVersion,
    this.itemCount,
    this.keySchema,
    this.latestStreamArn,
    this.latestStreamLabel,
    this.localSecondaryIndexes,
    this.provisionedThroughput,
    this.replicas,
    this.restoreSummary,
    this.sseDescription,
    this.streamSpecification,
    this.tableId,
    this.tableName,
    this.tableSizeBytes,
    this.tableStatus,
  });

  factory AwsDynamoDbTableDetails.fromJson(Map<String, dynamic> json) {
    return AwsDynamoDbTableDetails(
      attributeDefinitions: (json['AttributeDefinitions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsDynamoDbTableAttributeDefinition.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      billingModeSummary: json['BillingModeSummary'] != null
          ? AwsDynamoDbTableBillingModeSummary.fromJson(
              json['BillingModeSummary'] as Map<String, dynamic>)
          : null,
      creationDateTime: json['CreationDateTime'] as String?,
      deletionProtectionEnabled: json['DeletionProtectionEnabled'] as bool?,
      globalSecondaryIndexes: (json['GlobalSecondaryIndexes'] as List?)
          ?.whereNotNull()
          .map((e) => AwsDynamoDbTableGlobalSecondaryIndex.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      globalTableVersion: json['GlobalTableVersion'] as String?,
      itemCount: json['ItemCount'] as int?,
      keySchema: (json['KeySchema'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsDynamoDbTableKeySchema.fromJson(e as Map<String, dynamic>))
          .toList(),
      latestStreamArn: json['LatestStreamArn'] as String?,
      latestStreamLabel: json['LatestStreamLabel'] as String?,
      localSecondaryIndexes: (json['LocalSecondaryIndexes'] as List?)
          ?.whereNotNull()
          .map((e) => AwsDynamoDbTableLocalSecondaryIndex.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      provisionedThroughput: json['ProvisionedThroughput'] != null
          ? AwsDynamoDbTableProvisionedThroughput.fromJson(
              json['ProvisionedThroughput'] as Map<String, dynamic>)
          : null,
      replicas: (json['Replicas'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsDynamoDbTableReplica.fromJson(e as Map<String, dynamic>))
          .toList(),
      restoreSummary: json['RestoreSummary'] != null
          ? AwsDynamoDbTableRestoreSummary.fromJson(
              json['RestoreSummary'] as Map<String, dynamic>)
          : null,
      sseDescription: json['SseDescription'] != null
          ? AwsDynamoDbTableSseDescription.fromJson(
              json['SseDescription'] as Map<String, dynamic>)
          : null,
      streamSpecification: json['StreamSpecification'] != null
          ? AwsDynamoDbTableStreamSpecification.fromJson(
              json['StreamSpecification'] as Map<String, dynamic>)
          : null,
      tableId: json['TableId'] as String?,
      tableName: json['TableName'] as String?,
      tableSizeBytes: json['TableSizeBytes'] as int?,
      tableStatus: json['TableStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attributeDefinitions = this.attributeDefinitions;
    final billingModeSummary = this.billingModeSummary;
    final creationDateTime = this.creationDateTime;
    final deletionProtectionEnabled = this.deletionProtectionEnabled;
    final globalSecondaryIndexes = this.globalSecondaryIndexes;
    final globalTableVersion = this.globalTableVersion;
    final itemCount = this.itemCount;
    final keySchema = this.keySchema;
    final latestStreamArn = this.latestStreamArn;
    final latestStreamLabel = this.latestStreamLabel;
    final localSecondaryIndexes = this.localSecondaryIndexes;
    final provisionedThroughput = this.provisionedThroughput;
    final replicas = this.replicas;
    final restoreSummary = this.restoreSummary;
    final sseDescription = this.sseDescription;
    final streamSpecification = this.streamSpecification;
    final tableId = this.tableId;
    final tableName = this.tableName;
    final tableSizeBytes = this.tableSizeBytes;
    final tableStatus = this.tableStatus;
    return {
      if (attributeDefinitions != null)
        'AttributeDefinitions': attributeDefinitions,
      if (billingModeSummary != null) 'BillingModeSummary': billingModeSummary,
      if (creationDateTime != null) 'CreationDateTime': creationDateTime,
      if (deletionProtectionEnabled != null)
        'DeletionProtectionEnabled': deletionProtectionEnabled,
      if (globalSecondaryIndexes != null)
        'GlobalSecondaryIndexes': globalSecondaryIndexes,
      if (globalTableVersion != null) 'GlobalTableVersion': globalTableVersion,
      if (itemCount != null) 'ItemCount': itemCount,
      if (keySchema != null) 'KeySchema': keySchema,
      if (latestStreamArn != null) 'LatestStreamArn': latestStreamArn,
      if (latestStreamLabel != null) 'LatestStreamLabel': latestStreamLabel,
      if (localSecondaryIndexes != null)
        'LocalSecondaryIndexes': localSecondaryIndexes,
      if (provisionedThroughput != null)
        'ProvisionedThroughput': provisionedThroughput,
      if (replicas != null) 'Replicas': replicas,
      if (restoreSummary != null) 'RestoreSummary': restoreSummary,
      if (sseDescription != null) 'SseDescription': sseDescription,
      if (streamSpecification != null)
        'StreamSpecification': streamSpecification,
      if (tableId != null) 'TableId': tableId,
      if (tableName != null) 'TableName': tableName,
      if (tableSizeBytes != null) 'TableSizeBytes': tableSizeBytes,
      if (tableStatus != null) 'TableStatus': tableStatus,
    };
  }
}

/// Information abut a global secondary index for the table.
class AwsDynamoDbTableGlobalSecondaryIndex {
  /// Whether the index is currently backfilling.
  final bool? backfilling;

  /// The ARN of the index.
  final String? indexArn;

  /// The name of the index.
  final String? indexName;

  /// The total size in bytes of the index.
  final int? indexSizeBytes;

  /// The current status of the index.
  ///
  /// <ul>
  /// <li>
  /// <code>ACTIVE</code>
  /// </li>
  /// <li>
  /// <code>CREATING</code>
  /// </li>
  /// <li>
  /// <code>DELETING</code>
  /// </li>
  /// <li>
  /// <code>UPDATING</code>
  /// </li>
  /// </ul>
  final String? indexStatus;

  /// The number of items in the index.
  final int? itemCount;

  /// The key schema for the index.
  final List<AwsDynamoDbTableKeySchema>? keySchema;

  /// Attributes that are copied from the table into an index.
  final AwsDynamoDbTableProjection? projection;

  /// Information about the provisioned throughput settings for the indexes.
  final AwsDynamoDbTableProvisionedThroughput? provisionedThroughput;

  AwsDynamoDbTableGlobalSecondaryIndex({
    this.backfilling,
    this.indexArn,
    this.indexName,
    this.indexSizeBytes,
    this.indexStatus,
    this.itemCount,
    this.keySchema,
    this.projection,
    this.provisionedThroughput,
  });

  factory AwsDynamoDbTableGlobalSecondaryIndex.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableGlobalSecondaryIndex(
      backfilling: json['Backfilling'] as bool?,
      indexArn: json['IndexArn'] as String?,
      indexName: json['IndexName'] as String?,
      indexSizeBytes: json['IndexSizeBytes'] as int?,
      indexStatus: json['IndexStatus'] as String?,
      itemCount: json['ItemCount'] as int?,
      keySchema: (json['KeySchema'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsDynamoDbTableKeySchema.fromJson(e as Map<String, dynamic>))
          .toList(),
      projection: json['Projection'] != null
          ? AwsDynamoDbTableProjection.fromJson(
              json['Projection'] as Map<String, dynamic>)
          : null,
      provisionedThroughput: json['ProvisionedThroughput'] != null
          ? AwsDynamoDbTableProvisionedThroughput.fromJson(
              json['ProvisionedThroughput'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final backfilling = this.backfilling;
    final indexArn = this.indexArn;
    final indexName = this.indexName;
    final indexSizeBytes = this.indexSizeBytes;
    final indexStatus = this.indexStatus;
    final itemCount = this.itemCount;
    final keySchema = this.keySchema;
    final projection = this.projection;
    final provisionedThroughput = this.provisionedThroughput;
    return {
      if (backfilling != null) 'Backfilling': backfilling,
      if (indexArn != null) 'IndexArn': indexArn,
      if (indexName != null) 'IndexName': indexName,
      if (indexSizeBytes != null) 'IndexSizeBytes': indexSizeBytes,
      if (indexStatus != null) 'IndexStatus': indexStatus,
      if (itemCount != null) 'ItemCount': itemCount,
      if (keySchema != null) 'KeySchema': keySchema,
      if (projection != null) 'Projection': projection,
      if (provisionedThroughput != null)
        'ProvisionedThroughput': provisionedThroughput,
    };
  }
}

/// A component of the key schema for the DynamoDB table, a global secondary
/// index, or a local secondary index.
class AwsDynamoDbTableKeySchema {
  /// The name of the key schema attribute.
  final String? attributeName;

  /// The type of key used for the key schema attribute. Valid values are
  /// <code>HASH</code> or <code>RANGE</code>.
  final String? keyType;

  AwsDynamoDbTableKeySchema({
    this.attributeName,
    this.keyType,
  });

  factory AwsDynamoDbTableKeySchema.fromJson(Map<String, dynamic> json) {
    return AwsDynamoDbTableKeySchema(
      attributeName: json['AttributeName'] as String?,
      keyType: json['KeyType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attributeName = this.attributeName;
    final keyType = this.keyType;
    return {
      if (attributeName != null) 'AttributeName': attributeName,
      if (keyType != null) 'KeyType': keyType,
    };
  }
}

/// Information about a local secondary index for a DynamoDB table.
class AwsDynamoDbTableLocalSecondaryIndex {
  /// The ARN of the index.
  final String? indexArn;

  /// The name of the index.
  final String? indexName;

  /// The complete key schema for the index.
  final List<AwsDynamoDbTableKeySchema>? keySchema;

  /// Attributes that are copied from the table into the index. These are in
  /// addition to the primary key attributes and index key attributes, which are
  /// automatically projected.
  final AwsDynamoDbTableProjection? projection;

  AwsDynamoDbTableLocalSecondaryIndex({
    this.indexArn,
    this.indexName,
    this.keySchema,
    this.projection,
  });

  factory AwsDynamoDbTableLocalSecondaryIndex.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableLocalSecondaryIndex(
      indexArn: json['IndexArn'] as String?,
      indexName: json['IndexName'] as String?,
      keySchema: (json['KeySchema'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsDynamoDbTableKeySchema.fromJson(e as Map<String, dynamic>))
          .toList(),
      projection: json['Projection'] != null
          ? AwsDynamoDbTableProjection.fromJson(
              json['Projection'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final indexArn = this.indexArn;
    final indexName = this.indexName;
    final keySchema = this.keySchema;
    final projection = this.projection;
    return {
      if (indexArn != null) 'IndexArn': indexArn,
      if (indexName != null) 'IndexName': indexName,
      if (keySchema != null) 'KeySchema': keySchema,
      if (projection != null) 'Projection': projection,
    };
  }
}

/// For global and local secondary indexes, identifies the attributes that are
/// copied from the table into the index.
class AwsDynamoDbTableProjection {
  /// The nonkey attributes that are projected into the index. For each attribute,
  /// provide the attribute name.
  final List<String>? nonKeyAttributes;

  /// The types of attributes that are projected into the index. Valid values are
  /// as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL</code>
  /// </li>
  /// <li>
  /// <code>INCLUDE</code>
  /// </li>
  /// <li>
  /// <code>KEYS_ONLY</code>
  /// </li>
  /// </ul>
  final String? projectionType;

  AwsDynamoDbTableProjection({
    this.nonKeyAttributes,
    this.projectionType,
  });

  factory AwsDynamoDbTableProjection.fromJson(Map<String, dynamic> json) {
    return AwsDynamoDbTableProjection(
      nonKeyAttributes: (json['NonKeyAttributes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      projectionType: json['ProjectionType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final nonKeyAttributes = this.nonKeyAttributes;
    final projectionType = this.projectionType;
    return {
      if (nonKeyAttributes != null) 'NonKeyAttributes': nonKeyAttributes,
      if (projectionType != null) 'ProjectionType': projectionType,
    };
  }
}

/// Information about the provisioned throughput for the table or for a global
/// secondary index.
class AwsDynamoDbTableProvisionedThroughput {
  /// Indicates when the provisioned throughput was last decreased.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastDecreaseDateTime;

  /// Indicates when the provisioned throughput was last increased.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastIncreaseDateTime;

  /// The number of times during the current UTC calendar day that the provisioned
  /// throughput was decreased.
  final int? numberOfDecreasesToday;

  /// The maximum number of strongly consistent reads consumed per second before
  /// DynamoDB returns a <code>ThrottlingException</code>.
  final int? readCapacityUnits;

  /// The maximum number of writes consumed per second before DynamoDB returns a
  /// <code>ThrottlingException</code>.
  final int? writeCapacityUnits;

  AwsDynamoDbTableProvisionedThroughput({
    this.lastDecreaseDateTime,
    this.lastIncreaseDateTime,
    this.numberOfDecreasesToday,
    this.readCapacityUnits,
    this.writeCapacityUnits,
  });

  factory AwsDynamoDbTableProvisionedThroughput.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableProvisionedThroughput(
      lastDecreaseDateTime: json['LastDecreaseDateTime'] as String?,
      lastIncreaseDateTime: json['LastIncreaseDateTime'] as String?,
      numberOfDecreasesToday: json['NumberOfDecreasesToday'] as int?,
      readCapacityUnits: json['ReadCapacityUnits'] as int?,
      writeCapacityUnits: json['WriteCapacityUnits'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final lastDecreaseDateTime = this.lastDecreaseDateTime;
    final lastIncreaseDateTime = this.lastIncreaseDateTime;
    final numberOfDecreasesToday = this.numberOfDecreasesToday;
    final readCapacityUnits = this.readCapacityUnits;
    final writeCapacityUnits = this.writeCapacityUnits;
    return {
      if (lastDecreaseDateTime != null)
        'LastDecreaseDateTime': lastDecreaseDateTime,
      if (lastIncreaseDateTime != null)
        'LastIncreaseDateTime': lastIncreaseDateTime,
      if (numberOfDecreasesToday != null)
        'NumberOfDecreasesToday': numberOfDecreasesToday,
      if (readCapacityUnits != null) 'ReadCapacityUnits': readCapacityUnits,
      if (writeCapacityUnits != null) 'WriteCapacityUnits': writeCapacityUnits,
    };
  }
}

/// Replica-specific configuration for the provisioned throughput.
class AwsDynamoDbTableProvisionedThroughputOverride {
  /// The read capacity units for the replica.
  final int? readCapacityUnits;

  AwsDynamoDbTableProvisionedThroughputOverride({
    this.readCapacityUnits,
  });

  factory AwsDynamoDbTableProvisionedThroughputOverride.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableProvisionedThroughputOverride(
      readCapacityUnits: json['ReadCapacityUnits'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final readCapacityUnits = this.readCapacityUnits;
    return {
      if (readCapacityUnits != null) 'ReadCapacityUnits': readCapacityUnits,
    };
  }
}

/// Information about a replica of a DynamoDB table.
class AwsDynamoDbTableReplica {
  /// List of global secondary indexes for the replica.
  final List<AwsDynamoDbTableReplicaGlobalSecondaryIndex>?
      globalSecondaryIndexes;

  /// The identifier of the KMS key that will be used for KMS encryption for the
  /// replica.
  final String? kmsMasterKeyId;

  /// Replica-specific configuration for the provisioned throughput.
  final AwsDynamoDbTableProvisionedThroughputOverride?
      provisionedThroughputOverride;

  /// The name of the Region where the replica is located.
  final String? regionName;

  /// The current status of the replica. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ACTIVE</code>
  /// </li>
  /// <li>
  /// <code>CREATING</code>
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code>
  /// </li>
  /// <li>
  /// <code>DELETING</code>
  /// </li>
  /// <li>
  /// <code>UPDATING</code>
  /// </li>
  /// </ul>
  final String? replicaStatus;

  /// Detailed information about the replica status.
  final String? replicaStatusDescription;

  AwsDynamoDbTableReplica({
    this.globalSecondaryIndexes,
    this.kmsMasterKeyId,
    this.provisionedThroughputOverride,
    this.regionName,
    this.replicaStatus,
    this.replicaStatusDescription,
  });

  factory AwsDynamoDbTableReplica.fromJson(Map<String, dynamic> json) {
    return AwsDynamoDbTableReplica(
      globalSecondaryIndexes: (json['GlobalSecondaryIndexes'] as List?)
          ?.whereNotNull()
          .map((e) => AwsDynamoDbTableReplicaGlobalSecondaryIndex.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      kmsMasterKeyId: json['KmsMasterKeyId'] as String?,
      provisionedThroughputOverride:
          json['ProvisionedThroughputOverride'] != null
              ? AwsDynamoDbTableProvisionedThroughputOverride.fromJson(
                  json['ProvisionedThroughputOverride'] as Map<String, dynamic>)
              : null,
      regionName: json['RegionName'] as String?,
      replicaStatus: json['ReplicaStatus'] as String?,
      replicaStatusDescription: json['ReplicaStatusDescription'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final globalSecondaryIndexes = this.globalSecondaryIndexes;
    final kmsMasterKeyId = this.kmsMasterKeyId;
    final provisionedThroughputOverride = this.provisionedThroughputOverride;
    final regionName = this.regionName;
    final replicaStatus = this.replicaStatus;
    final replicaStatusDescription = this.replicaStatusDescription;
    return {
      if (globalSecondaryIndexes != null)
        'GlobalSecondaryIndexes': globalSecondaryIndexes,
      if (kmsMasterKeyId != null) 'KmsMasterKeyId': kmsMasterKeyId,
      if (provisionedThroughputOverride != null)
        'ProvisionedThroughputOverride': provisionedThroughputOverride,
      if (regionName != null) 'RegionName': regionName,
      if (replicaStatus != null) 'ReplicaStatus': replicaStatus,
      if (replicaStatusDescription != null)
        'ReplicaStatusDescription': replicaStatusDescription,
    };
  }
}

/// Information about a global secondary index for a DynamoDB table replica.
class AwsDynamoDbTableReplicaGlobalSecondaryIndex {
  /// The name of the index.
  final String? indexName;

  /// Replica-specific configuration for the provisioned throughput for the index.
  final AwsDynamoDbTableProvisionedThroughputOverride?
      provisionedThroughputOverride;

  AwsDynamoDbTableReplicaGlobalSecondaryIndex({
    this.indexName,
    this.provisionedThroughputOverride,
  });

  factory AwsDynamoDbTableReplicaGlobalSecondaryIndex.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableReplicaGlobalSecondaryIndex(
      indexName: json['IndexName'] as String?,
      provisionedThroughputOverride:
          json['ProvisionedThroughputOverride'] != null
              ? AwsDynamoDbTableProvisionedThroughputOverride.fromJson(
                  json['ProvisionedThroughputOverride'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final indexName = this.indexName;
    final provisionedThroughputOverride = this.provisionedThroughputOverride;
    return {
      if (indexName != null) 'IndexName': indexName,
      if (provisionedThroughputOverride != null)
        'ProvisionedThroughputOverride': provisionedThroughputOverride,
    };
  }
}

/// Information about the restore for the table.
class AwsDynamoDbTableRestoreSummary {
  /// Indicates the point in time that the table was restored to.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? restoreDateTime;

  /// Whether a restore is currently in progress.
  final bool? restoreInProgress;

  /// The ARN of the source backup from which the table was restored.
  final String? sourceBackupArn;

  /// The ARN of the source table for the backup.
  final String? sourceTableArn;

  AwsDynamoDbTableRestoreSummary({
    this.restoreDateTime,
    this.restoreInProgress,
    this.sourceBackupArn,
    this.sourceTableArn,
  });

  factory AwsDynamoDbTableRestoreSummary.fromJson(Map<String, dynamic> json) {
    return AwsDynamoDbTableRestoreSummary(
      restoreDateTime: json['RestoreDateTime'] as String?,
      restoreInProgress: json['RestoreInProgress'] as bool?,
      sourceBackupArn: json['SourceBackupArn'] as String?,
      sourceTableArn: json['SourceTableArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final restoreDateTime = this.restoreDateTime;
    final restoreInProgress = this.restoreInProgress;
    final sourceBackupArn = this.sourceBackupArn;
    final sourceTableArn = this.sourceTableArn;
    return {
      if (restoreDateTime != null) 'RestoreDateTime': restoreDateTime,
      if (restoreInProgress != null) 'RestoreInProgress': restoreInProgress,
      if (sourceBackupArn != null) 'SourceBackupArn': sourceBackupArn,
      if (sourceTableArn != null) 'SourceTableArn': sourceTableArn,
    };
  }
}

/// Information about the server-side encryption for the table.
class AwsDynamoDbTableSseDescription {
  /// If the key is inaccessible, the date and time when DynamoDB detected that
  /// the key was inaccessible.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? inaccessibleEncryptionDateTime;

  /// The ARN of the KMS key that is used for the KMS encryption.
  final String? kmsMasterKeyArn;

  /// The type of server-side encryption.
  final String? sseType;

  /// The status of the server-side encryption.
  final String? status;

  AwsDynamoDbTableSseDescription({
    this.inaccessibleEncryptionDateTime,
    this.kmsMasterKeyArn,
    this.sseType,
    this.status,
  });

  factory AwsDynamoDbTableSseDescription.fromJson(Map<String, dynamic> json) {
    return AwsDynamoDbTableSseDescription(
      inaccessibleEncryptionDateTime:
          json['InaccessibleEncryptionDateTime'] as String?,
      kmsMasterKeyArn: json['KmsMasterKeyArn'] as String?,
      sseType: json['SseType'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final inaccessibleEncryptionDateTime = this.inaccessibleEncryptionDateTime;
    final kmsMasterKeyArn = this.kmsMasterKeyArn;
    final sseType = this.sseType;
    final status = this.status;
    return {
      if (inaccessibleEncryptionDateTime != null)
        'InaccessibleEncryptionDateTime': inaccessibleEncryptionDateTime,
      if (kmsMasterKeyArn != null) 'KmsMasterKeyArn': kmsMasterKeyArn,
      if (sseType != null) 'SseType': sseType,
      if (status != null) 'Status': status,
    };
  }
}

/// The current DynamoDB Streams configuration for the table.
class AwsDynamoDbTableStreamSpecification {
  /// Indicates whether DynamoDB Streams is enabled on the table.
  final bool? streamEnabled;

  /// Determines the information that is written to the table.
  final String? streamViewType;

  AwsDynamoDbTableStreamSpecification({
    this.streamEnabled,
    this.streamViewType,
  });

  factory AwsDynamoDbTableStreamSpecification.fromJson(
      Map<String, dynamic> json) {
    return AwsDynamoDbTableStreamSpecification(
      streamEnabled: json['StreamEnabled'] as bool?,
      streamViewType: json['StreamViewType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final streamEnabled = this.streamEnabled;
    final streamViewType = this.streamViewType;
    return {
      if (streamEnabled != null) 'StreamEnabled': streamEnabled,
      if (streamViewType != null) 'StreamViewType': streamViewType,
    };
  }
}

/// Provides details about an Active Directory that’s used to authenticate an
/// Client VPN endpoint.
class AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails {
  /// The ID of the Active Directory used for authentication.
  final String? directoryId;

  AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails({
    this.directoryId,
  });

  factory AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails(
      directoryId: json['DirectoryId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final directoryId = this.directoryId;
    return {
      if (directoryId != null) 'DirectoryId': directoryId,
    };
  }
}

/// Information about the authentication method used by the Client VPN endpoint.
class AwsEc2ClientVpnEndpointAuthenticationOptionsDetails {
  /// Information about the Active Directory, if applicable. With Active Directory
  /// authentication, clients are authenticated against existing Active Directory
  /// groups.
  final AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails?
      activeDirectory;

  /// Information about the IAM SAML identity provider, if applicable.
  final AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails?
      federatedAuthentication;

  /// Information about the authentication certificates, if applicable.
  final AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails?
      mutualAuthentication;

  /// The authentication type used.
  final String? type;

  AwsEc2ClientVpnEndpointAuthenticationOptionsDetails({
    this.activeDirectory,
    this.federatedAuthentication,
    this.mutualAuthentication,
    this.type,
  });

  factory AwsEc2ClientVpnEndpointAuthenticationOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointAuthenticationOptionsDetails(
      activeDirectory: json['ActiveDirectory'] != null
          ? AwsEc2ClientVpnEndpointAuthenticationOptionsActiveDirectoryDetails
              .fromJson(json['ActiveDirectory'] as Map<String, dynamic>)
          : null,
      federatedAuthentication: json['FederatedAuthentication'] != null
          ? AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails
              .fromJson(json['FederatedAuthentication'] as Map<String, dynamic>)
          : null,
      mutualAuthentication: json['MutualAuthentication'] != null
          ? AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails
              .fromJson(json['MutualAuthentication'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final activeDirectory = this.activeDirectory;
    final federatedAuthentication = this.federatedAuthentication;
    final mutualAuthentication = this.mutualAuthentication;
    final type = this.type;
    return {
      if (activeDirectory != null) 'ActiveDirectory': activeDirectory,
      if (federatedAuthentication != null)
        'FederatedAuthentication': federatedAuthentication,
      if (mutualAuthentication != null)
        'MutualAuthentication': mutualAuthentication,
      if (type != null) 'Type': type,
    };
  }
}

/// Describes the IAM SAML identity providers used for federated authentication.
class AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails {
  /// The Amazon Resource Name (ARN) of the IAM SAML identity provider.
  final String? samlProviderArn;

  /// The Amazon Resource Name (ARN) of the IAM SAML identity provider for the
  /// self-service portal.
  final String? selfServiceSamlProviderArn;

  AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails({
    this.samlProviderArn,
    this.selfServiceSamlProviderArn,
  });

  factory AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointAuthenticationOptionsFederatedAuthenticationDetails(
      samlProviderArn: json['SamlProviderArn'] as String?,
      selfServiceSamlProviderArn: json['SelfServiceSamlProviderArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final samlProviderArn = this.samlProviderArn;
    final selfServiceSamlProviderArn = this.selfServiceSamlProviderArn;
    return {
      if (samlProviderArn != null) 'SamlProviderArn': samlProviderArn,
      if (selfServiceSamlProviderArn != null)
        'SelfServiceSamlProviderArn': selfServiceSamlProviderArn,
    };
  }
}

/// Information about the client certificate used for authentication.
class AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails {
  /// The Amazon Resource Name (ARN) of the client certificate.
  final String? clientRootCertificateChain;

  AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails({
    this.clientRootCertificateChain,
  });

  factory AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointAuthenticationOptionsMutualAuthenticationDetails(
      clientRootCertificateChain: json['ClientRootCertificateChain'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final clientRootCertificateChain = this.clientRootCertificateChain;
    return {
      if (clientRootCertificateChain != null)
        'ClientRootCertificateChain': clientRootCertificateChain,
    };
  }
}

/// The options for managing connection authorization for new client
/// connections.
class AwsEc2ClientVpnEndpointClientConnectOptionsDetails {
  /// Indicates whether client connect options are enabled.
  final bool? enabled;

  /// The Amazon Resource Name (ARN) of the Lambda function used for connection
  /// authorization.
  final String? lambdaFunctionArn;

  /// The status of any updates to the client connect options.
  final AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails? status;

  AwsEc2ClientVpnEndpointClientConnectOptionsDetails({
    this.enabled,
    this.lambdaFunctionArn,
    this.status,
  });

  factory AwsEc2ClientVpnEndpointClientConnectOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointClientConnectOptionsDetails(
      enabled: json['Enabled'] as bool?,
      lambdaFunctionArn: json['LambdaFunctionArn'] as String?,
      status: json['Status'] != null
          ? AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails.fromJson(
              json['Status'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final lambdaFunctionArn = this.lambdaFunctionArn;
    final status = this.status;
    return {
      if (enabled != null) 'Enabled': enabled,
      if (lambdaFunctionArn != null) 'LambdaFunctionArn': lambdaFunctionArn,
      if (status != null) 'Status': status,
    };
  }
}

/// Describes the status of the Client VPN endpoint attribute.
class AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails {
  /// The status code.
  final String? code;

  /// The status message.
  final String? message;

  AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails({
    this.code,
    this.message,
  });

  factory AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointClientConnectOptionsStatusDetails(
      code: json['Code'] as String?,
      message: json['Message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final code = this.code;
    final message = this.message;
    return {
      if (code != null) 'Code': code,
      if (message != null) 'Message': message,
    };
  }
}

/// Options for enabling a customizable text banner that will be displayed on
/// Amazon Web Services provided clients when a VPN session is established.
class AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails {
  /// Customizable text that will be displayed in a banner on Amazon Web Services
  /// provided clients when a VPN session is established.
  final String? bannerText;

  /// Current state of text banner feature.
  final bool? enabled;

  AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails({
    this.bannerText,
    this.enabled,
  });

  factory AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails(
      bannerText: json['BannerText'] as String?,
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final bannerText = this.bannerText;
    final enabled = this.enabled;
    return {
      if (bannerText != null) 'BannerText': bannerText,
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Information about the client connection logging options for the Client VPN
/// endpoint.
class AwsEc2ClientVpnEndpointConnectionLogOptionsDetails {
  /// The name of the Amazon CloudWatch Logs log group to which connection logging
  /// data is published.
  final String? cloudwatchLogGroup;

  /// The name of the Amazon CloudWatch Logs log stream to which connection
  /// logging data is published.
  final String? cloudwatchLogStream;

  /// Indicates whether client connection logging is enabled for the Client VPN
  /// endpoint.
  final bool? enabled;

  AwsEc2ClientVpnEndpointConnectionLogOptionsDetails({
    this.cloudwatchLogGroup,
    this.cloudwatchLogStream,
    this.enabled,
  });

  factory AwsEc2ClientVpnEndpointConnectionLogOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointConnectionLogOptionsDetails(
      cloudwatchLogGroup: json['CloudwatchLogGroup'] as String?,
      cloudwatchLogStream: json['CloudwatchLogStream'] as String?,
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudwatchLogGroup = this.cloudwatchLogGroup;
    final cloudwatchLogStream = this.cloudwatchLogStream;
    final enabled = this.enabled;
    return {
      if (cloudwatchLogGroup != null) 'CloudwatchLogGroup': cloudwatchLogGroup,
      if (cloudwatchLogStream != null)
        'CloudwatchLogStream': cloudwatchLogStream,
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Describes an Client VPN endpoint. A Client VPN endpoint is the resource that
/// you create and configure to enable and manage client VPN sessions. It's the
/// termination point for all client VPN sessions.
class AwsEc2ClientVpnEndpointDetails {
  /// Information about the authentication method used by the Client VPN endpoint.
  final List<AwsEc2ClientVpnEndpointAuthenticationOptionsDetails>?
      authenticationOptions;

  /// The IPv4 address range, in CIDR notation, from which client IP addresses are
  /// assigned.
  final String? clientCidrBlock;

  /// The options for managing connection authorization for new client
  /// connections.
  final AwsEc2ClientVpnEndpointClientConnectOptionsDetails?
      clientConnectOptions;

  /// Options for enabling a customizable text banner that will be displayed on
  /// Amazon Web Services provided clients when a VPN session is established.
  final AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails?
      clientLoginBannerOptions;

  /// The ID of the Client VPN endpoint.
  final String? clientVpnEndpointId;

  /// Information about the client connection logging options for the Client VPN
  /// endpoint.
  final AwsEc2ClientVpnEndpointConnectionLogOptionsDetails?
      connectionLogOptions;

  /// A brief description of the endpoint.
  final String? description;

  /// Information about the DNS servers to be used for DNS resolution.
  final List<String>? dnsServer;

  /// The IDs of the security groups for the target network.
  final List<String>? securityGroupIdSet;

  /// The URL of the self-service portal.
  final String? selfServicePortalUrl;

  /// The Amazon Resource Name (ARN) of the server certificate.
  final String? serverCertificateArn;

  /// The maximum VPN session duration time in hours.
  final int? sessionTimeoutHours;

  /// Indicates whether split-tunnel is enabled in the Client VPN endpoint.
  final bool? splitTunnel;

  /// The transport protocol used by the Client VPN endpoint.
  final String? transportProtocol;

  /// The ID of the VPC.
  final String? vpcId;

  /// The port number for the Client VPN endpoint.
  final int? vpnPort;

  AwsEc2ClientVpnEndpointDetails({
    this.authenticationOptions,
    this.clientCidrBlock,
    this.clientConnectOptions,
    this.clientLoginBannerOptions,
    this.clientVpnEndpointId,
    this.connectionLogOptions,
    this.description,
    this.dnsServer,
    this.securityGroupIdSet,
    this.selfServicePortalUrl,
    this.serverCertificateArn,
    this.sessionTimeoutHours,
    this.splitTunnel,
    this.transportProtocol,
    this.vpcId,
    this.vpnPort,
  });

  factory AwsEc2ClientVpnEndpointDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2ClientVpnEndpointDetails(
      authenticationOptions: (json['AuthenticationOptions'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2ClientVpnEndpointAuthenticationOptionsDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      clientCidrBlock: json['ClientCidrBlock'] as String?,
      clientConnectOptions: json['ClientConnectOptions'] != null
          ? AwsEc2ClientVpnEndpointClientConnectOptionsDetails.fromJson(
              json['ClientConnectOptions'] as Map<String, dynamic>)
          : null,
      clientLoginBannerOptions: json['ClientLoginBannerOptions'] != null
          ? AwsEc2ClientVpnEndpointClientLoginBannerOptionsDetails.fromJson(
              json['ClientLoginBannerOptions'] as Map<String, dynamic>)
          : null,
      clientVpnEndpointId: json['ClientVpnEndpointId'] as String?,
      connectionLogOptions: json['ConnectionLogOptions'] != null
          ? AwsEc2ClientVpnEndpointConnectionLogOptionsDetails.fromJson(
              json['ConnectionLogOptions'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      dnsServer: (json['DnsServer'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      securityGroupIdSet: (json['SecurityGroupIdSet'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      selfServicePortalUrl: json['SelfServicePortalUrl'] as String?,
      serverCertificateArn: json['ServerCertificateArn'] as String?,
      sessionTimeoutHours: json['SessionTimeoutHours'] as int?,
      splitTunnel: json['SplitTunnel'] as bool?,
      transportProtocol: json['TransportProtocol'] as String?,
      vpcId: json['VpcId'] as String?,
      vpnPort: json['VpnPort'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final authenticationOptions = this.authenticationOptions;
    final clientCidrBlock = this.clientCidrBlock;
    final clientConnectOptions = this.clientConnectOptions;
    final clientLoginBannerOptions = this.clientLoginBannerOptions;
    final clientVpnEndpointId = this.clientVpnEndpointId;
    final connectionLogOptions = this.connectionLogOptions;
    final description = this.description;
    final dnsServer = this.dnsServer;
    final securityGroupIdSet = this.securityGroupIdSet;
    final selfServicePortalUrl = this.selfServicePortalUrl;
    final serverCertificateArn = this.serverCertificateArn;
    final sessionTimeoutHours = this.sessionTimeoutHours;
    final splitTunnel = this.splitTunnel;
    final transportProtocol = this.transportProtocol;
    final vpcId = this.vpcId;
    final vpnPort = this.vpnPort;
    return {
      if (authenticationOptions != null)
        'AuthenticationOptions': authenticationOptions,
      if (clientCidrBlock != null) 'ClientCidrBlock': clientCidrBlock,
      if (clientConnectOptions != null)
        'ClientConnectOptions': clientConnectOptions,
      if (clientLoginBannerOptions != null)
        'ClientLoginBannerOptions': clientLoginBannerOptions,
      if (clientVpnEndpointId != null)
        'ClientVpnEndpointId': clientVpnEndpointId,
      if (connectionLogOptions != null)
        'ConnectionLogOptions': connectionLogOptions,
      if (description != null) 'Description': description,
      if (dnsServer != null) 'DnsServer': dnsServer,
      if (securityGroupIdSet != null) 'SecurityGroupIdSet': securityGroupIdSet,
      if (selfServicePortalUrl != null)
        'SelfServicePortalUrl': selfServicePortalUrl,
      if (serverCertificateArn != null)
        'ServerCertificateArn': serverCertificateArn,
      if (sessionTimeoutHours != null)
        'SessionTimeoutHours': sessionTimeoutHours,
      if (splitTunnel != null) 'SplitTunnel': splitTunnel,
      if (transportProtocol != null) 'TransportProtocol': transportProtocol,
      if (vpcId != null) 'VpcId': vpcId,
      if (vpnPort != null) 'VpnPort': vpnPort,
    };
  }
}

/// Information about an Elastic IP address.
class AwsEc2EipDetails {
  /// The identifier that Amazon Web Services assigns to represent the allocation
  /// of the Elastic IP address for use with Amazon VPC.
  final String? allocationId;

  /// The identifier that represents the association of the Elastic IP address
  /// with an EC2 instance.
  final String? associationId;

  /// The domain in which to allocate the address.
  ///
  /// If the address is for use with EC2 instances in a VPC, then
  /// <code>Domain</code> is <code>vpc</code>. Otherwise, <code>Domain</code> is
  /// <code>standard</code>.
  final String? domain;

  /// The identifier of the EC2 instance.
  final String? instanceId;

  /// The name of the location from which the Elastic IP address is advertised.
  final String? networkBorderGroup;

  /// The identifier of the network interface.
  final String? networkInterfaceId;

  /// The Amazon Web Services account ID of the owner of the network interface.
  final String? networkInterfaceOwnerId;

  /// The private IP address that is associated with the Elastic IP address.
  final String? privateIpAddress;

  /// A public IP address that is associated with the EC2 instance.
  final String? publicIp;

  /// The identifier of an IP address pool. This parameter allows Amazon EC2 to
  /// select an IP address from the address pool.
  final String? publicIpv4Pool;

  AwsEc2EipDetails({
    this.allocationId,
    this.associationId,
    this.domain,
    this.instanceId,
    this.networkBorderGroup,
    this.networkInterfaceId,
    this.networkInterfaceOwnerId,
    this.privateIpAddress,
    this.publicIp,
    this.publicIpv4Pool,
  });

  factory AwsEc2EipDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2EipDetails(
      allocationId: json['AllocationId'] as String?,
      associationId: json['AssociationId'] as String?,
      domain: json['Domain'] as String?,
      instanceId: json['InstanceId'] as String?,
      networkBorderGroup: json['NetworkBorderGroup'] as String?,
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
      networkInterfaceOwnerId: json['NetworkInterfaceOwnerId'] as String?,
      privateIpAddress: json['PrivateIpAddress'] as String?,
      publicIp: json['PublicIp'] as String?,
      publicIpv4Pool: json['PublicIpv4Pool'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final allocationId = this.allocationId;
    final associationId = this.associationId;
    final domain = this.domain;
    final instanceId = this.instanceId;
    final networkBorderGroup = this.networkBorderGroup;
    final networkInterfaceId = this.networkInterfaceId;
    final networkInterfaceOwnerId = this.networkInterfaceOwnerId;
    final privateIpAddress = this.privateIpAddress;
    final publicIp = this.publicIp;
    final publicIpv4Pool = this.publicIpv4Pool;
    return {
      if (allocationId != null) 'AllocationId': allocationId,
      if (associationId != null) 'AssociationId': associationId,
      if (domain != null) 'Domain': domain,
      if (instanceId != null) 'InstanceId': instanceId,
      if (networkBorderGroup != null) 'NetworkBorderGroup': networkBorderGroup,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (networkInterfaceOwnerId != null)
        'NetworkInterfaceOwnerId': networkInterfaceOwnerId,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
      if (publicIp != null) 'PublicIp': publicIp,
      if (publicIpv4Pool != null) 'PublicIpv4Pool': publicIpv4Pool,
    };
  }
}

/// The details of an Amazon EC2 instance.
class AwsEc2InstanceDetails {
  /// The IAM profile ARN of the instance.
  final String? iamInstanceProfileArn;

  /// The Amazon Machine Image (AMI) ID of the instance.
  final String? imageId;

  /// The IPv4 addresses associated with the instance.
  final List<String>? ipV4Addresses;

  /// The IPv6 addresses associated with the instance.
  final List<String>? ipV6Addresses;

  /// The key name associated with the instance.
  final String? keyName;

  /// Indicates when the instance was launched.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? launchedAt;

  /// Details about the metadata options for the Amazon EC2 instance.
  final AwsEc2InstanceMetadataOptions? metadataOptions;

  /// Describes the type of monitoring that’s turned on for an instance.
  final AwsEc2InstanceMonitoringDetails? monitoring;

  /// The identifiers of the network interfaces for the EC2 instance. The details
  /// for each network interface are in a corresponding
  /// <code>AwsEc2NetworkInterfacesDetails</code> object.
  final List<AwsEc2InstanceNetworkInterfacesDetails>? networkInterfaces;

  /// The identifier of the subnet that the instance was launched in.
  final String? subnetId;

  /// The instance type of the instance.
  final String? type;

  /// The virtualization type of the Amazon Machine Image (AMI) required to launch
  /// the instance.
  final String? virtualizationType;

  /// The identifier of the VPC that the instance was launched in.
  final String? vpcId;

  AwsEc2InstanceDetails({
    this.iamInstanceProfileArn,
    this.imageId,
    this.ipV4Addresses,
    this.ipV6Addresses,
    this.keyName,
    this.launchedAt,
    this.metadataOptions,
    this.monitoring,
    this.networkInterfaces,
    this.subnetId,
    this.type,
    this.virtualizationType,
    this.vpcId,
  });

  factory AwsEc2InstanceDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2InstanceDetails(
      iamInstanceProfileArn: json['IamInstanceProfileArn'] as String?,
      imageId: json['ImageId'] as String?,
      ipV4Addresses: (json['IpV4Addresses'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      ipV6Addresses: (json['IpV6Addresses'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      keyName: json['KeyName'] as String?,
      launchedAt: json['LaunchedAt'] as String?,
      metadataOptions: json['MetadataOptions'] != null
          ? AwsEc2InstanceMetadataOptions.fromJson(
              json['MetadataOptions'] as Map<String, dynamic>)
          : null,
      monitoring: json['Monitoring'] != null
          ? AwsEc2InstanceMonitoringDetails.fromJson(
              json['Monitoring'] as Map<String, dynamic>)
          : null,
      networkInterfaces: (json['NetworkInterfaces'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2InstanceNetworkInterfacesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      subnetId: json['SubnetId'] as String?,
      type: json['Type'] as String?,
      virtualizationType: json['VirtualizationType'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final iamInstanceProfileArn = this.iamInstanceProfileArn;
    final imageId = this.imageId;
    final ipV4Addresses = this.ipV4Addresses;
    final ipV6Addresses = this.ipV6Addresses;
    final keyName = this.keyName;
    final launchedAt = this.launchedAt;
    final metadataOptions = this.metadataOptions;
    final monitoring = this.monitoring;
    final networkInterfaces = this.networkInterfaces;
    final subnetId = this.subnetId;
    final type = this.type;
    final virtualizationType = this.virtualizationType;
    final vpcId = this.vpcId;
    return {
      if (iamInstanceProfileArn != null)
        'IamInstanceProfileArn': iamInstanceProfileArn,
      if (imageId != null) 'ImageId': imageId,
      if (ipV4Addresses != null) 'IpV4Addresses': ipV4Addresses,
      if (ipV6Addresses != null) 'IpV6Addresses': ipV6Addresses,
      if (keyName != null) 'KeyName': keyName,
      if (launchedAt != null) 'LaunchedAt': launchedAt,
      if (metadataOptions != null) 'MetadataOptions': metadataOptions,
      if (monitoring != null) 'Monitoring': monitoring,
      if (networkInterfaces != null) 'NetworkInterfaces': networkInterfaces,
      if (subnetId != null) 'SubnetId': subnetId,
      if (type != null) 'Type': type,
      if (virtualizationType != null) 'VirtualizationType': virtualizationType,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Metadata options that allow you to configure and secure the Amazon EC2
/// instance.
class AwsEc2InstanceMetadataOptions {
  /// Enables or disables the HTTP metadata endpoint on the instance.
  final String? httpEndpoint;

  /// Enables or disables the IPv6 endpoint for the instance metadata service.
  final String? httpProtocolIpv6;

  /// The desired HTTP PUT response hop limit for instance metadata requests. The
  /// larger the number, the further instance metadata requests can travel.
  final int? httpPutResponseHopLimit;

  /// The state of token usage for your instance metadata requests.
  final String? httpTokens;

  /// Specifies whether to allow access to instance tags from the instance
  /// metadata.
  final String? instanceMetadataTags;

  AwsEc2InstanceMetadataOptions({
    this.httpEndpoint,
    this.httpProtocolIpv6,
    this.httpPutResponseHopLimit,
    this.httpTokens,
    this.instanceMetadataTags,
  });

  factory AwsEc2InstanceMetadataOptions.fromJson(Map<String, dynamic> json) {
    return AwsEc2InstanceMetadataOptions(
      httpEndpoint: json['HttpEndpoint'] as String?,
      httpProtocolIpv6: json['HttpProtocolIpv6'] as String?,
      httpPutResponseHopLimit: json['HttpPutResponseHopLimit'] as int?,
      httpTokens: json['HttpTokens'] as String?,
      instanceMetadataTags: json['InstanceMetadataTags'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final httpEndpoint = this.httpEndpoint;
    final httpProtocolIpv6 = this.httpProtocolIpv6;
    final httpPutResponseHopLimit = this.httpPutResponseHopLimit;
    final httpTokens = this.httpTokens;
    final instanceMetadataTags = this.instanceMetadataTags;
    return {
      if (httpEndpoint != null) 'HttpEndpoint': httpEndpoint,
      if (httpProtocolIpv6 != null) 'HttpProtocolIpv6': httpProtocolIpv6,
      if (httpPutResponseHopLimit != null)
        'HttpPutResponseHopLimit': httpPutResponseHopLimit,
      if (httpTokens != null) 'HttpTokens': httpTokens,
      if (instanceMetadataTags != null)
        'InstanceMetadataTags': instanceMetadataTags,
    };
  }
}

/// The type of monitoring that’s turned on for an Amazon EC2 instance.
class AwsEc2InstanceMonitoringDetails {
  /// Indicates whether detailed monitoring is turned on. Otherwise, basic
  /// monitoring is turned on.
  final String? state;

  AwsEc2InstanceMonitoringDetails({
    this.state,
  });

  factory AwsEc2InstanceMonitoringDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2InstanceMonitoringDetails(
      state: json['State'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final state = this.state;
    return {
      if (state != null) 'State': state,
    };
  }
}

/// Identifies a network interface for the Amazon EC2 instance.
class AwsEc2InstanceNetworkInterfacesDetails {
  /// The identifier of the network interface. The details are in a corresponding
  /// <code>AwsEc2NetworkInterfacesDetails</code> object.
  final String? networkInterfaceId;

  AwsEc2InstanceNetworkInterfacesDetails({
    this.networkInterfaceId,
  });

  factory AwsEc2InstanceNetworkInterfacesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2InstanceNetworkInterfacesDetails(
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final networkInterfaceId = this.networkInterfaceId;
    return {
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
    };
  }
}

/// Information about a block device mapping for an Amazon Elastic Compute Cloud
/// (Amazon EC2) launch template.
class AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails {
  /// The device name.
  final String? deviceName;

  /// Parameters used to automatically set up Amazon EBS volumes when the instance
  /// is launched.
  final AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails? ebs;

  /// Omits the device from the block device mapping when an empty string is
  /// specified.
  final String? noDevice;

  /// The virtual device name (ephemeralN). Instance store volumes are numbered
  /// starting from 0. An instance type with 2 available instance store volumes
  /// can specify mappings for <code>ephemeral0</code> and
  /// <code>ephemeral1</code>. The number of available instance store volumes
  /// depends on the instance type.
  final String? virtualName;

  AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails({
    this.deviceName,
    this.ebs,
    this.noDevice,
    this.virtualName,
  });

  factory AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails(
      deviceName: json['DeviceName'] as String?,
      ebs: json['Ebs'] != null
          ? AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails.fromJson(
              json['Ebs'] as Map<String, dynamic>)
          : null,
      noDevice: json['NoDevice'] as String?,
      virtualName: json['VirtualName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deviceName = this.deviceName;
    final ebs = this.ebs;
    final noDevice = this.noDevice;
    final virtualName = this.virtualName;
    return {
      if (deviceName != null) 'DeviceName': deviceName,
      if (ebs != null) 'Ebs': ebs,
      if (noDevice != null) 'NoDevice': noDevice,
      if (virtualName != null) 'VirtualName': virtualName,
    };
  }
}

/// Parameters for a block device for an Amazon Elastic Block Store (Amazon EBS)
/// volume in an Amazon EC2 launch template.
class AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails {
  /// Indicates whether the EBS volume is deleted on instance termination.
  final bool? deleteOnTermination;

  /// Indicates whether the EBS volume is encrypted. Encrypted volumes can only be
  /// attached to instances that support Amazon EBS encryption. If you're creating
  /// a volume from a snapshot, you can't specify an encryption value.
  final bool? encrypted;

  /// The number of I/O operations per second (IOPS).
  final int? iops;

  /// The Amazon Resource Name (ARN) of the symmetric Key Management Service (KMS)
  /// customer managed key used for encryption.
  final String? kmsKeyId;

  /// The ID of the EBS snapshot.
  final String? snapshotId;

  /// The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
  final int? throughput;

  /// The size of the volume, in GiBs. You must specify either a snapshot ID or a
  /// volume size.
  final int? volumeSize;

  /// The volume type.
  final String? volumeType;

  AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails({
    this.deleteOnTermination,
    this.encrypted,
    this.iops,
    this.kmsKeyId,
    this.snapshotId,
    this.throughput,
    this.volumeSize,
    this.volumeType,
  });

  factory AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataBlockDeviceMappingSetEbsDetails(
      deleteOnTermination: json['DeleteOnTermination'] as bool?,
      encrypted: json['Encrypted'] as bool?,
      iops: json['Iops'] as int?,
      kmsKeyId: json['KmsKeyId'] as String?,
      snapshotId: json['SnapshotId'] as String?,
      throughput: json['Throughput'] as int?,
      volumeSize: json['VolumeSize'] as int?,
      volumeType: json['VolumeType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deleteOnTermination = this.deleteOnTermination;
    final encrypted = this.encrypted;
    final iops = this.iops;
    final kmsKeyId = this.kmsKeyId;
    final snapshotId = this.snapshotId;
    final throughput = this.throughput;
    final volumeSize = this.volumeSize;
    final volumeType = this.volumeType;
    return {
      if (deleteOnTermination != null)
        'DeleteOnTermination': deleteOnTermination,
      if (encrypted != null) 'Encrypted': encrypted,
      if (iops != null) 'Iops': iops,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (snapshotId != null) 'SnapshotId': snapshotId,
      if (throughput != null) 'Throughput': throughput,
      if (volumeSize != null) 'VolumeSize': volumeSize,
      if (volumeType != null) 'VolumeType': volumeType,
    };
  }
}

/// Information about the target Capacity Reservation or Capacity Reservation
/// group in which to run an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails {
  /// The ID of the Capacity Reservation in which to run the instance.
  final String? capacityReservationId;

  /// The Amazon Resource Name (ARN) of the Capacity Reservation resource group in
  /// which to run the instance.
  final String? capacityReservationResourceGroupArn;

  AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails({
    this.capacityReservationId,
    this.capacityReservationResourceGroupArn,
  });

  factory AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails(
      capacityReservationId: json['CapacityReservationId'] as String?,
      capacityReservationResourceGroupArn:
          json['CapacityReservationResourceGroupArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final capacityReservationId = this.capacityReservationId;
    final capacityReservationResourceGroupArn =
        this.capacityReservationResourceGroupArn;
    return {
      if (capacityReservationId != null)
        'CapacityReservationId': capacityReservationId,
      if (capacityReservationResourceGroupArn != null)
        'CapacityReservationResourceGroupArn':
            capacityReservationResourceGroupArn,
    };
  }
}

/// Specifies the Capacity Reservation targeting option of an Amazon EC2
/// instance.
class AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails {
  /// Indicates the instance's Capacity Reservation preferences. If equal to
  /// <code>open</code>, the instance can run in any open Capacity Reservation
  /// that has matching attributes (instance type, platform, Availability Zone).
  /// If equal to <code>none</code>, the instance avoids running in a Capacity
  /// Reservation even if one is available. The instance runs in On-Demand
  /// capacity.
  final String? capacityReservationPreference;

  /// Specifies a target Capacity Reservation.
  final AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails?
      capacityReservationTarget;

  AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails({
    this.capacityReservationPreference,
    this.capacityReservationTarget,
  });

  factory AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails(
      capacityReservationPreference:
          json['CapacityReservationPreference'] as String?,
      capacityReservationTarget: json['CapacityReservationTarget'] != null
          ? AwsEc2LaunchTemplateDataCapacityReservationSpecificationCapacityReservationTargetDetails
              .fromJson(
                  json['CapacityReservationTarget'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final capacityReservationPreference = this.capacityReservationPreference;
    final capacityReservationTarget = this.capacityReservationTarget;
    return {
      if (capacityReservationPreference != null)
        'CapacityReservationPreference': capacityReservationPreference,
      if (capacityReservationTarget != null)
        'CapacityReservationTarget': capacityReservationTarget,
    };
  }
}

/// Specifies the CPU options for an Amazon EC2 instance. For more information,
/// see <a
/// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimize
/// CPU options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.
class AwsEc2LaunchTemplateDataCpuOptionsDetails {
  /// The number of CPU cores for the instance.
  final int? coreCount;

  /// The number of threads per CPU core. A value of <code>1</code> disables
  /// multithreading for the instance, The default value is <code>2</code>.
  final int? threadsPerCore;

  AwsEc2LaunchTemplateDataCpuOptionsDetails({
    this.coreCount,
    this.threadsPerCore,
  });

  factory AwsEc2LaunchTemplateDataCpuOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataCpuOptionsDetails(
      coreCount: json['CoreCount'] as int?,
      threadsPerCore: json['ThreadsPerCore'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final coreCount = this.coreCount;
    final threadsPerCore = this.threadsPerCore;
    return {
      if (coreCount != null) 'CoreCount': coreCount,
      if (threadsPerCore != null) 'ThreadsPerCore': threadsPerCore,
    };
  }
}

/// Specifies the credit option for CPU usage of a T2, T3, or T3a Amazon EC2
/// instance.
class AwsEc2LaunchTemplateDataCreditSpecificationDetails {
  /// The credit option for CPU usage of a T instance.
  final String? cpuCredits;

  AwsEc2LaunchTemplateDataCreditSpecificationDetails({
    this.cpuCredits,
  });

  factory AwsEc2LaunchTemplateDataCreditSpecificationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataCreditSpecificationDetails(
      cpuCredits: json['CpuCredits'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cpuCredits = this.cpuCredits;
    return {
      if (cpuCredits != null) 'CpuCredits': cpuCredits,
    };
  }
}

/// The information to include in an Amazon Elastic Compute Cloud (Amazon EC2)
/// launch template.
class AwsEc2LaunchTemplateDataDetails {
  /// Information about a block device mapping for an Amazon EC2 launch template.
  final List<AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails>?
      blockDeviceMappingSet;

  /// Specifies an instance's Capacity Reservation targeting option. You can
  /// specify only one option at a time.
  final AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails?
      capacityReservationSpecification;

  /// Specifies the CPU options for an instance. For more information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html">Optimize
  /// CPU options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.
  final AwsEc2LaunchTemplateDataCpuOptionsDetails? cpuOptions;

  /// Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
  final AwsEc2LaunchTemplateDataCreditSpecificationDetails? creditSpecification;

  /// Indicates whether to enable the instance for stop protection. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Stop_Start.html#Using_StopProtection">Enable
  /// stop protection</a> in the <i>Amazon EC2 User Guide</i>.
  final bool? disableApiStop;

  /// If you set this parameter to <code>true</code>, you can't terminate the
  /// instance using the Amazon EC2 console, CLI, or API. If set to
  /// <code>true</code>, you can.
  final bool? disableApiTermination;

  /// Indicates whether the instance is optimized for Amazon EBS I/O.
  final bool? ebsOptimized;

  /// Provides details about Elastic Graphics accelerators to associate with the
  /// instance.
  final List<AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails>?
      elasticGpuSpecificationSet;

  /// The Amazon Elastic Inference accelerator for the instance.
  final List<AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails>?
      elasticInferenceAcceleratorSet;

  /// Indicates whether the Amazon EC2 instance is enabled for Amazon Web Services
  /// Nitro Enclaves.
  final AwsEc2LaunchTemplateDataEnclaveOptionsDetails? enclaveOptions;

  /// Specifies whether your Amazon EC2 instance is configured for hibernation.
  final AwsEc2LaunchTemplateDataHibernationOptionsDetails? hibernationOptions;

  /// The name or Amazon Resource Name (ARN) of an IAM instance profile.
  final AwsEc2LaunchTemplateDataIamInstanceProfileDetails? iamInstanceProfile;

  /// The ID of the Amazon Machine Image (AMI).
  final String? imageId;

  /// Provides the options for specifying the instance initiated shutdown
  /// behavior.
  final String? instanceInitiatedShutdownBehavior;

  /// Specifies the market (purchasing) option for an instance.
  final AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails?
      instanceMarketOptions;

  /// The attributes for the instance types. When you specify instance attributes,
  /// Amazon EC2 will identify instance types with these attributes. If you
  /// specify <code>InstanceRequirements</code>, you can't specify
  /// <code>InstanceType</code>.
  final AwsEc2LaunchTemplateDataInstanceRequirementsDetails?
      instanceRequirements;

  /// The instance type. For more information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html">Instance
  /// types</a> in the <i>Amazon EC2 User Guide</i>. If you specify
  /// <code>InstanceType</code>, you can't specify
  /// <code>InstanceRequirements</code>.
  final String? instanceType;

  /// The ID of the kernel.
  final String? kernelId;

  /// The name of the key pair that allows users to connect to the instance.
  final String? keyName;

  /// Specifies a license configuration for an instance.
  final List<AwsEc2LaunchTemplateDataLicenseSetDetails>? licenseSet;

  /// The maintenance options of your instance.
  final AwsEc2LaunchTemplateDataMaintenanceOptionsDetails? maintenanceOptions;

  /// The metadata options for the instance. For more information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance
  /// metadata and user data</a> in the <i>Amazon EC2 User Guide</i>.
  final AwsEc2LaunchTemplateDataMetadataOptionsDetails? metadataOptions;

  /// The monitoring for the instance.
  final AwsEc2LaunchTemplateDataMonitoringDetails? monitoring;

  /// Specifies the parameters for a network interface that is attached to the
  /// instance.
  final List<AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails>?
      networkInterfaceSet;

  /// Specifies the placement of an instance.
  final AwsEc2LaunchTemplateDataPlacementDetails? placement;

  /// The options for the instance hostname.
  final AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails?
      privateDnsNameOptions;

  /// The ID of the RAM disk.
  final String? ramDiskId;

  /// One or more security group IDs.
  final List<String>? securityGroupIdSet;

  /// One or more security group names. For a nondefault VPC, you must use
  /// security group IDs instead. You cannot specify both a security group ID and
  /// security name in the same request.
  final List<String>? securityGroupSet;

  /// The user data to make available to the instance.
  final String? userData;

  AwsEc2LaunchTemplateDataDetails({
    this.blockDeviceMappingSet,
    this.capacityReservationSpecification,
    this.cpuOptions,
    this.creditSpecification,
    this.disableApiStop,
    this.disableApiTermination,
    this.ebsOptimized,
    this.elasticGpuSpecificationSet,
    this.elasticInferenceAcceleratorSet,
    this.enclaveOptions,
    this.hibernationOptions,
    this.iamInstanceProfile,
    this.imageId,
    this.instanceInitiatedShutdownBehavior,
    this.instanceMarketOptions,
    this.instanceRequirements,
    this.instanceType,
    this.kernelId,
    this.keyName,
    this.licenseSet,
    this.maintenanceOptions,
    this.metadataOptions,
    this.monitoring,
    this.networkInterfaceSet,
    this.placement,
    this.privateDnsNameOptions,
    this.ramDiskId,
    this.securityGroupIdSet,
    this.securityGroupSet,
    this.userData,
  });

  factory AwsEc2LaunchTemplateDataDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataDetails(
      blockDeviceMappingSet: (json['BlockDeviceMappingSet'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2LaunchTemplateDataBlockDeviceMappingSetDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      capacityReservationSpecification:
          json['CapacityReservationSpecification'] != null
              ? AwsEc2LaunchTemplateDataCapacityReservationSpecificationDetails
                  .fromJson(json['CapacityReservationSpecification']
                      as Map<String, dynamic>)
              : null,
      cpuOptions: json['CpuOptions'] != null
          ? AwsEc2LaunchTemplateDataCpuOptionsDetails.fromJson(
              json['CpuOptions'] as Map<String, dynamic>)
          : null,
      creditSpecification: json['CreditSpecification'] != null
          ? AwsEc2LaunchTemplateDataCreditSpecificationDetails.fromJson(
              json['CreditSpecification'] as Map<String, dynamic>)
          : null,
      disableApiStop: json['DisableApiStop'] as bool?,
      disableApiTermination: json['DisableApiTermination'] as bool?,
      ebsOptimized: json['EbsOptimized'] as bool?,
      elasticGpuSpecificationSet: (json['ElasticGpuSpecificationSet'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      elasticInferenceAcceleratorSet:
          (json['ElasticInferenceAcceleratorSet'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails
                      .fromJson(e as Map<String, dynamic>))
              .toList(),
      enclaveOptions: json['EnclaveOptions'] != null
          ? AwsEc2LaunchTemplateDataEnclaveOptionsDetails.fromJson(
              json['EnclaveOptions'] as Map<String, dynamic>)
          : null,
      hibernationOptions: json['HibernationOptions'] != null
          ? AwsEc2LaunchTemplateDataHibernationOptionsDetails.fromJson(
              json['HibernationOptions'] as Map<String, dynamic>)
          : null,
      iamInstanceProfile: json['IamInstanceProfile'] != null
          ? AwsEc2LaunchTemplateDataIamInstanceProfileDetails.fromJson(
              json['IamInstanceProfile'] as Map<String, dynamic>)
          : null,
      imageId: json['ImageId'] as String?,
      instanceInitiatedShutdownBehavior:
          json['InstanceInitiatedShutdownBehavior'] as String?,
      instanceMarketOptions: json['InstanceMarketOptions'] != null
          ? AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails.fromJson(
              json['InstanceMarketOptions'] as Map<String, dynamic>)
          : null,
      instanceRequirements: json['InstanceRequirements'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsDetails.fromJson(
              json['InstanceRequirements'] as Map<String, dynamic>)
          : null,
      instanceType: json['InstanceType'] as String?,
      kernelId: json['KernelId'] as String?,
      keyName: json['KeyName'] as String?,
      licenseSet: (json['LicenseSet'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2LaunchTemplateDataLicenseSetDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      maintenanceOptions: json['MaintenanceOptions'] != null
          ? AwsEc2LaunchTemplateDataMaintenanceOptionsDetails.fromJson(
              json['MaintenanceOptions'] as Map<String, dynamic>)
          : null,
      metadataOptions: json['MetadataOptions'] != null
          ? AwsEc2LaunchTemplateDataMetadataOptionsDetails.fromJson(
              json['MetadataOptions'] as Map<String, dynamic>)
          : null,
      monitoring: json['Monitoring'] != null
          ? AwsEc2LaunchTemplateDataMonitoringDetails.fromJson(
              json['Monitoring'] as Map<String, dynamic>)
          : null,
      networkInterfaceSet: (json['NetworkInterfaceSet'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      placement: json['Placement'] != null
          ? AwsEc2LaunchTemplateDataPlacementDetails.fromJson(
              json['Placement'] as Map<String, dynamic>)
          : null,
      privateDnsNameOptions: json['PrivateDnsNameOptions'] != null
          ? AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails.fromJson(
              json['PrivateDnsNameOptions'] as Map<String, dynamic>)
          : null,
      ramDiskId: json['RamDiskId'] as String?,
      securityGroupIdSet: (json['SecurityGroupIdSet'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      securityGroupSet: (json['SecurityGroupSet'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      userData: json['UserData'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final blockDeviceMappingSet = this.blockDeviceMappingSet;
    final capacityReservationSpecification =
        this.capacityReservationSpecification;
    final cpuOptions = this.cpuOptions;
    final creditSpecification = this.creditSpecification;
    final disableApiStop = this.disableApiStop;
    final disableApiTermination = this.disableApiTermination;
    final ebsOptimized = this.ebsOptimized;
    final elasticGpuSpecificationSet = this.elasticGpuSpecificationSet;
    final elasticInferenceAcceleratorSet = this.elasticInferenceAcceleratorSet;
    final enclaveOptions = this.enclaveOptions;
    final hibernationOptions = this.hibernationOptions;
    final iamInstanceProfile = this.iamInstanceProfile;
    final imageId = this.imageId;
    final instanceInitiatedShutdownBehavior =
        this.instanceInitiatedShutdownBehavior;
    final instanceMarketOptions = this.instanceMarketOptions;
    final instanceRequirements = this.instanceRequirements;
    final instanceType = this.instanceType;
    final kernelId = this.kernelId;
    final keyName = this.keyName;
    final licenseSet = this.licenseSet;
    final maintenanceOptions = this.maintenanceOptions;
    final metadataOptions = this.metadataOptions;
    final monitoring = this.monitoring;
    final networkInterfaceSet = this.networkInterfaceSet;
    final placement = this.placement;
    final privateDnsNameOptions = this.privateDnsNameOptions;
    final ramDiskId = this.ramDiskId;
    final securityGroupIdSet = this.securityGroupIdSet;
    final securityGroupSet = this.securityGroupSet;
    final userData = this.userData;
    return {
      if (blockDeviceMappingSet != null)
        'BlockDeviceMappingSet': blockDeviceMappingSet,
      if (capacityReservationSpecification != null)
        'CapacityReservationSpecification': capacityReservationSpecification,
      if (cpuOptions != null) 'CpuOptions': cpuOptions,
      if (creditSpecification != null)
        'CreditSpecification': creditSpecification,
      if (disableApiStop != null) 'DisableApiStop': disableApiStop,
      if (disableApiTermination != null)
        'DisableApiTermination': disableApiTermination,
      if (ebsOptimized != null) 'EbsOptimized': ebsOptimized,
      if (elasticGpuSpecificationSet != null)
        'ElasticGpuSpecificationSet': elasticGpuSpecificationSet,
      if (elasticInferenceAcceleratorSet != null)
        'ElasticInferenceAcceleratorSet': elasticInferenceAcceleratorSet,
      if (enclaveOptions != null) 'EnclaveOptions': enclaveOptions,
      if (hibernationOptions != null) 'HibernationOptions': hibernationOptions,
      if (iamInstanceProfile != null) 'IamInstanceProfile': iamInstanceProfile,
      if (imageId != null) 'ImageId': imageId,
      if (instanceInitiatedShutdownBehavior != null)
        'InstanceInitiatedShutdownBehavior': instanceInitiatedShutdownBehavior,
      if (instanceMarketOptions != null)
        'InstanceMarketOptions': instanceMarketOptions,
      if (instanceRequirements != null)
        'InstanceRequirements': instanceRequirements,
      if (instanceType != null) 'InstanceType': instanceType,
      if (kernelId != null) 'KernelId': kernelId,
      if (keyName != null) 'KeyName': keyName,
      if (licenseSet != null) 'LicenseSet': licenseSet,
      if (maintenanceOptions != null) 'MaintenanceOptions': maintenanceOptions,
      if (metadataOptions != null) 'MetadataOptions': metadataOptions,
      if (monitoring != null) 'Monitoring': monitoring,
      if (networkInterfaceSet != null)
        'NetworkInterfaceSet': networkInterfaceSet,
      if (placement != null) 'Placement': placement,
      if (privateDnsNameOptions != null)
        'PrivateDnsNameOptions': privateDnsNameOptions,
      if (ramDiskId != null) 'RamDiskId': ramDiskId,
      if (securityGroupIdSet != null) 'SecurityGroupIdSet': securityGroupIdSet,
      if (securityGroupSet != null) 'SecurityGroupSet': securityGroupSet,
      if (userData != null) 'UserData': userData,
    };
  }
}

/// Provides details about an Elastic Graphics specification for an Amazon EC2
/// launch template.
class AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails {
  /// The type of Elastic Graphics accelerator.
  final String? type;

  AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails({
    this.type,
  });

  factory AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataElasticGpuSpecificationSetDetails(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Provides details for an Amazon Elastic Inference accelerator.
class AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails {
  /// The number of Elastic Inference accelerators to attach to the instance.
  final int? count;

  /// The type of Elastic Inference accelerator.
  final String? type;

  AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails({
    this.count,
    this.type,
  });

  factory AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataElasticInferenceAcceleratorSetDetails(
      count: json['Count'] as int?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final count = this.count;
    final type = this.type;
    return {
      if (count != null) 'Count': count,
      if (type != null) 'Type': type,
    };
  }
}

/// Indicates whether the instance is enabled for Amazon Web Services Nitro
/// Enclaves.
class AwsEc2LaunchTemplateDataEnclaveOptionsDetails {
  /// If this parameter is set to <code>true</code>, the instance is enabled for
  /// Amazon Web Services Nitro Enclaves.
  final bool? enabled;

  AwsEc2LaunchTemplateDataEnclaveOptionsDetails({
    this.enabled,
  });

  factory AwsEc2LaunchTemplateDataEnclaveOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataEnclaveOptionsDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Specifies whether your Amazon EC2 instance is configured for hibernation.
class AwsEc2LaunchTemplateDataHibernationOptionsDetails {
  /// If you set this parameter to <code>true</code>, the instance is enabled for
  /// hibernation.
  final bool? configured;

  AwsEc2LaunchTemplateDataHibernationOptionsDetails({
    this.configured,
  });

  factory AwsEc2LaunchTemplateDataHibernationOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataHibernationOptionsDetails(
      configured: json['Configured'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final configured = this.configured;
    return {
      if (configured != null) 'Configured': configured,
    };
  }
}

/// Provides details for an Identity and Access Management (IAM) instance
/// profile, which is a container for an IAM role for your instance.
class AwsEc2LaunchTemplateDataIamInstanceProfileDetails {
  /// The Amazon Resource Name (ARN) of the instance profile.
  final String? arn;

  /// The name of the instance profile.
  final String? name;

  AwsEc2LaunchTemplateDataIamInstanceProfileDetails({
    this.arn,
    this.name,
  });

  factory AwsEc2LaunchTemplateDataIamInstanceProfileDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataIamInstanceProfileDetails(
      arn: json['Arn'] as String?,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final name = this.name;
    return {
      if (arn != null) 'Arn': arn,
      if (name != null) 'Name': name,
    };
  }
}

/// Provides details about the market (purchasing) option for an Amazon EC2
/// instance.
class AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails {
  /// The market type.
  final String? marketType;

  /// The options for Spot Instances.
  final AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails?
      spotOptions;

  AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails({
    this.marketType,
    this.spotOptions,
  });

  factory AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceMarketOptionsDetails(
      marketType: json['MarketType'] as String?,
      spotOptions: json['SpotOptions'] != null
          ? AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails
              .fromJson(json['SpotOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final marketType = this.marketType;
    final spotOptions = this.spotOptions;
    return {
      if (marketType != null) 'MarketType': marketType,
      if (spotOptions != null) 'SpotOptions': spotOptions,
    };
  }
}

/// Provides details about the market (purchasing) options for Spot Instances.
class AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails {
  /// Deprecated.
  final int? blockDurationMinutes;

  /// The behavior when a Spot Instance is interrupted.
  final String? instanceInterruptionBehavior;

  /// The maximum hourly price you're willing to pay for the Spot Instances.
  final String? maxPrice;

  /// The Spot Instance request type.
  final String? spotInstanceType;

  /// The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ), for
  /// persistent requests.
  final String? validUntil;

  AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails({
    this.blockDurationMinutes,
    this.instanceInterruptionBehavior,
    this.maxPrice,
    this.spotInstanceType,
    this.validUntil,
  });

  factory AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceMarketOptionsSpotOptionsDetails(
      blockDurationMinutes: json['BlockDurationMinutes'] as int?,
      instanceInterruptionBehavior:
          json['InstanceInterruptionBehavior'] as String?,
      maxPrice: json['MaxPrice'] as String?,
      spotInstanceType: json['SpotInstanceType'] as String?,
      validUntil: json['ValidUntil'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final blockDurationMinutes = this.blockDurationMinutes;
    final instanceInterruptionBehavior = this.instanceInterruptionBehavior;
    final maxPrice = this.maxPrice;
    final spotInstanceType = this.spotInstanceType;
    final validUntil = this.validUntil;
    return {
      if (blockDurationMinutes != null)
        'BlockDurationMinutes': blockDurationMinutes,
      if (instanceInterruptionBehavior != null)
        'InstanceInterruptionBehavior': instanceInterruptionBehavior,
      if (maxPrice != null) 'MaxPrice': maxPrice,
      if (spotInstanceType != null) 'SpotInstanceType': spotInstanceType,
      if (validUntil != null) 'ValidUntil': validUntil,
    };
  }
}

/// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web
/// Services Inferentia chips) on an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails {
  /// The maximum number of accelerators. If this parameter isn't specified,
  /// there's no maximum limit. To exclude accelerator-enabled instance types, set
  /// <code>Max</code> to <code>0</code>.
  final int? max;

  /// The minimum number of accelerators. If this parameter isn't specified,
  /// there's no minimum limit.
  final int? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails(
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The minimum and maximum amount of memory, in MiB, for the accelerators on an
/// Amazon EC2 instance.
class AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails {
  /// The maximum amount of memory, in MiB. If this parameter isn't specified,
  /// there's no maximum limit.
  final int? max;

  /// The minimum amount of memory, in MiB. If <code>0</code> is specified,
  /// there's no maximum limit.
  final int? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails(
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The minimum and maximum baseline bandwidth to Amazon Elastic Block Store
/// (Amazon EBS), in Mbps. For more information, see <a
/// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html">Amazon
/// EBS–optimized instances </a> in the <i>Amazon EC2 User Guide</i>.
class AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails {
  /// The maximum baseline bandwidth, in Mbps. If this parameter is omitted,
  /// there's no maximum limit.
  final int? max;

  /// The minimum baseline bandwidth, in Mbps. If this parameter is omitted,
  /// there's no minimum limit.
  final int? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails(
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The attributes for the Amazon EC2 instance types.
class AwsEc2LaunchTemplateDataInstanceRequirementsDetails {
  /// The minimum and maximum number of accelerators (GPUs, FPGAs, or Amazon Web
  /// Services Inferentia chips) on an instance.
  final AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails?
      acceleratorCount;

  /// Indicates whether instance types must have accelerators by specific
  /// manufacturers.
  final List<String>? acceleratorManufacturers;

  /// The accelerators that must be on the instance type.
  final List<String>? acceleratorNames;

  /// The minimum and maximum amount of total accelerator memory, in MiB.
  final AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails?
      acceleratorTotalMemoryMiB;

  /// The accelerator types that must be on the instance type.
  final List<String>? acceleratorTypes;

  /// Indicates whether bare metal instance types must be included, excluded, or
  /// required.
  final String? bareMetal;

  /// The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html">Amazon
  /// EBS optimized instances</a> in the <i>Amazon EC2 User Guide</i>.
  final AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails?
      baselineEbsBandwidthMbps;

  /// Indicates whether burstable performance T instance types are included,
  /// excluded, or required. For more information, <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html">Burstable
  /// performance instances</a> in the <i>Amazon EC2 User Guide</i>.
  final String? burstablePerformance;

  /// The CPU manufacturers to include.
  final List<String>? cpuManufacturers;

  /// The instance types to exclude.
  final List<String>? excludedInstanceTypes;

  /// Indicates whether current or previous generation instance types are
  /// included.
  final List<String>? instanceGenerations;

  /// Indicates whether instance types with instance store volumes are included,
  /// excluded, or required. For more information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html">Amazon
  /// EC2 instance store</a> in the <i>Amazon EC2 User Guide</i>.
  final String? localStorage;

  /// The type of local storage that is required.
  final List<String>? localStorageTypes;

  /// The minimum and maximum amount of memory per vCPU, in GiB.
  final AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails?
      memoryGiBPerVCpu;

  /// The minimum and maximum amount of memory, in MiB.
  final AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails? memoryMiB;

  /// The minimum and maximum number of network interfaces.
  final AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails?
      networkInterfaceCount;

  /// The price protection threshold for On-Demand Instances. This is the maximum
  /// you'll pay for an On-Demand Instance, expressed as a percentage above the
  /// least expensive current generation M, C, or R instance type with your
  /// specified attributes. When Amazon EC2 selects instance types with your
  /// attributes, it excludes instance types priced above your threshold.
  ///
  /// The parameter accepts an integer, which Amazon EC2 interprets as a
  /// percentage.
  ///
  /// A high value, such as <code>999999</code>, turns off price protection.
  final int? onDemandMaxPricePercentageOverLowestPrice;

  /// Indicates whether instance types must support hibernation for On-Demand
  /// Instances.
  final bool? requireHibernateSupport;

  /// The price protection threshold for Spot Instances. This is the maximum
  /// you'll pay for a Spot Instance, expressed as a percentage above the least
  /// expensive current generation M, C, or R instance type with your specified
  /// attributes. When Amazon EC2 selects instance types with your attributes, it
  /// excludes instance types priced above your threshold.
  ///
  /// The parameter accepts an integer, which Amazon EC2 interprets as a
  /// percentage.
  ///
  /// A high value, such as <code>999999</code>, turns off price protection.
  final int? spotMaxPricePercentageOverLowestPrice;

  /// The minimum and maximum amount of total local storage, in GB.
  final AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails?
      totalLocalStorageGB;

  /// The minimum and maximum number of vCPUs.
  final AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails? vCpuCount;

  AwsEc2LaunchTemplateDataInstanceRequirementsDetails({
    this.acceleratorCount,
    this.acceleratorManufacturers,
    this.acceleratorNames,
    this.acceleratorTotalMemoryMiB,
    this.acceleratorTypes,
    this.bareMetal,
    this.baselineEbsBandwidthMbps,
    this.burstablePerformance,
    this.cpuManufacturers,
    this.excludedInstanceTypes,
    this.instanceGenerations,
    this.localStorage,
    this.localStorageTypes,
    this.memoryGiBPerVCpu,
    this.memoryMiB,
    this.networkInterfaceCount,
    this.onDemandMaxPricePercentageOverLowestPrice,
    this.requireHibernateSupport,
    this.spotMaxPricePercentageOverLowestPrice,
    this.totalLocalStorageGB,
    this.vCpuCount,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsDetails(
      acceleratorCount: json['AcceleratorCount'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorCountDetails
              .fromJson(json['AcceleratorCount'] as Map<String, dynamic>)
          : null,
      acceleratorManufacturers: (json['AcceleratorManufacturers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      acceleratorNames: (json['AcceleratorNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      acceleratorTotalMemoryMiB: json['AcceleratorTotalMemoryMiB'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsAcceleratorTotalMemoryMiBDetails
              .fromJson(
                  json['AcceleratorTotalMemoryMiB'] as Map<String, dynamic>)
          : null,
      acceleratorTypes: (json['AcceleratorTypes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      bareMetal: json['BareMetal'] as String?,
      baselineEbsBandwidthMbps: json['BaselineEbsBandwidthMbps'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsBaselineEbsBandwidthMbpsDetails
              .fromJson(
                  json['BaselineEbsBandwidthMbps'] as Map<String, dynamic>)
          : null,
      burstablePerformance: json['BurstablePerformance'] as String?,
      cpuManufacturers: (json['CpuManufacturers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      excludedInstanceTypes: (json['ExcludedInstanceTypes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      instanceGenerations: (json['InstanceGenerations'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      localStorage: json['LocalStorage'] as String?,
      localStorageTypes: (json['LocalStorageTypes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      memoryGiBPerVCpu: json['MemoryGiBPerVCpu'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails
              .fromJson(json['MemoryGiBPerVCpu'] as Map<String, dynamic>)
          : null,
      memoryMiB: json['MemoryMiB'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails
              .fromJson(json['MemoryMiB'] as Map<String, dynamic>)
          : null,
      networkInterfaceCount: json['NetworkInterfaceCount'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails
              .fromJson(json['NetworkInterfaceCount'] as Map<String, dynamic>)
          : null,
      onDemandMaxPricePercentageOverLowestPrice:
          json['OnDemandMaxPricePercentageOverLowestPrice'] as int?,
      requireHibernateSupport: json['RequireHibernateSupport'] as bool?,
      spotMaxPricePercentageOverLowestPrice:
          json['SpotMaxPricePercentageOverLowestPrice'] as int?,
      totalLocalStorageGB: json['TotalLocalStorageGB'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails
              .fromJson(json['TotalLocalStorageGB'] as Map<String, dynamic>)
          : null,
      vCpuCount: json['VCpuCount'] != null
          ? AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails
              .fromJson(json['VCpuCount'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final acceleratorCount = this.acceleratorCount;
    final acceleratorManufacturers = this.acceleratorManufacturers;
    final acceleratorNames = this.acceleratorNames;
    final acceleratorTotalMemoryMiB = this.acceleratorTotalMemoryMiB;
    final acceleratorTypes = this.acceleratorTypes;
    final bareMetal = this.bareMetal;
    final baselineEbsBandwidthMbps = this.baselineEbsBandwidthMbps;
    final burstablePerformance = this.burstablePerformance;
    final cpuManufacturers = this.cpuManufacturers;
    final excludedInstanceTypes = this.excludedInstanceTypes;
    final instanceGenerations = this.instanceGenerations;
    final localStorage = this.localStorage;
    final localStorageTypes = this.localStorageTypes;
    final memoryGiBPerVCpu = this.memoryGiBPerVCpu;
    final memoryMiB = this.memoryMiB;
    final networkInterfaceCount = this.networkInterfaceCount;
    final onDemandMaxPricePercentageOverLowestPrice =
        this.onDemandMaxPricePercentageOverLowestPrice;
    final requireHibernateSupport = this.requireHibernateSupport;
    final spotMaxPricePercentageOverLowestPrice =
        this.spotMaxPricePercentageOverLowestPrice;
    final totalLocalStorageGB = this.totalLocalStorageGB;
    final vCpuCount = this.vCpuCount;
    return {
      if (acceleratorCount != null) 'AcceleratorCount': acceleratorCount,
      if (acceleratorManufacturers != null)
        'AcceleratorManufacturers': acceleratorManufacturers,
      if (acceleratorNames != null) 'AcceleratorNames': acceleratorNames,
      if (acceleratorTotalMemoryMiB != null)
        'AcceleratorTotalMemoryMiB': acceleratorTotalMemoryMiB,
      if (acceleratorTypes != null) 'AcceleratorTypes': acceleratorTypes,
      if (bareMetal != null) 'BareMetal': bareMetal,
      if (baselineEbsBandwidthMbps != null)
        'BaselineEbsBandwidthMbps': baselineEbsBandwidthMbps,
      if (burstablePerformance != null)
        'BurstablePerformance': burstablePerformance,
      if (cpuManufacturers != null) 'CpuManufacturers': cpuManufacturers,
      if (excludedInstanceTypes != null)
        'ExcludedInstanceTypes': excludedInstanceTypes,
      if (instanceGenerations != null)
        'InstanceGenerations': instanceGenerations,
      if (localStorage != null) 'LocalStorage': localStorage,
      if (localStorageTypes != null) 'LocalStorageTypes': localStorageTypes,
      if (memoryGiBPerVCpu != null) 'MemoryGiBPerVCpu': memoryGiBPerVCpu,
      if (memoryMiB != null) 'MemoryMiB': memoryMiB,
      if (networkInterfaceCount != null)
        'NetworkInterfaceCount': networkInterfaceCount,
      if (onDemandMaxPricePercentageOverLowestPrice != null)
        'OnDemandMaxPricePercentageOverLowestPrice':
            onDemandMaxPricePercentageOverLowestPrice,
      if (requireHibernateSupport != null)
        'RequireHibernateSupport': requireHibernateSupport,
      if (spotMaxPricePercentageOverLowestPrice != null)
        'SpotMaxPricePercentageOverLowestPrice':
            spotMaxPricePercentageOverLowestPrice,
      if (totalLocalStorageGB != null)
        'TotalLocalStorageGB': totalLocalStorageGB,
      if (vCpuCount != null) 'VCpuCount': vCpuCount,
    };
  }
}

/// The minimum and maximum amount of memory per vCPU, in GiB.
class AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails {
  /// The maximum amount of memory per vCPU, in GiB. If this parameter is omitted,
  /// there's no maximum limit.
  final double? max;

  /// The minimum amount of memory per vCPU, in GiB. If this parameter is omitted,
  /// there's no maximum limit.
  final double? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsMemoryGiBPerVCpuDetails(
      max: json['Max'] as double?,
      min: json['Min'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The minimum and maximum amount of memory, in MiB, for an Amazon EC2
/// instance.
class AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails {
  /// The maximum amount of memory, in MiB.
  final int? max;

  /// The minimum amount of memory, in MiB.
  final int? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsMemoryMiBDetails(
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The minimum and maximum number of network interfaces to be attached to an
/// Amazon EC2 instance.
class AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails {
  /// The maximum number of network interfaces.
  final int? max;

  /// The minimum number of network interfaces.
  final int? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsNetworkInterfaceCountDetails(
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The minimum and maximum amount of total local storage, in GB, that an Amazon
/// EC2 instance uses.
class AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails {
  /// The maximum amount of total local storage, in GB.
  final double? max;

  /// The minimum amount of total local storage, in GB.
  final double? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsTotalLocalStorageGBDetails(
      max: json['Max'] as double?,
      min: json['Min'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The minimum and maximum number of vCPUs for an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails {
  /// The maximum number of vCPUs.
  final int? max;

  /// The minimum number of vCPUs.
  final int? min;

  AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails({
    this.max,
    this.min,
  });

  factory AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataInstanceRequirementsVCpuCountDetails(
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// Provides details about the license configuration for an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataLicenseSetDetails {
  /// The Amazon Resource Name (ARN) of the license configuration.
  final String? licenseConfigurationArn;

  AwsEc2LaunchTemplateDataLicenseSetDetails({
    this.licenseConfigurationArn,
  });

  factory AwsEc2LaunchTemplateDataLicenseSetDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataLicenseSetDetails(
      licenseConfigurationArn: json['LicenseConfigurationArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final licenseConfigurationArn = this.licenseConfigurationArn;
    return {
      if (licenseConfigurationArn != null)
        'LicenseConfigurationArn': licenseConfigurationArn,
    };
  }
}

/// The maintenance options of an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataMaintenanceOptionsDetails {
  /// Disables the automatic recovery behavior of your instance or sets it to
  /// default.
  final String? autoRecovery;

  AwsEc2LaunchTemplateDataMaintenanceOptionsDetails({
    this.autoRecovery,
  });

  factory AwsEc2LaunchTemplateDataMaintenanceOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataMaintenanceOptionsDetails(
      autoRecovery: json['AutoRecovery'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final autoRecovery = this.autoRecovery;
    return {
      if (autoRecovery != null) 'AutoRecovery': autoRecovery,
    };
  }
}

/// Specifies the metadata options for an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataMetadataOptionsDetails {
  /// Enables or disables the HTTP metadata endpoint on your instances. If the
  /// parameter is not specified, the default state is enabled, and you won't be
  /// able to access your instance metadata.
  final String? httpEndpoint;

  /// Enables or disables the IPv6 endpoint for the instance metadata service.
  final String? httpProtocolIpv6;

  /// The desired HTTP PUT response hop limit for instance metadata requests. The
  /// larger the number, the further instance metadata requests can travel.
  final int? httpPutResponseHopLimit;

  /// The state of token usage for your instance metadata requests.
  final String? httpTokens;

  /// When set to <code>enabled</code>, this parameter allows access to instance
  /// tags from the instance metadata. When set to <code>disabled</code>, it turns
  /// off access to instance tags from the instance metadata. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS">Work
  /// with instance tags in instance metadata</a> in the <i>Amazon EC2 User
  /// Guide</i>.
  final String? instanceMetadataTags;

  AwsEc2LaunchTemplateDataMetadataOptionsDetails({
    this.httpEndpoint,
    this.httpProtocolIpv6,
    this.httpPutResponseHopLimit,
    this.httpTokens,
    this.instanceMetadataTags,
  });

  factory AwsEc2LaunchTemplateDataMetadataOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataMetadataOptionsDetails(
      httpEndpoint: json['HttpEndpoint'] as String?,
      httpProtocolIpv6: json['HttpProtocolIpv6'] as String?,
      httpPutResponseHopLimit: json['HttpPutResponseHopLimit'] as int?,
      httpTokens: json['HttpTokens'] as String?,
      instanceMetadataTags: json['InstanceMetadataTags'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final httpEndpoint = this.httpEndpoint;
    final httpProtocolIpv6 = this.httpProtocolIpv6;
    final httpPutResponseHopLimit = this.httpPutResponseHopLimit;
    final httpTokens = this.httpTokens;
    final instanceMetadataTags = this.instanceMetadataTags;
    return {
      if (httpEndpoint != null) 'HttpEndpoint': httpEndpoint,
      if (httpProtocolIpv6 != null) 'HttpProtocolIpv6': httpProtocolIpv6,
      if (httpPutResponseHopLimit != null)
        'HttpPutResponseHopLimit': httpPutResponseHopLimit,
      if (httpTokens != null) 'HttpTokens': httpTokens,
      if (instanceMetadataTags != null)
        'InstanceMetadataTags': instanceMetadataTags,
    };
  }
}

/// The monitoring for an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataMonitoringDetails {
  /// Enables detailed monitoring when <code>true</code> is specified. Otherwise,
  /// basic monitoring is enabled. For more information about detailed monitoring,
  /// see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html">Enable
  /// or turn off detailed monitoring for your instances</a> in the <i>Amazon EC2
  /// User Guide</i>.
  final bool? enabled;

  AwsEc2LaunchTemplateDataMonitoringDetails({
    this.enabled,
  });

  factory AwsEc2LaunchTemplateDataMonitoringDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataMonitoringDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// One or more network interfaces to attach to an Amazon EC2 instance. If you
/// specify a network interface, you must specify security groups and subnets as
/// part of the network interface.
class AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails {
  /// Indicates whether to associate a Carrier IP address with eth0 for a new
  /// network interface. You use this option when you launch an instance in a
  /// Wavelength Zone and want to associate a Carrier IP address with the network
  /// interface. For more information, see <a
  /// href="https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip">Carrier
  /// IP address</a> in the <i>Wavelength Developer Guide</i>.
  final bool? associateCarrierIpAddress;

  /// Associates a public IPv4 address with eth0 for a new network interface.
  final bool? associatePublicIpAddress;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool? deleteOnTermination;

  /// A description for the network interface.
  final String? description;

  /// The device index for the network interface attachment.
  final int? deviceIndex;

  /// The IDs of one or more security groups.
  final List<String>? groups;

  /// The type of network interface.
  final String? interfaceType;

  /// The number of IPv4 prefixes to be automatically assigned to the network
  /// interface. You cannot use this option if you use the
  /// <code>Ipv4Prefixes</code> option.
  final int? ipv4PrefixCount;

  /// One or more IPv4 prefixes to be assigned to the network interface. You
  /// cannot use this option if you use the <code>Ipv4PrefixCount</code> option.
  final List<AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails>?
      ipv4Prefixes;

  /// The number of IPv6 addresses to assign to a network interface. Amazon EC2
  /// automatically selects the IPv6 addresses from the subnet range. You can't
  /// use this option if you use <code>Ipv6Addresses</code>.
  final int? ipv6AddressCount;

  /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your
  /// subnet. You can't use this option if you use <code>Ipv6AddressCount</code>.
  final List<AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails>?
      ipv6Addresses;

  /// The number of IPv6 prefixes to be automatically assigned to the network
  /// interface. You cannot use this option if you use the <code>Ipv6Prefix</code>
  /// option.
  final int? ipv6PrefixCount;

  /// One or more IPv6 prefixes to be assigned to the network interface. You
  /// cannot use this option if you use the <code>Ipv6PrefixCount</code> option.
  final List<AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails>?
      ipv6Prefixes;

  /// The index of the network card. Some instance types support multiple network
  /// cards. The primary network interface must be assigned to network card index
  /// <code>0</code>. The default is network card index <code>0</code>.
  final int? networkCardIndex;

  /// The ID of the network interface.
  final String? networkInterfaceId;

  /// The primary private IPv4 address of the network interface.
  final String? privateIpAddress;

  /// One or more private IPv4 addresses.
  final List<
          AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails>?
      privateIpAddresses;

  /// The number of secondary private IPv4 addresses to assign to a network
  /// interface.
  final int? secondaryPrivateIpAddressCount;

  /// The ID of the subnet for the network interface.
  final String? subnetId;

  AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails({
    this.associateCarrierIpAddress,
    this.associatePublicIpAddress,
    this.deleteOnTermination,
    this.description,
    this.deviceIndex,
    this.groups,
    this.interfaceType,
    this.ipv4PrefixCount,
    this.ipv4Prefixes,
    this.ipv6AddressCount,
    this.ipv6Addresses,
    this.ipv6PrefixCount,
    this.ipv6Prefixes,
    this.networkCardIndex,
    this.networkInterfaceId,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.secondaryPrivateIpAddressCount,
    this.subnetId,
  });

  factory AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataNetworkInterfaceSetDetails(
      associateCarrierIpAddress: json['AssociateCarrierIpAddress'] as bool?,
      associatePublicIpAddress: json['AssociatePublicIpAddress'] as bool?,
      deleteOnTermination: json['DeleteOnTermination'] as bool?,
      description: json['Description'] as String?,
      deviceIndex: json['DeviceIndex'] as int?,
      groups: (json['Groups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      interfaceType: json['InterfaceType'] as String?,
      ipv4PrefixCount: json['Ipv4PrefixCount'] as int?,
      ipv4Prefixes: (json['Ipv4Prefixes'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      ipv6AddressCount: json['Ipv6AddressCount'] as int?,
      ipv6Addresses: (json['Ipv6Addresses'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      ipv6PrefixCount: json['Ipv6PrefixCount'] as int?,
      ipv6Prefixes: (json['Ipv6Prefixes'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      networkCardIndex: json['NetworkCardIndex'] as int?,
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
      privateIpAddress: json['PrivateIpAddress'] as String?,
      privateIpAddresses: (json['PrivateIpAddresses'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      secondaryPrivateIpAddressCount:
          json['SecondaryPrivateIpAddressCount'] as int?,
      subnetId: json['SubnetId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associateCarrierIpAddress = this.associateCarrierIpAddress;
    final associatePublicIpAddress = this.associatePublicIpAddress;
    final deleteOnTermination = this.deleteOnTermination;
    final description = this.description;
    final deviceIndex = this.deviceIndex;
    final groups = this.groups;
    final interfaceType = this.interfaceType;
    final ipv4PrefixCount = this.ipv4PrefixCount;
    final ipv4Prefixes = this.ipv4Prefixes;
    final ipv6AddressCount = this.ipv6AddressCount;
    final ipv6Addresses = this.ipv6Addresses;
    final ipv6PrefixCount = this.ipv6PrefixCount;
    final ipv6Prefixes = this.ipv6Prefixes;
    final networkCardIndex = this.networkCardIndex;
    final networkInterfaceId = this.networkInterfaceId;
    final privateIpAddress = this.privateIpAddress;
    final privateIpAddresses = this.privateIpAddresses;
    final secondaryPrivateIpAddressCount = this.secondaryPrivateIpAddressCount;
    final subnetId = this.subnetId;
    return {
      if (associateCarrierIpAddress != null)
        'AssociateCarrierIpAddress': associateCarrierIpAddress,
      if (associatePublicIpAddress != null)
        'AssociatePublicIpAddress': associatePublicIpAddress,
      if (deleteOnTermination != null)
        'DeleteOnTermination': deleteOnTermination,
      if (description != null) 'Description': description,
      if (deviceIndex != null) 'DeviceIndex': deviceIndex,
      if (groups != null) 'Groups': groups,
      if (interfaceType != null) 'InterfaceType': interfaceType,
      if (ipv4PrefixCount != null) 'Ipv4PrefixCount': ipv4PrefixCount,
      if (ipv4Prefixes != null) 'Ipv4Prefixes': ipv4Prefixes,
      if (ipv6AddressCount != null) 'Ipv6AddressCount': ipv6AddressCount,
      if (ipv6Addresses != null) 'Ipv6Addresses': ipv6Addresses,
      if (ipv6PrefixCount != null) 'Ipv6PrefixCount': ipv6PrefixCount,
      if (ipv6Prefixes != null) 'Ipv6Prefixes': ipv6Prefixes,
      if (networkCardIndex != null) 'NetworkCardIndex': networkCardIndex,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
      if (privateIpAddresses != null) 'PrivateIpAddresses': privateIpAddresses,
      if (secondaryPrivateIpAddressCount != null)
        'SecondaryPrivateIpAddressCount': secondaryPrivateIpAddressCount,
      if (subnetId != null) 'SubnetId': subnetId,
    };
  }
}

/// Provides details on one or more IPv4 prefixes for a network interface.
class AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails {
  /// The IPv4 prefix. For more information, see <a
  /// href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html">Assigning
  /// prefixes to Amazon EC2 network interfaces</a> in the <i>Amazon Elastic
  /// Compute Cloud User Guide</i>.
  final String? ipv4Prefix;

  AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails({
    this.ipv4Prefix,
  });

  factory AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv4PrefixesDetails(
      ipv4Prefix: json['Ipv4Prefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipv4Prefix = this.ipv4Prefix;
    return {
      if (ipv4Prefix != null) 'Ipv4Prefix': ipv4Prefix,
    };
  }
}

/// Specifies an IPv6 address in an Amazon EC2 launch template.
class AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails {
  /// One or more specific IPv6 addresses from the IPv6 CIDR block range of your
  /// subnet.
  final String? ipv6Address;

  AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails({
    this.ipv6Address,
  });

  factory AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6AddressesDetails(
      ipv6Address: json['Ipv6Address'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipv6Address = this.ipv6Address;
    return {
      if (ipv6Address != null) 'Ipv6Address': ipv6Address,
    };
  }
}

/// Provides details on one or more IPv6 prefixes to be assigned to the network
/// interface.
class AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails {
  /// The IPv6 prefix.
  final String? ipv6Prefix;

  AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails({
    this.ipv6Prefix,
  });

  factory AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataNetworkInterfaceSetIpv6PrefixesDetails(
      ipv6Prefix: json['Ipv6Prefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipv6Prefix = this.ipv6Prefix;
    return {
      if (ipv6Prefix != null) 'Ipv6Prefix': ipv6Prefix,
    };
  }
}

/// One or more private IPv4 addresses.
class AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails {
  /// Indicates whether the private IPv4 address is the primary private IPv4
  /// address. Only one IPv4 address can be designated as primary.
  final bool? primary;

  /// The private IPv4 address.
  final String? privateIpAddress;

  AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails({
    this.primary,
    this.privateIpAddress,
  });

  factory AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataNetworkInterfaceSetPrivateIpAddressesDetails(
      primary: json['Primary'] as bool?,
      privateIpAddress: json['PrivateIpAddress'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final primary = this.primary;
    final privateIpAddress = this.privateIpAddress;
    return {
      if (primary != null) 'Primary': primary,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
    };
  }
}

/// Provides details about the placement of an Amazon EC2 instance.
class AwsEc2LaunchTemplateDataPlacementDetails {
  /// The affinity setting for an instance on an EC2 Dedicated Host.
  final String? affinity;

  /// The Availability Zone for the instance.
  final String? availabilityZone;

  /// The name of the placement group for the instance.
  final String? groupName;

  /// The ID of the Dedicated Host for the instance.
  final String? hostId;

  /// The Amazon Resource Name (ARN) of the host resource group in which to launch
  /// the instances.
  final String? hostResourceGroupArn;

  /// The number of the partition the instance should launch in.
  final int? partitionNumber;

  /// Reserved for future use.
  final String? spreadDomain;

  /// The tenancy of the instance (if the instance is running in a VPC). An
  /// instance with a tenancy of dedicated runs on single-tenant hardware.
  final String? tenancy;

  AwsEc2LaunchTemplateDataPlacementDetails({
    this.affinity,
    this.availabilityZone,
    this.groupName,
    this.hostId,
    this.hostResourceGroupArn,
    this.partitionNumber,
    this.spreadDomain,
    this.tenancy,
  });

  factory AwsEc2LaunchTemplateDataPlacementDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataPlacementDetails(
      affinity: json['Affinity'] as String?,
      availabilityZone: json['AvailabilityZone'] as String?,
      groupName: json['GroupName'] as String?,
      hostId: json['HostId'] as String?,
      hostResourceGroupArn: json['HostResourceGroupArn'] as String?,
      partitionNumber: json['PartitionNumber'] as int?,
      spreadDomain: json['SpreadDomain'] as String?,
      tenancy: json['Tenancy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final affinity = this.affinity;
    final availabilityZone = this.availabilityZone;
    final groupName = this.groupName;
    final hostId = this.hostId;
    final hostResourceGroupArn = this.hostResourceGroupArn;
    final partitionNumber = this.partitionNumber;
    final spreadDomain = this.spreadDomain;
    final tenancy = this.tenancy;
    return {
      if (affinity != null) 'Affinity': affinity,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (groupName != null) 'GroupName': groupName,
      if (hostId != null) 'HostId': hostId,
      if (hostResourceGroupArn != null)
        'HostResourceGroupArn': hostResourceGroupArn,
      if (partitionNumber != null) 'PartitionNumber': partitionNumber,
      if (spreadDomain != null) 'SpreadDomain': spreadDomain,
      if (tenancy != null) 'Tenancy': tenancy,
    };
  }
}

/// Describes the options for Amazon EC2 instance hostnames.
class AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails {
  /// Indicates whether to respond to DNS queries for instance hostnames with DNS
  /// AAAA records.
  final bool? enableResourceNameDnsAAAARecord;

  /// Indicates whether to respond to DNS queries for instance hostnames with DNS
  /// A records.
  final bool? enableResourceNameDnsARecord;

  /// The type of hostname for EC2 instances.
  final String? hostnameType;

  AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails({
    this.enableResourceNameDnsAAAARecord,
    this.enableResourceNameDnsARecord,
    this.hostnameType,
  });

  factory AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDataPrivateDnsNameOptionsDetails(
      enableResourceNameDnsAAAARecord:
          json['EnableResourceNameDnsAAAARecord'] as bool?,
      enableResourceNameDnsARecord:
          json['EnableResourceNameDnsARecord'] as bool?,
      hostnameType: json['HostnameType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final enableResourceNameDnsAAAARecord =
        this.enableResourceNameDnsAAAARecord;
    final enableResourceNameDnsARecord = this.enableResourceNameDnsARecord;
    final hostnameType = this.hostnameType;
    return {
      if (enableResourceNameDnsAAAARecord != null)
        'EnableResourceNameDnsAAAARecord': enableResourceNameDnsAAAARecord,
      if (enableResourceNameDnsARecord != null)
        'EnableResourceNameDnsARecord': enableResourceNameDnsARecord,
      if (hostnameType != null) 'HostnameType': hostnameType,
    };
  }
}

/// Specifies the properties for creating an Amazon Elastic Compute Cloud
/// (Amazon EC2) launch template.
class AwsEc2LaunchTemplateDetails {
  /// The default version of the launch template.
  final int? defaultVersionNumber;

  /// An ID for the launch template.
  final String? id;

  /// The latest version of the launch template.
  final int? latestVersionNumber;

  /// The information to include in the launch template.
  final AwsEc2LaunchTemplateDataDetails? launchTemplateData;

  /// A name for the launch template.
  final String? launchTemplateName;

  AwsEc2LaunchTemplateDetails({
    this.defaultVersionNumber,
    this.id,
    this.latestVersionNumber,
    this.launchTemplateData,
    this.launchTemplateName,
  });

  factory AwsEc2LaunchTemplateDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2LaunchTemplateDetails(
      defaultVersionNumber: json['DefaultVersionNumber'] as int?,
      id: json['Id'] as String?,
      latestVersionNumber: json['LatestVersionNumber'] as int?,
      launchTemplateData: json['LaunchTemplateData'] != null
          ? AwsEc2LaunchTemplateDataDetails.fromJson(
              json['LaunchTemplateData'] as Map<String, dynamic>)
          : null,
      launchTemplateName: json['LaunchTemplateName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultVersionNumber = this.defaultVersionNumber;
    final id = this.id;
    final latestVersionNumber = this.latestVersionNumber;
    final launchTemplateData = this.launchTemplateData;
    final launchTemplateName = this.launchTemplateName;
    return {
      if (defaultVersionNumber != null)
        'DefaultVersionNumber': defaultVersionNumber,
      if (id != null) 'Id': id,
      if (latestVersionNumber != null)
        'LatestVersionNumber': latestVersionNumber,
      if (launchTemplateData != null) 'LaunchTemplateData': launchTemplateData,
      if (launchTemplateName != null) 'LaunchTemplateName': launchTemplateName,
    };
  }
}

/// An association between the network ACL and a subnet.
class AwsEc2NetworkAclAssociation {
  /// The identifier of the association between the network ACL and the subnet.
  final String? networkAclAssociationId;

  /// The identifier of the network ACL.
  final String? networkAclId;

  /// The identifier of the subnet that is associated with the network ACL.
  final String? subnetId;

  AwsEc2NetworkAclAssociation({
    this.networkAclAssociationId,
    this.networkAclId,
    this.subnetId,
  });

  factory AwsEc2NetworkAclAssociation.fromJson(Map<String, dynamic> json) {
    return AwsEc2NetworkAclAssociation(
      networkAclAssociationId: json['NetworkAclAssociationId'] as String?,
      networkAclId: json['NetworkAclId'] as String?,
      subnetId: json['SubnetId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final networkAclAssociationId = this.networkAclAssociationId;
    final networkAclId = this.networkAclId;
    final subnetId = this.subnetId;
    return {
      if (networkAclAssociationId != null)
        'NetworkAclAssociationId': networkAclAssociationId,
      if (networkAclId != null) 'NetworkAclId': networkAclId,
      if (subnetId != null) 'SubnetId': subnetId,
    };
  }
}

/// Contains details about an Amazon EC2 network access control list (ACL).
class AwsEc2NetworkAclDetails {
  /// Associations between the network ACL and subnets.
  final List<AwsEc2NetworkAclAssociation>? associations;

  /// The set of rules in the network ACL.
  final List<AwsEc2NetworkAclEntry>? entries;

  /// Whether this is the default network ACL for the VPC.
  final bool? isDefault;

  /// The identifier of the network ACL.
  final String? networkAclId;

  /// The identifier of the Amazon Web Services account that owns the network ACL.
  final String? ownerId;

  /// The identifier of the VPC for the network ACL.
  final String? vpcId;

  AwsEc2NetworkAclDetails({
    this.associations,
    this.entries,
    this.isDefault,
    this.networkAclId,
    this.ownerId,
    this.vpcId,
  });

  factory AwsEc2NetworkAclDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2NetworkAclDetails(
      associations: (json['Associations'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2NetworkAclAssociation.fromJson(e as Map<String, dynamic>))
          .toList(),
      entries: (json['Entries'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2NetworkAclEntry.fromJson(e as Map<String, dynamic>))
          .toList(),
      isDefault: json['IsDefault'] as bool?,
      networkAclId: json['NetworkAclId'] as String?,
      ownerId: json['OwnerId'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associations = this.associations;
    final entries = this.entries;
    final isDefault = this.isDefault;
    final networkAclId = this.networkAclId;
    final ownerId = this.ownerId;
    final vpcId = this.vpcId;
    return {
      if (associations != null) 'Associations': associations,
      if (entries != null) 'Entries': entries,
      if (isDefault != null) 'IsDefault': isDefault,
      if (networkAclId != null) 'NetworkAclId': networkAclId,
      if (ownerId != null) 'OwnerId': ownerId,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// A rule for the network ACL. Each rule allows or denies access based on the
/// IP address, traffic direction, port, and protocol.
class AwsEc2NetworkAclEntry {
  /// The IPV4 network range for which to deny or allow access.
  final String? cidrBlock;

  /// Whether the rule is an egress rule. An egress rule is a rule that applies to
  /// traffic that leaves the subnet.
  final bool? egress;

  /// The Internet Control Message Protocol (ICMP) type and code for which to deny
  /// or allow access.
  final IcmpTypeCode? icmpTypeCode;

  /// The IPV6 network range for which to deny or allow access.
  final String? ipv6CidrBlock;

  /// For TCP or UDP protocols, the range of ports that the rule applies to.
  final PortRangeFromTo? portRange;

  /// The protocol that the rule applies to. To deny or allow access to all
  /// protocols, use the value <code>-1</code>.
  final String? protocol;

  /// Whether the rule is used to allow access or deny access.
  final String? ruleAction;

  /// The rule number. The rules are processed in order by their number.
  final int? ruleNumber;

  AwsEc2NetworkAclEntry({
    this.cidrBlock,
    this.egress,
    this.icmpTypeCode,
    this.ipv6CidrBlock,
    this.portRange,
    this.protocol,
    this.ruleAction,
    this.ruleNumber,
  });

  factory AwsEc2NetworkAclEntry.fromJson(Map<String, dynamic> json) {
    return AwsEc2NetworkAclEntry(
      cidrBlock: json['CidrBlock'] as String?,
      egress: json['Egress'] as bool?,
      icmpTypeCode: json['IcmpTypeCode'] != null
          ? IcmpTypeCode.fromJson(json['IcmpTypeCode'] as Map<String, dynamic>)
          : null,
      ipv6CidrBlock: json['Ipv6CidrBlock'] as String?,
      portRange: json['PortRange'] != null
          ? PortRangeFromTo.fromJson(json['PortRange'] as Map<String, dynamic>)
          : null,
      protocol: json['Protocol'] as String?,
      ruleAction: json['RuleAction'] as String?,
      ruleNumber: json['RuleNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrBlock = this.cidrBlock;
    final egress = this.egress;
    final icmpTypeCode = this.icmpTypeCode;
    final ipv6CidrBlock = this.ipv6CidrBlock;
    final portRange = this.portRange;
    final protocol = this.protocol;
    final ruleAction = this.ruleAction;
    final ruleNumber = this.ruleNumber;
    return {
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      if (egress != null) 'Egress': egress,
      if (icmpTypeCode != null) 'IcmpTypeCode': icmpTypeCode,
      if (ipv6CidrBlock != null) 'Ipv6CidrBlock': ipv6CidrBlock,
      if (portRange != null) 'PortRange': portRange,
      if (protocol != null) 'Protocol': protocol,
      if (ruleAction != null) 'RuleAction': ruleAction,
      if (ruleNumber != null) 'RuleNumber': ruleNumber,
    };
  }
}

/// Information about the network interface attachment.
class AwsEc2NetworkInterfaceAttachment {
  /// Indicates when the attachment initiated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? attachTime;

  /// The identifier of the network interface attachment
  final String? attachmentId;

  /// Indicates whether the network interface is deleted when the instance is
  /// terminated.
  final bool? deleteOnTermination;

  /// The device index of the network interface attachment on the instance.
  final int? deviceIndex;

  /// The ID of the instance.
  final String? instanceId;

  /// The Amazon Web Services account ID of the owner of the instance.
  final String? instanceOwnerId;

  /// The attachment state.
  ///
  /// Valid values: <code>attaching</code> | <code>attached</code> |
  /// <code>detaching</code> | <code>detached</code>
  final String? status;

  AwsEc2NetworkInterfaceAttachment({
    this.attachTime,
    this.attachmentId,
    this.deleteOnTermination,
    this.deviceIndex,
    this.instanceId,
    this.instanceOwnerId,
    this.status,
  });

  factory AwsEc2NetworkInterfaceAttachment.fromJson(Map<String, dynamic> json) {
    return AwsEc2NetworkInterfaceAttachment(
      attachTime: json['AttachTime'] as String?,
      attachmentId: json['AttachmentId'] as String?,
      deleteOnTermination: json['DeleteOnTermination'] as bool?,
      deviceIndex: json['DeviceIndex'] as int?,
      instanceId: json['InstanceId'] as String?,
      instanceOwnerId: json['InstanceOwnerId'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachTime = this.attachTime;
    final attachmentId = this.attachmentId;
    final deleteOnTermination = this.deleteOnTermination;
    final deviceIndex = this.deviceIndex;
    final instanceId = this.instanceId;
    final instanceOwnerId = this.instanceOwnerId;
    final status = this.status;
    return {
      if (attachTime != null) 'AttachTime': attachTime,
      if (attachmentId != null) 'AttachmentId': attachmentId,
      if (deleteOnTermination != null)
        'DeleteOnTermination': deleteOnTermination,
      if (deviceIndex != null) 'DeviceIndex': deviceIndex,
      if (instanceId != null) 'InstanceId': instanceId,
      if (instanceOwnerId != null) 'InstanceOwnerId': instanceOwnerId,
      if (status != null) 'Status': status,
    };
  }
}

/// Details about the network interface
class AwsEc2NetworkInterfaceDetails {
  /// The network interface attachment.
  final AwsEc2NetworkInterfaceAttachment? attachment;

  /// The IPv6 addresses associated with the network interface.
  final List<AwsEc2NetworkInterfaceIpV6AddressDetail>? ipV6Addresses;

  /// The ID of the network interface.
  final String? networkInterfaceId;

  /// The private IPv4 addresses associated with the network interface.
  final List<AwsEc2NetworkInterfacePrivateIpAddressDetail>? privateIpAddresses;

  /// The public DNS name of the network interface.
  final String? publicDnsName;

  /// The address of the Elastic IP address bound to the network interface.
  final String? publicIp;

  /// Security groups for the network interface.
  final List<AwsEc2NetworkInterfaceSecurityGroup>? securityGroups;

  /// Indicates whether traffic to or from the instance is validated.
  final bool? sourceDestCheck;

  AwsEc2NetworkInterfaceDetails({
    this.attachment,
    this.ipV6Addresses,
    this.networkInterfaceId,
    this.privateIpAddresses,
    this.publicDnsName,
    this.publicIp,
    this.securityGroups,
    this.sourceDestCheck,
  });

  factory AwsEc2NetworkInterfaceDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2NetworkInterfaceDetails(
      attachment: json['Attachment'] != null
          ? AwsEc2NetworkInterfaceAttachment.fromJson(
              json['Attachment'] as Map<String, dynamic>)
          : null,
      ipV6Addresses: (json['IpV6Addresses'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2NetworkInterfaceIpV6AddressDetail.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
      privateIpAddresses: (json['PrivateIpAddresses'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2NetworkInterfacePrivateIpAddressDetail.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      publicDnsName: json['PublicDnsName'] as String?,
      publicIp: json['PublicIp'] as String?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2NetworkInterfaceSecurityGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      sourceDestCheck: json['SourceDestCheck'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachment = this.attachment;
    final ipV6Addresses = this.ipV6Addresses;
    final networkInterfaceId = this.networkInterfaceId;
    final privateIpAddresses = this.privateIpAddresses;
    final publicDnsName = this.publicDnsName;
    final publicIp = this.publicIp;
    final securityGroups = this.securityGroups;
    final sourceDestCheck = this.sourceDestCheck;
    return {
      if (attachment != null) 'Attachment': attachment,
      if (ipV6Addresses != null) 'IpV6Addresses': ipV6Addresses,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (privateIpAddresses != null) 'PrivateIpAddresses': privateIpAddresses,
      if (publicDnsName != null) 'PublicDnsName': publicDnsName,
      if (publicIp != null) 'PublicIp': publicIp,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (sourceDestCheck != null) 'SourceDestCheck': sourceDestCheck,
    };
  }
}

/// Provides information about an IPV6 address that is associated with the
/// network interface.
class AwsEc2NetworkInterfaceIpV6AddressDetail {
  /// The IPV6 address.
  final String? ipV6Address;

  AwsEc2NetworkInterfaceIpV6AddressDetail({
    this.ipV6Address,
  });

  factory AwsEc2NetworkInterfaceIpV6AddressDetail.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2NetworkInterfaceIpV6AddressDetail(
      ipV6Address: json['IpV6Address'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipV6Address = this.ipV6Address;
    return {
      if (ipV6Address != null) 'IpV6Address': ipV6Address,
    };
  }
}

/// Provides information about a private IPv4 address that is with the network
/// interface.
class AwsEc2NetworkInterfacePrivateIpAddressDetail {
  /// The private DNS name for the IP address.
  final String? privateDnsName;

  /// The IP address.
  final String? privateIpAddress;

  AwsEc2NetworkInterfacePrivateIpAddressDetail({
    this.privateDnsName,
    this.privateIpAddress,
  });

  factory AwsEc2NetworkInterfacePrivateIpAddressDetail.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2NetworkInterfacePrivateIpAddressDetail(
      privateDnsName: json['PrivateDnsName'] as String?,
      privateIpAddress: json['PrivateIpAddress'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final privateDnsName = this.privateDnsName;
    final privateIpAddress = this.privateIpAddress;
    return {
      if (privateDnsName != null) 'PrivateDnsName': privateDnsName,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
    };
  }
}

/// A security group associated with the network interface.
class AwsEc2NetworkInterfaceSecurityGroup {
  /// The ID of the security group.
  final String? groupId;

  /// The name of the security group.
  final String? groupName;

  AwsEc2NetworkInterfaceSecurityGroup({
    this.groupId,
    this.groupName,
  });

  factory AwsEc2NetworkInterfaceSecurityGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2NetworkInterfaceSecurityGroup(
      groupId: json['GroupId'] as String?,
      groupName: json['GroupName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupId = this.groupId;
    final groupName = this.groupName;
    return {
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
    };
  }
}

/// Provides details about a route table for the specified VPC.
class AwsEc2RouteTableDetails {
  /// The associations between a route table and one or more subnets or a gateway.
  final List<AssociationSetDetails>? associationSet;

  /// The ID of the Amazon Web Services account that owns the route table.
  final String? ownerId;

  /// Describes a virtual private gateway propagating route.
  final List<PropagatingVgwSetDetails>? propagatingVgwSet;

  /// The routes in the route table.
  final List<RouteSetDetails>? routeSet;

  /// The ID of the route table.
  final String? routeTableId;

  /// The ID of the virtual private cloud (VPC).
  final String? vpcId;

  AwsEc2RouteTableDetails({
    this.associationSet,
    this.ownerId,
    this.propagatingVgwSet,
    this.routeSet,
    this.routeTableId,
    this.vpcId,
  });

  factory AwsEc2RouteTableDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2RouteTableDetails(
      associationSet: (json['AssociationSet'] as List?)
          ?.whereNotNull()
          .map((e) => AssociationSetDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      ownerId: json['OwnerId'] as String?,
      propagatingVgwSet: (json['PropagatingVgwSet'] as List?)
          ?.whereNotNull()
          .map((e) =>
              PropagatingVgwSetDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      routeSet: (json['RouteSet'] as List?)
          ?.whereNotNull()
          .map((e) => RouteSetDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      routeTableId: json['RouteTableId'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationSet = this.associationSet;
    final ownerId = this.ownerId;
    final propagatingVgwSet = this.propagatingVgwSet;
    final routeSet = this.routeSet;
    final routeTableId = this.routeTableId;
    final vpcId = this.vpcId;
    return {
      if (associationSet != null) 'AssociationSet': associationSet,
      if (ownerId != null) 'OwnerId': ownerId,
      if (propagatingVgwSet != null) 'PropagatingVgwSet': propagatingVgwSet,
      if (routeSet != null) 'RouteSet': routeSet,
      if (routeTableId != null) 'RouteTableId': routeTableId,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Details about an Amazon EC2 security group.
class AwsEc2SecurityGroupDetails {
  /// The ID of the security group.
  final String? groupId;

  /// The name of the security group.
  final String? groupName;

  /// The inbound rules associated with the security group.
  final List<AwsEc2SecurityGroupIpPermission>? ipPermissions;

  /// [VPC only] The outbound rules associated with the security group.
  final List<AwsEc2SecurityGroupIpPermission>? ipPermissionsEgress;

  /// The Amazon Web Services account ID of the owner of the security group.
  final String? ownerId;

  /// [VPC only] The ID of the VPC for the security group.
  final String? vpcId;

  AwsEc2SecurityGroupDetails({
    this.groupId,
    this.groupName,
    this.ipPermissions,
    this.ipPermissionsEgress,
    this.ownerId,
    this.vpcId,
  });

  factory AwsEc2SecurityGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2SecurityGroupDetails(
      groupId: json['GroupId'] as String?,
      groupName: json['GroupName'] as String?,
      ipPermissions: (json['IpPermissions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2SecurityGroupIpPermission.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ipPermissionsEgress: (json['IpPermissionsEgress'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2SecurityGroupIpPermission.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ownerId: json['OwnerId'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupId = this.groupId;
    final groupName = this.groupName;
    final ipPermissions = this.ipPermissions;
    final ipPermissionsEgress = this.ipPermissionsEgress;
    final ownerId = this.ownerId;
    final vpcId = this.vpcId;
    return {
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      if (ipPermissions != null) 'IpPermissions': ipPermissions,
      if (ipPermissionsEgress != null)
        'IpPermissionsEgress': ipPermissionsEgress,
      if (ownerId != null) 'OwnerId': ownerId,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// An IP permission for an EC2 security group.
class AwsEc2SecurityGroupIpPermission {
  /// The start of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6
  /// type number.
  ///
  /// A value of -1 indicates all ICMP/ICMPv6 types. If you specify all
  /// ICMP/ICMPv6 types, you must specify all codes.
  final int? fromPort;

  /// The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>,
  /// <code>icmpv6</code>) or number.
  ///
  /// [VPC only] Use <code>-1</code> to specify all protocols.
  ///
  /// When authorizing security group rules, specifying <code>-1</code> or a
  /// protocol number other than <code>tcp</code>, <code>udp</code>,
  /// <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports,
  /// regardless of any port range you specify.
  ///
  /// For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must
  /// specify a port range.
  ///
  /// For <code>icmpv6</code>, the port range is optional. If you omit the port
  /// range, traffic for all types and codes is allowed.
  final String? ipProtocol;

  /// The IPv4 ranges.
  final List<AwsEc2SecurityGroupIpRange>? ipRanges;

  /// The IPv6 ranges.
  final List<AwsEc2SecurityGroupIpv6Range>? ipv6Ranges;

  /// [VPC only] The prefix list IDs for an Amazon Web Services service. With
  /// outbound rules, this is the Amazon Web Services service to access through a
  /// VPC endpoint from instances associated with the security group.
  final List<AwsEc2SecurityGroupPrefixListId>? prefixListIds;

  /// The end of the port range for the TCP and UDP protocols, or an ICMP/ICMPv6
  /// code.
  ///
  /// A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify
  /// all ICMP/ICMPv6 types, you must specify all codes.
  final int? toPort;

  /// The security group and Amazon Web Services account ID pairs.
  final List<AwsEc2SecurityGroupUserIdGroupPair>? userIdGroupPairs;

  AwsEc2SecurityGroupIpPermission({
    this.fromPort,
    this.ipProtocol,
    this.ipRanges,
    this.ipv6Ranges,
    this.prefixListIds,
    this.toPort,
    this.userIdGroupPairs,
  });

  factory AwsEc2SecurityGroupIpPermission.fromJson(Map<String, dynamic> json) {
    return AwsEc2SecurityGroupIpPermission(
      fromPort: json['FromPort'] as int?,
      ipProtocol: json['IpProtocol'] as String?,
      ipRanges: (json['IpRanges'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2SecurityGroupIpRange.fromJson(e as Map<String, dynamic>))
          .toList(),
      ipv6Ranges: (json['Ipv6Ranges'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEc2SecurityGroupIpv6Range.fromJson(e as Map<String, dynamic>))
          .toList(),
      prefixListIds: (json['PrefixListIds'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2SecurityGroupPrefixListId.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      toPort: json['ToPort'] as int?,
      userIdGroupPairs: (json['UserIdGroupPairs'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2SecurityGroupUserIdGroupPair.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final fromPort = this.fromPort;
    final ipProtocol = this.ipProtocol;
    final ipRanges = this.ipRanges;
    final ipv6Ranges = this.ipv6Ranges;
    final prefixListIds = this.prefixListIds;
    final toPort = this.toPort;
    final userIdGroupPairs = this.userIdGroupPairs;
    return {
      if (fromPort != null) 'FromPort': fromPort,
      if (ipProtocol != null) 'IpProtocol': ipProtocol,
      if (ipRanges != null) 'IpRanges': ipRanges,
      if (ipv6Ranges != null) 'Ipv6Ranges': ipv6Ranges,
      if (prefixListIds != null) 'PrefixListIds': prefixListIds,
      if (toPort != null) 'ToPort': toPort,
      if (userIdGroupPairs != null) 'UserIdGroupPairs': userIdGroupPairs,
    };
  }
}

/// A range of IPv4 addresses.
class AwsEc2SecurityGroupIpRange {
  /// The IPv4 CIDR range. You can specify either a CIDR range or a source
  /// security group, but not both. To specify a single IPv4 address, use the /32
  /// prefix length.
  final String? cidrIp;

  AwsEc2SecurityGroupIpRange({
    this.cidrIp,
  });

  factory AwsEc2SecurityGroupIpRange.fromJson(Map<String, dynamic> json) {
    return AwsEc2SecurityGroupIpRange(
      cidrIp: json['CidrIp'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrIp = this.cidrIp;
    return {
      if (cidrIp != null) 'CidrIp': cidrIp,
    };
  }
}

/// A range of IPv6 addresses.
class AwsEc2SecurityGroupIpv6Range {
  /// The IPv6 CIDR range. You can specify either a CIDR range or a source
  /// security group, but not both. To specify a single IPv6 address, use the /128
  /// prefix length.
  final String? cidrIpv6;

  AwsEc2SecurityGroupIpv6Range({
    this.cidrIpv6,
  });

  factory AwsEc2SecurityGroupIpv6Range.fromJson(Map<String, dynamic> json) {
    return AwsEc2SecurityGroupIpv6Range(
      cidrIpv6: json['CidrIpv6'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrIpv6 = this.cidrIpv6;
    return {
      if (cidrIpv6 != null) 'CidrIpv6': cidrIpv6,
    };
  }
}

/// A prefix list ID.
class AwsEc2SecurityGroupPrefixListId {
  /// The ID of the prefix.
  final String? prefixListId;

  AwsEc2SecurityGroupPrefixListId({
    this.prefixListId,
  });

  factory AwsEc2SecurityGroupPrefixListId.fromJson(Map<String, dynamic> json) {
    return AwsEc2SecurityGroupPrefixListId(
      prefixListId: json['PrefixListId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final prefixListId = this.prefixListId;
    return {
      if (prefixListId != null) 'PrefixListId': prefixListId,
    };
  }
}

/// A relationship between a security group and a user.
class AwsEc2SecurityGroupUserIdGroupPair {
  /// The ID of the security group.
  final String? groupId;

  /// The name of the security group.
  final String? groupName;

  /// The status of a VPC peering connection, if applicable.
  final String? peeringStatus;

  /// The ID of an Amazon Web Services account.
  ///
  /// For a referenced security group in another VPC, the account ID of the
  /// referenced security group is returned in the response. If the referenced
  /// security group is deleted, this value is not returned.
  ///
  /// [EC2-Classic] Required when adding or removing rules that reference a
  /// security group in another VPC.
  final String? userId;

  /// The ID of the VPC for the referenced security group, if applicable.
  final String? vpcId;

  /// The ID of the VPC peering connection, if applicable.
  final String? vpcPeeringConnectionId;

  AwsEc2SecurityGroupUserIdGroupPair({
    this.groupId,
    this.groupName,
    this.peeringStatus,
    this.userId,
    this.vpcId,
    this.vpcPeeringConnectionId,
  });

  factory AwsEc2SecurityGroupUserIdGroupPair.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2SecurityGroupUserIdGroupPair(
      groupId: json['GroupId'] as String?,
      groupName: json['GroupName'] as String?,
      peeringStatus: json['PeeringStatus'] as String?,
      userId: json['UserId'] as String?,
      vpcId: json['VpcId'] as String?,
      vpcPeeringConnectionId: json['VpcPeeringConnectionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupId = this.groupId;
    final groupName = this.groupName;
    final peeringStatus = this.peeringStatus;
    final userId = this.userId;
    final vpcId = this.vpcId;
    final vpcPeeringConnectionId = this.vpcPeeringConnectionId;
    return {
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      if (peeringStatus != null) 'PeeringStatus': peeringStatus,
      if (userId != null) 'UserId': userId,
      if (vpcId != null) 'VpcId': vpcId,
      if (vpcPeeringConnectionId != null)
        'VpcPeeringConnectionId': vpcPeeringConnectionId,
    };
  }
}

/// Contains information about a subnet in Amazon EC2.
class AwsEc2SubnetDetails {
  /// Whether to assign an IPV6 address to a network interface that is created in
  /// this subnet.
  final bool? assignIpv6AddressOnCreation;

  /// The Availability Zone for the subnet.
  final String? availabilityZone;

  /// The identifier of the Availability Zone for the subnet.
  final String? availabilityZoneId;

  /// The number of available IPV4 addresses in the subnet. Does not include
  /// addresses for stopped instances.
  final int? availableIpAddressCount;

  /// The IPV4 CIDR block that is assigned to the subnet.
  final String? cidrBlock;

  /// Whether this subnet is the default subnet for the Availability Zone.
  final bool? defaultForAz;

  /// The IPV6 CIDR blocks that are associated with the subnet.
  final List<Ipv6CidrBlockAssociation>? ipv6CidrBlockAssociationSet;

  /// Whether instances in this subnet receive a public IP address.
  final bool? mapPublicIpOnLaunch;

  /// The identifier of the Amazon Web Services account that owns the subnet.
  final String? ownerId;

  /// The current state of the subnet. Valid values are <code>available</code> or
  /// <code>pending</code>.
  final String? state;

  /// The ARN of the subnet.
  final String? subnetArn;

  /// The identifier of the subnet.
  final String? subnetId;

  /// The identifier of the VPC that contains the subnet.
  final String? vpcId;

  AwsEc2SubnetDetails({
    this.assignIpv6AddressOnCreation,
    this.availabilityZone,
    this.availabilityZoneId,
    this.availableIpAddressCount,
    this.cidrBlock,
    this.defaultForAz,
    this.ipv6CidrBlockAssociationSet,
    this.mapPublicIpOnLaunch,
    this.ownerId,
    this.state,
    this.subnetArn,
    this.subnetId,
    this.vpcId,
  });

  factory AwsEc2SubnetDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2SubnetDetails(
      assignIpv6AddressOnCreation: json['AssignIpv6AddressOnCreation'] as bool?,
      availabilityZone: json['AvailabilityZone'] as String?,
      availabilityZoneId: json['AvailabilityZoneId'] as String?,
      availableIpAddressCount: json['AvailableIpAddressCount'] as int?,
      cidrBlock: json['CidrBlock'] as String?,
      defaultForAz: json['DefaultForAz'] as bool?,
      ipv6CidrBlockAssociationSet:
          (json['Ipv6CidrBlockAssociationSet'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  Ipv6CidrBlockAssociation.fromJson(e as Map<String, dynamic>))
              .toList(),
      mapPublicIpOnLaunch: json['MapPublicIpOnLaunch'] as bool?,
      ownerId: json['OwnerId'] as String?,
      state: json['State'] as String?,
      subnetArn: json['SubnetArn'] as String?,
      subnetId: json['SubnetId'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assignIpv6AddressOnCreation = this.assignIpv6AddressOnCreation;
    final availabilityZone = this.availabilityZone;
    final availabilityZoneId = this.availabilityZoneId;
    final availableIpAddressCount = this.availableIpAddressCount;
    final cidrBlock = this.cidrBlock;
    final defaultForAz = this.defaultForAz;
    final ipv6CidrBlockAssociationSet = this.ipv6CidrBlockAssociationSet;
    final mapPublicIpOnLaunch = this.mapPublicIpOnLaunch;
    final ownerId = this.ownerId;
    final state = this.state;
    final subnetArn = this.subnetArn;
    final subnetId = this.subnetId;
    final vpcId = this.vpcId;
    return {
      if (assignIpv6AddressOnCreation != null)
        'AssignIpv6AddressOnCreation': assignIpv6AddressOnCreation,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (availabilityZoneId != null) 'AvailabilityZoneId': availabilityZoneId,
      if (availableIpAddressCount != null)
        'AvailableIpAddressCount': availableIpAddressCount,
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      if (defaultForAz != null) 'DefaultForAz': defaultForAz,
      if (ipv6CidrBlockAssociationSet != null)
        'Ipv6CidrBlockAssociationSet': ipv6CidrBlockAssociationSet,
      if (mapPublicIpOnLaunch != null)
        'MapPublicIpOnLaunch': mapPublicIpOnLaunch,
      if (ownerId != null) 'OwnerId': ownerId,
      if (state != null) 'State': state,
      if (subnetArn != null) 'SubnetArn': subnetArn,
      if (subnetId != null) 'SubnetId': subnetId,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Information about an Amazon Web Services Amazon EC2 Transit Gateway that
/// interconnects virtual private clouds (VPCs) and on-premises networks.
class AwsEc2TransitGatewayDetails {
  /// A private Autonomous System Number (ASN) for the Amazon side of a BGP
  /// session.
  final int? amazonSideAsn;

  /// The ID of the default association route table.
  final String? associationDefaultRouteTableId;

  /// Turn on or turn off automatic acceptance of attachment requests.
  final String? autoAcceptSharedAttachments;

  /// Turn on or turn off automatic association with the default association route
  /// table.
  final String? defaultRouteTableAssociation;

  /// Turn on or turn off automatic propagation of routes to the default
  /// propagation route table.
  final String? defaultRouteTablePropagation;

  /// The description of the transit gateway.
  final String? description;

  /// Turn on or turn off DNS support.
  final String? dnsSupport;

  /// The ID of the transit gateway.
  final String? id;

  /// Indicates whether multicast is supported on the transit gateway.
  final String? multicastSupport;

  /// The ID of the default propagation route table.
  final String? propagationDefaultRouteTableId;

  /// The transit gateway Classless Inter-Domain Routing (CIDR) blocks.
  final List<String>? transitGatewayCidrBlocks;

  /// Turn on or turn off Equal Cost Multipath Protocol (ECMP) support.
  final String? vpnEcmpSupport;

  AwsEc2TransitGatewayDetails({
    this.amazonSideAsn,
    this.associationDefaultRouteTableId,
    this.autoAcceptSharedAttachments,
    this.defaultRouteTableAssociation,
    this.defaultRouteTablePropagation,
    this.description,
    this.dnsSupport,
    this.id,
    this.multicastSupport,
    this.propagationDefaultRouteTableId,
    this.transitGatewayCidrBlocks,
    this.vpnEcmpSupport,
  });

  factory AwsEc2TransitGatewayDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2TransitGatewayDetails(
      amazonSideAsn: json['AmazonSideAsn'] as int?,
      associationDefaultRouteTableId:
          json['AssociationDefaultRouteTableId'] as String?,
      autoAcceptSharedAttachments:
          json['AutoAcceptSharedAttachments'] as String?,
      defaultRouteTableAssociation:
          json['DefaultRouteTableAssociation'] as String?,
      defaultRouteTablePropagation:
          json['DefaultRouteTablePropagation'] as String?,
      description: json['Description'] as String?,
      dnsSupport: json['DnsSupport'] as String?,
      id: json['Id'] as String?,
      multicastSupport: json['MulticastSupport'] as String?,
      propagationDefaultRouteTableId:
          json['PropagationDefaultRouteTableId'] as String?,
      transitGatewayCidrBlocks: (json['TransitGatewayCidrBlocks'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      vpnEcmpSupport: json['VpnEcmpSupport'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final amazonSideAsn = this.amazonSideAsn;
    final associationDefaultRouteTableId = this.associationDefaultRouteTableId;
    final autoAcceptSharedAttachments = this.autoAcceptSharedAttachments;
    final defaultRouteTableAssociation = this.defaultRouteTableAssociation;
    final defaultRouteTablePropagation = this.defaultRouteTablePropagation;
    final description = this.description;
    final dnsSupport = this.dnsSupport;
    final id = this.id;
    final multicastSupport = this.multicastSupport;
    final propagationDefaultRouteTableId = this.propagationDefaultRouteTableId;
    final transitGatewayCidrBlocks = this.transitGatewayCidrBlocks;
    final vpnEcmpSupport = this.vpnEcmpSupport;
    return {
      if (amazonSideAsn != null) 'AmazonSideAsn': amazonSideAsn,
      if (associationDefaultRouteTableId != null)
        'AssociationDefaultRouteTableId': associationDefaultRouteTableId,
      if (autoAcceptSharedAttachments != null)
        'AutoAcceptSharedAttachments': autoAcceptSharedAttachments,
      if (defaultRouteTableAssociation != null)
        'DefaultRouteTableAssociation': defaultRouteTableAssociation,
      if (defaultRouteTablePropagation != null)
        'DefaultRouteTablePropagation': defaultRouteTablePropagation,
      if (description != null) 'Description': description,
      if (dnsSupport != null) 'DnsSupport': dnsSupport,
      if (id != null) 'Id': id,
      if (multicastSupport != null) 'MulticastSupport': multicastSupport,
      if (propagationDefaultRouteTableId != null)
        'PropagationDefaultRouteTableId': propagationDefaultRouteTableId,
      if (transitGatewayCidrBlocks != null)
        'TransitGatewayCidrBlocks': transitGatewayCidrBlocks,
      if (vpnEcmpSupport != null) 'VpnEcmpSupport': vpnEcmpSupport,
    };
  }
}

/// An attachment to an Amazon EC2 volume.
class AwsEc2VolumeAttachment {
  /// The datetime when the attachment initiated.
  final String? attachTime;

  /// Whether the EBS volume is deleted when the EC2 instance is terminated.
  final bool? deleteOnTermination;

  /// The identifier of the EC2 instance.
  final String? instanceId;

  /// The attachment state of the volume. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>attaching</code>
  /// </li>
  /// <li>
  /// <code>attached</code>
  /// </li>
  /// <li>
  /// <code>busy</code>
  /// </li>
  /// <li>
  /// <code>detaching</code>
  /// </li>
  /// <li>
  /// <code>detached</code>
  /// </li>
  /// </ul>
  final String? status;

  AwsEc2VolumeAttachment({
    this.attachTime,
    this.deleteOnTermination,
    this.instanceId,
    this.status,
  });

  factory AwsEc2VolumeAttachment.fromJson(Map<String, dynamic> json) {
    return AwsEc2VolumeAttachment(
      attachTime: json['AttachTime'] as String?,
      deleteOnTermination: json['DeleteOnTermination'] as bool?,
      instanceId: json['InstanceId'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachTime = this.attachTime;
    final deleteOnTermination = this.deleteOnTermination;
    final instanceId = this.instanceId;
    final status = this.status;
    return {
      if (attachTime != null) 'AttachTime': attachTime,
      if (deleteOnTermination != null)
        'DeleteOnTermination': deleteOnTermination,
      if (instanceId != null) 'InstanceId': instanceId,
      if (status != null) 'Status': status,
    };
  }
}

/// Details about an EC2 volume.
class AwsEc2VolumeDetails {
  /// The volume attachments.
  final List<AwsEc2VolumeAttachment>? attachments;

  /// Indicates when the volume was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createTime;

  /// The device name for the volume that is attached to the instance.
  final String? deviceName;

  /// Specifies whether the volume is encrypted.
  final bool? encrypted;

  /// The ARN of the KMS key that was used to protect the volume encryption key
  /// for the volume.
  final String? kmsKeyId;

  /// The size of the volume, in GiBs.
  final int? size;

  /// The snapshot from which the volume was created.
  final String? snapshotId;

  /// The volume state. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>available</code>
  /// </li>
  /// <li>
  /// <code>creating</code>
  /// </li>
  /// <li>
  /// <code>deleted</code>
  /// </li>
  /// <li>
  /// <code>deleting</code>
  /// </li>
  /// <li>
  /// <code>error</code>
  /// </li>
  /// <li>
  /// <code>in-use</code>
  /// </li>
  /// </ul>
  final String? status;

  /// The ID of the volume.
  final String? volumeId;

  /// Indicates whether the volume was scanned or skipped.
  final String? volumeScanStatus;

  /// The volume type.
  final String? volumeType;

  AwsEc2VolumeDetails({
    this.attachments,
    this.createTime,
    this.deviceName,
    this.encrypted,
    this.kmsKeyId,
    this.size,
    this.snapshotId,
    this.status,
    this.volumeId,
    this.volumeScanStatus,
    this.volumeType,
  });

  factory AwsEc2VolumeDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2VolumeDetails(
      attachments: (json['Attachments'] as List?)
          ?.whereNotNull()
          .map(
              (e) => AwsEc2VolumeAttachment.fromJson(e as Map<String, dynamic>))
          .toList(),
      createTime: json['CreateTime'] as String?,
      deviceName: json['DeviceName'] as String?,
      encrypted: json['Encrypted'] as bool?,
      kmsKeyId: json['KmsKeyId'] as String?,
      size: json['Size'] as int?,
      snapshotId: json['SnapshotId'] as String?,
      status: json['Status'] as String?,
      volumeId: json['VolumeId'] as String?,
      volumeScanStatus: json['VolumeScanStatus'] as String?,
      volumeType: json['VolumeType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachments = this.attachments;
    final createTime = this.createTime;
    final deviceName = this.deviceName;
    final encrypted = this.encrypted;
    final kmsKeyId = this.kmsKeyId;
    final size = this.size;
    final snapshotId = this.snapshotId;
    final status = this.status;
    final volumeId = this.volumeId;
    final volumeScanStatus = this.volumeScanStatus;
    final volumeType = this.volumeType;
    return {
      if (attachments != null) 'Attachments': attachments,
      if (createTime != null) 'CreateTime': createTime,
      if (deviceName != null) 'DeviceName': deviceName,
      if (encrypted != null) 'Encrypted': encrypted,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (size != null) 'Size': size,
      if (snapshotId != null) 'SnapshotId': snapshotId,
      if (status != null) 'Status': status,
      if (volumeId != null) 'VolumeId': volumeId,
      if (volumeScanStatus != null) 'VolumeScanStatus': volumeScanStatus,
      if (volumeType != null) 'VolumeType': volumeType,
    };
  }
}

/// Details about an EC2 VPC.
class AwsEc2VpcDetails {
  /// Information about the IPv4 CIDR blocks associated with the VPC.
  final List<CidrBlockAssociation>? cidrBlockAssociationSet;

  /// The identifier of the set of Dynamic Host Configuration Protocol (DHCP)
  /// options that are associated with the VPC. If the default options are
  /// associated with the VPC, then this is default.
  final String? dhcpOptionsId;

  /// Information about the IPv6 CIDR blocks associated with the VPC.
  final List<Ipv6CidrBlockAssociation>? ipv6CidrBlockAssociationSet;

  /// The current state of the VPC. Valid values are <code>available</code> or
  /// <code>pending</code>.
  final String? state;

  AwsEc2VpcDetails({
    this.cidrBlockAssociationSet,
    this.dhcpOptionsId,
    this.ipv6CidrBlockAssociationSet,
    this.state,
  });

  factory AwsEc2VpcDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2VpcDetails(
      cidrBlockAssociationSet: (json['CidrBlockAssociationSet'] as List?)
          ?.whereNotNull()
          .map((e) => CidrBlockAssociation.fromJson(e as Map<String, dynamic>))
          .toList(),
      dhcpOptionsId: json['DhcpOptionsId'] as String?,
      ipv6CidrBlockAssociationSet:
          (json['Ipv6CidrBlockAssociationSet'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  Ipv6CidrBlockAssociation.fromJson(e as Map<String, dynamic>))
              .toList(),
      state: json['State'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrBlockAssociationSet = this.cidrBlockAssociationSet;
    final dhcpOptionsId = this.dhcpOptionsId;
    final ipv6CidrBlockAssociationSet = this.ipv6CidrBlockAssociationSet;
    final state = this.state;
    return {
      if (cidrBlockAssociationSet != null)
        'CidrBlockAssociationSet': cidrBlockAssociationSet,
      if (dhcpOptionsId != null) 'DhcpOptionsId': dhcpOptionsId,
      if (ipv6CidrBlockAssociationSet != null)
        'Ipv6CidrBlockAssociationSet': ipv6CidrBlockAssociationSet,
      if (state != null) 'State': state,
    };
  }
}

/// Contains details about the service configuration for a VPC endpoint service.
class AwsEc2VpcEndpointServiceDetails {
  /// Whether requests from other Amazon Web Services accounts to create an
  /// endpoint to the service must first be accepted.
  final bool? acceptanceRequired;

  /// The Availability Zones where the service is available.
  final List<String>? availabilityZones;

  /// The DNS names for the service.
  final List<String>? baseEndpointDnsNames;

  /// The ARNs of the Gateway Load Balancers for the service.
  final List<String>? gatewayLoadBalancerArns;

  /// Whether the service manages its VPC endpoints.
  final bool? managesVpcEndpoints;

  /// The ARNs of the Network Load Balancers for the service.
  final List<String>? networkLoadBalancerArns;

  /// The private DNS name for the service.
  final String? privateDnsName;

  /// The identifier of the service.
  final String? serviceId;

  /// The name of the service.
  final String? serviceName;

  /// The current state of the service. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>Available</code>
  /// </li>
  /// <li>
  /// <code>Deleted</code>
  /// </li>
  /// <li>
  /// <code>Deleting</code>
  /// </li>
  /// <li>
  /// <code>Failed</code>
  /// </li>
  /// <li>
  /// <code>Pending</code>
  /// </li>
  /// </ul>
  final String? serviceState;

  /// The types for the service.
  final List<AwsEc2VpcEndpointServiceServiceTypeDetails>? serviceType;

  AwsEc2VpcEndpointServiceDetails({
    this.acceptanceRequired,
    this.availabilityZones,
    this.baseEndpointDnsNames,
    this.gatewayLoadBalancerArns,
    this.managesVpcEndpoints,
    this.networkLoadBalancerArns,
    this.privateDnsName,
    this.serviceId,
    this.serviceName,
    this.serviceState,
    this.serviceType,
  });

  factory AwsEc2VpcEndpointServiceDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2VpcEndpointServiceDetails(
      acceptanceRequired: json['AcceptanceRequired'] as bool?,
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      baseEndpointDnsNames: (json['BaseEndpointDnsNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      gatewayLoadBalancerArns: (json['GatewayLoadBalancerArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      managesVpcEndpoints: json['ManagesVpcEndpoints'] as bool?,
      networkLoadBalancerArns: (json['NetworkLoadBalancerArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      privateDnsName: json['PrivateDnsName'] as String?,
      serviceId: json['ServiceId'] as String?,
      serviceName: json['ServiceName'] as String?,
      serviceState: json['ServiceState'] as String?,
      serviceType: (json['ServiceType'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2VpcEndpointServiceServiceTypeDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final acceptanceRequired = this.acceptanceRequired;
    final availabilityZones = this.availabilityZones;
    final baseEndpointDnsNames = this.baseEndpointDnsNames;
    final gatewayLoadBalancerArns = this.gatewayLoadBalancerArns;
    final managesVpcEndpoints = this.managesVpcEndpoints;
    final networkLoadBalancerArns = this.networkLoadBalancerArns;
    final privateDnsName = this.privateDnsName;
    final serviceId = this.serviceId;
    final serviceName = this.serviceName;
    final serviceState = this.serviceState;
    final serviceType = this.serviceType;
    return {
      if (acceptanceRequired != null) 'AcceptanceRequired': acceptanceRequired,
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (baseEndpointDnsNames != null)
        'BaseEndpointDnsNames': baseEndpointDnsNames,
      if (gatewayLoadBalancerArns != null)
        'GatewayLoadBalancerArns': gatewayLoadBalancerArns,
      if (managesVpcEndpoints != null)
        'ManagesVpcEndpoints': managesVpcEndpoints,
      if (networkLoadBalancerArns != null)
        'NetworkLoadBalancerArns': networkLoadBalancerArns,
      if (privateDnsName != null) 'PrivateDnsName': privateDnsName,
      if (serviceId != null) 'ServiceId': serviceId,
      if (serviceName != null) 'ServiceName': serviceName,
      if (serviceState != null) 'ServiceState': serviceState,
      if (serviceType != null) 'ServiceType': serviceType,
    };
  }
}

/// The service type information for a VPC endpoint service.
class AwsEc2VpcEndpointServiceServiceTypeDetails {
  /// The type of service.
  final String? serviceType;

  AwsEc2VpcEndpointServiceServiceTypeDetails({
    this.serviceType,
  });

  factory AwsEc2VpcEndpointServiceServiceTypeDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpcEndpointServiceServiceTypeDetails(
      serviceType: json['ServiceType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final serviceType = this.serviceType;
    return {
      if (serviceType != null) 'ServiceType': serviceType,
    };
  }
}

/// Provides information about a VPC peering connection between two VPCs: a
/// requester VPC that you own and an accepter VPC with which to create the
/// connection.
class AwsEc2VpcPeeringConnectionDetails {
  /// Information about the accepter VPC.
  final AwsEc2VpcPeeringConnectionVpcInfoDetails? accepterVpcInfo;

  /// The time at which an unaccepted VPC peering connection will expire.
  final String? expirationTime;

  /// Information about the requester VPC.
  final AwsEc2VpcPeeringConnectionVpcInfoDetails? requesterVpcInfo;

  /// The status of the VPC peering connection.
  final AwsEc2VpcPeeringConnectionStatusDetails? status;

  /// The ID of the VPC peering connection.
  final String? vpcPeeringConnectionId;

  AwsEc2VpcPeeringConnectionDetails({
    this.accepterVpcInfo,
    this.expirationTime,
    this.requesterVpcInfo,
    this.status,
    this.vpcPeeringConnectionId,
  });

  factory AwsEc2VpcPeeringConnectionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpcPeeringConnectionDetails(
      accepterVpcInfo: json['AccepterVpcInfo'] != null
          ? AwsEc2VpcPeeringConnectionVpcInfoDetails.fromJson(
              json['AccepterVpcInfo'] as Map<String, dynamic>)
          : null,
      expirationTime: json['ExpirationTime'] as String?,
      requesterVpcInfo: json['RequesterVpcInfo'] != null
          ? AwsEc2VpcPeeringConnectionVpcInfoDetails.fromJson(
              json['RequesterVpcInfo'] as Map<String, dynamic>)
          : null,
      status: json['Status'] != null
          ? AwsEc2VpcPeeringConnectionStatusDetails.fromJson(
              json['Status'] as Map<String, dynamic>)
          : null,
      vpcPeeringConnectionId: json['VpcPeeringConnectionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accepterVpcInfo = this.accepterVpcInfo;
    final expirationTime = this.expirationTime;
    final requesterVpcInfo = this.requesterVpcInfo;
    final status = this.status;
    final vpcPeeringConnectionId = this.vpcPeeringConnectionId;
    return {
      if (accepterVpcInfo != null) 'AccepterVpcInfo': accepterVpcInfo,
      if (expirationTime != null) 'ExpirationTime': expirationTime,
      if (requesterVpcInfo != null) 'RequesterVpcInfo': requesterVpcInfo,
      if (status != null) 'Status': status,
      if (vpcPeeringConnectionId != null)
        'VpcPeeringConnectionId': vpcPeeringConnectionId,
    };
  }
}

/// Details about the status of the VPC peering connection.
class AwsEc2VpcPeeringConnectionStatusDetails {
  /// The status of the VPC peering connection.
  final String? code;

  /// A message that provides more information about the status, if applicable.
  final String? message;

  AwsEc2VpcPeeringConnectionStatusDetails({
    this.code,
    this.message,
  });

  factory AwsEc2VpcPeeringConnectionStatusDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpcPeeringConnectionStatusDetails(
      code: json['Code'] as String?,
      message: json['Message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final code = this.code;
    final message = this.message;
    return {
      if (code != null) 'Code': code,
      if (message != null) 'Message': message,
    };
  }
}

/// Describes a VPC in a VPC peering connection.
class AwsEc2VpcPeeringConnectionVpcInfoDetails {
  /// The IPv4 CIDR block for the VPC.
  final String? cidrBlock;

  /// Information about the IPv4 CIDR blocks for the VPC.
  final List<VpcInfoCidrBlockSetDetails>? cidrBlockSet;

  /// The IPv6 CIDR block for the VPC.
  final List<VpcInfoIpv6CidrBlockSetDetails>? ipv6CidrBlockSet;

  /// The ID of the Amazon Web Services account that owns the VPC.
  final String? ownerId;

  /// Information about the VPC peering connection options for the accepter or
  /// requester VPC.
  final VpcInfoPeeringOptionsDetails? peeringOptions;

  /// The Amazon Web Services Region in which the VPC is located.
  final String? region;

  /// The ID of the VPC.
  final String? vpcId;

  AwsEc2VpcPeeringConnectionVpcInfoDetails({
    this.cidrBlock,
    this.cidrBlockSet,
    this.ipv6CidrBlockSet,
    this.ownerId,
    this.peeringOptions,
    this.region,
    this.vpcId,
  });

  factory AwsEc2VpcPeeringConnectionVpcInfoDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpcPeeringConnectionVpcInfoDetails(
      cidrBlock: json['CidrBlock'] as String?,
      cidrBlockSet: (json['CidrBlockSet'] as List?)
          ?.whereNotNull()
          .map((e) =>
              VpcInfoCidrBlockSetDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      ipv6CidrBlockSet: (json['Ipv6CidrBlockSet'] as List?)
          ?.whereNotNull()
          .map((e) => VpcInfoIpv6CidrBlockSetDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ownerId: json['OwnerId'] as String?,
      peeringOptions: json['PeeringOptions'] != null
          ? VpcInfoPeeringOptionsDetails.fromJson(
              json['PeeringOptions'] as Map<String, dynamic>)
          : null,
      region: json['Region'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrBlock = this.cidrBlock;
    final cidrBlockSet = this.cidrBlockSet;
    final ipv6CidrBlockSet = this.ipv6CidrBlockSet;
    final ownerId = this.ownerId;
    final peeringOptions = this.peeringOptions;
    final region = this.region;
    final vpcId = this.vpcId;
    return {
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      if (cidrBlockSet != null) 'CidrBlockSet': cidrBlockSet,
      if (ipv6CidrBlockSet != null) 'Ipv6CidrBlockSet': ipv6CidrBlockSet,
      if (ownerId != null) 'OwnerId': ownerId,
      if (peeringOptions != null) 'PeeringOptions': peeringOptions,
      if (region != null) 'Region': region,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Details about an Amazon EC2 VPN connection.
class AwsEc2VpnConnectionDetails {
  /// The category of the VPN connection. <code>VPN</code> indicates an Amazon Web
  /// Services VPN connection. <code>VPN-Classic</code> indicates an Amazon Web
  /// Services Classic VPN connection.
  final String? category;

  /// The configuration information for the VPN connection's customer gateway, in
  /// the native XML format.
  final String? customerGatewayConfiguration;

  /// The identifier of the customer gateway that is at your end of the VPN
  /// connection.
  final String? customerGatewayId;

  /// The VPN connection options.
  final AwsEc2VpnConnectionOptionsDetails? options;

  /// The static routes that are associated with the VPN connection.
  final List<AwsEc2VpnConnectionRoutesDetails>? routes;

  /// The current state of the VPN connection. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>available</code>
  /// </li>
  /// <li>
  /// <code>deleted</code>
  /// </li>
  /// <li>
  /// <code>deleting</code>
  /// </li>
  /// <li>
  /// <code>pending</code>
  /// </li>
  /// </ul>
  final String? state;

  /// The identifier of the transit gateway that is associated with the VPN
  /// connection.
  final String? transitGatewayId;

  /// The type of VPN connection.
  final String? type;

  /// Information about the VPN tunnel.
  final List<AwsEc2VpnConnectionVgwTelemetryDetails>? vgwTelemetry;

  /// The identifier of the VPN connection.
  final String? vpnConnectionId;

  /// The identifier of the virtual private gateway that is at the Amazon Web
  /// Services side of the VPN connection.
  final String? vpnGatewayId;

  AwsEc2VpnConnectionDetails({
    this.category,
    this.customerGatewayConfiguration,
    this.customerGatewayId,
    this.options,
    this.routes,
    this.state,
    this.transitGatewayId,
    this.type,
    this.vgwTelemetry,
    this.vpnConnectionId,
    this.vpnGatewayId,
  });

  factory AwsEc2VpnConnectionDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2VpnConnectionDetails(
      category: json['Category'] as String?,
      customerGatewayConfiguration:
          json['CustomerGatewayConfiguration'] as String?,
      customerGatewayId: json['CustomerGatewayId'] as String?,
      options: json['Options'] != null
          ? AwsEc2VpnConnectionOptionsDetails.fromJson(
              json['Options'] as Map<String, dynamic>)
          : null,
      routes: (json['Routes'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2VpnConnectionRoutesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      state: json['State'] as String?,
      transitGatewayId: json['TransitGatewayId'] as String?,
      type: json['Type'] as String?,
      vgwTelemetry: (json['VgwTelemetry'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2VpnConnectionVgwTelemetryDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      vpnConnectionId: json['VpnConnectionId'] as String?,
      vpnGatewayId: json['VpnGatewayId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final customerGatewayConfiguration = this.customerGatewayConfiguration;
    final customerGatewayId = this.customerGatewayId;
    final options = this.options;
    final routes = this.routes;
    final state = this.state;
    final transitGatewayId = this.transitGatewayId;
    final type = this.type;
    final vgwTelemetry = this.vgwTelemetry;
    final vpnConnectionId = this.vpnConnectionId;
    final vpnGatewayId = this.vpnGatewayId;
    return {
      if (category != null) 'Category': category,
      if (customerGatewayConfiguration != null)
        'CustomerGatewayConfiguration': customerGatewayConfiguration,
      if (customerGatewayId != null) 'CustomerGatewayId': customerGatewayId,
      if (options != null) 'Options': options,
      if (routes != null) 'Routes': routes,
      if (state != null) 'State': state,
      if (transitGatewayId != null) 'TransitGatewayId': transitGatewayId,
      if (type != null) 'Type': type,
      if (vgwTelemetry != null) 'VgwTelemetry': vgwTelemetry,
      if (vpnConnectionId != null) 'VpnConnectionId': vpnConnectionId,
      if (vpnGatewayId != null) 'VpnGatewayId': vpnGatewayId,
    };
  }
}

/// VPN connection options.
class AwsEc2VpnConnectionOptionsDetails {
  /// Whether the VPN connection uses static routes only.
  final bool? staticRoutesOnly;

  /// The VPN tunnel options.
  final List<AwsEc2VpnConnectionOptionsTunnelOptionsDetails>? tunnelOptions;

  AwsEc2VpnConnectionOptionsDetails({
    this.staticRoutesOnly,
    this.tunnelOptions,
  });

  factory AwsEc2VpnConnectionOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpnConnectionOptionsDetails(
      staticRoutesOnly: json['StaticRoutesOnly'] as bool?,
      tunnelOptions: (json['TunnelOptions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEc2VpnConnectionOptionsTunnelOptionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final staticRoutesOnly = this.staticRoutesOnly;
    final tunnelOptions = this.tunnelOptions;
    return {
      if (staticRoutesOnly != null) 'StaticRoutesOnly': staticRoutesOnly,
      if (tunnelOptions != null) 'TunnelOptions': tunnelOptions,
    };
  }
}

/// The VPN tunnel options.
class AwsEc2VpnConnectionOptionsTunnelOptionsDetails {
  /// The number of seconds after which a Dead Peer Detection (DPD) timeout
  /// occurs.
  final int? dpdTimeoutSeconds;

  /// The Internet Key Exchange (IKE) versions that are permitted for the VPN
  /// tunnel.
  final List<String>? ikeVersions;

  /// The external IP address of the VPN tunnel.
  final String? outsideIpAddress;

  /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1
  /// IKE negotiations.
  final List<int>? phase1DhGroupNumbers;

  /// The permitted encryption algorithms for the VPN tunnel for phase 1 IKE
  /// negotiations.
  final List<String>? phase1EncryptionAlgorithms;

  /// The permitted integrity algorithms for the VPN tunnel for phase 1 IKE
  /// negotiations.
  final List<String>? phase1IntegrityAlgorithms;

  /// The lifetime for phase 1 of the IKE negotiation, in seconds.
  final int? phase1LifetimeSeconds;

  /// The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2
  /// IKE negotiations.
  final List<int>? phase2DhGroupNumbers;

  /// The permitted encryption algorithms for the VPN tunnel for phase 2 IKE
  /// negotiations.
  final List<String>? phase2EncryptionAlgorithms;

  /// The permitted integrity algorithms for the VPN tunnel for phase 2 IKE
  /// negotiations.
  final List<String>? phase2IntegrityAlgorithms;

  /// The lifetime for phase 2 of the IKE negotiation, in seconds.
  final int? phase2LifetimeSeconds;

  /// The preshared key to establish initial authentication between the virtual
  /// private gateway and the customer gateway.
  final String? preSharedKey;

  /// The percentage of the rekey window, which is determined by
  /// <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly
  /// selected.
  final int? rekeyFuzzPercentage;

  /// The margin time, in seconds, before the phase 2 lifetime expires, during
  /// which the Amazon Web Services side of the VPN connection performs an IKE
  /// rekey.
  final int? rekeyMarginTimeSeconds;

  /// The number of packets in an IKE replay window.
  final int? replayWindowSize;

  /// The range of inside IPv4 addresses for the tunnel.
  final String? tunnelInsideCidr;

  AwsEc2VpnConnectionOptionsTunnelOptionsDetails({
    this.dpdTimeoutSeconds,
    this.ikeVersions,
    this.outsideIpAddress,
    this.phase1DhGroupNumbers,
    this.phase1EncryptionAlgorithms,
    this.phase1IntegrityAlgorithms,
    this.phase1LifetimeSeconds,
    this.phase2DhGroupNumbers,
    this.phase2EncryptionAlgorithms,
    this.phase2IntegrityAlgorithms,
    this.phase2LifetimeSeconds,
    this.preSharedKey,
    this.rekeyFuzzPercentage,
    this.rekeyMarginTimeSeconds,
    this.replayWindowSize,
    this.tunnelInsideCidr,
  });

  factory AwsEc2VpnConnectionOptionsTunnelOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpnConnectionOptionsTunnelOptionsDetails(
      dpdTimeoutSeconds: json['DpdTimeoutSeconds'] as int?,
      ikeVersions: (json['IkeVersions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      outsideIpAddress: json['OutsideIpAddress'] as String?,
      phase1DhGroupNumbers: (json['Phase1DhGroupNumbers'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      phase1EncryptionAlgorithms: (json['Phase1EncryptionAlgorithms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      phase1IntegrityAlgorithms: (json['Phase1IntegrityAlgorithms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      phase1LifetimeSeconds: json['Phase1LifetimeSeconds'] as int?,
      phase2DhGroupNumbers: (json['Phase2DhGroupNumbers'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      phase2EncryptionAlgorithms: (json['Phase2EncryptionAlgorithms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      phase2IntegrityAlgorithms: (json['Phase2IntegrityAlgorithms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      phase2LifetimeSeconds: json['Phase2LifetimeSeconds'] as int?,
      preSharedKey: json['PreSharedKey'] as String?,
      rekeyFuzzPercentage: json['RekeyFuzzPercentage'] as int?,
      rekeyMarginTimeSeconds: json['RekeyMarginTimeSeconds'] as int?,
      replayWindowSize: json['ReplayWindowSize'] as int?,
      tunnelInsideCidr: json['TunnelInsideCidr'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dpdTimeoutSeconds = this.dpdTimeoutSeconds;
    final ikeVersions = this.ikeVersions;
    final outsideIpAddress = this.outsideIpAddress;
    final phase1DhGroupNumbers = this.phase1DhGroupNumbers;
    final phase1EncryptionAlgorithms = this.phase1EncryptionAlgorithms;
    final phase1IntegrityAlgorithms = this.phase1IntegrityAlgorithms;
    final phase1LifetimeSeconds = this.phase1LifetimeSeconds;
    final phase2DhGroupNumbers = this.phase2DhGroupNumbers;
    final phase2EncryptionAlgorithms = this.phase2EncryptionAlgorithms;
    final phase2IntegrityAlgorithms = this.phase2IntegrityAlgorithms;
    final phase2LifetimeSeconds = this.phase2LifetimeSeconds;
    final preSharedKey = this.preSharedKey;
    final rekeyFuzzPercentage = this.rekeyFuzzPercentage;
    final rekeyMarginTimeSeconds = this.rekeyMarginTimeSeconds;
    final replayWindowSize = this.replayWindowSize;
    final tunnelInsideCidr = this.tunnelInsideCidr;
    return {
      if (dpdTimeoutSeconds != null) 'DpdTimeoutSeconds': dpdTimeoutSeconds,
      if (ikeVersions != null) 'IkeVersions': ikeVersions,
      if (outsideIpAddress != null) 'OutsideIpAddress': outsideIpAddress,
      if (phase1DhGroupNumbers != null)
        'Phase1DhGroupNumbers': phase1DhGroupNumbers,
      if (phase1EncryptionAlgorithms != null)
        'Phase1EncryptionAlgorithms': phase1EncryptionAlgorithms,
      if (phase1IntegrityAlgorithms != null)
        'Phase1IntegrityAlgorithms': phase1IntegrityAlgorithms,
      if (phase1LifetimeSeconds != null)
        'Phase1LifetimeSeconds': phase1LifetimeSeconds,
      if (phase2DhGroupNumbers != null)
        'Phase2DhGroupNumbers': phase2DhGroupNumbers,
      if (phase2EncryptionAlgorithms != null)
        'Phase2EncryptionAlgorithms': phase2EncryptionAlgorithms,
      if (phase2IntegrityAlgorithms != null)
        'Phase2IntegrityAlgorithms': phase2IntegrityAlgorithms,
      if (phase2LifetimeSeconds != null)
        'Phase2LifetimeSeconds': phase2LifetimeSeconds,
      if (preSharedKey != null) 'PreSharedKey': preSharedKey,
      if (rekeyFuzzPercentage != null)
        'RekeyFuzzPercentage': rekeyFuzzPercentage,
      if (rekeyMarginTimeSeconds != null)
        'RekeyMarginTimeSeconds': rekeyMarginTimeSeconds,
      if (replayWindowSize != null) 'ReplayWindowSize': replayWindowSize,
      if (tunnelInsideCidr != null) 'TunnelInsideCidr': tunnelInsideCidr,
    };
  }
}

/// A static routes associated with the VPN connection.
class AwsEc2VpnConnectionRoutesDetails {
  /// The CIDR block associated with the local subnet of the customer data center.
  final String? destinationCidrBlock;

  /// The current state of the static route.
  final String? state;

  AwsEc2VpnConnectionRoutesDetails({
    this.destinationCidrBlock,
    this.state,
  });

  factory AwsEc2VpnConnectionRoutesDetails.fromJson(Map<String, dynamic> json) {
    return AwsEc2VpnConnectionRoutesDetails(
      destinationCidrBlock: json['DestinationCidrBlock'] as String?,
      state: json['State'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destinationCidrBlock = this.destinationCidrBlock;
    final state = this.state;
    return {
      if (destinationCidrBlock != null)
        'DestinationCidrBlock': destinationCidrBlock,
      if (state != null) 'State': state,
    };
  }
}

/// Information about the VPN tunnel.
class AwsEc2VpnConnectionVgwTelemetryDetails {
  /// The number of accepted routes.
  final int? acceptedRouteCount;

  /// The ARN of the VPN tunnel endpoint certificate.
  final String? certificateArn;

  /// The date and time of the last change in status.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastStatusChange;

  /// The Internet-routable IP address of the virtual private gateway's outside
  /// interface.
  final String? outsideIpAddress;

  /// The status of the VPN tunnel. Valid values are <code>DOWN</code> or
  /// <code>UP</code>.
  final String? status;

  /// If an error occurs, a description of the error.
  final String? statusMessage;

  AwsEc2VpnConnectionVgwTelemetryDetails({
    this.acceptedRouteCount,
    this.certificateArn,
    this.lastStatusChange,
    this.outsideIpAddress,
    this.status,
    this.statusMessage,
  });

  factory AwsEc2VpnConnectionVgwTelemetryDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEc2VpnConnectionVgwTelemetryDetails(
      acceptedRouteCount: json['AcceptedRouteCount'] as int?,
      certificateArn: json['CertificateArn'] as String?,
      lastStatusChange: json['LastStatusChange'] as String?,
      outsideIpAddress: json['OutsideIpAddress'] as String?,
      status: json['Status'] as String?,
      statusMessage: json['StatusMessage'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final acceptedRouteCount = this.acceptedRouteCount;
    final certificateArn = this.certificateArn;
    final lastStatusChange = this.lastStatusChange;
    final outsideIpAddress = this.outsideIpAddress;
    final status = this.status;
    final statusMessage = this.statusMessage;
    return {
      if (acceptedRouteCount != null) 'AcceptedRouteCount': acceptedRouteCount,
      if (certificateArn != null) 'CertificateArn': certificateArn,
      if (lastStatusChange != null) 'LastStatusChange': lastStatusChange,
      if (outsideIpAddress != null) 'OutsideIpAddress': outsideIpAddress,
      if (status != null) 'Status': status,
      if (statusMessage != null) 'StatusMessage': statusMessage,
    };
  }
}

/// Information about an Amazon ECR image.
class AwsEcrContainerImageDetails {
  /// The architecture of the image. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>arm64</code>
  /// </li>
  /// <li>
  /// <code>i386</code>
  /// </li>
  /// <li>
  /// <code>x86_64</code>
  /// </li>
  /// </ul>
  final String? architecture;

  /// The sha256 digest of the image manifest.
  final String? imageDigest;

  /// The date and time when the image was pushed to the repository.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? imagePublishedAt;

  /// The list of tags that are associated with the image.
  final List<String>? imageTags;

  /// The Amazon Web Services account identifier that is associated with the
  /// registry that the image belongs to.
  final String? registryId;

  /// The name of the repository that the image belongs to.
  final String? repositoryName;

  AwsEcrContainerImageDetails({
    this.architecture,
    this.imageDigest,
    this.imagePublishedAt,
    this.imageTags,
    this.registryId,
    this.repositoryName,
  });

  factory AwsEcrContainerImageDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcrContainerImageDetails(
      architecture: json['Architecture'] as String?,
      imageDigest: json['ImageDigest'] as String?,
      imagePublishedAt: json['ImagePublishedAt'] as String?,
      imageTags: (json['ImageTags'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      registryId: json['RegistryId'] as String?,
      repositoryName: json['RepositoryName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final architecture = this.architecture;
    final imageDigest = this.imageDigest;
    final imagePublishedAt = this.imagePublishedAt;
    final imageTags = this.imageTags;
    final registryId = this.registryId;
    final repositoryName = this.repositoryName;
    return {
      if (architecture != null) 'Architecture': architecture,
      if (imageDigest != null) 'ImageDigest': imageDigest,
      if (imagePublishedAt != null) 'ImagePublishedAt': imagePublishedAt,
      if (imageTags != null) 'ImageTags': imageTags,
      if (registryId != null) 'RegistryId': registryId,
      if (repositoryName != null) 'RepositoryName': repositoryName,
    };
  }
}

/// Provides information about an Amazon Elastic Container Registry repository.
class AwsEcrRepositoryDetails {
  /// The ARN of the repository.
  final String? arn;

  /// The image scanning configuration for a repository.
  final AwsEcrRepositoryImageScanningConfigurationDetails?
      imageScanningConfiguration;

  /// The tag mutability setting for the repository. Valid values are
  /// <code>IMMUTABLE</code> or <code>MUTABLE</code>.
  final String? imageTagMutability;

  /// Information about the lifecycle policy for the repository.
  final AwsEcrRepositoryLifecyclePolicyDetails? lifecyclePolicy;

  /// The name of the repository.
  final String? repositoryName;

  /// The text of the repository policy.
  final String? repositoryPolicyText;

  AwsEcrRepositoryDetails({
    this.arn,
    this.imageScanningConfiguration,
    this.imageTagMutability,
    this.lifecyclePolicy,
    this.repositoryName,
    this.repositoryPolicyText,
  });

  factory AwsEcrRepositoryDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcrRepositoryDetails(
      arn: json['Arn'] as String?,
      imageScanningConfiguration: json['ImageScanningConfiguration'] != null
          ? AwsEcrRepositoryImageScanningConfigurationDetails.fromJson(
              json['ImageScanningConfiguration'] as Map<String, dynamic>)
          : null,
      imageTagMutability: json['ImageTagMutability'] as String?,
      lifecyclePolicy: json['LifecyclePolicy'] != null
          ? AwsEcrRepositoryLifecyclePolicyDetails.fromJson(
              json['LifecyclePolicy'] as Map<String, dynamic>)
          : null,
      repositoryName: json['RepositoryName'] as String?,
      repositoryPolicyText: json['RepositoryPolicyText'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final imageScanningConfiguration = this.imageScanningConfiguration;
    final imageTagMutability = this.imageTagMutability;
    final lifecyclePolicy = this.lifecyclePolicy;
    final repositoryName = this.repositoryName;
    final repositoryPolicyText = this.repositoryPolicyText;
    return {
      if (arn != null) 'Arn': arn,
      if (imageScanningConfiguration != null)
        'ImageScanningConfiguration': imageScanningConfiguration,
      if (imageTagMutability != null) 'ImageTagMutability': imageTagMutability,
      if (lifecyclePolicy != null) 'LifecyclePolicy': lifecyclePolicy,
      if (repositoryName != null) 'RepositoryName': repositoryName,
      if (repositoryPolicyText != null)
        'RepositoryPolicyText': repositoryPolicyText,
    };
  }
}

/// The image scanning configuration for a repository.
class AwsEcrRepositoryImageScanningConfigurationDetails {
  /// Whether to scan images after they are pushed to a repository.
  final bool? scanOnPush;

  AwsEcrRepositoryImageScanningConfigurationDetails({
    this.scanOnPush,
  });

  factory AwsEcrRepositoryImageScanningConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcrRepositoryImageScanningConfigurationDetails(
      scanOnPush: json['ScanOnPush'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final scanOnPush = this.scanOnPush;
    return {
      if (scanOnPush != null) 'ScanOnPush': scanOnPush,
    };
  }
}

/// Information about the lifecycle policy for the repository.
class AwsEcrRepositoryLifecyclePolicyDetails {
  /// The text of the lifecycle policy.
  final String? lifecyclePolicyText;

  /// The Amazon Web Services account identifier that is associated with the
  /// registry that contains the repository.
  final String? registryId;

  AwsEcrRepositoryLifecyclePolicyDetails({
    this.lifecyclePolicyText,
    this.registryId,
  });

  factory AwsEcrRepositoryLifecyclePolicyDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcrRepositoryLifecyclePolicyDetails(
      lifecyclePolicyText: json['LifecyclePolicyText'] as String?,
      registryId: json['RegistryId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lifecyclePolicyText = this.lifecyclePolicyText;
    final registryId = this.registryId;
    return {
      if (lifecyclePolicyText != null)
        'LifecyclePolicyText': lifecyclePolicyText,
      if (registryId != null) 'RegistryId': registryId,
    };
  }
}

/// Indicates whether to enable CloudWatch Container Insights for the ECS
/// cluster.
class AwsEcsClusterClusterSettingsDetails {
  /// The name of the setting. The valid value is <code>containerInsights</code>.
  final String? name;

  /// The value of the setting. Valid values are <code>disabled</code> or
  /// <code>enabled</code>.
  final String? value;

  AwsEcsClusterClusterSettingsDetails({
    this.name,
    this.value,
  });

  factory AwsEcsClusterClusterSettingsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsClusterClusterSettingsDetails(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// The run command configuration for the cluster.
class AwsEcsClusterConfigurationDetails {
  /// Contains the run command configuration for the cluster.
  final AwsEcsClusterConfigurationExecuteCommandConfigurationDetails?
      executeCommandConfiguration;

  AwsEcsClusterConfigurationDetails({
    this.executeCommandConfiguration,
  });

  factory AwsEcsClusterConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsClusterConfigurationDetails(
      executeCommandConfiguration: json['ExecuteCommandConfiguration'] != null
          ? AwsEcsClusterConfigurationExecuteCommandConfigurationDetails
              .fromJson(
                  json['ExecuteCommandConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final executeCommandConfiguration = this.executeCommandConfiguration;
    return {
      if (executeCommandConfiguration != null)
        'ExecuteCommandConfiguration': executeCommandConfiguration,
    };
  }
}

/// Contains the run command configuration for the cluster.
class AwsEcsClusterConfigurationExecuteCommandConfigurationDetails {
  /// The identifier of the KMS key that is used to encrypt the data between the
  /// local client and the container.
  final String? kmsKeyId;

  /// The log configuration for the results of the run command actions. Required
  /// if <code>Logging</code> is <code>NONE</code>.
  final AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails?
      logConfiguration;

  /// The log setting to use for redirecting logs for run command results.
  final String? logging;

  AwsEcsClusterConfigurationExecuteCommandConfigurationDetails({
    this.kmsKeyId,
    this.logConfiguration,
    this.logging,
  });

  factory AwsEcsClusterConfigurationExecuteCommandConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsClusterConfigurationExecuteCommandConfigurationDetails(
      kmsKeyId: json['KmsKeyId'] as String?,
      logConfiguration: json['LogConfiguration'] != null
          ? AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails
              .fromJson(json['LogConfiguration'] as Map<String, dynamic>)
          : null,
      logging: json['Logging'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final kmsKeyId = this.kmsKeyId;
    final logConfiguration = this.logConfiguration;
    final logging = this.logging;
    return {
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (logConfiguration != null) 'LogConfiguration': logConfiguration,
      if (logging != null) 'Logging': logging,
    };
  }
}

/// The log configuration for the results of the run command actions.
class AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails {
  /// Whether to enable encryption on the CloudWatch logs.
  final bool? cloudWatchEncryptionEnabled;

  /// The name of the CloudWatch log group to send the logs to.
  final String? cloudWatchLogGroupName;

  /// The name of the S3 bucket to send logs to.
  final String? s3BucketName;

  /// Whether to encrypt the logs that are sent to the S3 bucket.
  final bool? s3EncryptionEnabled;

  /// Identifies the folder in the S3 bucket to send the logs to.
  final String? s3KeyPrefix;

  AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails({
    this.cloudWatchEncryptionEnabled,
    this.cloudWatchLogGroupName,
    this.s3BucketName,
    this.s3EncryptionEnabled,
    this.s3KeyPrefix,
  });

  factory AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsClusterConfigurationExecuteCommandConfigurationLogConfigurationDetails(
      cloudWatchEncryptionEnabled: json['CloudWatchEncryptionEnabled'] as bool?,
      cloudWatchLogGroupName: json['CloudWatchLogGroupName'] as String?,
      s3BucketName: json['S3BucketName'] as String?,
      s3EncryptionEnabled: json['S3EncryptionEnabled'] as bool?,
      s3KeyPrefix: json['S3KeyPrefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchEncryptionEnabled = this.cloudWatchEncryptionEnabled;
    final cloudWatchLogGroupName = this.cloudWatchLogGroupName;
    final s3BucketName = this.s3BucketName;
    final s3EncryptionEnabled = this.s3EncryptionEnabled;
    final s3KeyPrefix = this.s3KeyPrefix;
    return {
      if (cloudWatchEncryptionEnabled != null)
        'CloudWatchEncryptionEnabled': cloudWatchEncryptionEnabled,
      if (cloudWatchLogGroupName != null)
        'CloudWatchLogGroupName': cloudWatchLogGroupName,
      if (s3BucketName != null) 'S3BucketName': s3BucketName,
      if (s3EncryptionEnabled != null)
        'S3EncryptionEnabled': s3EncryptionEnabled,
      if (s3KeyPrefix != null) 'S3KeyPrefix': s3KeyPrefix,
    };
  }
}

/// The default capacity provider strategy for the cluster. The default capacity
/// provider strategy is used when services or tasks are run without a specified
/// launch type or capacity provider strategy.
class AwsEcsClusterDefaultCapacityProviderStrategyDetails {
  /// The minimum number of tasks to run on the specified capacity provider.
  final int? base;

  /// The name of the capacity provider.
  final String? capacityProvider;

  /// The relative percentage of the total number of tasks launched that should
  /// use the capacity provider.
  final int? weight;

  AwsEcsClusterDefaultCapacityProviderStrategyDetails({
    this.base,
    this.capacityProvider,
    this.weight,
  });

  factory AwsEcsClusterDefaultCapacityProviderStrategyDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsClusterDefaultCapacityProviderStrategyDetails(
      base: json['Base'] as int?,
      capacityProvider: json['CapacityProvider'] as String?,
      weight: json['Weight'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final base = this.base;
    final capacityProvider = this.capacityProvider;
    final weight = this.weight;
    return {
      if (base != null) 'Base': base,
      if (capacityProvider != null) 'CapacityProvider': capacityProvider,
      if (weight != null) 'Weight': weight,
    };
  }
}

/// Provides details about an Amazon ECS cluster.
class AwsEcsClusterDetails {
  /// The number of services that are running on the cluster in an
  /// <code>ACTIVE</code> state. You can view these services with the Amazon ECS
  /// <a
  /// href="https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_ListServices.html">
  /// <code>ListServices</code> </a> API operation.
  final int? activeServicesCount;

  /// The short name of one or more capacity providers to associate with the
  /// cluster.
  final List<String>? capacityProviders;

  /// The Amazon Resource Name (ARN) that identifies the cluster.
  final String? clusterArn;

  /// A name that you use to identify your cluster.
  final String? clusterName;

  /// The setting to use to create the cluster. Specifically used to configure
  /// whether to enable CloudWatch Container Insights for the cluster.
  final List<AwsEcsClusterClusterSettingsDetails>? clusterSettings;

  /// The run command configuration for the cluster.
  final AwsEcsClusterConfigurationDetails? configuration;

  /// The default capacity provider strategy for the cluster. The default capacity
  /// provider strategy is used when services or tasks are run without a specified
  /// launch type or capacity provider strategy.
  final List<AwsEcsClusterDefaultCapacityProviderStrategyDetails>?
      defaultCapacityProviderStrategy;

  /// The number of container instances registered into the cluster. This includes
  /// container instances in both <code>ACTIVE</code> and <code>DRAINING</code>
  /// status.
  final int? registeredContainerInstancesCount;

  /// The number of tasks in the cluster that are in the <code>RUNNING</code>
  /// state.
  final int? runningTasksCount;

  /// The status of the cluster.
  final String? status;

  AwsEcsClusterDetails({
    this.activeServicesCount,
    this.capacityProviders,
    this.clusterArn,
    this.clusterName,
    this.clusterSettings,
    this.configuration,
    this.defaultCapacityProviderStrategy,
    this.registeredContainerInstancesCount,
    this.runningTasksCount,
    this.status,
  });

  factory AwsEcsClusterDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsClusterDetails(
      activeServicesCount: json['ActiveServicesCount'] as int?,
      capacityProviders: (json['CapacityProviders'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      clusterArn: json['ClusterArn'] as String?,
      clusterName: json['ClusterName'] as String?,
      clusterSettings: (json['ClusterSettings'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsClusterClusterSettingsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      configuration: json['Configuration'] != null
          ? AwsEcsClusterConfigurationDetails.fromJson(
              json['Configuration'] as Map<String, dynamic>)
          : null,
      defaultCapacityProviderStrategy:
          (json['DefaultCapacityProviderStrategy'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  AwsEcsClusterDefaultCapacityProviderStrategyDetails.fromJson(
                      e as Map<String, dynamic>))
              .toList(),
      registeredContainerInstancesCount:
          json['RegisteredContainerInstancesCount'] as int?,
      runningTasksCount: json['RunningTasksCount'] as int?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final activeServicesCount = this.activeServicesCount;
    final capacityProviders = this.capacityProviders;
    final clusterArn = this.clusterArn;
    final clusterName = this.clusterName;
    final clusterSettings = this.clusterSettings;
    final configuration = this.configuration;
    final defaultCapacityProviderStrategy =
        this.defaultCapacityProviderStrategy;
    final registeredContainerInstancesCount =
        this.registeredContainerInstancesCount;
    final runningTasksCount = this.runningTasksCount;
    final status = this.status;
    return {
      if (activeServicesCount != null)
        'ActiveServicesCount': activeServicesCount,
      if (capacityProviders != null) 'CapacityProviders': capacityProviders,
      if (clusterArn != null) 'ClusterArn': clusterArn,
      if (clusterName != null) 'ClusterName': clusterName,
      if (clusterSettings != null) 'ClusterSettings': clusterSettings,
      if (configuration != null) 'Configuration': configuration,
      if (defaultCapacityProviderStrategy != null)
        'DefaultCapacityProviderStrategy': defaultCapacityProviderStrategy,
      if (registeredContainerInstancesCount != null)
        'RegisteredContainerInstancesCount': registeredContainerInstancesCount,
      if (runningTasksCount != null) 'RunningTasksCount': runningTasksCount,
      if (status != null) 'Status': status,
    };
  }
}

/// Provides information about an Amazon ECS container.
class AwsEcsContainerDetails {
  /// The image used for the container.
  final String? image;

  /// The mount points for data volumes in your container.
  final List<AwsMountPoint>? mountPoints;

  /// The name of the container.
  final String? name;

  /// When this parameter is true, the container is given elevated privileges on
  /// the host container instance (similar to the root user).
  final bool? privileged;

  AwsEcsContainerDetails({
    this.image,
    this.mountPoints,
    this.name,
    this.privileged,
  });

  factory AwsEcsContainerDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsContainerDetails(
      image: json['Image'] as String?,
      mountPoints: (json['MountPoints'] as List?)
          ?.whereNotNull()
          .map((e) => AwsMountPoint.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      privileged: json['Privileged'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final image = this.image;
    final mountPoints = this.mountPoints;
    final name = this.name;
    final privileged = this.privileged;
    return {
      if (image != null) 'Image': image,
      if (mountPoints != null) 'MountPoints': mountPoints,
      if (name != null) 'Name': name,
      if (privileged != null) 'Privileged': privileged,
    };
  }
}

/// Strategy item for the capacity provider strategy that the service uses.
class AwsEcsServiceCapacityProviderStrategyDetails {
  /// The minimum number of tasks to run on the capacity provider. Only one
  /// strategy item can specify a value for <code>Base</code>.
  ///
  /// The value must be between 0 and 100000.
  final int? base;

  /// The short name of the capacity provider.
  final String? capacityProvider;

  /// The relative percentage of the total number of tasks that should use the
  /// capacity provider.
  ///
  /// If no weight is specified, the default value is 0. At least one capacity
  /// provider must have a weight greater than 0.
  ///
  /// The value can be between 0 and 1000.
  final int? weight;

  AwsEcsServiceCapacityProviderStrategyDetails({
    this.base,
    this.capacityProvider,
    this.weight,
  });

  factory AwsEcsServiceCapacityProviderStrategyDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceCapacityProviderStrategyDetails(
      base: json['Base'] as int?,
      capacityProvider: json['CapacityProvider'] as String?,
      weight: json['Weight'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final base = this.base;
    final capacityProvider = this.capacityProvider;
    final weight = this.weight;
    return {
      if (base != null) 'Base': base,
      if (capacityProvider != null) 'CapacityProvider': capacityProvider,
      if (weight != null) 'Weight': weight,
    };
  }
}

/// Determines whether a service deployment fails if a service cannot reach a
/// steady state.
class AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails {
  /// Whether to enable the deployment circuit breaker logic for the service.
  final bool? enable;

  /// Whether to roll back the service if a service deployment fails. If rollback
  /// is enabled, when a service deployment fails, the service is rolled back to
  /// the last deployment that completed successfully.
  final bool? rollback;

  AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails({
    this.enable,
    this.rollback,
  });

  factory AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails(
      enable: json['Enable'] as bool?,
      rollback: json['Rollback'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enable = this.enable;
    final rollback = this.rollback;
    return {
      if (enable != null) 'Enable': enable,
      if (rollback != null) 'Rollback': rollback,
    };
  }
}

/// Optional deployment parameters for the service.
class AwsEcsServiceDeploymentConfigurationDetails {
  /// Determines whether a service deployment fails if a service cannot reach a
  /// steady state.
  final AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails?
      deploymentCircuitBreaker;

  /// For a service that uses the rolling update (<code>ECS</code>) deployment
  /// type, the maximum number of tasks in a service that are allowed in the
  /// <code>RUNNING</code> or <code>PENDING</code> state during a deployment, and
  /// for tasks that use the EC2 launch type, when any container instances are in
  /// the <code>DRAINING</code> state. Provided as a percentage of the desired
  /// number of tasks. The default value is 200%.
  ///
  /// For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or
  /// <code>EXTERNAL</code> deployment types, and tasks that use the EC2 launch
  /// type, the maximum number of tasks in the service that remain in the
  /// <code>RUNNING</code> state while the container instances are in the
  /// <code>DRAINING</code> state.
  ///
  /// For the Fargate launch type, the maximum percent value is not used.
  final int? maximumPercent;

  /// For a service that uses the rolling update (<code>ECS</code>) deployment
  /// type, the minimum number of tasks in a service that must remain in the
  /// <code>RUNNING</code> state during a deployment, and while any container
  /// instances are in the <code>DRAINING</code> state if the service contains
  /// tasks using the EC2 launch type. Expressed as a percentage of the desired
  /// number of tasks. The default value is 100%.
  ///
  /// For a service that uses the blue/green (<code>CODE_DEPLOY</code>) or
  /// <code>EXTERNAL</code> deployment types and tasks that use the EC2 launch
  /// type, the minimum number of the tasks in the service that remain in the
  /// <code>RUNNING</code> state while the container instances are in the
  /// <code>DRAINING</code> state.
  ///
  /// For the Fargate launch type, the minimum healthy percent value is not used.
  final int? minimumHealthyPercent;

  AwsEcsServiceDeploymentConfigurationDetails({
    this.deploymentCircuitBreaker,
    this.maximumPercent,
    this.minimumHealthyPercent,
  });

  factory AwsEcsServiceDeploymentConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceDeploymentConfigurationDetails(
      deploymentCircuitBreaker: json['DeploymentCircuitBreaker'] != null
          ? AwsEcsServiceDeploymentConfigurationDeploymentCircuitBreakerDetails
              .fromJson(
                  json['DeploymentCircuitBreaker'] as Map<String, dynamic>)
          : null,
      maximumPercent: json['MaximumPercent'] as int?,
      minimumHealthyPercent: json['MinimumHealthyPercent'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final deploymentCircuitBreaker = this.deploymentCircuitBreaker;
    final maximumPercent = this.maximumPercent;
    final minimumHealthyPercent = this.minimumHealthyPercent;
    return {
      if (deploymentCircuitBreaker != null)
        'DeploymentCircuitBreaker': deploymentCircuitBreaker,
      if (maximumPercent != null) 'MaximumPercent': maximumPercent,
      if (minimumHealthyPercent != null)
        'MinimumHealthyPercent': minimumHealthyPercent,
    };
  }
}

/// Information about the deployment controller type that the service uses.
class AwsEcsServiceDeploymentControllerDetails {
  /// The rolling update (<code>ECS</code>) deployment type replaces the current
  /// running version of the container with the latest version.
  ///
  /// The blue/green (<code>CODE_DEPLOY</code>) deployment type uses the
  /// blue/green deployment model that is powered by CodeDeploy. This deployment
  /// model a new deployment of a service can be verified before production
  /// traffic is sent to it.
  ///
  /// The external (<code>EXTERNAL</code>) deployment type allows the use of any
  /// third-party deployment controller for full control over the deployment
  /// process for an Amazon ECS service.
  ///
  /// Valid values: <code>ECS</code> | <code>CODE_DEPLOY</code> |
  /// <code>EXTERNAL</code>
  final String? type;

  AwsEcsServiceDeploymentControllerDetails({
    this.type,
  });

  factory AwsEcsServiceDeploymentControllerDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceDeploymentControllerDetails(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Provides details about a service within an ECS cluster.
class AwsEcsServiceDetails {
  /// The capacity provider strategy that the service uses.
  final List<AwsEcsServiceCapacityProviderStrategyDetails>?
      capacityProviderStrategy;

  /// The ARN of the cluster that hosts the service.
  final String? cluster;

  /// Deployment parameters for the service. Includes the number of tasks that run
  /// and the order in which to start and stop tasks.
  final AwsEcsServiceDeploymentConfigurationDetails? deploymentConfiguration;

  /// Contains the deployment controller type that the service uses.
  final AwsEcsServiceDeploymentControllerDetails? deploymentController;

  /// The number of instantiations of the task definition to run on the service.
  final int? desiredCount;

  /// Whether to enable Amazon ECS managed tags for the tasks in the service.
  final bool? enableEcsManagedTags;

  /// Whether the execute command functionality is enabled for the service.
  final bool? enableExecuteCommand;

  /// After a task starts, the amount of time in seconds that the Amazon ECS
  /// service scheduler ignores unhealthy Elastic Load Balancing target health
  /// checks.
  final int? healthCheckGracePeriodSeconds;

  /// The launch type that the service uses.
  ///
  /// Valid values: <code>EC2</code> | <code>FARGATE</code> |
  /// <code>EXTERNAL</code>
  final String? launchType;

  /// Information about the load balancers that the service uses.
  final List<AwsEcsServiceLoadBalancersDetails>? loadBalancers;

  /// The name of the service.
  final String? name;

  /// For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet
  /// and security group configuration.
  final AwsEcsServiceNetworkConfigurationDetails? networkConfiguration;

  /// The placement constraints for the tasks in the service.
  final List<AwsEcsServicePlacementConstraintsDetails>? placementConstraints;

  /// Information about how tasks for the service are placed.
  final List<AwsEcsServicePlacementStrategiesDetails>? placementStrategies;

  /// The platform version on which to run the service. Only specified for tasks
  /// that are hosted on Fargate. If a platform version is not specified, the
  /// <code>LATEST</code> platform version is used by default.
  final String? platformVersion;

  /// Indicates whether to propagate the tags from the task definition to the task
  /// or from the service to the task. If no value is provided, then tags are not
  /// propagated.
  ///
  /// Valid values: <code>TASK_DEFINITION</code> | <code>SERVICE</code>
  final String? propagateTags;

  /// The ARN of the IAM role that is associated with the service. The role allows
  /// the Amazon ECS container agent to register container instances with an
  /// Elastic Load Balancing load balancer.
  final String? role;

  /// The scheduling strategy to use for the service.
  ///
  /// The <code>REPLICA</code> scheduling strategy places and maintains the
  /// desired number of tasks across the cluster. By default, the service
  /// scheduler spreads tasks across Availability Zones. Task placement strategies
  /// and constraints are used to customize task placement decisions.
  ///
  /// The <code>DAEMON</code> scheduling strategy deploys exactly one task on each
  /// active container instance that meets all of the task placement constraints
  /// that are specified in the cluster. The service scheduler also evaluates the
  /// task placement constraints for running tasks and stops tasks that do not
  /// meet the placement constraints.
  ///
  /// Valid values: <code>REPLICA</code> | <code>DAEMON</code>
  final String? schedulingStrategy;

  /// The ARN of the service.
  final String? serviceArn;

  /// The name of the service.
  ///
  /// The name can contain up to 255 characters. It can use letters, numbers,
  /// underscores, and hyphens.
  final String? serviceName;

  /// Information about the service discovery registries to assign to the service.
  final List<AwsEcsServiceServiceRegistriesDetails>? serviceRegistries;

  /// The task definition to use for tasks in the service.
  final String? taskDefinition;

  AwsEcsServiceDetails({
    this.capacityProviderStrategy,
    this.cluster,
    this.deploymentConfiguration,
    this.deploymentController,
    this.desiredCount,
    this.enableEcsManagedTags,
    this.enableExecuteCommand,
    this.healthCheckGracePeriodSeconds,
    this.launchType,
    this.loadBalancers,
    this.name,
    this.networkConfiguration,
    this.placementConstraints,
    this.placementStrategies,
    this.platformVersion,
    this.propagateTags,
    this.role,
    this.schedulingStrategy,
    this.serviceArn,
    this.serviceName,
    this.serviceRegistries,
    this.taskDefinition,
  });

  factory AwsEcsServiceDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsServiceDetails(
      capacityProviderStrategy: (json['CapacityProviderStrategy'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsServiceCapacityProviderStrategyDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      cluster: json['Cluster'] as String?,
      deploymentConfiguration: json['DeploymentConfiguration'] != null
          ? AwsEcsServiceDeploymentConfigurationDetails.fromJson(
              json['DeploymentConfiguration'] as Map<String, dynamic>)
          : null,
      deploymentController: json['DeploymentController'] != null
          ? AwsEcsServiceDeploymentControllerDetails.fromJson(
              json['DeploymentController'] as Map<String, dynamic>)
          : null,
      desiredCount: json['DesiredCount'] as int?,
      enableEcsManagedTags: json['EnableEcsManagedTags'] as bool?,
      enableExecuteCommand: json['EnableExecuteCommand'] as bool?,
      healthCheckGracePeriodSeconds:
          json['HealthCheckGracePeriodSeconds'] as int?,
      launchType: json['LaunchType'] as String?,
      loadBalancers: (json['LoadBalancers'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsServiceLoadBalancersDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      networkConfiguration: json['NetworkConfiguration'] != null
          ? AwsEcsServiceNetworkConfigurationDetails.fromJson(
              json['NetworkConfiguration'] as Map<String, dynamic>)
          : null,
      placementConstraints: (json['PlacementConstraints'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsServicePlacementConstraintsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      placementStrategies: (json['PlacementStrategies'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsServicePlacementStrategiesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      platformVersion: json['PlatformVersion'] as String?,
      propagateTags: json['PropagateTags'] as String?,
      role: json['Role'] as String?,
      schedulingStrategy: json['SchedulingStrategy'] as String?,
      serviceArn: json['ServiceArn'] as String?,
      serviceName: json['ServiceName'] as String?,
      serviceRegistries: (json['ServiceRegistries'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsServiceServiceRegistriesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      taskDefinition: json['TaskDefinition'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final capacityProviderStrategy = this.capacityProviderStrategy;
    final cluster = this.cluster;
    final deploymentConfiguration = this.deploymentConfiguration;
    final deploymentController = this.deploymentController;
    final desiredCount = this.desiredCount;
    final enableEcsManagedTags = this.enableEcsManagedTags;
    final enableExecuteCommand = this.enableExecuteCommand;
    final healthCheckGracePeriodSeconds = this.healthCheckGracePeriodSeconds;
    final launchType = this.launchType;
    final loadBalancers = this.loadBalancers;
    final name = this.name;
    final networkConfiguration = this.networkConfiguration;
    final placementConstraints = this.placementConstraints;
    final placementStrategies = this.placementStrategies;
    final platformVersion = this.platformVersion;
    final propagateTags = this.propagateTags;
    final role = this.role;
    final schedulingStrategy = this.schedulingStrategy;
    final serviceArn = this.serviceArn;
    final serviceName = this.serviceName;
    final serviceRegistries = this.serviceRegistries;
    final taskDefinition = this.taskDefinition;
    return {
      if (capacityProviderStrategy != null)
        'CapacityProviderStrategy': capacityProviderStrategy,
      if (cluster != null) 'Cluster': cluster,
      if (deploymentConfiguration != null)
        'DeploymentConfiguration': deploymentConfiguration,
      if (deploymentController != null)
        'DeploymentController': deploymentController,
      if (desiredCount != null) 'DesiredCount': desiredCount,
      if (enableEcsManagedTags != null)
        'EnableEcsManagedTags': enableEcsManagedTags,
      if (enableExecuteCommand != null)
        'EnableExecuteCommand': enableExecuteCommand,
      if (healthCheckGracePeriodSeconds != null)
        'HealthCheckGracePeriodSeconds': healthCheckGracePeriodSeconds,
      if (launchType != null) 'LaunchType': launchType,
      if (loadBalancers != null) 'LoadBalancers': loadBalancers,
      if (name != null) 'Name': name,
      if (networkConfiguration != null)
        'NetworkConfiguration': networkConfiguration,
      if (placementConstraints != null)
        'PlacementConstraints': placementConstraints,
      if (placementStrategies != null)
        'PlacementStrategies': placementStrategies,
      if (platformVersion != null) 'PlatformVersion': platformVersion,
      if (propagateTags != null) 'PropagateTags': propagateTags,
      if (role != null) 'Role': role,
      if (schedulingStrategy != null) 'SchedulingStrategy': schedulingStrategy,
      if (serviceArn != null) 'ServiceArn': serviceArn,
      if (serviceName != null) 'ServiceName': serviceName,
      if (serviceRegistries != null) 'ServiceRegistries': serviceRegistries,
      if (taskDefinition != null) 'TaskDefinition': taskDefinition,
    };
  }
}

/// Information about a load balancer that the service uses.
class AwsEcsServiceLoadBalancersDetails {
  /// The name of the container to associate with the load balancer.
  final String? containerName;

  /// The port on the container to associate with the load balancer. This port
  /// must correspond to a <code>containerPort</code> in the task definition the
  /// tasks in the service are using. For tasks that use the EC2 launch type, the
  /// container instance they are launched on must allow ingress traffic on the
  /// <code>hostPort</code> of the port mapping.
  final int? containerPort;

  /// The name of the load balancer to associate with the Amazon ECS service or
  /// task set.
  ///
  /// Only specified when using a Classic Load Balancer. For an Application Load
  /// Balancer or a Network Load Balancer, the load balancer name is omitted.
  final String? loadBalancerName;

  /// The ARN of the Elastic Load Balancing target group or groups associated with
  /// a service or task set.
  ///
  /// Only specified when using an Application Load Balancer or a Network Load
  /// Balancer. For a Classic Load Balancer, the target group ARN is omitted.
  final String? targetGroupArn;

  AwsEcsServiceLoadBalancersDetails({
    this.containerName,
    this.containerPort,
    this.loadBalancerName,
    this.targetGroupArn,
  });

  factory AwsEcsServiceLoadBalancersDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceLoadBalancersDetails(
      containerName: json['ContainerName'] as String?,
      containerPort: json['ContainerPort'] as int?,
      loadBalancerName: json['LoadBalancerName'] as String?,
      targetGroupArn: json['TargetGroupArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerName = this.containerName;
    final containerPort = this.containerPort;
    final loadBalancerName = this.loadBalancerName;
    final targetGroupArn = this.targetGroupArn;
    return {
      if (containerName != null) 'ContainerName': containerName,
      if (containerPort != null) 'ContainerPort': containerPort,
      if (loadBalancerName != null) 'LoadBalancerName': loadBalancerName,
      if (targetGroupArn != null) 'TargetGroupArn': targetGroupArn,
    };
  }
}

/// For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet
/// and security group configuration.
class AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails {
  /// Whether the task's elastic network interface receives a public IP address.
  /// The default value is <code>DISABLED</code>.
  ///
  /// Valid values: <code>ENABLED</code> | <code>DISABLED</code>
  final String? assignPublicIp;

  /// The IDs of the security groups associated with the task or service.
  ///
  /// You can provide up to five security groups.
  final List<String>? securityGroups;

  /// The IDs of the subnets associated with the task or service.
  ///
  /// You can provide up to 16 subnets.
  final List<String>? subnets;

  AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails({
    this.assignPublicIp,
    this.securityGroups,
    this.subnets,
  });

  factory AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails(
      assignPublicIp: json['AssignPublicIp'] as String?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnets: (json['Subnets'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final assignPublicIp = this.assignPublicIp;
    final securityGroups = this.securityGroups;
    final subnets = this.subnets;
    return {
      if (assignPublicIp != null) 'AssignPublicIp': assignPublicIp,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (subnets != null) 'Subnets': subnets,
    };
  }
}

/// For tasks that use the <code>awsvpc</code> networking mode, the VPC subnet
/// and security group configuration.
class AwsEcsServiceNetworkConfigurationDetails {
  /// The VPC subnet and security group configuration.
  final AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails?
      awsVpcConfiguration;

  AwsEcsServiceNetworkConfigurationDetails({
    this.awsVpcConfiguration,
  });

  factory AwsEcsServiceNetworkConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceNetworkConfigurationDetails(
      awsVpcConfiguration: json['AwsVpcConfiguration'] != null
          ? AwsEcsServiceNetworkConfigurationAwsVpcConfigurationDetails
              .fromJson(json['AwsVpcConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final awsVpcConfiguration = this.awsVpcConfiguration;
    return {
      if (awsVpcConfiguration != null)
        'AwsVpcConfiguration': awsVpcConfiguration,
    };
  }
}

/// A placement constraint for the tasks in the service.
class AwsEcsServicePlacementConstraintsDetails {
  /// A cluster query language expression to apply to the constraint. You cannot
  /// specify an expression if the constraint type is
  /// <code>distinctInstance</code>.
  final String? expression;

  /// The type of constraint. Use <code>distinctInstance</code> to run each task
  /// in a particular group on a different container instance. Use
  /// <code>memberOf</code> to restrict the selection to a group of valid
  /// candidates.
  ///
  /// Valid values: <code>distinctInstance</code> | <code>memberOf</code>
  final String? type;

  AwsEcsServicePlacementConstraintsDetails({
    this.expression,
    this.type,
  });

  factory AwsEcsServicePlacementConstraintsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServicePlacementConstraintsDetails(
      expression: json['Expression'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final type = this.type;
    return {
      if (expression != null) 'Expression': expression,
      if (type != null) 'Type': type,
    };
  }
}

/// A placement strategy that determines how to place the tasks for the service.
class AwsEcsServicePlacementStrategiesDetails {
  /// The field to apply the placement strategy against.
  ///
  /// For the <code>spread</code> placement strategy, valid values are
  /// <code>instanceId</code> (or <code>host</code>, which has the same effect),
  /// or any platform or custom attribute that is applied to a container instance,
  /// such as <code>attribute:ecs.availability-zone</code>.
  ///
  /// For the <code>binpack</code> placement strategy, valid values are
  /// <code>cpu</code> and <code>memory</code>.
  ///
  /// For the <code>random</code> placement strategy, this attribute is not used.
  final String? field;

  /// The type of placement strategy.
  ///
  /// The <code>random</code> placement strategy randomly places tasks on
  /// available candidates.
  ///
  /// The <code>spread</code> placement strategy spreads placement across
  /// available candidates evenly based on the value of <code>Field</code>.
  ///
  /// The <code>binpack</code> strategy places tasks on available candidates that
  /// have the least available amount of the resource that is specified in
  /// <code>Field</code>.
  ///
  /// Valid values: <code>random</code> | <code>spread</code> |
  /// <code>binpack</code>
  final String? type;

  AwsEcsServicePlacementStrategiesDetails({
    this.field,
    this.type,
  });

  factory AwsEcsServicePlacementStrategiesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServicePlacementStrategiesDetails(
      field: json['Field'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final field = this.field;
    final type = this.type;
    return {
      if (field != null) 'Field': field,
      if (type != null) 'Type': type,
    };
  }
}

/// Information about a service discovery registry to assign to the service.
class AwsEcsServiceServiceRegistriesDetails {
  /// The container name value to use for the service discovery service.
  ///
  /// If the task definition uses the <code>bridge</code> or <code>host</code>
  /// network mode, you must specify <code>ContainerName</code> and
  /// <code>ContainerPort</code>.
  ///
  /// If the task definition uses the <code>awsvpc</code> network mode and a type
  /// SRV DNS record, you must specify either <code>ContainerName</code> and
  /// <code>ContainerPort</code>, or <code>Port</code> , but not both.
  final String? containerName;

  /// The port value to use for the service discovery service.
  ///
  /// If the task definition uses the <code>bridge</code> or <code>host</code>
  /// network mode, you must specify <code>ContainerName</code> and
  /// <code>ContainerPort</code>.
  ///
  /// If the task definition uses the <code>awsvpc</code> network mode and a type
  /// SRV DNS record, you must specify either <code>ContainerName</code> and
  /// <code>ContainerPort</code>, or <code>Port</code> , but not both.
  final int? containerPort;

  /// The port value to use for a service discovery service that specifies an SRV
  /// record. This field can be used if both the <code>awsvpc</code>awsvpc network
  /// mode and SRV records are used.
  final int? port;

  /// The ARN of the service registry.
  final String? registryArn;

  AwsEcsServiceServiceRegistriesDetails({
    this.containerName,
    this.containerPort,
    this.port,
    this.registryArn,
  });

  factory AwsEcsServiceServiceRegistriesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsServiceServiceRegistriesDetails(
      containerName: json['ContainerName'] as String?,
      containerPort: json['ContainerPort'] as int?,
      port: json['Port'] as int?,
      registryArn: json['RegistryArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerName = this.containerName;
    final containerPort = this.containerPort;
    final port = this.port;
    final registryArn = this.registryArn;
    return {
      if (containerName != null) 'ContainerName': containerName,
      if (containerPort != null) 'ContainerPort': containerPort,
      if (port != null) 'Port': port,
      if (registryArn != null) 'RegistryArn': registryArn,
    };
  }
}

/// A dependency that is defined for container startup and shutdown.
class AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails {
  /// The dependency condition of the dependent container. Indicates the required
  /// status of the dependent container before the current container can start.
  /// Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>COMPLETE</code>
  /// </li>
  /// <li>
  /// <code>HEALTHY</code>
  /// </li>
  /// <li>
  /// <code>SUCCESS</code>
  /// </li>
  /// <li>
  /// <code>START</code>
  /// </li>
  /// </ul>
  final String? condition;

  /// The name of the dependent container.
  final String? containerName;

  AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails({
    this.condition,
    this.containerName,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails(
      condition: json['Condition'] as String?,
      containerName: json['ContainerName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final condition = this.condition;
    final containerName = this.containerName;
    return {
      if (condition != null) 'Condition': condition,
      if (containerName != null) 'ContainerName': containerName,
    };
  }
}

/// A container definition that describes a container in the task.
class AwsEcsTaskDefinitionContainerDefinitionsDetails {
  /// The command that is passed to the container.
  final List<String>? command;

  /// The number of CPU units reserved for the container.
  final int? cpu;

  /// The dependencies that are defined for container startup and shutdown.
  final List<AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails>?
      dependsOn;

  /// Whether to disable networking within the container.
  final bool? disableNetworking;

  /// A list of DNS search domains that are presented to the container.
  final List<String>? dnsSearchDomains;

  /// A list of DNS servers that are presented to the container.
  final List<String>? dnsServers;

  /// A key-value map of labels to add to the container.
  final Map<String, String>? dockerLabels;

  /// A list of strings to provide custom labels for SELinux and AppArmor
  /// multi-level security systems.
  final List<String>? dockerSecurityOptions;

  /// The entry point that is passed to the container.
  final List<String>? entryPoint;

  /// The environment variables to pass to a container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails>?
      environment;

  /// A list of files containing the environment variables to pass to a container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails>?
      environmentFiles;

  /// Whether the container is essential. All tasks must have at least one
  /// essential container.
  final bool? essential;

  /// A list of hostnames and IP address mappings to append to the
  /// <b>/etc/hosts</b> file on the container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails>?
      extraHosts;

  /// The FireLens configuration for the container. Specifies and configures a log
  /// router for container logs.
  final AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails?
      firelensConfiguration;

  /// The container health check command and associated configuration parameters
  /// for the container.
  final AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails? healthCheck;

  /// The hostname to use for the container.
  final String? hostname;

  /// The image used to start the container.
  final String? image;

  /// If set to true, then containerized applications can be deployed that require
  /// <code>stdin</code> or a <code>tty</code> to be allocated.
  final bool? interactive;

  /// A list of links for the container in the form <code>
  /// <i>container_name</i>:<i>alias</i> </code>. Allows containers to communicate
  /// with each other without the need for port mappings.
  final List<String>? links;

  /// Linux-specific modifications that are applied to the container, such as
  /// Linux kernel capabilities.
  final AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails?
      linuxParameters;

  /// The log configuration specification for the container.
  final AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails?
      logConfiguration;

  /// The amount (in MiB) of memory to present to the container. If the container
  /// attempts to exceed the memory specified here, the container is shut down.
  /// The total amount of memory reserved for all containers within a task must be
  /// lower than the task memory value, if one is specified.
  final int? memory;

  /// The soft limit (in MiB) of memory to reserve for the container.
  final int? memoryReservation;

  /// The mount points for the data volumes in the container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails>?
      mountPoints;

  /// The name of the container.
  final String? name;

  /// The list of port mappings for the container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails>?
      portMappings;

  /// Whether the container is given elevated privileges on the host container
  /// instance. The elevated privileges are similar to the root user.
  final bool? privileged;

  /// Whether to allocate a TTY to the container.
  final bool? pseudoTerminal;

  /// Whether the container is given read-only access to its root file system.
  final bool? readonlyRootFilesystem;

  /// The private repository authentication credentials to use.
  final AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails?
      repositoryCredentials;

  /// The type and amount of a resource to assign to a container. The only
  /// supported resource is a GPU.
  final List<
          AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails>?
      resourceRequirements;

  /// The secrets to pass to the container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails>? secrets;

  /// The number of seconds to wait before giving up on resolving dependencies for
  /// a container.
  final int? startTimeout;

  /// The number of seconds to wait before the container is stopped if it doesn't
  /// shut down normally on its own.
  final int? stopTimeout;

  /// A list of namespaced kernel parameters to set in the container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails>?
      systemControls;

  /// A list of ulimits to set in the container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails>? ulimits;

  /// The user to use inside the container.
  ///
  /// The value can use one of the following formats.
  ///
  /// <ul>
  /// <li>
  /// <code> <i>user</i> </code>
  /// </li>
  /// <li>
  /// <code> <i>user</i> </code>:<code> <i>group</i> </code>
  /// </li>
  /// <li>
  /// <code> <i>uid</i> </code>
  /// </li>
  /// <li>
  /// <code> <i>uid</i> </code>:<code> <i>gid</i> </code>
  /// </li>
  /// <li>
  /// <code> <i>user</i> </code>:<code> <i>gid</i> </code>
  /// </li>
  /// <li>
  /// <code> <i>uid</i> </code>:<code> <i>group</i> </code>
  /// </li>
  /// </ul>
  final String? user;

  /// Data volumes to mount from another container.
  final List<AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails>?
      volumesFrom;

  /// The working directory in which to run commands inside the container.
  final String? workingDirectory;

  AwsEcsTaskDefinitionContainerDefinitionsDetails({
    this.command,
    this.cpu,
    this.dependsOn,
    this.disableNetworking,
    this.dnsSearchDomains,
    this.dnsServers,
    this.dockerLabels,
    this.dockerSecurityOptions,
    this.entryPoint,
    this.environment,
    this.environmentFiles,
    this.essential,
    this.extraHosts,
    this.firelensConfiguration,
    this.healthCheck,
    this.hostname,
    this.image,
    this.interactive,
    this.links,
    this.linuxParameters,
    this.logConfiguration,
    this.memory,
    this.memoryReservation,
    this.mountPoints,
    this.name,
    this.portMappings,
    this.privileged,
    this.pseudoTerminal,
    this.readonlyRootFilesystem,
    this.repositoryCredentials,
    this.resourceRequirements,
    this.secrets,
    this.startTimeout,
    this.stopTimeout,
    this.systemControls,
    this.ulimits,
    this.user,
    this.volumesFrom,
    this.workingDirectory,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsDetails(
      command: (json['Command'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      cpu: json['Cpu'] as int?,
      dependsOn: (json['DependsOn'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsDependsOnDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      disableNetworking: json['DisableNetworking'] as bool?,
      dnsSearchDomains: (json['DnsSearchDomains'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      dnsServers: (json['DnsServers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      dockerLabels: (json['DockerLabels'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      dockerSecurityOptions: (json['DockerSecurityOptions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      entryPoint: (json['EntryPoint'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      environment: (json['Environment'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      environmentFiles: (json['EnvironmentFiles'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      essential: json['Essential'] as bool?,
      extraHosts: (json['ExtraHosts'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      firelensConfiguration: json['FirelensConfiguration'] != null
          ? AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails
              .fromJson(json['FirelensConfiguration'] as Map<String, dynamic>)
          : null,
      healthCheck: json['HealthCheck'] != null
          ? AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails.fromJson(
              json['HealthCheck'] as Map<String, dynamic>)
          : null,
      hostname: json['Hostname'] as String?,
      image: json['Image'] as String?,
      interactive: json['Interactive'] as bool?,
      links: (json['Links'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      linuxParameters: json['LinuxParameters'] != null
          ? AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails
              .fromJson(json['LinuxParameters'] as Map<String, dynamic>)
          : null,
      logConfiguration: json['LogConfiguration'] != null
          ? AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails
              .fromJson(json['LogConfiguration'] as Map<String, dynamic>)
          : null,
      memory: json['Memory'] as int?,
      memoryReservation: json['MemoryReservation'] as int?,
      mountPoints: (json['MountPoints'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      portMappings: (json['PortMappings'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      privileged: json['Privileged'] as bool?,
      pseudoTerminal: json['PseudoTerminal'] as bool?,
      readonlyRootFilesystem: json['ReadonlyRootFilesystem'] as bool?,
      repositoryCredentials: json['RepositoryCredentials'] != null
          ? AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails
              .fromJson(json['RepositoryCredentials'] as Map<String, dynamic>)
          : null,
      resourceRequirements: (json['ResourceRequirements'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      secrets: (json['Secrets'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      startTimeout: json['StartTimeout'] as int?,
      stopTimeout: json['StopTimeout'] as int?,
      systemControls: (json['SystemControls'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      ulimits: (json['Ulimits'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      user: json['User'] as String?,
      volumesFrom: (json['VolumesFrom'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails
              .fromJson(e as Map<String, dynamic>))
          .toList(),
      workingDirectory: json['WorkingDirectory'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final command = this.command;
    final cpu = this.cpu;
    final dependsOn = this.dependsOn;
    final disableNetworking = this.disableNetworking;
    final dnsSearchDomains = this.dnsSearchDomains;
    final dnsServers = this.dnsServers;
    final dockerLabels = this.dockerLabels;
    final dockerSecurityOptions = this.dockerSecurityOptions;
    final entryPoint = this.entryPoint;
    final environment = this.environment;
    final environmentFiles = this.environmentFiles;
    final essential = this.essential;
    final extraHosts = this.extraHosts;
    final firelensConfiguration = this.firelensConfiguration;
    final healthCheck = this.healthCheck;
    final hostname = this.hostname;
    final image = this.image;
    final interactive = this.interactive;
    final links = this.links;
    final linuxParameters = this.linuxParameters;
    final logConfiguration = this.logConfiguration;
    final memory = this.memory;
    final memoryReservation = this.memoryReservation;
    final mountPoints = this.mountPoints;
    final name = this.name;
    final portMappings = this.portMappings;
    final privileged = this.privileged;
    final pseudoTerminal = this.pseudoTerminal;
    final readonlyRootFilesystem = this.readonlyRootFilesystem;
    final repositoryCredentials = this.repositoryCredentials;
    final resourceRequirements = this.resourceRequirements;
    final secrets = this.secrets;
    final startTimeout = this.startTimeout;
    final stopTimeout = this.stopTimeout;
    final systemControls = this.systemControls;
    final ulimits = this.ulimits;
    final user = this.user;
    final volumesFrom = this.volumesFrom;
    final workingDirectory = this.workingDirectory;
    return {
      if (command != null) 'Command': command,
      if (cpu != null) 'Cpu': cpu,
      if (dependsOn != null) 'DependsOn': dependsOn,
      if (disableNetworking != null) 'DisableNetworking': disableNetworking,
      if (dnsSearchDomains != null) 'DnsSearchDomains': dnsSearchDomains,
      if (dnsServers != null) 'DnsServers': dnsServers,
      if (dockerLabels != null) 'DockerLabels': dockerLabels,
      if (dockerSecurityOptions != null)
        'DockerSecurityOptions': dockerSecurityOptions,
      if (entryPoint != null) 'EntryPoint': entryPoint,
      if (environment != null) 'Environment': environment,
      if (environmentFiles != null) 'EnvironmentFiles': environmentFiles,
      if (essential != null) 'Essential': essential,
      if (extraHosts != null) 'ExtraHosts': extraHosts,
      if (firelensConfiguration != null)
        'FirelensConfiguration': firelensConfiguration,
      if (healthCheck != null) 'HealthCheck': healthCheck,
      if (hostname != null) 'Hostname': hostname,
      if (image != null) 'Image': image,
      if (interactive != null) 'Interactive': interactive,
      if (links != null) 'Links': links,
      if (linuxParameters != null) 'LinuxParameters': linuxParameters,
      if (logConfiguration != null) 'LogConfiguration': logConfiguration,
      if (memory != null) 'Memory': memory,
      if (memoryReservation != null) 'MemoryReservation': memoryReservation,
      if (mountPoints != null) 'MountPoints': mountPoints,
      if (name != null) 'Name': name,
      if (portMappings != null) 'PortMappings': portMappings,
      if (privileged != null) 'Privileged': privileged,
      if (pseudoTerminal != null) 'PseudoTerminal': pseudoTerminal,
      if (readonlyRootFilesystem != null)
        'ReadonlyRootFilesystem': readonlyRootFilesystem,
      if (repositoryCredentials != null)
        'RepositoryCredentials': repositoryCredentials,
      if (resourceRequirements != null)
        'ResourceRequirements': resourceRequirements,
      if (secrets != null) 'Secrets': secrets,
      if (startTimeout != null) 'StartTimeout': startTimeout,
      if (stopTimeout != null) 'StopTimeout': stopTimeout,
      if (systemControls != null) 'SystemControls': systemControls,
      if (ulimits != null) 'Ulimits': ulimits,
      if (user != null) 'User': user,
      if (volumesFrom != null) 'VolumesFrom': volumesFrom,
      if (workingDirectory != null) 'WorkingDirectory': workingDirectory,
    };
  }
}

/// An environment variable to pass to the container.
class AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails {
  /// The name of the environment variable.
  final String? name;

  /// The value of the environment variable.
  final String? value;

  AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails({
    this.name,
    this.value,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsEnvironmentDetails(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// A file that contain environment variables to pass to a container.
class AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails {
  /// The type of environment file. The valid value is <code>s3</code>.
  final String? type;

  /// The ARN of the S3 object that contains the environment variable file.
  final String? value;

  AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails({
    this.type,
    this.value,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsEnvironmentFilesDetails(
      type: json['Type'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    final value = this.value;
    return {
      if (type != null) 'Type': type,
      if (value != null) 'Value': value,
    };
  }
}

/// A hostname and IP address mapping to append to the <b>/etc/hosts</b> file on
/// the container.
class AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails {
  /// The hostname to use in the <b>/etc/hosts</b> entry.
  final String? hostname;

  /// The IP address to use in the <b>/etc/hosts</b> entry.
  final String? ipAddress;

  AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails({
    this.hostname,
    this.ipAddress,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsExtraHostsDetails(
      hostname: json['Hostname'] as String?,
      ipAddress: json['IpAddress'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hostname = this.hostname;
    final ipAddress = this.ipAddress;
    return {
      if (hostname != null) 'Hostname': hostname,
      if (ipAddress != null) 'IpAddress': ipAddress,
    };
  }
}

/// The FireLens configuration for the container. The configuration specifies
/// and configures a log router for container logs.
class AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails {
  /// The options to use to configure the log router.
  ///
  /// The valid option keys are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>enable-ecs-log-metadata</code>. The value can be <code>true</code> or
  /// <code>false</code>.
  /// </li>
  /// <li>
  /// <code>config-file-type</code>. The value can be <code>s3</code> or
  /// <code>file</code>.
  /// </li>
  /// <li>
  /// <code>config-file-value</code>. The value is either an S3 ARN or a file
  /// path.
  /// </li>
  /// </ul>
  final Map<String, String>? options;

  /// The log router to use. Valid values are <code>fluentbit</code> or
  /// <code>fluentd</code>.
  final String? type;

  AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails({
    this.options,
    this.type,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsFirelensConfigurationDetails(
      options: (json['Options'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final options = this.options;
    final type = this.type;
    return {
      if (options != null) 'Options': options,
      if (type != null) 'Type': type,
    };
  }
}

/// The container health check command and associated configuration parameters
/// for the container.
class AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails {
  /// The command that the container runs to determine whether it is healthy.
  final List<String>? command;

  /// The time period in seconds between each health check execution. The default
  /// value is 30 seconds.
  final int? interval;

  /// The number of times to retry a failed health check before the container is
  /// considered unhealthy. The default value is 3.
  final int? retries;

  /// The optional grace period in seconds that allows containers time to
  /// bootstrap before failed health checks count towards the maximum number of
  /// retries.
  final int? startPeriod;

  /// The time period in seconds to wait for a health check to succeed before it
  /// is considered a failure. The default value is 5.
  final int? timeout;

  AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails({
    this.command,
    this.interval,
    this.retries,
    this.startPeriod,
    this.timeout,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsHealthCheckDetails(
      command: (json['Command'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      interval: json['Interval'] as int?,
      retries: json['Retries'] as int?,
      startPeriod: json['StartPeriod'] as int?,
      timeout: json['Timeout'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final command = this.command;
    final interval = this.interval;
    final retries = this.retries;
    final startPeriod = this.startPeriod;
    final timeout = this.timeout;
    return {
      if (command != null) 'Command': command,
      if (interval != null) 'Interval': interval,
      if (retries != null) 'Retries': retries,
      if (startPeriod != null) 'StartPeriod': startPeriod,
      if (timeout != null) 'Timeout': timeout,
    };
  }
}

/// The Linux capabilities for the container that are added to or dropped from
/// the default configuration provided by Docker.
class AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails {
  /// The Linux capabilities for the container that are added to the default
  /// configuration provided by Docker. Valid values are as follows:
  ///
  /// Valid values: <code>"ALL"</code> | <code>"AUDIT_CONTROL"</code> |<code>
  /// "AUDIT_WRITE"</code> | <code>"BLOCK_SUSPEND"</code> | <code>"CHOWN"</code> |
  /// <code>"DAC_OVERRIDE"</code> | <code>"DAC_READ_SEARCH"</code> |
  /// <code>"FOWNER"</code> | <code>"FSETID"</code> | <code>"IPC_LOCK"</code> |
  /// <code>"IPC_OWNER"</code> | <code>"KILL"</code> | <code>"LEASE"</code> |
  /// <code>"LINUX_IMMUTABLE"</code> | <code>"MAC_ADMIN"</code> |<code>
  /// "MAC_OVERRIDE"</code> | <code>"MKNOD"</code> | <code>"NET_ADMIN"</code> |
  /// <code>"NET_BIND_SERVICE"</code> | <code>"NET_BROADCAST"</code> |
  /// <code>"NET_RAW"</code> | <code>"SETFCAP"</code> | <code>"SETGID"</code> |
  /// <code>"SETPCAP"</code> | <code>"SETUID"</code> | <code>"SYS_ADMIN"</code> |
  /// <code>"SYS_BOOT"</code> | <code>"SYS_CHROOT"</code> |
  /// <code>"SYS_MODULE"</code> | <code>"SYS_NICE"</code> |
  /// <code>"SYS_PACCT"</code> | <code>"SYS_PTRACE"</code> |
  /// <code>"SYS_RAWIO"</code> | <code>"SYS_RESOURCE"</code> |
  /// <code>"SYS_TIME"</code> | <code>"SYS_TTY_CONFIG"</code> |
  /// <code>"SYSLOG"</code> | <code>"WAKE_ALARM"</code>
  final List<String>? add;

  /// The Linux capabilities for the container that are dropped from the default
  /// configuration provided by Docker.
  ///
  /// Valid values: <code>"ALL"</code> | <code>"AUDIT_CONTROL"</code> |<code>
  /// "AUDIT_WRITE"</code> | <code>"BLOCK_SUSPEND"</code> | <code>"CHOWN"</code> |
  /// <code>"DAC_OVERRIDE"</code> | <code>"DAC_READ_SEARCH"</code> |
  /// <code>"FOWNER"</code> | <code>"FSETID"</code> | <code>"IPC_LOCK"</code> |
  /// <code>"IPC_OWNER"</code> | <code>"KILL"</code> | <code>"LEASE"</code> |
  /// <code>"LINUX_IMMUTABLE"</code> | <code>"MAC_ADMIN"</code> |<code>
  /// "MAC_OVERRIDE"</code> | <code>"MKNOD"</code> | <code>"NET_ADMIN"</code> |
  /// <code>"NET_BIND_SERVICE"</code> | <code>"NET_BROADCAST"</code> |
  /// <code>"NET_RAW"</code> | <code>"SETFCAP"</code> | <code>"SETGID"</code> |
  /// <code>"SETPCAP"</code> | <code>"SETUID"</code> | <code>"SYS_ADMIN"</code> |
  /// <code>"SYS_BOOT"</code> | <code>"SYS_CHROOT"</code> |
  /// <code>"SYS_MODULE"</code> | <code>"SYS_NICE"</code> |
  /// <code>"SYS_PACCT"</code> | <code>"SYS_PTRACE"</code> |
  /// <code>"SYS_RAWIO"</code> | <code>"SYS_RESOURCE"</code> |
  /// <code>"SYS_TIME"</code> | <code>"SYS_TTY_CONFIG"</code> |
  /// <code>"SYSLOG"</code> | <code>"WAKE_ALARM"</code>
  final List<String>? drop;

  AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails({
    this.add,
    this.drop,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails(
      add: (json['Add'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      drop: (json['Drop'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final add = this.add;
    final drop = this.drop;
    return {
      if (add != null) 'Add': add,
      if (drop != null) 'Drop': drop,
    };
  }
}

/// &gt;Linux-specific modifications that are applied to the container, such as
/// Linux kernel capabilities.
class AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails {
  /// The Linux capabilities for the container that are added to or dropped from
  /// the default configuration provided by Docker.
  final AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails?
      capabilities;

  /// The host devices to expose to the container.
  final List<
          AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails>?
      devices;

  /// Whether to run an <code>init</code> process inside the container that
  /// forwards signals and reaps processes.
  final bool? initProcessEnabled;

  /// The total amount of swap memory (in MiB) that a container can use.
  final int? maxSwap;

  /// The value for the size (in MiB) of the <b>/dev/shm</b> volume.
  final int? sharedMemorySize;

  /// Configures the container's memory swappiness behavior. Determines how
  /// aggressively pages are swapped. The higher the value, the more aggressive
  /// the swappiness. The default is 60.
  final int? swappiness;

  /// The container path, mount options, and size (in MiB) of the tmpfs mount.
  final List<
          AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails>?
      tmpfs;

  AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails({
    this.capabilities,
    this.devices,
    this.initProcessEnabled,
    this.maxSwap,
    this.sharedMemorySize,
    this.swappiness,
    this.tmpfs,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDetails(
      capabilities: json['Capabilities'] != null
          ? AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersCapabilitiesDetails
              .fromJson(json['Capabilities'] as Map<String, dynamic>)
          : null,
      devices: (json['Devices'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      initProcessEnabled: json['InitProcessEnabled'] as bool?,
      maxSwap: json['MaxSwap'] as int?,
      sharedMemorySize: json['SharedMemorySize'] as int?,
      swappiness: json['Swappiness'] as int?,
      tmpfs: (json['Tmpfs'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final capabilities = this.capabilities;
    final devices = this.devices;
    final initProcessEnabled = this.initProcessEnabled;
    final maxSwap = this.maxSwap;
    final sharedMemorySize = this.sharedMemorySize;
    final swappiness = this.swappiness;
    final tmpfs = this.tmpfs;
    return {
      if (capabilities != null) 'Capabilities': capabilities,
      if (devices != null) 'Devices': devices,
      if (initProcessEnabled != null) 'InitProcessEnabled': initProcessEnabled,
      if (maxSwap != null) 'MaxSwap': maxSwap,
      if (sharedMemorySize != null) 'SharedMemorySize': sharedMemorySize,
      if (swappiness != null) 'Swappiness': swappiness,
      if (tmpfs != null) 'Tmpfs': tmpfs,
    };
  }
}

/// A host device to expose to the container.
class AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails {
  /// The path inside the container at which to expose the host device.
  final String? containerPath;

  /// The path for the device on the host container instance.
  final String? hostPath;

  /// The explicit permissions to provide to the container for the device. By
  /// default, the container has permissions for read, write, and
  /// <code>mknod</code> for the device.
  final List<String>? permissions;

  AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails({
    this.containerPath,
    this.hostPath,
    this.permissions,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersDevicesDetails(
      containerPath: json['ContainerPath'] as String?,
      hostPath: json['HostPath'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final containerPath = this.containerPath;
    final hostPath = this.hostPath;
    final permissions = this.permissions;
    return {
      if (containerPath != null) 'ContainerPath': containerPath,
      if (hostPath != null) 'HostPath': hostPath,
      if (permissions != null) 'Permissions': permissions,
    };
  }
}

/// The container path, mount options, and size (in MiB) of a tmpfs mount.
class AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails {
  /// The absolute file path where the tmpfs volume is to be mounted.
  final String? containerPath;

  /// The list of tmpfs volume mount options.
  ///
  /// Valid values: <code>"defaults"</code> | <code>"ro"</code> |
  /// <code>"rw"</code> | <code>"suid"</code> | <code>"nosuid"</code> |
  /// <code>"dev"</code> | <code>"nodev"</code> |<code> "exec"</code> |
  /// <code>"noexec"</code> | <code>"sync"</code> | <code>"async"</code> |
  /// <code>"dirsync"</code> | <code>"remount"</code> | <code>"mand"</code> |
  /// <code>"nomand"</code> | <code>"atime"</code> | <code>"noatime"</code> |
  /// <code>"diratime"</code> | <code>"nodiratime"</code> | <code>"bind"</code> |
  /// <code>"rbind"</code> | <code>"unbindable"</code> |
  /// <code>"runbindable"</code> | <code>"private"</code> |
  /// <code>"rprivate"</code> | <code>"shared"</code> | <code>"rshared"</code> |
  /// <code>"slave"</code> | <code>"rslave"</code> | <code>"relatime"</code> |
  /// <code>"norelatime"</code> | <code>"strictatime"</code> |
  /// <code>"nostrictatime"</code> |<code> "mode"</code> | <code>"uid"</code> |
  /// <code>"gid"</code> | <code>"nr_inodes"</code> |<code> "nr_blocks"</code> |
  /// <code>"mpol"</code>
  final List<String>? mountOptions;

  /// The maximum size (in MiB) of the tmpfs volume.
  final int? size;

  AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails({
    this.containerPath,
    this.mountOptions,
    this.size,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsLinuxParametersTmpfsDetails(
      containerPath: json['ContainerPath'] as String?,
      mountOptions: (json['MountOptions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      size: json['Size'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerPath = this.containerPath;
    final mountOptions = this.mountOptions;
    final size = this.size;
    return {
      if (containerPath != null) 'ContainerPath': containerPath,
      if (mountOptions != null) 'MountOptions': mountOptions,
      if (size != null) 'Size': size,
    };
  }
}

/// The log configuration specification for the container.
class AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails {
  /// The log driver to use for the container.
  ///
  /// Valid values on Fargate are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>awsfirelens</code>
  /// </li>
  /// <li>
  /// <code>awslogs</code>
  /// </li>
  /// <li>
  /// <code>splunk</code>
  /// </li>
  /// </ul>
  /// Valid values on Amazon EC2 are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>awsfirelens</code>
  /// </li>
  /// <li>
  /// <code>awslogs</code>
  /// </li>
  /// <li>
  /// <code>fluentd</code>
  /// </li>
  /// <li>
  /// <code>gelf</code>
  /// </li>
  /// <li>
  /// <code>journald</code>
  /// </li>
  /// <li>
  /// <code>json-file</code>
  /// </li>
  /// <li>
  /// <code>logentries</code>
  /// </li>
  /// <li>
  /// <code>splunk</code>
  /// </li>
  /// <li>
  /// <code>syslog</code>
  /// </li>
  /// </ul>
  final String? logDriver;

  /// The configuration options to send to the log driver. Requires version 1.19
  /// of the Docker Remote API or greater on your container instance.
  final Map<String, String>? options;

  /// The secrets to pass to the log configuration.
  final List<
          AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails>?
      secretOptions;

  AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails({
    this.logDriver,
    this.options,
    this.secretOptions,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationDetails(
      logDriver: json['LogDriver'] as String?,
      options: (json['Options'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      secretOptions: (json['SecretOptions'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final logDriver = this.logDriver;
    final options = this.options;
    final secretOptions = this.secretOptions;
    return {
      if (logDriver != null) 'LogDriver': logDriver,
      if (options != null) 'Options': options,
      if (secretOptions != null) 'SecretOptions': secretOptions,
    };
  }
}

/// A secret to pass to the log configuration.
class AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails {
  /// The name of the secret.
  final String? name;

  /// The secret to expose to the container.
  ///
  /// The value is either the full ARN of the Secrets Manager secret or the full
  /// ARN of the parameter in the Systems Manager Parameter Store.
  final String? valueFrom;

  AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails({
    this.name,
    this.valueFrom,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsLogConfigurationSecretOptionsDetails(
      name: json['Name'] as String?,
      valueFrom: json['ValueFrom'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final valueFrom = this.valueFrom;
    return {
      if (name != null) 'Name': name,
      if (valueFrom != null) 'ValueFrom': valueFrom,
    };
  }
}

/// A mount point for the data volumes in the container.
class AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails {
  /// The path on the container to mount the host volume at.
  final String? containerPath;

  /// Whether the container has read-only access to the volume.
  final bool? readOnly;

  /// The name of the volume to mount. Must match the name of a volume listed in
  /// <code>VolumeDetails</code> for the task definition.
  final String? sourceVolume;

  AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails({
    this.containerPath,
    this.readOnly,
    this.sourceVolume,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsMountPointsDetails(
      containerPath: json['ContainerPath'] as String?,
      readOnly: json['ReadOnly'] as bool?,
      sourceVolume: json['SourceVolume'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerPath = this.containerPath;
    final readOnly = this.readOnly;
    final sourceVolume = this.sourceVolume;
    return {
      if (containerPath != null) 'ContainerPath': containerPath,
      if (readOnly != null) 'ReadOnly': readOnly,
      if (sourceVolume != null) 'SourceVolume': sourceVolume,
    };
  }
}

/// A port mapping for the container.
class AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails {
  /// The port number on the container that is bound to the user-specified or
  /// automatically assigned host port.
  final int? containerPort;

  /// The port number on the container instance to reserve for the container.
  final int? hostPort;

  /// The protocol used for the port mapping. The default is <code>tcp</code>.
  final String? protocol;

  AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails({
    this.containerPort,
    this.hostPort,
    this.protocol,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsPortMappingsDetails(
      containerPort: json['ContainerPort'] as int?,
      hostPort: json['HostPort'] as int?,
      protocol: json['Protocol'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerPort = this.containerPort;
    final hostPort = this.hostPort;
    final protocol = this.protocol;
    return {
      if (containerPort != null) 'ContainerPort': containerPort,
      if (hostPort != null) 'HostPort': hostPort,
      if (protocol != null) 'Protocol': protocol,
    };
  }
}

/// The private repository authentication credentials to use.
class AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails {
  /// The ARN of the secret that contains the private repository credentials.
  final String? credentialsParameter;

  AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails({
    this.credentialsParameter,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsRepositoryCredentialsDetails(
      credentialsParameter: json['CredentialsParameter'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final credentialsParameter = this.credentialsParameter;
    return {
      if (credentialsParameter != null)
        'CredentialsParameter': credentialsParameter,
    };
  }
}

/// A resource to assign to a container.
class AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails {
  /// The type of resource to assign to a container. Valid values are
  /// <code>GPU</code> or <code>InferenceAccelerator</code>.
  final String? type;

  /// The value for the specified resource type.
  ///
  /// For <code>GPU</code>, the value is the number of physical GPUs the Amazon
  /// ECS container agent reserves for the container.
  ///
  /// For <code>InferenceAccelerator</code>, the value should match the
  /// <code>DeviceName</code> attribute of an entry in
  /// <code>InferenceAccelerators</code>.
  final String? value;

  AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails({
    this.type,
    this.value,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsResourceRequirementsDetails(
      type: json['Type'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    final value = this.value;
    return {
      if (type != null) 'Type': type,
      if (value != null) 'Value': value,
    };
  }
}

/// A secret to pass to the container.
class AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails {
  /// The name of the secret.
  final String? name;

  /// The secret to expose to the container. The value is either the full ARN of
  /// the Secrets Manager secret or the full ARN of the parameter in the Systems
  /// Manager Parameter Store.
  final String? valueFrom;

  AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails({
    this.name,
    this.valueFrom,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsSecretsDetails(
      name: json['Name'] as String?,
      valueFrom: json['ValueFrom'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final valueFrom = this.valueFrom;
    return {
      if (name != null) 'Name': name,
      if (valueFrom != null) 'ValueFrom': valueFrom,
    };
  }
}

/// A namespaced kernel parameter to set in the container.
class AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails {
  /// The namespaced kernel parameter for which to set a value.
  final String? namespace;

  /// The value of the parameter.
  final String? value;

  AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails({
    this.namespace,
    this.value,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsSystemControlsDetails(
      namespace: json['Namespace'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final namespace = this.namespace;
    final value = this.value;
    return {
      if (namespace != null) 'Namespace': namespace,
      if (value != null) 'Value': value,
    };
  }
}

/// A ulimit to set in the container.
class AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails {
  /// The hard limit for the ulimit type.
  final int? hardLimit;

  /// The type of the ulimit. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>core</code>
  /// </li>
  /// <li>
  /// <code>cpu</code>
  /// </li>
  /// <li>
  /// <code>data</code>
  /// </li>
  /// <li>
  /// <code>fsize</code>
  /// </li>
  /// <li>
  /// <code>locks</code>
  /// </li>
  /// <li>
  /// <code>memlock</code>
  /// </li>
  /// <li>
  /// <code>msgqueue</code>
  /// </li>
  /// <li>
  /// <code>nice</code>
  /// </li>
  /// <li>
  /// <code>nofile</code>
  /// </li>
  /// <li>
  /// <code>nproc</code>
  /// </li>
  /// <li>
  /// <code>rss</code>
  /// </li>
  /// <li>
  /// <code>rtprio</code>
  /// </li>
  /// <li>
  /// <code>rttime</code>
  /// </li>
  /// <li>
  /// <code>sigpending</code>
  /// </li>
  /// <li>
  /// <code>stack</code>
  /// </li>
  /// </ul>
  final String? name;

  /// The soft limit for the ulimit type.
  final int? softLimit;

  AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails({
    this.hardLimit,
    this.name,
    this.softLimit,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsUlimitsDetails(
      hardLimit: json['HardLimit'] as int?,
      name: json['Name'] as String?,
      softLimit: json['SoftLimit'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final hardLimit = this.hardLimit;
    final name = this.name;
    final softLimit = this.softLimit;
    return {
      if (hardLimit != null) 'HardLimit': hardLimit,
      if (name != null) 'Name': name,
      if (softLimit != null) 'SoftLimit': softLimit,
    };
  }
}

/// A data volume to mount from another container.
class AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails {
  /// Whether the container has read-only access to the volume.
  final bool? readOnly;

  /// The name of another container within the same task definition from which to
  /// mount volumes.
  final String? sourceContainer;

  AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails({
    this.readOnly,
    this.sourceContainer,
  });

  factory AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionContainerDefinitionsVolumesFromDetails(
      readOnly: json['ReadOnly'] as bool?,
      sourceContainer: json['SourceContainer'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final readOnly = this.readOnly;
    final sourceContainer = this.sourceContainer;
    return {
      if (readOnly != null) 'ReadOnly': readOnly,
      if (sourceContainer != null) 'SourceContainer': sourceContainer,
    };
  }
}

/// Details about a task definition. A task definition describes the container
/// and volume definitions of an Amazon Elastic Container Service task.
class AwsEcsTaskDefinitionDetails {
  /// The container definitions that describe the containers that make up the
  /// task.
  final List<AwsEcsTaskDefinitionContainerDefinitionsDetails>?
      containerDefinitions;

  /// The number of CPU units used by the task.Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>256 (.25 vCPU)</code>
  /// </li>
  /// <li>
  /// <code>512 (.5 vCPU)</code>
  /// </li>
  /// <li>
  /// <code>1024 (1 vCPU)</code>
  /// </li>
  /// <li>
  /// <code>2048 (2 vCPU)</code>
  /// </li>
  /// <li>
  /// <code>4096 (4 vCPU)</code>
  /// </li>
  /// </ul>
  final String? cpu;

  /// The ARN of the task execution role that grants the container agent
  /// permission to make API calls on behalf of the container user.
  final String? executionRoleArn;

  /// The name of a family that this task definition is registered to.
  final String? family;

  /// The Elastic Inference accelerators to use for the containers in the task.
  final List<AwsEcsTaskDefinitionInferenceAcceleratorsDetails>?
      inferenceAccelerators;

  /// The inter-process communication (IPC) resource namespace to use for the
  /// containers in the task. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>host</code>
  /// </li>
  /// <li>
  /// <code>none</code>
  /// </li>
  /// <li>
  /// <code>task</code>
  /// </li>
  /// </ul>
  final String? ipcMode;

  /// The amount (in MiB) of memory used by the task.
  ///
  /// For tasks that are hosted on Amazon EC2, you can provide a task-level memory
  /// value or a container-level memory value. For tasks that are hosted on
  /// Fargate, you must use one of the <a
  /// href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html#task_size">specified
  /// values</a> in the <i> <i>Amazon Elastic Container Service Developer
  /// Guide</i> </i>, which determines your range of supported values for the
  /// <code>Cpu</code> and <code>Memory</code> parameters.
  final String? memory;

  /// The Docker networking mode to use for the containers in the task. Valid
  /// values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>awsvpc</code>
  /// </li>
  /// <li>
  /// <code>bridge</code>
  /// </li>
  /// <li>
  /// <code>host</code>
  /// </li>
  /// <li>
  /// <code>none</code>
  /// </li>
  /// </ul>
  final String? networkMode;

  /// The process namespace to use for the containers in the task. Valid values
  /// are <code>host</code> or <code>task</code>.
  final String? pidMode;

  /// The placement constraint objects to use for tasks.
  final List<AwsEcsTaskDefinitionPlacementConstraintsDetails>?
      placementConstraints;

  /// The configuration details for the App Mesh proxy.
  final AwsEcsTaskDefinitionProxyConfigurationDetails? proxyConfiguration;

  /// The task launch types that the task definition was validated against.
  final List<String>? requiresCompatibilities;

  /// The status of the task definition.
  final String? status;

  /// The short name or ARN of the IAM role that grants containers in the task
  /// permission to call Amazon Web Services API operations on your behalf.
  final String? taskRoleArn;

  /// The data volume definitions for the task.
  final List<AwsEcsTaskDefinitionVolumesDetails>? volumes;

  AwsEcsTaskDefinitionDetails({
    this.containerDefinitions,
    this.cpu,
    this.executionRoleArn,
    this.family,
    this.inferenceAccelerators,
    this.ipcMode,
    this.memory,
    this.networkMode,
    this.pidMode,
    this.placementConstraints,
    this.proxyConfiguration,
    this.requiresCompatibilities,
    this.status,
    this.taskRoleArn,
    this.volumes,
  });

  factory AwsEcsTaskDefinitionDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionDetails(
      containerDefinitions: (json['ContainerDefinitions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionContainerDefinitionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      cpu: json['Cpu'] as String?,
      executionRoleArn: json['ExecutionRoleArn'] as String?,
      family: json['Family'] as String?,
      inferenceAccelerators: (json['InferenceAccelerators'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionInferenceAcceleratorsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ipcMode: json['IpcMode'] as String?,
      memory: json['Memory'] as String?,
      networkMode: json['NetworkMode'] as String?,
      pidMode: json['PidMode'] as String?,
      placementConstraints: (json['PlacementConstraints'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionPlacementConstraintsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      proxyConfiguration: json['ProxyConfiguration'] != null
          ? AwsEcsTaskDefinitionProxyConfigurationDetails.fromJson(
              json['ProxyConfiguration'] as Map<String, dynamic>)
          : null,
      requiresCompatibilities: (json['RequiresCompatibilities'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      status: json['Status'] as String?,
      taskRoleArn: json['TaskRoleArn'] as String?,
      volumes: (json['Volumes'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEcsTaskDefinitionVolumesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final containerDefinitions = this.containerDefinitions;
    final cpu = this.cpu;
    final executionRoleArn = this.executionRoleArn;
    final family = this.family;
    final inferenceAccelerators = this.inferenceAccelerators;
    final ipcMode = this.ipcMode;
    final memory = this.memory;
    final networkMode = this.networkMode;
    final pidMode = this.pidMode;
    final placementConstraints = this.placementConstraints;
    final proxyConfiguration = this.proxyConfiguration;
    final requiresCompatibilities = this.requiresCompatibilities;
    final status = this.status;
    final taskRoleArn = this.taskRoleArn;
    final volumes = this.volumes;
    return {
      if (containerDefinitions != null)
        'ContainerDefinitions': containerDefinitions,
      if (cpu != null) 'Cpu': cpu,
      if (executionRoleArn != null) 'ExecutionRoleArn': executionRoleArn,
      if (family != null) 'Family': family,
      if (inferenceAccelerators != null)
        'InferenceAccelerators': inferenceAccelerators,
      if (ipcMode != null) 'IpcMode': ipcMode,
      if (memory != null) 'Memory': memory,
      if (networkMode != null) 'NetworkMode': networkMode,
      if (pidMode != null) 'PidMode': pidMode,
      if (placementConstraints != null)
        'PlacementConstraints': placementConstraints,
      if (proxyConfiguration != null) 'ProxyConfiguration': proxyConfiguration,
      if (requiresCompatibilities != null)
        'RequiresCompatibilities': requiresCompatibilities,
      if (status != null) 'Status': status,
      if (taskRoleArn != null) 'TaskRoleArn': taskRoleArn,
      if (volumes != null) 'Volumes': volumes,
    };
  }
}

/// An Elastic Inference accelerator to use for the containers in the task.
class AwsEcsTaskDefinitionInferenceAcceleratorsDetails {
  /// The Elastic Inference accelerator device name.
  final String? deviceName;

  /// The Elastic Inference accelerator type to use.
  final String? deviceType;

  AwsEcsTaskDefinitionInferenceAcceleratorsDetails({
    this.deviceName,
    this.deviceType,
  });

  factory AwsEcsTaskDefinitionInferenceAcceleratorsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionInferenceAcceleratorsDetails(
      deviceName: json['DeviceName'] as String?,
      deviceType: json['DeviceType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deviceName = this.deviceName;
    final deviceType = this.deviceType;
    return {
      if (deviceName != null) 'DeviceName': deviceName,
      if (deviceType != null) 'DeviceType': deviceType,
    };
  }
}

/// A placement constraint object to use for tasks.
class AwsEcsTaskDefinitionPlacementConstraintsDetails {
  /// A cluster query language expression to apply to the constraint.
  final String? expression;

  /// The type of constraint.
  final String? type;

  AwsEcsTaskDefinitionPlacementConstraintsDetails({
    this.expression,
    this.type,
  });

  factory AwsEcsTaskDefinitionPlacementConstraintsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionPlacementConstraintsDetails(
      expression: json['Expression'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final type = this.type;
    return {
      if (expression != null) 'Expression': expression,
      if (type != null) 'Type': type,
    };
  }
}

/// The configuration details for the App Mesh proxy.
class AwsEcsTaskDefinitionProxyConfigurationDetails {
  /// The name of the container that will serve as the App Mesh proxy.
  final String? containerName;

  /// The set of network configuration parameters to provide to the Container
  /// Network Interface (CNI) plugin, specified as key-value pairs.
  final List<
          AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails>?
      proxyConfigurationProperties;

  /// The proxy type.
  final String? type;

  AwsEcsTaskDefinitionProxyConfigurationDetails({
    this.containerName,
    this.proxyConfigurationProperties,
    this.type,
  });

  factory AwsEcsTaskDefinitionProxyConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionProxyConfigurationDetails(
      containerName: json['ContainerName'] as String?,
      proxyConfigurationProperties: (json['ProxyConfigurationProperties']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerName = this.containerName;
    final proxyConfigurationProperties = this.proxyConfigurationProperties;
    final type = this.type;
    return {
      if (containerName != null) 'ContainerName': containerName,
      if (proxyConfigurationProperties != null)
        'ProxyConfigurationProperties': proxyConfigurationProperties,
      if (type != null) 'Type': type,
    };
  }
}

/// A network configuration parameter to provide to the Container Network
/// Interface (CNI) plugin.
class AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails {
  /// The name of the property.
  final String? name;

  /// The value of the property.
  final String? value;

  AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails({
    this.name,
    this.value,
  });

  factory AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionProxyConfigurationProxyConfigurationPropertiesDetails(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// A data volume to mount from another container.
class AwsEcsTaskDefinitionVolumesDetails {
  /// Information about a Docker volume.
  final AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails?
      dockerVolumeConfiguration;

  /// Information about the Amazon Elastic File System file system that is used
  /// for task storage.
  final AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails?
      efsVolumeConfiguration;

  /// Information about a bind mount host volume.
  final AwsEcsTaskDefinitionVolumesHostDetails? host;

  /// The name of the data volume.
  final String? name;

  AwsEcsTaskDefinitionVolumesDetails({
    this.dockerVolumeConfiguration,
    this.efsVolumeConfiguration,
    this.host,
    this.name,
  });

  factory AwsEcsTaskDefinitionVolumesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionVolumesDetails(
      dockerVolumeConfiguration: json['DockerVolumeConfiguration'] != null
          ? AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails
              .fromJson(
                  json['DockerVolumeConfiguration'] as Map<String, dynamic>)
          : null,
      efsVolumeConfiguration: json['EfsVolumeConfiguration'] != null
          ? AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails.fromJson(
              json['EfsVolumeConfiguration'] as Map<String, dynamic>)
          : null,
      host: json['Host'] != null
          ? AwsEcsTaskDefinitionVolumesHostDetails.fromJson(
              json['Host'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dockerVolumeConfiguration = this.dockerVolumeConfiguration;
    final efsVolumeConfiguration = this.efsVolumeConfiguration;
    final host = this.host;
    final name = this.name;
    return {
      if (dockerVolumeConfiguration != null)
        'DockerVolumeConfiguration': dockerVolumeConfiguration,
      if (efsVolumeConfiguration != null)
        'EfsVolumeConfiguration': efsVolumeConfiguration,
      if (host != null) 'Host': host,
      if (name != null) 'Name': name,
    };
  }
}

/// Information about a Docker volume.
class AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails {
  /// Whether to create the Docker volume automatically if it does not already
  /// exist.
  final bool? autoprovision;

  /// The Docker volume driver to use.
  final String? driver;

  /// A map of Docker driver-specific options that are passed through.
  final Map<String, String>? driverOpts;

  /// Custom metadata to add to the Docker volume.
  final Map<String, String>? labels;

  /// The scope for the Docker volume that determines its lifecycle. Docker
  /// volumes that are scoped to a task are provisioned automatically when the
  /// task starts and destroyed when the task stops. Docker volumes that are
  /// shared persist after the task stops. Valid values are <code>shared</code> or
  /// <code>task</code>.
  final String? scope;

  AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails({
    this.autoprovision,
    this.driver,
    this.driverOpts,
    this.labels,
    this.scope,
  });

  factory AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionVolumesDockerVolumeConfigurationDetails(
      autoprovision: json['Autoprovision'] as bool?,
      driver: json['Driver'] as String?,
      driverOpts: (json['DriverOpts'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      labels: (json['Labels'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      scope: json['Scope'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final autoprovision = this.autoprovision;
    final driver = this.driver;
    final driverOpts = this.driverOpts;
    final labels = this.labels;
    final scope = this.scope;
    return {
      if (autoprovision != null) 'Autoprovision': autoprovision,
      if (driver != null) 'Driver': driver,
      if (driverOpts != null) 'DriverOpts': driverOpts,
      if (labels != null) 'Labels': labels,
      if (scope != null) 'Scope': scope,
    };
  }
}

/// <p/>
class AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails {
  /// The Amazon EFS access point identifier to use.
  final String? accessPointId;

  /// Whether to use the Amazon ECS task IAM role defined in a task definition
  /// when mounting the Amazon EFS file system.
  final String? iam;

  AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails({
    this.accessPointId,
    this.iam,
  });

  factory AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails(
      accessPointId: json['AccessPointId'] as String?,
      iam: json['Iam'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accessPointId = this.accessPointId;
    final iam = this.iam;
    return {
      if (accessPointId != null) 'AccessPointId': accessPointId,
      if (iam != null) 'Iam': iam,
    };
  }
}

/// Information about the Amazon Elastic File System file system that is used
/// for task storage.
class AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails {
  /// The authorization configuration details for the Amazon EFS file system.
  final AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails?
      authorizationConfig;

  /// The Amazon EFS file system identifier to use.
  final String? filesystemId;

  /// The directory within the Amazon EFS file system to mount as the root
  /// directory inside the host.
  final String? rootDirectory;

  /// Whether to enable encryption for Amazon EFS data in transit between the
  /// Amazon ECS host and the Amazon EFS server.
  final String? transitEncryption;

  /// The port to use when sending encrypted data between the Amazon ECS host and
  /// the Amazon EFS server.
  final int? transitEncryptionPort;

  AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails({
    this.authorizationConfig,
    this.filesystemId,
    this.rootDirectory,
    this.transitEncryption,
    this.transitEncryptionPort,
  });

  factory AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationDetails(
      authorizationConfig: json['AuthorizationConfig'] != null
          ? AwsEcsTaskDefinitionVolumesEfsVolumeConfigurationAuthorizationConfigDetails
              .fromJson(json['AuthorizationConfig'] as Map<String, dynamic>)
          : null,
      filesystemId: json['FilesystemId'] as String?,
      rootDirectory: json['RootDirectory'] as String?,
      transitEncryption: json['TransitEncryption'] as String?,
      transitEncryptionPort: json['TransitEncryptionPort'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final authorizationConfig = this.authorizationConfig;
    final filesystemId = this.filesystemId;
    final rootDirectory = this.rootDirectory;
    final transitEncryption = this.transitEncryption;
    final transitEncryptionPort = this.transitEncryptionPort;
    return {
      if (authorizationConfig != null)
        'AuthorizationConfig': authorizationConfig,
      if (filesystemId != null) 'FilesystemId': filesystemId,
      if (rootDirectory != null) 'RootDirectory': rootDirectory,
      if (transitEncryption != null) 'TransitEncryption': transitEncryption,
      if (transitEncryptionPort != null)
        'TransitEncryptionPort': transitEncryptionPort,
    };
  }
}

/// Information about a bind mount host volume.
class AwsEcsTaskDefinitionVolumesHostDetails {
  /// The path on the host container instance that is presented to the container.
  final String? sourcePath;

  AwsEcsTaskDefinitionVolumesHostDetails({
    this.sourcePath,
  });

  factory AwsEcsTaskDefinitionVolumesHostDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEcsTaskDefinitionVolumesHostDetails(
      sourcePath: json['SourcePath'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final sourcePath = this.sourcePath;
    return {
      if (sourcePath != null) 'SourcePath': sourcePath,
    };
  }
}

/// Provides details about a task in a cluster.
class AwsEcsTaskDetails {
  /// The Amazon Resource Name (ARN) of the cluster that hosts the task.
  final String? clusterArn;

  /// The containers that are associated with the task.
  final List<AwsEcsContainerDetails>? containers;

  /// The Unix timestamp for the time when the task was created. More
  /// specifically, it's for the time when the task entered the
  /// <code>PENDING</code> state.
  final String? createdAt;

  /// The name of the task group that's associated with the task.
  final String? group;

  /// The Unix timestamp for the time when the task started. More specifically,
  /// it's for the time when the task transitioned from the <code>PENDING</code>
  /// state to the <code>RUNNING</code> state.
  final String? startedAt;

  /// The tag specified when a task is started. If an Amazon ECS service started
  /// the task, the <code>startedBy</code> parameter contains the deployment ID of
  /// that service.
  final String? startedBy;

  /// The ARN of the task definition that creates the task.
  final String? taskDefinitionArn;

  /// The version counter for the task.
  final String? version;

  /// Details about the data volume that is used in a task definition.
  final List<AwsEcsTaskVolumeDetails>? volumes;

  AwsEcsTaskDetails({
    this.clusterArn,
    this.containers,
    this.createdAt,
    this.group,
    this.startedAt,
    this.startedBy,
    this.taskDefinitionArn,
    this.version,
    this.volumes,
  });

  factory AwsEcsTaskDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsTaskDetails(
      clusterArn: json['ClusterArn'] as String?,
      containers: (json['Containers'] as List?)
          ?.whereNotNull()
          .map(
              (e) => AwsEcsContainerDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: json['CreatedAt'] as String?,
      group: json['Group'] as String?,
      startedAt: json['StartedAt'] as String?,
      startedBy: json['StartedBy'] as String?,
      taskDefinitionArn: json['TaskDefinitionArn'] as String?,
      version: json['Version'] as String?,
      volumes: (json['Volumes'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsEcsTaskVolumeDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final clusterArn = this.clusterArn;
    final containers = this.containers;
    final createdAt = this.createdAt;
    final group = this.group;
    final startedAt = this.startedAt;
    final startedBy = this.startedBy;
    final taskDefinitionArn = this.taskDefinitionArn;
    final version = this.version;
    final volumes = this.volumes;
    return {
      if (clusterArn != null) 'ClusterArn': clusterArn,
      if (containers != null) 'Containers': containers,
      if (createdAt != null) 'CreatedAt': createdAt,
      if (group != null) 'Group': group,
      if (startedAt != null) 'StartedAt': startedAt,
      if (startedBy != null) 'StartedBy': startedBy,
      if (taskDefinitionArn != null) 'TaskDefinitionArn': taskDefinitionArn,
      if (version != null) 'Version': version,
      if (volumes != null) 'Volumes': volumes,
    };
  }
}

/// Provides information about a data volume that's used in a task definition.
class AwsEcsTaskVolumeDetails {
  /// This parameter is specified when you use bind mount host volumes. The
  /// contents of the <code>host</code> parameter determine whether your bind
  /// mount host volume persists on the host container instance and where it's
  /// stored.
  final AwsEcsTaskVolumeHostDetails? host;

  /// The name of the volume. Up to 255 letters (uppercase and lowercase),
  /// numbers, underscores, and hyphens are allowed. This name is referenced in
  /// the <code>sourceVolume</code> parameter of container definition
  /// <code>mountPoints</code>.
  final String? name;

  AwsEcsTaskVolumeDetails({
    this.host,
    this.name,
  });

  factory AwsEcsTaskVolumeDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsTaskVolumeDetails(
      host: json['Host'] != null
          ? AwsEcsTaskVolumeHostDetails.fromJson(
              json['Host'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final host = this.host;
    final name = this.name;
    return {
      if (host != null) 'Host': host,
      if (name != null) 'Name': name,
    };
  }
}

/// Provides details on a container instance bind mount host volume.
class AwsEcsTaskVolumeHostDetails {
  /// When the <code>host</code> parameter is used, specify a
  /// <code>sourcePath</code> to declare the path on the host container instance
  /// that's presented to the container.
  final String? sourcePath;

  AwsEcsTaskVolumeHostDetails({
    this.sourcePath,
  });

  factory AwsEcsTaskVolumeHostDetails.fromJson(Map<String, dynamic> json) {
    return AwsEcsTaskVolumeHostDetails(
      sourcePath: json['SourcePath'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final sourcePath = this.sourcePath;
    return {
      if (sourcePath != null) 'SourcePath': sourcePath,
    };
  }
}

/// Provides information about an Amazon EFS access point.
class AwsEfsAccessPointDetails {
  /// The ID of the Amazon EFS access point.
  final String? accessPointId;

  /// The Amazon Resource Name (ARN) of the Amazon EFS access point.
  final String? arn;

  /// The opaque string specified in the request to ensure idempotent creation.
  final String? clientToken;

  /// The ID of the Amazon EFS file system that the access point applies to.
  final String? fileSystemId;

  /// The full POSIX identity, including the user ID, group ID, and secondary
  /// group IDs on the access point, that is used for all file operations by NFS
  /// clients using the access point.
  final AwsEfsAccessPointPosixUserDetails? posixUser;

  /// The directory on the Amazon EFS file system that the access point exposes as
  /// the root directory to NFS clients using the access point.
  final AwsEfsAccessPointRootDirectoryDetails? rootDirectory;

  AwsEfsAccessPointDetails({
    this.accessPointId,
    this.arn,
    this.clientToken,
    this.fileSystemId,
    this.posixUser,
    this.rootDirectory,
  });

  factory AwsEfsAccessPointDetails.fromJson(Map<String, dynamic> json) {
    return AwsEfsAccessPointDetails(
      accessPointId: json['AccessPointId'] as String?,
      arn: json['Arn'] as String?,
      clientToken: json['ClientToken'] as String?,
      fileSystemId: json['FileSystemId'] as String?,
      posixUser: json['PosixUser'] != null
          ? AwsEfsAccessPointPosixUserDetails.fromJson(
              json['PosixUser'] as Map<String, dynamic>)
          : null,
      rootDirectory: json['RootDirectory'] != null
          ? AwsEfsAccessPointRootDirectoryDetails.fromJson(
              json['RootDirectory'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessPointId = this.accessPointId;
    final arn = this.arn;
    final clientToken = this.clientToken;
    final fileSystemId = this.fileSystemId;
    final posixUser = this.posixUser;
    final rootDirectory = this.rootDirectory;
    return {
      if (accessPointId != null) 'AccessPointId': accessPointId,
      if (arn != null) 'Arn': arn,
      if (clientToken != null) 'ClientToken': clientToken,
      if (fileSystemId != null) 'FileSystemId': fileSystemId,
      if (posixUser != null) 'PosixUser': posixUser,
      if (rootDirectory != null) 'RootDirectory': rootDirectory,
    };
  }
}

/// Provides details for all file system operations using this Amazon EFS access
/// point.
class AwsEfsAccessPointPosixUserDetails {
  /// The POSIX group ID used for all file system operations using this access
  /// point.
  final String? gid;

  /// Secondary POSIX group IDs used for all file system operations using this
  /// access point.
  final List<String>? secondaryGids;

  /// The POSIX user ID used for all file system operations using this access
  /// point.
  final String? uid;

  AwsEfsAccessPointPosixUserDetails({
    this.gid,
    this.secondaryGids,
    this.uid,
  });

  factory AwsEfsAccessPointPosixUserDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEfsAccessPointPosixUserDetails(
      gid: json['Gid'] as String?,
      secondaryGids: (json['SecondaryGids'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      uid: json['Uid'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final gid = this.gid;
    final secondaryGids = this.secondaryGids;
    final uid = this.uid;
    return {
      if (gid != null) 'Gid': gid,
      if (secondaryGids != null) 'SecondaryGids': secondaryGids,
      if (uid != null) 'Uid': uid,
    };
  }
}

/// Provides information about the settings that Amazon EFS uses to create the
/// root directory when a client connects to an access point.
class AwsEfsAccessPointRootDirectoryCreationInfoDetails {
  /// Specifies the POSIX group ID to apply to the root directory.
  final String? ownerGid;

  /// Specifies the POSIX user ID to apply to the root directory.
  final String? ownerUid;

  /// Specifies the POSIX permissions to apply to the root directory, in the
  /// format of an octal number representing the file's mode bits.
  final String? permissions;

  AwsEfsAccessPointRootDirectoryCreationInfoDetails({
    this.ownerGid,
    this.ownerUid,
    this.permissions,
  });

  factory AwsEfsAccessPointRootDirectoryCreationInfoDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEfsAccessPointRootDirectoryCreationInfoDetails(
      ownerGid: json['OwnerGid'] as String?,
      ownerUid: json['OwnerUid'] as String?,
      permissions: json['Permissions'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ownerGid = this.ownerGid;
    final ownerUid = this.ownerUid;
    final permissions = this.permissions;
    return {
      if (ownerGid != null) 'OwnerGid': ownerGid,
      if (ownerUid != null) 'OwnerUid': ownerUid,
      if (permissions != null) 'Permissions': permissions,
    };
  }
}

/// Provides information about the directory on the Amazon EFS file system that
/// the access point exposes as the root directory to NFS clients using the
/// access point.
class AwsEfsAccessPointRootDirectoryDetails {
  /// Specifies the POSIX IDs and permissions to apply to the access point's root
  /// directory.
  final AwsEfsAccessPointRootDirectoryCreationInfoDetails? creationInfo;

  /// Specifies the path on the Amazon EFS file system to expose as the root
  /// directory to NFS clients using the access point to access the EFS file
  /// system. A path can have up to four subdirectories. If the specified path
  /// does not exist, you are required to provide <code>CreationInfo</code>.
  final String? path;

  AwsEfsAccessPointRootDirectoryDetails({
    this.creationInfo,
    this.path,
  });

  factory AwsEfsAccessPointRootDirectoryDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEfsAccessPointRootDirectoryDetails(
      creationInfo: json['CreationInfo'] != null
          ? AwsEfsAccessPointRootDirectoryCreationInfoDetails.fromJson(
              json['CreationInfo'] as Map<String, dynamic>)
          : null,
      path: json['Path'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final creationInfo = this.creationInfo;
    final path = this.path;
    return {
      if (creationInfo != null) 'CreationInfo': creationInfo,
      if (path != null) 'Path': path,
    };
  }
}

/// Provides details about an Amazon EKS cluster.
class AwsEksClusterDetails {
  /// The ARN of the cluster.
  final String? arn;

  /// The certificate authority data for the cluster.
  final String? certificateAuthorityData;

  /// The status of the cluster. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ACTIVE</code>
  /// </li>
  /// <li>
  /// <code>CREATING</code>
  /// </li>
  /// <li>
  /// <code>DELETING</code>
  /// </li>
  /// <li>
  /// <code>FAILED</code>
  /// </li>
  /// <li>
  /// <code>PENDING</code>
  /// </li>
  /// <li>
  /// <code>UPDATING</code>
  /// </li>
  /// </ul>
  final String? clusterStatus;

  /// The endpoint for the Amazon EKS API server.
  final String? endpoint;

  /// The logging configuration for the cluster.
  final AwsEksClusterLoggingDetails? logging;

  /// The name of the cluster.
  final String? name;

  /// The VPC configuration used by the cluster control plane.
  final AwsEksClusterResourcesVpcConfigDetails? resourcesVpcConfig;

  /// The ARN of the IAM role that provides permissions for the Amazon EKS control
  /// plane to make calls to Amazon Web Services API operations on your behalf.
  final String? roleArn;

  /// The Amazon EKS server version for the cluster.
  final String? version;

  AwsEksClusterDetails({
    this.arn,
    this.certificateAuthorityData,
    this.clusterStatus,
    this.endpoint,
    this.logging,
    this.name,
    this.resourcesVpcConfig,
    this.roleArn,
    this.version,
  });

  factory AwsEksClusterDetails.fromJson(Map<String, dynamic> json) {
    return AwsEksClusterDetails(
      arn: json['Arn'] as String?,
      certificateAuthorityData: json['CertificateAuthorityData'] as String?,
      clusterStatus: json['ClusterStatus'] as String?,
      endpoint: json['Endpoint'] as String?,
      logging: json['Logging'] != null
          ? AwsEksClusterLoggingDetails.fromJson(
              json['Logging'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      resourcesVpcConfig: json['ResourcesVpcConfig'] != null
          ? AwsEksClusterResourcesVpcConfigDetails.fromJson(
              json['ResourcesVpcConfig'] as Map<String, dynamic>)
          : null,
      roleArn: json['RoleArn'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final certificateAuthorityData = this.certificateAuthorityData;
    final clusterStatus = this.clusterStatus;
    final endpoint = this.endpoint;
    final logging = this.logging;
    final name = this.name;
    final resourcesVpcConfig = this.resourcesVpcConfig;
    final roleArn = this.roleArn;
    final version = this.version;
    return {
      if (arn != null) 'Arn': arn,
      if (certificateAuthorityData != null)
        'CertificateAuthorityData': certificateAuthorityData,
      if (clusterStatus != null) 'ClusterStatus': clusterStatus,
      if (endpoint != null) 'Endpoint': endpoint,
      if (logging != null) 'Logging': logging,
      if (name != null) 'Name': name,
      if (resourcesVpcConfig != null) 'ResourcesVpcConfig': resourcesVpcConfig,
      if (roleArn != null) 'RoleArn': roleArn,
      if (version != null) 'Version': version,
    };
  }
}

/// Details for a cluster logging configuration.
class AwsEksClusterLoggingClusterLoggingDetails {
  /// Whether the logging types that are listed in <code>Types</code> are enabled.
  final bool? enabled;

  /// A list of logging types. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>api</code>
  /// </li>
  /// <li>
  /// <code>audit</code>
  /// </li>
  /// <li>
  /// <code>authenticator</code>
  /// </li>
  /// <li>
  /// <code>controllerManager</code>
  /// </li>
  /// <li>
  /// <code>scheduler</code>
  /// </li>
  /// </ul>
  final List<String>? types;

  AwsEksClusterLoggingClusterLoggingDetails({
    this.enabled,
    this.types,
  });

  factory AwsEksClusterLoggingClusterLoggingDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEksClusterLoggingClusterLoggingDetails(
      enabled: json['Enabled'] as bool?,
      types: (json['Types'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final types = this.types;
    return {
      if (enabled != null) 'Enabled': enabled,
      if (types != null) 'Types': types,
    };
  }
}

/// The logging configuration for an Amazon EKS cluster.
class AwsEksClusterLoggingDetails {
  /// Cluster logging configurations.
  final List<AwsEksClusterLoggingClusterLoggingDetails>? clusterLogging;

  AwsEksClusterLoggingDetails({
    this.clusterLogging,
  });

  factory AwsEksClusterLoggingDetails.fromJson(Map<String, dynamic> json) {
    return AwsEksClusterLoggingDetails(
      clusterLogging: (json['ClusterLogging'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEksClusterLoggingClusterLoggingDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final clusterLogging = this.clusterLogging;
    return {
      if (clusterLogging != null) 'ClusterLogging': clusterLogging,
    };
  }
}

/// Information about the VPC configuration used by the cluster control plane.
class AwsEksClusterResourcesVpcConfigDetails {
  /// Indicates whether the Amazon EKS public API server endpoint is turned on. If
  /// the Amazon EKS public API server endpoint is turned off, your cluster's
  /// Kubernetes API server can only receive requests that originate from within
  /// the cluster VPC.
  final bool? endpointPublicAccess;

  /// The security groups that are associated with the cross-account elastic
  /// network interfaces that are used to allow communication between your nodes
  /// and the Amazon EKS control plane.
  final List<String>? securityGroupIds;

  /// The subnets that are associated with the cluster.
  final List<String>? subnetIds;

  AwsEksClusterResourcesVpcConfigDetails({
    this.endpointPublicAccess,
    this.securityGroupIds,
    this.subnetIds,
  });

  factory AwsEksClusterResourcesVpcConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEksClusterResourcesVpcConfigDetails(
      endpointPublicAccess: json['EndpointPublicAccess'] as bool?,
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnetIds: (json['SubnetIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final endpointPublicAccess = this.endpointPublicAccess;
    final securityGroupIds = this.securityGroupIds;
    final subnetIds = this.subnetIds;
    return {
      if (endpointPublicAccess != null)
        'EndpointPublicAccess': endpointPublicAccess,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (subnetIds != null) 'SubnetIds': subnetIds,
    };
  }
}

/// Contains details about an Elastic Beanstalk environment.
class AwsElasticBeanstalkEnvironmentDetails {
  /// The name of the application that is associated with the environment.
  final String? applicationName;

  /// The URL to the CNAME for this environment.
  final String? cname;

  /// The creation date for this environment.
  final String? dateCreated;

  /// The date when this environment was last modified.
  final String? dateUpdated;

  /// A description of the environment.
  final String? description;

  /// For load-balanced, autoscaling environments, the URL to the load balancer.
  /// For single-instance environments, the IP address of the instance.
  final String? endpointUrl;

  /// The ARN of the environment.
  final String? environmentArn;

  /// The identifier of the environment.
  final String? environmentId;

  /// Links to other environments in the same group.
  final List<AwsElasticBeanstalkEnvironmentEnvironmentLink>? environmentLinks;

  /// The name of the environment.
  final String? environmentName;

  /// The configuration setting for the environment.
  final List<AwsElasticBeanstalkEnvironmentOptionSetting>? optionSettings;

  /// The ARN of the platform version for the environment.
  final String? platformArn;

  /// The name of the solution stack that is deployed with the environment.
  final String? solutionStackName;

  /// The current operational status of the environment. Valid values are as
  /// follows:
  ///
  /// <ul>
  /// <li>
  /// <code>Aborting</code>
  /// </li>
  /// <li>
  /// <code>Launching</code>
  /// </li>
  /// <li>
  /// <code>LinkingFrom</code>
  /// </li>
  /// <li>
  /// <code>LinkingTo</code>
  /// </li>
  /// <li>
  /// <code>Ready</code>
  /// </li>
  /// <li>
  /// <code>Terminated</code>
  /// </li>
  /// <li>
  /// <code>Terminating</code>
  /// </li>
  /// <li>
  /// <code>Updating</code>
  /// </li>
  /// </ul>
  final String? status;

  /// The tier of the environment.
  final AwsElasticBeanstalkEnvironmentTier? tier;

  /// The application version of the environment.
  final String? versionLabel;

  AwsElasticBeanstalkEnvironmentDetails({
    this.applicationName,
    this.cname,
    this.dateCreated,
    this.dateUpdated,
    this.description,
    this.endpointUrl,
    this.environmentArn,
    this.environmentId,
    this.environmentLinks,
    this.environmentName,
    this.optionSettings,
    this.platformArn,
    this.solutionStackName,
    this.status,
    this.tier,
    this.versionLabel,
  });

  factory AwsElasticBeanstalkEnvironmentDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticBeanstalkEnvironmentDetails(
      applicationName: json['ApplicationName'] as String?,
      cname: json['Cname'] as String?,
      dateCreated: json['DateCreated'] as String?,
      dateUpdated: json['DateUpdated'] as String?,
      description: json['Description'] as String?,
      endpointUrl: json['EndpointUrl'] as String?,
      environmentArn: json['EnvironmentArn'] as String?,
      environmentId: json['EnvironmentId'] as String?,
      environmentLinks: (json['EnvironmentLinks'] as List?)
          ?.whereNotNull()
          .map((e) => AwsElasticBeanstalkEnvironmentEnvironmentLink.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      environmentName: json['EnvironmentName'] as String?,
      optionSettings: (json['OptionSettings'] as List?)
          ?.whereNotNull()
          .map((e) => AwsElasticBeanstalkEnvironmentOptionSetting.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      platformArn: json['PlatformArn'] as String?,
      solutionStackName: json['SolutionStackName'] as String?,
      status: json['Status'] as String?,
      tier: json['Tier'] != null
          ? AwsElasticBeanstalkEnvironmentTier.fromJson(
              json['Tier'] as Map<String, dynamic>)
          : null,
      versionLabel: json['VersionLabel'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final applicationName = this.applicationName;
    final cname = this.cname;
    final dateCreated = this.dateCreated;
    final dateUpdated = this.dateUpdated;
    final description = this.description;
    final endpointUrl = this.endpointUrl;
    final environmentArn = this.environmentArn;
    final environmentId = this.environmentId;
    final environmentLinks = this.environmentLinks;
    final environmentName = this.environmentName;
    final optionSettings = this.optionSettings;
    final platformArn = this.platformArn;
    final solutionStackName = this.solutionStackName;
    final status = this.status;
    final tier = this.tier;
    final versionLabel = this.versionLabel;
    return {
      if (applicationName != null) 'ApplicationName': applicationName,
      if (cname != null) 'Cname': cname,
      if (dateCreated != null) 'DateCreated': dateCreated,
      if (dateUpdated != null) 'DateUpdated': dateUpdated,
      if (description != null) 'Description': description,
      if (endpointUrl != null) 'EndpointUrl': endpointUrl,
      if (environmentArn != null) 'EnvironmentArn': environmentArn,
      if (environmentId != null) 'EnvironmentId': environmentId,
      if (environmentLinks != null) 'EnvironmentLinks': environmentLinks,
      if (environmentName != null) 'EnvironmentName': environmentName,
      if (optionSettings != null) 'OptionSettings': optionSettings,
      if (platformArn != null) 'PlatformArn': platformArn,
      if (solutionStackName != null) 'SolutionStackName': solutionStackName,
      if (status != null) 'Status': status,
      if (tier != null) 'Tier': tier,
      if (versionLabel != null) 'VersionLabel': versionLabel,
    };
  }
}

/// Contains information about a link to another environment that is in the same
/// group.
class AwsElasticBeanstalkEnvironmentEnvironmentLink {
  /// The name of the linked environment.
  final String? environmentName;

  /// The name of the environment link.
  final String? linkName;

  AwsElasticBeanstalkEnvironmentEnvironmentLink({
    this.environmentName,
    this.linkName,
  });

  factory AwsElasticBeanstalkEnvironmentEnvironmentLink.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticBeanstalkEnvironmentEnvironmentLink(
      environmentName: json['EnvironmentName'] as String?,
      linkName: json['LinkName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final environmentName = this.environmentName;
    final linkName = this.linkName;
    return {
      if (environmentName != null) 'EnvironmentName': environmentName,
      if (linkName != null) 'LinkName': linkName,
    };
  }
}

/// A configuration option setting for the environment.
class AwsElasticBeanstalkEnvironmentOptionSetting {
  /// The type of resource that the configuration option is associated with.
  final String? namespace;

  /// The name of the option.
  final String? optionName;

  /// The name of the resource.
  final String? resourceName;

  /// The value of the configuration setting.
  final String? value;

  AwsElasticBeanstalkEnvironmentOptionSetting({
    this.namespace,
    this.optionName,
    this.resourceName,
    this.value,
  });

  factory AwsElasticBeanstalkEnvironmentOptionSetting.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticBeanstalkEnvironmentOptionSetting(
      namespace: json['Namespace'] as String?,
      optionName: json['OptionName'] as String?,
      resourceName: json['ResourceName'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final namespace = this.namespace;
    final optionName = this.optionName;
    final resourceName = this.resourceName;
    final value = this.value;
    return {
      if (namespace != null) 'Namespace': namespace,
      if (optionName != null) 'OptionName': optionName,
      if (resourceName != null) 'ResourceName': resourceName,
      if (value != null) 'Value': value,
    };
  }
}

/// Contains information about the tier of the environment.
class AwsElasticBeanstalkEnvironmentTier {
  /// The name of the environment tier. Valid values are <code>WebServer</code> or
  /// <code>Worker</code>.
  final String? name;

  /// The type of environment tier. Valid values are <code>Standard</code> or
  /// <code>SQS/HTTP</code>.
  final String? type;

  /// The version of the environment tier.
  final String? version;

  AwsElasticBeanstalkEnvironmentTier({
    this.name,
    this.type,
    this.version,
  });

  factory AwsElasticBeanstalkEnvironmentTier.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticBeanstalkEnvironmentTier(
      name: json['Name'] as String?,
      type: json['Type'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final type = this.type;
    final version = this.version;
    return {
      if (name != null) 'Name': name,
      if (type != null) 'Type': type,
      if (version != null) 'Version': version,
    };
  }
}

/// Information about an Elasticsearch domain.
class AwsElasticsearchDomainDetails {
  /// IAM policy document specifying the access policies for the new Elasticsearch
  /// domain.
  final String? accessPolicies;

  /// Additional options for the domain endpoint.
  final AwsElasticsearchDomainDomainEndpointOptions? domainEndpointOptions;

  /// Unique identifier for an Elasticsearch domain.
  final String? domainId;

  /// Name of an Elasticsearch domain.
  ///
  /// Domain names are unique across all domains owned by the same account within
  /// an Amazon Web Services Region.
  ///
  /// Domain names must start with a lowercase letter and must be between 3 and 28
  /// characters.
  ///
  /// Valid characters are a-z (lowercase only), 0-9, and – (hyphen).
  final String? domainName;

  /// Information about an OpenSearch cluster configuration.
  final AwsElasticsearchDomainElasticsearchClusterConfigDetails?
      elasticsearchClusterConfig;

  /// OpenSearch version.
  final String? elasticsearchVersion;

  /// Details about the configuration for encryption at rest.
  final AwsElasticsearchDomainEncryptionAtRestOptions? encryptionAtRestOptions;

  /// Domain-specific endpoint used to submit index, search, and data upload
  /// requests to an Elasticsearch domain.
  ///
  /// The endpoint is a service URL.
  final String? endpoint;

  /// The key-value pair that exists if the Elasticsearch domain uses VPC
  /// endpoints.
  final Map<String, String>? endpoints;

  /// Configures the CloudWatch Logs to publish for the Elasticsearch domain.
  final AwsElasticsearchDomainLogPublishingOptions? logPublishingOptions;

  /// Details about the configuration for node-to-node encryption.
  final AwsElasticsearchDomainNodeToNodeEncryptionOptions?
      nodeToNodeEncryptionOptions;

  /// Information about the status of a domain relative to the latest service
  /// software.
  final AwsElasticsearchDomainServiceSoftwareOptions? serviceSoftwareOptions;

  /// Information that OpenSearch derives based on <code>VPCOptions</code> for the
  /// domain.
  final AwsElasticsearchDomainVPCOptions? vPCOptions;

  AwsElasticsearchDomainDetails({
    this.accessPolicies,
    this.domainEndpointOptions,
    this.domainId,
    this.domainName,
    this.elasticsearchClusterConfig,
    this.elasticsearchVersion,
    this.encryptionAtRestOptions,
    this.endpoint,
    this.endpoints,
    this.logPublishingOptions,
    this.nodeToNodeEncryptionOptions,
    this.serviceSoftwareOptions,
    this.vPCOptions,
  });

  factory AwsElasticsearchDomainDetails.fromJson(Map<String, dynamic> json) {
    return AwsElasticsearchDomainDetails(
      accessPolicies: json['AccessPolicies'] as String?,
      domainEndpointOptions: json['DomainEndpointOptions'] != null
          ? AwsElasticsearchDomainDomainEndpointOptions.fromJson(
              json['DomainEndpointOptions'] as Map<String, dynamic>)
          : null,
      domainId: json['DomainId'] as String?,
      domainName: json['DomainName'] as String?,
      elasticsearchClusterConfig: json['ElasticsearchClusterConfig'] != null
          ? AwsElasticsearchDomainElasticsearchClusterConfigDetails.fromJson(
              json['ElasticsearchClusterConfig'] as Map<String, dynamic>)
          : null,
      elasticsearchVersion: json['ElasticsearchVersion'] as String?,
      encryptionAtRestOptions: json['EncryptionAtRestOptions'] != null
          ? AwsElasticsearchDomainEncryptionAtRestOptions.fromJson(
              json['EncryptionAtRestOptions'] as Map<String, dynamic>)
          : null,
      endpoint: json['Endpoint'] as String?,
      endpoints: (json['Endpoints'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      logPublishingOptions: json['LogPublishingOptions'] != null
          ? AwsElasticsearchDomainLogPublishingOptions.fromJson(
              json['LogPublishingOptions'] as Map<String, dynamic>)
          : null,
      nodeToNodeEncryptionOptions: json['NodeToNodeEncryptionOptions'] != null
          ? AwsElasticsearchDomainNodeToNodeEncryptionOptions.fromJson(
              json['NodeToNodeEncryptionOptions'] as Map<String, dynamic>)
          : null,
      serviceSoftwareOptions: json['ServiceSoftwareOptions'] != null
          ? AwsElasticsearchDomainServiceSoftwareOptions.fromJson(
              json['ServiceSoftwareOptions'] as Map<String, dynamic>)
          : null,
      vPCOptions: json['VPCOptions'] != null
          ? AwsElasticsearchDomainVPCOptions.fromJson(
              json['VPCOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessPolicies = this.accessPolicies;
    final domainEndpointOptions = this.domainEndpointOptions;
    final domainId = this.domainId;
    final domainName = this.domainName;
    final elasticsearchClusterConfig = this.elasticsearchClusterConfig;
    final elasticsearchVersion = this.elasticsearchVersion;
    final encryptionAtRestOptions = this.encryptionAtRestOptions;
    final endpoint = this.endpoint;
    final endpoints = this.endpoints;
    final logPublishingOptions = this.logPublishingOptions;
    final nodeToNodeEncryptionOptions = this.nodeToNodeEncryptionOptions;
    final serviceSoftwareOptions = this.serviceSoftwareOptions;
    final vPCOptions = this.vPCOptions;
    return {
      if (accessPolicies != null) 'AccessPolicies': accessPolicies,
      if (domainEndpointOptions != null)
        'DomainEndpointOptions': domainEndpointOptions,
      if (domainId != null) 'DomainId': domainId,
      if (domainName != null) 'DomainName': domainName,
      if (elasticsearchClusterConfig != null)
        'ElasticsearchClusterConfig': elasticsearchClusterConfig,
      if (elasticsearchVersion != null)
        'ElasticsearchVersion': elasticsearchVersion,
      if (encryptionAtRestOptions != null)
        'EncryptionAtRestOptions': encryptionAtRestOptions,
      if (endpoint != null) 'Endpoint': endpoint,
      if (endpoints != null) 'Endpoints': endpoints,
      if (logPublishingOptions != null)
        'LogPublishingOptions': logPublishingOptions,
      if (nodeToNodeEncryptionOptions != null)
        'NodeToNodeEncryptionOptions': nodeToNodeEncryptionOptions,
      if (serviceSoftwareOptions != null)
        'ServiceSoftwareOptions': serviceSoftwareOptions,
      if (vPCOptions != null) 'VPCOptions': vPCOptions,
    };
  }
}

/// Additional options for the domain endpoint, such as whether to require HTTPS
/// for all traffic.
class AwsElasticsearchDomainDomainEndpointOptions {
  /// Whether to require that all traffic to the domain arrive over HTTPS.
  final bool? enforceHTTPS;

  /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch
  /// domain.
  ///
  /// Valid values:
  ///
  /// <ul>
  /// <li>
  /// <code>Policy-Min-TLS-1-0-2019-07</code>, which supports TLSv1.0 and higher
  /// </li>
  /// <li>
  /// <code>Policy-Min-TLS-1-2-2019-07</code>, which only supports TLSv1.2
  /// </li>
  /// </ul>
  final String? tLSSecurityPolicy;

  AwsElasticsearchDomainDomainEndpointOptions({
    this.enforceHTTPS,
    this.tLSSecurityPolicy,
  });

  factory AwsElasticsearchDomainDomainEndpointOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainDomainEndpointOptions(
      enforceHTTPS: json['EnforceHTTPS'] as bool?,
      tLSSecurityPolicy: json['TLSSecurityPolicy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final enforceHTTPS = this.enforceHTTPS;
    final tLSSecurityPolicy = this.tLSSecurityPolicy;
    return {
      if (enforceHTTPS != null) 'EnforceHTTPS': enforceHTTPS,
      if (tLSSecurityPolicy != null) 'TLSSecurityPolicy': tLSSecurityPolicy,
    };
  }
}

/// details about the configuration of an OpenSearch cluster.
class AwsElasticsearchDomainElasticsearchClusterConfigDetails {
  /// The number of instances to use for the master node. If this attribute is
  /// specified, then <code>DedicatedMasterEnabled</code> must be
  /// <code>true</code>.
  final int? dedicatedMasterCount;

  /// Whether to use a dedicated master node for the Elasticsearch domain. A
  /// dedicated master node performs cluster management tasks, but doesn't hold
  /// data or respond to data upload requests.
  final bool? dedicatedMasterEnabled;

  /// The hardware configuration of the computer that hosts the dedicated master
  /// node. A sample value is <code>m3.medium.elasticsearch</code>. If this
  /// attribute is specified, then <code>DedicatedMasterEnabled</code> must be
  /// <code>true</code>.
  ///
  /// For a list of valid values, see <a
  /// href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html">Supported
  /// instance types in Amazon OpenSearch Service</a> in the <i>Amazon OpenSearch
  /// Service Developer Guide</i>.
  final String? dedicatedMasterType;

  /// The number of data nodes to use in the Elasticsearch domain.
  final int? instanceCount;

  /// The instance type for your data nodes. For example,
  /// <code>m3.medium.elasticsearch</code>.
  ///
  /// For a list of valid values, see <a
  /// href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html">Supported
  /// instance types in Amazon OpenSearch Service</a> in the <i>Amazon OpenSearch
  /// Service Developer Guide</i>.
  final String? instanceType;

  /// Configuration options for zone awareness. Provided if
  /// <code>ZoneAwarenessEnabled</code> is <code>true</code>.
  final AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails?
      zoneAwarenessConfig;

  /// Whether to enable zone awareness for the Elasticsearch domain. When zone
  /// awareness is enabled, OpenSearch allocates the cluster's nodes and replica
  /// index shards across Availability Zones in the same Region. This prevents
  /// data loss and minimizes downtime if a node or data center fails.
  final bool? zoneAwarenessEnabled;

  AwsElasticsearchDomainElasticsearchClusterConfigDetails({
    this.dedicatedMasterCount,
    this.dedicatedMasterEnabled,
    this.dedicatedMasterType,
    this.instanceCount,
    this.instanceType,
    this.zoneAwarenessConfig,
    this.zoneAwarenessEnabled,
  });

  factory AwsElasticsearchDomainElasticsearchClusterConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainElasticsearchClusterConfigDetails(
      dedicatedMasterCount: json['DedicatedMasterCount'] as int?,
      dedicatedMasterEnabled: json['DedicatedMasterEnabled'] as bool?,
      dedicatedMasterType: json['DedicatedMasterType'] as String?,
      instanceCount: json['InstanceCount'] as int?,
      instanceType: json['InstanceType'] as String?,
      zoneAwarenessConfig: json['ZoneAwarenessConfig'] != null
          ? AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails
              .fromJson(json['ZoneAwarenessConfig'] as Map<String, dynamic>)
          : null,
      zoneAwarenessEnabled: json['ZoneAwarenessEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final dedicatedMasterCount = this.dedicatedMasterCount;
    final dedicatedMasterEnabled = this.dedicatedMasterEnabled;
    final dedicatedMasterType = this.dedicatedMasterType;
    final instanceCount = this.instanceCount;
    final instanceType = this.instanceType;
    final zoneAwarenessConfig = this.zoneAwarenessConfig;
    final zoneAwarenessEnabled = this.zoneAwarenessEnabled;
    return {
      if (dedicatedMasterCount != null)
        'DedicatedMasterCount': dedicatedMasterCount,
      if (dedicatedMasterEnabled != null)
        'DedicatedMasterEnabled': dedicatedMasterEnabled,
      if (dedicatedMasterType != null)
        'DedicatedMasterType': dedicatedMasterType,
      if (instanceCount != null) 'InstanceCount': instanceCount,
      if (instanceType != null) 'InstanceType': instanceType,
      if (zoneAwarenessConfig != null)
        'ZoneAwarenessConfig': zoneAwarenessConfig,
      if (zoneAwarenessEnabled != null)
        'ZoneAwarenessEnabled': zoneAwarenessEnabled,
    };
  }
}

/// Configuration options for zone awareness.
class AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails {
  /// he number of Availability Zones that the domain uses. Valid values are 2 and
  /// 3. The default is 2.
  final int? availabilityZoneCount;

  AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails({
    this.availabilityZoneCount,
  });

  factory AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainElasticsearchClusterConfigZoneAwarenessConfigDetails(
      availabilityZoneCount: json['AvailabilityZoneCount'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZoneCount = this.availabilityZoneCount;
    return {
      if (availabilityZoneCount != null)
        'AvailabilityZoneCount': availabilityZoneCount,
    };
  }
}

/// Details about the configuration for encryption at rest.
class AwsElasticsearchDomainEncryptionAtRestOptions {
  /// Whether encryption at rest is enabled.
  final bool? enabled;

  /// The KMS key ID. Takes the form
  /// <code>1a2a3a4-1a2a-3a4a-5a6a-1a2a3a4a5a6a</code>.
  final String? kmsKeyId;

  AwsElasticsearchDomainEncryptionAtRestOptions({
    this.enabled,
    this.kmsKeyId,
  });

  factory AwsElasticsearchDomainEncryptionAtRestOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainEncryptionAtRestOptions(
      enabled: json['Enabled'] as bool?,
      kmsKeyId: json['KmsKeyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final kmsKeyId = this.kmsKeyId;
    return {
      if (enabled != null) 'Enabled': enabled,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
    };
  }
}

/// configures the CloudWatch Logs to publish for the Elasticsearch domain.
class AwsElasticsearchDomainLogPublishingOptions {
  final AwsElasticsearchDomainLogPublishingOptionsLogConfig? auditLogs;

  /// Configures the OpenSearch index logs publishing.
  final AwsElasticsearchDomainLogPublishingOptionsLogConfig? indexSlowLogs;

  /// Configures the OpenSearch search slow log publishing.
  final AwsElasticsearchDomainLogPublishingOptionsLogConfig? searchSlowLogs;

  AwsElasticsearchDomainLogPublishingOptions({
    this.auditLogs,
    this.indexSlowLogs,
    this.searchSlowLogs,
  });

  factory AwsElasticsearchDomainLogPublishingOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainLogPublishingOptions(
      auditLogs: json['AuditLogs'] != null
          ? AwsElasticsearchDomainLogPublishingOptionsLogConfig.fromJson(
              json['AuditLogs'] as Map<String, dynamic>)
          : null,
      indexSlowLogs: json['IndexSlowLogs'] != null
          ? AwsElasticsearchDomainLogPublishingOptionsLogConfig.fromJson(
              json['IndexSlowLogs'] as Map<String, dynamic>)
          : null,
      searchSlowLogs: json['SearchSlowLogs'] != null
          ? AwsElasticsearchDomainLogPublishingOptionsLogConfig.fromJson(
              json['SearchSlowLogs'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final auditLogs = this.auditLogs;
    final indexSlowLogs = this.indexSlowLogs;
    final searchSlowLogs = this.searchSlowLogs;
    return {
      if (auditLogs != null) 'AuditLogs': auditLogs,
      if (indexSlowLogs != null) 'IndexSlowLogs': indexSlowLogs,
      if (searchSlowLogs != null) 'SearchSlowLogs': searchSlowLogs,
    };
  }
}

/// The log configuration.
class AwsElasticsearchDomainLogPublishingOptionsLogConfig {
  /// The ARN of the CloudWatch Logs group to publish the logs to.
  final String? cloudWatchLogsLogGroupArn;

  /// Whether the log publishing is enabled.
  final bool? enabled;

  AwsElasticsearchDomainLogPublishingOptionsLogConfig({
    this.cloudWatchLogsLogGroupArn,
    this.enabled,
  });

  factory AwsElasticsearchDomainLogPublishingOptionsLogConfig.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainLogPublishingOptionsLogConfig(
      cloudWatchLogsLogGroupArn: json['CloudWatchLogsLogGroupArn'] as String?,
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsLogGroupArn = this.cloudWatchLogsLogGroupArn;
    final enabled = this.enabled;
    return {
      if (cloudWatchLogsLogGroupArn != null)
        'CloudWatchLogsLogGroupArn': cloudWatchLogsLogGroupArn,
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Details about the configuration for node-to-node encryption.
class AwsElasticsearchDomainNodeToNodeEncryptionOptions {
  /// Whether node-to-node encryption is enabled.
  final bool? enabled;

  AwsElasticsearchDomainNodeToNodeEncryptionOptions({
    this.enabled,
  });

  factory AwsElasticsearchDomainNodeToNodeEncryptionOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainNodeToNodeEncryptionOptions(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Information about the state of the domain relative to the latest service
/// software.
class AwsElasticsearchDomainServiceSoftwareOptions {
  /// The epoch time when the deployment window closes for required updates. After
  /// this time, Amazon OpenSearch Service schedules the software upgrade
  /// automatically.
  final String? automatedUpdateDate;

  /// Whether a request to update the domain can be canceled.
  final bool? cancellable;

  /// The version of the service software that is currently installed on the
  /// domain.
  final String? currentVersion;

  /// A more detailed description of the service software status.
  final String? description;

  /// The most recent version of the service software.
  final String? newVersion;

  /// Whether a service software update is available for the domain.
  final bool? updateAvailable;

  /// The status of the service software update. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>COMPLETED</code>
  /// </li>
  /// <li>
  /// <code>ELIGIBLE</code>
  /// </li>
  /// <li>
  /// <code>IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>NOT_ELIGIBLE</code>
  /// </li>
  /// <li>
  /// <code>PENDING_UPDATE</code>
  /// </li>
  /// </ul>
  final String? updateStatus;

  AwsElasticsearchDomainServiceSoftwareOptions({
    this.automatedUpdateDate,
    this.cancellable,
    this.currentVersion,
    this.description,
    this.newVersion,
    this.updateAvailable,
    this.updateStatus,
  });

  factory AwsElasticsearchDomainServiceSoftwareOptions.fromJson(
      Map<String, dynamic> json) {
    return AwsElasticsearchDomainServiceSoftwareOptions(
      automatedUpdateDate: json['AutomatedUpdateDate'] as String?,
      cancellable: json['Cancellable'] as bool?,
      currentVersion: json['CurrentVersion'] as String?,
      description: json['Description'] as String?,
      newVersion: json['NewVersion'] as String?,
      updateAvailable: json['UpdateAvailable'] as bool?,
      updateStatus: json['UpdateStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final automatedUpdateDate = this.automatedUpdateDate;
    final cancellable = this.cancellable;
    final currentVersion = this.currentVersion;
    final description = this.description;
    final newVersion = this.newVersion;
    final updateAvailable = this.updateAvailable;
    final updateStatus = this.updateStatus;
    return {
      if (automatedUpdateDate != null)
        'AutomatedUpdateDate': automatedUpdateDate,
      if (cancellable != null) 'Cancellable': cancellable,
      if (currentVersion != null) 'CurrentVersion': currentVersion,
      if (description != null) 'Description': description,
      if (newVersion != null) 'NewVersion': newVersion,
      if (updateAvailable != null) 'UpdateAvailable': updateAvailable,
      if (updateStatus != null) 'UpdateStatus': updateStatus,
    };
  }
}

/// Information that OpenSearch derives based on <code>VPCOptions</code> for the
/// domain.
class AwsElasticsearchDomainVPCOptions {
  /// The list of Availability Zones associated with the VPC subnets.
  final List<String>? availabilityZones;

  /// The list of security group IDs associated with the VPC endpoints for the
  /// domain.
  final List<String>? securityGroupIds;

  /// A list of subnet IDs associated with the VPC endpoints for the domain.
  final List<String>? subnetIds;

  /// ID for the VPC.
  final String? vPCId;

  AwsElasticsearchDomainVPCOptions({
    this.availabilityZones,
    this.securityGroupIds,
    this.subnetIds,
    this.vPCId,
  });

  factory AwsElasticsearchDomainVPCOptions.fromJson(Map<String, dynamic> json) {
    return AwsElasticsearchDomainVPCOptions(
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnetIds: (json['SubnetIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      vPCId: json['VPCId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZones = this.availabilityZones;
    final securityGroupIds = this.securityGroupIds;
    final subnetIds = this.subnetIds;
    final vPCId = this.vPCId;
    return {
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (subnetIds != null) 'SubnetIds': subnetIds,
      if (vPCId != null) 'VPCId': vPCId,
    };
  }
}

/// Contains information about a stickiness policy that was created using
/// <code>CreateAppCookieStickinessPolicy</code>.
class AwsElbAppCookieStickinessPolicy {
  /// The name of the application cookie used for stickiness.
  final String? cookieName;

  /// The mnemonic name for the policy being created. The name must be unique
  /// within the set of policies for the load balancer.
  final String? policyName;

  AwsElbAppCookieStickinessPolicy({
    this.cookieName,
    this.policyName,
  });

  factory AwsElbAppCookieStickinessPolicy.fromJson(Map<String, dynamic> json) {
    return AwsElbAppCookieStickinessPolicy(
      cookieName: json['CookieName'] as String?,
      policyName: json['PolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cookieName = this.cookieName;
    final policyName = this.policyName;
    return {
      if (cookieName != null) 'CookieName': cookieName,
      if (policyName != null) 'PolicyName': policyName,
    };
  }
}

/// Contains information about a stickiness policy that was created using
/// <code>CreateLBCookieStickinessPolicy</code>.
class AwsElbLbCookieStickinessPolicy {
  /// The amount of time, in seconds, after which the cookie is considered stale.
  /// If an expiration period is not specified, the stickiness session lasts for
  /// the duration of the browser session.
  final int? cookieExpirationPeriod;

  /// The name of the policy. The name must be unique within the set of policies
  /// for the load balancer.
  final String? policyName;

  AwsElbLbCookieStickinessPolicy({
    this.cookieExpirationPeriod,
    this.policyName,
  });

  factory AwsElbLbCookieStickinessPolicy.fromJson(Map<String, dynamic> json) {
    return AwsElbLbCookieStickinessPolicy(
      cookieExpirationPeriod: json['CookieExpirationPeriod'] as int?,
      policyName: json['PolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cookieExpirationPeriod = this.cookieExpirationPeriod;
    final policyName = this.policyName;
    return {
      if (cookieExpirationPeriod != null)
        'CookieExpirationPeriod': cookieExpirationPeriod,
      if (policyName != null) 'PolicyName': policyName,
    };
  }
}

/// Contains information about the access log configuration for the load
/// balancer.
class AwsElbLoadBalancerAccessLog {
  /// The interval in minutes for publishing the access logs.
  ///
  /// You can publish access logs either every 5 minutes or every 60 minutes.
  final int? emitInterval;

  /// Indicates whether access logs are enabled for the load balancer.
  final bool? enabled;

  /// The name of the S3 bucket where the access logs are stored.
  final String? s3BucketName;

  /// The logical hierarchy that was created for the S3 bucket.
  ///
  /// If a prefix is not provided, the log is placed at the root level of the
  /// bucket.
  final String? s3BucketPrefix;

  AwsElbLoadBalancerAccessLog({
    this.emitInterval,
    this.enabled,
    this.s3BucketName,
    this.s3BucketPrefix,
  });

  factory AwsElbLoadBalancerAccessLog.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerAccessLog(
      emitInterval: json['EmitInterval'] as int?,
      enabled: json['Enabled'] as bool?,
      s3BucketName: json['S3BucketName'] as String?,
      s3BucketPrefix: json['S3BucketPrefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final emitInterval = this.emitInterval;
    final enabled = this.enabled;
    final s3BucketName = this.s3BucketName;
    final s3BucketPrefix = this.s3BucketPrefix;
    return {
      if (emitInterval != null) 'EmitInterval': emitInterval,
      if (enabled != null) 'Enabled': enabled,
      if (s3BucketName != null) 'S3BucketName': s3BucketName,
      if (s3BucketPrefix != null) 'S3BucketPrefix': s3BucketPrefix,
    };
  }
}

/// Provides information about additional attributes for the load balancer.
class AwsElbLoadBalancerAdditionalAttribute {
  /// The name of the attribute.
  final String? key;

  /// The value of the attribute.
  final String? value;

  AwsElbLoadBalancerAdditionalAttribute({
    this.key,
    this.value,
  });

  factory AwsElbLoadBalancerAdditionalAttribute.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerAdditionalAttribute(
      key: json['Key'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      if (key != null) 'Key': key,
      if (value != null) 'Value': value,
    };
  }
}

/// Contains attributes for the load balancer.
class AwsElbLoadBalancerAttributes {
  /// Information about the access log configuration for the load balancer.
  ///
  /// If the access log is enabled, the load balancer captures detailed
  /// information about all requests. It delivers the information to a specified
  /// S3 bucket.
  final AwsElbLoadBalancerAccessLog? accessLog;

  /// Any additional attributes for a load balancer.
  final List<AwsElbLoadBalancerAdditionalAttribute>? additionalAttributes;

  /// Information about the connection draining configuration for the load
  /// balancer.
  ///
  /// If connection draining is enabled, the load balancer allows existing
  /// requests to complete before it shifts traffic away from a deregistered or
  /// unhealthy instance.
  final AwsElbLoadBalancerConnectionDraining? connectionDraining;

  /// Connection settings for the load balancer.
  ///
  /// If an idle timeout is configured, the load balancer allows connections to
  /// remain idle for the specified duration. When a connection is idle, no data
  /// is sent over the connection.
  final AwsElbLoadBalancerConnectionSettings? connectionSettings;

  /// Cross-zone load balancing settings for the load balancer.
  ///
  /// If cross-zone load balancing is enabled, the load balancer routes the
  /// request traffic evenly across all instances regardless of the Availability
  /// Zones.
  final AwsElbLoadBalancerCrossZoneLoadBalancing? crossZoneLoadBalancing;

  AwsElbLoadBalancerAttributes({
    this.accessLog,
    this.additionalAttributes,
    this.connectionDraining,
    this.connectionSettings,
    this.crossZoneLoadBalancing,
  });

  factory AwsElbLoadBalancerAttributes.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerAttributes(
      accessLog: json['AccessLog'] != null
          ? AwsElbLoadBalancerAccessLog.fromJson(
              json['AccessLog'] as Map<String, dynamic>)
          : null,
      additionalAttributes: (json['AdditionalAttributes'] as List?)
          ?.whereNotNull()
          .map((e) => AwsElbLoadBalancerAdditionalAttribute.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      connectionDraining: json['ConnectionDraining'] != null
          ? AwsElbLoadBalancerConnectionDraining.fromJson(
              json['ConnectionDraining'] as Map<String, dynamic>)
          : null,
      connectionSettings: json['ConnectionSettings'] != null
          ? AwsElbLoadBalancerConnectionSettings.fromJson(
              json['ConnectionSettings'] as Map<String, dynamic>)
          : null,
      crossZoneLoadBalancing: json['CrossZoneLoadBalancing'] != null
          ? AwsElbLoadBalancerCrossZoneLoadBalancing.fromJson(
              json['CrossZoneLoadBalancing'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessLog = this.accessLog;
    final additionalAttributes = this.additionalAttributes;
    final connectionDraining = this.connectionDraining;
    final connectionSettings = this.connectionSettings;
    final crossZoneLoadBalancing = this.crossZoneLoadBalancing;
    return {
      if (accessLog != null) 'AccessLog': accessLog,
      if (additionalAttributes != null)
        'AdditionalAttributes': additionalAttributes,
      if (connectionDraining != null) 'ConnectionDraining': connectionDraining,
      if (connectionSettings != null) 'ConnectionSettings': connectionSettings,
      if (crossZoneLoadBalancing != null)
        'CrossZoneLoadBalancing': crossZoneLoadBalancing,
    };
  }
}

/// Provides information about the configuration of an EC2 instance for the load
/// balancer.
class AwsElbLoadBalancerBackendServerDescription {
  /// The port on which the EC2 instance is listening.
  final int? instancePort;

  /// The names of the policies that are enabled for the EC2 instance.
  final List<String>? policyNames;

  AwsElbLoadBalancerBackendServerDescription({
    this.instancePort,
    this.policyNames,
  });

  factory AwsElbLoadBalancerBackendServerDescription.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerBackendServerDescription(
      instancePort: json['InstancePort'] as int?,
      policyNames: (json['PolicyNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final instancePort = this.instancePort;
    final policyNames = this.policyNames;
    return {
      if (instancePort != null) 'InstancePort': instancePort,
      if (policyNames != null) 'PolicyNames': policyNames,
    };
  }
}

/// Contains information about the connection draining configuration for the
/// load balancer.
class AwsElbLoadBalancerConnectionDraining {
  /// Indicates whether connection draining is enabled for the load balancer.
  final bool? enabled;

  /// The maximum time, in seconds, to keep the existing connections open before
  /// deregistering the instances.
  final int? timeout;

  AwsElbLoadBalancerConnectionDraining({
    this.enabled,
    this.timeout,
  });

  factory AwsElbLoadBalancerConnectionDraining.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerConnectionDraining(
      enabled: json['Enabled'] as bool?,
      timeout: json['Timeout'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final timeout = this.timeout;
    return {
      if (enabled != null) 'Enabled': enabled,
      if (timeout != null) 'Timeout': timeout,
    };
  }
}

/// Contains connection settings for the load balancer.
class AwsElbLoadBalancerConnectionSettings {
  /// The time, in seconds, that the connection can be idle (no data is sent over
  /// the connection) before it is closed by the load balancer.
  final int? idleTimeout;

  AwsElbLoadBalancerConnectionSettings({
    this.idleTimeout,
  });

  factory AwsElbLoadBalancerConnectionSettings.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerConnectionSettings(
      idleTimeout: json['IdleTimeout'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final idleTimeout = this.idleTimeout;
    return {
      if (idleTimeout != null) 'IdleTimeout': idleTimeout,
    };
  }
}

/// Contains cross-zone load balancing settings for the load balancer.
class AwsElbLoadBalancerCrossZoneLoadBalancing {
  /// Indicates whether cross-zone load balancing is enabled for the load
  /// balancer.
  final bool? enabled;

  AwsElbLoadBalancerCrossZoneLoadBalancing({
    this.enabled,
  });

  factory AwsElbLoadBalancerCrossZoneLoadBalancing.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerCrossZoneLoadBalancing(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Contains details about a Classic Load Balancer.
class AwsElbLoadBalancerDetails {
  /// The list of Availability Zones for the load balancer.
  final List<String>? availabilityZones;

  /// Information about the configuration of the EC2 instances.
  final List<AwsElbLoadBalancerBackendServerDescription>?
      backendServerDescriptions;

  /// The name of the Amazon Route 53 hosted zone for the load balancer.
  final String? canonicalHostedZoneName;

  /// The ID of the Amazon Route 53 hosted zone for the load balancer.
  final String? canonicalHostedZoneNameID;

  /// Indicates when the load balancer was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdTime;

  /// The DNS name of the load balancer.
  final String? dnsName;

  /// Information about the health checks that are conducted on the load balancer.
  final AwsElbLoadBalancerHealthCheck? healthCheck;

  /// List of EC2 instances for the load balancer.
  final List<AwsElbLoadBalancerInstance>? instances;

  /// The policies that are enabled for the load balancer listeners.
  final List<AwsElbLoadBalancerListenerDescription>? listenerDescriptions;

  /// The attributes for a load balancer.
  final AwsElbLoadBalancerAttributes? loadBalancerAttributes;

  /// The name of the load balancer.
  final String? loadBalancerName;

  /// The policies for a load balancer.
  final AwsElbLoadBalancerPolicies? policies;

  /// The type of load balancer. Only provided if the load balancer is in a VPC.
  ///
  /// If <code>Scheme</code> is <code>internet-facing</code>, the load balancer
  /// has a public DNS name that resolves to a public IP address.
  ///
  /// If <code>Scheme</code> is <code>internal</code>, the load balancer has a
  /// public DNS name that resolves to a private IP address.
  final String? scheme;

  /// The security groups for the load balancer. Only provided if the load
  /// balancer is in a VPC.
  final List<String>? securityGroups;

  /// Information about the security group for the load balancer. This is the
  /// security group that is used for inbound rules.
  final AwsElbLoadBalancerSourceSecurityGroup? sourceSecurityGroup;

  /// The list of subnet identifiers for the load balancer.
  final List<String>? subnets;

  /// The identifier of the VPC for the load balancer.
  final String? vpcId;

  AwsElbLoadBalancerDetails({
    this.availabilityZones,
    this.backendServerDescriptions,
    this.canonicalHostedZoneName,
    this.canonicalHostedZoneNameID,
    this.createdTime,
    this.dnsName,
    this.healthCheck,
    this.instances,
    this.listenerDescriptions,
    this.loadBalancerAttributes,
    this.loadBalancerName,
    this.policies,
    this.scheme,
    this.securityGroups,
    this.sourceSecurityGroup,
    this.subnets,
    this.vpcId,
  });

  factory AwsElbLoadBalancerDetails.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerDetails(
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      backendServerDescriptions: (json['BackendServerDescriptions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsElbLoadBalancerBackendServerDescription.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      canonicalHostedZoneName: json['CanonicalHostedZoneName'] as String?,
      canonicalHostedZoneNameID: json['CanonicalHostedZoneNameID'] as String?,
      createdTime: json['CreatedTime'] as String?,
      dnsName: json['DnsName'] as String?,
      healthCheck: json['HealthCheck'] != null
          ? AwsElbLoadBalancerHealthCheck.fromJson(
              json['HealthCheck'] as Map<String, dynamic>)
          : null,
      instances: (json['Instances'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsElbLoadBalancerInstance.fromJson(e as Map<String, dynamic>))
          .toList(),
      listenerDescriptions: (json['ListenerDescriptions'] as List?)
          ?.whereNotNull()
          .map((e) => AwsElbLoadBalancerListenerDescription.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      loadBalancerAttributes: json['LoadBalancerAttributes'] != null
          ? AwsElbLoadBalancerAttributes.fromJson(
              json['LoadBalancerAttributes'] as Map<String, dynamic>)
          : null,
      loadBalancerName: json['LoadBalancerName'] as String?,
      policies: json['Policies'] != null
          ? AwsElbLoadBalancerPolicies.fromJson(
              json['Policies'] as Map<String, dynamic>)
          : null,
      scheme: json['Scheme'] as String?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      sourceSecurityGroup: json['SourceSecurityGroup'] != null
          ? AwsElbLoadBalancerSourceSecurityGroup.fromJson(
              json['SourceSecurityGroup'] as Map<String, dynamic>)
          : null,
      subnets: (json['Subnets'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZones = this.availabilityZones;
    final backendServerDescriptions = this.backendServerDescriptions;
    final canonicalHostedZoneName = this.canonicalHostedZoneName;
    final canonicalHostedZoneNameID = this.canonicalHostedZoneNameID;
    final createdTime = this.createdTime;
    final dnsName = this.dnsName;
    final healthCheck = this.healthCheck;
    final instances = this.instances;
    final listenerDescriptions = this.listenerDescriptions;
    final loadBalancerAttributes = this.loadBalancerAttributes;
    final loadBalancerName = this.loadBalancerName;
    final policies = this.policies;
    final scheme = this.scheme;
    final securityGroups = this.securityGroups;
    final sourceSecurityGroup = this.sourceSecurityGroup;
    final subnets = this.subnets;
    final vpcId = this.vpcId;
    return {
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (backendServerDescriptions != null)
        'BackendServerDescriptions': backendServerDescriptions,
      if (canonicalHostedZoneName != null)
        'CanonicalHostedZoneName': canonicalHostedZoneName,
      if (canonicalHostedZoneNameID != null)
        'CanonicalHostedZoneNameID': canonicalHostedZoneNameID,
      if (createdTime != null) 'CreatedTime': createdTime,
      if (dnsName != null) 'DnsName': dnsName,
      if (healthCheck != null) 'HealthCheck': healthCheck,
      if (instances != null) 'Instances': instances,
      if (listenerDescriptions != null)
        'ListenerDescriptions': listenerDescriptions,
      if (loadBalancerAttributes != null)
        'LoadBalancerAttributes': loadBalancerAttributes,
      if (loadBalancerName != null) 'LoadBalancerName': loadBalancerName,
      if (policies != null) 'Policies': policies,
      if (scheme != null) 'Scheme': scheme,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (sourceSecurityGroup != null)
        'SourceSecurityGroup': sourceSecurityGroup,
      if (subnets != null) 'Subnets': subnets,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Contains information about the health checks that are conducted on the load
/// balancer.
class AwsElbLoadBalancerHealthCheck {
  /// The number of consecutive health check successes required before the
  /// instance is moved to the Healthy state.
  final int? healthyThreshold;

  /// The approximate interval, in seconds, between health checks of an individual
  /// instance.
  final int? interval;

  /// The instance that is being checked. The target specifies the protocol and
  /// port. The available protocols are TCP, SSL, HTTP, and HTTPS. The range of
  /// valid ports is 1 through 65535.
  ///
  /// For the HTTP and HTTPS protocols, the target also specifies the ping path.
  ///
  /// For the TCP protocol, the target is specified as <code>TCP:
  /// <i>&lt;port&gt;</i> </code>.
  ///
  /// For the SSL protocol, the target is specified as
  /// <code>SSL.<i>&lt;port&gt;</i> </code>.
  ///
  /// For the HTTP and HTTPS protocols, the target is specified as <code>
  /// <i>&lt;protocol&gt;</i>:<i>&lt;port&gt;</i>/<i>&lt;path to ping&gt;</i>
  /// </code>.
  final String? target;

  /// The amount of time, in seconds, during which no response means a failed
  /// health check.
  final int? timeout;

  /// The number of consecutive health check failures that must occur before the
  /// instance is moved to the Unhealthy state.
  final int? unhealthyThreshold;

  AwsElbLoadBalancerHealthCheck({
    this.healthyThreshold,
    this.interval,
    this.target,
    this.timeout,
    this.unhealthyThreshold,
  });

  factory AwsElbLoadBalancerHealthCheck.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerHealthCheck(
      healthyThreshold: json['HealthyThreshold'] as int?,
      interval: json['Interval'] as int?,
      target: json['Target'] as String?,
      timeout: json['Timeout'] as int?,
      unhealthyThreshold: json['UnhealthyThreshold'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final healthyThreshold = this.healthyThreshold;
    final interval = this.interval;
    final target = this.target;
    final timeout = this.timeout;
    final unhealthyThreshold = this.unhealthyThreshold;
    return {
      if (healthyThreshold != null) 'HealthyThreshold': healthyThreshold,
      if (interval != null) 'Interval': interval,
      if (target != null) 'Target': target,
      if (timeout != null) 'Timeout': timeout,
      if (unhealthyThreshold != null) 'UnhealthyThreshold': unhealthyThreshold,
    };
  }
}

/// Provides information about an EC2 instance for a load balancer.
class AwsElbLoadBalancerInstance {
  /// The instance identifier.
  final String? instanceId;

  AwsElbLoadBalancerInstance({
    this.instanceId,
  });

  factory AwsElbLoadBalancerInstance.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerInstance(
      instanceId: json['InstanceId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final instanceId = this.instanceId;
    return {
      if (instanceId != null) 'InstanceId': instanceId,
    };
  }
}

/// Information about a load balancer listener.
class AwsElbLoadBalancerListener {
  /// The port on which the instance is listening.
  final int? instancePort;

  /// The protocol to use to route traffic to instances.
  ///
  /// Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> |
  /// <code>SSL</code>
  final String? instanceProtocol;

  /// The port on which the load balancer is listening.
  ///
  /// On EC2-VPC, you can specify any port from the range 1-65535.
  ///
  /// On EC2-Classic, you can specify any port from the following list: 25, 80,
  /// 443, 465, 587, 1024-65535.
  final int? loadBalancerPort;

  /// The load balancer transport protocol to use for routing.
  ///
  /// Valid values: <code>HTTP</code> | <code>HTTPS</code> | <code>TCP</code> |
  /// <code>SSL</code>
  final String? protocol;

  /// The ARN of the server certificate.
  final String? sslCertificateId;

  AwsElbLoadBalancerListener({
    this.instancePort,
    this.instanceProtocol,
    this.loadBalancerPort,
    this.protocol,
    this.sslCertificateId,
  });

  factory AwsElbLoadBalancerListener.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerListener(
      instancePort: json['InstancePort'] as int?,
      instanceProtocol: json['InstanceProtocol'] as String?,
      loadBalancerPort: json['LoadBalancerPort'] as int?,
      protocol: json['Protocol'] as String?,
      sslCertificateId: json['SslCertificateId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final instancePort = this.instancePort;
    final instanceProtocol = this.instanceProtocol;
    final loadBalancerPort = this.loadBalancerPort;
    final protocol = this.protocol;
    final sslCertificateId = this.sslCertificateId;
    return {
      if (instancePort != null) 'InstancePort': instancePort,
      if (instanceProtocol != null) 'InstanceProtocol': instanceProtocol,
      if (loadBalancerPort != null) 'LoadBalancerPort': loadBalancerPort,
      if (protocol != null) 'Protocol': protocol,
      if (sslCertificateId != null) 'SslCertificateId': sslCertificateId,
    };
  }
}

/// Lists the policies that are enabled for a load balancer listener.
class AwsElbLoadBalancerListenerDescription {
  /// Information about the listener.
  final AwsElbLoadBalancerListener? listener;

  /// The policies enabled for the listener.
  final List<String>? policyNames;

  AwsElbLoadBalancerListenerDescription({
    this.listener,
    this.policyNames,
  });

  factory AwsElbLoadBalancerListenerDescription.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerListenerDescription(
      listener: json['Listener'] != null
          ? AwsElbLoadBalancerListener.fromJson(
              json['Listener'] as Map<String, dynamic>)
          : null,
      policyNames: (json['PolicyNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final listener = this.listener;
    final policyNames = this.policyNames;
    return {
      if (listener != null) 'Listener': listener,
      if (policyNames != null) 'PolicyNames': policyNames,
    };
  }
}

/// Contains information about the policies for a load balancer.
class AwsElbLoadBalancerPolicies {
  /// The stickiness policies that are created using
  /// <code>CreateAppCookieStickinessPolicy</code>.
  final List<AwsElbAppCookieStickinessPolicy>? appCookieStickinessPolicies;

  /// The stickiness policies that are created using
  /// <code>CreateLBCookieStickinessPolicy</code>.
  final List<AwsElbLbCookieStickinessPolicy>? lbCookieStickinessPolicies;

  /// The policies other than the stickiness policies.
  final List<String>? otherPolicies;

  AwsElbLoadBalancerPolicies({
    this.appCookieStickinessPolicies,
    this.lbCookieStickinessPolicies,
    this.otherPolicies,
  });

  factory AwsElbLoadBalancerPolicies.fromJson(Map<String, dynamic> json) {
    return AwsElbLoadBalancerPolicies(
      appCookieStickinessPolicies:
          (json['AppCookieStickinessPolicies'] as List?)
              ?.whereNotNull()
              .map((e) => AwsElbAppCookieStickinessPolicy.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      lbCookieStickinessPolicies: (json['LbCookieStickinessPolicies'] as List?)
          ?.whereNotNull()
          .map((e) => AwsElbLbCookieStickinessPolicy.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      otherPolicies: (json['OtherPolicies'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final appCookieStickinessPolicies = this.appCookieStickinessPolicies;
    final lbCookieStickinessPolicies = this.lbCookieStickinessPolicies;
    final otherPolicies = this.otherPolicies;
    return {
      if (appCookieStickinessPolicies != null)
        'AppCookieStickinessPolicies': appCookieStickinessPolicies,
      if (lbCookieStickinessPolicies != null)
        'LbCookieStickinessPolicies': lbCookieStickinessPolicies,
      if (otherPolicies != null) 'OtherPolicies': otherPolicies,
    };
  }
}

/// Contains information about the security group for the load balancer.
class AwsElbLoadBalancerSourceSecurityGroup {
  /// The name of the security group.
  final String? groupName;

  /// The owner of the security group.
  final String? ownerAlias;

  AwsElbLoadBalancerSourceSecurityGroup({
    this.groupName,
    this.ownerAlias,
  });

  factory AwsElbLoadBalancerSourceSecurityGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsElbLoadBalancerSourceSecurityGroup(
      groupName: json['GroupName'] as String?,
      ownerAlias: json['OwnerAlias'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupName = this.groupName;
    final ownerAlias = this.ownerAlias;
    return {
      if (groupName != null) 'GroupName': groupName,
      if (ownerAlias != null) 'OwnerAlias': ownerAlias,
    };
  }
}

/// A load balancer attribute.
class AwsElbv2LoadBalancerAttribute {
  /// The name of the load balancer attribute.
  final String? key;

  /// The value of the load balancer attribute.
  final String? value;

  AwsElbv2LoadBalancerAttribute({
    this.key,
    this.value,
  });

  factory AwsElbv2LoadBalancerAttribute.fromJson(Map<String, dynamic> json) {
    return AwsElbv2LoadBalancerAttribute(
      key: json['Key'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      if (key != null) 'Key': key,
      if (value != null) 'Value': value,
    };
  }
}

/// Information about a load balancer.
class AwsElbv2LoadBalancerDetails {
  /// The Availability Zones for the load balancer.
  final List<AvailabilityZone>? availabilityZones;

  /// The ID of the Amazon Route 53 hosted zone associated with the load balancer.
  final String? canonicalHostedZoneId;

  /// Indicates when the load balancer was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdTime;

  /// The public DNS name of the load balancer.
  final String? dNSName;

  /// The type of IP addresses used by the subnets for your load balancer. The
  /// possible values are <code>ipv4</code> (for IPv4 addresses) and
  /// <code>dualstack</code> (for IPv4 and IPv6 addresses).
  final String? ipAddressType;

  /// Attributes of the load balancer.
  final List<AwsElbv2LoadBalancerAttribute>? loadBalancerAttributes;

  /// The nodes of an Internet-facing load balancer have public IP addresses.
  final String? scheme;

  /// The IDs of the security groups for the load balancer.
  final List<String>? securityGroups;

  /// The state of the load balancer.
  final LoadBalancerState? state;

  /// The type of load balancer.
  final String? type;

  /// The ID of the VPC for the load balancer.
  final String? vpcId;

  AwsElbv2LoadBalancerDetails({
    this.availabilityZones,
    this.canonicalHostedZoneId,
    this.createdTime,
    this.dNSName,
    this.ipAddressType,
    this.loadBalancerAttributes,
    this.scheme,
    this.securityGroups,
    this.state,
    this.type,
    this.vpcId,
  });

  factory AwsElbv2LoadBalancerDetails.fromJson(Map<String, dynamic> json) {
    return AwsElbv2LoadBalancerDetails(
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => AvailabilityZone.fromJson(e as Map<String, dynamic>))
          .toList(),
      canonicalHostedZoneId: json['CanonicalHostedZoneId'] as String?,
      createdTime: json['CreatedTime'] as String?,
      dNSName: json['DNSName'] as String?,
      ipAddressType: json['IpAddressType'] as String?,
      loadBalancerAttributes: (json['LoadBalancerAttributes'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsElbv2LoadBalancerAttribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      scheme: json['Scheme'] as String?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      state: json['State'] != null
          ? LoadBalancerState.fromJson(json['State'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZones = this.availabilityZones;
    final canonicalHostedZoneId = this.canonicalHostedZoneId;
    final createdTime = this.createdTime;
    final dNSName = this.dNSName;
    final ipAddressType = this.ipAddressType;
    final loadBalancerAttributes = this.loadBalancerAttributes;
    final scheme = this.scheme;
    final securityGroups = this.securityGroups;
    final state = this.state;
    final type = this.type;
    final vpcId = this.vpcId;
    return {
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (canonicalHostedZoneId != null)
        'CanonicalHostedZoneId': canonicalHostedZoneId,
      if (createdTime != null) 'CreatedTime': createdTime,
      if (dNSName != null) 'DNSName': dNSName,
      if (ipAddressType != null) 'IpAddressType': ipAddressType,
      if (loadBalancerAttributes != null)
        'LoadBalancerAttributes': loadBalancerAttributes,
      if (scheme != null) 'Scheme': scheme,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (state != null) 'State': state,
      if (type != null) 'Type': type,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// A schema defines the structure of events that are sent to Amazon
/// EventBridge. Schema registries are containers for schemas. They collect and
/// organize schemas so that your schemas are in logical groups.
class AwsEventSchemasRegistryDetails {
  /// A description of the registry to be created.
  final String? description;

  /// The Amazon Resource Name (ARN) of the registry.
  final String? registryArn;

  /// The name of the schema registry.
  final String? registryName;

  AwsEventSchemasRegistryDetails({
    this.description,
    this.registryArn,
    this.registryName,
  });

  factory AwsEventSchemasRegistryDetails.fromJson(Map<String, dynamic> json) {
    return AwsEventSchemasRegistryDetails(
      description: json['Description'] as String?,
      registryArn: json['RegistryArn'] as String?,
      registryName: json['RegistryName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final registryArn = this.registryArn;
    final registryName = this.registryName;
    return {
      if (description != null) 'Description': description,
      if (registryArn != null) 'RegistryArn': registryArn,
      if (registryName != null) 'RegistryName': registryName,
    };
  }
}

/// Provides details about an Amazon EventBridge global endpoint. The endpoint
/// can improve your application’s availability by making it Regional-fault
/// tolerant.
class AwsEventsEndpointDetails {
  /// The Amazon Resource Name (ARN) of the endpoint.
  final String? arn;

  /// A description of the endpoint.
  final String? description;

  /// The URL subdomain of the endpoint. For example, if <code>EndpointUrl</code>
  /// is <code>https://abcde.veo.endpoints.event.amazonaws.com</code>, then the
  /// <code>EndpointId</code> is <code>abcde.veo</code>.
  final String? endpointId;

  /// The URL of the endpoint.
  final String? endpointUrl;

  /// The event buses being used by the endpoint.
  final List<AwsEventsEndpointEventBusesDetails>? eventBuses;

  /// The name of the endpoint.
  final String? name;

  /// Whether event replication was enabled or disabled for this endpoint. The
  /// default state is <code>ENABLED</code>, which means you must supply a
  /// <code>RoleArn</code>. If you don't have a <code>RoleArn</code> or you don't
  /// want event replication enabled, set the state to <code>DISABLED</code>.
  final AwsEventsEndpointReplicationConfigDetails? replicationConfig;

  /// The ARN of the role used by event replication for the endpoint.
  final String? roleArn;

  /// The routing configuration of the endpoint.
  final AwsEventsEndpointRoutingConfigDetails? routingConfig;

  /// The current state of the endpoint.
  final String? state;

  /// The reason the endpoint is in its current state.
  final String? stateReason;

  AwsEventsEndpointDetails({
    this.arn,
    this.description,
    this.endpointId,
    this.endpointUrl,
    this.eventBuses,
    this.name,
    this.replicationConfig,
    this.roleArn,
    this.routingConfig,
    this.state,
    this.stateReason,
  });

  factory AwsEventsEndpointDetails.fromJson(Map<String, dynamic> json) {
    return AwsEventsEndpointDetails(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      endpointId: json['EndpointId'] as String?,
      endpointUrl: json['EndpointUrl'] as String?,
      eventBuses: (json['EventBuses'] as List?)
          ?.whereNotNull()
          .map((e) => AwsEventsEndpointEventBusesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      replicationConfig: json['ReplicationConfig'] != null
          ? AwsEventsEndpointReplicationConfigDetails.fromJson(
              json['ReplicationConfig'] as Map<String, dynamic>)
          : null,
      roleArn: json['RoleArn'] as String?,
      routingConfig: json['RoutingConfig'] != null
          ? AwsEventsEndpointRoutingConfigDetails.fromJson(
              json['RoutingConfig'] as Map<String, dynamic>)
          : null,
      state: json['State'] as String?,
      stateReason: json['StateReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final endpointId = this.endpointId;
    final endpointUrl = this.endpointUrl;
    final eventBuses = this.eventBuses;
    final name = this.name;
    final replicationConfig = this.replicationConfig;
    final roleArn = this.roleArn;
    final routingConfig = this.routingConfig;
    final state = this.state;
    final stateReason = this.stateReason;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (endpointId != null) 'EndpointId': endpointId,
      if (endpointUrl != null) 'EndpointUrl': endpointUrl,
      if (eventBuses != null) 'EventBuses': eventBuses,
      if (name != null) 'Name': name,
      if (replicationConfig != null) 'ReplicationConfig': replicationConfig,
      if (roleArn != null) 'RoleArn': roleArn,
      if (routingConfig != null) 'RoutingConfig': routingConfig,
      if (state != null) 'State': state,
      if (stateReason != null) 'StateReason': stateReason,
    };
  }
}

/// Provides details about the Amazon EventBridge event buses that the endpoint
/// is associated with.
class AwsEventsEndpointEventBusesDetails {
  /// The Amazon Resource Name (ARN) of the event bus that the endpoint is
  /// associated with.
  final String? eventBusArn;

  AwsEventsEndpointEventBusesDetails({
    this.eventBusArn,
  });

  factory AwsEventsEndpointEventBusesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEventsEndpointEventBusesDetails(
      eventBusArn: json['EventBusArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final eventBusArn = this.eventBusArn;
    return {
      if (eventBusArn != null) 'EventBusArn': eventBusArn,
    };
  }
}

/// Indicates whether replication is enabled or disabled for the endpoint. If
/// enabled, the endpoint can replicate all events to a secondary Amazon Web
/// Services Region.
class AwsEventsEndpointReplicationConfigDetails {
  /// The state of event replication.
  final String? state;

  AwsEventsEndpointReplicationConfigDetails({
    this.state,
  });

  factory AwsEventsEndpointReplicationConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEventsEndpointReplicationConfigDetails(
      state: json['State'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final state = this.state;
    return {
      if (state != null) 'State': state,
    };
  }
}

/// Provides details about the routing configuration of the endpoint.
class AwsEventsEndpointRoutingConfigDetails {
  /// The failover configuration for an endpoint. This includes what triggers
  /// failover and what happens when it's triggered.
  final AwsEventsEndpointRoutingConfigFailoverConfigDetails? failoverConfig;

  AwsEventsEndpointRoutingConfigDetails({
    this.failoverConfig,
  });

  factory AwsEventsEndpointRoutingConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEventsEndpointRoutingConfigDetails(
      failoverConfig: json['FailoverConfig'] != null
          ? AwsEventsEndpointRoutingConfigFailoverConfigDetails.fromJson(
              json['FailoverConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final failoverConfig = this.failoverConfig;
    return {
      if (failoverConfig != null) 'FailoverConfig': failoverConfig,
    };
  }
}

/// The failover configuration for an endpoint. This includes what triggers
/// failover and what happens when it's triggered.
class AwsEventsEndpointRoutingConfigFailoverConfigDetails {
  /// The main Region of the endpoint.
  final AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails? primary;

  /// The Region that events are routed to when failover is triggered or event
  /// replication is enabled.
  final AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails? secondary;

  AwsEventsEndpointRoutingConfigFailoverConfigDetails({
    this.primary,
    this.secondary,
  });

  factory AwsEventsEndpointRoutingConfigFailoverConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEventsEndpointRoutingConfigFailoverConfigDetails(
      primary: json['Primary'] != null
          ? AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails.fromJson(
              json['Primary'] as Map<String, dynamic>)
          : null,
      secondary: json['Secondary'] != null
          ? AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails
              .fromJson(json['Secondary'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final primary = this.primary;
    final secondary = this.secondary;
    return {
      if (primary != null) 'Primary': primary,
      if (secondary != null) 'Secondary': secondary,
    };
  }
}

/// Provides details about the primary Amazon Web Services Region of the
/// endpoint.
class AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails {
  /// The Amazon Resource Name (ARN) of the health check used by the endpoint to
  /// determine whether failover is triggered.
  final String? healthCheck;

  AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails({
    this.healthCheck,
  });

  factory AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEventsEndpointRoutingConfigFailoverConfigPrimaryDetails(
      healthCheck: json['HealthCheck'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final healthCheck = this.healthCheck;
    return {
      if (healthCheck != null) 'HealthCheck': healthCheck,
    };
  }
}

/// The Amazon Web Services Region that events are routed to when failover is
/// triggered or event replication is enabled.
class AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails {
  /// Defines the secondary Region.
  final String? route;

  AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails({
    this.route,
  });

  factory AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsEventsEndpointRoutingConfigFailoverConfigSecondaryDetails(
      route: json['Route'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final route = this.route;
    return {
      if (route != null) 'Route': route,
    };
  }
}

/// Provides details about Amazon EventBridge event bus. An event bus is a
/// router that receives events and delivers them to zero or more destinations,
/// or targets. This can be a custom event bus which you can use to receive
/// events from your custom applications and services, or it can be a partner
/// event bus which can be matched to a partner event source.
class AwsEventsEventbusDetails {
  /// The Amazon Resource Name (ARN) of the account permitted to write events to
  /// the current account.
  final String? arn;

  /// The name of the event bus.
  final String? name;

  /// The policy that enables the external account to send events to your account.
  final String? policy;

  AwsEventsEventbusDetails({
    this.arn,
    this.name,
    this.policy,
  });

  factory AwsEventsEventbusDetails.fromJson(Map<String, dynamic> json) {
    return AwsEventsEventbusDetails(
      arn: json['Arn'] as String?,
      name: json['Name'] as String?,
      policy: json['Policy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final name = this.name;
    final policy = this.policy;
    return {
      if (arn != null) 'Arn': arn,
      if (name != null) 'Name': name,
      if (policy != null) 'Policy': policy,
    };
  }
}

/// An object that contains information on the status of CloudTrail as a data
/// source for the detector.
class AwsGuardDutyDetectorDataSourcesCloudTrailDetails {
  /// Specifies whether CloudTrail is activated as a data source for the detector.
  final String? status;

  AwsGuardDutyDetectorDataSourcesCloudTrailDetails({
    this.status,
  });

  factory AwsGuardDutyDetectorDataSourcesCloudTrailDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesCloudTrailDetails(
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status,
    };
  }
}

/// Describes which data sources are activated for the detector.
class AwsGuardDutyDetectorDataSourcesDetails {
  /// An object that contains information on the status of CloudTrail as a data
  /// source for the detector.
  final AwsGuardDutyDetectorDataSourcesCloudTrailDetails? cloudTrail;

  /// An object that contains information on the status of DNS logs as a data
  /// source for the detector.
  final AwsGuardDutyDetectorDataSourcesDnsLogsDetails? dnsLogs;

  /// An object that contains information on the status of VPC Flow Logs as a data
  /// source for the detector.
  final AwsGuardDutyDetectorDataSourcesFlowLogsDetails? flowLogs;

  /// An object that contains information on the status of Kubernetes data sources
  /// for the detector.
  final AwsGuardDutyDetectorDataSourcesKubernetesDetails? kubernetes;

  /// An object that contains information on the status of Malware Protection as a
  /// data source for the detector.
  final AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails?
      malwareProtection;

  /// An object that contains information on the status of S3 Data event logs as a
  /// data source for the detector.
  final AwsGuardDutyDetectorDataSourcesS3LogsDetails? s3Logs;

  AwsGuardDutyDetectorDataSourcesDetails({
    this.cloudTrail,
    this.dnsLogs,
    this.flowLogs,
    this.kubernetes,
    this.malwareProtection,
    this.s3Logs,
  });

  factory AwsGuardDutyDetectorDataSourcesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesDetails(
      cloudTrail: json['CloudTrail'] != null
          ? AwsGuardDutyDetectorDataSourcesCloudTrailDetails.fromJson(
              json['CloudTrail'] as Map<String, dynamic>)
          : null,
      dnsLogs: json['DnsLogs'] != null
          ? AwsGuardDutyDetectorDataSourcesDnsLogsDetails.fromJson(
              json['DnsLogs'] as Map<String, dynamic>)
          : null,
      flowLogs: json['FlowLogs'] != null
          ? AwsGuardDutyDetectorDataSourcesFlowLogsDetails.fromJson(
              json['FlowLogs'] as Map<String, dynamic>)
          : null,
      kubernetes: json['Kubernetes'] != null
          ? AwsGuardDutyDetectorDataSourcesKubernetesDetails.fromJson(
              json['Kubernetes'] as Map<String, dynamic>)
          : null,
      malwareProtection: json['MalwareProtection'] != null
          ? AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails.fromJson(
              json['MalwareProtection'] as Map<String, dynamic>)
          : null,
      s3Logs: json['S3Logs'] != null
          ? AwsGuardDutyDetectorDataSourcesS3LogsDetails.fromJson(
              json['S3Logs'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudTrail = this.cloudTrail;
    final dnsLogs = this.dnsLogs;
    final flowLogs = this.flowLogs;
    final kubernetes = this.kubernetes;
    final malwareProtection = this.malwareProtection;
    final s3Logs = this.s3Logs;
    return {
      if (cloudTrail != null) 'CloudTrail': cloudTrail,
      if (dnsLogs != null) 'DnsLogs': dnsLogs,
      if (flowLogs != null) 'FlowLogs': flowLogs,
      if (kubernetes != null) 'Kubernetes': kubernetes,
      if (malwareProtection != null) 'MalwareProtection': malwareProtection,
      if (s3Logs != null) 'S3Logs': s3Logs,
    };
  }
}

/// An object that contains information on the status of DNS logs as a data
/// source for the detector.
class AwsGuardDutyDetectorDataSourcesDnsLogsDetails {
  /// Describes whether DNS logs is enabled as a data source for the detector.
  final String? status;

  AwsGuardDutyDetectorDataSourcesDnsLogsDetails({
    this.status,
  });

  factory AwsGuardDutyDetectorDataSourcesDnsLogsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesDnsLogsDetails(
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status,
    };
  }
}

/// An object that contains information on the status of VPC Flow Logs as a data
/// source for the detector.
class AwsGuardDutyDetectorDataSourcesFlowLogsDetails {
  /// Describes whether VPC Flow Logs are activated as a data source for the
  /// detector.
  final String? status;

  AwsGuardDutyDetectorDataSourcesFlowLogsDetails({
    this.status,
  });

  factory AwsGuardDutyDetectorDataSourcesFlowLogsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesFlowLogsDetails(
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status,
    };
  }
}

/// An object that contains information on the status of Kubernetes audit logs
/// as a data source for the detector.
class AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails {
  /// Describes whether Kubernetes audit logs are activated as a data source for
  /// the detector.
  final String? status;

  AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails({
    this.status,
  });

  factory AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails(
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status,
    };
  }
}

/// An object that contains information on the status of Kubernetes data sources
/// for the detector.
class AwsGuardDutyDetectorDataSourcesKubernetesDetails {
  /// Describes whether Kubernetes audit logs are activated as a data source for
  /// the detector.
  final AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails? auditLogs;

  AwsGuardDutyDetectorDataSourcesKubernetesDetails({
    this.auditLogs,
  });

  factory AwsGuardDutyDetectorDataSourcesKubernetesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesKubernetesDetails(
      auditLogs: json['AuditLogs'] != null
          ? AwsGuardDutyDetectorDataSourcesKubernetesAuditLogsDetails.fromJson(
              json['AuditLogs'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final auditLogs = this.auditLogs;
    return {
      if (auditLogs != null) 'AuditLogs': auditLogs,
    };
  }
}

/// An object that contains information on the status of Malware Protection as a
/// data source for the detector.
class AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails {
  /// Describes the configuration of Malware Protection for EC2 instances with
  /// findings.
  final AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails?
      scanEc2InstanceWithFindings;

  /// The GuardDuty Malware Protection service role.
  final String? serviceRole;

  AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails({
    this.scanEc2InstanceWithFindings,
    this.serviceRole,
  });

  factory AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesMalwareProtectionDetails(
      scanEc2InstanceWithFindings: json['ScanEc2InstanceWithFindings'] != null
          ? AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails
              .fromJson(
                  json['ScanEc2InstanceWithFindings'] as Map<String, dynamic>)
          : null,
      serviceRole: json['ServiceRole'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final scanEc2InstanceWithFindings = this.scanEc2InstanceWithFindings;
    final serviceRole = this.serviceRole;
    return {
      if (scanEc2InstanceWithFindings != null)
        'ScanEc2InstanceWithFindings': scanEc2InstanceWithFindings,
      if (serviceRole != null) 'ServiceRole': serviceRole,
    };
  }
}

/// Describes the configuration of Malware Protection for EC2 instances with
/// findings.
class AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails {
  /// Describes the configuration of scanning EBS volumes (Malware Protection) as
  /// a data source.
  final AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails?
      ebsVolumes;

  AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails({
    this.ebsVolumes,
  });

  factory AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsDetails(
      ebsVolumes: json['EbsVolumes'] != null
          ? AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails
              .fromJson(json['EbsVolumes'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final ebsVolumes = this.ebsVolumes;
    return {
      if (ebsVolumes != null) 'EbsVolumes': ebsVolumes,
    };
  }
}

/// Describes the configuration of scanning EBS volumes (Malware Protection) as
/// a data source.
class AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails {
  /// Specifies the reason why scanning EBS volumes (Malware Protection) isn’t
  /// activated as a data source.
  final String? reason;

  /// Describes whether scanning EBS volumes is activated as a data source for the
  /// detector.
  final String? status;

  AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails({
    this.reason,
    this.status,
  });

  factory AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesMalwareProtectionScanEc2InstanceWithFindingsEbsVolumesDetails(
      reason: json['Reason'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final reason = this.reason;
    final status = this.status;
    return {
      if (reason != null) 'Reason': reason,
      if (status != null) 'Status': status,
    };
  }
}

/// An object that contains information on the status of S3 data event logs as a
/// data source for the detector.
class AwsGuardDutyDetectorDataSourcesS3LogsDetails {
  /// A value that describes whether S3 data event logs are automatically enabled
  /// for new members of an organization.
  final String? status;

  AwsGuardDutyDetectorDataSourcesS3LogsDetails({
    this.status,
  });

  factory AwsGuardDutyDetectorDataSourcesS3LogsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDataSourcesS3LogsDetails(
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status,
    };
  }
}

/// Provides details about an Amazon GuardDuty detector. A detector is an object
/// that represents the GuardDuty service. A detector is required for GuardDuty
/// to become operational.
class AwsGuardDutyDetectorDetails {
  /// Describes which data sources are activated for the detector.
  final AwsGuardDutyDetectorDataSourcesDetails? dataSources;

  /// Describes which features are activated for the detector.
  final List<AwsGuardDutyDetectorFeaturesDetails>? features;

  /// The publishing frequency of the finding.
  final String? findingPublishingFrequency;

  /// The GuardDuty service role.
  final String? serviceRole;

  /// The activation status of the detector.
  final String? status;

  AwsGuardDutyDetectorDetails({
    this.dataSources,
    this.features,
    this.findingPublishingFrequency,
    this.serviceRole,
    this.status,
  });

  factory AwsGuardDutyDetectorDetails.fromJson(Map<String, dynamic> json) {
    return AwsGuardDutyDetectorDetails(
      dataSources: json['DataSources'] != null
          ? AwsGuardDutyDetectorDataSourcesDetails.fromJson(
              json['DataSources'] as Map<String, dynamic>)
          : null,
      features: (json['Features'] as List?)
          ?.whereNotNull()
          .map((e) => AwsGuardDutyDetectorFeaturesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      findingPublishingFrequency: json['FindingPublishingFrequency'] as String?,
      serviceRole: json['ServiceRole'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSources = this.dataSources;
    final features = this.features;
    final findingPublishingFrequency = this.findingPublishingFrequency;
    final serviceRole = this.serviceRole;
    final status = this.status;
    return {
      if (dataSources != null) 'DataSources': dataSources,
      if (features != null) 'Features': features,
      if (findingPublishingFrequency != null)
        'FindingPublishingFrequency': findingPublishingFrequency,
      if (serviceRole != null) 'ServiceRole': serviceRole,
      if (status != null) 'Status': status,
    };
  }
}

/// Describes which features are activated for the detector.
class AwsGuardDutyDetectorFeaturesDetails {
  /// Indicates the name of the feature that is activated for the detector.
  final String? name;

  /// Indicates the status of the feature that is activated for the detector.
  final String? status;

  AwsGuardDutyDetectorFeaturesDetails({
    this.name,
    this.status,
  });

  factory AwsGuardDutyDetectorFeaturesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsGuardDutyDetectorFeaturesDetails(
      name: json['Name'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final status = this.status;
    return {
      if (name != null) 'Name': name,
      if (status != null) 'Status': status,
    };
  }
}

/// IAM access key details related to a finding.
class AwsIamAccessKeyDetails {
  /// The identifier of the access key.
  final String? accessKeyId;

  /// The Amazon Web Services account ID of the account for the key.
  final String? accountId;

  /// Indicates when the IAM access key was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdAt;

  /// The ID of the principal associated with an access key.
  final String? principalId;

  /// The name of the principal.
  final String? principalName;

  /// The type of principal associated with an access key.
  final String? principalType;

  /// Information about the session that the key was used for.
  final AwsIamAccessKeySessionContext? sessionContext;

  /// The status of the IAM access key related to a finding.
  final AwsIamAccessKeyStatus? status;

  /// The user associated with the IAM access key related to a finding.
  ///
  /// The <code>UserName</code> parameter has been replaced with the
  /// <code>PrincipalName</code> parameter because access keys can also be
  /// assigned to principals that are not IAM users.
  final String? userName;

  AwsIamAccessKeyDetails({
    this.accessKeyId,
    this.accountId,
    this.createdAt,
    this.principalId,
    this.principalName,
    this.principalType,
    this.sessionContext,
    this.status,
    this.userName,
  });

  factory AwsIamAccessKeyDetails.fromJson(Map<String, dynamic> json) {
    return AwsIamAccessKeyDetails(
      accessKeyId: json['AccessKeyId'] as String?,
      accountId: json['AccountId'] as String?,
      createdAt: json['CreatedAt'] as String?,
      principalId: json['PrincipalId'] as String?,
      principalName: json['PrincipalName'] as String?,
      principalType: json['PrincipalType'] as String?,
      sessionContext: json['SessionContext'] != null
          ? AwsIamAccessKeySessionContext.fromJson(
              json['SessionContext'] as Map<String, dynamic>)
          : null,
      status: (json['Status'] as String?)?.toAwsIamAccessKeyStatus(),
      userName: json['UserName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accessKeyId = this.accessKeyId;
    final accountId = this.accountId;
    final createdAt = this.createdAt;
    final principalId = this.principalId;
    final principalName = this.principalName;
    final principalType = this.principalType;
    final sessionContext = this.sessionContext;
    final status = this.status;
    final userName = this.userName;
    return {
      if (accessKeyId != null) 'AccessKeyId': accessKeyId,
      if (accountId != null) 'AccountId': accountId,
      if (createdAt != null) 'CreatedAt': createdAt,
      if (principalId != null) 'PrincipalId': principalId,
      if (principalName != null) 'PrincipalName': principalName,
      if (principalType != null) 'PrincipalType': principalType,
      if (sessionContext != null) 'SessionContext': sessionContext,
      if (status != null) 'Status': status.toValue(),
      if (userName != null) 'UserName': userName,
    };
  }
}

/// Provides information about the session that the key was used for.
class AwsIamAccessKeySessionContext {
  /// Attributes of the session that the key was used for.
  final AwsIamAccessKeySessionContextAttributes? attributes;

  /// Information about the entity that created the session.
  final AwsIamAccessKeySessionContextSessionIssuer? sessionIssuer;

  AwsIamAccessKeySessionContext({
    this.attributes,
    this.sessionIssuer,
  });

  factory AwsIamAccessKeySessionContext.fromJson(Map<String, dynamic> json) {
    return AwsIamAccessKeySessionContext(
      attributes: json['Attributes'] != null
          ? AwsIamAccessKeySessionContextAttributes.fromJson(
              json['Attributes'] as Map<String, dynamic>)
          : null,
      sessionIssuer: json['SessionIssuer'] != null
          ? AwsIamAccessKeySessionContextSessionIssuer.fromJson(
              json['SessionIssuer'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final attributes = this.attributes;
    final sessionIssuer = this.sessionIssuer;
    return {
      if (attributes != null) 'Attributes': attributes,
      if (sessionIssuer != null) 'SessionIssuer': sessionIssuer,
    };
  }
}

/// Attributes of the session that the key was used for.
class AwsIamAccessKeySessionContextAttributes {
  /// Indicates when the session was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? creationDate;

  /// Indicates whether the session used multi-factor authentication (MFA).
  final bool? mfaAuthenticated;

  AwsIamAccessKeySessionContextAttributes({
    this.creationDate,
    this.mfaAuthenticated,
  });

  factory AwsIamAccessKeySessionContextAttributes.fromJson(
      Map<String, dynamic> json) {
    return AwsIamAccessKeySessionContextAttributes(
      creationDate: json['CreationDate'] as String?,
      mfaAuthenticated: json['MfaAuthenticated'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final creationDate = this.creationDate;
    final mfaAuthenticated = this.mfaAuthenticated;
    return {
      if (creationDate != null) 'CreationDate': creationDate,
      if (mfaAuthenticated != null) 'MfaAuthenticated': mfaAuthenticated,
    };
  }
}

/// Information about the entity that created the session.
class AwsIamAccessKeySessionContextSessionIssuer {
  /// The identifier of the Amazon Web Services account that created the session.
  final String? accountId;

  /// The ARN of the session.
  final String? arn;

  /// The principal ID of the principal (user, role, or group) that created the
  /// session.
  final String? principalId;

  /// The type of principal (user, role, or group) that created the session.
  final String? type;

  /// The name of the principal that created the session.
  final String? userName;

  AwsIamAccessKeySessionContextSessionIssuer({
    this.accountId,
    this.arn,
    this.principalId,
    this.type,
    this.userName,
  });

  factory AwsIamAccessKeySessionContextSessionIssuer.fromJson(
      Map<String, dynamic> json) {
    return AwsIamAccessKeySessionContextSessionIssuer(
      accountId: json['AccountId'] as String?,
      arn: json['Arn'] as String?,
      principalId: json['PrincipalId'] as String?,
      type: json['Type'] as String?,
      userName: json['UserName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final arn = this.arn;
    final principalId = this.principalId;
    final type = this.type;
    final userName = this.userName;
    return {
      if (accountId != null) 'AccountId': accountId,
      if (arn != null) 'Arn': arn,
      if (principalId != null) 'PrincipalId': principalId,
      if (type != null) 'Type': type,
      if (userName != null) 'UserName': userName,
    };
  }
}

enum AwsIamAccessKeyStatus {
  active,
  inactive,
}

extension AwsIamAccessKeyStatusValueExtension on AwsIamAccessKeyStatus {
  String toValue() {
    switch (this) {
      case AwsIamAccessKeyStatus.active:
        return 'Active';
      case AwsIamAccessKeyStatus.inactive:
        return 'Inactive';
    }
  }
}

extension AwsIamAccessKeyStatusFromString on String {
  AwsIamAccessKeyStatus toAwsIamAccessKeyStatus() {
    switch (this) {
      case 'Active':
        return AwsIamAccessKeyStatus.active;
      case 'Inactive':
        return AwsIamAccessKeyStatus.inactive;
    }
    throw Exception('$this is not known in enum AwsIamAccessKeyStatus');
  }
}

/// A managed policy that is attached to an IAM principal.
class AwsIamAttachedManagedPolicy {
  /// The ARN of the policy.
  final String? policyArn;

  /// The name of the policy.
  final String? policyName;

  AwsIamAttachedManagedPolicy({
    this.policyArn,
    this.policyName,
  });

  factory AwsIamAttachedManagedPolicy.fromJson(Map<String, dynamic> json) {
    return AwsIamAttachedManagedPolicy(
      policyArn: json['PolicyArn'] as String?,
      policyName: json['PolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final policyArn = this.policyArn;
    final policyName = this.policyName;
    return {
      if (policyArn != null) 'PolicyArn': policyArn,
      if (policyName != null) 'PolicyName': policyName,
    };
  }
}

/// Contains details about an IAM group.
class AwsIamGroupDetails {
  /// A list of the managed policies that are attached to the IAM group.
  final List<AwsIamAttachedManagedPolicy>? attachedManagedPolicies;

  /// Indicates when the IAM group was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// The identifier of the IAM group.
  final String? groupId;

  /// The name of the IAM group.
  final String? groupName;

  /// The list of inline policies that are embedded in the group.
  final List<AwsIamGroupPolicy>? groupPolicyList;

  /// The path to the group.
  final String? path;

  AwsIamGroupDetails({
    this.attachedManagedPolicies,
    this.createDate,
    this.groupId,
    this.groupName,
    this.groupPolicyList,
    this.path,
  });

  factory AwsIamGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsIamGroupDetails(
      attachedManagedPolicies: (json['AttachedManagedPolicies'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsIamAttachedManagedPolicy.fromJson(e as Map<String, dynamic>))
          .toList(),
      createDate: json['CreateDate'] as String?,
      groupId: json['GroupId'] as String?,
      groupName: json['GroupName'] as String?,
      groupPolicyList: (json['GroupPolicyList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsIamGroupPolicy.fromJson(e as Map<String, dynamic>))
          .toList(),
      path: json['Path'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachedManagedPolicies = this.attachedManagedPolicies;
    final createDate = this.createDate;
    final groupId = this.groupId;
    final groupName = this.groupName;
    final groupPolicyList = this.groupPolicyList;
    final path = this.path;
    return {
      if (attachedManagedPolicies != null)
        'AttachedManagedPolicies': attachedManagedPolicies,
      if (createDate != null) 'CreateDate': createDate,
      if (groupId != null) 'GroupId': groupId,
      if (groupName != null) 'GroupName': groupName,
      if (groupPolicyList != null) 'GroupPolicyList': groupPolicyList,
      if (path != null) 'Path': path,
    };
  }
}

/// A managed policy that is attached to the IAM group.
class AwsIamGroupPolicy {
  /// The name of the policy.
  final String? policyName;

  AwsIamGroupPolicy({
    this.policyName,
  });

  factory AwsIamGroupPolicy.fromJson(Map<String, dynamic> json) {
    return AwsIamGroupPolicy(
      policyName: json['PolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final policyName = this.policyName;
    return {
      if (policyName != null) 'PolicyName': policyName,
    };
  }
}

/// Information about an instance profile.
class AwsIamInstanceProfile {
  /// The ARN of the instance profile.
  final String? arn;

  /// Indicates when the instance profile was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// The identifier of the instance profile.
  final String? instanceProfileId;

  /// The name of the instance profile.
  final String? instanceProfileName;

  /// The path to the instance profile.
  final String? path;

  /// The roles associated with the instance profile.
  final List<AwsIamInstanceProfileRole>? roles;

  AwsIamInstanceProfile({
    this.arn,
    this.createDate,
    this.instanceProfileId,
    this.instanceProfileName,
    this.path,
    this.roles,
  });

  factory AwsIamInstanceProfile.fromJson(Map<String, dynamic> json) {
    return AwsIamInstanceProfile(
      arn: json['Arn'] as String?,
      createDate: json['CreateDate'] as String?,
      instanceProfileId: json['InstanceProfileId'] as String?,
      instanceProfileName: json['InstanceProfileName'] as String?,
      path: json['Path'] as String?,
      roles: (json['Roles'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsIamInstanceProfileRole.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createDate = this.createDate;
    final instanceProfileId = this.instanceProfileId;
    final instanceProfileName = this.instanceProfileName;
    final path = this.path;
    final roles = this.roles;
    return {
      if (arn != null) 'Arn': arn,
      if (createDate != null) 'CreateDate': createDate,
      if (instanceProfileId != null) 'InstanceProfileId': instanceProfileId,
      if (instanceProfileName != null)
        'InstanceProfileName': instanceProfileName,
      if (path != null) 'Path': path,
      if (roles != null) 'Roles': roles,
    };
  }
}

/// Information about a role associated with an instance profile.
class AwsIamInstanceProfileRole {
  /// The ARN of the role.
  final String? arn;

  /// The policy that grants an entity permission to assume the role.
  final String? assumeRolePolicyDocument;

  /// Indicates when the role was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// The path to the role.
  final String? path;

  /// The identifier of the role.
  final String? roleId;

  /// The name of the role.
  final String? roleName;

  AwsIamInstanceProfileRole({
    this.arn,
    this.assumeRolePolicyDocument,
    this.createDate,
    this.path,
    this.roleId,
    this.roleName,
  });

  factory AwsIamInstanceProfileRole.fromJson(Map<String, dynamic> json) {
    return AwsIamInstanceProfileRole(
      arn: json['Arn'] as String?,
      assumeRolePolicyDocument: json['AssumeRolePolicyDocument'] as String?,
      createDate: json['CreateDate'] as String?,
      path: json['Path'] as String?,
      roleId: json['RoleId'] as String?,
      roleName: json['RoleName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assumeRolePolicyDocument = this.assumeRolePolicyDocument;
    final createDate = this.createDate;
    final path = this.path;
    final roleId = this.roleId;
    final roleName = this.roleName;
    return {
      if (arn != null) 'Arn': arn,
      if (assumeRolePolicyDocument != null)
        'AssumeRolePolicyDocument': assumeRolePolicyDocument,
      if (createDate != null) 'CreateDate': createDate,
      if (path != null) 'Path': path,
      if (roleId != null) 'RoleId': roleId,
      if (roleName != null) 'RoleName': roleName,
    };
  }
}

/// Information about the policy used to set the permissions boundary for an IAM
/// principal.
class AwsIamPermissionsBoundary {
  /// The ARN of the policy used to set the permissions boundary.
  final String? permissionsBoundaryArn;

  /// The usage type for the permissions boundary.
  final String? permissionsBoundaryType;

  AwsIamPermissionsBoundary({
    this.permissionsBoundaryArn,
    this.permissionsBoundaryType,
  });

  factory AwsIamPermissionsBoundary.fromJson(Map<String, dynamic> json) {
    return AwsIamPermissionsBoundary(
      permissionsBoundaryArn: json['PermissionsBoundaryArn'] as String?,
      permissionsBoundaryType: json['PermissionsBoundaryType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissionsBoundaryArn = this.permissionsBoundaryArn;
    final permissionsBoundaryType = this.permissionsBoundaryType;
    return {
      if (permissionsBoundaryArn != null)
        'PermissionsBoundaryArn': permissionsBoundaryArn,
      if (permissionsBoundaryType != null)
        'PermissionsBoundaryType': permissionsBoundaryType,
    };
  }
}

/// Represents an IAM permissions policy.
class AwsIamPolicyDetails {
  /// The number of users, groups, and roles that the policy is attached to.
  final int? attachmentCount;

  /// When the policy was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// The identifier of the default version of the policy.
  final String? defaultVersionId;

  /// A description of the policy.
  final String? description;

  /// Whether the policy can be attached to a user, group, or role.
  final bool? isAttachable;

  /// The path to the policy.
  final String? path;

  /// The number of users and roles that use the policy to set the permissions
  /// boundary.
  final int? permissionsBoundaryUsageCount;

  /// The unique identifier of the policy.
  final String? policyId;

  /// The name of the policy.
  final String? policyName;

  /// List of versions of the policy.
  final List<AwsIamPolicyVersion>? policyVersionList;

  /// When the policy was most recently updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? updateDate;

  AwsIamPolicyDetails({
    this.attachmentCount,
    this.createDate,
    this.defaultVersionId,
    this.description,
    this.isAttachable,
    this.path,
    this.permissionsBoundaryUsageCount,
    this.policyId,
    this.policyName,
    this.policyVersionList,
    this.updateDate,
  });

  factory AwsIamPolicyDetails.fromJson(Map<String, dynamic> json) {
    return AwsIamPolicyDetails(
      attachmentCount: json['AttachmentCount'] as int?,
      createDate: json['CreateDate'] as String?,
      defaultVersionId: json['DefaultVersionId'] as String?,
      description: json['Description'] as String?,
      isAttachable: json['IsAttachable'] as bool?,
      path: json['Path'] as String?,
      permissionsBoundaryUsageCount:
          json['PermissionsBoundaryUsageCount'] as int?,
      policyId: json['PolicyId'] as String?,
      policyName: json['PolicyName'] as String?,
      policyVersionList: (json['PolicyVersionList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsIamPolicyVersion.fromJson(e as Map<String, dynamic>))
          .toList(),
      updateDate: json['UpdateDate'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final attachmentCount = this.attachmentCount;
    final createDate = this.createDate;
    final defaultVersionId = this.defaultVersionId;
    final description = this.description;
    final isAttachable = this.isAttachable;
    final path = this.path;
    final permissionsBoundaryUsageCount = this.permissionsBoundaryUsageCount;
    final policyId = this.policyId;
    final policyName = this.policyName;
    final policyVersionList = this.policyVersionList;
    final updateDate = this.updateDate;
    return {
      if (attachmentCount != null) 'AttachmentCount': attachmentCount,
      if (createDate != null) 'CreateDate': createDate,
      if (defaultVersionId != null) 'DefaultVersionId': defaultVersionId,
      if (description != null) 'Description': description,
      if (isAttachable != null) 'IsAttachable': isAttachable,
      if (path != null) 'Path': path,
      if (permissionsBoundaryUsageCount != null)
        'PermissionsBoundaryUsageCount': permissionsBoundaryUsageCount,
      if (policyId != null) 'PolicyId': policyId,
      if (policyName != null) 'PolicyName': policyName,
      if (policyVersionList != null) 'PolicyVersionList': policyVersionList,
      if (updateDate != null) 'UpdateDate': updateDate,
    };
  }
}

/// A version of an IAM policy.
class AwsIamPolicyVersion {
  /// Indicates when the version was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// Whether the version is the default version.
  final bool? isDefaultVersion;

  /// The identifier of the policy version.
  final String? versionId;

  AwsIamPolicyVersion({
    this.createDate,
    this.isDefaultVersion,
    this.versionId,
  });

  factory AwsIamPolicyVersion.fromJson(Map<String, dynamic> json) {
    return AwsIamPolicyVersion(
      createDate: json['CreateDate'] as String?,
      isDefaultVersion: json['IsDefaultVersion'] as bool?,
      versionId: json['VersionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final createDate = this.createDate;
    final isDefaultVersion = this.isDefaultVersion;
    final versionId = this.versionId;
    return {
      if (createDate != null) 'CreateDate': createDate,
      if (isDefaultVersion != null) 'IsDefaultVersion': isDefaultVersion,
      if (versionId != null) 'VersionId': versionId,
    };
  }
}

/// Contains information about an IAM role, including all of the role's
/// policies.
class AwsIamRoleDetails {
  /// The trust policy that grants permission to assume the role.
  final String? assumeRolePolicyDocument;

  /// The list of the managed policies that are attached to the role.
  final List<AwsIamAttachedManagedPolicy>? attachedManagedPolicies;

  /// Indicates when the role was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// The list of instance profiles that contain this role.
  final List<AwsIamInstanceProfile>? instanceProfileList;

  /// The maximum session duration (in seconds) that you want to set for the
  /// specified role.
  final int? maxSessionDuration;

  /// The path to the role.
  final String? path;
  final AwsIamPermissionsBoundary? permissionsBoundary;

  /// The stable and unique string identifying the role.
  final String? roleId;

  /// The friendly name that identifies the role.
  final String? roleName;

  /// The list of inline policies that are embedded in the role.
  final List<AwsIamRolePolicy>? rolePolicyList;

  AwsIamRoleDetails({
    this.assumeRolePolicyDocument,
    this.attachedManagedPolicies,
    this.createDate,
    this.instanceProfileList,
    this.maxSessionDuration,
    this.path,
    this.permissionsBoundary,
    this.roleId,
    this.roleName,
    this.rolePolicyList,
  });

  factory AwsIamRoleDetails.fromJson(Map<String, dynamic> json) {
    return AwsIamRoleDetails(
      assumeRolePolicyDocument: json['AssumeRolePolicyDocument'] as String?,
      attachedManagedPolicies: (json['AttachedManagedPolicies'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsIamAttachedManagedPolicy.fromJson(e as Map<String, dynamic>))
          .toList(),
      createDate: json['CreateDate'] as String?,
      instanceProfileList: (json['InstanceProfileList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsIamInstanceProfile.fromJson(e as Map<String, dynamic>))
          .toList(),
      maxSessionDuration: json['MaxSessionDuration'] as int?,
      path: json['Path'] as String?,
      permissionsBoundary: json['PermissionsBoundary'] != null
          ? AwsIamPermissionsBoundary.fromJson(
              json['PermissionsBoundary'] as Map<String, dynamic>)
          : null,
      roleId: json['RoleId'] as String?,
      roleName: json['RoleName'] as String?,
      rolePolicyList: (json['RolePolicyList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsIamRolePolicy.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final assumeRolePolicyDocument = this.assumeRolePolicyDocument;
    final attachedManagedPolicies = this.attachedManagedPolicies;
    final createDate = this.createDate;
    final instanceProfileList = this.instanceProfileList;
    final maxSessionDuration = this.maxSessionDuration;
    final path = this.path;
    final permissionsBoundary = this.permissionsBoundary;
    final roleId = this.roleId;
    final roleName = this.roleName;
    final rolePolicyList = this.rolePolicyList;
    return {
      if (assumeRolePolicyDocument != null)
        'AssumeRolePolicyDocument': assumeRolePolicyDocument,
      if (attachedManagedPolicies != null)
        'AttachedManagedPolicies': attachedManagedPolicies,
      if (createDate != null) 'CreateDate': createDate,
      if (instanceProfileList != null)
        'InstanceProfileList': instanceProfileList,
      if (maxSessionDuration != null) 'MaxSessionDuration': maxSessionDuration,
      if (path != null) 'Path': path,
      if (permissionsBoundary != null)
        'PermissionsBoundary': permissionsBoundary,
      if (roleId != null) 'RoleId': roleId,
      if (roleName != null) 'RoleName': roleName,
      if (rolePolicyList != null) 'RolePolicyList': rolePolicyList,
    };
  }
}

/// An inline policy that is embedded in the role.
class AwsIamRolePolicy {
  /// The name of the policy.
  final String? policyName;

  AwsIamRolePolicy({
    this.policyName,
  });

  factory AwsIamRolePolicy.fromJson(Map<String, dynamic> json) {
    return AwsIamRolePolicy(
      policyName: json['PolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final policyName = this.policyName;
    return {
      if (policyName != null) 'PolicyName': policyName,
    };
  }
}

/// Information about an IAM user.
class AwsIamUserDetails {
  /// A list of the managed policies that are attached to the user.
  final List<AwsIamAttachedManagedPolicy>? attachedManagedPolicies;

  /// Indicates when the user was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createDate;

  /// A list of IAM groups that the user belongs to.
  final List<String>? groupList;

  /// The path to the user.
  final String? path;

  /// The permissions boundary for the user.
  final AwsIamPermissionsBoundary? permissionsBoundary;

  /// The unique identifier for the user.
  final String? userId;

  /// The name of the user.
  final String? userName;

  /// The list of inline policies that are embedded in the user.
  final List<AwsIamUserPolicy>? userPolicyList;

  AwsIamUserDetails({
    this.attachedManagedPolicies,
    this.createDate,
    this.groupList,
    this.path,
    this.permissionsBoundary,
    this.userId,
    this.userName,
    this.userPolicyList,
  });

  factory AwsIamUserDetails.fromJson(Map<String, dynamic> json) {
    return AwsIamUserDetails(
      attachedManagedPolicies: (json['AttachedManagedPolicies'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsIamAttachedManagedPolicy.fromJson(e as Map<String, dynamic>))
          .toList(),
      createDate: json['CreateDate'] as String?,
      groupList: (json['GroupList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      path: json['Path'] as String?,
      permissionsBoundary: json['PermissionsBoundary'] != null
          ? AwsIamPermissionsBoundary.fromJson(
              json['PermissionsBoundary'] as Map<String, dynamic>)
          : null,
      userId: json['UserId'] as String?,
      userName: json['UserName'] as String?,
      userPolicyList: (json['UserPolicyList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsIamUserPolicy.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final attachedManagedPolicies = this.attachedManagedPolicies;
    final createDate = this.createDate;
    final groupList = this.groupList;
    final path = this.path;
    final permissionsBoundary = this.permissionsBoundary;
    final userId = this.userId;
    final userName = this.userName;
    final userPolicyList = this.userPolicyList;
    return {
      if (attachedManagedPolicies != null)
        'AttachedManagedPolicies': attachedManagedPolicies,
      if (createDate != null) 'CreateDate': createDate,
      if (groupList != null) 'GroupList': groupList,
      if (path != null) 'Path': path,
      if (permissionsBoundary != null)
        'PermissionsBoundary': permissionsBoundary,
      if (userId != null) 'UserId': userId,
      if (userName != null) 'UserName': userName,
      if (userPolicyList != null) 'UserPolicyList': userPolicyList,
    };
  }
}

/// Information about an inline policy that is embedded in the user.
class AwsIamUserPolicy {
  /// The name of the policy.
  final String? policyName;

  AwsIamUserPolicy({
    this.policyName,
  });

  factory AwsIamUserPolicy.fromJson(Map<String, dynamic> json) {
    return AwsIamUserPolicy(
      policyName: json['PolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final policyName = this.policyName;
    return {
      if (policyName != null) 'PolicyName': policyName,
    };
  }
}

/// Provides information about an Amazon Kinesis data stream.
class AwsKinesisStreamDetails {
  /// The Amazon Resource Name (ARN) of the Kinesis data stream.
  final String? arn;

  /// The name of the Kinesis stream. If you don't specify a name, CloudFront
  /// generates a unique physical ID and uses that ID for the stream name.
  final String? name;

  /// The number of hours for the data records that are stored in shards to remain
  /// accessible.
  final int? retentionPeriodHours;

  /// The number of shards that the stream uses.
  final int? shardCount;

  /// When specified, enables or updates server-side encryption using an KMS key
  /// for a specified stream. Removing this property from your stack template and
  /// updating your stack disables encryption.
  final AwsKinesisStreamStreamEncryptionDetails? streamEncryption;

  AwsKinesisStreamDetails({
    this.arn,
    this.name,
    this.retentionPeriodHours,
    this.shardCount,
    this.streamEncryption,
  });

  factory AwsKinesisStreamDetails.fromJson(Map<String, dynamic> json) {
    return AwsKinesisStreamDetails(
      arn: json['Arn'] as String?,
      name: json['Name'] as String?,
      retentionPeriodHours: json['RetentionPeriodHours'] as int?,
      shardCount: json['ShardCount'] as int?,
      streamEncryption: json['StreamEncryption'] != null
          ? AwsKinesisStreamStreamEncryptionDetails.fromJson(
              json['StreamEncryption'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final name = this.name;
    final retentionPeriodHours = this.retentionPeriodHours;
    final shardCount = this.shardCount;
    final streamEncryption = this.streamEncryption;
    return {
      if (arn != null) 'Arn': arn,
      if (name != null) 'Name': name,
      if (retentionPeriodHours != null)
        'RetentionPeriodHours': retentionPeriodHours,
      if (shardCount != null) 'ShardCount': shardCount,
      if (streamEncryption != null) 'StreamEncryption': streamEncryption,
    };
  }
}

/// Provides information about stream encryption.
class AwsKinesisStreamStreamEncryptionDetails {
  /// The encryption type to use.
  final String? encryptionType;

  /// The globally unique identifier for the customer-managed KMS key to use for
  /// encryption.
  final String? keyId;

  AwsKinesisStreamStreamEncryptionDetails({
    this.encryptionType,
    this.keyId,
  });

  factory AwsKinesisStreamStreamEncryptionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsKinesisStreamStreamEncryptionDetails(
      encryptionType: json['EncryptionType'] as String?,
      keyId: json['KeyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionType = this.encryptionType;
    final keyId = this.keyId;
    return {
      if (encryptionType != null) 'EncryptionType': encryptionType,
      if (keyId != null) 'KeyId': keyId,
    };
  }
}

/// Contains metadata about an KMS key.
class AwsKmsKeyDetails {
  /// The twelve-digit account ID of the Amazon Web Services account that owns the
  /// KMS key.
  final String? awsAccountId;

  /// Indicates when the KMS key was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final double? creationDate;

  /// A description of the KMS key.
  final String? description;

  /// The globally unique identifier for the KMS key.
  final String? keyId;

  /// The manager of the KMS key. KMS keys in your Amazon Web Services account are
  /// either customer managed or Amazon Web Services managed.
  final String? keyManager;

  /// Whether the key has key rotation enabled.
  final bool? keyRotationStatus;

  /// The state of the KMS key. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>Disabled</code>
  /// </li>
  /// <li>
  /// <code>Enabled</code>
  /// </li>
  /// <li>
  /// <code>PendingDeletion</code>
  /// </li>
  /// <li>
  /// <code>PendingImport</code>
  /// </li>
  /// <li>
  /// <code>Unavailable</code>
  /// </li>
  /// </ul>
  final String? keyState;

  /// The source of the KMS key material.
  ///
  /// When this value is <code>AWS_KMS</code>, KMS created the key material.
  ///
  /// When this value is <code>EXTERNAL</code>, the key material was imported from
  /// your existing key management infrastructure or the KMS key lacks key
  /// material.
  ///
  /// When this value is <code>AWS_CLOUDHSM</code>, the key material was created
  /// in the CloudHSM cluster associated with a custom key store.
  final String? origin;

  AwsKmsKeyDetails({
    this.awsAccountId,
    this.creationDate,
    this.description,
    this.keyId,
    this.keyManager,
    this.keyRotationStatus,
    this.keyState,
    this.origin,
  });

  factory AwsKmsKeyDetails.fromJson(Map<String, dynamic> json) {
    return AwsKmsKeyDetails(
      awsAccountId: json['AWSAccountId'] as String?,
      creationDate: json['CreationDate'] as double?,
      description: json['Description'] as String?,
      keyId: json['KeyId'] as String?,
      keyManager: json['KeyManager'] as String?,
      keyRotationStatus: json['KeyRotationStatus'] as bool?,
      keyState: json['KeyState'] as String?,
      origin: json['Origin'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final creationDate = this.creationDate;
    final description = this.description;
    final keyId = this.keyId;
    final keyManager = this.keyManager;
    final keyRotationStatus = this.keyRotationStatus;
    final keyState = this.keyState;
    final origin = this.origin;
    return {
      if (awsAccountId != null) 'AWSAccountId': awsAccountId,
      if (creationDate != null) 'CreationDate': creationDate,
      if (description != null) 'Description': description,
      if (keyId != null) 'KeyId': keyId,
      if (keyManager != null) 'KeyManager': keyManager,
      if (keyRotationStatus != null) 'KeyRotationStatus': keyRotationStatus,
      if (keyState != null) 'KeyState': keyState,
      if (origin != null) 'Origin': origin,
    };
  }
}

/// The code for the Lambda function. You can specify either an object in Amazon
/// S3, or upload a deployment package directly.
class AwsLambdaFunctionCode {
  /// An Amazon S3 bucket in the same Amazon Web Services Region as your function.
  /// The bucket can be in a different Amazon Web Services account.
  final String? s3Bucket;

  /// The Amazon S3 key of the deployment package.
  final String? s3Key;

  /// For versioned objects, the version of the deployment package object to use.
  final String? s3ObjectVersion;

  /// The base64-encoded contents of the deployment package. Amazon Web Services
  /// SDK and Amazon Web Services CLI clients handle the encoding for you.
  final String? zipFile;

  AwsLambdaFunctionCode({
    this.s3Bucket,
    this.s3Key,
    this.s3ObjectVersion,
    this.zipFile,
  });

  factory AwsLambdaFunctionCode.fromJson(Map<String, dynamic> json) {
    return AwsLambdaFunctionCode(
      s3Bucket: json['S3Bucket'] as String?,
      s3Key: json['S3Key'] as String?,
      s3ObjectVersion: json['S3ObjectVersion'] as String?,
      zipFile: json['ZipFile'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final s3Bucket = this.s3Bucket;
    final s3Key = this.s3Key;
    final s3ObjectVersion = this.s3ObjectVersion;
    final zipFile = this.zipFile;
    return {
      if (s3Bucket != null) 'S3Bucket': s3Bucket,
      if (s3Key != null) 'S3Key': s3Key,
      if (s3ObjectVersion != null) 'S3ObjectVersion': s3ObjectVersion,
      if (zipFile != null) 'ZipFile': zipFile,
    };
  }
}

/// The dead-letter queue for failed asynchronous invocations.
class AwsLambdaFunctionDeadLetterConfig {
  /// The ARN of an SQS queue or SNS topic.
  final String? targetArn;

  AwsLambdaFunctionDeadLetterConfig({
    this.targetArn,
  });

  factory AwsLambdaFunctionDeadLetterConfig.fromJson(
      Map<String, dynamic> json) {
    return AwsLambdaFunctionDeadLetterConfig(
      targetArn: json['TargetArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final targetArn = this.targetArn;
    return {
      if (targetArn != null) 'TargetArn': targetArn,
    };
  }
}

/// Details about an Lambda function's configuration.
class AwsLambdaFunctionDetails {
  /// The instruction set architecture that the function uses. Valid values are
  /// <code>x86_64</code> or <code>arm64</code>.
  final List<String>? architectures;

  /// An <code>AwsLambdaFunctionCode</code> object.
  final AwsLambdaFunctionCode? code;

  /// The SHA256 hash of the function's deployment package.
  final String? codeSha256;

  /// The function's dead letter queue.
  final AwsLambdaFunctionDeadLetterConfig? deadLetterConfig;

  /// The function's environment variables.
  final AwsLambdaFunctionEnvironment? environment;

  /// The name of the function.
  final String? functionName;

  /// The function that Lambda calls to begin executing your function.
  final String? handler;

  /// The KMS key that is used to encrypt the function's environment variables.
  /// This key is only returned if you've configured a customer managed customer
  /// managed key.
  final String? kmsKeyArn;

  /// Indicates when the function was last updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastModified;

  /// The function's layers.
  final List<AwsLambdaFunctionLayer>? layers;

  /// For Lambda@Edge functions, the ARN of the master function.
  final String? masterArn;

  /// The memory that is allocated to the function.
  final int? memorySize;

  /// The type of deployment package that's used to deploy the function code to
  /// Lambda. Set to <code>Image</code> for a container image and <code>Zip</code>
  /// for a .zip file archive.
  final String? packageType;

  /// The latest updated revision of the function or alias.
  final String? revisionId;

  /// The function's execution role.
  final String? role;

  /// The runtime environment for the Lambda function.
  final String? runtime;

  /// The amount of time that Lambda allows a function to run before stopping it.
  final int? timeout;

  /// The function's X-Ray tracing configuration.
  final AwsLambdaFunctionTracingConfig? tracingConfig;

  /// The version of the Lambda function.
  final String? version;

  /// The function's networking configuration.
  final AwsLambdaFunctionVpcConfig? vpcConfig;

  AwsLambdaFunctionDetails({
    this.architectures,
    this.code,
    this.codeSha256,
    this.deadLetterConfig,
    this.environment,
    this.functionName,
    this.handler,
    this.kmsKeyArn,
    this.lastModified,
    this.layers,
    this.masterArn,
    this.memorySize,
    this.packageType,
    this.revisionId,
    this.role,
    this.runtime,
    this.timeout,
    this.tracingConfig,
    this.version,
    this.vpcConfig,
  });

  factory AwsLambdaFunctionDetails.fromJson(Map<String, dynamic> json) {
    return AwsLambdaFunctionDetails(
      architectures: (json['Architectures'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      code: json['Code'] != null
          ? AwsLambdaFunctionCode.fromJson(json['Code'] as Map<String, dynamic>)
          : null,
      codeSha256: json['CodeSha256'] as String?,
      deadLetterConfig: json['DeadLetterConfig'] != null
          ? AwsLambdaFunctionDeadLetterConfig.fromJson(
              json['DeadLetterConfig'] as Map<String, dynamic>)
          : null,
      environment: json['Environment'] != null
          ? AwsLambdaFunctionEnvironment.fromJson(
              json['Environment'] as Map<String, dynamic>)
          : null,
      functionName: json['FunctionName'] as String?,
      handler: json['Handler'] as String?,
      kmsKeyArn: json['KmsKeyArn'] as String?,
      lastModified: json['LastModified'] as String?,
      layers: (json['Layers'] as List?)
          ?.whereNotNull()
          .map(
              (e) => AwsLambdaFunctionLayer.fromJson(e as Map<String, dynamic>))
          .toList(),
      masterArn: json['MasterArn'] as String?,
      memorySize: json['MemorySize'] as int?,
      packageType: json['PackageType'] as String?,
      revisionId: json['RevisionId'] as String?,
      role: json['Role'] as String?,
      runtime: json['Runtime'] as String?,
      timeout: json['Timeout'] as int?,
      tracingConfig: json['TracingConfig'] != null
          ? AwsLambdaFunctionTracingConfig.fromJson(
              json['TracingConfig'] as Map<String, dynamic>)
          : null,
      version: json['Version'] as String?,
      vpcConfig: json['VpcConfig'] != null
          ? AwsLambdaFunctionVpcConfig.fromJson(
              json['VpcConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final architectures = this.architectures;
    final code = this.code;
    final codeSha256 = this.codeSha256;
    final deadLetterConfig = this.deadLetterConfig;
    final environment = this.environment;
    final functionName = this.functionName;
    final handler = this.handler;
    final kmsKeyArn = this.kmsKeyArn;
    final lastModified = this.lastModified;
    final layers = this.layers;
    final masterArn = this.masterArn;
    final memorySize = this.memorySize;
    final packageType = this.packageType;
    final revisionId = this.revisionId;
    final role = this.role;
    final runtime = this.runtime;
    final timeout = this.timeout;
    final tracingConfig = this.tracingConfig;
    final version = this.version;
    final vpcConfig = this.vpcConfig;
    return {
      if (architectures != null) 'Architectures': architectures,
      if (code != null) 'Code': code,
      if (codeSha256 != null) 'CodeSha256': codeSha256,
      if (deadLetterConfig != null) 'DeadLetterConfig': deadLetterConfig,
      if (environment != null) 'Environment': environment,
      if (functionName != null) 'FunctionName': functionName,
      if (handler != null) 'Handler': handler,
      if (kmsKeyArn != null) 'KmsKeyArn': kmsKeyArn,
      if (lastModified != null) 'LastModified': lastModified,
      if (layers != null) 'Layers': layers,
      if (masterArn != null) 'MasterArn': masterArn,
      if (memorySize != null) 'MemorySize': memorySize,
      if (packageType != null) 'PackageType': packageType,
      if (revisionId != null) 'RevisionId': revisionId,
      if (role != null) 'Role': role,
      if (runtime != null) 'Runtime': runtime,
      if (timeout != null) 'Timeout': timeout,
      if (tracingConfig != null) 'TracingConfig': tracingConfig,
      if (version != null) 'Version': version,
      if (vpcConfig != null) 'VpcConfig': vpcConfig,
    };
  }
}

/// A function's environment variable settings.
class AwsLambdaFunctionEnvironment {
  /// An <code>AwsLambdaFunctionEnvironmentError</code> object.
  final AwsLambdaFunctionEnvironmentError? error;

  /// Environment variable key-value pairs.
  final Map<String, String>? variables;

  AwsLambdaFunctionEnvironment({
    this.error,
    this.variables,
  });

  factory AwsLambdaFunctionEnvironment.fromJson(Map<String, dynamic> json) {
    return AwsLambdaFunctionEnvironment(
      error: json['Error'] != null
          ? AwsLambdaFunctionEnvironmentError.fromJson(
              json['Error'] as Map<String, dynamic>)
          : null,
      variables: (json['Variables'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final error = this.error;
    final variables = this.variables;
    return {
      if (error != null) 'Error': error,
      if (variables != null) 'Variables': variables,
    };
  }
}

/// Error messages for environment variables that could not be applied.
class AwsLambdaFunctionEnvironmentError {
  /// The error code.
  final String? errorCode;

  /// The error message.
  final String? message;

  AwsLambdaFunctionEnvironmentError({
    this.errorCode,
    this.message,
  });

  factory AwsLambdaFunctionEnvironmentError.fromJson(
      Map<String, dynamic> json) {
    return AwsLambdaFunctionEnvironmentError(
      errorCode: json['ErrorCode'] as String?,
      message: json['Message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final message = this.message;
    return {
      if (errorCode != null) 'ErrorCode': errorCode,
      if (message != null) 'Message': message,
    };
  }
}

/// An Lambda layer.
class AwsLambdaFunctionLayer {
  /// The ARN of the function layer.
  final String? arn;

  /// The size of the layer archive in bytes.
  final int? codeSize;

  AwsLambdaFunctionLayer({
    this.arn,
    this.codeSize,
  });

  factory AwsLambdaFunctionLayer.fromJson(Map<String, dynamic> json) {
    return AwsLambdaFunctionLayer(
      arn: json['Arn'] as String?,
      codeSize: json['CodeSize'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final codeSize = this.codeSize;
    return {
      if (arn != null) 'Arn': arn,
      if (codeSize != null) 'CodeSize': codeSize,
    };
  }
}

/// The function's X-Ray tracing configuration.
class AwsLambdaFunctionTracingConfig {
  /// The tracing mode.
  final String? mode;

  AwsLambdaFunctionTracingConfig({
    this.mode,
  });

  factory AwsLambdaFunctionTracingConfig.fromJson(Map<String, dynamic> json) {
    return AwsLambdaFunctionTracingConfig(
      mode: json['Mode'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final mode = this.mode;
    return {
      if (mode != null) 'Mode': mode,
    };
  }
}

/// The VPC security groups and subnets that are attached to a Lambda function.
class AwsLambdaFunctionVpcConfig {
  /// A list of VPC security groups IDs.
  final List<String>? securityGroupIds;

  /// A list of VPC subnet IDs.
  final List<String>? subnetIds;

  /// The ID of the VPC.
  final String? vpcId;

  AwsLambdaFunctionVpcConfig({
    this.securityGroupIds,
    this.subnetIds,
    this.vpcId,
  });

  factory AwsLambdaFunctionVpcConfig.fromJson(Map<String, dynamic> json) {
    return AwsLambdaFunctionVpcConfig(
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnetIds: (json['SubnetIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final securityGroupIds = this.securityGroupIds;
    final subnetIds = this.subnetIds;
    final vpcId = this.vpcId;
    return {
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (subnetIds != null) 'SubnetIds': subnetIds,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Details about a Lambda layer version.
class AwsLambdaLayerVersionDetails {
  /// The layer's compatible <a
  /// href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">function
  /// runtimes</a>.
  ///
  /// The following list includes deprecated runtimes. For more information, see
  /// <a
  /// href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy">Runtime
  /// deprecation policy</a> in the <i>Lambda Developer Guide</i>.
  ///
  /// Array Members: Maximum number of 5 items.
  ///
  /// Valid Values: <code>nodejs | nodejs4.3 | nodejs6.10 | nodejs8.10 |
  /// nodejs10.x | nodejs12.x | nodejs14.x | nodejs16.x | java8 | java8.al2 |
  /// java11 | python2.7 | python3.6 | python3.7 | python3.8 | python3.9 |
  /// dotnetcore1.0 | dotnetcore2.0 | dotnetcore2.1 | dotnetcore3.1 | dotnet6 |
  /// nodejs4.3-edge | go1.x | ruby2.5 | ruby2.7 | provided | provided.al2 |
  /// nodejs18.x | python3.10 | java17 | ruby3.2 | python3.11 | nodejs20.x |
  /// provided.al2023 | python3.12 | java21</code>
  final List<String>? compatibleRuntimes;

  /// Indicates when the version was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdDate;

  /// The version number.
  final int? version;

  AwsLambdaLayerVersionDetails({
    this.compatibleRuntimes,
    this.createdDate,
    this.version,
  });

  factory AwsLambdaLayerVersionDetails.fromJson(Map<String, dynamic> json) {
    return AwsLambdaLayerVersionDetails(
      compatibleRuntimes: (json['CompatibleRuntimes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      createdDate: json['CreatedDate'] as String?,
      version: json['Version'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final compatibleRuntimes = this.compatibleRuntimes;
    final createdDate = this.createdDate;
    final version = this.version;
    return {
      if (compatibleRuntimes != null) 'CompatibleRuntimes': compatibleRuntimes,
      if (createdDate != null) 'CreatedDate': createdDate,
      if (version != null) 'Version': version,
    };
  }
}

/// Details for a volume mount point that's used in a container definition.
class AwsMountPoint {
  /// The path on the container to mount the host volume at.
  final String? containerPath;

  /// The name of the volume to mount. Must be a volume name referenced in the
  /// <code>name</code> parameter of task definition <code>volume</code>.
  final String? sourceVolume;

  AwsMountPoint({
    this.containerPath,
    this.sourceVolume,
  });

  factory AwsMountPoint.fromJson(Map<String, dynamic> json) {
    return AwsMountPoint(
      containerPath: json['ContainerPath'] as String?,
      sourceVolume: json['SourceVolume'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final containerPath = this.containerPath;
    final sourceVolume = this.sourceVolume;
    return {
      if (containerPath != null) 'ContainerPath': containerPath,
      if (sourceVolume != null) 'SourceVolume': sourceVolume,
    };
  }
}

/// Provides details about different modes of client authentication.
class AwsMskClusterClusterInfoClientAuthenticationDetails {
  /// Provides details for client authentication using SASL.
  final AwsMskClusterClusterInfoClientAuthenticationSaslDetails? sasl;

  /// Provides details for client authentication using TLS.
  final AwsMskClusterClusterInfoClientAuthenticationTlsDetails? tls;

  /// Provides details for allowing no client authentication.
  final AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails?
      unauthenticated;

  AwsMskClusterClusterInfoClientAuthenticationDetails({
    this.sasl,
    this.tls,
    this.unauthenticated,
  });

  factory AwsMskClusterClusterInfoClientAuthenticationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoClientAuthenticationDetails(
      sasl: json['Sasl'] != null
          ? AwsMskClusterClusterInfoClientAuthenticationSaslDetails.fromJson(
              json['Sasl'] as Map<String, dynamic>)
          : null,
      tls: json['Tls'] != null
          ? AwsMskClusterClusterInfoClientAuthenticationTlsDetails.fromJson(
              json['Tls'] as Map<String, dynamic>)
          : null,
      unauthenticated: json['Unauthenticated'] != null
          ? AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails
              .fromJson(json['Unauthenticated'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sasl = this.sasl;
    final tls = this.tls;
    final unauthenticated = this.unauthenticated;
    return {
      if (sasl != null) 'Sasl': sasl,
      if (tls != null) 'Tls': tls,
      if (unauthenticated != null) 'Unauthenticated': unauthenticated,
    };
  }
}

/// Provides details for client authentication using SASL.
class AwsMskClusterClusterInfoClientAuthenticationSaslDetails {
  /// Provides details for SASL client authentication using IAM.
  final AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails? iam;

  /// Details for SASL client authentication using SCRAM.
  final AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails? scram;

  AwsMskClusterClusterInfoClientAuthenticationSaslDetails({
    this.iam,
    this.scram,
  });

  factory AwsMskClusterClusterInfoClientAuthenticationSaslDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoClientAuthenticationSaslDetails(
      iam: json['Iam'] != null
          ? AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails.fromJson(
              json['Iam'] as Map<String, dynamic>)
          : null,
      scram: json['Scram'] != null
          ? AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails
              .fromJson(json['Scram'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final iam = this.iam;
    final scram = this.scram;
    return {
      if (iam != null) 'Iam': iam,
      if (scram != null) 'Scram': scram,
    };
  }
}

/// Details for SASL/IAM client authentication.
class AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails {
  /// Indicates whether SASL/IAM authentication is enabled or not.
  final bool? enabled;

  AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails({
    this.enabled,
  });

  factory AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoClientAuthenticationSaslIamDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Details for SASL/SCRAM client authentication.
class AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails {
  /// Indicates whether SASL/SCRAM authentication is enabled or not.
  final bool? enabled;

  AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails({
    this.enabled,
  });

  factory AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoClientAuthenticationSaslScramDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Provides details for client authentication using TLS.
class AwsMskClusterClusterInfoClientAuthenticationTlsDetails {
  /// List of Amazon Web Services Private CA Amazon Resource Names (ARNs). Amazon
  /// Web Services Private CA enables creation of private certificate authority
  /// (CA) hierarchies, including root and subordinate CAs, without the investment
  /// and maintenance costs of operating an on-premises CA.
  final List<String>? certificateAuthorityArnList;

  /// Indicates whether TLS authentication is enabled or not.
  final bool? enabled;

  AwsMskClusterClusterInfoClientAuthenticationTlsDetails({
    this.certificateAuthorityArnList,
    this.enabled,
  });

  factory AwsMskClusterClusterInfoClientAuthenticationTlsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoClientAuthenticationTlsDetails(
      certificateAuthorityArnList:
          (json['CertificateAuthorityArnList'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final certificateAuthorityArnList = this.certificateAuthorityArnList;
    final enabled = this.enabled;
    return {
      if (certificateAuthorityArnList != null)
        'CertificateAuthorityArnList': certificateAuthorityArnList,
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Provides details for allowing no client authentication.
class AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails {
  /// Indicates whether unauthenticated is allowed or not.
  final bool? enabled;

  AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails({
    this.enabled,
  });

  factory AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoClientAuthenticationUnauthenticatedDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Provide details about an Amazon Managed Streaming for Apache Kafka (Amazon
/// MSK) cluster.
class AwsMskClusterClusterInfoDetails {
  /// Provides information for different modes of client authentication.
  final AwsMskClusterClusterInfoClientAuthenticationDetails?
      clientAuthentication;

  /// The name of the cluster.
  final String? clusterName;

  /// The current version of the cluster.
  final String? currentVersion;

  /// Includes encryption-related information, such as the KMS key used for
  /// encrypting data at rest and whether you want Amazon MSK to encrypt your data
  /// in transit.
  final AwsMskClusterClusterInfoEncryptionInfoDetails? encryptionInfo;

  /// Specifies the level of monitoring for the cluster.
  final String? enhancedMonitoring;

  /// The number of broker nodes in the cluster.
  final int? numberOfBrokerNodes;

  AwsMskClusterClusterInfoDetails({
    this.clientAuthentication,
    this.clusterName,
    this.currentVersion,
    this.encryptionInfo,
    this.enhancedMonitoring,
    this.numberOfBrokerNodes,
  });

  factory AwsMskClusterClusterInfoDetails.fromJson(Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoDetails(
      clientAuthentication: json['ClientAuthentication'] != null
          ? AwsMskClusterClusterInfoClientAuthenticationDetails.fromJson(
              json['ClientAuthentication'] as Map<String, dynamic>)
          : null,
      clusterName: json['ClusterName'] as String?,
      currentVersion: json['CurrentVersion'] as String?,
      encryptionInfo: json['EncryptionInfo'] != null
          ? AwsMskClusterClusterInfoEncryptionInfoDetails.fromJson(
              json['EncryptionInfo'] as Map<String, dynamic>)
          : null,
      enhancedMonitoring: json['EnhancedMonitoring'] as String?,
      numberOfBrokerNodes: json['NumberOfBrokerNodes'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final clientAuthentication = this.clientAuthentication;
    final clusterName = this.clusterName;
    final currentVersion = this.currentVersion;
    final encryptionInfo = this.encryptionInfo;
    final enhancedMonitoring = this.enhancedMonitoring;
    final numberOfBrokerNodes = this.numberOfBrokerNodes;
    return {
      if (clientAuthentication != null)
        'ClientAuthentication': clientAuthentication,
      if (clusterName != null) 'ClusterName': clusterName,
      if (currentVersion != null) 'CurrentVersion': currentVersion,
      if (encryptionInfo != null) 'EncryptionInfo': encryptionInfo,
      if (enhancedMonitoring != null) 'EnhancedMonitoring': enhancedMonitoring,
      if (numberOfBrokerNodes != null)
        'NumberOfBrokerNodes': numberOfBrokerNodes,
    };
  }
}

/// Includes encryption-related information, such as the KMS key used for
/// encrypting data at rest and whether you want MSK to encrypt your data in
/// transit.
class AwsMskClusterClusterInfoEncryptionInfoDetails {
  /// The data-volume encryption details. You can't update encryption at rest
  /// settings for existing clusters.
  final AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails?
      encryptionAtRest;

  /// The settings for encrypting data in transit.
  final AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails?
      encryptionInTransit;

  AwsMskClusterClusterInfoEncryptionInfoDetails({
    this.encryptionAtRest,
    this.encryptionInTransit,
  });

  factory AwsMskClusterClusterInfoEncryptionInfoDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoEncryptionInfoDetails(
      encryptionAtRest: json['EncryptionAtRest'] != null
          ? AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails
              .fromJson(json['EncryptionAtRest'] as Map<String, dynamic>)
          : null,
      encryptionInTransit: json['EncryptionInTransit'] != null
          ? AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails
              .fromJson(json['EncryptionInTransit'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final encryptionAtRest = this.encryptionAtRest;
    final encryptionInTransit = this.encryptionInTransit;
    return {
      if (encryptionAtRest != null) 'EncryptionAtRest': encryptionAtRest,
      if (encryptionInTransit != null)
        'EncryptionInTransit': encryptionInTransit,
    };
  }
}

/// The data-volume encryption details. You can't update encryption at rest
/// settings for existing clusters.
class AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails {
  /// The Amazon Resource Name (ARN) of the KMS key for encrypting data at rest.
  /// If you don't specify a KMS key, MSK creates one for you and uses it.
  final String? dataVolumeKMSKeyId;

  AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails({
    this.dataVolumeKMSKeyId,
  });

  factory AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoEncryptionInfoEncryptionAtRestDetails(
      dataVolumeKMSKeyId: json['DataVolumeKMSKeyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataVolumeKMSKeyId = this.dataVolumeKMSKeyId;
    return {
      if (dataVolumeKMSKeyId != null) 'DataVolumeKMSKeyId': dataVolumeKMSKeyId,
    };
  }
}

/// The settings for encrypting data in transit.
class AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails {
  /// Indicates the encryption setting for data in transit between clients and
  /// brokers.
  final String? clientBroker;

  /// When set to <code>true</code>, it indicates that data communication among
  /// the broker nodes of the cluster is encrypted. When set to
  /// <code>false</code>, the communication happens in plain text. The default
  /// value is <code>true</code>.
  final bool? inCluster;

  AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails({
    this.clientBroker,
    this.inCluster,
  });

  factory AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsMskClusterClusterInfoEncryptionInfoEncryptionInTransitDetails(
      clientBroker: json['ClientBroker'] as String?,
      inCluster: json['InCluster'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final clientBroker = this.clientBroker;
    final inCluster = this.inCluster;
    return {
      if (clientBroker != null) 'ClientBroker': clientBroker,
      if (inCluster != null) 'InCluster': inCluster,
    };
  }
}

/// Provides details about an Amazon Managed Streaming for Apache Kafka (Amazon
/// MSK) cluster.
class AwsMskClusterDetails {
  /// Provides information about a cluster.
  final AwsMskClusterClusterInfoDetails? clusterInfo;

  AwsMskClusterDetails({
    this.clusterInfo,
  });

  factory AwsMskClusterDetails.fromJson(Map<String, dynamic> json) {
    return AwsMskClusterDetails(
      clusterInfo: json['ClusterInfo'] != null
          ? AwsMskClusterClusterInfoDetails.fromJson(
              json['ClusterInfo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final clusterInfo = this.clusterInfo;
    return {
      if (clusterInfo != null) 'ClusterInfo': clusterInfo,
    };
  }
}

/// Details about an Network Firewall firewall.
class AwsNetworkFirewallFirewallDetails {
  /// Whether the firewall is protected from deletion. If set to
  /// <code>true</code>, then the firewall cannot be deleted.
  final bool? deleteProtection;

  /// A description of the firewall.
  final String? description;

  /// The ARN of the firewall.
  final String? firewallArn;

  /// The identifier of the firewall.
  final String? firewallId;

  /// A descriptive name of the firewall.
  final String? firewallName;

  /// The ARN of the firewall policy.
  final String? firewallPolicyArn;

  /// Whether the firewall is protected from a change to the firewall policy. If
  /// set to <code>true</code>, you cannot associate a different policy with the
  /// firewall.
  final bool? firewallPolicyChangeProtection;

  /// Whether the firewall is protected from a change to the subnet associations.
  /// If set to <code>true</code>, you cannot map different subnets to the
  /// firewall.
  final bool? subnetChangeProtection;

  /// The public subnets that Network Firewall uses for the firewall. Each subnet
  /// must belong to a different Availability Zone.
  final List<AwsNetworkFirewallFirewallSubnetMappingsDetails>? subnetMappings;

  /// The identifier of the VPC where the firewall is used.
  final String? vpcId;

  AwsNetworkFirewallFirewallDetails({
    this.deleteProtection,
    this.description,
    this.firewallArn,
    this.firewallId,
    this.firewallName,
    this.firewallPolicyArn,
    this.firewallPolicyChangeProtection,
    this.subnetChangeProtection,
    this.subnetMappings,
    this.vpcId,
  });

  factory AwsNetworkFirewallFirewallDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsNetworkFirewallFirewallDetails(
      deleteProtection: json['DeleteProtection'] as bool?,
      description: json['Description'] as String?,
      firewallArn: json['FirewallArn'] as String?,
      firewallId: json['FirewallId'] as String?,
      firewallName: json['FirewallName'] as String?,
      firewallPolicyArn: json['FirewallPolicyArn'] as String?,
      firewallPolicyChangeProtection:
          json['FirewallPolicyChangeProtection'] as bool?,
      subnetChangeProtection: json['SubnetChangeProtection'] as bool?,
      subnetMappings: (json['SubnetMappings'] as List?)
          ?.whereNotNull()
          .map((e) => AwsNetworkFirewallFirewallSubnetMappingsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deleteProtection = this.deleteProtection;
    final description = this.description;
    final firewallArn = this.firewallArn;
    final firewallId = this.firewallId;
    final firewallName = this.firewallName;
    final firewallPolicyArn = this.firewallPolicyArn;
    final firewallPolicyChangeProtection = this.firewallPolicyChangeProtection;
    final subnetChangeProtection = this.subnetChangeProtection;
    final subnetMappings = this.subnetMappings;
    final vpcId = this.vpcId;
    return {
      if (deleteProtection != null) 'DeleteProtection': deleteProtection,
      if (description != null) 'Description': description,
      if (firewallArn != null) 'FirewallArn': firewallArn,
      if (firewallId != null) 'FirewallId': firewallId,
      if (firewallName != null) 'FirewallName': firewallName,
      if (firewallPolicyArn != null) 'FirewallPolicyArn': firewallPolicyArn,
      if (firewallPolicyChangeProtection != null)
        'FirewallPolicyChangeProtection': firewallPolicyChangeProtection,
      if (subnetChangeProtection != null)
        'SubnetChangeProtection': subnetChangeProtection,
      if (subnetMappings != null) 'SubnetMappings': subnetMappings,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Details about a firewall policy. A firewall policy defines the behavior of a
/// network firewall.
class AwsNetworkFirewallFirewallPolicyDetails {
  /// A description of the firewall policy.
  final String? description;

  /// The firewall policy configuration.
  final FirewallPolicyDetails? firewallPolicy;

  /// The ARN of the firewall policy.
  final String? firewallPolicyArn;

  /// The identifier of the firewall policy.
  final String? firewallPolicyId;

  /// The name of the firewall policy.
  final String? firewallPolicyName;

  AwsNetworkFirewallFirewallPolicyDetails({
    this.description,
    this.firewallPolicy,
    this.firewallPolicyArn,
    this.firewallPolicyId,
    this.firewallPolicyName,
  });

  factory AwsNetworkFirewallFirewallPolicyDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsNetworkFirewallFirewallPolicyDetails(
      description: json['Description'] as String?,
      firewallPolicy: json['FirewallPolicy'] != null
          ? FirewallPolicyDetails.fromJson(
              json['FirewallPolicy'] as Map<String, dynamic>)
          : null,
      firewallPolicyArn: json['FirewallPolicyArn'] as String?,
      firewallPolicyId: json['FirewallPolicyId'] as String?,
      firewallPolicyName: json['FirewallPolicyName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final firewallPolicy = this.firewallPolicy;
    final firewallPolicyArn = this.firewallPolicyArn;
    final firewallPolicyId = this.firewallPolicyId;
    final firewallPolicyName = this.firewallPolicyName;
    return {
      if (description != null) 'Description': description,
      if (firewallPolicy != null) 'FirewallPolicy': firewallPolicy,
      if (firewallPolicyArn != null) 'FirewallPolicyArn': firewallPolicyArn,
      if (firewallPolicyId != null) 'FirewallPolicyId': firewallPolicyId,
      if (firewallPolicyName != null) 'FirewallPolicyName': firewallPolicyName,
    };
  }
}

/// A public subnet that Network Firewall uses for the firewall.
class AwsNetworkFirewallFirewallSubnetMappingsDetails {
  /// The identifier of the subnet
  final String? subnetId;

  AwsNetworkFirewallFirewallSubnetMappingsDetails({
    this.subnetId,
  });

  factory AwsNetworkFirewallFirewallSubnetMappingsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsNetworkFirewallFirewallSubnetMappingsDetails(
      subnetId: json['SubnetId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final subnetId = this.subnetId;
    return {
      if (subnetId != null) 'SubnetId': subnetId,
    };
  }
}

/// Details about an Network Firewall rule group. Rule groups are used to
/// inspect and control network traffic. Stateless rule groups apply to
/// individual packets. Stateful rule groups apply to packets in the context of
/// their traffic flow.
///
/// Rule groups are referenced in firewall policies.
class AwsNetworkFirewallRuleGroupDetails {
  /// The maximum number of operating resources that this rule group can use.
  final int? capacity;

  /// A description of the rule group.
  final String? description;

  /// Details about the rule group.
  final RuleGroupDetails? ruleGroup;

  /// The ARN of the rule group.
  final String? ruleGroupArn;

  /// The identifier of the rule group.
  final String? ruleGroupId;

  /// The descriptive name of the rule group.
  final String? ruleGroupName;

  /// The type of rule group. A rule group can be stateful or stateless.
  final String? type;

  AwsNetworkFirewallRuleGroupDetails({
    this.capacity,
    this.description,
    this.ruleGroup,
    this.ruleGroupArn,
    this.ruleGroupId,
    this.ruleGroupName,
    this.type,
  });

  factory AwsNetworkFirewallRuleGroupDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsNetworkFirewallRuleGroupDetails(
      capacity: json['Capacity'] as int?,
      description: json['Description'] as String?,
      ruleGroup: json['RuleGroup'] != null
          ? RuleGroupDetails.fromJson(json['RuleGroup'] as Map<String, dynamic>)
          : null,
      ruleGroupArn: json['RuleGroupArn'] as String?,
      ruleGroupId: json['RuleGroupId'] as String?,
      ruleGroupName: json['RuleGroupName'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final capacity = this.capacity;
    final description = this.description;
    final ruleGroup = this.ruleGroup;
    final ruleGroupArn = this.ruleGroupArn;
    final ruleGroupId = this.ruleGroupId;
    final ruleGroupName = this.ruleGroupName;
    final type = this.type;
    return {
      if (capacity != null) 'Capacity': capacity,
      if (description != null) 'Description': description,
      if (ruleGroup != null) 'RuleGroup': ruleGroup,
      if (ruleGroupArn != null) 'RuleGroupArn': ruleGroupArn,
      if (ruleGroupId != null) 'RuleGroupId': ruleGroupId,
      if (ruleGroupName != null) 'RuleGroupName': ruleGroupName,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about domain access control options.
class AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails {
  /// Enables fine-grained access control.
  final bool? enabled;

  /// Enables the internal user database.
  final bool? internalUserDatabaseEnabled;

  /// Specifies information about the master user of the domain.
  final AwsOpenSearchServiceDomainMasterUserOptionsDetails? masterUserOptions;

  AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails({
    this.enabled,
    this.internalUserDatabaseEnabled,
    this.masterUserOptions,
  });

  factory AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails(
      enabled: json['Enabled'] as bool?,
      internalUserDatabaseEnabled: json['InternalUserDatabaseEnabled'] as bool?,
      masterUserOptions: json['MasterUserOptions'] != null
          ? AwsOpenSearchServiceDomainMasterUserOptionsDetails.fromJson(
              json['MasterUserOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final internalUserDatabaseEnabled = this.internalUserDatabaseEnabled;
    final masterUserOptions = this.masterUserOptions;
    return {
      if (enabled != null) 'Enabled': enabled,
      if (internalUserDatabaseEnabled != null)
        'InternalUserDatabaseEnabled': internalUserDatabaseEnabled,
      if (masterUserOptions != null) 'MasterUserOptions': masterUserOptions,
    };
  }
}

/// Details about the configuration of an OpenSearch cluster.
class AwsOpenSearchServiceDomainClusterConfigDetails {
  /// The number of instances to use for the master node. If this attribute is
  /// specified, then <code>DedicatedMasterEnabled</code> must be
  /// <code>true</code>.
  final int? dedicatedMasterCount;

  /// Whether to use a dedicated master node for the OpenSearch domain. A
  /// dedicated master node performs cluster management tasks, but does not hold
  /// data or respond to data upload requests.
  final bool? dedicatedMasterEnabled;

  /// The hardware configuration of the computer that hosts the dedicated master
  /// node.
  ///
  /// If this attribute is specified, then <code>DedicatedMasterEnabled</code>
  /// must be <code>true</code>.
  final String? dedicatedMasterType;

  /// The number of data nodes to use in the OpenSearch domain.
  final int? instanceCount;

  /// The instance type for your data nodes.
  ///
  /// For a list of valid values, see <a
  /// href="https://docs.aws.amazon.com/opensearch-service/latest/developerguide/supported-instance-types.html">Supported
  /// instance types in Amazon OpenSearch Service</a> in the <i>Amazon OpenSearch
  /// Service Developer Guide</i>.
  final String? instanceType;

  /// The number of UltraWarm instances.
  final int? warmCount;

  /// Whether UltraWarm is enabled.
  final bool? warmEnabled;

  /// The type of UltraWarm instance.
  final String? warmType;

  /// Configuration options for zone awareness. Provided if
  /// <code>ZoneAwarenessEnabled</code> is <code>true</code>.
  final AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails?
      zoneAwarenessConfig;

  /// Whether to enable zone awareness for the OpenSearch domain. When zone
  /// awareness is enabled, OpenSearch Service allocates the cluster's nodes and
  /// replica index shards across Availability Zones (AZs) in the same Region.
  /// This prevents data loss and minimizes downtime if a node or data center
  /// fails.
  final bool? zoneAwarenessEnabled;

  AwsOpenSearchServiceDomainClusterConfigDetails({
    this.dedicatedMasterCount,
    this.dedicatedMasterEnabled,
    this.dedicatedMasterType,
    this.instanceCount,
    this.instanceType,
    this.warmCount,
    this.warmEnabled,
    this.warmType,
    this.zoneAwarenessConfig,
    this.zoneAwarenessEnabled,
  });

  factory AwsOpenSearchServiceDomainClusterConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainClusterConfigDetails(
      dedicatedMasterCount: json['DedicatedMasterCount'] as int?,
      dedicatedMasterEnabled: json['DedicatedMasterEnabled'] as bool?,
      dedicatedMasterType: json['DedicatedMasterType'] as String?,
      instanceCount: json['InstanceCount'] as int?,
      instanceType: json['InstanceType'] as String?,
      warmCount: json['WarmCount'] as int?,
      warmEnabled: json['WarmEnabled'] as bool?,
      warmType: json['WarmType'] as String?,
      zoneAwarenessConfig: json['ZoneAwarenessConfig'] != null
          ? AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails
              .fromJson(json['ZoneAwarenessConfig'] as Map<String, dynamic>)
          : null,
      zoneAwarenessEnabled: json['ZoneAwarenessEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final dedicatedMasterCount = this.dedicatedMasterCount;
    final dedicatedMasterEnabled = this.dedicatedMasterEnabled;
    final dedicatedMasterType = this.dedicatedMasterType;
    final instanceCount = this.instanceCount;
    final instanceType = this.instanceType;
    final warmCount = this.warmCount;
    final warmEnabled = this.warmEnabled;
    final warmType = this.warmType;
    final zoneAwarenessConfig = this.zoneAwarenessConfig;
    final zoneAwarenessEnabled = this.zoneAwarenessEnabled;
    return {
      if (dedicatedMasterCount != null)
        'DedicatedMasterCount': dedicatedMasterCount,
      if (dedicatedMasterEnabled != null)
        'DedicatedMasterEnabled': dedicatedMasterEnabled,
      if (dedicatedMasterType != null)
        'DedicatedMasterType': dedicatedMasterType,
      if (instanceCount != null) 'InstanceCount': instanceCount,
      if (instanceType != null) 'InstanceType': instanceType,
      if (warmCount != null) 'WarmCount': warmCount,
      if (warmEnabled != null) 'WarmEnabled': warmEnabled,
      if (warmType != null) 'WarmType': warmType,
      if (zoneAwarenessConfig != null)
        'ZoneAwarenessConfig': zoneAwarenessConfig,
      if (zoneAwarenessEnabled != null)
        'ZoneAwarenessEnabled': zoneAwarenessEnabled,
    };
  }
}

/// Configuration options for zone awareness.
class AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails {
  /// The number of Availability Zones that the domain uses. Valid values are
  /// <code>2</code> or <code>3</code>. The default is <code>2</code>.
  final int? availabilityZoneCount;

  AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails({
    this.availabilityZoneCount,
  });

  factory AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainClusterConfigZoneAwarenessConfigDetails(
      availabilityZoneCount: json['AvailabilityZoneCount'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZoneCount = this.availabilityZoneCount;
    return {
      if (availabilityZoneCount != null)
        'AvailabilityZoneCount': availabilityZoneCount,
    };
  }
}

/// Information about an Amazon OpenSearch Service domain.
class AwsOpenSearchServiceDomainDetails {
  /// IAM policy document that specifies the access policies for the OpenSearch
  /// Service domain.
  final String? accessPolicies;

  /// Specifies options for fine-grained access control.
  final AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails?
      advancedSecurityOptions;

  /// The ARN of the OpenSearch Service domain.
  final String? arn;

  /// Details about the configuration of an OpenSearch cluster.
  final AwsOpenSearchServiceDomainClusterConfigDetails? clusterConfig;

  /// The domain endpoint.
  final String? domainEndpoint;

  /// Additional options for the domain endpoint.
  final AwsOpenSearchServiceDomainDomainEndpointOptionsDetails?
      domainEndpointOptions;

  /// The domain endpoints. Used if the OpenSearch domain resides in a VPC.
  ///
  /// This is a map of key-value pairs. The key is always <code>vpc</code>. The
  /// value is the endpoint.
  final Map<String, String>? domainEndpoints;

  /// The name of the endpoint.
  final String? domainName;

  /// Details about the configuration for encryption at rest.
  final AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails?
      encryptionAtRestOptions;

  /// The version of the domain engine.
  final String? engineVersion;

  /// The identifier of the domain.
  final String? id;

  /// Configures the CloudWatch Logs to publish for the OpenSearch domain.
  final AwsOpenSearchServiceDomainLogPublishingOptionsDetails?
      logPublishingOptions;

  /// Details about the configuration for node-to-node encryption.
  final AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails?
      nodeToNodeEncryptionOptions;

  /// Information about the status of a domain relative to the latest service
  /// software.
  final AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails?
      serviceSoftwareOptions;

  /// Information that OpenSearch Service derives based on <code>VPCOptions</code>
  /// for the domain.
  final AwsOpenSearchServiceDomainVpcOptionsDetails? vpcOptions;

  AwsOpenSearchServiceDomainDetails({
    this.accessPolicies,
    this.advancedSecurityOptions,
    this.arn,
    this.clusterConfig,
    this.domainEndpoint,
    this.domainEndpointOptions,
    this.domainEndpoints,
    this.domainName,
    this.encryptionAtRestOptions,
    this.engineVersion,
    this.id,
    this.logPublishingOptions,
    this.nodeToNodeEncryptionOptions,
    this.serviceSoftwareOptions,
    this.vpcOptions,
  });

  factory AwsOpenSearchServiceDomainDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainDetails(
      accessPolicies: json['AccessPolicies'] as String?,
      advancedSecurityOptions: json['AdvancedSecurityOptions'] != null
          ? AwsOpenSearchServiceDomainAdvancedSecurityOptionsDetails.fromJson(
              json['AdvancedSecurityOptions'] as Map<String, dynamic>)
          : null,
      arn: json['Arn'] as String?,
      clusterConfig: json['ClusterConfig'] != null
          ? AwsOpenSearchServiceDomainClusterConfigDetails.fromJson(
              json['ClusterConfig'] as Map<String, dynamic>)
          : null,
      domainEndpoint: json['DomainEndpoint'] as String?,
      domainEndpointOptions: json['DomainEndpointOptions'] != null
          ? AwsOpenSearchServiceDomainDomainEndpointOptionsDetails.fromJson(
              json['DomainEndpointOptions'] as Map<String, dynamic>)
          : null,
      domainEndpoints: (json['DomainEndpoints'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      domainName: json['DomainName'] as String?,
      encryptionAtRestOptions: json['EncryptionAtRestOptions'] != null
          ? AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails.fromJson(
              json['EncryptionAtRestOptions'] as Map<String, dynamic>)
          : null,
      engineVersion: json['EngineVersion'] as String?,
      id: json['Id'] as String?,
      logPublishingOptions: json['LogPublishingOptions'] != null
          ? AwsOpenSearchServiceDomainLogPublishingOptionsDetails.fromJson(
              json['LogPublishingOptions'] as Map<String, dynamic>)
          : null,
      nodeToNodeEncryptionOptions: json['NodeToNodeEncryptionOptions'] != null
          ? AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails
              .fromJson(
                  json['NodeToNodeEncryptionOptions'] as Map<String, dynamic>)
          : null,
      serviceSoftwareOptions: json['ServiceSoftwareOptions'] != null
          ? AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails.fromJson(
              json['ServiceSoftwareOptions'] as Map<String, dynamic>)
          : null,
      vpcOptions: json['VpcOptions'] != null
          ? AwsOpenSearchServiceDomainVpcOptionsDetails.fromJson(
              json['VpcOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessPolicies = this.accessPolicies;
    final advancedSecurityOptions = this.advancedSecurityOptions;
    final arn = this.arn;
    final clusterConfig = this.clusterConfig;
    final domainEndpoint = this.domainEndpoint;
    final domainEndpointOptions = this.domainEndpointOptions;
    final domainEndpoints = this.domainEndpoints;
    final domainName = this.domainName;
    final encryptionAtRestOptions = this.encryptionAtRestOptions;
    final engineVersion = this.engineVersion;
    final id = this.id;
    final logPublishingOptions = this.logPublishingOptions;
    final nodeToNodeEncryptionOptions = this.nodeToNodeEncryptionOptions;
    final serviceSoftwareOptions = this.serviceSoftwareOptions;
    final vpcOptions = this.vpcOptions;
    return {
      if (accessPolicies != null) 'AccessPolicies': accessPolicies,
      if (advancedSecurityOptions != null)
        'AdvancedSecurityOptions': advancedSecurityOptions,
      if (arn != null) 'Arn': arn,
      if (clusterConfig != null) 'ClusterConfig': clusterConfig,
      if (domainEndpoint != null) 'DomainEndpoint': domainEndpoint,
      if (domainEndpointOptions != null)
        'DomainEndpointOptions': domainEndpointOptions,
      if (domainEndpoints != null) 'DomainEndpoints': domainEndpoints,
      if (domainName != null) 'DomainName': domainName,
      if (encryptionAtRestOptions != null)
        'EncryptionAtRestOptions': encryptionAtRestOptions,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (id != null) 'Id': id,
      if (logPublishingOptions != null)
        'LogPublishingOptions': logPublishingOptions,
      if (nodeToNodeEncryptionOptions != null)
        'NodeToNodeEncryptionOptions': nodeToNodeEncryptionOptions,
      if (serviceSoftwareOptions != null)
        'ServiceSoftwareOptions': serviceSoftwareOptions,
      if (vpcOptions != null) 'VpcOptions': vpcOptions,
    };
  }
}

/// Information about additional options for the domain endpoint.
class AwsOpenSearchServiceDomainDomainEndpointOptionsDetails {
  /// The fully qualified URL for the custom endpoint.
  final String? customEndpoint;

  /// The ARN for the security certificate. The certificate is managed in ACM.
  final String? customEndpointCertificateArn;

  /// Whether to enable a custom endpoint for the domain.
  final bool? customEndpointEnabled;

  /// Whether to require that all traffic to the domain arrive over HTTPS.
  final bool? enforceHTTPS;

  /// The TLS security policy to apply to the HTTPS endpoint of the OpenSearch
  /// domain.
  final String? tLSSecurityPolicy;

  AwsOpenSearchServiceDomainDomainEndpointOptionsDetails({
    this.customEndpoint,
    this.customEndpointCertificateArn,
    this.customEndpointEnabled,
    this.enforceHTTPS,
    this.tLSSecurityPolicy,
  });

  factory AwsOpenSearchServiceDomainDomainEndpointOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainDomainEndpointOptionsDetails(
      customEndpoint: json['CustomEndpoint'] as String?,
      customEndpointCertificateArn:
          json['CustomEndpointCertificateArn'] as String?,
      customEndpointEnabled: json['CustomEndpointEnabled'] as bool?,
      enforceHTTPS: json['EnforceHTTPS'] as bool?,
      tLSSecurityPolicy: json['TLSSecurityPolicy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final customEndpoint = this.customEndpoint;
    final customEndpointCertificateArn = this.customEndpointCertificateArn;
    final customEndpointEnabled = this.customEndpointEnabled;
    final enforceHTTPS = this.enforceHTTPS;
    final tLSSecurityPolicy = this.tLSSecurityPolicy;
    return {
      if (customEndpoint != null) 'CustomEndpoint': customEndpoint,
      if (customEndpointCertificateArn != null)
        'CustomEndpointCertificateArn': customEndpointCertificateArn,
      if (customEndpointEnabled != null)
        'CustomEndpointEnabled': customEndpointEnabled,
      if (enforceHTTPS != null) 'EnforceHTTPS': enforceHTTPS,
      if (tLSSecurityPolicy != null) 'TLSSecurityPolicy': tLSSecurityPolicy,
    };
  }
}

/// Details about the configuration for encryption at rest for the OpenSearch
/// domain.
class AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails {
  /// Whether encryption at rest is enabled.
  final bool? enabled;

  /// The KMS key ID.
  final String? kmsKeyId;

  AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails({
    this.enabled,
    this.kmsKeyId,
  });

  factory AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainEncryptionAtRestOptionsDetails(
      enabled: json['Enabled'] as bool?,
      kmsKeyId: json['KmsKeyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    final kmsKeyId = this.kmsKeyId;
    return {
      if (enabled != null) 'Enabled': enabled,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
    };
  }
}

/// Configuration details for a log publishing option.
class AwsOpenSearchServiceDomainLogPublishingOption {
  /// The ARN of the CloudWatch Logs group to publish the logs to.
  final String? cloudWatchLogsLogGroupArn;

  /// Whether the log publishing is enabled.
  final bool? enabled;

  AwsOpenSearchServiceDomainLogPublishingOption({
    this.cloudWatchLogsLogGroupArn,
    this.enabled,
  });

  factory AwsOpenSearchServiceDomainLogPublishingOption.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainLogPublishingOption(
      cloudWatchLogsLogGroupArn: json['CloudWatchLogsLogGroupArn'] as String?,
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsLogGroupArn = this.cloudWatchLogsLogGroupArn;
    final enabled = this.enabled;
    return {
      if (cloudWatchLogsLogGroupArn != null)
        'CloudWatchLogsLogGroupArn': cloudWatchLogsLogGroupArn,
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Configures the CloudWatch Logs to publish for the OpenSearch domain.
class AwsOpenSearchServiceDomainLogPublishingOptionsDetails {
  /// Configures the OpenSearch audit logs publishing.
  final AwsOpenSearchServiceDomainLogPublishingOption? auditLogs;

  /// Configures the OpenSearch index logs publishing.
  final AwsOpenSearchServiceDomainLogPublishingOption? indexSlowLogs;

  /// Configures the OpenSearch search slow log publishing.
  final AwsOpenSearchServiceDomainLogPublishingOption? searchSlowLogs;

  AwsOpenSearchServiceDomainLogPublishingOptionsDetails({
    this.auditLogs,
    this.indexSlowLogs,
    this.searchSlowLogs,
  });

  factory AwsOpenSearchServiceDomainLogPublishingOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainLogPublishingOptionsDetails(
      auditLogs: json['AuditLogs'] != null
          ? AwsOpenSearchServiceDomainLogPublishingOption.fromJson(
              json['AuditLogs'] as Map<String, dynamic>)
          : null,
      indexSlowLogs: json['IndexSlowLogs'] != null
          ? AwsOpenSearchServiceDomainLogPublishingOption.fromJson(
              json['IndexSlowLogs'] as Map<String, dynamic>)
          : null,
      searchSlowLogs: json['SearchSlowLogs'] != null
          ? AwsOpenSearchServiceDomainLogPublishingOption.fromJson(
              json['SearchSlowLogs'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final auditLogs = this.auditLogs;
    final indexSlowLogs = this.indexSlowLogs;
    final searchSlowLogs = this.searchSlowLogs;
    return {
      if (auditLogs != null) 'AuditLogs': auditLogs,
      if (indexSlowLogs != null) 'IndexSlowLogs': indexSlowLogs,
      if (searchSlowLogs != null) 'SearchSlowLogs': searchSlowLogs,
    };
  }
}

/// Specifies information about the master user of the domain.
class AwsOpenSearchServiceDomainMasterUserOptionsDetails {
  /// The Amazon Resource Name (ARN) for the master user.
  final String? masterUserArn;

  /// The username for the master user.
  final String? masterUserName;

  /// The password for the master user.
  final String? masterUserPassword;

  AwsOpenSearchServiceDomainMasterUserOptionsDetails({
    this.masterUserArn,
    this.masterUserName,
    this.masterUserPassword,
  });

  factory AwsOpenSearchServiceDomainMasterUserOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainMasterUserOptionsDetails(
      masterUserArn: json['MasterUserArn'] as String?,
      masterUserName: json['MasterUserName'] as String?,
      masterUserPassword: json['MasterUserPassword'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final masterUserArn = this.masterUserArn;
    final masterUserName = this.masterUserName;
    final masterUserPassword = this.masterUserPassword;
    return {
      if (masterUserArn != null) 'MasterUserArn': masterUserArn,
      if (masterUserName != null) 'MasterUserName': masterUserName,
      if (masterUserPassword != null) 'MasterUserPassword': masterUserPassword,
    };
  }
}

/// Provides details about the configuration for node-to-node encryption.
class AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails {
  /// Whether node-to-node encryption is enabled.
  final bool? enabled;

  AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails({
    this.enabled,
  });

  factory AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainNodeToNodeEncryptionOptionsDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Provides information about the state of the domain relative to the latest
/// service software.
class AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails {
  /// The epoch time when the deployment window closes for required updates. After
  /// this time, OpenSearch Service schedules the software upgrade automatically.
  final String? automatedUpdateDate;

  /// Whether a request to update the domain can be canceled.
  final bool? cancellable;

  /// The version of the service software that is currently installed on the
  /// domain.
  final String? currentVersion;

  /// A more detailed description of the service software status.
  final String? description;

  /// The most recent version of the service software.
  final String? newVersion;

  /// Whether the service software update is optional.
  final bool? optionalDeployment;

  /// Whether a service software update is available for the domain.
  final bool? updateAvailable;

  /// The status of the service software update. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>COMPLETED</code>
  /// </li>
  /// <li>
  /// <code>ELIGIBLE</code>
  /// </li>
  /// <li>
  /// <code>IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>NOT_ELIGIBLE</code>
  /// </li>
  /// <li>
  /// <code>PENDING_UPDATE</code>
  /// </li>
  /// </ul>
  final String? updateStatus;

  AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails({
    this.automatedUpdateDate,
    this.cancellable,
    this.currentVersion,
    this.description,
    this.newVersion,
    this.optionalDeployment,
    this.updateAvailable,
    this.updateStatus,
  });

  factory AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainServiceSoftwareOptionsDetails(
      automatedUpdateDate: json['AutomatedUpdateDate'] as String?,
      cancellable: json['Cancellable'] as bool?,
      currentVersion: json['CurrentVersion'] as String?,
      description: json['Description'] as String?,
      newVersion: json['NewVersion'] as String?,
      optionalDeployment: json['OptionalDeployment'] as bool?,
      updateAvailable: json['UpdateAvailable'] as bool?,
      updateStatus: json['UpdateStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final automatedUpdateDate = this.automatedUpdateDate;
    final cancellable = this.cancellable;
    final currentVersion = this.currentVersion;
    final description = this.description;
    final newVersion = this.newVersion;
    final optionalDeployment = this.optionalDeployment;
    final updateAvailable = this.updateAvailable;
    final updateStatus = this.updateStatus;
    return {
      if (automatedUpdateDate != null)
        'AutomatedUpdateDate': automatedUpdateDate,
      if (cancellable != null) 'Cancellable': cancellable,
      if (currentVersion != null) 'CurrentVersion': currentVersion,
      if (description != null) 'Description': description,
      if (newVersion != null) 'NewVersion': newVersion,
      if (optionalDeployment != null) 'OptionalDeployment': optionalDeployment,
      if (updateAvailable != null) 'UpdateAvailable': updateAvailable,
      if (updateStatus != null) 'UpdateStatus': updateStatus,
    };
  }
}

/// Contains information that OpenSearch Service derives based on the
/// <code>VPCOptions</code> for the domain.
class AwsOpenSearchServiceDomainVpcOptionsDetails {
  /// The list of security group IDs that are associated with the VPC endpoints
  /// for the domain.
  final List<String>? securityGroupIds;

  /// A list of subnet IDs that are associated with the VPC endpoints for the
  /// domain.
  final List<String>? subnetIds;

  AwsOpenSearchServiceDomainVpcOptionsDetails({
    this.securityGroupIds,
    this.subnetIds,
  });

  factory AwsOpenSearchServiceDomainVpcOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsOpenSearchServiceDomainVpcOptionsDetails(
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnetIds: (json['SubnetIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final securityGroupIds = this.securityGroupIds;
    final subnetIds = this.subnetIds;
    return {
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (subnetIds != null) 'SubnetIds': subnetIds,
    };
  }
}

/// An IAM role that is associated with the Amazon RDS DB cluster.
class AwsRdsDbClusterAssociatedRole {
  /// The ARN of the IAM role.
  final String? roleArn;

  /// The status of the association between the IAM role and the DB cluster. Valid
  /// values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ACTIVE</code>
  /// </li>
  /// <li>
  /// <code>INVALID</code>
  /// </li>
  /// <li>
  /// <code>PENDING</code>
  /// </li>
  /// </ul>
  final String? status;

  AwsRdsDbClusterAssociatedRole({
    this.roleArn,
    this.status,
  });

  factory AwsRdsDbClusterAssociatedRole.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbClusterAssociatedRole(
      roleArn: json['RoleArn'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final roleArn = this.roleArn;
    final status = this.status;
    return {
      if (roleArn != null) 'RoleArn': roleArn,
      if (status != null) 'Status': status,
    };
  }
}

/// Information about an Amazon RDS DB cluster.
class AwsRdsDbClusterDetails {
  /// The status of the database activity stream. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>started</code>
  /// </li>
  /// <li>
  /// <code>starting</code>
  /// </li>
  /// <li>
  /// <code>stopped</code>
  /// </li>
  /// <li>
  /// <code>stopping</code>
  /// </li>
  /// </ul>
  final String? activityStreamStatus;

  /// For all database engines except Aurora, specifies the allocated storage size
  /// in gibibytes (GiB).
  final int? allocatedStorage;

  /// A list of the IAM roles that are associated with the DB cluster.
  final List<AwsRdsDbClusterAssociatedRole>? associatedRoles;

  /// Indicates if minor version upgrades are automatically applied to the
  /// cluster.
  final bool? autoMinorVersionUpgrade;

  /// A list of Availability Zones (AZs) where instances in the DB cluster can be
  /// created.
  final List<String>? availabilityZones;

  /// The number of days for which automated backups are retained.
  final int? backupRetentionPeriod;

  /// Indicates when the DB cluster was created, in Universal Coordinated Time
  /// (UTC).
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? clusterCreateTime;

  /// Whether tags are copied from the DB cluster to snapshots of the DB cluster.
  final bool? copyTagsToSnapshot;

  /// Whether the DB cluster is a clone of a DB cluster owned by a different
  /// Amazon Web Services account.
  final bool? crossAccountClone;

  /// A list of custom endpoints for the DB cluster.
  final List<String>? customEndpoints;

  /// The name of the database.
  final String? databaseName;

  /// The DB cluster identifier that the user assigned to the cluster. This
  /// identifier is the unique key that identifies a DB cluster.
  final String? dbClusterIdentifier;

  /// The list of instances that make up the DB cluster.
  final List<AwsRdsDbClusterMember>? dbClusterMembers;

  /// The list of option group memberships for this DB cluster.
  final List<AwsRdsDbClusterOptionGroupMembership>?
      dbClusterOptionGroupMemberships;

  /// The name of the DB cluster parameter group for the DB cluster.
  final String? dbClusterParameterGroup;

  /// The identifier of the DB cluster. The identifier must be unique within each
  /// Amazon Web Services Region and is immutable.
  final String? dbClusterResourceId;

  /// The subnet group that is associated with the DB cluster, including the name,
  /// description, and subnets in the subnet group.
  final String? dbSubnetGroup;

  /// Whether the DB cluster has deletion protection enabled.
  final bool? deletionProtection;

  /// The Active Directory domain membership records that are associated with the
  /// DB cluster.
  final List<AwsRdsDbDomainMembership>? domainMemberships;

  /// A list of log types that this DB cluster is configured to export to
  /// CloudWatch Logs.
  final List<String>? enabledCloudWatchLogsExports;

  /// The connection endpoint for the primary instance of the DB cluster.
  final String? endpoint;

  /// The name of the database engine to use for this DB cluster. Valid values are
  /// as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>aurora</code>
  /// </li>
  /// <li>
  /// <code>aurora-mysql</code>
  /// </li>
  /// <li>
  /// <code>aurora-postgresql</code>
  /// </li>
  /// </ul>
  final String? engine;

  /// The database engine mode of the DB cluster.Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>global</code>
  /// </li>
  /// <li>
  /// <code>multimaster</code>
  /// </li>
  /// <li>
  /// <code>parallelquery</code>
  /// </li>
  /// <li>
  /// <code>provisioned</code>
  /// </li>
  /// <li>
  /// <code>serverless</code>
  /// </li>
  /// </ul>
  final String? engineMode;

  /// The version number of the database engine to use.
  final String? engineVersion;

  /// Specifies the identifier that Amazon Route 53 assigns when you create a
  /// hosted zone.
  final String? hostedZoneId;

  /// Whether the HTTP endpoint for an Aurora Serverless DB cluster is enabled.
  final bool? httpEndpointEnabled;

  /// Whether the mapping of IAM accounts to database accounts is enabled.
  final bool? iamDatabaseAuthenticationEnabled;

  /// The ARN of the KMS master key that is used to encrypt the database instances
  /// in the DB cluster.
  final String? kmsKeyId;

  /// The name of the master user for the DB cluster.
  final String? masterUsername;

  /// Whether the DB cluster has instances in multiple Availability Zones.
  final bool? multiAz;

  /// The port number on which the DB instances in the DB cluster accept
  /// connections.
  final int? port;

  /// The range of time each day when automated backups are created, if automated
  /// backups are enabled.
  ///
  /// Uses the format <code>HH:MM-HH:MM</code>. For example,
  /// <code>04:52-05:22</code>.
  final String? preferredBackupWindow;

  /// The weekly time range during which system maintenance can occur, in
  /// Universal Coordinated Time (UTC).
  ///
  /// Uses the format <code>&lt;day&gt;:HH:MM-&lt;day&gt;:HH:MM</code>.
  ///
  /// For the day values, use
  /// <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.
  ///
  /// For example, <code>sun:09:32-sun:10:02</code>.
  final String? preferredMaintenanceWindow;

  /// The identifiers of the read replicas that are associated with this DB
  /// cluster.
  final List<String>? readReplicaIdentifiers;

  /// The reader endpoint for the DB cluster.
  final String? readerEndpoint;

  /// The current status of this DB cluster.
  final String? status;

  /// Whether the DB cluster is encrypted.
  final bool? storageEncrypted;

  /// A list of VPC security groups that the DB cluster belongs to.
  final List<AwsRdsDbInstanceVpcSecurityGroup>? vpcSecurityGroups;

  AwsRdsDbClusterDetails({
    this.activityStreamStatus,
    this.allocatedStorage,
    this.associatedRoles,
    this.autoMinorVersionUpgrade,
    this.availabilityZones,
    this.backupRetentionPeriod,
    this.clusterCreateTime,
    this.copyTagsToSnapshot,
    this.crossAccountClone,
    this.customEndpoints,
    this.databaseName,
    this.dbClusterIdentifier,
    this.dbClusterMembers,
    this.dbClusterOptionGroupMemberships,
    this.dbClusterParameterGroup,
    this.dbClusterResourceId,
    this.dbSubnetGroup,
    this.deletionProtection,
    this.domainMemberships,
    this.enabledCloudWatchLogsExports,
    this.endpoint,
    this.engine,
    this.engineMode,
    this.engineVersion,
    this.hostedZoneId,
    this.httpEndpointEnabled,
    this.iamDatabaseAuthenticationEnabled,
    this.kmsKeyId,
    this.masterUsername,
    this.multiAz,
    this.port,
    this.preferredBackupWindow,
    this.preferredMaintenanceWindow,
    this.readReplicaIdentifiers,
    this.readerEndpoint,
    this.status,
    this.storageEncrypted,
    this.vpcSecurityGroups,
  });

  factory AwsRdsDbClusterDetails.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbClusterDetails(
      activityStreamStatus: json['ActivityStreamStatus'] as String?,
      allocatedStorage: json['AllocatedStorage'] as int?,
      associatedRoles: (json['AssociatedRoles'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbClusterAssociatedRole.fromJson(e as Map<String, dynamic>))
          .toList(),
      autoMinorVersionUpgrade: json['AutoMinorVersionUpgrade'] as bool?,
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      backupRetentionPeriod: json['BackupRetentionPeriod'] as int?,
      clusterCreateTime: json['ClusterCreateTime'] as String?,
      copyTagsToSnapshot: json['CopyTagsToSnapshot'] as bool?,
      crossAccountClone: json['CrossAccountClone'] as bool?,
      customEndpoints: (json['CustomEndpoints'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      databaseName: json['DatabaseName'] as String?,
      dbClusterIdentifier: json['DbClusterIdentifier'] as String?,
      dbClusterMembers: (json['DbClusterMembers'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRdsDbClusterMember.fromJson(e as Map<String, dynamic>))
          .toList(),
      dbClusterOptionGroupMemberships:
          (json['DbClusterOptionGroupMemberships'] as List?)
              ?.whereNotNull()
              .map((e) => AwsRdsDbClusterOptionGroupMembership.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      dbClusterParameterGroup: json['DbClusterParameterGroup'] as String?,
      dbClusterResourceId: json['DbClusterResourceId'] as String?,
      dbSubnetGroup: json['DbSubnetGroup'] as String?,
      deletionProtection: json['DeletionProtection'] as bool?,
      domainMemberships: (json['DomainMemberships'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbDomainMembership.fromJson(e as Map<String, dynamic>))
          .toList(),
      enabledCloudWatchLogsExports:
          (json['EnabledCloudWatchLogsExports'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      endpoint: json['Endpoint'] as String?,
      engine: json['Engine'] as String?,
      engineMode: json['EngineMode'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      hostedZoneId: json['HostedZoneId'] as String?,
      httpEndpointEnabled: json['HttpEndpointEnabled'] as bool?,
      iamDatabaseAuthenticationEnabled:
          json['IamDatabaseAuthenticationEnabled'] as bool?,
      kmsKeyId: json['KmsKeyId'] as String?,
      masterUsername: json['MasterUsername'] as String?,
      multiAz: json['MultiAz'] as bool?,
      port: json['Port'] as int?,
      preferredBackupWindow: json['PreferredBackupWindow'] as String?,
      preferredMaintenanceWindow: json['PreferredMaintenanceWindow'] as String?,
      readReplicaIdentifiers: (json['ReadReplicaIdentifiers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      readerEndpoint: json['ReaderEndpoint'] as String?,
      status: json['Status'] as String?,
      storageEncrypted: json['StorageEncrypted'] as bool?,
      vpcSecurityGroups: (json['VpcSecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRdsDbInstanceVpcSecurityGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final activityStreamStatus = this.activityStreamStatus;
    final allocatedStorage = this.allocatedStorage;
    final associatedRoles = this.associatedRoles;
    final autoMinorVersionUpgrade = this.autoMinorVersionUpgrade;
    final availabilityZones = this.availabilityZones;
    final backupRetentionPeriod = this.backupRetentionPeriod;
    final clusterCreateTime = this.clusterCreateTime;
    final copyTagsToSnapshot = this.copyTagsToSnapshot;
    final crossAccountClone = this.crossAccountClone;
    final customEndpoints = this.customEndpoints;
    final databaseName = this.databaseName;
    final dbClusterIdentifier = this.dbClusterIdentifier;
    final dbClusterMembers = this.dbClusterMembers;
    final dbClusterOptionGroupMemberships =
        this.dbClusterOptionGroupMemberships;
    final dbClusterParameterGroup = this.dbClusterParameterGroup;
    final dbClusterResourceId = this.dbClusterResourceId;
    final dbSubnetGroup = this.dbSubnetGroup;
    final deletionProtection = this.deletionProtection;
    final domainMemberships = this.domainMemberships;
    final enabledCloudWatchLogsExports = this.enabledCloudWatchLogsExports;
    final endpoint = this.endpoint;
    final engine = this.engine;
    final engineMode = this.engineMode;
    final engineVersion = this.engineVersion;
    final hostedZoneId = this.hostedZoneId;
    final httpEndpointEnabled = this.httpEndpointEnabled;
    final iamDatabaseAuthenticationEnabled =
        this.iamDatabaseAuthenticationEnabled;
    final kmsKeyId = this.kmsKeyId;
    final masterUsername = this.masterUsername;
    final multiAz = this.multiAz;
    final port = this.port;
    final preferredBackupWindow = this.preferredBackupWindow;
    final preferredMaintenanceWindow = this.preferredMaintenanceWindow;
    final readReplicaIdentifiers = this.readReplicaIdentifiers;
    final readerEndpoint = this.readerEndpoint;
    final status = this.status;
    final storageEncrypted = this.storageEncrypted;
    final vpcSecurityGroups = this.vpcSecurityGroups;
    return {
      if (activityStreamStatus != null)
        'ActivityStreamStatus': activityStreamStatus,
      if (allocatedStorage != null) 'AllocatedStorage': allocatedStorage,
      if (associatedRoles != null) 'AssociatedRoles': associatedRoles,
      if (autoMinorVersionUpgrade != null)
        'AutoMinorVersionUpgrade': autoMinorVersionUpgrade,
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (backupRetentionPeriod != null)
        'BackupRetentionPeriod': backupRetentionPeriod,
      if (clusterCreateTime != null) 'ClusterCreateTime': clusterCreateTime,
      if (copyTagsToSnapshot != null) 'CopyTagsToSnapshot': copyTagsToSnapshot,
      if (crossAccountClone != null) 'CrossAccountClone': crossAccountClone,
      if (customEndpoints != null) 'CustomEndpoints': customEndpoints,
      if (databaseName != null) 'DatabaseName': databaseName,
      if (dbClusterIdentifier != null)
        'DbClusterIdentifier': dbClusterIdentifier,
      if (dbClusterMembers != null) 'DbClusterMembers': dbClusterMembers,
      if (dbClusterOptionGroupMemberships != null)
        'DbClusterOptionGroupMemberships': dbClusterOptionGroupMemberships,
      if (dbClusterParameterGroup != null)
        'DbClusterParameterGroup': dbClusterParameterGroup,
      if (dbClusterResourceId != null)
        'DbClusterResourceId': dbClusterResourceId,
      if (dbSubnetGroup != null) 'DbSubnetGroup': dbSubnetGroup,
      if (deletionProtection != null) 'DeletionProtection': deletionProtection,
      if (domainMemberships != null) 'DomainMemberships': domainMemberships,
      if (enabledCloudWatchLogsExports != null)
        'EnabledCloudWatchLogsExports': enabledCloudWatchLogsExports,
      if (endpoint != null) 'Endpoint': endpoint,
      if (engine != null) 'Engine': engine,
      if (engineMode != null) 'EngineMode': engineMode,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (hostedZoneId != null) 'HostedZoneId': hostedZoneId,
      if (httpEndpointEnabled != null)
        'HttpEndpointEnabled': httpEndpointEnabled,
      if (iamDatabaseAuthenticationEnabled != null)
        'IamDatabaseAuthenticationEnabled': iamDatabaseAuthenticationEnabled,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (masterUsername != null) 'MasterUsername': masterUsername,
      if (multiAz != null) 'MultiAz': multiAz,
      if (port != null) 'Port': port,
      if (preferredBackupWindow != null)
        'PreferredBackupWindow': preferredBackupWindow,
      if (preferredMaintenanceWindow != null)
        'PreferredMaintenanceWindow': preferredMaintenanceWindow,
      if (readReplicaIdentifiers != null)
        'ReadReplicaIdentifiers': readReplicaIdentifiers,
      if (readerEndpoint != null) 'ReaderEndpoint': readerEndpoint,
      if (status != null) 'Status': status,
      if (storageEncrypted != null) 'StorageEncrypted': storageEncrypted,
      if (vpcSecurityGroups != null) 'VpcSecurityGroups': vpcSecurityGroups,
    };
  }
}

/// Information about an instance in the DB cluster.
class AwsRdsDbClusterMember {
  /// The status of the DB cluster parameter group for this member of the DB
  /// cluster.
  final String? dbClusterParameterGroupStatus;

  /// The instance identifier for this member of the DB cluster.
  final String? dbInstanceIdentifier;

  /// Whether the cluster member is the primary instance for the DB cluster.
  final bool? isClusterWriter;

  /// Specifies the order in which an Aurora replica is promoted to the primary
  /// instance when the existing primary instance fails.
  final int? promotionTier;

  AwsRdsDbClusterMember({
    this.dbClusterParameterGroupStatus,
    this.dbInstanceIdentifier,
    this.isClusterWriter,
    this.promotionTier,
  });

  factory AwsRdsDbClusterMember.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbClusterMember(
      dbClusterParameterGroupStatus:
          json['DbClusterParameterGroupStatus'] as String?,
      dbInstanceIdentifier: json['DbInstanceIdentifier'] as String?,
      isClusterWriter: json['IsClusterWriter'] as bool?,
      promotionTier: json['PromotionTier'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dbClusterParameterGroupStatus = this.dbClusterParameterGroupStatus;
    final dbInstanceIdentifier = this.dbInstanceIdentifier;
    final isClusterWriter = this.isClusterWriter;
    final promotionTier = this.promotionTier;
    return {
      if (dbClusterParameterGroupStatus != null)
        'DbClusterParameterGroupStatus': dbClusterParameterGroupStatus,
      if (dbInstanceIdentifier != null)
        'DbInstanceIdentifier': dbInstanceIdentifier,
      if (isClusterWriter != null) 'IsClusterWriter': isClusterWriter,
      if (promotionTier != null) 'PromotionTier': promotionTier,
    };
  }
}

/// Information about an option group membership for a DB cluster.
class AwsRdsDbClusterOptionGroupMembership {
  /// The name of the DB cluster option group.
  final String? dbClusterOptionGroupName;

  /// The status of the DB cluster option group.
  final String? status;

  AwsRdsDbClusterOptionGroupMembership({
    this.dbClusterOptionGroupName,
    this.status,
  });

  factory AwsRdsDbClusterOptionGroupMembership.fromJson(
      Map<String, dynamic> json) {
    return AwsRdsDbClusterOptionGroupMembership(
      dbClusterOptionGroupName: json['DbClusterOptionGroupName'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dbClusterOptionGroupName = this.dbClusterOptionGroupName;
    final status = this.status;
    return {
      if (dbClusterOptionGroupName != null)
        'DbClusterOptionGroupName': dbClusterOptionGroupName,
      if (status != null) 'Status': status,
    };
  }
}

/// Contains the name and values of a manual Amazon Relational Database Service
/// (RDS) DB cluster snapshot attribute.
class AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute {
  /// The name of the manual DB cluster snapshot attribute. The attribute named
  /// <code>restore</code> refers to the list of Amazon Web Services accounts that
  /// have permission to copy or restore the manual DB cluster snapshot.
  final String? attributeName;

  /// The value(s) for the manual DB cluster snapshot attribute. If the
  /// <code>AttributeName</code> field is set to <code>restore</code>, then this
  /// element returns a list of IDs of the Amazon Web Services accounts that are
  /// authorized to copy or restore the manual DB cluster snapshot. If a value of
  /// <code>all</code> is in the list, then the manual DB cluster snapshot is
  /// public and available for any Amazon Web Services account to copy or restore.
  final List<String>? attributeValues;

  AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute({
    this.attributeName,
    this.attributeValues,
  });

  factory AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute.fromJson(
      Map<String, dynamic> json) {
    return AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute(
      attributeName: json['AttributeName'] as String?,
      attributeValues: (json['AttributeValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final attributeName = this.attributeName;
    final attributeValues = this.attributeValues;
    return {
      if (attributeName != null) 'AttributeName': attributeName,
      if (attributeValues != null) 'AttributeValues': attributeValues,
    };
  }
}

/// Information about an Amazon RDS DB cluster snapshot.
class AwsRdsDbClusterSnapshotDetails {
  /// Specifies the allocated storage size in gibibytes (GiB).
  final int? allocatedStorage;

  /// A list of Availability Zones where instances in the DB cluster can be
  /// created.
  final List<String>? availabilityZones;

  /// Indicates when the DB cluster was created, in Universal Coordinated Time
  /// (UTC).
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? clusterCreateTime;

  /// The DB cluster identifier.
  final String? dbClusterIdentifier;

  /// Contains the name and values of a manual DB cluster snapshot attribute.
  final List<AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute>?
      dbClusterSnapshotAttributes;

  /// The identifier of the DB cluster snapshot.
  final String? dbClusterSnapshotIdentifier;

  /// The name of the database engine that you want to use for this DB instance.
  final String? engine;

  /// The version of the database engine to use.
  final String? engineVersion;

  /// Whether mapping of IAM accounts to database accounts is enabled.
  final bool? iamDatabaseAuthenticationEnabled;

  /// The ARN of the KMS master key that is used to encrypt the database instances
  /// in the DB cluster.
  final String? kmsKeyId;

  /// The license model information for this DB cluster snapshot.
  final String? licenseModel;

  /// The name of the master user for the DB cluster.
  final String? masterUsername;

  /// Specifies the percentage of the estimated data that has been transferred.
  final int? percentProgress;

  /// The port number on which the DB instances in the DB cluster accept
  /// connections.
  final int? port;

  /// Indicates when the snapshot was taken.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? snapshotCreateTime;

  /// The type of DB cluster snapshot.
  final String? snapshotType;

  /// The status of this DB cluster snapshot.
  final String? status;

  /// Whether the DB cluster is encrypted.
  final bool? storageEncrypted;

  /// The VPC ID that is associated with the DB cluster snapshot.
  final String? vpcId;

  AwsRdsDbClusterSnapshotDetails({
    this.allocatedStorage,
    this.availabilityZones,
    this.clusterCreateTime,
    this.dbClusterIdentifier,
    this.dbClusterSnapshotAttributes,
    this.dbClusterSnapshotIdentifier,
    this.engine,
    this.engineVersion,
    this.iamDatabaseAuthenticationEnabled,
    this.kmsKeyId,
    this.licenseModel,
    this.masterUsername,
    this.percentProgress,
    this.port,
    this.snapshotCreateTime,
    this.snapshotType,
    this.status,
    this.storageEncrypted,
    this.vpcId,
  });

  factory AwsRdsDbClusterSnapshotDetails.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbClusterSnapshotDetails(
      allocatedStorage: json['AllocatedStorage'] as int?,
      availabilityZones: (json['AvailabilityZones'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      clusterCreateTime: json['ClusterCreateTime'] as String?,
      dbClusterIdentifier: json['DbClusterIdentifier'] as String?,
      dbClusterSnapshotAttributes:
          (json['DbClusterSnapshotAttributes'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  AwsRdsDbClusterSnapshotDbClusterSnapshotAttribute.fromJson(
                      e as Map<String, dynamic>))
              .toList(),
      dbClusterSnapshotIdentifier:
          json['DbClusterSnapshotIdentifier'] as String?,
      engine: json['Engine'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      iamDatabaseAuthenticationEnabled:
          json['IamDatabaseAuthenticationEnabled'] as bool?,
      kmsKeyId: json['KmsKeyId'] as String?,
      licenseModel: json['LicenseModel'] as String?,
      masterUsername: json['MasterUsername'] as String?,
      percentProgress: json['PercentProgress'] as int?,
      port: json['Port'] as int?,
      snapshotCreateTime: json['SnapshotCreateTime'] as String?,
      snapshotType: json['SnapshotType'] as String?,
      status: json['Status'] as String?,
      storageEncrypted: json['StorageEncrypted'] as bool?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final allocatedStorage = this.allocatedStorage;
    final availabilityZones = this.availabilityZones;
    final clusterCreateTime = this.clusterCreateTime;
    final dbClusterIdentifier = this.dbClusterIdentifier;
    final dbClusterSnapshotAttributes = this.dbClusterSnapshotAttributes;
    final dbClusterSnapshotIdentifier = this.dbClusterSnapshotIdentifier;
    final engine = this.engine;
    final engineVersion = this.engineVersion;
    final iamDatabaseAuthenticationEnabled =
        this.iamDatabaseAuthenticationEnabled;
    final kmsKeyId = this.kmsKeyId;
    final licenseModel = this.licenseModel;
    final masterUsername = this.masterUsername;
    final percentProgress = this.percentProgress;
    final port = this.port;
    final snapshotCreateTime = this.snapshotCreateTime;
    final snapshotType = this.snapshotType;
    final status = this.status;
    final storageEncrypted = this.storageEncrypted;
    final vpcId = this.vpcId;
    return {
      if (allocatedStorage != null) 'AllocatedStorage': allocatedStorage,
      if (availabilityZones != null) 'AvailabilityZones': availabilityZones,
      if (clusterCreateTime != null) 'ClusterCreateTime': clusterCreateTime,
      if (dbClusterIdentifier != null)
        'DbClusterIdentifier': dbClusterIdentifier,
      if (dbClusterSnapshotAttributes != null)
        'DbClusterSnapshotAttributes': dbClusterSnapshotAttributes,
      if (dbClusterSnapshotIdentifier != null)
        'DbClusterSnapshotIdentifier': dbClusterSnapshotIdentifier,
      if (engine != null) 'Engine': engine,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (iamDatabaseAuthenticationEnabled != null)
        'IamDatabaseAuthenticationEnabled': iamDatabaseAuthenticationEnabled,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (licenseModel != null) 'LicenseModel': licenseModel,
      if (masterUsername != null) 'MasterUsername': masterUsername,
      if (percentProgress != null) 'PercentProgress': percentProgress,
      if (port != null) 'Port': port,
      if (snapshotCreateTime != null) 'SnapshotCreateTime': snapshotCreateTime,
      if (snapshotType != null) 'SnapshotType': snapshotType,
      if (status != null) 'Status': status,
      if (storageEncrypted != null) 'StorageEncrypted': storageEncrypted,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Information about an Active Directory domain membership record associated
/// with the DB instance.
class AwsRdsDbDomainMembership {
  /// The identifier of the Active Directory domain.
  final String? domain;

  /// The fully qualified domain name of the Active Directory domain.
  final String? fqdn;

  /// The name of the IAM role to use when making API calls to the Directory
  /// Service.
  final String? iamRoleName;

  /// The status of the Active Directory Domain membership for the DB instance.
  final String? status;

  AwsRdsDbDomainMembership({
    this.domain,
    this.fqdn,
    this.iamRoleName,
    this.status,
  });

  factory AwsRdsDbDomainMembership.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbDomainMembership(
      domain: json['Domain'] as String?,
      fqdn: json['Fqdn'] as String?,
      iamRoleName: json['IamRoleName'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final domain = this.domain;
    final fqdn = this.fqdn;
    final iamRoleName = this.iamRoleName;
    final status = this.status;
    return {
      if (domain != null) 'Domain': domain,
      if (fqdn != null) 'Fqdn': fqdn,
      if (iamRoleName != null) 'IamRoleName': iamRoleName,
      if (status != null) 'Status': status,
    };
  }
}

/// An IAM role associated with the DB instance.
class AwsRdsDbInstanceAssociatedRole {
  /// The name of the feature associated with the IAM role.
  final String? featureName;

  /// The ARN of the IAM role that is associated with the DB instance.
  final String? roleArn;

  /// Describes the state of the association between the IAM role and the DB
  /// instance. The <code>Status</code> property returns one of the following
  /// values:
  ///
  /// <ul>
  /// <li>
  /// <code>ACTIVE</code> - The IAM role ARN is associated with the DB instance
  /// and can be used to access other Amazon Web Services services on your behalf.
  /// </li>
  /// <li>
  /// <code>PENDING</code> - The IAM role ARN is being associated with the DB
  /// instance.
  /// </li>
  /// <li>
  /// <code>INVALID</code> - The IAM role ARN is associated with the DB instance.
  /// But the DB instance is unable to assume the IAM role in order to access
  /// other Amazon Web Services services on your behalf.
  /// </li>
  /// </ul>
  final String? status;

  AwsRdsDbInstanceAssociatedRole({
    this.featureName,
    this.roleArn,
    this.status,
  });

  factory AwsRdsDbInstanceAssociatedRole.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbInstanceAssociatedRole(
      featureName: json['FeatureName'] as String?,
      roleArn: json['RoleArn'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final featureName = this.featureName;
    final roleArn = this.roleArn;
    final status = this.status;
    return {
      if (featureName != null) 'FeatureName': featureName,
      if (roleArn != null) 'RoleArn': roleArn,
      if (status != null) 'Status': status,
    };
  }
}

/// Contains the details of an Amazon RDS DB instance.
class AwsRdsDbInstanceDetails {
  /// The amount of storage (in gigabytes) to initially allocate for the DB
  /// instance.
  final int? allocatedStorage;

  /// The IAM roles associated with the DB instance.
  final List<AwsRdsDbInstanceAssociatedRole>? associatedRoles;

  /// Indicates whether minor version patches are applied automatically.
  final bool? autoMinorVersionUpgrade;

  /// The Availability Zone where the DB instance will be created.
  final String? availabilityZone;

  /// The number of days for which to retain automated backups.
  final int? backupRetentionPeriod;

  /// The identifier of the CA certificate for this DB instance.
  final String? cACertificateIdentifier;

  /// The name of the character set that this DB instance is associated with.
  final String? characterSetName;

  /// Whether to copy resource tags to snapshots of the DB instance.
  final bool? copyTagsToSnapshot;

  /// If the DB instance is a member of a DB cluster, contains the name of the DB
  /// cluster that the DB instance is a member of.
  final String? dBClusterIdentifier;

  /// Contains the name of the compute and memory capacity class of the DB
  /// instance.
  final String? dBInstanceClass;

  /// Contains a user-supplied database identifier. This identifier is the unique
  /// key that identifies a DB instance.
  final String? dBInstanceIdentifier;

  /// The meaning of this parameter differs according to the database engine you
  /// use.
  ///
  /// <b>MySQL, MariaDB, SQL Server, PostgreSQL</b>
  ///
  /// Contains the name of the initial database of this instance that was provided
  /// at create time, if one was specified when the DB instance was created. This
  /// same name is returned for the life of the DB instance.
  ///
  /// <b>Oracle</b>
  ///
  /// Contains the Oracle System ID (SID) of the created DB instance. Not shown
  /// when the returned parameters do not apply to an Oracle DB instance.
  final String? dBName;

  /// Specifies the port that the DB instance listens on. If the DB instance is
  /// part of a DB cluster, this can be a different port than the DB cluster port.
  final int? dbInstancePort;

  /// The current status of the DB instance.
  final String? dbInstanceStatus;

  /// A list of the DB parameter groups to assign to the DB instance.
  final List<AwsRdsDbParameterGroup>? dbParameterGroups;

  /// A list of the DB security groups to assign to the DB instance.
  final List<String>? dbSecurityGroups;

  /// Information about the subnet group that is associated with the DB instance.
  final AwsRdsDbSubnetGroup? dbSubnetGroup;

  /// The Amazon Web Services Region-unique, immutable identifier for the DB
  /// instance. This identifier is found in CloudTrail log entries whenever the
  /// KMS key for the DB instance is accessed.
  final String? dbiResourceId;

  /// Indicates whether the DB instance has deletion protection enabled.
  ///
  /// When deletion protection is enabled, the database cannot be deleted.
  final bool? deletionProtection;

  /// The Active Directory domain membership records associated with the DB
  /// instance.
  final List<AwsRdsDbDomainMembership>? domainMemberships;

  /// A list of log types that this DB instance is configured to export to
  /// CloudWatch Logs.
  final List<String>? enabledCloudWatchLogsExports;

  /// Specifies the connection endpoint.
  final AwsRdsDbInstanceEndpoint? endpoint;

  /// Provides the name of the database engine to use for this DB instance.
  final String? engine;

  /// Indicates the database engine version.
  final String? engineVersion;

  /// The ARN of the CloudWatch Logs log stream that receives the enhanced
  /// monitoring metrics data for the DB instance.
  final String? enhancedMonitoringResourceArn;

  /// True if mapping of IAM accounts to database accounts is enabled, and
  /// otherwise false.
  ///
  /// IAM database authentication can be enabled for the following database
  /// engines.
  ///
  /// <ul>
  /// <li>
  /// For MySQL 5.6, minor version 5.6.34 or higher
  /// </li>
  /// <li>
  /// For MySQL 5.7, minor version 5.7.16 or higher
  /// </li>
  /// <li>
  /// Aurora 5.6 or higher
  /// </li>
  /// </ul>
  final bool? iAMDatabaseAuthenticationEnabled;

  /// Indicates when the DB instance was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? instanceCreateTime;

  /// Specifies the provisioned IOPS (I/O operations per second) for this DB
  /// instance.
  final int? iops;

  /// If <code>StorageEncrypted</code> is true, the KMS key identifier for the
  /// encrypted DB instance.
  final String? kmsKeyId;

  /// Specifies the latest time to which a database can be restored with
  /// point-in-time restore.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? latestRestorableTime;

  /// License model information for this DB instance.
  final String? licenseModel;
  final AwsRdsDbInstanceEndpoint? listenerEndpoint;

  /// The master user name of the DB instance.
  final String? masterUsername;

  /// The upper limit to which Amazon RDS can automatically scale the storage of
  /// the DB instance.
  final int? maxAllocatedStorage;

  /// The interval, in seconds, between points when enhanced monitoring metrics
  /// are collected for the DB instance.
  final int? monitoringInterval;

  /// The ARN for the IAM role that permits Amazon RDS to send enhanced monitoring
  /// metrics to CloudWatch Logs.
  final String? monitoringRoleArn;

  /// Whether the DB instance is a multiple Availability Zone deployment.
  final bool? multiAz;

  /// The list of option group memberships for this DB instance.
  final List<AwsRdsDbOptionGroupMembership>? optionGroupMemberships;

  /// Changes to the DB instance that are currently pending.
  final AwsRdsDbPendingModifiedValues? pendingModifiedValues;

  /// Indicates whether Performance Insights is enabled for the DB instance.
  final bool? performanceInsightsEnabled;

  /// The identifier of the KMS key used to encrypt the Performance Insights data.
  final String? performanceInsightsKmsKeyId;

  /// The number of days to retain Performance Insights data.
  final int? performanceInsightsRetentionPeriod;

  /// The range of time each day when automated backups are created, if automated
  /// backups are enabled.
  ///
  /// Uses the format <code>HH:MM-HH:MM</code>. For example,
  /// <code>04:52-05:22</code>.
  final String? preferredBackupWindow;

  /// The weekly time range during which system maintenance can occur, in
  /// Universal Coordinated Time (UTC).
  ///
  /// Uses the format <code>&lt;day&gt;:HH:MM-&lt;day&gt;:HH:MM</code>.
  ///
  /// For the day values, use
  /// <code>mon</code>|<code>tue</code>|<code>wed</code>|<code>thu</code>|<code>fri</code>|<code>sat</code>|<code>sun</code>.
  ///
  /// For example, <code>sun:09:32-sun:10:02</code>.
  final String? preferredMaintenanceWindow;

  /// The number of CPU cores and the number of threads per core for the DB
  /// instance class of the DB instance.
  final List<AwsRdsDbProcessorFeature>? processorFeatures;

  /// The order in which to promote an Aurora replica to the primary instance
  /// after a failure of the existing primary instance.
  final int? promotionTier;

  /// Specifies the accessibility options for the DB instance.
  ///
  /// A value of true specifies an Internet-facing instance with a publicly
  /// resolvable DNS name, which resolves to a public IP address.
  ///
  /// A value of false specifies an internal instance with a DNS name that
  /// resolves to a private IP address.
  final bool? publiclyAccessible;

  /// List of identifiers of Aurora DB clusters to which the RDS DB instance is
  /// replicated as a read replica.
  final List<String>? readReplicaDBClusterIdentifiers;

  /// List of identifiers of the read replicas associated with this DB instance.
  final List<String>? readReplicaDBInstanceIdentifiers;

  /// If this DB instance is a read replica, contains the identifier of the source
  /// DB instance.
  final String? readReplicaSourceDBInstanceIdentifier;

  /// For a DB instance with multi-Availability Zone support, the name of the
  /// secondary Availability Zone.
  final String? secondaryAvailabilityZone;

  /// The status of a read replica. If the instance isn't a read replica, this is
  /// empty.
  final List<AwsRdsDbStatusInfo>? statusInfos;

  /// Specifies whether the DB instance is encrypted.
  final bool? storageEncrypted;

  /// The storage type for the DB instance.
  final String? storageType;

  /// The ARN from the key store with which the instance is associated for TDE
  /// encryption.
  final String? tdeCredentialArn;

  /// The time zone of the DB instance.
  final String? timezone;

  /// A list of VPC security groups that the DB instance belongs to.
  final List<AwsRdsDbInstanceVpcSecurityGroup>? vpcSecurityGroups;

  AwsRdsDbInstanceDetails({
    this.allocatedStorage,
    this.associatedRoles,
    this.autoMinorVersionUpgrade,
    this.availabilityZone,
    this.backupRetentionPeriod,
    this.cACertificateIdentifier,
    this.characterSetName,
    this.copyTagsToSnapshot,
    this.dBClusterIdentifier,
    this.dBInstanceClass,
    this.dBInstanceIdentifier,
    this.dBName,
    this.dbInstancePort,
    this.dbInstanceStatus,
    this.dbParameterGroups,
    this.dbSecurityGroups,
    this.dbSubnetGroup,
    this.dbiResourceId,
    this.deletionProtection,
    this.domainMemberships,
    this.enabledCloudWatchLogsExports,
    this.endpoint,
    this.engine,
    this.engineVersion,
    this.enhancedMonitoringResourceArn,
    this.iAMDatabaseAuthenticationEnabled,
    this.instanceCreateTime,
    this.iops,
    this.kmsKeyId,
    this.latestRestorableTime,
    this.licenseModel,
    this.listenerEndpoint,
    this.masterUsername,
    this.maxAllocatedStorage,
    this.monitoringInterval,
    this.monitoringRoleArn,
    this.multiAz,
    this.optionGroupMemberships,
    this.pendingModifiedValues,
    this.performanceInsightsEnabled,
    this.performanceInsightsKmsKeyId,
    this.performanceInsightsRetentionPeriod,
    this.preferredBackupWindow,
    this.preferredMaintenanceWindow,
    this.processorFeatures,
    this.promotionTier,
    this.publiclyAccessible,
    this.readReplicaDBClusterIdentifiers,
    this.readReplicaDBInstanceIdentifiers,
    this.readReplicaSourceDBInstanceIdentifier,
    this.secondaryAvailabilityZone,
    this.statusInfos,
    this.storageEncrypted,
    this.storageType,
    this.tdeCredentialArn,
    this.timezone,
    this.vpcSecurityGroups,
  });

  factory AwsRdsDbInstanceDetails.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbInstanceDetails(
      allocatedStorage: json['AllocatedStorage'] as int?,
      associatedRoles: (json['AssociatedRoles'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRdsDbInstanceAssociatedRole.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      autoMinorVersionUpgrade: json['AutoMinorVersionUpgrade'] as bool?,
      availabilityZone: json['AvailabilityZone'] as String?,
      backupRetentionPeriod: json['BackupRetentionPeriod'] as int?,
      cACertificateIdentifier: json['CACertificateIdentifier'] as String?,
      characterSetName: json['CharacterSetName'] as String?,
      copyTagsToSnapshot: json['CopyTagsToSnapshot'] as bool?,
      dBClusterIdentifier: json['DBClusterIdentifier'] as String?,
      dBInstanceClass: json['DBInstanceClass'] as String?,
      dBInstanceIdentifier: json['DBInstanceIdentifier'] as String?,
      dBName: json['DBName'] as String?,
      dbInstancePort: json['DbInstancePort'] as int?,
      dbInstanceStatus: json['DbInstanceStatus'] as String?,
      dbParameterGroups: (json['DbParameterGroups'] as List?)
          ?.whereNotNull()
          .map(
              (e) => AwsRdsDbParameterGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      dbSecurityGroups: (json['DbSecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      dbSubnetGroup: json['DbSubnetGroup'] != null
          ? AwsRdsDbSubnetGroup.fromJson(
              json['DbSubnetGroup'] as Map<String, dynamic>)
          : null,
      dbiResourceId: json['DbiResourceId'] as String?,
      deletionProtection: json['DeletionProtection'] as bool?,
      domainMemberships: (json['DomainMemberships'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbDomainMembership.fromJson(e as Map<String, dynamic>))
          .toList(),
      enabledCloudWatchLogsExports:
          (json['EnabledCloudWatchLogsExports'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      endpoint: json['Endpoint'] != null
          ? AwsRdsDbInstanceEndpoint.fromJson(
              json['Endpoint'] as Map<String, dynamic>)
          : null,
      engine: json['Engine'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      enhancedMonitoringResourceArn:
          json['EnhancedMonitoringResourceArn'] as String?,
      iAMDatabaseAuthenticationEnabled:
          json['IAMDatabaseAuthenticationEnabled'] as bool?,
      instanceCreateTime: json['InstanceCreateTime'] as String?,
      iops: json['Iops'] as int?,
      kmsKeyId: json['KmsKeyId'] as String?,
      latestRestorableTime: json['LatestRestorableTime'] as String?,
      licenseModel: json['LicenseModel'] as String?,
      listenerEndpoint: json['ListenerEndpoint'] != null
          ? AwsRdsDbInstanceEndpoint.fromJson(
              json['ListenerEndpoint'] as Map<String, dynamic>)
          : null,
      masterUsername: json['MasterUsername'] as String?,
      maxAllocatedStorage: json['MaxAllocatedStorage'] as int?,
      monitoringInterval: json['MonitoringInterval'] as int?,
      monitoringRoleArn: json['MonitoringRoleArn'] as String?,
      multiAz: json['MultiAz'] as bool?,
      optionGroupMemberships: (json['OptionGroupMemberships'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbOptionGroupMembership.fromJson(e as Map<String, dynamic>))
          .toList(),
      pendingModifiedValues: json['PendingModifiedValues'] != null
          ? AwsRdsDbPendingModifiedValues.fromJson(
              json['PendingModifiedValues'] as Map<String, dynamic>)
          : null,
      performanceInsightsEnabled: json['PerformanceInsightsEnabled'] as bool?,
      performanceInsightsKmsKeyId:
          json['PerformanceInsightsKmsKeyId'] as String?,
      performanceInsightsRetentionPeriod:
          json['PerformanceInsightsRetentionPeriod'] as int?,
      preferredBackupWindow: json['PreferredBackupWindow'] as String?,
      preferredMaintenanceWindow: json['PreferredMaintenanceWindow'] as String?,
      processorFeatures: (json['ProcessorFeatures'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbProcessorFeature.fromJson(e as Map<String, dynamic>))
          .toList(),
      promotionTier: json['PromotionTier'] as int?,
      publiclyAccessible: json['PubliclyAccessible'] as bool?,
      readReplicaDBClusterIdentifiers:
          (json['ReadReplicaDBClusterIdentifiers'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      readReplicaDBInstanceIdentifiers:
          (json['ReadReplicaDBInstanceIdentifiers'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      readReplicaSourceDBInstanceIdentifier:
          json['ReadReplicaSourceDBInstanceIdentifier'] as String?,
      secondaryAvailabilityZone: json['SecondaryAvailabilityZone'] as String?,
      statusInfos: (json['StatusInfos'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRdsDbStatusInfo.fromJson(e as Map<String, dynamic>))
          .toList(),
      storageEncrypted: json['StorageEncrypted'] as bool?,
      storageType: json['StorageType'] as String?,
      tdeCredentialArn: json['TdeCredentialArn'] as String?,
      timezone: json['Timezone'] as String?,
      vpcSecurityGroups: (json['VpcSecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRdsDbInstanceVpcSecurityGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final allocatedStorage = this.allocatedStorage;
    final associatedRoles = this.associatedRoles;
    final autoMinorVersionUpgrade = this.autoMinorVersionUpgrade;
    final availabilityZone = this.availabilityZone;
    final backupRetentionPeriod = this.backupRetentionPeriod;
    final cACertificateIdentifier = this.cACertificateIdentifier;
    final characterSetName = this.characterSetName;
    final copyTagsToSnapshot = this.copyTagsToSnapshot;
    final dBClusterIdentifier = this.dBClusterIdentifier;
    final dBInstanceClass = this.dBInstanceClass;
    final dBInstanceIdentifier = this.dBInstanceIdentifier;
    final dBName = this.dBName;
    final dbInstancePort = this.dbInstancePort;
    final dbInstanceStatus = this.dbInstanceStatus;
    final dbParameterGroups = this.dbParameterGroups;
    final dbSecurityGroups = this.dbSecurityGroups;
    final dbSubnetGroup = this.dbSubnetGroup;
    final dbiResourceId = this.dbiResourceId;
    final deletionProtection = this.deletionProtection;
    final domainMemberships = this.domainMemberships;
    final enabledCloudWatchLogsExports = this.enabledCloudWatchLogsExports;
    final endpoint = this.endpoint;
    final engine = this.engine;
    final engineVersion = this.engineVersion;
    final enhancedMonitoringResourceArn = this.enhancedMonitoringResourceArn;
    final iAMDatabaseAuthenticationEnabled =
        this.iAMDatabaseAuthenticationEnabled;
    final instanceCreateTime = this.instanceCreateTime;
    final iops = this.iops;
    final kmsKeyId = this.kmsKeyId;
    final latestRestorableTime = this.latestRestorableTime;
    final licenseModel = this.licenseModel;
    final listenerEndpoint = this.listenerEndpoint;
    final masterUsername = this.masterUsername;
    final maxAllocatedStorage = this.maxAllocatedStorage;
    final monitoringInterval = this.monitoringInterval;
    final monitoringRoleArn = this.monitoringRoleArn;
    final multiAz = this.multiAz;
    final optionGroupMemberships = this.optionGroupMemberships;
    final pendingModifiedValues = this.pendingModifiedValues;
    final performanceInsightsEnabled = this.performanceInsightsEnabled;
    final performanceInsightsKmsKeyId = this.performanceInsightsKmsKeyId;
    final performanceInsightsRetentionPeriod =
        this.performanceInsightsRetentionPeriod;
    final preferredBackupWindow = this.preferredBackupWindow;
    final preferredMaintenanceWindow = this.preferredMaintenanceWindow;
    final processorFeatures = this.processorFeatures;
    final promotionTier = this.promotionTier;
    final publiclyAccessible = this.publiclyAccessible;
    final readReplicaDBClusterIdentifiers =
        this.readReplicaDBClusterIdentifiers;
    final readReplicaDBInstanceIdentifiers =
        this.readReplicaDBInstanceIdentifiers;
    final readReplicaSourceDBInstanceIdentifier =
        this.readReplicaSourceDBInstanceIdentifier;
    final secondaryAvailabilityZone = this.secondaryAvailabilityZone;
    final statusInfos = this.statusInfos;
    final storageEncrypted = this.storageEncrypted;
    final storageType = this.storageType;
    final tdeCredentialArn = this.tdeCredentialArn;
    final timezone = this.timezone;
    final vpcSecurityGroups = this.vpcSecurityGroups;
    return {
      if (allocatedStorage != null) 'AllocatedStorage': allocatedStorage,
      if (associatedRoles != null) 'AssociatedRoles': associatedRoles,
      if (autoMinorVersionUpgrade != null)
        'AutoMinorVersionUpgrade': autoMinorVersionUpgrade,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (backupRetentionPeriod != null)
        'BackupRetentionPeriod': backupRetentionPeriod,
      if (cACertificateIdentifier != null)
        'CACertificateIdentifier': cACertificateIdentifier,
      if (characterSetName != null) 'CharacterSetName': characterSetName,
      if (copyTagsToSnapshot != null) 'CopyTagsToSnapshot': copyTagsToSnapshot,
      if (dBClusterIdentifier != null)
        'DBClusterIdentifier': dBClusterIdentifier,
      if (dBInstanceClass != null) 'DBInstanceClass': dBInstanceClass,
      if (dBInstanceIdentifier != null)
        'DBInstanceIdentifier': dBInstanceIdentifier,
      if (dBName != null) 'DBName': dBName,
      if (dbInstancePort != null) 'DbInstancePort': dbInstancePort,
      if (dbInstanceStatus != null) 'DbInstanceStatus': dbInstanceStatus,
      if (dbParameterGroups != null) 'DbParameterGroups': dbParameterGroups,
      if (dbSecurityGroups != null) 'DbSecurityGroups': dbSecurityGroups,
      if (dbSubnetGroup != null) 'DbSubnetGroup': dbSubnetGroup,
      if (dbiResourceId != null) 'DbiResourceId': dbiResourceId,
      if (deletionProtection != null) 'DeletionProtection': deletionProtection,
      if (domainMemberships != null) 'DomainMemberships': domainMemberships,
      if (enabledCloudWatchLogsExports != null)
        'EnabledCloudWatchLogsExports': enabledCloudWatchLogsExports,
      if (endpoint != null) 'Endpoint': endpoint,
      if (engine != null) 'Engine': engine,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (enhancedMonitoringResourceArn != null)
        'EnhancedMonitoringResourceArn': enhancedMonitoringResourceArn,
      if (iAMDatabaseAuthenticationEnabled != null)
        'IAMDatabaseAuthenticationEnabled': iAMDatabaseAuthenticationEnabled,
      if (instanceCreateTime != null) 'InstanceCreateTime': instanceCreateTime,
      if (iops != null) 'Iops': iops,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (latestRestorableTime != null)
        'LatestRestorableTime': latestRestorableTime,
      if (licenseModel != null) 'LicenseModel': licenseModel,
      if (listenerEndpoint != null) 'ListenerEndpoint': listenerEndpoint,
      if (masterUsername != null) 'MasterUsername': masterUsername,
      if (maxAllocatedStorage != null)
        'MaxAllocatedStorage': maxAllocatedStorage,
      if (monitoringInterval != null) 'MonitoringInterval': monitoringInterval,
      if (monitoringRoleArn != null) 'MonitoringRoleArn': monitoringRoleArn,
      if (multiAz != null) 'MultiAz': multiAz,
      if (optionGroupMemberships != null)
        'OptionGroupMemberships': optionGroupMemberships,
      if (pendingModifiedValues != null)
        'PendingModifiedValues': pendingModifiedValues,
      if (performanceInsightsEnabled != null)
        'PerformanceInsightsEnabled': performanceInsightsEnabled,
      if (performanceInsightsKmsKeyId != null)
        'PerformanceInsightsKmsKeyId': performanceInsightsKmsKeyId,
      if (performanceInsightsRetentionPeriod != null)
        'PerformanceInsightsRetentionPeriod':
            performanceInsightsRetentionPeriod,
      if (preferredBackupWindow != null)
        'PreferredBackupWindow': preferredBackupWindow,
      if (preferredMaintenanceWindow != null)
        'PreferredMaintenanceWindow': preferredMaintenanceWindow,
      if (processorFeatures != null) 'ProcessorFeatures': processorFeatures,
      if (promotionTier != null) 'PromotionTier': promotionTier,
      if (publiclyAccessible != null) 'PubliclyAccessible': publiclyAccessible,
      if (readReplicaDBClusterIdentifiers != null)
        'ReadReplicaDBClusterIdentifiers': readReplicaDBClusterIdentifiers,
      if (readReplicaDBInstanceIdentifiers != null)
        'ReadReplicaDBInstanceIdentifiers': readReplicaDBInstanceIdentifiers,
      if (readReplicaSourceDBInstanceIdentifier != null)
        'ReadReplicaSourceDBInstanceIdentifier':
            readReplicaSourceDBInstanceIdentifier,
      if (secondaryAvailabilityZone != null)
        'SecondaryAvailabilityZone': secondaryAvailabilityZone,
      if (statusInfos != null) 'StatusInfos': statusInfos,
      if (storageEncrypted != null) 'StorageEncrypted': storageEncrypted,
      if (storageType != null) 'StorageType': storageType,
      if (tdeCredentialArn != null) 'TdeCredentialArn': tdeCredentialArn,
      if (timezone != null) 'Timezone': timezone,
      if (vpcSecurityGroups != null) 'VpcSecurityGroups': vpcSecurityGroups,
    };
  }
}

/// Specifies the connection endpoint.
class AwsRdsDbInstanceEndpoint {
  /// Specifies the DNS address of the DB instance.
  final String? address;

  /// Specifies the ID that Amazon Route 53 assigns when you create a hosted zone.
  final String? hostedZoneId;

  /// Specifies the port that the database engine is listening on.
  final int? port;

  AwsRdsDbInstanceEndpoint({
    this.address,
    this.hostedZoneId,
    this.port,
  });

  factory AwsRdsDbInstanceEndpoint.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbInstanceEndpoint(
      address: json['Address'] as String?,
      hostedZoneId: json['HostedZoneId'] as String?,
      port: json['Port'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final address = this.address;
    final hostedZoneId = this.hostedZoneId;
    final port = this.port;
    return {
      if (address != null) 'Address': address,
      if (hostedZoneId != null) 'HostedZoneId': hostedZoneId,
      if (port != null) 'Port': port,
    };
  }
}

/// A VPC security groups that the DB instance belongs to.
class AwsRdsDbInstanceVpcSecurityGroup {
  /// The status of the VPC security group.
  final String? status;

  /// The name of the VPC security group.
  final String? vpcSecurityGroupId;

  AwsRdsDbInstanceVpcSecurityGroup({
    this.status,
    this.vpcSecurityGroupId,
  });

  factory AwsRdsDbInstanceVpcSecurityGroup.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbInstanceVpcSecurityGroup(
      status: json['Status'] as String?,
      vpcSecurityGroupId: json['VpcSecurityGroupId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    final vpcSecurityGroupId = this.vpcSecurityGroupId;
    return {
      if (status != null) 'Status': status,
      if (vpcSecurityGroupId != null) 'VpcSecurityGroupId': vpcSecurityGroupId,
    };
  }
}

/// An option group membership.
class AwsRdsDbOptionGroupMembership {
  /// The name of the option group.
  final String? optionGroupName;

  /// The status of the option group membership.
  final String? status;

  AwsRdsDbOptionGroupMembership({
    this.optionGroupName,
    this.status,
  });

  factory AwsRdsDbOptionGroupMembership.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbOptionGroupMembership(
      optionGroupName: json['OptionGroupName'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final optionGroupName = this.optionGroupName;
    final status = this.status;
    return {
      if (optionGroupName != null) 'OptionGroupName': optionGroupName,
      if (status != null) 'Status': status,
    };
  }
}

/// Provides information about a parameter group for a DB instance.
class AwsRdsDbParameterGroup {
  /// The name of the parameter group.
  final String? dbParameterGroupName;

  /// The status of parameter updates.
  final String? parameterApplyStatus;

  AwsRdsDbParameterGroup({
    this.dbParameterGroupName,
    this.parameterApplyStatus,
  });

  factory AwsRdsDbParameterGroup.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbParameterGroup(
      dbParameterGroupName: json['DbParameterGroupName'] as String?,
      parameterApplyStatus: json['ParameterApplyStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dbParameterGroupName = this.dbParameterGroupName;
    final parameterApplyStatus = this.parameterApplyStatus;
    return {
      if (dbParameterGroupName != null)
        'DbParameterGroupName': dbParameterGroupName,
      if (parameterApplyStatus != null)
        'ParameterApplyStatus': parameterApplyStatus,
    };
  }
}

/// Changes to a DB instance that are currently pending.
class AwsRdsDbPendingModifiedValues {
  /// The new value of the allocated storage for the DB instance.
  final int? allocatedStorage;

  /// The new backup retention period for the DB instance.
  final int? backupRetentionPeriod;

  /// The new CA certificate identifier for the DB instance.
  final String? caCertificateIdentifier;

  /// The new DB instance class for the DB instance.
  final String? dbInstanceClass;

  /// The new DB instance identifier for the DB instance.
  final String? dbInstanceIdentifier;

  /// The name of the new subnet group for the DB instance.
  final String? dbSubnetGroupName;

  /// The new engine version for the DB instance.
  final String? engineVersion;

  /// The new provisioned IOPS value for the DB instance.
  final int? iops;

  /// The new license model value for the DB instance.
  final String? licenseModel;

  /// The new master user password for the DB instance.
  final String? masterUserPassword;

  /// Indicates that a single Availability Zone DB instance is changing to a
  /// multiple Availability Zone deployment.
  final bool? multiAZ;

  /// A list of log types that are being enabled or disabled.
  final AwsRdsPendingCloudWatchLogsExports? pendingCloudWatchLogsExports;

  /// The new port for the DB instance.
  final int? port;

  /// Processor features that are being updated.
  final List<AwsRdsDbProcessorFeature>? processorFeatures;

  /// The new storage type for the DB instance.
  final String? storageType;

  AwsRdsDbPendingModifiedValues({
    this.allocatedStorage,
    this.backupRetentionPeriod,
    this.caCertificateIdentifier,
    this.dbInstanceClass,
    this.dbInstanceIdentifier,
    this.dbSubnetGroupName,
    this.engineVersion,
    this.iops,
    this.licenseModel,
    this.masterUserPassword,
    this.multiAZ,
    this.pendingCloudWatchLogsExports,
    this.port,
    this.processorFeatures,
    this.storageType,
  });

  factory AwsRdsDbPendingModifiedValues.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbPendingModifiedValues(
      allocatedStorage: json['AllocatedStorage'] as int?,
      backupRetentionPeriod: json['BackupRetentionPeriod'] as int?,
      caCertificateIdentifier: json['CaCertificateIdentifier'] as String?,
      dbInstanceClass: json['DbInstanceClass'] as String?,
      dbInstanceIdentifier: json['DbInstanceIdentifier'] as String?,
      dbSubnetGroupName: json['DbSubnetGroupName'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      iops: json['Iops'] as int?,
      licenseModel: json['LicenseModel'] as String?,
      masterUserPassword: json['MasterUserPassword'] as String?,
      multiAZ: json['MultiAZ'] as bool?,
      pendingCloudWatchLogsExports: json['PendingCloudWatchLogsExports'] != null
          ? AwsRdsPendingCloudWatchLogsExports.fromJson(
              json['PendingCloudWatchLogsExports'] as Map<String, dynamic>)
          : null,
      port: json['Port'] as int?,
      processorFeatures: (json['ProcessorFeatures'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbProcessorFeature.fromJson(e as Map<String, dynamic>))
          .toList(),
      storageType: json['StorageType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final allocatedStorage = this.allocatedStorage;
    final backupRetentionPeriod = this.backupRetentionPeriod;
    final caCertificateIdentifier = this.caCertificateIdentifier;
    final dbInstanceClass = this.dbInstanceClass;
    final dbInstanceIdentifier = this.dbInstanceIdentifier;
    final dbSubnetGroupName = this.dbSubnetGroupName;
    final engineVersion = this.engineVersion;
    final iops = this.iops;
    final licenseModel = this.licenseModel;
    final masterUserPassword = this.masterUserPassword;
    final multiAZ = this.multiAZ;
    final pendingCloudWatchLogsExports = this.pendingCloudWatchLogsExports;
    final port = this.port;
    final processorFeatures = this.processorFeatures;
    final storageType = this.storageType;
    return {
      if (allocatedStorage != null) 'AllocatedStorage': allocatedStorage,
      if (backupRetentionPeriod != null)
        'BackupRetentionPeriod': backupRetentionPeriod,
      if (caCertificateIdentifier != null)
        'CaCertificateIdentifier': caCertificateIdentifier,
      if (dbInstanceClass != null) 'DbInstanceClass': dbInstanceClass,
      if (dbInstanceIdentifier != null)
        'DbInstanceIdentifier': dbInstanceIdentifier,
      if (dbSubnetGroupName != null) 'DbSubnetGroupName': dbSubnetGroupName,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (iops != null) 'Iops': iops,
      if (licenseModel != null) 'LicenseModel': licenseModel,
      if (masterUserPassword != null) 'MasterUserPassword': masterUserPassword,
      if (multiAZ != null) 'MultiAZ': multiAZ,
      if (pendingCloudWatchLogsExports != null)
        'PendingCloudWatchLogsExports': pendingCloudWatchLogsExports,
      if (port != null) 'Port': port,
      if (processorFeatures != null) 'ProcessorFeatures': processorFeatures,
      if (storageType != null) 'StorageType': storageType,
    };
  }
}

/// A processor feature.
class AwsRdsDbProcessorFeature {
  /// The name of the processor feature. Valid values are <code>coreCount</code>
  /// or <code>threadsPerCore</code>.
  final String? name;

  /// The value of the processor feature.
  final String? value;

  AwsRdsDbProcessorFeature({
    this.name,
    this.value,
  });

  factory AwsRdsDbProcessorFeature.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbProcessorFeature(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// Provides information about an Amazon RDS DB security group.
class AwsRdsDbSecurityGroupDetails {
  /// The ARN for the DB security group.
  final String? dbSecurityGroupArn;

  /// Provides the description of the DB security group.
  final String? dbSecurityGroupDescription;

  /// Specifies the name of the DB security group.
  final String? dbSecurityGroupName;

  /// Contains a list of EC2 security groups.
  final List<AwsRdsDbSecurityGroupEc2SecurityGroup>? ec2SecurityGroups;

  /// Contains a list of IP ranges.
  final List<AwsRdsDbSecurityGroupIpRange>? ipRanges;

  /// Provides the Amazon Web Services ID of the owner of a specific DB security
  /// group.
  final String? ownerId;

  /// Provides VPC ID associated with the DB security group.
  final String? vpcId;

  AwsRdsDbSecurityGroupDetails({
    this.dbSecurityGroupArn,
    this.dbSecurityGroupDescription,
    this.dbSecurityGroupName,
    this.ec2SecurityGroups,
    this.ipRanges,
    this.ownerId,
    this.vpcId,
  });

  factory AwsRdsDbSecurityGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbSecurityGroupDetails(
      dbSecurityGroupArn: json['DbSecurityGroupArn'] as String?,
      dbSecurityGroupDescription: json['DbSecurityGroupDescription'] as String?,
      dbSecurityGroupName: json['DbSecurityGroupName'] as String?,
      ec2SecurityGroups: (json['Ec2SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRdsDbSecurityGroupEc2SecurityGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ipRanges: (json['IpRanges'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbSecurityGroupIpRange.fromJson(e as Map<String, dynamic>))
          .toList(),
      ownerId: json['OwnerId'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dbSecurityGroupArn = this.dbSecurityGroupArn;
    final dbSecurityGroupDescription = this.dbSecurityGroupDescription;
    final dbSecurityGroupName = this.dbSecurityGroupName;
    final ec2SecurityGroups = this.ec2SecurityGroups;
    final ipRanges = this.ipRanges;
    final ownerId = this.ownerId;
    final vpcId = this.vpcId;
    return {
      if (dbSecurityGroupArn != null) 'DbSecurityGroupArn': dbSecurityGroupArn,
      if (dbSecurityGroupDescription != null)
        'DbSecurityGroupDescription': dbSecurityGroupDescription,
      if (dbSecurityGroupName != null)
        'DbSecurityGroupName': dbSecurityGroupName,
      if (ec2SecurityGroups != null) 'Ec2SecurityGroups': ec2SecurityGroups,
      if (ipRanges != null) 'IpRanges': ipRanges,
      if (ownerId != null) 'OwnerId': ownerId,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// EC2 security group information for an RDS DB security group.
class AwsRdsDbSecurityGroupEc2SecurityGroup {
  /// Specifies the ID for the EC2 security group.
  final String? ec2SecurityGroupId;

  /// Specifies the name of the EC2 security group.
  final String? ec2SecurityGroupName;

  /// Provides the Amazon Web Services ID of the owner of the EC2 security group.
  final String? ec2SecurityGroupOwnerId;

  /// Provides the status of the EC2 security group.
  final String? status;

  AwsRdsDbSecurityGroupEc2SecurityGroup({
    this.ec2SecurityGroupId,
    this.ec2SecurityGroupName,
    this.ec2SecurityGroupOwnerId,
    this.status,
  });

  factory AwsRdsDbSecurityGroupEc2SecurityGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsRdsDbSecurityGroupEc2SecurityGroup(
      ec2SecurityGroupId: json['Ec2SecurityGroupId'] as String?,
      ec2SecurityGroupName: json['Ec2SecurityGroupName'] as String?,
      ec2SecurityGroupOwnerId: json['Ec2SecurityGroupOwnerId'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ec2SecurityGroupId = this.ec2SecurityGroupId;
    final ec2SecurityGroupName = this.ec2SecurityGroupName;
    final ec2SecurityGroupOwnerId = this.ec2SecurityGroupOwnerId;
    final status = this.status;
    return {
      if (ec2SecurityGroupId != null) 'Ec2SecurityGroupId': ec2SecurityGroupId,
      if (ec2SecurityGroupName != null)
        'Ec2SecurityGroupName': ec2SecurityGroupName,
      if (ec2SecurityGroupOwnerId != null)
        'Ec2SecurityGroupOwnerId': ec2SecurityGroupOwnerId,
      if (status != null) 'Status': status,
    };
  }
}

/// IP range information for an RDS DB security group.
class AwsRdsDbSecurityGroupIpRange {
  /// Specifies the IP range.
  final String? cidrIp;

  /// Specifies the status of the IP range.
  final String? status;

  AwsRdsDbSecurityGroupIpRange({
    this.cidrIp,
    this.status,
  });

  factory AwsRdsDbSecurityGroupIpRange.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbSecurityGroupIpRange(
      cidrIp: json['CidrIp'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrIp = this.cidrIp;
    final status = this.status;
    return {
      if (cidrIp != null) 'CidrIp': cidrIp,
      if (status != null) 'Status': status,
    };
  }
}

/// Provides details about an Amazon RDS DB cluster snapshot.
class AwsRdsDbSnapshotDetails {
  /// The amount of storage (in gigabytes) to be initially allocated for the
  /// database instance.
  final int? allocatedStorage;

  /// Specifies the name of the Availability Zone in which the DB instance was
  /// located at the time of the DB snapshot.
  final String? availabilityZone;

  /// A name for the DB instance.
  final String? dbInstanceIdentifier;

  /// The name or ARN of the DB snapshot that is used to restore the DB instance.
  final String? dbSnapshotIdentifier;

  /// The identifier for the source DB instance.
  final String? dbiResourceId;

  /// Whether the DB snapshot is encrypted.
  final bool? encrypted;

  /// The name of the database engine to use for this DB instance. Valid values
  /// are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>aurora</code>
  /// </li>
  /// <li>
  /// <code>aurora-mysql</code>
  /// </li>
  /// <li>
  /// <code>aurora-postgresql</code>
  /// </li>
  /// <li>
  /// <code>c</code>
  /// </li>
  /// <li>
  /// <code>mariadb</code>
  /// </li>
  /// <li>
  /// <code>mysql</code>
  /// </li>
  /// <li>
  /// <code>oracle-ee</code>
  /// </li>
  /// <li>
  /// <code>oracle-se</code>
  /// </li>
  /// <li>
  /// <code>oracle-se1</code>
  /// </li>
  /// <li>
  /// <code>oracle-se2</code>
  /// </li>
  /// <li>
  /// <code>sqlserver-ee</code>
  /// </li>
  /// <li>
  /// <code>sqlserver-ex</code>
  /// </li>
  /// <li>
  /// <code>sqlserver-se</code>
  /// </li>
  /// <li>
  /// <code>sqlserver-web</code>
  /// </li>
  /// </ul>
  final String? engine;

  /// The version of the database engine.
  final String? engineVersion;

  /// Whether mapping of IAM accounts to database accounts is enabled.
  final bool? iamDatabaseAuthenticationEnabled;

  /// Specifies the time in Coordinated Universal Time (UTC) when the DB instance,
  /// from which the snapshot was taken, was created.
  final String? instanceCreateTime;

  /// The provisioned IOPS (I/O operations per second) value of the DB instance at
  /// the time of the snapshot.
  final int? iops;

  /// If <code>Encrypted</code> is <code>true</code>, the KMS key identifier for
  /// the encrypted DB snapshot.
  final String? kmsKeyId;

  /// License model information for the restored DB instance.
  final String? licenseModel;

  /// The master user name for the DB snapshot.
  final String? masterUsername;

  /// The option group name for the DB snapshot.
  final String? optionGroupName;

  /// The percentage of the estimated data that has been transferred.
  final int? percentProgress;

  /// The port that the database engine was listening on at the time of the
  /// snapshot.
  final int? port;

  /// The number of CPU cores and the number of threads per core for the DB
  /// instance class of the DB instance.
  final List<AwsRdsDbProcessorFeature>? processorFeatures;

  /// When the snapshot was taken in Coordinated Universal Time (UTC).
  final String? snapshotCreateTime;

  /// The type of the DB snapshot.
  final String? snapshotType;

  /// The DB snapshot ARN that the DB snapshot was copied from.
  final String? sourceDbSnapshotIdentifier;

  /// The Amazon Web Services Region that the DB snapshot was created in or copied
  /// from.
  final String? sourceRegion;

  /// The status of this DB snapshot.
  final String? status;

  /// The storage type associated with the DB snapshot. Valid values are as
  /// follows:
  ///
  /// <ul>
  /// <li>
  /// <code>gp2</code>
  /// </li>
  /// <li>
  /// <code>io1</code>
  /// </li>
  /// <li>
  /// <code>standard</code>
  /// </li>
  /// </ul>
  final String? storageType;

  /// The ARN from the key store with which to associate the instance for TDE
  /// encryption.
  final String? tdeCredentialArn;

  /// The time zone of the DB snapshot.
  final String? timezone;

  /// The VPC ID associated with the DB snapshot.
  final String? vpcId;

  AwsRdsDbSnapshotDetails({
    this.allocatedStorage,
    this.availabilityZone,
    this.dbInstanceIdentifier,
    this.dbSnapshotIdentifier,
    this.dbiResourceId,
    this.encrypted,
    this.engine,
    this.engineVersion,
    this.iamDatabaseAuthenticationEnabled,
    this.instanceCreateTime,
    this.iops,
    this.kmsKeyId,
    this.licenseModel,
    this.masterUsername,
    this.optionGroupName,
    this.percentProgress,
    this.port,
    this.processorFeatures,
    this.snapshotCreateTime,
    this.snapshotType,
    this.sourceDbSnapshotIdentifier,
    this.sourceRegion,
    this.status,
    this.storageType,
    this.tdeCredentialArn,
    this.timezone,
    this.vpcId,
  });

  factory AwsRdsDbSnapshotDetails.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbSnapshotDetails(
      allocatedStorage: json['AllocatedStorage'] as int?,
      availabilityZone: json['AvailabilityZone'] as String?,
      dbInstanceIdentifier: json['DbInstanceIdentifier'] as String?,
      dbSnapshotIdentifier: json['DbSnapshotIdentifier'] as String?,
      dbiResourceId: json['DbiResourceId'] as String?,
      encrypted: json['Encrypted'] as bool?,
      engine: json['Engine'] as String?,
      engineVersion: json['EngineVersion'] as String?,
      iamDatabaseAuthenticationEnabled:
          json['IamDatabaseAuthenticationEnabled'] as bool?,
      instanceCreateTime: json['InstanceCreateTime'] as String?,
      iops: json['Iops'] as int?,
      kmsKeyId: json['KmsKeyId'] as String?,
      licenseModel: json['LicenseModel'] as String?,
      masterUsername: json['MasterUsername'] as String?,
      optionGroupName: json['OptionGroupName'] as String?,
      percentProgress: json['PercentProgress'] as int?,
      port: json['Port'] as int?,
      processorFeatures: (json['ProcessorFeatures'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbProcessorFeature.fromJson(e as Map<String, dynamic>))
          .toList(),
      snapshotCreateTime: json['SnapshotCreateTime'] as String?,
      snapshotType: json['SnapshotType'] as String?,
      sourceDbSnapshotIdentifier: json['SourceDbSnapshotIdentifier'] as String?,
      sourceRegion: json['SourceRegion'] as String?,
      status: json['Status'] as String?,
      storageType: json['StorageType'] as String?,
      tdeCredentialArn: json['TdeCredentialArn'] as String?,
      timezone: json['Timezone'] as String?,
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final allocatedStorage = this.allocatedStorage;
    final availabilityZone = this.availabilityZone;
    final dbInstanceIdentifier = this.dbInstanceIdentifier;
    final dbSnapshotIdentifier = this.dbSnapshotIdentifier;
    final dbiResourceId = this.dbiResourceId;
    final encrypted = this.encrypted;
    final engine = this.engine;
    final engineVersion = this.engineVersion;
    final iamDatabaseAuthenticationEnabled =
        this.iamDatabaseAuthenticationEnabled;
    final instanceCreateTime = this.instanceCreateTime;
    final iops = this.iops;
    final kmsKeyId = this.kmsKeyId;
    final licenseModel = this.licenseModel;
    final masterUsername = this.masterUsername;
    final optionGroupName = this.optionGroupName;
    final percentProgress = this.percentProgress;
    final port = this.port;
    final processorFeatures = this.processorFeatures;
    final snapshotCreateTime = this.snapshotCreateTime;
    final snapshotType = this.snapshotType;
    final sourceDbSnapshotIdentifier = this.sourceDbSnapshotIdentifier;
    final sourceRegion = this.sourceRegion;
    final status = this.status;
    final storageType = this.storageType;
    final tdeCredentialArn = this.tdeCredentialArn;
    final timezone = this.timezone;
    final vpcId = this.vpcId;
    return {
      if (allocatedStorage != null) 'AllocatedStorage': allocatedStorage,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (dbInstanceIdentifier != null)
        'DbInstanceIdentifier': dbInstanceIdentifier,
      if (dbSnapshotIdentifier != null)
        'DbSnapshotIdentifier': dbSnapshotIdentifier,
      if (dbiResourceId != null) 'DbiResourceId': dbiResourceId,
      if (encrypted != null) 'Encrypted': encrypted,
      if (engine != null) 'Engine': engine,
      if (engineVersion != null) 'EngineVersion': engineVersion,
      if (iamDatabaseAuthenticationEnabled != null)
        'IamDatabaseAuthenticationEnabled': iamDatabaseAuthenticationEnabled,
      if (instanceCreateTime != null) 'InstanceCreateTime': instanceCreateTime,
      if (iops != null) 'Iops': iops,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (licenseModel != null) 'LicenseModel': licenseModel,
      if (masterUsername != null) 'MasterUsername': masterUsername,
      if (optionGroupName != null) 'OptionGroupName': optionGroupName,
      if (percentProgress != null) 'PercentProgress': percentProgress,
      if (port != null) 'Port': port,
      if (processorFeatures != null) 'ProcessorFeatures': processorFeatures,
      if (snapshotCreateTime != null) 'SnapshotCreateTime': snapshotCreateTime,
      if (snapshotType != null) 'SnapshotType': snapshotType,
      if (sourceDbSnapshotIdentifier != null)
        'SourceDbSnapshotIdentifier': sourceDbSnapshotIdentifier,
      if (sourceRegion != null) 'SourceRegion': sourceRegion,
      if (status != null) 'Status': status,
      if (storageType != null) 'StorageType': storageType,
      if (tdeCredentialArn != null) 'TdeCredentialArn': tdeCredentialArn,
      if (timezone != null) 'Timezone': timezone,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Information about the status of a read replica.
class AwsRdsDbStatusInfo {
  /// If the read replica is currently in an error state, provides the error
  /// details.
  final String? message;

  /// Whether the read replica instance is operating normally.
  final bool? normal;

  /// The status of the read replica instance.
  final String? status;

  /// The type of status. For a read replica, the status type is read replication.
  final String? statusType;

  AwsRdsDbStatusInfo({
    this.message,
    this.normal,
    this.status,
    this.statusType,
  });

  factory AwsRdsDbStatusInfo.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbStatusInfo(
      message: json['Message'] as String?,
      normal: json['Normal'] as bool?,
      status: json['Status'] as String?,
      statusType: json['StatusType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final normal = this.normal;
    final status = this.status;
    final statusType = this.statusType;
    return {
      if (message != null) 'Message': message,
      if (normal != null) 'Normal': normal,
      if (status != null) 'Status': status,
      if (statusType != null) 'StatusType': statusType,
    };
  }
}

/// Information about the subnet group for the database instance.
class AwsRdsDbSubnetGroup {
  /// The ARN of the subnet group.
  final String? dbSubnetGroupArn;

  /// The description of the subnet group.
  final String? dbSubnetGroupDescription;

  /// The name of the subnet group.
  final String? dbSubnetGroupName;

  /// The status of the subnet group.
  final String? subnetGroupStatus;

  /// A list of subnets in the subnet group.
  final List<AwsRdsDbSubnetGroupSubnet>? subnets;

  /// The VPC ID of the subnet group.
  final String? vpcId;

  AwsRdsDbSubnetGroup({
    this.dbSubnetGroupArn,
    this.dbSubnetGroupDescription,
    this.dbSubnetGroupName,
    this.subnetGroupStatus,
    this.subnets,
    this.vpcId,
  });

  factory AwsRdsDbSubnetGroup.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbSubnetGroup(
      dbSubnetGroupArn: json['DbSubnetGroupArn'] as String?,
      dbSubnetGroupDescription: json['DbSubnetGroupDescription'] as String?,
      dbSubnetGroupName: json['DbSubnetGroupName'] as String?,
      subnetGroupStatus: json['SubnetGroupStatus'] as String?,
      subnets: (json['Subnets'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRdsDbSubnetGroupSubnet.fromJson(e as Map<String, dynamic>))
          .toList(),
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dbSubnetGroupArn = this.dbSubnetGroupArn;
    final dbSubnetGroupDescription = this.dbSubnetGroupDescription;
    final dbSubnetGroupName = this.dbSubnetGroupName;
    final subnetGroupStatus = this.subnetGroupStatus;
    final subnets = this.subnets;
    final vpcId = this.vpcId;
    return {
      if (dbSubnetGroupArn != null) 'DbSubnetGroupArn': dbSubnetGroupArn,
      if (dbSubnetGroupDescription != null)
        'DbSubnetGroupDescription': dbSubnetGroupDescription,
      if (dbSubnetGroupName != null) 'DbSubnetGroupName': dbSubnetGroupName,
      if (subnetGroupStatus != null) 'SubnetGroupStatus': subnetGroupStatus,
      if (subnets != null) 'Subnets': subnets,
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// Information about a subnet in a subnet group.
class AwsRdsDbSubnetGroupSubnet {
  /// Information about the Availability Zone for a subnet in the subnet group.
  final AwsRdsDbSubnetGroupSubnetAvailabilityZone? subnetAvailabilityZone;

  /// The identifier of a subnet in the subnet group.
  final String? subnetIdentifier;

  /// The status of a subnet in the subnet group.
  final String? subnetStatus;

  AwsRdsDbSubnetGroupSubnet({
    this.subnetAvailabilityZone,
    this.subnetIdentifier,
    this.subnetStatus,
  });

  factory AwsRdsDbSubnetGroupSubnet.fromJson(Map<String, dynamic> json) {
    return AwsRdsDbSubnetGroupSubnet(
      subnetAvailabilityZone: json['SubnetAvailabilityZone'] != null
          ? AwsRdsDbSubnetGroupSubnetAvailabilityZone.fromJson(
              json['SubnetAvailabilityZone'] as Map<String, dynamic>)
          : null,
      subnetIdentifier: json['SubnetIdentifier'] as String?,
      subnetStatus: json['SubnetStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final subnetAvailabilityZone = this.subnetAvailabilityZone;
    final subnetIdentifier = this.subnetIdentifier;
    final subnetStatus = this.subnetStatus;
    return {
      if (subnetAvailabilityZone != null)
        'SubnetAvailabilityZone': subnetAvailabilityZone,
      if (subnetIdentifier != null) 'SubnetIdentifier': subnetIdentifier,
      if (subnetStatus != null) 'SubnetStatus': subnetStatus,
    };
  }
}

/// An Availability Zone for a subnet in a subnet group.
class AwsRdsDbSubnetGroupSubnetAvailabilityZone {
  /// The name of the Availability Zone for a subnet in the subnet group.
  final String? name;

  AwsRdsDbSubnetGroupSubnetAvailabilityZone({
    this.name,
  });

  factory AwsRdsDbSubnetGroupSubnetAvailabilityZone.fromJson(
      Map<String, dynamic> json) {
    return AwsRdsDbSubnetGroupSubnetAvailabilityZone(
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      if (name != null) 'Name': name,
    };
  }
}

/// Details about an Amazon RDS event notification subscription. The
/// subscription allows Amazon RDS to post events to an SNS topic.
class AwsRdsEventSubscriptionDetails {
  /// The identifier of the account that is associated with the event notification
  /// subscription.
  final String? custSubscriptionId;

  /// The identifier of the event notification subscription.
  final String? customerAwsId;

  /// Whether the event notification subscription is enabled.
  final bool? enabled;

  /// The list of event categories for the event notification subscription.
  final List<String>? eventCategoriesList;

  /// The ARN of the event notification subscription.
  final String? eventSubscriptionArn;

  /// The ARN of the SNS topic to post the event notifications to.
  final String? snsTopicArn;

  /// A list of source identifiers for the event notification subscription.
  final List<String>? sourceIdsList;

  /// The source type for the event notification subscription.
  final String? sourceType;

  /// The status of the event notification subscription.
  ///
  /// Valid values: <code>creating</code> | <code>modifying</code> |
  /// <code>deleting</code> | <code>active</code> | <code>no-permission</code> |
  /// <code>topic-not-exist</code>
  final String? status;

  /// The datetime when the event notification subscription was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? subscriptionCreationTime;

  AwsRdsEventSubscriptionDetails({
    this.custSubscriptionId,
    this.customerAwsId,
    this.enabled,
    this.eventCategoriesList,
    this.eventSubscriptionArn,
    this.snsTopicArn,
    this.sourceIdsList,
    this.sourceType,
    this.status,
    this.subscriptionCreationTime,
  });

  factory AwsRdsEventSubscriptionDetails.fromJson(Map<String, dynamic> json) {
    return AwsRdsEventSubscriptionDetails(
      custSubscriptionId: json['CustSubscriptionId'] as String?,
      customerAwsId: json['CustomerAwsId'] as String?,
      enabled: json['Enabled'] as bool?,
      eventCategoriesList: (json['EventCategoriesList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      eventSubscriptionArn: json['EventSubscriptionArn'] as String?,
      snsTopicArn: json['SnsTopicArn'] as String?,
      sourceIdsList: (json['SourceIdsList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      sourceType: json['SourceType'] as String?,
      status: json['Status'] as String?,
      subscriptionCreationTime: json['SubscriptionCreationTime'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final custSubscriptionId = this.custSubscriptionId;
    final customerAwsId = this.customerAwsId;
    final enabled = this.enabled;
    final eventCategoriesList = this.eventCategoriesList;
    final eventSubscriptionArn = this.eventSubscriptionArn;
    final snsTopicArn = this.snsTopicArn;
    final sourceIdsList = this.sourceIdsList;
    final sourceType = this.sourceType;
    final status = this.status;
    final subscriptionCreationTime = this.subscriptionCreationTime;
    return {
      if (custSubscriptionId != null) 'CustSubscriptionId': custSubscriptionId,
      if (customerAwsId != null) 'CustomerAwsId': customerAwsId,
      if (enabled != null) 'Enabled': enabled,
      if (eventCategoriesList != null)
        'EventCategoriesList': eventCategoriesList,
      if (eventSubscriptionArn != null)
        'EventSubscriptionArn': eventSubscriptionArn,
      if (snsTopicArn != null) 'SnsTopicArn': snsTopicArn,
      if (sourceIdsList != null) 'SourceIdsList': sourceIdsList,
      if (sourceType != null) 'SourceType': sourceType,
      if (status != null) 'Status': status,
      if (subscriptionCreationTime != null)
        'SubscriptionCreationTime': subscriptionCreationTime,
    };
  }
}

/// Identifies the log types to enable and disable.
class AwsRdsPendingCloudWatchLogsExports {
  /// A list of log types that are being disabled.
  final List<String>? logTypesToDisable;

  /// A list of log types that are being enabled.
  final List<String>? logTypesToEnable;

  AwsRdsPendingCloudWatchLogsExports({
    this.logTypesToDisable,
    this.logTypesToEnable,
  });

  factory AwsRdsPendingCloudWatchLogsExports.fromJson(
      Map<String, dynamic> json) {
    return AwsRdsPendingCloudWatchLogsExports(
      logTypesToDisable: (json['LogTypesToDisable'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      logTypesToEnable: (json['LogTypesToEnable'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final logTypesToDisable = this.logTypesToDisable;
    final logTypesToEnable = this.logTypesToEnable;
    return {
      if (logTypesToDisable != null) 'LogTypesToDisable': logTypesToDisable,
      if (logTypesToEnable != null) 'LogTypesToEnable': logTypesToEnable,
    };
  }
}

/// A node in an Amazon Redshift cluster.
class AwsRedshiftClusterClusterNode {
  /// The role of the node. A node might be a leader node or a compute node.
  final String? nodeRole;

  /// The private IP address of the node.
  final String? privateIpAddress;

  /// The public IP address of the node.
  final String? publicIpAddress;

  AwsRedshiftClusterClusterNode({
    this.nodeRole,
    this.privateIpAddress,
    this.publicIpAddress,
  });

  factory AwsRedshiftClusterClusterNode.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterClusterNode(
      nodeRole: json['NodeRole'] as String?,
      privateIpAddress: json['PrivateIpAddress'] as String?,
      publicIpAddress: json['PublicIpAddress'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final nodeRole = this.nodeRole;
    final privateIpAddress = this.privateIpAddress;
    final publicIpAddress = this.publicIpAddress;
    return {
      if (nodeRole != null) 'NodeRole': nodeRole,
      if (privateIpAddress != null) 'PrivateIpAddress': privateIpAddress,
      if (publicIpAddress != null) 'PublicIpAddress': publicIpAddress,
    };
  }
}

/// A cluster parameter group that is associated with an Amazon Redshift
/// cluster.
class AwsRedshiftClusterClusterParameterGroup {
  /// The list of parameter statuses.
  final List<AwsRedshiftClusterClusterParameterStatus>?
      clusterParameterStatusList;

  /// The status of updates to the parameters.
  final String? parameterApplyStatus;

  /// The name of the parameter group.
  final String? parameterGroupName;

  AwsRedshiftClusterClusterParameterGroup({
    this.clusterParameterStatusList,
    this.parameterApplyStatus,
    this.parameterGroupName,
  });

  factory AwsRedshiftClusterClusterParameterGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterClusterParameterGroup(
      clusterParameterStatusList: (json['ClusterParameterStatusList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRedshiftClusterClusterParameterStatus.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      parameterApplyStatus: json['ParameterApplyStatus'] as String?,
      parameterGroupName: json['ParameterGroupName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final clusterParameterStatusList = this.clusterParameterStatusList;
    final parameterApplyStatus = this.parameterApplyStatus;
    final parameterGroupName = this.parameterGroupName;
    return {
      if (clusterParameterStatusList != null)
        'ClusterParameterStatusList': clusterParameterStatusList,
      if (parameterApplyStatus != null)
        'ParameterApplyStatus': parameterApplyStatus,
      if (parameterGroupName != null) 'ParameterGroupName': parameterGroupName,
    };
  }
}

/// The status of a parameter in a cluster parameter group for an Amazon
/// Redshift cluster.
class AwsRedshiftClusterClusterParameterStatus {
  /// The error that prevented the parameter from being applied to the database.
  final String? parameterApplyErrorDescription;

  /// The status of the parameter. Indicates whether the parameter is in sync with
  /// the database, waiting for a cluster reboot, or encountered an error when it
  /// was applied.
  ///
  /// Valid values: <code>in-sync</code> | <code>pending-reboot</code> |
  /// <code>applying</code> | <code>invalid-parameter</code> |
  /// <code>apply-deferred</code> | <code>apply-error</code> |
  /// <code>unknown-error</code>
  final String? parameterApplyStatus;

  /// The name of the parameter.
  final String? parameterName;

  AwsRedshiftClusterClusterParameterStatus({
    this.parameterApplyErrorDescription,
    this.parameterApplyStatus,
    this.parameterName,
  });

  factory AwsRedshiftClusterClusterParameterStatus.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterClusterParameterStatus(
      parameterApplyErrorDescription:
          json['ParameterApplyErrorDescription'] as String?,
      parameterApplyStatus: json['ParameterApplyStatus'] as String?,
      parameterName: json['ParameterName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final parameterApplyErrorDescription = this.parameterApplyErrorDescription;
    final parameterApplyStatus = this.parameterApplyStatus;
    final parameterName = this.parameterName;
    return {
      if (parameterApplyErrorDescription != null)
        'ParameterApplyErrorDescription': parameterApplyErrorDescription,
      if (parameterApplyStatus != null)
        'ParameterApplyStatus': parameterApplyStatus,
      if (parameterName != null) 'ParameterName': parameterName,
    };
  }
}

/// A security group that is associated with the cluster.
class AwsRedshiftClusterClusterSecurityGroup {
  /// The name of the cluster security group.
  final String? clusterSecurityGroupName;

  /// The status of the cluster security group.
  final String? status;

  AwsRedshiftClusterClusterSecurityGroup({
    this.clusterSecurityGroupName,
    this.status,
  });

  factory AwsRedshiftClusterClusterSecurityGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterClusterSecurityGroup(
      clusterSecurityGroupName: json['ClusterSecurityGroupName'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final clusterSecurityGroupName = this.clusterSecurityGroupName;
    final status = this.status;
    return {
      if (clusterSecurityGroupName != null)
        'ClusterSecurityGroupName': clusterSecurityGroupName,
      if (status != null) 'Status': status,
    };
  }
}

/// You can configure Amazon Redshift to copy snapshots for a cluster to another
/// Amazon Web Services Region. This parameter provides information about a
/// cross-Region snapshot copy.
class AwsRedshiftClusterClusterSnapshotCopyStatus {
  /// The destination Region that snapshots are automatically copied to when
  /// cross-Region snapshot copy is enabled.
  final String? destinationRegion;

  /// The number of days that manual snapshots are retained in the destination
  /// Region after they are copied from a source Region.
  ///
  /// If the value is <code>-1</code>, then the manual snapshot is retained
  /// indefinitely.
  ///
  /// Valid values: Either <code>-1</code> or an integer between 1 and 3,653
  final int? manualSnapshotRetentionPeriod;

  /// The number of days to retain automated snapshots in the destination Region
  /// after they are copied from a source Region.
  final int? retentionPeriod;

  /// The name of the snapshot copy grant.
  final String? snapshotCopyGrantName;

  AwsRedshiftClusterClusterSnapshotCopyStatus({
    this.destinationRegion,
    this.manualSnapshotRetentionPeriod,
    this.retentionPeriod,
    this.snapshotCopyGrantName,
  });

  factory AwsRedshiftClusterClusterSnapshotCopyStatus.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterClusterSnapshotCopyStatus(
      destinationRegion: json['DestinationRegion'] as String?,
      manualSnapshotRetentionPeriod:
          json['ManualSnapshotRetentionPeriod'] as int?,
      retentionPeriod: json['RetentionPeriod'] as int?,
      snapshotCopyGrantName: json['SnapshotCopyGrantName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destinationRegion = this.destinationRegion;
    final manualSnapshotRetentionPeriod = this.manualSnapshotRetentionPeriod;
    final retentionPeriod = this.retentionPeriod;
    final snapshotCopyGrantName = this.snapshotCopyGrantName;
    return {
      if (destinationRegion != null) 'DestinationRegion': destinationRegion,
      if (manualSnapshotRetentionPeriod != null)
        'ManualSnapshotRetentionPeriod': manualSnapshotRetentionPeriod,
      if (retentionPeriod != null) 'RetentionPeriod': retentionPeriod,
      if (snapshotCopyGrantName != null)
        'SnapshotCopyGrantName': snapshotCopyGrantName,
    };
  }
}

/// A time windows during which maintenance was deferred for an Amazon Redshift
/// cluster.
class AwsRedshiftClusterDeferredMaintenanceWindow {
  /// The end of the time window for which maintenance was deferred.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? deferMaintenanceEndTime;

  /// The identifier of the maintenance window.
  final String? deferMaintenanceIdentifier;

  /// The start of the time window for which maintenance was deferred.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? deferMaintenanceStartTime;

  AwsRedshiftClusterDeferredMaintenanceWindow({
    this.deferMaintenanceEndTime,
    this.deferMaintenanceIdentifier,
    this.deferMaintenanceStartTime,
  });

  factory AwsRedshiftClusterDeferredMaintenanceWindow.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterDeferredMaintenanceWindow(
      deferMaintenanceEndTime: json['DeferMaintenanceEndTime'] as String?,
      deferMaintenanceIdentifier: json['DeferMaintenanceIdentifier'] as String?,
      deferMaintenanceStartTime: json['DeferMaintenanceStartTime'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deferMaintenanceEndTime = this.deferMaintenanceEndTime;
    final deferMaintenanceIdentifier = this.deferMaintenanceIdentifier;
    final deferMaintenanceStartTime = this.deferMaintenanceStartTime;
    return {
      if (deferMaintenanceEndTime != null)
        'DeferMaintenanceEndTime': deferMaintenanceEndTime,
      if (deferMaintenanceIdentifier != null)
        'DeferMaintenanceIdentifier': deferMaintenanceIdentifier,
      if (deferMaintenanceStartTime != null)
        'DeferMaintenanceStartTime': deferMaintenanceStartTime,
    };
  }
}

/// Details about an Amazon Redshift cluster.
class AwsRedshiftClusterDetails {
  /// Indicates whether major version upgrades are applied automatically to the
  /// cluster during the maintenance window.
  final bool? allowVersionUpgrade;

  /// The number of days that automatic cluster snapshots are retained.
  final int? automatedSnapshotRetentionPeriod;

  /// The name of the Availability Zone in which the cluster is located.
  final String? availabilityZone;

  /// The availability status of the cluster for queries. Possible values are the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>Available</code> - The cluster is available for queries.
  /// </li>
  /// <li>
  /// <code>Unavailable</code> - The cluster is not available for queries.
  /// </li>
  /// <li>
  /// <code>Maintenance</code> - The cluster is intermittently available for
  /// queries due to maintenance activities.
  /// </li>
  /// <li>
  /// <code>Modifying</code> -The cluster is intermittently available for queries
  /// due to changes that modify the cluster.
  /// </li>
  /// <li>
  /// <code>Failed</code> - The cluster failed and is not available for queries.
  /// </li>
  /// </ul>
  final String? clusterAvailabilityStatus;

  /// Indicates when the cluster was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? clusterCreateTime;

  /// The unique identifier of the cluster.
  final String? clusterIdentifier;

  /// The nodes in the cluster.
  final List<AwsRedshiftClusterClusterNode>? clusterNodes;

  /// The list of cluster parameter groups that are associated with this cluster.
  final List<AwsRedshiftClusterClusterParameterGroup>? clusterParameterGroups;

  /// The public key for the cluster.
  final String? clusterPublicKey;

  /// The specific revision number of the database in the cluster.
  final String? clusterRevisionNumber;

  /// A list of cluster security groups that are associated with the cluster.
  final List<AwsRedshiftClusterClusterSecurityGroup>? clusterSecurityGroups;

  /// Information about the destination Region and retention period for the
  /// cross-Region snapshot copy.
  final AwsRedshiftClusterClusterSnapshotCopyStatus? clusterSnapshotCopyStatus;

  /// The current status of the cluster.
  ///
  /// Valid values: <code>available</code> | <code>available,
  /// prep-for-resize</code> | <code>available, resize-cleanup</code> |<code>
  /// cancelling-resize</code> | <code>creating</code> | <code>deleting</code> |
  /// <code>final-snapshot</code> | <code>hardware-failure</code> |
  /// <code>incompatible-hsm</code> |<code> incompatible-network</code> |
  /// <code>incompatible-parameters</code> | <code>incompatible-restore</code> |
  /// <code>modifying</code> | <code>paused</code> | <code>rebooting</code> |
  /// <code>renaming</code> | <code>resizing</code> | <code>rotating-keys</code> |
  /// <code>storage-full</code> | <code>updating-hsm</code>
  final String? clusterStatus;

  /// The name of the subnet group that is associated with the cluster. This
  /// parameter is valid only when the cluster is in a VPC.
  final String? clusterSubnetGroupName;

  /// The version ID of the Amazon Redshift engine that runs on the cluster.
  final String? clusterVersion;

  /// The name of the initial database that was created when the cluster was
  /// created.
  ///
  /// The same name is returned for the life of the cluster.
  ///
  /// If an initial database is not specified, a database named
  /// <code>devdev</code> is created by default.
  final String? dBName;

  /// List of time windows during which maintenance was deferred.
  final List<AwsRedshiftClusterDeferredMaintenanceWindow>?
      deferredMaintenanceWindows;

  /// Information about the status of the Elastic IP (EIP) address.
  final AwsRedshiftClusterElasticIpStatus? elasticIpStatus;

  /// The number of nodes that you can use the elastic resize method to resize the
  /// cluster to.
  final String? elasticResizeNumberOfNodeOptions;

  /// Indicates whether the data in the cluster is encrypted at rest.
  final bool? encrypted;

  /// The connection endpoint.
  final AwsRedshiftClusterEndpoint? endpoint;

  /// Indicates whether to create the cluster with enhanced VPC routing enabled.
  final bool? enhancedVpcRouting;

  /// Indicates when the next snapshot is expected to be taken. The cluster must
  /// have a valid snapshot schedule and have backups enabled.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? expectedNextSnapshotScheduleTime;

  /// The status of the next expected snapshot.
  ///
  /// Valid values: <code>OnTrack</code> | <code>Pending</code>
  final String? expectedNextSnapshotScheduleTimeStatus;

  /// Information about whether the Amazon Redshift cluster finished applying any
  /// changes to hardware security module (HSM) settings that were specified in a
  /// modify cluster command.
  final AwsRedshiftClusterHsmStatus? hsmStatus;

  /// A list of IAM roles that the cluster can use to access other Amazon Web
  /// Services services.
  final List<AwsRedshiftClusterIamRole>? iamRoles;

  /// The identifier of the KMS encryption key that is used to encrypt data in the
  /// cluster.
  final String? kmsKeyId;

  /// Information about the logging status of the cluster.
  final AwsRedshiftClusterLoggingStatus? loggingStatus;

  /// The name of the maintenance track for the cluster.
  final String? maintenanceTrackName;

  /// The default number of days to retain a manual snapshot.
  ///
  /// If the value is <code>-1</code>, the snapshot is retained indefinitely.
  ///
  /// This setting doesn't change the retention period of existing snapshots.
  ///
  /// Valid values: Either <code>-1</code> or an integer between 1 and 3,653
  final int? manualSnapshotRetentionPeriod;

  /// The master user name for the cluster. This name is used to connect to the
  /// database that is specified in as the value of <code>DBName</code>.
  final String? masterUsername;

  /// Indicates the start of the next maintenance window.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? nextMaintenanceWindowStartTime;

  /// The node type for the nodes in the cluster.
  final String? nodeType;

  /// The number of compute nodes in the cluster.
  final int? numberOfNodes;

  /// A list of cluster operations that are waiting to start.
  final List<String>? pendingActions;

  /// A list of changes to the cluster that are currently pending.
  final AwsRedshiftClusterPendingModifiedValues? pendingModifiedValues;

  /// The weekly time range, in Universal Coordinated Time (UTC), during which
  /// system maintenance can occur.
  ///
  /// Format: <code> <i>&lt;day&gt;</i>:HH:MM-<i>&lt;day&gt;</i>:HH:MM</code>
  ///
  /// For the day values, use <code>mon</code> | <code>tue</code> |
  /// <code>wed</code> | <code>thu</code> | <code>fri</code> | <code>sat</code> |
  /// <code>sun</code>
  ///
  /// For example, <code>sun:09:32-sun:10:02</code>
  final String? preferredMaintenanceWindow;

  /// Whether the cluster can be accessed from a public network.
  final bool? publiclyAccessible;

  /// Information about the resize operation for the cluster.
  final AwsRedshiftClusterResizeInfo? resizeInfo;

  /// Information about the status of a cluster restore action. Only applies to a
  /// cluster that was created by restoring a snapshot.
  final AwsRedshiftClusterRestoreStatus? restoreStatus;

  /// A unique identifier for the cluster snapshot schedule.
  final String? snapshotScheduleIdentifier;

  /// The current state of the cluster snapshot schedule.
  ///
  /// Valid values: <code>MODIFYING</code> | <code>ACTIVE</code> |
  /// <code>FAILED</code>
  final String? snapshotScheduleState;

  /// The identifier of the VPC that the cluster is in, if the cluster is in a
  /// VPC.
  final String? vpcId;

  /// The list of VPC security groups that the cluster belongs to, if the cluster
  /// is in a VPC.
  final List<AwsRedshiftClusterVpcSecurityGroup>? vpcSecurityGroups;

  AwsRedshiftClusterDetails({
    this.allowVersionUpgrade,
    this.automatedSnapshotRetentionPeriod,
    this.availabilityZone,
    this.clusterAvailabilityStatus,
    this.clusterCreateTime,
    this.clusterIdentifier,
    this.clusterNodes,
    this.clusterParameterGroups,
    this.clusterPublicKey,
    this.clusterRevisionNumber,
    this.clusterSecurityGroups,
    this.clusterSnapshotCopyStatus,
    this.clusterStatus,
    this.clusterSubnetGroupName,
    this.clusterVersion,
    this.dBName,
    this.deferredMaintenanceWindows,
    this.elasticIpStatus,
    this.elasticResizeNumberOfNodeOptions,
    this.encrypted,
    this.endpoint,
    this.enhancedVpcRouting,
    this.expectedNextSnapshotScheduleTime,
    this.expectedNextSnapshotScheduleTimeStatus,
    this.hsmStatus,
    this.iamRoles,
    this.kmsKeyId,
    this.loggingStatus,
    this.maintenanceTrackName,
    this.manualSnapshotRetentionPeriod,
    this.masterUsername,
    this.nextMaintenanceWindowStartTime,
    this.nodeType,
    this.numberOfNodes,
    this.pendingActions,
    this.pendingModifiedValues,
    this.preferredMaintenanceWindow,
    this.publiclyAccessible,
    this.resizeInfo,
    this.restoreStatus,
    this.snapshotScheduleIdentifier,
    this.snapshotScheduleState,
    this.vpcId,
    this.vpcSecurityGroups,
  });

  factory AwsRedshiftClusterDetails.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterDetails(
      allowVersionUpgrade: json['AllowVersionUpgrade'] as bool?,
      automatedSnapshotRetentionPeriod:
          json['AutomatedSnapshotRetentionPeriod'] as int?,
      availabilityZone: json['AvailabilityZone'] as String?,
      clusterAvailabilityStatus: json['ClusterAvailabilityStatus'] as String?,
      clusterCreateTime: json['ClusterCreateTime'] as String?,
      clusterIdentifier: json['ClusterIdentifier'] as String?,
      clusterNodes: (json['ClusterNodes'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRedshiftClusterClusterNode.fromJson(e as Map<String, dynamic>))
          .toList(),
      clusterParameterGroups: (json['ClusterParameterGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRedshiftClusterClusterParameterGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      clusterPublicKey: json['ClusterPublicKey'] as String?,
      clusterRevisionNumber: json['ClusterRevisionNumber'] as String?,
      clusterSecurityGroups: (json['ClusterSecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRedshiftClusterClusterSecurityGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      clusterSnapshotCopyStatus: json['ClusterSnapshotCopyStatus'] != null
          ? AwsRedshiftClusterClusterSnapshotCopyStatus.fromJson(
              json['ClusterSnapshotCopyStatus'] as Map<String, dynamic>)
          : null,
      clusterStatus: json['ClusterStatus'] as String?,
      clusterSubnetGroupName: json['ClusterSubnetGroupName'] as String?,
      clusterVersion: json['ClusterVersion'] as String?,
      dBName: json['DBName'] as String?,
      deferredMaintenanceWindows: (json['DeferredMaintenanceWindows'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRedshiftClusterDeferredMaintenanceWindow.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      elasticIpStatus: json['ElasticIpStatus'] != null
          ? AwsRedshiftClusterElasticIpStatus.fromJson(
              json['ElasticIpStatus'] as Map<String, dynamic>)
          : null,
      elasticResizeNumberOfNodeOptions:
          json['ElasticResizeNumberOfNodeOptions'] as String?,
      encrypted: json['Encrypted'] as bool?,
      endpoint: json['Endpoint'] != null
          ? AwsRedshiftClusterEndpoint.fromJson(
              json['Endpoint'] as Map<String, dynamic>)
          : null,
      enhancedVpcRouting: json['EnhancedVpcRouting'] as bool?,
      expectedNextSnapshotScheduleTime:
          json['ExpectedNextSnapshotScheduleTime'] as String?,
      expectedNextSnapshotScheduleTimeStatus:
          json['ExpectedNextSnapshotScheduleTimeStatus'] as String?,
      hsmStatus: json['HsmStatus'] != null
          ? AwsRedshiftClusterHsmStatus.fromJson(
              json['HsmStatus'] as Map<String, dynamic>)
          : null,
      iamRoles: (json['IamRoles'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsRedshiftClusterIamRole.fromJson(e as Map<String, dynamic>))
          .toList(),
      kmsKeyId: json['KmsKeyId'] as String?,
      loggingStatus: json['LoggingStatus'] != null
          ? AwsRedshiftClusterLoggingStatus.fromJson(
              json['LoggingStatus'] as Map<String, dynamic>)
          : null,
      maintenanceTrackName: json['MaintenanceTrackName'] as String?,
      manualSnapshotRetentionPeriod:
          json['ManualSnapshotRetentionPeriod'] as int?,
      masterUsername: json['MasterUsername'] as String?,
      nextMaintenanceWindowStartTime:
          json['NextMaintenanceWindowStartTime'] as String?,
      nodeType: json['NodeType'] as String?,
      numberOfNodes: json['NumberOfNodes'] as int?,
      pendingActions: (json['PendingActions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      pendingModifiedValues: json['PendingModifiedValues'] != null
          ? AwsRedshiftClusterPendingModifiedValues.fromJson(
              json['PendingModifiedValues'] as Map<String, dynamic>)
          : null,
      preferredMaintenanceWindow: json['PreferredMaintenanceWindow'] as String?,
      publiclyAccessible: json['PubliclyAccessible'] as bool?,
      resizeInfo: json['ResizeInfo'] != null
          ? AwsRedshiftClusterResizeInfo.fromJson(
              json['ResizeInfo'] as Map<String, dynamic>)
          : null,
      restoreStatus: json['RestoreStatus'] != null
          ? AwsRedshiftClusterRestoreStatus.fromJson(
              json['RestoreStatus'] as Map<String, dynamic>)
          : null,
      snapshotScheduleIdentifier: json['SnapshotScheduleIdentifier'] as String?,
      snapshotScheduleState: json['SnapshotScheduleState'] as String?,
      vpcId: json['VpcId'] as String?,
      vpcSecurityGroups: (json['VpcSecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRedshiftClusterVpcSecurityGroup.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final allowVersionUpgrade = this.allowVersionUpgrade;
    final automatedSnapshotRetentionPeriod =
        this.automatedSnapshotRetentionPeriod;
    final availabilityZone = this.availabilityZone;
    final clusterAvailabilityStatus = this.clusterAvailabilityStatus;
    final clusterCreateTime = this.clusterCreateTime;
    final clusterIdentifier = this.clusterIdentifier;
    final clusterNodes = this.clusterNodes;
    final clusterParameterGroups = this.clusterParameterGroups;
    final clusterPublicKey = this.clusterPublicKey;
    final clusterRevisionNumber = this.clusterRevisionNumber;
    final clusterSecurityGroups = this.clusterSecurityGroups;
    final clusterSnapshotCopyStatus = this.clusterSnapshotCopyStatus;
    final clusterStatus = this.clusterStatus;
    final clusterSubnetGroupName = this.clusterSubnetGroupName;
    final clusterVersion = this.clusterVersion;
    final dBName = this.dBName;
    final deferredMaintenanceWindows = this.deferredMaintenanceWindows;
    final elasticIpStatus = this.elasticIpStatus;
    final elasticResizeNumberOfNodeOptions =
        this.elasticResizeNumberOfNodeOptions;
    final encrypted = this.encrypted;
    final endpoint = this.endpoint;
    final enhancedVpcRouting = this.enhancedVpcRouting;
    final expectedNextSnapshotScheduleTime =
        this.expectedNextSnapshotScheduleTime;
    final expectedNextSnapshotScheduleTimeStatus =
        this.expectedNextSnapshotScheduleTimeStatus;
    final hsmStatus = this.hsmStatus;
    final iamRoles = this.iamRoles;
    final kmsKeyId = this.kmsKeyId;
    final loggingStatus = this.loggingStatus;
    final maintenanceTrackName = this.maintenanceTrackName;
    final manualSnapshotRetentionPeriod = this.manualSnapshotRetentionPeriod;
    final masterUsername = this.masterUsername;
    final nextMaintenanceWindowStartTime = this.nextMaintenanceWindowStartTime;
    final nodeType = this.nodeType;
    final numberOfNodes = this.numberOfNodes;
    final pendingActions = this.pendingActions;
    final pendingModifiedValues = this.pendingModifiedValues;
    final preferredMaintenanceWindow = this.preferredMaintenanceWindow;
    final publiclyAccessible = this.publiclyAccessible;
    final resizeInfo = this.resizeInfo;
    final restoreStatus = this.restoreStatus;
    final snapshotScheduleIdentifier = this.snapshotScheduleIdentifier;
    final snapshotScheduleState = this.snapshotScheduleState;
    final vpcId = this.vpcId;
    final vpcSecurityGroups = this.vpcSecurityGroups;
    return {
      if (allowVersionUpgrade != null)
        'AllowVersionUpgrade': allowVersionUpgrade,
      if (automatedSnapshotRetentionPeriod != null)
        'AutomatedSnapshotRetentionPeriod': automatedSnapshotRetentionPeriod,
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (clusterAvailabilityStatus != null)
        'ClusterAvailabilityStatus': clusterAvailabilityStatus,
      if (clusterCreateTime != null) 'ClusterCreateTime': clusterCreateTime,
      if (clusterIdentifier != null) 'ClusterIdentifier': clusterIdentifier,
      if (clusterNodes != null) 'ClusterNodes': clusterNodes,
      if (clusterParameterGroups != null)
        'ClusterParameterGroups': clusterParameterGroups,
      if (clusterPublicKey != null) 'ClusterPublicKey': clusterPublicKey,
      if (clusterRevisionNumber != null)
        'ClusterRevisionNumber': clusterRevisionNumber,
      if (clusterSecurityGroups != null)
        'ClusterSecurityGroups': clusterSecurityGroups,
      if (clusterSnapshotCopyStatus != null)
        'ClusterSnapshotCopyStatus': clusterSnapshotCopyStatus,
      if (clusterStatus != null) 'ClusterStatus': clusterStatus,
      if (clusterSubnetGroupName != null)
        'ClusterSubnetGroupName': clusterSubnetGroupName,
      if (clusterVersion != null) 'ClusterVersion': clusterVersion,
      if (dBName != null) 'DBName': dBName,
      if (deferredMaintenanceWindows != null)
        'DeferredMaintenanceWindows': deferredMaintenanceWindows,
      if (elasticIpStatus != null) 'ElasticIpStatus': elasticIpStatus,
      if (elasticResizeNumberOfNodeOptions != null)
        'ElasticResizeNumberOfNodeOptions': elasticResizeNumberOfNodeOptions,
      if (encrypted != null) 'Encrypted': encrypted,
      if (endpoint != null) 'Endpoint': endpoint,
      if (enhancedVpcRouting != null) 'EnhancedVpcRouting': enhancedVpcRouting,
      if (expectedNextSnapshotScheduleTime != null)
        'ExpectedNextSnapshotScheduleTime': expectedNextSnapshotScheduleTime,
      if (expectedNextSnapshotScheduleTimeStatus != null)
        'ExpectedNextSnapshotScheduleTimeStatus':
            expectedNextSnapshotScheduleTimeStatus,
      if (hsmStatus != null) 'HsmStatus': hsmStatus,
      if (iamRoles != null) 'IamRoles': iamRoles,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (loggingStatus != null) 'LoggingStatus': loggingStatus,
      if (maintenanceTrackName != null)
        'MaintenanceTrackName': maintenanceTrackName,
      if (manualSnapshotRetentionPeriod != null)
        'ManualSnapshotRetentionPeriod': manualSnapshotRetentionPeriod,
      if (masterUsername != null) 'MasterUsername': masterUsername,
      if (nextMaintenanceWindowStartTime != null)
        'NextMaintenanceWindowStartTime': nextMaintenanceWindowStartTime,
      if (nodeType != null) 'NodeType': nodeType,
      if (numberOfNodes != null) 'NumberOfNodes': numberOfNodes,
      if (pendingActions != null) 'PendingActions': pendingActions,
      if (pendingModifiedValues != null)
        'PendingModifiedValues': pendingModifiedValues,
      if (preferredMaintenanceWindow != null)
        'PreferredMaintenanceWindow': preferredMaintenanceWindow,
      if (publiclyAccessible != null) 'PubliclyAccessible': publiclyAccessible,
      if (resizeInfo != null) 'ResizeInfo': resizeInfo,
      if (restoreStatus != null) 'RestoreStatus': restoreStatus,
      if (snapshotScheduleIdentifier != null)
        'SnapshotScheduleIdentifier': snapshotScheduleIdentifier,
      if (snapshotScheduleState != null)
        'SnapshotScheduleState': snapshotScheduleState,
      if (vpcId != null) 'VpcId': vpcId,
      if (vpcSecurityGroups != null) 'VpcSecurityGroups': vpcSecurityGroups,
    };
  }
}

/// The status of the elastic IP (EIP) address for an Amazon Redshift cluster.
class AwsRedshiftClusterElasticIpStatus {
  /// The elastic IP address for the cluster.
  final String? elasticIp;

  /// The status of the elastic IP address.
  final String? status;

  AwsRedshiftClusterElasticIpStatus({
    this.elasticIp,
    this.status,
  });

  factory AwsRedshiftClusterElasticIpStatus.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterElasticIpStatus(
      elasticIp: json['ElasticIp'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final elasticIp = this.elasticIp;
    final status = this.status;
    return {
      if (elasticIp != null) 'ElasticIp': elasticIp,
      if (status != null) 'Status': status,
    };
  }
}

/// The connection endpoint for an Amazon Redshift cluster.
class AwsRedshiftClusterEndpoint {
  /// The DNS address of the cluster.
  final String? address;

  /// The port that the database engine listens on.
  final int? port;

  AwsRedshiftClusterEndpoint({
    this.address,
    this.port,
  });

  factory AwsRedshiftClusterEndpoint.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterEndpoint(
      address: json['Address'] as String?,
      port: json['Port'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final address = this.address;
    final port = this.port;
    return {
      if (address != null) 'Address': address,
      if (port != null) 'Port': port,
    };
  }
}

/// Information about whether an Amazon Redshift cluster finished applying any
/// hardware changes to security module (HSM) settings that were specified in a
/// modify cluster command.
class AwsRedshiftClusterHsmStatus {
  /// The name of the HSM client certificate that the Amazon Redshift cluster uses
  /// to retrieve the data encryption keys that are stored in an HSM.
  final String? hsmClientCertificateIdentifier;

  /// The name of the HSM configuration that contains the information that the
  /// Amazon Redshift cluster can use to retrieve and store keys in an HSM.
  final String? hsmConfigurationIdentifier;

  /// Indicates whether the Amazon Redshift cluster has finished applying any HSM
  /// settings changes specified in a modify cluster command.
  ///
  /// Type: String
  ///
  /// Valid values: <code>active</code> | <code>applying</code>
  final String? status;

  AwsRedshiftClusterHsmStatus({
    this.hsmClientCertificateIdentifier,
    this.hsmConfigurationIdentifier,
    this.status,
  });

  factory AwsRedshiftClusterHsmStatus.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterHsmStatus(
      hsmClientCertificateIdentifier:
          json['HsmClientCertificateIdentifier'] as String?,
      hsmConfigurationIdentifier: json['HsmConfigurationIdentifier'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hsmClientCertificateIdentifier = this.hsmClientCertificateIdentifier;
    final hsmConfigurationIdentifier = this.hsmConfigurationIdentifier;
    final status = this.status;
    return {
      if (hsmClientCertificateIdentifier != null)
        'HsmClientCertificateIdentifier': hsmClientCertificateIdentifier,
      if (hsmConfigurationIdentifier != null)
        'HsmConfigurationIdentifier': hsmConfigurationIdentifier,
      if (status != null) 'Status': status,
    };
  }
}

/// An IAM role that the cluster can use to access other Amazon Web Services
/// services.
class AwsRedshiftClusterIamRole {
  /// The status of the IAM role's association with the cluster.
  ///
  /// Valid values: <code>in-sync</code> | <code>adding</code> |
  /// <code>removing</code>
  final String? applyStatus;

  /// The ARN of the IAM role.
  final String? iamRoleArn;

  AwsRedshiftClusterIamRole({
    this.applyStatus,
    this.iamRoleArn,
  });

  factory AwsRedshiftClusterIamRole.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterIamRole(
      applyStatus: json['ApplyStatus'] as String?,
      iamRoleArn: json['IamRoleArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final applyStatus = this.applyStatus;
    final iamRoleArn = this.iamRoleArn;
    return {
      if (applyStatus != null) 'ApplyStatus': applyStatus,
      if (iamRoleArn != null) 'IamRoleArn': iamRoleArn,
    };
  }
}

/// Provides information about the logging status of the cluster.
class AwsRedshiftClusterLoggingStatus {
  /// The name of the S3 bucket where the log files are stored.
  final String? bucketName;

  /// The message indicating that the logs failed to be delivered.
  final String? lastFailureMessage;

  /// The last time when logs failed to be delivered.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastFailureTime;

  /// The last time that logs were delivered successfully.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastSuccessfulDeliveryTime;

  /// Indicates whether logging is enabled.
  final bool? loggingEnabled;

  /// Provides the prefix applied to the log file names.
  final String? s3KeyPrefix;

  AwsRedshiftClusterLoggingStatus({
    this.bucketName,
    this.lastFailureMessage,
    this.lastFailureTime,
    this.lastSuccessfulDeliveryTime,
    this.loggingEnabled,
    this.s3KeyPrefix,
  });

  factory AwsRedshiftClusterLoggingStatus.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterLoggingStatus(
      bucketName: json['BucketName'] as String?,
      lastFailureMessage: json['LastFailureMessage'] as String?,
      lastFailureTime: json['LastFailureTime'] as String?,
      lastSuccessfulDeliveryTime: json['LastSuccessfulDeliveryTime'] as String?,
      loggingEnabled: json['LoggingEnabled'] as bool?,
      s3KeyPrefix: json['S3KeyPrefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final bucketName = this.bucketName;
    final lastFailureMessage = this.lastFailureMessage;
    final lastFailureTime = this.lastFailureTime;
    final lastSuccessfulDeliveryTime = this.lastSuccessfulDeliveryTime;
    final loggingEnabled = this.loggingEnabled;
    final s3KeyPrefix = this.s3KeyPrefix;
    return {
      if (bucketName != null) 'BucketName': bucketName,
      if (lastFailureMessage != null) 'LastFailureMessage': lastFailureMessage,
      if (lastFailureTime != null) 'LastFailureTime': lastFailureTime,
      if (lastSuccessfulDeliveryTime != null)
        'LastSuccessfulDeliveryTime': lastSuccessfulDeliveryTime,
      if (loggingEnabled != null) 'LoggingEnabled': loggingEnabled,
      if (s3KeyPrefix != null) 'S3KeyPrefix': s3KeyPrefix,
    };
  }
}

/// Changes to the Amazon Redshift cluster that are currently pending.
class AwsRedshiftClusterPendingModifiedValues {
  /// The pending or in-progress change to the automated snapshot retention
  /// period.
  final int? automatedSnapshotRetentionPeriod;

  /// The pending or in-progress change to the identifier for the cluster.
  final String? clusterIdentifier;

  /// The pending or in-progress change to the cluster type.
  final String? clusterType;

  /// The pending or in-progress change to the service version.
  final String? clusterVersion;

  /// The encryption type for a cluster.
  final String? encryptionType;

  /// Indicates whether to create the cluster with enhanced VPC routing enabled.
  final bool? enhancedVpcRouting;

  /// The name of the maintenance track that the cluster changes to during the
  /// next maintenance window.
  final String? maintenanceTrackName;

  /// The pending or in-progress change to the master user password for the
  /// cluster.
  final String? masterUserPassword;

  /// The pending or in-progress change to the cluster's node type.
  final String? nodeType;

  /// The pending or in-progress change to the number of nodes in the cluster.
  final int? numberOfNodes;

  /// The pending or in-progress change to whether the cluster can be connected to
  /// from the public network.
  final bool? publiclyAccessible;

  AwsRedshiftClusterPendingModifiedValues({
    this.automatedSnapshotRetentionPeriod,
    this.clusterIdentifier,
    this.clusterType,
    this.clusterVersion,
    this.encryptionType,
    this.enhancedVpcRouting,
    this.maintenanceTrackName,
    this.masterUserPassword,
    this.nodeType,
    this.numberOfNodes,
    this.publiclyAccessible,
  });

  factory AwsRedshiftClusterPendingModifiedValues.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterPendingModifiedValues(
      automatedSnapshotRetentionPeriod:
          json['AutomatedSnapshotRetentionPeriod'] as int?,
      clusterIdentifier: json['ClusterIdentifier'] as String?,
      clusterType: json['ClusterType'] as String?,
      clusterVersion: json['ClusterVersion'] as String?,
      encryptionType: json['EncryptionType'] as String?,
      enhancedVpcRouting: json['EnhancedVpcRouting'] as bool?,
      maintenanceTrackName: json['MaintenanceTrackName'] as String?,
      masterUserPassword: json['MasterUserPassword'] as String?,
      nodeType: json['NodeType'] as String?,
      numberOfNodes: json['NumberOfNodes'] as int?,
      publiclyAccessible: json['PubliclyAccessible'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final automatedSnapshotRetentionPeriod =
        this.automatedSnapshotRetentionPeriod;
    final clusterIdentifier = this.clusterIdentifier;
    final clusterType = this.clusterType;
    final clusterVersion = this.clusterVersion;
    final encryptionType = this.encryptionType;
    final enhancedVpcRouting = this.enhancedVpcRouting;
    final maintenanceTrackName = this.maintenanceTrackName;
    final masterUserPassword = this.masterUserPassword;
    final nodeType = this.nodeType;
    final numberOfNodes = this.numberOfNodes;
    final publiclyAccessible = this.publiclyAccessible;
    return {
      if (automatedSnapshotRetentionPeriod != null)
        'AutomatedSnapshotRetentionPeriod': automatedSnapshotRetentionPeriod,
      if (clusterIdentifier != null) 'ClusterIdentifier': clusterIdentifier,
      if (clusterType != null) 'ClusterType': clusterType,
      if (clusterVersion != null) 'ClusterVersion': clusterVersion,
      if (encryptionType != null) 'EncryptionType': encryptionType,
      if (enhancedVpcRouting != null) 'EnhancedVpcRouting': enhancedVpcRouting,
      if (maintenanceTrackName != null)
        'MaintenanceTrackName': maintenanceTrackName,
      if (masterUserPassword != null) 'MasterUserPassword': masterUserPassword,
      if (nodeType != null) 'NodeType': nodeType,
      if (numberOfNodes != null) 'NumberOfNodes': numberOfNodes,
      if (publiclyAccessible != null) 'PubliclyAccessible': publiclyAccessible,
    };
  }
}

/// Information about the resize operation for the cluster.
class AwsRedshiftClusterResizeInfo {
  /// Indicates whether the resize operation can be canceled.
  final bool? allowCancelResize;

  /// The type of resize operation.
  ///
  /// Valid values: <code>ClassicResize</code>
  final String? resizeType;

  AwsRedshiftClusterResizeInfo({
    this.allowCancelResize,
    this.resizeType,
  });

  factory AwsRedshiftClusterResizeInfo.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterResizeInfo(
      allowCancelResize: json['AllowCancelResize'] as bool?,
      resizeType: json['ResizeType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final allowCancelResize = this.allowCancelResize;
    final resizeType = this.resizeType;
    return {
      if (allowCancelResize != null) 'AllowCancelResize': allowCancelResize,
      if (resizeType != null) 'ResizeType': resizeType,
    };
  }
}

/// Information about the status of a cluster restore action. It only applies if
/// the cluster was created by restoring a snapshot.
class AwsRedshiftClusterRestoreStatus {
  /// The number of megabytes per second being transferred from the backup
  /// storage. Returns the average rate for a completed backup.
  ///
  /// This field is only updated when you restore to DC2 and DS2 node types.
  final double? currentRestoreRateInMegaBytesPerSecond;

  /// The amount of time an in-progress restore has been running, or the amount of
  /// time it took a completed restore to finish.
  ///
  /// This field is only updated when you restore to DC2 and DS2 node types.
  final int? elapsedTimeInSeconds;

  /// The estimate of the time remaining before the restore is complete. Returns 0
  /// for a completed restore.
  ///
  /// This field is only updated when you restore to DC2 and DS2 node types.
  final int? estimatedTimeToCompletionInSeconds;

  /// The number of megabytes that were transferred from snapshot storage.
  ///
  /// This field is only updated when you restore to DC2 and DS2 node types.
  final int? progressInMegaBytes;

  /// The size of the set of snapshot data that was used to restore the cluster.
  ///
  /// This field is only updated when you restore to DC2 and DS2 node types.
  final int? snapshotSizeInMegaBytes;

  /// The status of the restore action.
  ///
  /// Valid values: <code>starting</code> | <code>restoring</code> |
  /// <code>completed</code> | <code>failed</code>
  final String? status;

  AwsRedshiftClusterRestoreStatus({
    this.currentRestoreRateInMegaBytesPerSecond,
    this.elapsedTimeInSeconds,
    this.estimatedTimeToCompletionInSeconds,
    this.progressInMegaBytes,
    this.snapshotSizeInMegaBytes,
    this.status,
  });

  factory AwsRedshiftClusterRestoreStatus.fromJson(Map<String, dynamic> json) {
    return AwsRedshiftClusterRestoreStatus(
      currentRestoreRateInMegaBytesPerSecond:
          json['CurrentRestoreRateInMegaBytesPerSecond'] as double?,
      elapsedTimeInSeconds: json['ElapsedTimeInSeconds'] as int?,
      estimatedTimeToCompletionInSeconds:
          json['EstimatedTimeToCompletionInSeconds'] as int?,
      progressInMegaBytes: json['ProgressInMegaBytes'] as int?,
      snapshotSizeInMegaBytes: json['SnapshotSizeInMegaBytes'] as int?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final currentRestoreRateInMegaBytesPerSecond =
        this.currentRestoreRateInMegaBytesPerSecond;
    final elapsedTimeInSeconds = this.elapsedTimeInSeconds;
    final estimatedTimeToCompletionInSeconds =
        this.estimatedTimeToCompletionInSeconds;
    final progressInMegaBytes = this.progressInMegaBytes;
    final snapshotSizeInMegaBytes = this.snapshotSizeInMegaBytes;
    final status = this.status;
    return {
      if (currentRestoreRateInMegaBytesPerSecond != null)
        'CurrentRestoreRateInMegaBytesPerSecond':
            currentRestoreRateInMegaBytesPerSecond,
      if (elapsedTimeInSeconds != null)
        'ElapsedTimeInSeconds': elapsedTimeInSeconds,
      if (estimatedTimeToCompletionInSeconds != null)
        'EstimatedTimeToCompletionInSeconds':
            estimatedTimeToCompletionInSeconds,
      if (progressInMegaBytes != null)
        'ProgressInMegaBytes': progressInMegaBytes,
      if (snapshotSizeInMegaBytes != null)
        'SnapshotSizeInMegaBytes': snapshotSizeInMegaBytes,
      if (status != null) 'Status': status,
    };
  }
}

/// A VPC security group that the cluster belongs to, if the cluster is in a
/// VPC.
class AwsRedshiftClusterVpcSecurityGroup {
  /// The status of the VPC security group.
  final String? status;

  /// The identifier of the VPC security group.
  final String? vpcSecurityGroupId;

  AwsRedshiftClusterVpcSecurityGroup({
    this.status,
    this.vpcSecurityGroupId,
  });

  factory AwsRedshiftClusterVpcSecurityGroup.fromJson(
      Map<String, dynamic> json) {
    return AwsRedshiftClusterVpcSecurityGroup(
      status: json['Status'] as String?,
      vpcSecurityGroupId: json['VpcSecurityGroupId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    final vpcSecurityGroupId = this.vpcSecurityGroupId;
    return {
      if (status != null) 'Status': status,
      if (vpcSecurityGroupId != null) 'VpcSecurityGroupId': vpcSecurityGroupId,
    };
  }
}

/// An object that contains an optional comment about your Amazon Route 53
/// hosted zone.
class AwsRoute53HostedZoneConfigDetails {
  /// Any comments that you include about the hosted zone.
  final String? comment;

  AwsRoute53HostedZoneConfigDetails({
    this.comment,
  });

  factory AwsRoute53HostedZoneConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsRoute53HostedZoneConfigDetails(
      comment: json['Comment'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final comment = this.comment;
    return {
      if (comment != null) 'Comment': comment,
    };
  }
}

/// Provides details about a specified Amazon Route 53 hosted zone, including
/// the four name servers assigned to the hosted zone. A hosted zone represents
/// a collection of records that can be managed together, belonging to a single
/// parent domain name.
class AwsRoute53HostedZoneDetails {
  /// An object that contains information about the specified hosted zone.
  final AwsRoute53HostedZoneObjectDetails? hostedZone;

  /// An object that contains a list of the authoritative name servers for a
  /// hosted zone or for a reusable delegation set.
  final List<String>? nameServers;

  /// An array that contains one <code>QueryLoggingConfig</code> element for each
  /// DNS query logging configuration that is associated with the current Amazon
  /// Web Services account.
  final AwsRoute53QueryLoggingConfigDetails? queryLoggingConfig;

  /// An object that contains information about the Amazon Virtual Private Clouds
  /// (Amazon VPCs) that are associated with the specified hosted zone.
  final List<AwsRoute53HostedZoneVpcDetails>? vpcs;

  AwsRoute53HostedZoneDetails({
    this.hostedZone,
    this.nameServers,
    this.queryLoggingConfig,
    this.vpcs,
  });

  factory AwsRoute53HostedZoneDetails.fromJson(Map<String, dynamic> json) {
    return AwsRoute53HostedZoneDetails(
      hostedZone: json['HostedZone'] != null
          ? AwsRoute53HostedZoneObjectDetails.fromJson(
              json['HostedZone'] as Map<String, dynamic>)
          : null,
      nameServers: (json['NameServers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      queryLoggingConfig: json['QueryLoggingConfig'] != null
          ? AwsRoute53QueryLoggingConfigDetails.fromJson(
              json['QueryLoggingConfig'] as Map<String, dynamic>)
          : null,
      vpcs: (json['Vpcs'] as List?)
          ?.whereNotNull()
          .map((e) => AwsRoute53HostedZoneVpcDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final hostedZone = this.hostedZone;
    final nameServers = this.nameServers;
    final queryLoggingConfig = this.queryLoggingConfig;
    final vpcs = this.vpcs;
    return {
      if (hostedZone != null) 'HostedZone': hostedZone,
      if (nameServers != null) 'NameServers': nameServers,
      if (queryLoggingConfig != null) 'QueryLoggingConfig': queryLoggingConfig,
      if (vpcs != null) 'Vpcs': vpcs,
    };
  }
}

/// An object that contains information about an Amazon Route 53 hosted zone.
class AwsRoute53HostedZoneObjectDetails {
  /// An object that includes the <code>Comment</code> element.
  final AwsRoute53HostedZoneConfigDetails? config;

  /// The ID that Route 53 assigns to the hosted zone when you create it.
  final String? id;

  /// The name of the domain. For public hosted zones, this is the name that you
  /// have registered with your DNS registrar.
  final String? name;

  AwsRoute53HostedZoneObjectDetails({
    this.config,
    this.id,
    this.name,
  });

  factory AwsRoute53HostedZoneObjectDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsRoute53HostedZoneObjectDetails(
      config: json['Config'] != null
          ? AwsRoute53HostedZoneConfigDetails.fromJson(
              json['Config'] as Map<String, dynamic>)
          : null,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final config = this.config;
    final id = this.id;
    final name = this.name;
    return {
      if (config != null) 'Config': config,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
    };
  }
}

/// For private hosted zones, this is a complex type that contains information
/// about an Amazon VPC.
class AwsRoute53HostedZoneVpcDetails {
  /// The identifier of an Amazon VPC.
  final String? id;

  /// The Amazon Web Services Region that an Amazon VPC was created in.
  final String? region;

  AwsRoute53HostedZoneVpcDetails({
    this.id,
    this.region,
  });

  factory AwsRoute53HostedZoneVpcDetails.fromJson(Map<String, dynamic> json) {
    return AwsRoute53HostedZoneVpcDetails(
      id: json['Id'] as String?,
      region: json['Region'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final region = this.region;
    return {
      if (id != null) 'Id': id,
      if (region != null) 'Region': region,
    };
  }
}

/// Provides details about a specified Amazon Route 53 configuration for DNS
/// query logging.
class AwsRoute53QueryLoggingConfigDetails {
  /// The Amazon Resource Name (ARN) of the Amazon CloudWatch Logs log group that
  /// Route 53 is publishing logs to.
  final CloudWatchLogsLogGroupArnConfigDetails? cloudWatchLogsLogGroupArn;

  AwsRoute53QueryLoggingConfigDetails({
    this.cloudWatchLogsLogGroupArn,
  });

  factory AwsRoute53QueryLoggingConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsRoute53QueryLoggingConfigDetails(
      cloudWatchLogsLogGroupArn: json['CloudWatchLogsLogGroupArn'] != null
          ? CloudWatchLogsLogGroupArnConfigDetails.fromJson(
              json['CloudWatchLogsLogGroupArn'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsLogGroupArn = this.cloudWatchLogsLogGroupArn;
    return {
      if (cloudWatchLogsLogGroupArn != null)
        'CloudWatchLogsLogGroupArn': cloudWatchLogsLogGroupArn,
    };
  }
}

/// Returns configuration information about the specified Amazon S3 access
/// point. S3 access points are named network endpoints that are attached to
/// buckets that you can use to perform S3 object operations.
class AwsS3AccessPointDetails {
  /// The Amazon Resource Name (ARN) of the access point.
  final String? accessPointArn;

  /// The name or alias of the access point.
  final String? alias;

  /// The name of the S3 bucket associated with the specified access point.
  final String? bucket;

  /// The Amazon Web Services account ID associated with the S3 bucket associated
  /// with this access point.
  final String? bucketAccountId;

  /// The name of the specified access point.
  final String? name;

  /// Indicates whether this access point allows access from the public internet.
  final String? networkOrigin;
  final AwsS3AccountPublicAccessBlockDetails? publicAccessBlockConfiguration;

  /// Contains the virtual private cloud (VPC) configuration for the specified
  /// access point.
  final AwsS3AccessPointVpcConfigurationDetails? vpcConfiguration;

  AwsS3AccessPointDetails({
    this.accessPointArn,
    this.alias,
    this.bucket,
    this.bucketAccountId,
    this.name,
    this.networkOrigin,
    this.publicAccessBlockConfiguration,
    this.vpcConfiguration,
  });

  factory AwsS3AccessPointDetails.fromJson(Map<String, dynamic> json) {
    return AwsS3AccessPointDetails(
      accessPointArn: json['AccessPointArn'] as String?,
      alias: json['Alias'] as String?,
      bucket: json['Bucket'] as String?,
      bucketAccountId: json['BucketAccountId'] as String?,
      name: json['Name'] as String?,
      networkOrigin: json['NetworkOrigin'] as String?,
      publicAccessBlockConfiguration: json['PublicAccessBlockConfiguration'] !=
              null
          ? AwsS3AccountPublicAccessBlockDetails.fromJson(
              json['PublicAccessBlockConfiguration'] as Map<String, dynamic>)
          : null,
      vpcConfiguration: json['VpcConfiguration'] != null
          ? AwsS3AccessPointVpcConfigurationDetails.fromJson(
              json['VpcConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessPointArn = this.accessPointArn;
    final alias = this.alias;
    final bucket = this.bucket;
    final bucketAccountId = this.bucketAccountId;
    final name = this.name;
    final networkOrigin = this.networkOrigin;
    final publicAccessBlockConfiguration = this.publicAccessBlockConfiguration;
    final vpcConfiguration = this.vpcConfiguration;
    return {
      if (accessPointArn != null) 'AccessPointArn': accessPointArn,
      if (alias != null) 'Alias': alias,
      if (bucket != null) 'Bucket': bucket,
      if (bucketAccountId != null) 'BucketAccountId': bucketAccountId,
      if (name != null) 'Name': name,
      if (networkOrigin != null) 'NetworkOrigin': networkOrigin,
      if (publicAccessBlockConfiguration != null)
        'PublicAccessBlockConfiguration': publicAccessBlockConfiguration,
      if (vpcConfiguration != null) 'VpcConfiguration': vpcConfiguration,
    };
  }
}

/// The virtual private cloud (VPC) configuration for an Amazon S3 access point.
class AwsS3AccessPointVpcConfigurationDetails {
  /// If this field is specified, this access point will only allow connections
  /// from the specified VPC ID.
  final String? vpcId;

  AwsS3AccessPointVpcConfigurationDetails({
    this.vpcId,
  });

  factory AwsS3AccessPointVpcConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3AccessPointVpcConfigurationDetails(
      vpcId: json['VpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final vpcId = this.vpcId;
    return {
      if (vpcId != null) 'VpcId': vpcId,
    };
  }
}

/// provides information about the Amazon S3 Public Access Block configuration
/// for accounts.
class AwsS3AccountPublicAccessBlockDetails {
  /// Indicates whether to reject calls to update an S3 bucket if the calls
  /// include a public access control list (ACL).
  final bool? blockPublicAcls;

  /// Indicates whether to reject calls to update the access policy for an S3
  /// bucket or access point if the policy allows public access.
  final bool? blockPublicPolicy;

  /// Indicates whether Amazon S3 ignores public ACLs that are associated with an
  /// S3 bucket.
  final bool? ignorePublicAcls;

  /// Indicates whether to restrict access to an access point or S3 bucket that
  /// has a public policy to only Amazon Web Services service principals and
  /// authorized users within the S3 bucket owner's account.
  final bool? restrictPublicBuckets;

  AwsS3AccountPublicAccessBlockDetails({
    this.blockPublicAcls,
    this.blockPublicPolicy,
    this.ignorePublicAcls,
    this.restrictPublicBuckets,
  });

  factory AwsS3AccountPublicAccessBlockDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3AccountPublicAccessBlockDetails(
      blockPublicAcls: json['BlockPublicAcls'] as bool?,
      blockPublicPolicy: json['BlockPublicPolicy'] as bool?,
      ignorePublicAcls: json['IgnorePublicAcls'] as bool?,
      restrictPublicBuckets: json['RestrictPublicBuckets'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final blockPublicAcls = this.blockPublicAcls;
    final blockPublicPolicy = this.blockPublicPolicy;
    final ignorePublicAcls = this.ignorePublicAcls;
    final restrictPublicBuckets = this.restrictPublicBuckets;
    return {
      if (blockPublicAcls != null) 'BlockPublicAcls': blockPublicAcls,
      if (blockPublicPolicy != null) 'BlockPublicPolicy': blockPublicPolicy,
      if (ignorePublicAcls != null) 'IgnorePublicAcls': ignorePublicAcls,
      if (restrictPublicBuckets != null)
        'RestrictPublicBuckets': restrictPublicBuckets,
    };
  }
}

/// The lifecycle configuration for the objects in the S3 bucket.
class AwsS3BucketBucketLifecycleConfigurationDetails {
  /// The lifecycle rules.
  final List<AwsS3BucketBucketLifecycleConfigurationRulesDetails>? rules;

  AwsS3BucketBucketLifecycleConfigurationDetails({
    this.rules,
  });

  factory AwsS3BucketBucketLifecycleConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationDetails(
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsS3BucketBucketLifecycleConfigurationRulesDetails.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final rules = this.rules;
    return {
      if (rules != null) 'Rules': rules,
    };
  }
}

/// Information about what Amazon S3 does when a multipart upload is incomplete.
class AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails {
  /// The number of days after which Amazon S3 cancels an incomplete multipart
  /// upload.
  final int? daysAfterInitiation;

  AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails({
    this.daysAfterInitiation,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails(
      daysAfterInitiation: json['DaysAfterInitiation'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final daysAfterInitiation = this.daysAfterInitiation;
    return {
      if (daysAfterInitiation != null)
        'DaysAfterInitiation': daysAfterInitiation,
    };
  }
}

/// Configuration for a lifecycle rule.
class AwsS3BucketBucketLifecycleConfigurationRulesDetails {
  /// How Amazon S3 responds when a multipart upload is incomplete. Specifically,
  /// provides a number of days before Amazon S3 cancels the entire upload.
  final AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails?
      abortIncompleteMultipartUpload;

  /// The date when objects are moved or deleted.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? expirationDate;

  /// The length in days of the lifetime for objects that are subject to the rule.
  final int? expirationInDays;

  /// Whether Amazon S3 removes a delete marker that has no noncurrent versions.
  /// If set to <code>true</code>, the delete marker is expired. If set to
  /// <code>false</code>, the policy takes no action.
  ///
  /// If you provide <code>ExpiredObjectDeleteMarker</code>, you cannot provide
  /// <code>ExpirationInDays</code> or <code>ExpirationDate</code>.
  final bool? expiredObjectDeleteMarker;

  /// Identifies the objects that a rule applies to.
  final AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails? filter;

  /// The unique identifier of the rule.
  final String? id;

  /// The number of days that an object is noncurrent before Amazon S3 can perform
  /// the associated action.
  final int? noncurrentVersionExpirationInDays;

  /// Transition rules that describe when noncurrent objects transition to a
  /// specified storage class.
  final List<
          AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails>?
      noncurrentVersionTransitions;

  /// A prefix that identifies one or more objects that the rule applies to.
  final String? prefix;

  /// The current status of the rule. Indicates whether the rule is currently
  /// being applied.
  final String? status;

  /// Transition rules that indicate when objects transition to a specified
  /// storage class.
  final List<AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails>?
      transitions;

  AwsS3BucketBucketLifecycleConfigurationRulesDetails({
    this.abortIncompleteMultipartUpload,
    this.expirationDate,
    this.expirationInDays,
    this.expiredObjectDeleteMarker,
    this.filter,
    this.id,
    this.noncurrentVersionExpirationInDays,
    this.noncurrentVersionTransitions,
    this.prefix,
    this.status,
    this.transitions,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesDetails(
      abortIncompleteMultipartUpload: json['AbortIncompleteMultipartUpload'] !=
              null
          ? AwsS3BucketBucketLifecycleConfigurationRulesAbortIncompleteMultipartUploadDetails
              .fromJson(json['AbortIncompleteMultipartUpload']
                  as Map<String, dynamic>)
          : null,
      expirationDate: json['ExpirationDate'] as String?,
      expirationInDays: json['ExpirationInDays'] as int?,
      expiredObjectDeleteMarker: json['ExpiredObjectDeleteMarker'] as bool?,
      filter: json['Filter'] != null
          ? AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails.fromJson(
              json['Filter'] as Map<String, dynamic>)
          : null,
      id: json['ID'] as String?,
      noncurrentVersionExpirationInDays:
          json['NoncurrentVersionExpirationInDays'] as int?,
      noncurrentVersionTransitions: (json['NoncurrentVersionTransitions']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      prefix: json['Prefix'] as String?,
      status: json['Status'] as String?,
      transitions: (json['Transitions'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final abortIncompleteMultipartUpload = this.abortIncompleteMultipartUpload;
    final expirationDate = this.expirationDate;
    final expirationInDays = this.expirationInDays;
    final expiredObjectDeleteMarker = this.expiredObjectDeleteMarker;
    final filter = this.filter;
    final id = this.id;
    final noncurrentVersionExpirationInDays =
        this.noncurrentVersionExpirationInDays;
    final noncurrentVersionTransitions = this.noncurrentVersionTransitions;
    final prefix = this.prefix;
    final status = this.status;
    final transitions = this.transitions;
    return {
      if (abortIncompleteMultipartUpload != null)
        'AbortIncompleteMultipartUpload': abortIncompleteMultipartUpload,
      if (expirationDate != null) 'ExpirationDate': expirationDate,
      if (expirationInDays != null) 'ExpirationInDays': expirationInDays,
      if (expiredObjectDeleteMarker != null)
        'ExpiredObjectDeleteMarker': expiredObjectDeleteMarker,
      if (filter != null) 'Filter': filter,
      if (id != null) 'ID': id,
      if (noncurrentVersionExpirationInDays != null)
        'NoncurrentVersionExpirationInDays': noncurrentVersionExpirationInDays,
      if (noncurrentVersionTransitions != null)
        'NoncurrentVersionTransitions': noncurrentVersionTransitions,
      if (prefix != null) 'Prefix': prefix,
      if (status != null) 'Status': status,
      if (transitions != null) 'Transitions': transitions,
    };
  }
}

/// Identifies the objects that a rule applies to.
class AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails {
  /// The configuration for the filter.
  final AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails?
      predicate;

  AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails({
    this.predicate,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesFilterDetails(
      predicate: json['Predicate'] != null
          ? AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails
              .fromJson(json['Predicate'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final predicate = this.predicate;
    return {
      if (predicate != null) 'Predicate': predicate,
    };
  }
}

/// The configuration for the filter.
class AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails {
  /// The values to use for the filter.
  final List<
          AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails>?
      operands;

  /// A prefix filter.
  final String? prefix;

  /// A tag filter.
  final AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails?
      tag;

  /// Whether to use <code>AND</code> or <code>OR</code> to join the operands.
  /// Valid values are <code>LifecycleAndOperator</code> or
  /// <code>LifecycleOrOperator</code>.
  final String? type;

  AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails({
    this.operands,
    this.prefix,
    this.tag,
    this.type,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateDetails(
      operands: (json['Operands'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      prefix: json['Prefix'] as String?,
      tag: json['Tag'] != null
          ? AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails
              .fromJson(json['Tag'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final operands = this.operands;
    final prefix = this.prefix;
    final tag = this.tag;
    final type = this.type;
    return {
      if (operands != null) 'Operands': operands,
      if (prefix != null) 'Prefix': prefix,
      if (tag != null) 'Tag': tag,
      if (type != null) 'Type': type,
    };
  }
}

/// A value to use for the filter.
class AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails {
  /// Prefix text for matching objects.
  final String? prefix;

  /// A tag that is assigned to matching objects.
  final AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails?
      tag;

  /// The type of filter value. Valid values are
  /// <code>LifecyclePrefixPredicate</code> or <code>LifecycleTagPredicate</code>.
  final String? type;

  AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails({
    this.prefix,
    this.tag,
    this.type,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsDetails(
      prefix: json['Prefix'] as String?,
      tag: json['Tag'] != null
          ? AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails
              .fromJson(json['Tag'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final prefix = this.prefix;
    final tag = this.tag;
    final type = this.type;
    return {
      if (prefix != null) 'Prefix': prefix,
      if (tag != null) 'Tag': tag,
      if (type != null) 'Type': type,
    };
  }
}

/// A tag that is assigned to matching objects.
class AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails {
  /// The tag key.
  final String? key;

  /// The tag value.
  final String? value;

  AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails({
    this.key,
    this.value,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateOperandsTagDetails(
      key: json['Key'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      if (key != null) 'Key': key,
      if (value != null) 'Value': value,
    };
  }
}

/// A tag filter.
class AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails {
  /// The tag key.
  final String? key;

  /// The tag value
  final String? value;

  AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails({
    this.key,
    this.value,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesFilterPredicateTagDetails(
      key: json['Key'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      if (key != null) 'Key': key,
      if (value != null) 'Value': value,
    };
  }
}

/// A transition rule that describes when noncurrent objects transition to a
/// specified storage class.
class AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails {
  /// The number of days that an object is noncurrent before Amazon S3 can perform
  /// the associated action.
  final int? days;

  /// The class of storage to change the object to after the object is noncurrent
  /// for the specified number of days.
  final String? storageClass;

  AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails({
    this.days,
    this.storageClass,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesNoncurrentVersionTransitionsDetails(
      days: json['Days'] as int?,
      storageClass: json['StorageClass'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final days = this.days;
    final storageClass = this.storageClass;
    return {
      if (days != null) 'Days': days,
      if (storageClass != null) 'StorageClass': storageClass,
    };
  }
}

/// A rule for when objects transition to specific storage classes.
class AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails {
  /// A date on which to transition objects to the specified storage class. If you
  /// provide <code>Date</code>, you cannot provide <code>Days</code>.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? date;

  /// The number of days after which to transition the object to the specified
  /// storage class. If you provide <code>Days</code>, you cannot provide
  /// <code>Date</code>.
  final int? days;

  /// The storage class to transition the object to. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>DEEP_ARCHIVE</code>
  /// </li>
  /// <li>
  /// <code>GLACIER</code>
  /// </li>
  /// <li>
  /// <code>INTELLIGENT_TIERING</code>
  /// </li>
  /// <li>
  /// <code>ONEZONE_IA</code>
  /// </li>
  /// <li>
  /// <code>STANDARD_IA</code>
  /// </li>
  /// </ul>
  final String? storageClass;

  AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails({
    this.date,
    this.days,
    this.storageClass,
  });

  factory AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketLifecycleConfigurationRulesTransitionsDetails(
      date: json['Date'] as String?,
      days: json['Days'] as int?,
      storageClass: json['StorageClass'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final date = this.date;
    final days = this.days;
    final storageClass = this.storageClass;
    return {
      if (date != null) 'Date': date,
      if (days != null) 'Days': days,
      if (storageClass != null) 'StorageClass': storageClass,
    };
  }
}

/// Describes the versioning state of an S3 bucket.
class AwsS3BucketBucketVersioningConfiguration {
  /// Specifies whether MFA delete is currently enabled in the S3 bucket
  /// versioning configuration. If the S3 bucket was never configured with MFA
  /// delete, then this attribute is not included.
  final bool? isMfaDeleteEnabled;

  /// The versioning status of the S3 bucket. Valid values are
  /// <code>Enabled</code> or <code>Suspended</code>.
  final String? status;

  AwsS3BucketBucketVersioningConfiguration({
    this.isMfaDeleteEnabled,
    this.status,
  });

  factory AwsS3BucketBucketVersioningConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketBucketVersioningConfiguration(
      isMfaDeleteEnabled: json['IsMfaDeleteEnabled'] as bool?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final isMfaDeleteEnabled = this.isMfaDeleteEnabled;
    final status = this.status;
    return {
      if (isMfaDeleteEnabled != null) 'IsMfaDeleteEnabled': isMfaDeleteEnabled,
      if (status != null) 'Status': status,
    };
  }
}

/// The details of an Amazon Simple Storage Service (Amazon S3) bucket.
class AwsS3BucketDetails {
  /// The access control list for the S3 bucket.
  final String? accessControlList;

  /// The lifecycle configuration for objects in the specified bucket.
  final AwsS3BucketBucketLifecycleConfigurationDetails?
      bucketLifecycleConfiguration;

  /// The logging configuration for the S3 bucket.
  final AwsS3BucketLoggingConfiguration? bucketLoggingConfiguration;

  /// The notification configuration for the S3 bucket.
  final AwsS3BucketNotificationConfiguration? bucketNotificationConfiguration;

  /// The versioning state of an S3 bucket.
  final AwsS3BucketBucketVersioningConfiguration? bucketVersioningConfiguration;

  /// The website configuration parameters for the S3 bucket.
  final AwsS3BucketWebsiteConfiguration? bucketWebsiteConfiguration;

  /// Indicates when the S3 bucket was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? createdAt;

  /// The name of the bucket.
  final String? name;

  /// Specifies which rule Amazon S3 applies by default to every new object placed
  /// in the bucket.
  final AwsS3BucketObjectLockConfiguration? objectLockConfiguration;

  /// The Amazon Web Services account identifier of the account that owns the S3
  /// bucket.
  final String? ownerAccountId;

  /// The canonical user ID of the owner of the S3 bucket.
  final String? ownerId;

  /// The display name of the owner of the S3 bucket.
  final String? ownerName;

  /// Provides information about the Amazon S3 Public Access Block configuration
  /// for the S3 bucket.
  final AwsS3AccountPublicAccessBlockDetails? publicAccessBlockConfiguration;

  /// The encryption rules that are applied to the S3 bucket.
  final AwsS3BucketServerSideEncryptionConfiguration?
      serverSideEncryptionConfiguration;

  AwsS3BucketDetails({
    this.accessControlList,
    this.bucketLifecycleConfiguration,
    this.bucketLoggingConfiguration,
    this.bucketNotificationConfiguration,
    this.bucketVersioningConfiguration,
    this.bucketWebsiteConfiguration,
    this.createdAt,
    this.name,
    this.objectLockConfiguration,
    this.ownerAccountId,
    this.ownerId,
    this.ownerName,
    this.publicAccessBlockConfiguration,
    this.serverSideEncryptionConfiguration,
  });

  factory AwsS3BucketDetails.fromJson(Map<String, dynamic> json) {
    return AwsS3BucketDetails(
      accessControlList: json['AccessControlList'] as String?,
      bucketLifecycleConfiguration: json['BucketLifecycleConfiguration'] != null
          ? AwsS3BucketBucketLifecycleConfigurationDetails.fromJson(
              json['BucketLifecycleConfiguration'] as Map<String, dynamic>)
          : null,
      bucketLoggingConfiguration: json['BucketLoggingConfiguration'] != null
          ? AwsS3BucketLoggingConfiguration.fromJson(
              json['BucketLoggingConfiguration'] as Map<String, dynamic>)
          : null,
      bucketNotificationConfiguration:
          json['BucketNotificationConfiguration'] != null
              ? AwsS3BucketNotificationConfiguration.fromJson(
                  json['BucketNotificationConfiguration']
                      as Map<String, dynamic>)
              : null,
      bucketVersioningConfiguration:
          json['BucketVersioningConfiguration'] != null
              ? AwsS3BucketBucketVersioningConfiguration.fromJson(
                  json['BucketVersioningConfiguration'] as Map<String, dynamic>)
              : null,
      bucketWebsiteConfiguration: json['BucketWebsiteConfiguration'] != null
          ? AwsS3BucketWebsiteConfiguration.fromJson(
              json['BucketWebsiteConfiguration'] as Map<String, dynamic>)
          : null,
      createdAt: json['CreatedAt'] as String?,
      name: json['Name'] as String?,
      objectLockConfiguration: json['ObjectLockConfiguration'] != null
          ? AwsS3BucketObjectLockConfiguration.fromJson(
              json['ObjectLockConfiguration'] as Map<String, dynamic>)
          : null,
      ownerAccountId: json['OwnerAccountId'] as String?,
      ownerId: json['OwnerId'] as String?,
      ownerName: json['OwnerName'] as String?,
      publicAccessBlockConfiguration: json['PublicAccessBlockConfiguration'] !=
              null
          ? AwsS3AccountPublicAccessBlockDetails.fromJson(
              json['PublicAccessBlockConfiguration'] as Map<String, dynamic>)
          : null,
      serverSideEncryptionConfiguration:
          json['ServerSideEncryptionConfiguration'] != null
              ? AwsS3BucketServerSideEncryptionConfiguration.fromJson(
                  json['ServerSideEncryptionConfiguration']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final accessControlList = this.accessControlList;
    final bucketLifecycleConfiguration = this.bucketLifecycleConfiguration;
    final bucketLoggingConfiguration = this.bucketLoggingConfiguration;
    final bucketNotificationConfiguration =
        this.bucketNotificationConfiguration;
    final bucketVersioningConfiguration = this.bucketVersioningConfiguration;
    final bucketWebsiteConfiguration = this.bucketWebsiteConfiguration;
    final createdAt = this.createdAt;
    final name = this.name;
    final objectLockConfiguration = this.objectLockConfiguration;
    final ownerAccountId = this.ownerAccountId;
    final ownerId = this.ownerId;
    final ownerName = this.ownerName;
    final publicAccessBlockConfiguration = this.publicAccessBlockConfiguration;
    final serverSideEncryptionConfiguration =
        this.serverSideEncryptionConfiguration;
    return {
      if (accessControlList != null) 'AccessControlList': accessControlList,
      if (bucketLifecycleConfiguration != null)
        'BucketLifecycleConfiguration': bucketLifecycleConfiguration,
      if (bucketLoggingConfiguration != null)
        'BucketLoggingConfiguration': bucketLoggingConfiguration,
      if (bucketNotificationConfiguration != null)
        'BucketNotificationConfiguration': bucketNotificationConfiguration,
      if (bucketVersioningConfiguration != null)
        'BucketVersioningConfiguration': bucketVersioningConfiguration,
      if (bucketWebsiteConfiguration != null)
        'BucketWebsiteConfiguration': bucketWebsiteConfiguration,
      if (createdAt != null) 'CreatedAt': createdAt,
      if (name != null) 'Name': name,
      if (objectLockConfiguration != null)
        'ObjectLockConfiguration': objectLockConfiguration,
      if (ownerAccountId != null) 'OwnerAccountId': ownerAccountId,
      if (ownerId != null) 'OwnerId': ownerId,
      if (ownerName != null) 'OwnerName': ownerName,
      if (publicAccessBlockConfiguration != null)
        'PublicAccessBlockConfiguration': publicAccessBlockConfiguration,
      if (serverSideEncryptionConfiguration != null)
        'ServerSideEncryptionConfiguration': serverSideEncryptionConfiguration,
    };
  }
}

/// Information about logging for the S3 bucket
class AwsS3BucketLoggingConfiguration {
  /// The name of the S3 bucket where log files for the S3 bucket are stored.
  final String? destinationBucketName;

  /// The prefix added to log files for the S3 bucket.
  final String? logFilePrefix;

  AwsS3BucketLoggingConfiguration({
    this.destinationBucketName,
    this.logFilePrefix,
  });

  factory AwsS3BucketLoggingConfiguration.fromJson(Map<String, dynamic> json) {
    return AwsS3BucketLoggingConfiguration(
      destinationBucketName: json['DestinationBucketName'] as String?,
      logFilePrefix: json['LogFilePrefix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destinationBucketName = this.destinationBucketName;
    final logFilePrefix = this.logFilePrefix;
    return {
      if (destinationBucketName != null)
        'DestinationBucketName': destinationBucketName,
      if (logFilePrefix != null) 'LogFilePrefix': logFilePrefix,
    };
  }
}

/// The notification configuration for the S3 bucket.
class AwsS3BucketNotificationConfiguration {
  /// Configurations for S3 bucket notifications.
  final List<AwsS3BucketNotificationConfigurationDetail>? configurations;

  AwsS3BucketNotificationConfiguration({
    this.configurations,
  });

  factory AwsS3BucketNotificationConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketNotificationConfiguration(
      configurations: (json['Configurations'] as List?)
          ?.whereNotNull()
          .map((e) => AwsS3BucketNotificationConfigurationDetail.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final configurations = this.configurations;
    return {
      if (configurations != null) 'Configurations': configurations,
    };
  }
}

/// Details for an S3 bucket notification configuration.
class AwsS3BucketNotificationConfigurationDetail {
  /// The ARN of the Lambda function, Amazon SQS queue, or Amazon SNS topic that
  /// generates the notification.
  final String? destination;

  /// The list of events that trigger a notification.
  final List<String>? events;

  /// The filters that determine which S3 buckets generate notifications.
  final AwsS3BucketNotificationConfigurationFilter? filter;

  /// Indicates the type of notification. Notifications can be generated using
  /// Lambda functions, Amazon SQS queues, or Amazon SNS topics, with
  /// corresponding valid values as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>LambdaConfiguration</code>
  /// </li>
  /// <li>
  /// <code>QueueConfiguration</code>
  /// </li>
  /// <li>
  /// <code>TopicConfiguration</code>
  /// </li>
  /// </ul>
  final String? type;

  AwsS3BucketNotificationConfigurationDetail({
    this.destination,
    this.events,
    this.filter,
    this.type,
  });

  factory AwsS3BucketNotificationConfigurationDetail.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketNotificationConfigurationDetail(
      destination: json['Destination'] as String?,
      events: (json['Events'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      filter: json['Filter'] != null
          ? AwsS3BucketNotificationConfigurationFilter.fromJson(
              json['Filter'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destination = this.destination;
    final events = this.events;
    final filter = this.filter;
    final type = this.type;
    return {
      if (destination != null) 'Destination': destination,
      if (events != null) 'Events': events,
      if (filter != null) 'Filter': filter,
      if (type != null) 'Type': type,
    };
  }
}

/// Filtering information for the notifications. The filtering is based on
/// Amazon S3 key names.
class AwsS3BucketNotificationConfigurationFilter {
  /// Details for an Amazon S3 filter.
  final AwsS3BucketNotificationConfigurationS3KeyFilter? s3KeyFilter;

  AwsS3BucketNotificationConfigurationFilter({
    this.s3KeyFilter,
  });

  factory AwsS3BucketNotificationConfigurationFilter.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketNotificationConfigurationFilter(
      s3KeyFilter: json['S3KeyFilter'] != null
          ? AwsS3BucketNotificationConfigurationS3KeyFilter.fromJson(
              json['S3KeyFilter'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final s3KeyFilter = this.s3KeyFilter;
    return {
      if (s3KeyFilter != null) 'S3KeyFilter': s3KeyFilter,
    };
  }
}

/// Details for an Amazon S3 filter.
class AwsS3BucketNotificationConfigurationS3KeyFilter {
  /// The filter rules for the filter.
  final List<AwsS3BucketNotificationConfigurationS3KeyFilterRule>? filterRules;

  AwsS3BucketNotificationConfigurationS3KeyFilter({
    this.filterRules,
  });

  factory AwsS3BucketNotificationConfigurationS3KeyFilter.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketNotificationConfigurationS3KeyFilter(
      filterRules: (json['FilterRules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsS3BucketNotificationConfigurationS3KeyFilterRule.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final filterRules = this.filterRules;
    return {
      if (filterRules != null) 'FilterRules': filterRules,
    };
  }
}

/// Details for a filter rule.
class AwsS3BucketNotificationConfigurationS3KeyFilterRule {
  /// Indicates whether the filter is based on the prefix or suffix of the Amazon
  /// S3 key.
  final AwsS3BucketNotificationConfigurationS3KeyFilterRuleName? name;

  /// The filter value.
  final String? value;

  AwsS3BucketNotificationConfigurationS3KeyFilterRule({
    this.name,
    this.value,
  });

  factory AwsS3BucketNotificationConfigurationS3KeyFilterRule.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketNotificationConfigurationS3KeyFilterRule(
      name: (json['Name'] as String?)
          ?.toAwsS3BucketNotificationConfigurationS3KeyFilterRuleName(),
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
  prefix,
  suffix,
}

extension AwsS3BucketNotificationConfigurationS3KeyFilterRuleNameValueExtension
    on AwsS3BucketNotificationConfigurationS3KeyFilterRuleName {
  String toValue() {
    switch (this) {
      case AwsS3BucketNotificationConfigurationS3KeyFilterRuleName.prefix:
        return 'Prefix';
      case AwsS3BucketNotificationConfigurationS3KeyFilterRuleName.suffix:
        return 'Suffix';
    }
  }
}

extension AwsS3BucketNotificationConfigurationS3KeyFilterRuleNameFromString
    on String {
  AwsS3BucketNotificationConfigurationS3KeyFilterRuleName
      toAwsS3BucketNotificationConfigurationS3KeyFilterRuleName() {
    switch (this) {
      case 'Prefix':
        return AwsS3BucketNotificationConfigurationS3KeyFilterRuleName.prefix;
      case 'Suffix':
        return AwsS3BucketNotificationConfigurationS3KeyFilterRuleName.suffix;
    }
    throw Exception(
        '$this is not known in enum AwsS3BucketNotificationConfigurationS3KeyFilterRuleName');
  }
}

/// The container element for S3 Object Lock configuration parameters. In Amazon
/// S3, Object Lock can help prevent objects from being deleted or overwritten
/// for a fixed amount of time or indefinitely.
class AwsS3BucketObjectLockConfiguration {
  /// Indicates whether the bucket has an Object Lock configuration enabled.
  final String? objectLockEnabled;

  /// Specifies the Object Lock rule for the specified object.
  final AwsS3BucketObjectLockConfigurationRuleDetails? rule;

  AwsS3BucketObjectLockConfiguration({
    this.objectLockEnabled,
    this.rule,
  });

  factory AwsS3BucketObjectLockConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketObjectLockConfiguration(
      objectLockEnabled: json['ObjectLockEnabled'] as String?,
      rule: json['Rule'] != null
          ? AwsS3BucketObjectLockConfigurationRuleDetails.fromJson(
              json['Rule'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final objectLockEnabled = this.objectLockEnabled;
    final rule = this.rule;
    return {
      if (objectLockEnabled != null) 'ObjectLockEnabled': objectLockEnabled,
      if (rule != null) 'Rule': rule,
    };
  }
}

/// The default S3 Object Lock retention mode and period that you want to apply
/// to new objects placed in the specified Amazon S3 bucket.
class AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails {
  /// The number of days that you want to specify for the default retention
  /// period.
  final int? days;

  /// The default Object Lock retention mode you want to apply to new objects
  /// placed in the specified bucket.
  final String? mode;

  /// The number of years that you want to specify for the default retention
  /// period.
  final int? years;

  AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails({
    this.days,
    this.mode,
    this.years,
  });

  factory AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails(
      days: json['Days'] as int?,
      mode: json['Mode'] as String?,
      years: json['Years'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final days = this.days;
    final mode = this.mode;
    final years = this.years;
    return {
      if (days != null) 'Days': days,
      if (mode != null) 'Mode': mode,
      if (years != null) 'Years': years,
    };
  }
}

/// Specifies the S3 Object Lock rule for the specified object. In Amazon S3,
/// Object Lock can help prevent objects from being deleted or overwritten for a
/// fixed amount of time or indefinitely.
class AwsS3BucketObjectLockConfigurationRuleDetails {
  /// The default Object Lock retention mode and period that you want to apply to
  /// new objects placed in the specified bucket.
  final AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails?
      defaultRetention;

  AwsS3BucketObjectLockConfigurationRuleDetails({
    this.defaultRetention,
  });

  factory AwsS3BucketObjectLockConfigurationRuleDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketObjectLockConfigurationRuleDetails(
      defaultRetention: json['DefaultRetention'] != null
          ? AwsS3BucketObjectLockConfigurationRuleDefaultRetentionDetails
              .fromJson(json['DefaultRetention'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultRetention = this.defaultRetention;
    return {
      if (defaultRetention != null) 'DefaultRetention': defaultRetention,
    };
  }
}

/// Specifies the default server-side encryption to apply to new objects in the
/// bucket.
class AwsS3BucketServerSideEncryptionByDefault {
  /// KMS key ID to use for the default encryption.
  final String? kMSMasterKeyID;

  /// Server-side encryption algorithm to use for the default encryption. Valid
  /// values are <code>aws: kms</code> or <code>AES256</code>.
  final String? sSEAlgorithm;

  AwsS3BucketServerSideEncryptionByDefault({
    this.kMSMasterKeyID,
    this.sSEAlgorithm,
  });

  factory AwsS3BucketServerSideEncryptionByDefault.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketServerSideEncryptionByDefault(
      kMSMasterKeyID: json['KMSMasterKeyID'] as String?,
      sSEAlgorithm: json['SSEAlgorithm'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final kMSMasterKeyID = this.kMSMasterKeyID;
    final sSEAlgorithm = this.sSEAlgorithm;
    return {
      if (kMSMasterKeyID != null) 'KMSMasterKeyID': kMSMasterKeyID,
      if (sSEAlgorithm != null) 'SSEAlgorithm': sSEAlgorithm,
    };
  }
}

/// The encryption configuration for the S3 bucket.
class AwsS3BucketServerSideEncryptionConfiguration {
  /// The encryption rules that are applied to the S3 bucket.
  final List<AwsS3BucketServerSideEncryptionRule>? rules;

  AwsS3BucketServerSideEncryptionConfiguration({
    this.rules,
  });

  factory AwsS3BucketServerSideEncryptionConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketServerSideEncryptionConfiguration(
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) => AwsS3BucketServerSideEncryptionRule.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final rules = this.rules;
    return {
      if (rules != null) 'Rules': rules,
    };
  }
}

/// An encryption rule to apply to the S3 bucket.
class AwsS3BucketServerSideEncryptionRule {
  /// Specifies the default server-side encryption to apply to new objects in the
  /// bucket. If a <code>PUT</code> object request doesn't specify any server-side
  /// encryption, this default encryption is applied.
  final AwsS3BucketServerSideEncryptionByDefault?
      applyServerSideEncryptionByDefault;

  AwsS3BucketServerSideEncryptionRule({
    this.applyServerSideEncryptionByDefault,
  });

  factory AwsS3BucketServerSideEncryptionRule.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketServerSideEncryptionRule(
      applyServerSideEncryptionByDefault:
          json['ApplyServerSideEncryptionByDefault'] != null
              ? AwsS3BucketServerSideEncryptionByDefault.fromJson(
                  json['ApplyServerSideEncryptionByDefault']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final applyServerSideEncryptionByDefault =
        this.applyServerSideEncryptionByDefault;
    return {
      if (applyServerSideEncryptionByDefault != null)
        'ApplyServerSideEncryptionByDefault':
            applyServerSideEncryptionByDefault,
    };
  }
}

/// Website parameters for the S3 bucket.
class AwsS3BucketWebsiteConfiguration {
  /// The name of the error document for the website.
  final String? errorDocument;

  /// The name of the index document for the website.
  final String? indexDocumentSuffix;

  /// The redirect behavior for requests to the website.
  final AwsS3BucketWebsiteConfigurationRedirectTo? redirectAllRequestsTo;

  /// The rules for applying redirects for requests to the website.
  final List<AwsS3BucketWebsiteConfigurationRoutingRule>? routingRules;

  AwsS3BucketWebsiteConfiguration({
    this.errorDocument,
    this.indexDocumentSuffix,
    this.redirectAllRequestsTo,
    this.routingRules,
  });

  factory AwsS3BucketWebsiteConfiguration.fromJson(Map<String, dynamic> json) {
    return AwsS3BucketWebsiteConfiguration(
      errorDocument: json['ErrorDocument'] as String?,
      indexDocumentSuffix: json['IndexDocumentSuffix'] as String?,
      redirectAllRequestsTo: json['RedirectAllRequestsTo'] != null
          ? AwsS3BucketWebsiteConfigurationRedirectTo.fromJson(
              json['RedirectAllRequestsTo'] as Map<String, dynamic>)
          : null,
      routingRules: (json['RoutingRules'] as List?)
          ?.whereNotNull()
          .map((e) => AwsS3BucketWebsiteConfigurationRoutingRule.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final errorDocument = this.errorDocument;
    final indexDocumentSuffix = this.indexDocumentSuffix;
    final redirectAllRequestsTo = this.redirectAllRequestsTo;
    final routingRules = this.routingRules;
    return {
      if (errorDocument != null) 'ErrorDocument': errorDocument,
      if (indexDocumentSuffix != null)
        'IndexDocumentSuffix': indexDocumentSuffix,
      if (redirectAllRequestsTo != null)
        'RedirectAllRequestsTo': redirectAllRequestsTo,
      if (routingRules != null) 'RoutingRules': routingRules,
    };
  }
}

/// The redirect behavior for requests to the website.
class AwsS3BucketWebsiteConfigurationRedirectTo {
  /// The name of the host to redirect requests to.
  final String? hostname;

  /// The protocol to use when redirecting requests. By default, this field uses
  /// the same protocol as the original request. Valid values are
  /// <code>http</code> or <code>https</code>.
  final String? protocol;

  AwsS3BucketWebsiteConfigurationRedirectTo({
    this.hostname,
    this.protocol,
  });

  factory AwsS3BucketWebsiteConfigurationRedirectTo.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketWebsiteConfigurationRedirectTo(
      hostname: json['Hostname'] as String?,
      protocol: json['Protocol'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hostname = this.hostname;
    final protocol = this.protocol;
    return {
      if (hostname != null) 'Hostname': hostname,
      if (protocol != null) 'Protocol': protocol,
    };
  }
}

/// A rule for redirecting requests to the website.
class AwsS3BucketWebsiteConfigurationRoutingRule {
  /// Provides the condition that must be met in order to apply the routing rule.
  final AwsS3BucketWebsiteConfigurationRoutingRuleCondition? condition;

  /// Provides the rules to redirect the request if the condition in
  /// <code>Condition</code> is met.
  final AwsS3BucketWebsiteConfigurationRoutingRuleRedirect? redirect;

  AwsS3BucketWebsiteConfigurationRoutingRule({
    this.condition,
    this.redirect,
  });

  factory AwsS3BucketWebsiteConfigurationRoutingRule.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketWebsiteConfigurationRoutingRule(
      condition: json['Condition'] != null
          ? AwsS3BucketWebsiteConfigurationRoutingRuleCondition.fromJson(
              json['Condition'] as Map<String, dynamic>)
          : null,
      redirect: json['Redirect'] != null
          ? AwsS3BucketWebsiteConfigurationRoutingRuleRedirect.fromJson(
              json['Redirect'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final condition = this.condition;
    final redirect = this.redirect;
    return {
      if (condition != null) 'Condition': condition,
      if (redirect != null) 'Redirect': redirect,
    };
  }
}

/// The condition that must be met in order to apply the routing rule.
class AwsS3BucketWebsiteConfigurationRoutingRuleCondition {
  /// Indicates to redirect the request if the HTTP error code matches this value.
  final String? httpErrorCodeReturnedEquals;

  /// Indicates to redirect the request if the key prefix matches this value.
  final String? keyPrefixEquals;

  AwsS3BucketWebsiteConfigurationRoutingRuleCondition({
    this.httpErrorCodeReturnedEquals,
    this.keyPrefixEquals,
  });

  factory AwsS3BucketWebsiteConfigurationRoutingRuleCondition.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketWebsiteConfigurationRoutingRuleCondition(
      httpErrorCodeReturnedEquals:
          json['HttpErrorCodeReturnedEquals'] as String?,
      keyPrefixEquals: json['KeyPrefixEquals'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final httpErrorCodeReturnedEquals = this.httpErrorCodeReturnedEquals;
    final keyPrefixEquals = this.keyPrefixEquals;
    return {
      if (httpErrorCodeReturnedEquals != null)
        'HttpErrorCodeReturnedEquals': httpErrorCodeReturnedEquals,
      if (keyPrefixEquals != null) 'KeyPrefixEquals': keyPrefixEquals,
    };
  }
}

/// The rules to redirect the request if the condition in <code>Condition</code>
/// is met.
class AwsS3BucketWebsiteConfigurationRoutingRuleRedirect {
  /// The host name to use in the redirect request.
  final String? hostname;

  /// The HTTP redirect code to use in the response.
  final String? httpRedirectCode;

  /// The protocol to use to redirect the request. By default, uses the protocol
  /// from the original request.
  final String? protocol;

  /// The object key prefix to use in the redirect request.
  ///
  /// Cannot be provided if <code>ReplaceKeyWith</code> is present.
  final String? replaceKeyPrefixWith;

  /// The specific object key to use in the redirect request.
  ///
  /// Cannot be provided if <code>ReplaceKeyPrefixWith</code> is present.
  final String? replaceKeyWith;

  AwsS3BucketWebsiteConfigurationRoutingRuleRedirect({
    this.hostname,
    this.httpRedirectCode,
    this.protocol,
    this.replaceKeyPrefixWith,
    this.replaceKeyWith,
  });

  factory AwsS3BucketWebsiteConfigurationRoutingRuleRedirect.fromJson(
      Map<String, dynamic> json) {
    return AwsS3BucketWebsiteConfigurationRoutingRuleRedirect(
      hostname: json['Hostname'] as String?,
      httpRedirectCode: json['HttpRedirectCode'] as String?,
      protocol: json['Protocol'] as String?,
      replaceKeyPrefixWith: json['ReplaceKeyPrefixWith'] as String?,
      replaceKeyWith: json['ReplaceKeyWith'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final hostname = this.hostname;
    final httpRedirectCode = this.httpRedirectCode;
    final protocol = this.protocol;
    final replaceKeyPrefixWith = this.replaceKeyPrefixWith;
    final replaceKeyWith = this.replaceKeyWith;
    return {
      if (hostname != null) 'Hostname': hostname,
      if (httpRedirectCode != null) 'HttpRedirectCode': httpRedirectCode,
      if (protocol != null) 'Protocol': protocol,
      if (replaceKeyPrefixWith != null)
        'ReplaceKeyPrefixWith': replaceKeyPrefixWith,
      if (replaceKeyWith != null) 'ReplaceKeyWith': replaceKeyWith,
    };
  }
}

/// Details about an Amazon S3 object.
class AwsS3ObjectDetails {
  /// A standard MIME type describing the format of the object data.
  final String? contentType;

  /// The opaque identifier assigned by a web server to a specific version of a
  /// resource found at a URL.
  final String? eTag;

  /// Indicates when the object was last modified.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastModified;

  /// The identifier of the KMS symmetric customer managed key that was used for
  /// the object.
  final String? sSEKMSKeyId;

  /// If the object is stored using server-side encryption, the value of the
  /// server-side encryption algorithm used when storing this object in Amazon S3.
  final String? serverSideEncryption;

  /// The version of the object.
  final String? versionId;

  AwsS3ObjectDetails({
    this.contentType,
    this.eTag,
    this.lastModified,
    this.sSEKMSKeyId,
    this.serverSideEncryption,
    this.versionId,
  });

  factory AwsS3ObjectDetails.fromJson(Map<String, dynamic> json) {
    return AwsS3ObjectDetails(
      contentType: json['ContentType'] as String?,
      eTag: json['ETag'] as String?,
      lastModified: json['LastModified'] as String?,
      sSEKMSKeyId: json['SSEKMSKeyId'] as String?,
      serverSideEncryption: json['ServerSideEncryption'] as String?,
      versionId: json['VersionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final contentType = this.contentType;
    final eTag = this.eTag;
    final lastModified = this.lastModified;
    final sSEKMSKeyId = this.sSEKMSKeyId;
    final serverSideEncryption = this.serverSideEncryption;
    final versionId = this.versionId;
    return {
      if (contentType != null) 'ContentType': contentType,
      if (eTag != null) 'ETag': eTag,
      if (lastModified != null) 'LastModified': lastModified,
      if (sSEKMSKeyId != null) 'SSEKMSKeyId': sSEKMSKeyId,
      if (serverSideEncryption != null)
        'ServerSideEncryption': serverSideEncryption,
      if (versionId != null) 'VersionId': versionId,
    };
  }
}

/// Provides details about an Amazon SageMaker notebook instance.
class AwsSageMakerNotebookInstanceDetails {
  /// A list of Amazon Elastic Inference instance types to associate with the
  /// notebook instance. Currently, only one instance type can be associated with
  /// a notebook instance.
  final List<String>? acceleratorTypes;

  /// An array of up to three Git repositories associated with the notebook
  /// instance. These can be either the names of Git repositories stored as
  /// resources in your account, or the URL of Git repositories in <a
  /// href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">CodeCommit</a>
  /// or in any other Git repository. These repositories are cloned at the same
  /// level as the default repository of your notebook instance. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating
  /// Git repositories with SageMaker notebook instances</a> in the <i>Amazon
  /// SageMaker Developer Guide</i>.
  final List<String>? additionalCodeRepositories;

  /// The Git repository associated with the notebook instance as its default code
  /// repository. This can be either the name of a Git repository stored as a
  /// resource in your account, or the URL of a Git repository in <a
  /// href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">CodeCommit</a>
  /// or in any other Git repository. When you open a notebook instance, it opens
  /// in the directory that contains this repository. For more information, see <a
  /// href="https://docs.aws.amazon.com/sagemaker/latest/dg/nbi-git-repo.html">Associating
  /// Git repositories with SageMaker notebook instances</a> in the <i>Amazon
  /// SageMaker Developer Guide</i>.
  final String? defaultCodeRepository;

  /// Sets whether SageMaker provides internet access to the notebook instance. If
  /// you set this to <code>Disabled</code>, this notebook instance is able to
  /// access resources only in your VPC, and is not be able to connect to
  /// SageMaker training and endpoint services unless you configure a Network
  /// Address Translation (NAT) Gateway in your VPC.
  final String? directInternetAccess;

  /// If status of the instance is <code>Failed</code>, the reason it failed.
  final String? failureReason;

  /// Information on the IMDS configuration of the notebook instance.
  final AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails?
      instanceMetadataServiceConfiguration;

  /// The type of machine learning (ML) compute instance to launch for the
  /// notebook instance.
  final String? instanceType;

  /// The Amazon Resource Name (ARN) of an Key Management Service (KMS) key that
  /// SageMaker uses to encrypt data on the storage volume attached to your
  /// notebook instance. The KMS key you provide must be enabled. For information,
  /// see <a
  /// href="https://docs.aws.amazon.com/kms/latest/developerguide/enabling-keys.html">Enabling
  /// and disabling keys</a> in the <i>Key Management Service Developer Guide</i>.
  final String? kmsKeyId;

  /// The network interface ID that SageMaker created when the instance was
  /// created.
  final String? networkInterfaceId;

  /// The Amazon Resource Name (ARN) of the notebook instance.
  final String? notebookInstanceArn;

  /// The name of a notebook instance lifecycle configuration.
  final String? notebookInstanceLifecycleConfigName;

  /// The name of the new notebook instance.
  final String? notebookInstanceName;

  /// The status of the notebook instance.
  final String? notebookInstanceStatus;

  /// The platform identifier of the notebook instance runtime environment.
  final String? platformIdentifier;

  /// The Amazon Resource Name (ARN) of the IAM role associated with the instance.
  final String? roleArn;

  /// Whether root access is enabled or disabled for users of the notebook
  /// instance.
  final String? rootAccess;

  /// The VPC security group IDs.
  final List<String>? securityGroups;

  /// The ID of the VPC subnet to which you have a connectivity from your ML
  /// compute instance.
  final String? subnetId;

  /// The URL that you use to connect to the Jupyter notebook that is running in
  /// your notebook instance.
  final String? url;

  /// The size, in GB, of the ML storage volume to attach to the notebook
  /// instance.
  final int? volumeSizeInGB;

  AwsSageMakerNotebookInstanceDetails({
    this.acceleratorTypes,
    this.additionalCodeRepositories,
    this.defaultCodeRepository,
    this.directInternetAccess,
    this.failureReason,
    this.instanceMetadataServiceConfiguration,
    this.instanceType,
    this.kmsKeyId,
    this.networkInterfaceId,
    this.notebookInstanceArn,
    this.notebookInstanceLifecycleConfigName,
    this.notebookInstanceName,
    this.notebookInstanceStatus,
    this.platformIdentifier,
    this.roleArn,
    this.rootAccess,
    this.securityGroups,
    this.subnetId,
    this.url,
    this.volumeSizeInGB,
  });

  factory AwsSageMakerNotebookInstanceDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsSageMakerNotebookInstanceDetails(
      acceleratorTypes: (json['AcceleratorTypes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      additionalCodeRepositories: (json['AdditionalCodeRepositories'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      defaultCodeRepository: json['DefaultCodeRepository'] as String?,
      directInternetAccess: json['DirectInternetAccess'] as String?,
      failureReason: json['FailureReason'] as String?,
      instanceMetadataServiceConfiguration:
          json['InstanceMetadataServiceConfiguration'] != null
              ? AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails
                  .fromJson(json['InstanceMetadataServiceConfiguration']
                      as Map<String, dynamic>)
              : null,
      instanceType: json['InstanceType'] as String?,
      kmsKeyId: json['KmsKeyId'] as String?,
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
      notebookInstanceArn: json['NotebookInstanceArn'] as String?,
      notebookInstanceLifecycleConfigName:
          json['NotebookInstanceLifecycleConfigName'] as String?,
      notebookInstanceName: json['NotebookInstanceName'] as String?,
      notebookInstanceStatus: json['NotebookInstanceStatus'] as String?,
      platformIdentifier: json['PlatformIdentifier'] as String?,
      roleArn: json['RoleArn'] as String?,
      rootAccess: json['RootAccess'] as String?,
      securityGroups: (json['SecurityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnetId: json['SubnetId'] as String?,
      url: json['Url'] as String?,
      volumeSizeInGB: json['VolumeSizeInGB'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final acceleratorTypes = this.acceleratorTypes;
    final additionalCodeRepositories = this.additionalCodeRepositories;
    final defaultCodeRepository = this.defaultCodeRepository;
    final directInternetAccess = this.directInternetAccess;
    final failureReason = this.failureReason;
    final instanceMetadataServiceConfiguration =
        this.instanceMetadataServiceConfiguration;
    final instanceType = this.instanceType;
    final kmsKeyId = this.kmsKeyId;
    final networkInterfaceId = this.networkInterfaceId;
    final notebookInstanceArn = this.notebookInstanceArn;
    final notebookInstanceLifecycleConfigName =
        this.notebookInstanceLifecycleConfigName;
    final notebookInstanceName = this.notebookInstanceName;
    final notebookInstanceStatus = this.notebookInstanceStatus;
    final platformIdentifier = this.platformIdentifier;
    final roleArn = this.roleArn;
    final rootAccess = this.rootAccess;
    final securityGroups = this.securityGroups;
    final subnetId = this.subnetId;
    final url = this.url;
    final volumeSizeInGB = this.volumeSizeInGB;
    return {
      if (acceleratorTypes != null) 'AcceleratorTypes': acceleratorTypes,
      if (additionalCodeRepositories != null)
        'AdditionalCodeRepositories': additionalCodeRepositories,
      if (defaultCodeRepository != null)
        'DefaultCodeRepository': defaultCodeRepository,
      if (directInternetAccess != null)
        'DirectInternetAccess': directInternetAccess,
      if (failureReason != null) 'FailureReason': failureReason,
      if (instanceMetadataServiceConfiguration != null)
        'InstanceMetadataServiceConfiguration':
            instanceMetadataServiceConfiguration,
      if (instanceType != null) 'InstanceType': instanceType,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (notebookInstanceArn != null)
        'NotebookInstanceArn': notebookInstanceArn,
      if (notebookInstanceLifecycleConfigName != null)
        'NotebookInstanceLifecycleConfigName':
            notebookInstanceLifecycleConfigName,
      if (notebookInstanceName != null)
        'NotebookInstanceName': notebookInstanceName,
      if (notebookInstanceStatus != null)
        'NotebookInstanceStatus': notebookInstanceStatus,
      if (platformIdentifier != null) 'PlatformIdentifier': platformIdentifier,
      if (roleArn != null) 'RoleArn': roleArn,
      if (rootAccess != null) 'RootAccess': rootAccess,
      if (securityGroups != null) 'SecurityGroups': securityGroups,
      if (subnetId != null) 'SubnetId': subnetId,
      if (url != null) 'Url': url,
      if (volumeSizeInGB != null) 'VolumeSizeInGB': volumeSizeInGB,
    };
  }
}

/// Information on the instance metadata service (IMDS) configuration of the
/// notebook instance.
class AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails {
  /// Indicates the minimum IMDS version that the notebook instance supports.
  final String? minimumInstanceMetadataServiceVersion;

  AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails({
    this.minimumInstanceMetadataServiceVersion,
  });

  factory AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsSageMakerNotebookInstanceMetadataServiceConfigurationDetails(
      minimumInstanceMetadataServiceVersion:
          json['MinimumInstanceMetadataServiceVersion'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final minimumInstanceMetadataServiceVersion =
        this.minimumInstanceMetadataServiceVersion;
    return {
      if (minimumInstanceMetadataServiceVersion != null)
        'MinimumInstanceMetadataServiceVersion':
            minimumInstanceMetadataServiceVersion,
    };
  }
}

/// Details about an Secrets Manager secret.
class AwsSecretsManagerSecretDetails {
  /// Whether the secret is deleted.
  final bool? deleted;

  /// The user-provided description of the secret.
  final String? description;

  /// The ARN, Key ID, or alias of the KMS key used to encrypt the
  /// <code>SecretString</code> or <code>SecretBinary</code> values for versions
  /// of this secret.
  final String? kmsKeyId;

  /// The name of the secret.
  final String? name;

  /// Whether rotation is enabled.
  final bool? rotationEnabled;

  /// The ARN of the Lambda function that rotates the secret.
  final String? rotationLambdaArn;

  /// Whether the rotation occurred within the specified rotation frequency.
  final bool? rotationOccurredWithinFrequency;

  /// Defines the rotation schedule for the secret.
  final AwsSecretsManagerSecretRotationRules? rotationRules;

  AwsSecretsManagerSecretDetails({
    this.deleted,
    this.description,
    this.kmsKeyId,
    this.name,
    this.rotationEnabled,
    this.rotationLambdaArn,
    this.rotationOccurredWithinFrequency,
    this.rotationRules,
  });

  factory AwsSecretsManagerSecretDetails.fromJson(Map<String, dynamic> json) {
    return AwsSecretsManagerSecretDetails(
      deleted: json['Deleted'] as bool?,
      description: json['Description'] as String?,
      kmsKeyId: json['KmsKeyId'] as String?,
      name: json['Name'] as String?,
      rotationEnabled: json['RotationEnabled'] as bool?,
      rotationLambdaArn: json['RotationLambdaArn'] as String?,
      rotationOccurredWithinFrequency:
          json['RotationOccurredWithinFrequency'] as bool?,
      rotationRules: json['RotationRules'] != null
          ? AwsSecretsManagerSecretRotationRules.fromJson(
              json['RotationRules'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final deleted = this.deleted;
    final description = this.description;
    final kmsKeyId = this.kmsKeyId;
    final name = this.name;
    final rotationEnabled = this.rotationEnabled;
    final rotationLambdaArn = this.rotationLambdaArn;
    final rotationOccurredWithinFrequency =
        this.rotationOccurredWithinFrequency;
    final rotationRules = this.rotationRules;
    return {
      if (deleted != null) 'Deleted': deleted,
      if (description != null) 'Description': description,
      if (kmsKeyId != null) 'KmsKeyId': kmsKeyId,
      if (name != null) 'Name': name,
      if (rotationEnabled != null) 'RotationEnabled': rotationEnabled,
      if (rotationLambdaArn != null) 'RotationLambdaArn': rotationLambdaArn,
      if (rotationOccurredWithinFrequency != null)
        'RotationOccurredWithinFrequency': rotationOccurredWithinFrequency,
      if (rotationRules != null) 'RotationRules': rotationRules,
    };
  }
}

/// Defines the rotation schedule for the secret.
class AwsSecretsManagerSecretRotationRules {
  /// The number of days after the previous rotation to rotate the secret.
  final int? automaticallyAfterDays;

  AwsSecretsManagerSecretRotationRules({
    this.automaticallyAfterDays,
  });

  factory AwsSecretsManagerSecretRotationRules.fromJson(
      Map<String, dynamic> json) {
    return AwsSecretsManagerSecretRotationRules(
      automaticallyAfterDays: json['AutomaticallyAfterDays'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final automaticallyAfterDays = this.automaticallyAfterDays;
    return {
      if (automaticallyAfterDays != null)
        'AutomaticallyAfterDays': automaticallyAfterDays,
    };
  }
}

/// Provides a consistent format for Security Hub findings.
/// <code>AwsSecurityFinding</code> format allows you to share findings between
/// Amazon Web Services security services and third-party solutions.
/// <note>
/// A finding is a potential security issue generated either by Amazon Web
/// Services services or by the integrated third-party solutions and standards
/// checks.
/// </note>
class AwsSecurityFinding {
  /// The Amazon Web Services account ID that a finding is generated in.
  ///
  /// Length Constraints: 12.
  final String awsAccountId;

  /// Indicates when the security findings provider created the potential security
  /// issue that a finding captured.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String createdAt;

  /// A finding's description. <code>Description</code> is a required property.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 1024.
  final String description;

  /// The identifier for the solution-specific component (a discrete unit of
  /// logic) that generated a finding. In various security findings providers'
  /// solutions, this generator can be called a rule, a check, a detector, a
  /// plugin, or something else.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 512.
  final String generatorId;

  /// The security findings provider-specific identifier for a finding.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 512.
  final String id;

  /// The ARN generated by Security Hub that uniquely identifies a product that
  /// generates findings. This can be the ARN for a third-party product that is
  /// integrated with Security Hub, or the ARN for a custom integration.
  ///
  /// Length Constraints: Minimum length of 12. Maximum length of 2048.
  final String productArn;

  /// A set of resource data types that describe the resources that the finding
  /// refers to.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 32 items.
  final List<Resource> resources;

  /// The schema version that a finding is formatted for. The value is
  /// <code>2018-10-08</code>.
  final String schemaVersion;

  /// A finding's title. <code>Title</code> is a required property.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256.
  final String title;

  /// Indicates when the security findings provider last updated the finding
  /// record.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String updatedAt;

  /// Provides details about an action that affects or that was taken on a
  /// resource.
  final Action? action;

  /// The name of the Amazon Web Services account from which a finding was
  /// generated.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 50.
  final String? awsAccountName;

  /// The name of the company for the product that generated the finding.
  ///
  /// Security Hub populates this attribute automatically for each finding. You
  /// cannot update this attribute with <code>BatchImportFindings</code> or
  /// <code>BatchUpdateFindings</code>. The exception to this is a custom
  /// integration.
  ///
  /// When you use the Security Hub console or API to filter findings by company
  /// name, you use this attribute.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 128.
  final String? companyName;

  /// This data type is exclusive to findings that are generated as the result of
  /// a check run against a specific rule in a supported security standard, such
  /// as CIS Amazon Web Services Foundations. Contains security standard-related
  /// finding details.
  final Compliance? compliance;

  /// A finding's confidence. Confidence is defined as the likelihood that a
  /// finding accurately identifies the behavior or issue that it was intended to
  /// identify.
  ///
  /// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
  /// zero percent confidence and 100 means 100 percent confidence.
  final int? confidence;

  /// The level of importance assigned to the resources associated with the
  /// finding.
  ///
  /// A score of 0 means that the underlying resources have no criticality, and a
  /// score of 100 is reserved for the most critical resources.
  final int? criticality;

  /// In a <code>BatchImportFindings</code> request, finding providers use
  /// <code>FindingProviderFields</code> to provide and update their own values
  /// for confidence, criticality, related findings, severity, and types.
  final FindingProviderFields? findingProviderFields;

  /// Indicates when the security findings provider first observed the potential
  /// security issue that a finding captured.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? firstObservedAt;

  /// Provides metadata for the Amazon CodeGuru detector associated with a
  /// finding. This field pertains to findings that relate to Lambda functions.
  /// Amazon Inspector identifies policy violations and vulnerabilities in Lambda
  /// function code based on internal detectors developed in collaboration with
  /// Amazon CodeGuru. Security Hub receives those findings.
  final GeneratorDetails? generatorDetails;

  /// Indicates when the security findings provider most recently observed the
  /// potential security issue that a finding captured.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastObservedAt;

  /// A list of malware related to a finding.
  ///
  /// Array Members: Maximum number of 5 items.
  final List<Malware>? malware;

  /// The details of network-related information about a finding.
  final Network? network;

  /// Provides information about a network path that is relevant to a finding.
  /// Each entry under <code>NetworkPath</code> represents a component of that
  /// path.
  final List<NetworkPathComponent>? networkPath;

  /// A user-defined note added to a finding.
  final Note? note;

  /// Provides an overview of the patch compliance status for an instance against
  /// a selected compliance standard.
  final PatchSummary? patchSummary;

  /// The details of process-related information about a finding.
  final ProcessDetails? process;

  /// A timestamp that indicates when Security Hub received a finding and begins
  /// to process it.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? processedAt;

  /// A data type where security findings providers can include additional
  /// solution-specific details that aren't part of the defined
  /// <code>AwsSecurityFinding</code> format.
  ///
  /// Can contain up to 50 key-value pairs. For each key-value pair, the key can
  /// contain up to 128 characters, and the value can contain up to 2048
  /// characters.
  final Map<String, String>? productFields;

  /// The name of the product that generated the finding.
  ///
  /// Security Hub populates this attribute automatically for each finding. You
  /// cannot update this attribute with <code>BatchImportFindings</code> or
  /// <code>BatchUpdateFindings</code>. The exception to this is a custom
  /// integration.
  ///
  /// When you use the Security Hub console or API to filter findings by product
  /// name, you use this attribute.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 128.
  final String? productName;

  /// The record state of a finding.
  final RecordState? recordState;

  /// The Region from which the finding was generated.
  ///
  /// Security Hub populates this attribute automatically for each finding. You
  /// cannot update it using <code>BatchImportFindings</code> or
  /// <code>BatchUpdateFindings</code>.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 16.
  final String? region;

  /// A list of related findings.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 10 items.
  final List<RelatedFinding>? relatedFindings;

  /// A data type that describes the remediation options for a finding.
  final Remediation? remediation;

  /// Indicates whether the finding is a sample finding.
  final bool? sample;

  /// A finding's severity.
  final Severity? severity;

  /// A URL that links to a page about the current finding in the security
  /// findings provider's solution.
  final String? sourceUrl;

  /// Threat intelligence details related to a finding.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 5 items.
  final List<ThreatIntelIndicator>? threatIntelIndicators;

  /// Details about the threat detected in a security finding and the file paths
  /// that were affected by the threat.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 32 items.
  final List<Threat>? threats;

  /// One or more finding types in the format of
  /// <code>namespace/category/classifier</code> that classify a finding.
  ///
  /// Valid namespace values are: Software and Configuration Checks | TTPs |
  /// Effects | Unusual Behaviors | Sensitive Data Identifications
  ///
  /// Array Members: Maximum number of 50 items.
  final List<String>? types;

  /// A list of name/value string pairs associated with the finding. These are
  /// custom, user-defined fields added to a finding.
  ///
  /// Can contain up to 50 key-value pairs. For each key-value pair, the key can
  /// contain up to 128 characters, and the value can contain up to 1024
  /// characters.
  final Map<String, String>? userDefinedFields;

  /// Indicates the veracity of a finding.
  final VerificationState? verificationState;

  /// Provides a list of vulnerabilities associated with the findings.
  final List<Vulnerability>? vulnerabilities;

  /// Provides information about the status of the investigation into a finding.
  final Workflow? workflow;

  /// The workflow state of a finding.
  final WorkflowState? workflowState;

  AwsSecurityFinding({
    required this.awsAccountId,
    required this.createdAt,
    required this.description,
    required this.generatorId,
    required this.id,
    required this.productArn,
    required this.resources,
    required this.schemaVersion,
    required this.title,
    required this.updatedAt,
    this.action,
    this.awsAccountName,
    this.companyName,
    this.compliance,
    this.confidence,
    this.criticality,
    this.findingProviderFields,
    this.firstObservedAt,
    this.generatorDetails,
    this.lastObservedAt,
    this.malware,
    this.network,
    this.networkPath,
    this.note,
    this.patchSummary,
    this.process,
    this.processedAt,
    this.productFields,
    this.productName,
    this.recordState,
    this.region,
    this.relatedFindings,
    this.remediation,
    this.sample,
    this.severity,
    this.sourceUrl,
    this.threatIntelIndicators,
    this.threats,
    this.types,
    this.userDefinedFields,
    this.verificationState,
    this.vulnerabilities,
    this.workflow,
    this.workflowState,
  });

  factory AwsSecurityFinding.fromJson(Map<String, dynamic> json) {
    return AwsSecurityFinding(
      awsAccountId: json['AwsAccountId'] as String,
      createdAt: json['CreatedAt'] as String,
      description: json['Description'] as String,
      generatorId: json['GeneratorId'] as String,
      id: json['Id'] as String,
      productArn: json['ProductArn'] as String,
      resources: (json['Resources'] as List)
          .whereNotNull()
          .map((e) => Resource.fromJson(e as Map<String, dynamic>))
          .toList(),
      schemaVersion: json['SchemaVersion'] as String,
      title: json['Title'] as String,
      updatedAt: json['UpdatedAt'] as String,
      action: json['Action'] != null
          ? Action.fromJson(json['Action'] as Map<String, dynamic>)
          : null,
      awsAccountName: json['AwsAccountName'] as String?,
      companyName: json['CompanyName'] as String?,
      compliance: json['Compliance'] != null
          ? Compliance.fromJson(json['Compliance'] as Map<String, dynamic>)
          : null,
      confidence: json['Confidence'] as int?,
      criticality: json['Criticality'] as int?,
      findingProviderFields: json['FindingProviderFields'] != null
          ? FindingProviderFields.fromJson(
              json['FindingProviderFields'] as Map<String, dynamic>)
          : null,
      firstObservedAt: json['FirstObservedAt'] as String?,
      generatorDetails: json['GeneratorDetails'] != null
          ? GeneratorDetails.fromJson(
              json['GeneratorDetails'] as Map<String, dynamic>)
          : null,
      lastObservedAt: json['LastObservedAt'] as String?,
      malware: (json['Malware'] as List?)
          ?.whereNotNull()
          .map((e) => Malware.fromJson(e as Map<String, dynamic>))
          .toList(),
      network: json['Network'] != null
          ? Network.fromJson(json['Network'] as Map<String, dynamic>)
          : null,
      networkPath: (json['NetworkPath'] as List?)
          ?.whereNotNull()
          .map((e) => NetworkPathComponent.fromJson(e as Map<String, dynamic>))
          .toList(),
      note: json['Note'] != null
          ? Note.fromJson(json['Note'] as Map<String, dynamic>)
          : null,
      patchSummary: json['PatchSummary'] != null
          ? PatchSummary.fromJson(json['PatchSummary'] as Map<String, dynamic>)
          : null,
      process: json['Process'] != null
          ? ProcessDetails.fromJson(json['Process'] as Map<String, dynamic>)
          : null,
      processedAt: json['ProcessedAt'] as String?,
      productFields: (json['ProductFields'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      productName: json['ProductName'] as String?,
      recordState: (json['RecordState'] as String?)?.toRecordState(),
      region: json['Region'] as String?,
      relatedFindings: (json['RelatedFindings'] as List?)
          ?.whereNotNull()
          .map((e) => RelatedFinding.fromJson(e as Map<String, dynamic>))
          .toList(),
      remediation: json['Remediation'] != null
          ? Remediation.fromJson(json['Remediation'] as Map<String, dynamic>)
          : null,
      sample: json['Sample'] as bool?,
      severity: json['Severity'] != null
          ? Severity.fromJson(json['Severity'] as Map<String, dynamic>)
          : null,
      sourceUrl: json['SourceUrl'] as String?,
      threatIntelIndicators: (json['ThreatIntelIndicators'] as List?)
          ?.whereNotNull()
          .map((e) => ThreatIntelIndicator.fromJson(e as Map<String, dynamic>))
          .toList(),
      threats: (json['Threats'] as List?)
          ?.whereNotNull()
          .map((e) => Threat.fromJson(e as Map<String, dynamic>))
          .toList(),
      types: (json['Types'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      userDefinedFields: (json['UserDefinedFields'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      verificationState:
          (json['VerificationState'] as String?)?.toVerificationState(),
      vulnerabilities: (json['Vulnerabilities'] as List?)
          ?.whereNotNull()
          .map((e) => Vulnerability.fromJson(e as Map<String, dynamic>))
          .toList(),
      workflow: json['Workflow'] != null
          ? Workflow.fromJson(json['Workflow'] as Map<String, dynamic>)
          : null,
      workflowState: (json['WorkflowState'] as String?)?.toWorkflowState(),
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final createdAt = this.createdAt;
    final description = this.description;
    final generatorId = this.generatorId;
    final id = this.id;
    final productArn = this.productArn;
    final resources = this.resources;
    final schemaVersion = this.schemaVersion;
    final title = this.title;
    final updatedAt = this.updatedAt;
    final action = this.action;
    final awsAccountName = this.awsAccountName;
    final companyName = this.companyName;
    final compliance = this.compliance;
    final confidence = this.confidence;
    final criticality = this.criticality;
    final findingProviderFields = this.findingProviderFields;
    final firstObservedAt = this.firstObservedAt;
    final generatorDetails = this.generatorDetails;
    final lastObservedAt = this.lastObservedAt;
    final malware = this.malware;
    final network = this.network;
    final networkPath = this.networkPath;
    final note = this.note;
    final patchSummary = this.patchSummary;
    final process = this.process;
    final processedAt = this.processedAt;
    final productFields = this.productFields;
    final productName = this.productName;
    final recordState = this.recordState;
    final region = this.region;
    final relatedFindings = this.relatedFindings;
    final remediation = this.remediation;
    final sample = this.sample;
    final severity = this.severity;
    final sourceUrl = this.sourceUrl;
    final threatIntelIndicators = this.threatIntelIndicators;
    final threats = this.threats;
    final types = this.types;
    final userDefinedFields = this.userDefinedFields;
    final verificationState = this.verificationState;
    final vulnerabilities = this.vulnerabilities;
    final workflow = this.workflow;
    final workflowState = this.workflowState;
    return {
      'AwsAccountId': awsAccountId,
      'CreatedAt': createdAt,
      'Description': description,
      'GeneratorId': generatorId,
      'Id': id,
      'ProductArn': productArn,
      'Resources': resources,
      'SchemaVersion': schemaVersion,
      'Title': title,
      'UpdatedAt': updatedAt,
      if (action != null) 'Action': action,
      if (awsAccountName != null) 'AwsAccountName': awsAccountName,
      if (companyName != null) 'CompanyName': companyName,
      if (compliance != null) 'Compliance': compliance,
      if (confidence != null) 'Confidence': confidence,
      if (criticality != null) 'Criticality': criticality,
      if (findingProviderFields != null)
        'FindingProviderFields': findingProviderFields,
      if (firstObservedAt != null) 'FirstObservedAt': firstObservedAt,
      if (generatorDetails != null) 'GeneratorDetails': generatorDetails,
      if (lastObservedAt != null) 'LastObservedAt': lastObservedAt,
      if (malware != null) 'Malware': malware,
      if (network != null) 'Network': network,
      if (networkPath != null) 'NetworkPath': networkPath,
      if (note != null) 'Note': note,
      if (patchSummary != null) 'PatchSummary': patchSummary,
      if (process != null) 'Process': process,
      if (processedAt != null) 'ProcessedAt': processedAt,
      if (productFields != null) 'ProductFields': productFields,
      if (productName != null) 'ProductName': productName,
      if (recordState != null) 'RecordState': recordState.toValue(),
      if (region != null) 'Region': region,
      if (relatedFindings != null) 'RelatedFindings': relatedFindings,
      if (remediation != null) 'Remediation': remediation,
      if (sample != null) 'Sample': sample,
      if (severity != null) 'Severity': severity,
      if (sourceUrl != null) 'SourceUrl': sourceUrl,
      if (threatIntelIndicators != null)
        'ThreatIntelIndicators': threatIntelIndicators,
      if (threats != null) 'Threats': threats,
      if (types != null) 'Types': types,
      if (userDefinedFields != null) 'UserDefinedFields': userDefinedFields,
      if (verificationState != null)
        'VerificationState': verificationState.toValue(),
      if (vulnerabilities != null) 'Vulnerabilities': vulnerabilities,
      if (workflow != null) 'Workflow': workflow,
      if (workflowState != null) 'WorkflowState': workflowState.toValue(),
    };
  }
}

/// A collection of filters that are applied to all active findings aggregated
/// by Security Hub.
///
/// You can filter by up to ten finding attributes. For each attribute, you can
/// provide up to 20 filter values.
class AwsSecurityFindingFilters {
  /// The Amazon Web Services account ID in which a finding is generated.
  final List<StringFilter>? awsAccountId;

  /// The name of the Amazon Web Services account in which a finding is generated.
  final List<StringFilter>? awsAccountName;

  /// The name of the findings provider (company) that owns the solution (product)
  /// that generates findings.
  final List<StringFilter>? companyName;

  /// The unique identifier of a standard in which a control is enabled. This
  /// field consists of the resource portion of the Amazon Resource Name (ARN)
  /// returned for a standard in the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_DescribeStandards.html">DescribeStandards</a>
  /// API response.
  final List<StringFilter>? complianceAssociatedStandardsId;

  /// The unique identifier of a control across standards. Values for this field
  /// typically consist of an Amazon Web Service and a number, such as
  /// APIGateway.5.
  final List<StringFilter>? complianceSecurityControlId;

  /// The name of a security control parameter.
  final List<StringFilter>? complianceSecurityControlParametersName;

  /// The current value of a security control parameter.
  final List<StringFilter>? complianceSecurityControlParametersValue;

  /// Exclusive to findings that are generated as the result of a check run
  /// against a specific rule in a supported standard, such as CIS Amazon Web
  /// Services Foundations. Contains security standard-related finding details.
  final List<StringFilter>? complianceStatus;

  /// A finding's confidence. Confidence is defined as the likelihood that a
  /// finding accurately identifies the behavior or issue that it was intended to
  /// identify.
  ///
  /// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
  /// zero percent confidence and 100 means 100 percent confidence.
  final List<NumberFilter>? confidence;

  /// A timestamp that indicates when the security findings provider created the
  /// potential security issue that a finding reflects.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? createdAt;

  /// The level of importance assigned to the resources associated with the
  /// finding.
  ///
  /// A score of 0 means that the underlying resources have no criticality, and a
  /// score of 100 is reserved for the most critical resources.
  final List<NumberFilter>? criticality;

  /// A finding's description.
  final List<StringFilter>? description;

  /// The finding provider value for the finding confidence. Confidence is defined
  /// as the likelihood that a finding accurately identifies the behavior or issue
  /// that it was intended to identify.
  ///
  /// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
  /// zero percent confidence and 100 means 100 percent confidence.
  final List<NumberFilter>? findingProviderFieldsConfidence;

  /// The finding provider value for the level of importance assigned to the
  /// resources associated with the findings.
  ///
  /// A score of 0 means that the underlying resources have no criticality, and a
  /// score of 100 is reserved for the most critical resources.
  final List<NumberFilter>? findingProviderFieldsCriticality;

  /// The finding identifier of a related finding that is identified by the
  /// finding provider.
  final List<StringFilter>? findingProviderFieldsRelatedFindingsId;

  /// The ARN of the solution that generated a related finding that is identified
  /// by the finding provider.
  final List<StringFilter>? findingProviderFieldsRelatedFindingsProductArn;

  /// The finding provider value for the severity label.
  final List<StringFilter>? findingProviderFieldsSeverityLabel;

  /// The finding provider's original value for the severity.
  final List<StringFilter>? findingProviderFieldsSeverityOriginal;

  /// One or more finding types that the finding provider assigned to the finding.
  /// Uses the format of <code>namespace/category/classifier</code> that classify
  /// a finding.
  ///
  /// Valid namespace values are: Software and Configuration Checks | TTPs |
  /// Effects | Unusual Behaviors | Sensitive Data Identifications
  final List<StringFilter>? findingProviderFieldsTypes;

  /// A timestamp that indicates when the security findings provider first
  /// observed the potential security issue that a finding captured.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? firstObservedAt;

  /// The identifier for the solution-specific component (a discrete unit of
  /// logic) that generated a finding. In various security findings providers'
  /// solutions, this generator can be called a rule, a check, a detector, a
  /// plugin, etc.
  final List<StringFilter>? generatorId;

  /// The security findings provider-specific identifier for a finding.
  final List<StringFilter>? id;

  /// A keyword for a finding.
  final List<KeywordFilter>? keyword;

  /// A timestamp that indicates when the security findings provider most recently
  /// observed the potential security issue that a finding captured.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? lastObservedAt;

  /// The name of the malware that was observed.
  final List<StringFilter>? malwareName;

  /// The filesystem path of the malware that was observed.
  final List<StringFilter>? malwarePath;

  /// The state of the malware that was observed.
  final List<StringFilter>? malwareState;

  /// The type of the malware that was observed.
  final List<StringFilter>? malwareType;

  /// The destination domain of network-related information about a finding.
  final List<StringFilter>? networkDestinationDomain;

  /// The destination IPv4 address of network-related information about a finding.
  final List<IpFilter>? networkDestinationIpV4;

  /// The destination IPv6 address of network-related information about a finding.
  final List<IpFilter>? networkDestinationIpV6;

  /// The destination port of network-related information about a finding.
  final List<NumberFilter>? networkDestinationPort;

  /// Indicates the direction of network traffic associated with a finding.
  final List<StringFilter>? networkDirection;

  /// The protocol of network-related information about a finding.
  final List<StringFilter>? networkProtocol;

  /// The source domain of network-related information about a finding.
  final List<StringFilter>? networkSourceDomain;

  /// The source IPv4 address of network-related information about a finding.
  final List<IpFilter>? networkSourceIpV4;

  /// The source IPv6 address of network-related information about a finding.
  final List<IpFilter>? networkSourceIpV6;

  /// The source media access control (MAC) address of network-related information
  /// about a finding.
  final List<StringFilter>? networkSourceMac;

  /// The source port of network-related information about a finding.
  final List<NumberFilter>? networkSourcePort;

  /// The text of a note.
  final List<StringFilter>? noteText;

  /// The timestamp of when the note was updated.
  final List<DateFilter>? noteUpdatedAt;

  /// The principal that created a note.
  final List<StringFilter>? noteUpdatedBy;

  /// A timestamp that identifies when the process was launched.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? processLaunchedAt;

  /// The name of the process.
  final List<StringFilter>? processName;

  /// The parent process ID. This field accepts positive integers between
  /// <code>O</code> and <code>2147483647</code>.
  final List<NumberFilter>? processParentPid;

  /// The path to the process executable.
  final List<StringFilter>? processPath;

  /// The process ID.
  final List<NumberFilter>? processPid;

  /// A timestamp that identifies when the process was terminated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? processTerminatedAt;

  /// The ARN generated by Security Hub that uniquely identifies a third-party
  /// company (security findings provider) after this provider's product (solution
  /// that generates findings) is registered with Security Hub.
  final List<StringFilter>? productArn;

  /// A data type where security findings providers can include additional
  /// solution-specific details that aren't part of the defined
  /// <code>AwsSecurityFinding</code> format.
  final List<MapFilter>? productFields;

  /// The name of the solution (product) that generates findings.
  final List<StringFilter>? productName;

  /// The recommendation of what to do about the issue described in a finding.
  final List<StringFilter>? recommendationText;

  /// The updated record state for the finding.
  final List<StringFilter>? recordState;

  /// The Region from which the finding was generated.
  final List<StringFilter>? region;

  /// The solution-generated identifier for a related finding.
  final List<StringFilter>? relatedFindingsId;

  /// The ARN of the solution that generated a related finding.
  final List<StringFilter>? relatedFindingsProductArn;

  /// The ARN of the application that is related to a finding.
  final List<StringFilter>? resourceApplicationArn;

  /// The name of the application that is related to a finding.
  final List<StringFilter>? resourceApplicationName;

  /// The IAM profile ARN of the instance.
  final List<StringFilter>? resourceAwsEc2InstanceIamInstanceProfileArn;

  /// The Amazon Machine Image (AMI) ID of the instance.
  final List<StringFilter>? resourceAwsEc2InstanceImageId;

  /// The IPv4 addresses associated with the instance.
  final List<IpFilter>? resourceAwsEc2InstanceIpV4Addresses;

  /// The IPv6 addresses associated with the instance.
  final List<IpFilter>? resourceAwsEc2InstanceIpV6Addresses;

  /// The key name associated with the instance.
  final List<StringFilter>? resourceAwsEc2InstanceKeyName;

  /// The date and time the instance was launched.
  final List<DateFilter>? resourceAwsEc2InstanceLaunchedAt;

  /// The identifier of the subnet that the instance was launched in.
  final List<StringFilter>? resourceAwsEc2InstanceSubnetId;

  /// The instance type of the instance.
  final List<StringFilter>? resourceAwsEc2InstanceType;

  /// The identifier of the VPC that the instance was launched in.
  final List<StringFilter>? resourceAwsEc2InstanceVpcId;

  /// The creation date/time of the IAM access key related to a finding.
  final List<DateFilter>? resourceAwsIamAccessKeyCreatedAt;

  /// The name of the principal that is associated with an IAM access key.
  final List<StringFilter>? resourceAwsIamAccessKeyPrincipalName;

  /// The status of the IAM access key related to a finding.
  final List<StringFilter>? resourceAwsIamAccessKeyStatus;

  /// The user associated with the IAM access key related to a finding.
  final List<StringFilter>? resourceAwsIamAccessKeyUserName;

  /// The name of an IAM user.
  final List<StringFilter>? resourceAwsIamUserUserName;

  /// The canonical user ID of the owner of the S3 bucket.
  final List<StringFilter>? resourceAwsS3BucketOwnerId;

  /// The display name of the owner of the S3 bucket.
  final List<StringFilter>? resourceAwsS3BucketOwnerName;

  /// The identifier of the image related to a finding.
  final List<StringFilter>? resourceContainerImageId;

  /// The name of the image related to a finding.
  final List<StringFilter>? resourceContainerImageName;

  /// A timestamp that identifies when the container was started.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? resourceContainerLaunchedAt;

  /// The name of the container related to a finding.
  final List<StringFilter>? resourceContainerName;

  /// The details of a resource that doesn't have a specific subfield for the
  /// resource type defined.
  final List<MapFilter>? resourceDetailsOther;

  /// The canonical identifier for the given resource type.
  final List<StringFilter>? resourceId;

  /// The canonical Amazon Web Services partition name that the Region is assigned
  /// to.
  final List<StringFilter>? resourcePartition;

  /// The canonical Amazon Web Services external Region name where this resource
  /// is located.
  final List<StringFilter>? resourceRegion;

  /// A list of Amazon Web Services tags associated with a resource at the time
  /// the finding was processed.
  final List<MapFilter>? resourceTags;

  /// Specifies the type of the resource that details are provided for.
  final List<StringFilter>? resourceType;

  /// Indicates whether or not sample findings are included in the filter results.
  final List<BooleanFilter>? sample;

  /// The label of a finding's severity.
  final List<StringFilter>? severityLabel;

  /// The normalized severity of a finding.
  final List<NumberFilter>? severityNormalized;

  /// The native severity as defined by the security findings provider's solution
  /// that generated the finding.
  final List<NumberFilter>? severityProduct;

  /// A URL that links to a page about the current finding in the security
  /// findings provider's solution.
  final List<StringFilter>? sourceUrl;

  /// The category of a threat intelligence indicator.
  final List<StringFilter>? threatIntelIndicatorCategory;

  /// A timestamp that identifies the last observation of a threat intelligence
  /// indicator.
  final List<DateFilter>? threatIntelIndicatorLastObservedAt;

  /// The source of the threat intelligence.
  final List<StringFilter>? threatIntelIndicatorSource;

  /// The URL for more details from the source of the threat intelligence.
  final List<StringFilter>? threatIntelIndicatorSourceUrl;

  /// The type of a threat intelligence indicator.
  final List<StringFilter>? threatIntelIndicatorType;

  /// The value of a threat intelligence indicator.
  final List<StringFilter>? threatIntelIndicatorValue;

  /// A finding's title.
  final List<StringFilter>? title;

  /// A finding type in the format of <code>namespace/category/classifier</code>
  /// that classifies a finding.
  final List<StringFilter>? type;

  /// A timestamp that indicates when the security findings provider last updated
  /// the finding record.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final List<DateFilter>? updatedAt;

  /// A list of name/value string pairs associated with the finding. These are
  /// custom, user-defined fields added to a finding.
  final List<MapFilter>? userDefinedFields;

  /// The veracity of a finding.
  final List<StringFilter>? verificationState;

  /// Indicates whether a software vulnerability in your environment has a known
  /// exploit. You can filter findings by this field only if you use Security Hub
  /// and Amazon Inspector.
  final List<StringFilter>? vulnerabilitiesExploitAvailable;

  /// Indicates whether a vulnerability is fixed in a newer version of the
  /// affected software packages. You can filter findings by this field only if
  /// you use Security Hub and Amazon Inspector.
  final List<StringFilter>? vulnerabilitiesFixAvailable;

  /// The workflow state of a finding.
  ///
  /// Note that this field is deprecated. To search for a finding based on its
  /// workflow status, use <code>WorkflowStatus</code>.
  final List<StringFilter>? workflowState;

  /// The status of the investigation into a finding. Allowed values are the
  /// following.
  ///
  /// <ul>
  /// <li>
  /// <code>NEW</code> - The initial state of a finding, before it is reviewed.
  ///
  /// Security Hub also resets the workflow status from <code>NOTIFIED</code> or
  /// <code>RESOLVED</code> to <code>NEW</code> in the following cases:
  ///
  /// <ul>
  /// <li>
  /// <code>RecordState</code> changes from <code>ARCHIVED</code> to
  /// <code>ACTIVE</code>.
  /// </li>
  /// <li>
  /// <code>Compliance.Status</code> changes from <code>PASSED</code> to either
  /// <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>NOTIFIED</code> - Indicates that the resource owner has been notified
  /// about the security issue. Used when the initial reviewer is not the resource
  /// owner, and needs intervention from the resource owner.
  ///
  /// If one of the following occurs, the workflow status is changed automatically
  /// from <code>NOTIFIED</code> to <code>NEW</code>:
  ///
  /// <ul>
  /// <li>
  /// <code>RecordState</code> changes from <code>ARCHIVED</code> to
  /// <code>ACTIVE</code>.
  /// </li>
  /// <li>
  /// <code>Compliance.Status</code> changes from <code>PASSED</code> to
  /// <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not
  /// believe that any action is needed.
  ///
  /// The workflow status of a <code>SUPPRESSED</code> finding does not change if
  /// <code>RecordState</code> changes from <code>ARCHIVED</code> to
  /// <code>ACTIVE</code>.
  /// </li>
  /// <li>
  /// <code>RESOLVED</code> - The finding was reviewed and remediated and is now
  /// considered resolved.
  ///
  /// The finding remains <code>RESOLVED</code> unless one of the following
  /// occurs:
  ///
  /// <ul>
  /// <li>
  /// <code>RecordState</code> changes from <code>ARCHIVED</code> to
  /// <code>ACTIVE</code>.
  /// </li>
  /// <li>
  /// <code>Compliance.Status</code> changes from <code>PASSED</code> to
  /// <code>FAILED</code>, <code>WARNING</code>, or <code>NOT_AVAILABLE</code>.
  /// </li>
  /// </ul>
  /// In those cases, the workflow status is automatically reset to
  /// <code>NEW</code>.
  ///
  /// For findings from controls, if <code>Compliance.Status</code> is
  /// <code>PASSED</code>, then Security Hub automatically sets the workflow
  /// status to <code>RESOLVED</code>.
  /// </li>
  /// </ul>
  final List<StringFilter>? workflowStatus;

  AwsSecurityFindingFilters({
    this.awsAccountId,
    this.awsAccountName,
    this.companyName,
    this.complianceAssociatedStandardsId,
    this.complianceSecurityControlId,
    this.complianceSecurityControlParametersName,
    this.complianceSecurityControlParametersValue,
    this.complianceStatus,
    this.confidence,
    this.createdAt,
    this.criticality,
    this.description,
    this.findingProviderFieldsConfidence,
    this.findingProviderFieldsCriticality,
    this.findingProviderFieldsRelatedFindingsId,
    this.findingProviderFieldsRelatedFindingsProductArn,
    this.findingProviderFieldsSeverityLabel,
    this.findingProviderFieldsSeverityOriginal,
    this.findingProviderFieldsTypes,
    this.firstObservedAt,
    this.generatorId,
    this.id,
    this.keyword,
    this.lastObservedAt,
    this.malwareName,
    this.malwarePath,
    this.malwareState,
    this.malwareType,
    this.networkDestinationDomain,
    this.networkDestinationIpV4,
    this.networkDestinationIpV6,
    this.networkDestinationPort,
    this.networkDirection,
    this.networkProtocol,
    this.networkSourceDomain,
    this.networkSourceIpV4,
    this.networkSourceIpV6,
    this.networkSourceMac,
    this.networkSourcePort,
    this.noteText,
    this.noteUpdatedAt,
    this.noteUpdatedBy,
    this.processLaunchedAt,
    this.processName,
    this.processParentPid,
    this.processPath,
    this.processPid,
    this.processTerminatedAt,
    this.productArn,
    this.productFields,
    this.productName,
    this.recommendationText,
    this.recordState,
    this.region,
    this.relatedFindingsId,
    this.relatedFindingsProductArn,
    this.resourceApplicationArn,
    this.resourceApplicationName,
    this.resourceAwsEc2InstanceIamInstanceProfileArn,
    this.resourceAwsEc2InstanceImageId,
    this.resourceAwsEc2InstanceIpV4Addresses,
    this.resourceAwsEc2InstanceIpV6Addresses,
    this.resourceAwsEc2InstanceKeyName,
    this.resourceAwsEc2InstanceLaunchedAt,
    this.resourceAwsEc2InstanceSubnetId,
    this.resourceAwsEc2InstanceType,
    this.resourceAwsEc2InstanceVpcId,
    this.resourceAwsIamAccessKeyCreatedAt,
    this.resourceAwsIamAccessKeyPrincipalName,
    this.resourceAwsIamAccessKeyStatus,
    this.resourceAwsIamAccessKeyUserName,
    this.resourceAwsIamUserUserName,
    this.resourceAwsS3BucketOwnerId,
    this.resourceAwsS3BucketOwnerName,
    this.resourceContainerImageId,
    this.resourceContainerImageName,
    this.resourceContainerLaunchedAt,
    this.resourceContainerName,
    this.resourceDetailsOther,
    this.resourceId,
    this.resourcePartition,
    this.resourceRegion,
    this.resourceTags,
    this.resourceType,
    this.sample,
    this.severityLabel,
    this.severityNormalized,
    this.severityProduct,
    this.sourceUrl,
    this.threatIntelIndicatorCategory,
    this.threatIntelIndicatorLastObservedAt,
    this.threatIntelIndicatorSource,
    this.threatIntelIndicatorSourceUrl,
    this.threatIntelIndicatorType,
    this.threatIntelIndicatorValue,
    this.title,
    this.type,
    this.updatedAt,
    this.userDefinedFields,
    this.verificationState,
    this.vulnerabilitiesExploitAvailable,
    this.vulnerabilitiesFixAvailable,
    this.workflowState,
    this.workflowStatus,
  });

  factory AwsSecurityFindingFilters.fromJson(Map<String, dynamic> json) {
    return AwsSecurityFindingFilters(
      awsAccountId: (json['AwsAccountId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      awsAccountName: (json['AwsAccountName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      companyName: (json['CompanyName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      complianceAssociatedStandardsId:
          (json['ComplianceAssociatedStandardsId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      complianceSecurityControlId:
          (json['ComplianceSecurityControlId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      complianceSecurityControlParametersName:
          (json['ComplianceSecurityControlParametersName'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      complianceSecurityControlParametersValue:
          (json['ComplianceSecurityControlParametersValue'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      complianceStatus: (json['ComplianceStatus'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      confidence: (json['Confidence'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: (json['CreatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      criticality: (json['Criticality'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      description: (json['Description'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      findingProviderFieldsConfidence:
          (json['FindingProviderFieldsConfidence'] as List?)
              ?.whereNotNull()
              .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      findingProviderFieldsCriticality:
          (json['FindingProviderFieldsCriticality'] as List?)
              ?.whereNotNull()
              .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      findingProviderFieldsRelatedFindingsId:
          (json['FindingProviderFieldsRelatedFindingsId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      findingProviderFieldsRelatedFindingsProductArn:
          (json['FindingProviderFieldsRelatedFindingsProductArn'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      findingProviderFieldsSeverityLabel:
          (json['FindingProviderFieldsSeverityLabel'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      findingProviderFieldsSeverityOriginal:
          (json['FindingProviderFieldsSeverityOriginal'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      findingProviderFieldsTypes: (json['FindingProviderFieldsTypes'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      firstObservedAt: (json['FirstObservedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      generatorId: (json['GeneratorId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      id: (json['Id'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      keyword: (json['Keyword'] as List?)
          ?.whereNotNull()
          .map((e) => KeywordFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      lastObservedAt: (json['LastObservedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      malwareName: (json['MalwareName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      malwarePath: (json['MalwarePath'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      malwareState: (json['MalwareState'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      malwareType: (json['MalwareType'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkDestinationDomain: (json['NetworkDestinationDomain'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkDestinationIpV4: (json['NetworkDestinationIpV4'] as List?)
          ?.whereNotNull()
          .map((e) => IpFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkDestinationIpV6: (json['NetworkDestinationIpV6'] as List?)
          ?.whereNotNull()
          .map((e) => IpFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkDestinationPort: (json['NetworkDestinationPort'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkDirection: (json['NetworkDirection'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkProtocol: (json['NetworkProtocol'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkSourceDomain: (json['NetworkSourceDomain'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkSourceIpV4: (json['NetworkSourceIpV4'] as List?)
          ?.whereNotNull()
          .map((e) => IpFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkSourceIpV6: (json['NetworkSourceIpV6'] as List?)
          ?.whereNotNull()
          .map((e) => IpFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkSourceMac: (json['NetworkSourceMac'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      networkSourcePort: (json['NetworkSourcePort'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      noteText: (json['NoteText'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      noteUpdatedAt: (json['NoteUpdatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      noteUpdatedBy: (json['NoteUpdatedBy'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      processLaunchedAt: (json['ProcessLaunchedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      processName: (json['ProcessName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      processParentPid: (json['ProcessParentPid'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      processPath: (json['ProcessPath'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      processPid: (json['ProcessPid'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      processTerminatedAt: (json['ProcessTerminatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      productArn: (json['ProductArn'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      productFields: (json['ProductFields'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      productName: (json['ProductName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      recommendationText: (json['RecommendationText'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      recordState: (json['RecordState'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      region: (json['Region'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      relatedFindingsId: (json['RelatedFindingsId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      relatedFindingsProductArn: (json['RelatedFindingsProductArn'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceApplicationArn: (json['ResourceApplicationArn'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceApplicationName: (json['ResourceApplicationName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceAwsEc2InstanceIamInstanceProfileArn:
          (json['ResourceAwsEc2InstanceIamInstanceProfileArn'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceImageId:
          (json['ResourceAwsEc2InstanceImageId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceIpV4Addresses:
          (json['ResourceAwsEc2InstanceIpV4Addresses'] as List?)
              ?.whereNotNull()
              .map((e) => IpFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceIpV6Addresses:
          (json['ResourceAwsEc2InstanceIpV6Addresses'] as List?)
              ?.whereNotNull()
              .map((e) => IpFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceKeyName:
          (json['ResourceAwsEc2InstanceKeyName'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceLaunchedAt:
          (json['ResourceAwsEc2InstanceLaunchedAt'] as List?)
              ?.whereNotNull()
              .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceSubnetId:
          (json['ResourceAwsEc2InstanceSubnetId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsEc2InstanceType: (json['ResourceAwsEc2InstanceType'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceAwsEc2InstanceVpcId:
          (json['ResourceAwsEc2InstanceVpcId'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsIamAccessKeyCreatedAt:
          (json['ResourceAwsIamAccessKeyCreatedAt'] as List?)
              ?.whereNotNull()
              .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsIamAccessKeyPrincipalName:
          (json['ResourceAwsIamAccessKeyPrincipalName'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsIamAccessKeyStatus:
          (json['ResourceAwsIamAccessKeyStatus'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsIamAccessKeyUserName:
          (json['ResourceAwsIamAccessKeyUserName'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceAwsIamUserUserName: (json['ResourceAwsIamUserUserName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceAwsS3BucketOwnerId: (json['ResourceAwsS3BucketOwnerId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceAwsS3BucketOwnerName:
          (json['ResourceAwsS3BucketOwnerName'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceContainerImageId: (json['ResourceContainerImageId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceContainerImageName: (json['ResourceContainerImageName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceContainerLaunchedAt:
          (json['ResourceContainerLaunchedAt'] as List?)
              ?.whereNotNull()
              .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      resourceContainerName: (json['ResourceContainerName'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceDetailsOther: (json['ResourceDetailsOther'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceId: (json['ResourceId'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourcePartition: (json['ResourcePartition'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceRegion: (json['ResourceRegion'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceTags: (json['ResourceTags'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceType: (json['ResourceType'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      sample: (json['Sample'] as List?)
          ?.whereNotNull()
          .map((e) => BooleanFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      severityLabel: (json['SeverityLabel'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      severityNormalized: (json['SeverityNormalized'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      severityProduct: (json['SeverityProduct'] as List?)
          ?.whereNotNull()
          .map((e) => NumberFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      sourceUrl: (json['SourceUrl'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      threatIntelIndicatorCategory:
          (json['ThreatIntelIndicatorCategory'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      threatIntelIndicatorLastObservedAt:
          (json['ThreatIntelIndicatorLastObservedAt'] as List?)
              ?.whereNotNull()
              .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      threatIntelIndicatorSource: (json['ThreatIntelIndicatorSource'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      threatIntelIndicatorSourceUrl:
          (json['ThreatIntelIndicatorSourceUrl'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      threatIntelIndicatorType: (json['ThreatIntelIndicatorType'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      threatIntelIndicatorValue: (json['ThreatIntelIndicatorValue'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      title: (json['Title'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      type: (json['Type'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      updatedAt: (json['UpdatedAt'] as List?)
          ?.whereNotNull()
          .map((e) => DateFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      userDefinedFields: (json['UserDefinedFields'] as List?)
          ?.whereNotNull()
          .map((e) => MapFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      verificationState: (json['VerificationState'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      vulnerabilitiesExploitAvailable:
          (json['VulnerabilitiesExploitAvailable'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      vulnerabilitiesFixAvailable:
          (json['VulnerabilitiesFixAvailable'] as List?)
              ?.whereNotNull()
              .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
              .toList(),
      workflowState: (json['WorkflowState'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      workflowStatus: (json['WorkflowStatus'] as List?)
          ?.whereNotNull()
          .map((e) => StringFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final awsAccountName = this.awsAccountName;
    final companyName = this.companyName;
    final complianceAssociatedStandardsId =
        this.complianceAssociatedStandardsId;
    final complianceSecurityControlId = this.complianceSecurityControlId;
    final complianceSecurityControlParametersName =
        this.complianceSecurityControlParametersName;
    final complianceSecurityControlParametersValue =
        this.complianceSecurityControlParametersValue;
    final complianceStatus = this.complianceStatus;
    final confidence = this.confidence;
    final createdAt = this.createdAt;
    final criticality = this.criticality;
    final description = this.description;
    final findingProviderFieldsConfidence =
        this.findingProviderFieldsConfidence;
    final findingProviderFieldsCriticality =
        this.findingProviderFieldsCriticality;
    final findingProviderFieldsRelatedFindingsId =
        this.findingProviderFieldsRelatedFindingsId;
    final findingProviderFieldsRelatedFindingsProductArn =
        this.findingProviderFieldsRelatedFindingsProductArn;
    final findingProviderFieldsSeverityLabel =
        this.findingProviderFieldsSeverityLabel;
    final findingProviderFieldsSeverityOriginal =
        this.findingProviderFieldsSeverityOriginal;
    final findingProviderFieldsTypes = this.findingProviderFieldsTypes;
    final firstObservedAt = this.firstObservedAt;
    final generatorId = this.generatorId;
    final id = this.id;
    final keyword = this.keyword;
    final lastObservedAt = this.lastObservedAt;
    final malwareName = this.malwareName;
    final malwarePath = this.malwarePath;
    final malwareState = this.malwareState;
    final malwareType = this.malwareType;
    final networkDestinationDomain = this.networkDestinationDomain;
    final networkDestinationIpV4 = this.networkDestinationIpV4;
    final networkDestinationIpV6 = this.networkDestinationIpV6;
    final networkDestinationPort = this.networkDestinationPort;
    final networkDirection = this.networkDirection;
    final networkProtocol = this.networkProtocol;
    final networkSourceDomain = this.networkSourceDomain;
    final networkSourceIpV4 = this.networkSourceIpV4;
    final networkSourceIpV6 = this.networkSourceIpV6;
    final networkSourceMac = this.networkSourceMac;
    final networkSourcePort = this.networkSourcePort;
    final noteText = this.noteText;
    final noteUpdatedAt = this.noteUpdatedAt;
    final noteUpdatedBy = this.noteUpdatedBy;
    final processLaunchedAt = this.processLaunchedAt;
    final processName = this.processName;
    final processParentPid = this.processParentPid;
    final processPath = this.processPath;
    final processPid = this.processPid;
    final processTerminatedAt = this.processTerminatedAt;
    final productArn = this.productArn;
    final productFields = this.productFields;
    final productName = this.productName;
    final recommendationText = this.recommendationText;
    final recordState = this.recordState;
    final region = this.region;
    final relatedFindingsId = this.relatedFindingsId;
    final relatedFindingsProductArn = this.relatedFindingsProductArn;
    final resourceApplicationArn = this.resourceApplicationArn;
    final resourceApplicationName = this.resourceApplicationName;
    final resourceAwsEc2InstanceIamInstanceProfileArn =
        this.resourceAwsEc2InstanceIamInstanceProfileArn;
    final resourceAwsEc2InstanceImageId = this.resourceAwsEc2InstanceImageId;
    final resourceAwsEc2InstanceIpV4Addresses =
        this.resourceAwsEc2InstanceIpV4Addresses;
    final resourceAwsEc2InstanceIpV6Addresses =
        this.resourceAwsEc2InstanceIpV6Addresses;
    final resourceAwsEc2InstanceKeyName = this.resourceAwsEc2InstanceKeyName;
    final resourceAwsEc2InstanceLaunchedAt =
        this.resourceAwsEc2InstanceLaunchedAt;
    final resourceAwsEc2InstanceSubnetId = this.resourceAwsEc2InstanceSubnetId;
    final resourceAwsEc2InstanceType = this.resourceAwsEc2InstanceType;
    final resourceAwsEc2InstanceVpcId = this.resourceAwsEc2InstanceVpcId;
    final resourceAwsIamAccessKeyCreatedAt =
        this.resourceAwsIamAccessKeyCreatedAt;
    final resourceAwsIamAccessKeyPrincipalName =
        this.resourceAwsIamAccessKeyPrincipalName;
    final resourceAwsIamAccessKeyStatus = this.resourceAwsIamAccessKeyStatus;
    final resourceAwsIamAccessKeyUserName =
        this.resourceAwsIamAccessKeyUserName;
    final resourceAwsIamUserUserName = this.resourceAwsIamUserUserName;
    final resourceAwsS3BucketOwnerId = this.resourceAwsS3BucketOwnerId;
    final resourceAwsS3BucketOwnerName = this.resourceAwsS3BucketOwnerName;
    final resourceContainerImageId = this.resourceContainerImageId;
    final resourceContainerImageName = this.resourceContainerImageName;
    final resourceContainerLaunchedAt = this.resourceContainerLaunchedAt;
    final resourceContainerName = this.resourceContainerName;
    final resourceDetailsOther = this.resourceDetailsOther;
    final resourceId = this.resourceId;
    final resourcePartition = this.resourcePartition;
    final resourceRegion = this.resourceRegion;
    final resourceTags = this.resourceTags;
    final resourceType = this.resourceType;
    final sample = this.sample;
    final severityLabel = this.severityLabel;
    final severityNormalized = this.severityNormalized;
    final severityProduct = this.severityProduct;
    final sourceUrl = this.sourceUrl;
    final threatIntelIndicatorCategory = this.threatIntelIndicatorCategory;
    final threatIntelIndicatorLastObservedAt =
        this.threatIntelIndicatorLastObservedAt;
    final threatIntelIndicatorSource = this.threatIntelIndicatorSource;
    final threatIntelIndicatorSourceUrl = this.threatIntelIndicatorSourceUrl;
    final threatIntelIndicatorType = this.threatIntelIndicatorType;
    final threatIntelIndicatorValue = this.threatIntelIndicatorValue;
    final title = this.title;
    final type = this.type;
    final updatedAt = this.updatedAt;
    final userDefinedFields = this.userDefinedFields;
    final verificationState = this.verificationState;
    final vulnerabilitiesExploitAvailable =
        this.vulnerabilitiesExploitAvailable;
    final vulnerabilitiesFixAvailable = this.vulnerabilitiesFixAvailable;
    final workflowState = this.workflowState;
    final workflowStatus = this.workflowStatus;
    return {
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (awsAccountName != null) 'AwsAccountName': awsAccountName,
      if (companyName != null) 'CompanyName': companyName,
      if (complianceAssociatedStandardsId != null)
        'ComplianceAssociatedStandardsId': complianceAssociatedStandardsId,
      if (complianceSecurityControlId != null)
        'ComplianceSecurityControlId': complianceSecurityControlId,
      if (complianceSecurityControlParametersName != null)
        'ComplianceSecurityControlParametersName':
            complianceSecurityControlParametersName,
      if (complianceSecurityControlParametersValue != null)
        'ComplianceSecurityControlParametersValue':
            complianceSecurityControlParametersValue,
      if (complianceStatus != null) 'ComplianceStatus': complianceStatus,
      if (confidence != null) 'Confidence': confidence,
      if (createdAt != null) 'CreatedAt': createdAt,
      if (criticality != null) 'Criticality': criticality,
      if (description != null) 'Description': description,
      if (findingProviderFieldsConfidence != null)
        'FindingProviderFieldsConfidence': findingProviderFieldsConfidence,
      if (findingProviderFieldsCriticality != null)
        'FindingProviderFieldsCriticality': findingProviderFieldsCriticality,
      if (findingProviderFieldsRelatedFindingsId != null)
        'FindingProviderFieldsRelatedFindingsId':
            findingProviderFieldsRelatedFindingsId,
      if (findingProviderFieldsRelatedFindingsProductArn != null)
        'FindingProviderFieldsRelatedFindingsProductArn':
            findingProviderFieldsRelatedFindingsProductArn,
      if (findingProviderFieldsSeverityLabel != null)
        'FindingProviderFieldsSeverityLabel':
            findingProviderFieldsSeverityLabel,
      if (findingProviderFieldsSeverityOriginal != null)
        'FindingProviderFieldsSeverityOriginal':
            findingProviderFieldsSeverityOriginal,
      if (findingProviderFieldsTypes != null)
        'FindingProviderFieldsTypes': findingProviderFieldsTypes,
      if (firstObservedAt != null) 'FirstObservedAt': firstObservedAt,
      if (generatorId != null) 'GeneratorId': generatorId,
      if (id != null) 'Id': id,
      if (keyword != null) 'Keyword': keyword,
      if (lastObservedAt != null) 'LastObservedAt': lastObservedAt,
      if (malwareName != null) 'MalwareName': malwareName,
      if (malwarePath != null) 'MalwarePath': malwarePath,
      if (malwareState != null) 'MalwareState': malwareState,
      if (malwareType != null) 'MalwareType': malwareType,
      if (networkDestinationDomain != null)
        'NetworkDestinationDomain': networkDestinationDomain,
      if (networkDestinationIpV4 != null)
        'NetworkDestinationIpV4': networkDestinationIpV4,
      if (networkDestinationIpV6 != null)
        'NetworkDestinationIpV6': networkDestinationIpV6,
      if (networkDestinationPort != null)
        'NetworkDestinationPort': networkDestinationPort,
      if (networkDirection != null) 'NetworkDirection': networkDirection,
      if (networkProtocol != null) 'NetworkProtocol': networkProtocol,
      if (networkSourceDomain != null)
        'NetworkSourceDomain': networkSourceDomain,
      if (networkSourceIpV4 != null) 'NetworkSourceIpV4': networkSourceIpV4,
      if (networkSourceIpV6 != null) 'NetworkSourceIpV6': networkSourceIpV6,
      if (networkSourceMac != null) 'NetworkSourceMac': networkSourceMac,
      if (networkSourcePort != null) 'NetworkSourcePort': networkSourcePort,
      if (noteText != null) 'NoteText': noteText,
      if (noteUpdatedAt != null) 'NoteUpdatedAt': noteUpdatedAt,
      if (noteUpdatedBy != null) 'NoteUpdatedBy': noteUpdatedBy,
      if (processLaunchedAt != null) 'ProcessLaunchedAt': processLaunchedAt,
      if (processName != null) 'ProcessName': processName,
      if (processParentPid != null) 'ProcessParentPid': processParentPid,
      if (processPath != null) 'ProcessPath': processPath,
      if (processPid != null) 'ProcessPid': processPid,
      if (processTerminatedAt != null)
        'ProcessTerminatedAt': processTerminatedAt,
      if (productArn != null) 'ProductArn': productArn,
      if (productFields != null) 'ProductFields': productFields,
      if (productName != null) 'ProductName': productName,
      if (recommendationText != null) 'RecommendationText': recommendationText,
      if (recordState != null) 'RecordState': recordState,
      if (region != null) 'Region': region,
      if (relatedFindingsId != null) 'RelatedFindingsId': relatedFindingsId,
      if (relatedFindingsProductArn != null)
        'RelatedFindingsProductArn': relatedFindingsProductArn,
      if (resourceApplicationArn != null)
        'ResourceApplicationArn': resourceApplicationArn,
      if (resourceApplicationName != null)
        'ResourceApplicationName': resourceApplicationName,
      if (resourceAwsEc2InstanceIamInstanceProfileArn != null)
        'ResourceAwsEc2InstanceIamInstanceProfileArn':
            resourceAwsEc2InstanceIamInstanceProfileArn,
      if (resourceAwsEc2InstanceImageId != null)
        'ResourceAwsEc2InstanceImageId': resourceAwsEc2InstanceImageId,
      if (resourceAwsEc2InstanceIpV4Addresses != null)
        'ResourceAwsEc2InstanceIpV4Addresses':
            resourceAwsEc2InstanceIpV4Addresses,
      if (resourceAwsEc2InstanceIpV6Addresses != null)
        'ResourceAwsEc2InstanceIpV6Addresses':
            resourceAwsEc2InstanceIpV6Addresses,
      if (resourceAwsEc2InstanceKeyName != null)
        'ResourceAwsEc2InstanceKeyName': resourceAwsEc2InstanceKeyName,
      if (resourceAwsEc2InstanceLaunchedAt != null)
        'ResourceAwsEc2InstanceLaunchedAt': resourceAwsEc2InstanceLaunchedAt,
      if (resourceAwsEc2InstanceSubnetId != null)
        'ResourceAwsEc2InstanceSubnetId': resourceAwsEc2InstanceSubnetId,
      if (resourceAwsEc2InstanceType != null)
        'ResourceAwsEc2InstanceType': resourceAwsEc2InstanceType,
      if (resourceAwsEc2InstanceVpcId != null)
        'ResourceAwsEc2InstanceVpcId': resourceAwsEc2InstanceVpcId,
      if (resourceAwsIamAccessKeyCreatedAt != null)
        'ResourceAwsIamAccessKeyCreatedAt': resourceAwsIamAccessKeyCreatedAt,
      if (resourceAwsIamAccessKeyPrincipalName != null)
        'ResourceAwsIamAccessKeyPrincipalName':
            resourceAwsIamAccessKeyPrincipalName,
      if (resourceAwsIamAccessKeyStatus != null)
        'ResourceAwsIamAccessKeyStatus': resourceAwsIamAccessKeyStatus,
      if (resourceAwsIamAccessKeyUserName != null)
        'ResourceAwsIamAccessKeyUserName': resourceAwsIamAccessKeyUserName,
      if (resourceAwsIamUserUserName != null)
        'ResourceAwsIamUserUserName': resourceAwsIamUserUserName,
      if (resourceAwsS3BucketOwnerId != null)
        'ResourceAwsS3BucketOwnerId': resourceAwsS3BucketOwnerId,
      if (resourceAwsS3BucketOwnerName != null)
        'ResourceAwsS3BucketOwnerName': resourceAwsS3BucketOwnerName,
      if (resourceContainerImageId != null)
        'ResourceContainerImageId': resourceContainerImageId,
      if (resourceContainerImageName != null)
        'ResourceContainerImageName': resourceContainerImageName,
      if (resourceContainerLaunchedAt != null)
        'ResourceContainerLaunchedAt': resourceContainerLaunchedAt,
      if (resourceContainerName != null)
        'ResourceContainerName': resourceContainerName,
      if (resourceDetailsOther != null)
        'ResourceDetailsOther': resourceDetailsOther,
      if (resourceId != null) 'ResourceId': resourceId,
      if (resourcePartition != null) 'ResourcePartition': resourcePartition,
      if (resourceRegion != null) 'ResourceRegion': resourceRegion,
      if (resourceTags != null) 'ResourceTags': resourceTags,
      if (resourceType != null) 'ResourceType': resourceType,
      if (sample != null) 'Sample': sample,
      if (severityLabel != null) 'SeverityLabel': severityLabel,
      if (severityNormalized != null) 'SeverityNormalized': severityNormalized,
      if (severityProduct != null) 'SeverityProduct': severityProduct,
      if (sourceUrl != null) 'SourceUrl': sourceUrl,
      if (threatIntelIndicatorCategory != null)
        'ThreatIntelIndicatorCategory': threatIntelIndicatorCategory,
      if (threatIntelIndicatorLastObservedAt != null)
        'ThreatIntelIndicatorLastObservedAt':
            threatIntelIndicatorLastObservedAt,
      if (threatIntelIndicatorSource != null)
        'ThreatIntelIndicatorSource': threatIntelIndicatorSource,
      if (threatIntelIndicatorSourceUrl != null)
        'ThreatIntelIndicatorSourceUrl': threatIntelIndicatorSourceUrl,
      if (threatIntelIndicatorType != null)
        'ThreatIntelIndicatorType': threatIntelIndicatorType,
      if (threatIntelIndicatorValue != null)
        'ThreatIntelIndicatorValue': threatIntelIndicatorValue,
      if (title != null) 'Title': title,
      if (type != null) 'Type': type,
      if (updatedAt != null) 'UpdatedAt': updatedAt,
      if (userDefinedFields != null) 'UserDefinedFields': userDefinedFields,
      if (verificationState != null) 'VerificationState': verificationState,
      if (vulnerabilitiesExploitAvailable != null)
        'VulnerabilitiesExploitAvailable': vulnerabilitiesExploitAvailable,
      if (vulnerabilitiesFixAvailable != null)
        'VulnerabilitiesFixAvailable': vulnerabilitiesFixAvailable,
      if (workflowState != null) 'WorkflowState': workflowState,
      if (workflowStatus != null) 'WorkflowStatus': workflowStatus,
    };
  }
}

/// Identifies which finding to get the finding history for.
class AwsSecurityFindingIdentifier {
  /// The identifier of the finding that was specified by the finding provider.
  final String id;

  /// The ARN generated by Security Hub that uniquely identifies a product that
  /// generates findings. This can be the ARN for a third-party product that is
  /// integrated with Security Hub, or the ARN for a custom integration.
  final String productArn;

  AwsSecurityFindingIdentifier({
    required this.id,
    required this.productArn,
  });

  factory AwsSecurityFindingIdentifier.fromJson(Map<String, dynamic> json) {
    return AwsSecurityFindingIdentifier(
      id: json['Id'] as String,
      productArn: json['ProductArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final productArn = this.productArn;
    return {
      'Id': id,
      'ProductArn': productArn,
    };
  }
}

/// Provides information about an Amazon SNS topic to which notifications can be
/// published.
class AwsSnsTopicDetails {
  /// Indicates failed message delivery status for an Amazon SNS topic that is
  /// subscribed to a platform application endpoint.
  final String? applicationSuccessFeedbackRoleArn;

  /// Indicates failed message delivery status for an Amazon SNS topic that is
  /// subscribed to an Amazon Kinesis Data Firehose endpoint.
  final String? firehoseFailureFeedbackRoleArn;

  /// Indicates successful message delivery status for an Amazon SNS topic that is
  /// subscribed to an Amazon Kinesis Data Firehose endpoint.
  final String? firehoseSuccessFeedbackRoleArn;

  /// Indicates failed message delivery status for an Amazon SNS topic that is
  /// subscribed to an HTTP endpoint.
  final String? httpFailureFeedbackRoleArn;

  /// Indicates successful message delivery status for an Amazon SNS topic that is
  /// subscribed to an HTTP endpoint.
  final String? httpSuccessFeedbackRoleArn;

  /// The ID of an Amazon Web Services managed key for Amazon SNS or a customer
  /// managed key.
  final String? kmsMasterKeyId;

  /// The subscription's owner.
  final String? owner;

  /// Indicates failed message delivery status for an Amazon SNS topic that is
  /// subscribed to an Amazon SQS endpoint.
  final String? sqsFailureFeedbackRoleArn;

  /// Indicates successful message delivery status for an Amazon SNS topic that is
  /// subscribed to an Amazon SQS endpoint.
  final String? sqsSuccessFeedbackRoleArn;

  /// Subscription is an embedded property that describes the subscription
  /// endpoints of an Amazon SNS topic.
  final List<AwsSnsTopicSubscription>? subscription;

  /// The name of the Amazon SNS topic.
  final String? topicName;

  AwsSnsTopicDetails({
    this.applicationSuccessFeedbackRoleArn,
    this.firehoseFailureFeedbackRoleArn,
    this.firehoseSuccessFeedbackRoleArn,
    this.httpFailureFeedbackRoleArn,
    this.httpSuccessFeedbackRoleArn,
    this.kmsMasterKeyId,
    this.owner,
    this.sqsFailureFeedbackRoleArn,
    this.sqsSuccessFeedbackRoleArn,
    this.subscription,
    this.topicName,
  });

  factory AwsSnsTopicDetails.fromJson(Map<String, dynamic> json) {
    return AwsSnsTopicDetails(
      applicationSuccessFeedbackRoleArn:
          json['ApplicationSuccessFeedbackRoleArn'] as String?,
      firehoseFailureFeedbackRoleArn:
          json['FirehoseFailureFeedbackRoleArn'] as String?,
      firehoseSuccessFeedbackRoleArn:
          json['FirehoseSuccessFeedbackRoleArn'] as String?,
      httpFailureFeedbackRoleArn: json['HttpFailureFeedbackRoleArn'] as String?,
      httpSuccessFeedbackRoleArn: json['HttpSuccessFeedbackRoleArn'] as String?,
      kmsMasterKeyId: json['KmsMasterKeyId'] as String?,
      owner: json['Owner'] as String?,
      sqsFailureFeedbackRoleArn: json['SqsFailureFeedbackRoleArn'] as String?,
      sqsSuccessFeedbackRoleArn: json['SqsSuccessFeedbackRoleArn'] as String?,
      subscription: (json['Subscription'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsSnsTopicSubscription.fromJson(e as Map<String, dynamic>))
          .toList(),
      topicName: json['TopicName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final applicationSuccessFeedbackRoleArn =
        this.applicationSuccessFeedbackRoleArn;
    final firehoseFailureFeedbackRoleArn = this.firehoseFailureFeedbackRoleArn;
    final firehoseSuccessFeedbackRoleArn = this.firehoseSuccessFeedbackRoleArn;
    final httpFailureFeedbackRoleArn = this.httpFailureFeedbackRoleArn;
    final httpSuccessFeedbackRoleArn = this.httpSuccessFeedbackRoleArn;
    final kmsMasterKeyId = this.kmsMasterKeyId;
    final owner = this.owner;
    final sqsFailureFeedbackRoleArn = this.sqsFailureFeedbackRoleArn;
    final sqsSuccessFeedbackRoleArn = this.sqsSuccessFeedbackRoleArn;
    final subscription = this.subscription;
    final topicName = this.topicName;
    return {
      if (applicationSuccessFeedbackRoleArn != null)
        'ApplicationSuccessFeedbackRoleArn': applicationSuccessFeedbackRoleArn,
      if (firehoseFailureFeedbackRoleArn != null)
        'FirehoseFailureFeedbackRoleArn': firehoseFailureFeedbackRoleArn,
      if (firehoseSuccessFeedbackRoleArn != null)
        'FirehoseSuccessFeedbackRoleArn': firehoseSuccessFeedbackRoleArn,
      if (httpFailureFeedbackRoleArn != null)
        'HttpFailureFeedbackRoleArn': httpFailureFeedbackRoleArn,
      if (httpSuccessFeedbackRoleArn != null)
        'HttpSuccessFeedbackRoleArn': httpSuccessFeedbackRoleArn,
      if (kmsMasterKeyId != null) 'KmsMasterKeyId': kmsMasterKeyId,
      if (owner != null) 'Owner': owner,
      if (sqsFailureFeedbackRoleArn != null)
        'SqsFailureFeedbackRoleArn': sqsFailureFeedbackRoleArn,
      if (sqsSuccessFeedbackRoleArn != null)
        'SqsSuccessFeedbackRoleArn': sqsSuccessFeedbackRoleArn,
      if (subscription != null) 'Subscription': subscription,
      if (topicName != null) 'TopicName': topicName,
    };
  }
}

/// A wrapper type for the attributes of an Amazon SNS subscription.
class AwsSnsTopicSubscription {
  /// The subscription's endpoint (format depends on the protocol).
  final String? endpoint;

  /// The subscription's protocol.
  final String? protocol;

  AwsSnsTopicSubscription({
    this.endpoint,
    this.protocol,
  });

  factory AwsSnsTopicSubscription.fromJson(Map<String, dynamic> json) {
    return AwsSnsTopicSubscription(
      endpoint: json['Endpoint'] as String?,
      protocol: json['Protocol'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final endpoint = this.endpoint;
    final protocol = this.protocol;
    return {
      if (endpoint != null) 'Endpoint': endpoint,
      if (protocol != null) 'Protocol': protocol,
    };
  }
}

/// Data about a queue.
class AwsSqsQueueDetails {
  /// The ARN of the dead-letter queue to which Amazon SQS moves messages after
  /// the value of <code>maxReceiveCount</code> is exceeded.
  final String? deadLetterTargetArn;

  /// The length of time, in seconds, for which Amazon SQS can reuse a data key to
  /// encrypt or decrypt messages before calling KMS again.
  final int? kmsDataKeyReusePeriodSeconds;

  /// The ID of an Amazon Web Services managed key for Amazon SQS or a custom KMS
  /// key.
  final String? kmsMasterKeyId;

  /// The name of the new queue.
  final String? queueName;

  AwsSqsQueueDetails({
    this.deadLetterTargetArn,
    this.kmsDataKeyReusePeriodSeconds,
    this.kmsMasterKeyId,
    this.queueName,
  });

  factory AwsSqsQueueDetails.fromJson(Map<String, dynamic> json) {
    return AwsSqsQueueDetails(
      deadLetterTargetArn: json['DeadLetterTargetArn'] as String?,
      kmsDataKeyReusePeriodSeconds:
          json['KmsDataKeyReusePeriodSeconds'] as int?,
      kmsMasterKeyId: json['KmsMasterKeyId'] as String?,
      queueName: json['QueueName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deadLetterTargetArn = this.deadLetterTargetArn;
    final kmsDataKeyReusePeriodSeconds = this.kmsDataKeyReusePeriodSeconds;
    final kmsMasterKeyId = this.kmsMasterKeyId;
    final queueName = this.queueName;
    return {
      if (deadLetterTargetArn != null)
        'DeadLetterTargetArn': deadLetterTargetArn,
      if (kmsDataKeyReusePeriodSeconds != null)
        'KmsDataKeyReusePeriodSeconds': kmsDataKeyReusePeriodSeconds,
      if (kmsMasterKeyId != null) 'KmsMasterKeyId': kmsMasterKeyId,
      if (queueName != null) 'QueueName': queueName,
    };
  }
}

/// Provides the details about the compliance status for a patch.
class AwsSsmComplianceSummary {
  /// The type of resource for which the compliance was determined. For
  /// <code>AwsSsmPatchCompliance</code>, <code>ComplianceType</code> is
  /// <code>Patch</code>.
  final String? complianceType;

  /// For the patches that are compliant, the number that have a severity of
  /// <code>CRITICAL</code>.
  final int? compliantCriticalCount;

  /// For the patches that are compliant, the number that have a severity of
  /// <code>HIGH</code>.
  final int? compliantHighCount;

  /// For the patches that are compliant, the number that have a severity of
  /// <code>INFORMATIONAL</code>.
  final int? compliantInformationalCount;

  /// For the patches that are compliant, the number that have a severity of
  /// <code>LOW</code>.
  final int? compliantLowCount;

  /// For the patches that are compliant, the number that have a severity of
  /// <code>MEDIUM</code>.
  final int? compliantMediumCount;

  /// For the patches that are compliant, the number that have a severity of
  /// <code>UNSPECIFIED</code>.
  final int? compliantUnspecifiedCount;

  /// The type of execution that was used determine compliance.
  final String? executionType;

  /// For the patch items that are noncompliant, the number of items that have a
  /// severity of <code>CRITICAL</code>.
  final int? nonCompliantCriticalCount;

  /// For the patches that are noncompliant, the number that have a severity of
  /// <code>HIGH</code>.
  final int? nonCompliantHighCount;

  /// For the patches that are noncompliant, the number that have a severity of
  /// <code>INFORMATIONAL</code>.
  final int? nonCompliantInformationalCount;

  /// For the patches that are noncompliant, the number that have a severity of
  /// <code>LOW</code>.
  final int? nonCompliantLowCount;

  /// For the patches that are noncompliant, the number that have a severity of
  /// <code>MEDIUM</code>.
  final int? nonCompliantMediumCount;

  /// For the patches that are noncompliant, the number that have a severity of
  /// <code>UNSPECIFIED</code>.
  final int? nonCompliantUnspecifiedCount;

  /// The highest severity for the patches. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>CRITICAL</code>
  /// </li>
  /// <li>
  /// <code>HIGH</code>
  /// </li>
  /// <li>
  /// <code>MEDIUM</code>
  /// </li>
  /// <li>
  /// <code>LOW</code>
  /// </li>
  /// <li>
  /// <code>INFORMATIONAL</code>
  /// </li>
  /// <li>
  /// <code>UNSPECIFIED</code>
  /// </li>
  /// </ul>
  final String? overallSeverity;

  /// The identifier of the patch baseline. The patch baseline lists the patches
  /// that are approved for installation.
  final String? patchBaselineId;

  /// The identifier of the patch group for which compliance was determined. A
  /// patch group uses tags to group EC2 instances that should have the same patch
  /// compliance.
  final String? patchGroup;

  /// The current patch compliance status. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>COMPLIANT</code>
  /// </li>
  /// <li>
  /// <code>NON_COMPLIANT</code>
  /// </li>
  /// <li>
  /// <code>UNSPECIFIED_DATA</code>
  /// </li>
  /// </ul>
  final String? status;

  AwsSsmComplianceSummary({
    this.complianceType,
    this.compliantCriticalCount,
    this.compliantHighCount,
    this.compliantInformationalCount,
    this.compliantLowCount,
    this.compliantMediumCount,
    this.compliantUnspecifiedCount,
    this.executionType,
    this.nonCompliantCriticalCount,
    this.nonCompliantHighCount,
    this.nonCompliantInformationalCount,
    this.nonCompliantLowCount,
    this.nonCompliantMediumCount,
    this.nonCompliantUnspecifiedCount,
    this.overallSeverity,
    this.patchBaselineId,
    this.patchGroup,
    this.status,
  });

  factory AwsSsmComplianceSummary.fromJson(Map<String, dynamic> json) {
    return AwsSsmComplianceSummary(
      complianceType: json['ComplianceType'] as String?,
      compliantCriticalCount: json['CompliantCriticalCount'] as int?,
      compliantHighCount: json['CompliantHighCount'] as int?,
      compliantInformationalCount: json['CompliantInformationalCount'] as int?,
      compliantLowCount: json['CompliantLowCount'] as int?,
      compliantMediumCount: json['CompliantMediumCount'] as int?,
      compliantUnspecifiedCount: json['CompliantUnspecifiedCount'] as int?,
      executionType: json['ExecutionType'] as String?,
      nonCompliantCriticalCount: json['NonCompliantCriticalCount'] as int?,
      nonCompliantHighCount: json['NonCompliantHighCount'] as int?,
      nonCompliantInformationalCount:
          json['NonCompliantInformationalCount'] as int?,
      nonCompliantLowCount: json['NonCompliantLowCount'] as int?,
      nonCompliantMediumCount: json['NonCompliantMediumCount'] as int?,
      nonCompliantUnspecifiedCount:
          json['NonCompliantUnspecifiedCount'] as int?,
      overallSeverity: json['OverallSeverity'] as String?,
      patchBaselineId: json['PatchBaselineId'] as String?,
      patchGroup: json['PatchGroup'] as String?,
      status: json['Status'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final complianceType = this.complianceType;
    final compliantCriticalCount = this.compliantCriticalCount;
    final compliantHighCount = this.compliantHighCount;
    final compliantInformationalCount = this.compliantInformationalCount;
    final compliantLowCount = this.compliantLowCount;
    final compliantMediumCount = this.compliantMediumCount;
    final compliantUnspecifiedCount = this.compliantUnspecifiedCount;
    final executionType = this.executionType;
    final nonCompliantCriticalCount = this.nonCompliantCriticalCount;
    final nonCompliantHighCount = this.nonCompliantHighCount;
    final nonCompliantInformationalCount = this.nonCompliantInformationalCount;
    final nonCompliantLowCount = this.nonCompliantLowCount;
    final nonCompliantMediumCount = this.nonCompliantMediumCount;
    final nonCompliantUnspecifiedCount = this.nonCompliantUnspecifiedCount;
    final overallSeverity = this.overallSeverity;
    final patchBaselineId = this.patchBaselineId;
    final patchGroup = this.patchGroup;
    final status = this.status;
    return {
      if (complianceType != null) 'ComplianceType': complianceType,
      if (compliantCriticalCount != null)
        'CompliantCriticalCount': compliantCriticalCount,
      if (compliantHighCount != null) 'CompliantHighCount': compliantHighCount,
      if (compliantInformationalCount != null)
        'CompliantInformationalCount': compliantInformationalCount,
      if (compliantLowCount != null) 'CompliantLowCount': compliantLowCount,
      if (compliantMediumCount != null)
        'CompliantMediumCount': compliantMediumCount,
      if (compliantUnspecifiedCount != null)
        'CompliantUnspecifiedCount': compliantUnspecifiedCount,
      if (executionType != null) 'ExecutionType': executionType,
      if (nonCompliantCriticalCount != null)
        'NonCompliantCriticalCount': nonCompliantCriticalCount,
      if (nonCompliantHighCount != null)
        'NonCompliantHighCount': nonCompliantHighCount,
      if (nonCompliantInformationalCount != null)
        'NonCompliantInformationalCount': nonCompliantInformationalCount,
      if (nonCompliantLowCount != null)
        'NonCompliantLowCount': nonCompliantLowCount,
      if (nonCompliantMediumCount != null)
        'NonCompliantMediumCount': nonCompliantMediumCount,
      if (nonCompliantUnspecifiedCount != null)
        'NonCompliantUnspecifiedCount': nonCompliantUnspecifiedCount,
      if (overallSeverity != null) 'OverallSeverity': overallSeverity,
      if (patchBaselineId != null) 'PatchBaselineId': patchBaselineId,
      if (patchGroup != null) 'PatchGroup': patchGroup,
      if (status != null) 'Status': status,
    };
  }
}

/// Provides details about the compliance for a patch.
class AwsSsmPatch {
  /// The compliance status details for the patch.
  final AwsSsmComplianceSummary? complianceSummary;

  AwsSsmPatch({
    this.complianceSummary,
  });

  factory AwsSsmPatch.fromJson(Map<String, dynamic> json) {
    return AwsSsmPatch(
      complianceSummary: json['ComplianceSummary'] != null
          ? AwsSsmComplianceSummary.fromJson(
              json['ComplianceSummary'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final complianceSummary = this.complianceSummary;
    return {
      if (complianceSummary != null) 'ComplianceSummary': complianceSummary,
    };
  }
}

/// Provides information about the state of a patch on an instance based on the
/// patch baseline that was used to patch the instance.
class AwsSsmPatchComplianceDetails {
  /// Information about the status of a patch.
  final AwsSsmPatch? patch;

  AwsSsmPatchComplianceDetails({
    this.patch,
  });

  factory AwsSsmPatchComplianceDetails.fromJson(Map<String, dynamic> json) {
    return AwsSsmPatchComplianceDetails(
      patch: json['Patch'] != null
          ? AwsSsmPatch.fromJson(json['Patch'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final patch = this.patch;
    return {
      if (patch != null) 'Patch': patch,
    };
  }
}

/// Provides details about an Step Functions state machine, which is a workflow
/// consisting of a series of event- driven steps.
class AwsStepFunctionStateMachineDetails {
  /// A user-defined or an auto-generated string that identifies a
  /// <code>Map</code> state. This parameter is present only if the
  /// <code>stateMachineArn</code> specified in input is a qualified state machine
  /// ARN.
  final String? label;

  /// Used to set CloudWatch Logs options.
  final AwsStepFunctionStateMachineLoggingConfigurationDetails?
      loggingConfiguration;

  /// The name of the state machine.
  final String? name;

  /// The Amazon Resource Name (ARN) of the IAM role used when creating this state
  /// machine.
  final String? roleArn;

  /// The ARN that identifies the state machine.
  final String? stateMachineArn;

  /// The current status of the state machine.
  final String? status;

  /// Specifies whether X-Ray tracing is enabled.
  final AwsStepFunctionStateMachineTracingConfigurationDetails?
      tracingConfiguration;

  /// The type of the state machine (STANDARD or EXPRESS).
  final String? type;

  AwsStepFunctionStateMachineDetails({
    this.label,
    this.loggingConfiguration,
    this.name,
    this.roleArn,
    this.stateMachineArn,
    this.status,
    this.tracingConfiguration,
    this.type,
  });

  factory AwsStepFunctionStateMachineDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsStepFunctionStateMachineDetails(
      label: json['Label'] as String?,
      loggingConfiguration: json['LoggingConfiguration'] != null
          ? AwsStepFunctionStateMachineLoggingConfigurationDetails.fromJson(
              json['LoggingConfiguration'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      roleArn: json['RoleArn'] as String?,
      stateMachineArn: json['StateMachineArn'] as String?,
      status: json['Status'] as String?,
      tracingConfiguration: json['TracingConfiguration'] != null
          ? AwsStepFunctionStateMachineTracingConfigurationDetails.fromJson(
              json['TracingConfiguration'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final label = this.label;
    final loggingConfiguration = this.loggingConfiguration;
    final name = this.name;
    final roleArn = this.roleArn;
    final stateMachineArn = this.stateMachineArn;
    final status = this.status;
    final tracingConfiguration = this.tracingConfiguration;
    final type = this.type;
    return {
      if (label != null) 'Label': label,
      if (loggingConfiguration != null)
        'LoggingConfiguration': loggingConfiguration,
      if (name != null) 'Name': name,
      if (roleArn != null) 'RoleArn': roleArn,
      if (stateMachineArn != null) 'StateMachineArn': stateMachineArn,
      if (status != null) 'Status': status,
      if (tracingConfiguration != null)
        'TracingConfiguration': tracingConfiguration,
      if (type != null) 'Type': type,
    };
  }
}

/// An object describing a CloudWatch log group. For more information, see <a
/// href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html">
/// Amazon Web Services::Logs::LogGroup</a> in the <i>CloudFormation User
/// Guide</i>.
class AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails {
  /// The ARN (ends with <code>:*</code>) of the CloudWatch Logs log group to
  /// which you want your logs emitted.
  final String? logGroupArn;

  AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails({
    this.logGroupArn,
  });

  factory AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails(
      logGroupArn: json['LogGroupArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final logGroupArn = this.logGroupArn;
    return {
      if (logGroupArn != null) 'LogGroupArn': logGroupArn,
    };
  }
}

/// An array of objects that describes where your execution history events will
/// be logged.
class AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails {
  /// An object describing a CloudWatch Logs log group. For more information, see
  /// <a
  /// href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html">
  /// Amazon Web Services::Logs::LogGroup</a> in the <i>CloudFormation User
  /// Guide</i>.
  final AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails?
      cloudWatchLogsLogGroup;

  AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails({
    this.cloudWatchLogsLogGroup,
  });

  factory AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails(
      cloudWatchLogsLogGroup: json['CloudWatchLogsLogGroup'] != null
          ? AwsStepFunctionStateMachineLoggingConfigurationDestinationsCloudWatchLogsLogGroupDetails
              .fromJson(json['CloudWatchLogsLogGroup'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsLogGroup = this.cloudWatchLogsLogGroup;
    return {
      if (cloudWatchLogsLogGroup != null)
        'CloudWatchLogsLogGroup': cloudWatchLogsLogGroup,
    };
  }
}

/// The <code>LoggingConfiguration</code> data type is used to set CloudWatch
/// Logs options.
class AwsStepFunctionStateMachineLoggingConfigurationDetails {
  /// An array of objects that describes where your execution history events will
  /// be logged.
  final List<
          AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails>?
      destinations;

  /// Determines whether execution data is included in your log. When set to
  /// false, data is excluded.
  final bool? includeExecutionData;

  /// Defines which category of execution history events are logged.
  final String? level;

  AwsStepFunctionStateMachineLoggingConfigurationDetails({
    this.destinations,
    this.includeExecutionData,
    this.level,
  });

  factory AwsStepFunctionStateMachineLoggingConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsStepFunctionStateMachineLoggingConfigurationDetails(
      destinations: (json['Destinations'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsStepFunctionStateMachineLoggingConfigurationDestinationsDetails
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      includeExecutionData: json['IncludeExecutionData'] as bool?,
      level: json['Level'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destinations = this.destinations;
    final includeExecutionData = this.includeExecutionData;
    final level = this.level;
    return {
      if (destinations != null) 'Destinations': destinations,
      if (includeExecutionData != null)
        'IncludeExecutionData': includeExecutionData,
      if (level != null) 'Level': level,
    };
  }
}

/// Specifies whether X-Ray tracing is enabled.
class AwsStepFunctionStateMachineTracingConfigurationDetails {
  /// When set to true, X-Ray tracing is enabled.
  final bool? enabled;

  AwsStepFunctionStateMachineTracingConfigurationDetails({
    this.enabled,
  });

  factory AwsStepFunctionStateMachineTracingConfigurationDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsStepFunctionStateMachineTracingConfigurationDetails(
      enabled: json['Enabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      if (enabled != null) 'Enabled': enabled,
    };
  }
}

/// Details about a rate-based rule for global resources. A rate-based rule
/// provides settings to indicate when to allow, block, or count a request.
/// Rate-based rules include the number of requests that arrive over a specified
/// period of time.
class AwsWafRateBasedRuleDetails {
  /// The predicates to include in the rate-based rule.
  final List<AwsWafRateBasedRuleMatchPredicate>? matchPredicates;

  /// The name of the metrics for the rate-based rule.
  final String? metricName;

  /// The name of the rate-based rule.
  final String? name;

  /// The field that WAF uses to determine whether requests are likely arriving
  /// from single source and are subject to rate monitoring.
  final String? rateKey;

  /// The maximum number of requests that have an identical value for the field
  /// specified in <code>RateKey</code> that are allowed within a five-minute
  /// period. If the number of requests exceeds <code>RateLimit</code> and the
  /// other predicates specified in the rule are met, WAF triggers the action for
  /// the rule.
  final int? rateLimit;

  /// The unique identifier for the rate-based rule.
  final String? ruleId;

  AwsWafRateBasedRuleDetails({
    this.matchPredicates,
    this.metricName,
    this.name,
    this.rateKey,
    this.rateLimit,
    this.ruleId,
  });

  factory AwsWafRateBasedRuleDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRateBasedRuleDetails(
      matchPredicates: (json['MatchPredicates'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafRateBasedRuleMatchPredicate.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      rateKey: json['RateKey'] as String?,
      rateLimit: json['RateLimit'] as int?,
      ruleId: json['RuleId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final matchPredicates = this.matchPredicates;
    final metricName = this.metricName;
    final name = this.name;
    final rateKey = this.rateKey;
    final rateLimit = this.rateLimit;
    final ruleId = this.ruleId;
    return {
      if (matchPredicates != null) 'MatchPredicates': matchPredicates,
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (rateKey != null) 'RateKey': rateKey,
      if (rateLimit != null) 'RateLimit': rateLimit,
      if (ruleId != null) 'RuleId': ruleId,
    };
  }
}

/// A match predicate. A predicate might look for characteristics such as
/// specific IP addresses, geographic locations, or sizes.
class AwsWafRateBasedRuleMatchPredicate {
  /// The unique identifier for the predicate.
  final String? dataId;

  /// If set to <code>true</code>, then the rule actions are performed on requests
  /// that match the predicate settings.
  ///
  /// If set to <code>false</code>, then the rule actions are performed on all
  /// requests except those that match the predicate settings.
  final bool? negated;

  /// The type of predicate. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ByteMatch</code>
  /// </li>
  /// <li>
  /// <code>GeoMatch</code>
  /// </li>
  /// <li>
  /// <code>IPMatch</code>
  /// </li>
  /// <li>
  /// <code>RegexMatch</code>
  /// </li>
  /// <li>
  /// <code>SizeConstraint</code>
  /// </li>
  /// <li>
  /// <code>SqlInjectionMatch</code>
  /// </li>
  /// <li>
  /// <code>XssMatch</code>
  /// </li>
  /// </ul>
  final String? type;

  AwsWafRateBasedRuleMatchPredicate({
    this.dataId,
    this.negated,
    this.type,
  });

  factory AwsWafRateBasedRuleMatchPredicate.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRateBasedRuleMatchPredicate(
      dataId: json['DataId'] as String?,
      negated: json['Negated'] as bool?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataId = this.dataId;
    final negated = this.negated;
    final type = this.type;
    return {
      if (dataId != null) 'DataId': dataId,
      if (negated != null) 'Negated': negated,
      if (type != null) 'Type': type,
    };
  }
}

/// contains details about a rate-based rule for Regional resources. A
/// rate-based rule provides settings to indicate when to allow, block, or count
/// a request. Rate-based rules include the number of requests that arrive over
/// a specified period of time.
class AwsWafRegionalRateBasedRuleDetails {
  /// The predicates to include in the rate-based rule.
  final List<AwsWafRegionalRateBasedRuleMatchPredicate>? matchPredicates;

  /// The name of the metrics for the rate-based rule.
  final String? metricName;

  /// The name of the rate-based rule.
  final String? name;

  /// The field that WAF uses to determine whether requests are likely arriving
  /// from single source and are subject to rate monitoring.
  final String? rateKey;

  /// The maximum number of requests that have an identical value for the field
  /// specified in <code>RateKey</code> that are allowed within a five-minute
  /// period. If the number of requests exceeds <code>RateLimit</code> and the
  /// other predicates specified in the rule are met, WAF triggers the action for
  /// the rule.
  final int? rateLimit;

  /// The unique identifier for the rate-based rule.
  final String? ruleId;

  AwsWafRegionalRateBasedRuleDetails({
    this.matchPredicates,
    this.metricName,
    this.name,
    this.rateKey,
    this.rateLimit,
    this.ruleId,
  });

  factory AwsWafRegionalRateBasedRuleDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalRateBasedRuleDetails(
      matchPredicates: (json['MatchPredicates'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafRegionalRateBasedRuleMatchPredicate.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      rateKey: json['RateKey'] as String?,
      rateLimit: json['RateLimit'] as int?,
      ruleId: json['RuleId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final matchPredicates = this.matchPredicates;
    final metricName = this.metricName;
    final name = this.name;
    final rateKey = this.rateKey;
    final rateLimit = this.rateLimit;
    final ruleId = this.ruleId;
    return {
      if (matchPredicates != null) 'MatchPredicates': matchPredicates,
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (rateKey != null) 'RateKey': rateKey,
      if (rateLimit != null) 'RateLimit': rateLimit,
      if (ruleId != null) 'RuleId': ruleId,
    };
  }
}

/// Details for a match predicate. A predicate might look for characteristics
/// such as specific IP addresses, geographic locations, or sizes.
class AwsWafRegionalRateBasedRuleMatchPredicate {
  /// The unique identifier for the predicate.
  final String? dataId;

  /// If set to <code>true</code>, then the rule actions are performed on requests
  /// that match the predicate settings.
  ///
  /// If set to <code>false</code>, then the rule actions are performed on all
  /// requests except those that match the predicate settings.
  final bool? negated;

  /// The type of predicate. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ByteMatch</code>
  /// </li>
  /// <li>
  /// <code>GeoMatch</code>
  /// </li>
  /// <li>
  /// <code>IPMatch</code>
  /// </li>
  /// <li>
  /// <code>RegexMatch</code>
  /// </li>
  /// <li>
  /// <code>SizeConstraint</code>
  /// </li>
  /// <li>
  /// <code>SqlInjectionMatch</code>
  /// </li>
  /// <li>
  /// <code>XssMatch</code>
  /// </li>
  /// </ul>
  final String? type;

  AwsWafRegionalRateBasedRuleMatchPredicate({
    this.dataId,
    this.negated,
    this.type,
  });

  factory AwsWafRegionalRateBasedRuleMatchPredicate.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalRateBasedRuleMatchPredicate(
      dataId: json['DataId'] as String?,
      negated: json['Negated'] as bool?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataId = this.dataId;
    final negated = this.negated;
    final type = this.type;
    return {
      if (dataId != null) 'DataId': dataId,
      if (negated != null) 'Negated': negated,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about an WAF Regional rule. This rule identifies the
/// web requests that you want to allow, block, or count.
class AwsWafRegionalRuleDetails {
  /// A name for the metrics for the rule.
  final String? metricName;

  /// A descriptive name for the rule.
  final String? name;

  /// Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>,
  /// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
  /// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and
  /// <code>SizeConstraintSet</code> objects that you want to add to a rule and,
  /// for each object, indicates whether you want to negate the settings.
  final List<AwsWafRegionalRulePredicateListDetails>? predicateList;

  /// The ID of the rule.
  final String? ruleId;

  AwsWafRegionalRuleDetails({
    this.metricName,
    this.name,
    this.predicateList,
    this.ruleId,
  });

  factory AwsWafRegionalRuleDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRegionalRuleDetails(
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      predicateList: (json['PredicateList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafRegionalRulePredicateListDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ruleId: json['RuleId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final metricName = this.metricName;
    final name = this.name;
    final predicateList = this.predicateList;
    final ruleId = this.ruleId;
    return {
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (predicateList != null) 'PredicateList': predicateList,
      if (ruleId != null) 'RuleId': ruleId,
    };
  }
}

/// Provides information about an WAF Regional rule group. The rule group is a
/// collection of rules for inspecting and controlling web requests.
class AwsWafRegionalRuleGroupDetails {
  /// A name for the metrics for this rule group.
  final String? metricName;

  /// The descriptive name of the rule group.
  final String? name;

  /// The ID of the rule group.
  final String? ruleGroupId;

  /// Provides information about the rule statements used to identify the web
  /// requests that you want to allow, block, or count.
  final List<AwsWafRegionalRuleGroupRulesDetails>? rules;

  AwsWafRegionalRuleGroupDetails({
    this.metricName,
    this.name,
    this.ruleGroupId,
    this.rules,
  });

  factory AwsWafRegionalRuleGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRegionalRuleGroupDetails(
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      ruleGroupId: json['RuleGroupId'] as String?,
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafRegionalRuleGroupRulesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final metricName = this.metricName;
    final name = this.name;
    final ruleGroupId = this.ruleGroupId;
    final rules = this.rules;
    return {
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (ruleGroupId != null) 'RuleGroupId': ruleGroupId,
      if (rules != null) 'Rules': rules,
    };
  }
}

/// Describes the action that WAF should take on a web request when it matches
/// the criteria defined in the rule.
class AwsWafRegionalRuleGroupRulesActionDetails {
  /// Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>,
  /// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
  /// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and
  /// <code>SizeConstraintSet</code> objects that you want to add to a rule and,
  /// for each object, indicates whether you want to negate the settings.
  final String? type;

  AwsWafRegionalRuleGroupRulesActionDetails({
    this.type,
  });

  factory AwsWafRegionalRuleGroupRulesActionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalRuleGroupRulesActionDetails(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about the rules attached to a rule group
class AwsWafRegionalRuleGroupRulesDetails {
  /// The action that WAF should take on a web request when it matches the
  /// criteria defined in the rule.
  final AwsWafRegionalRuleGroupRulesActionDetails? action;

  /// If you define more than one rule in a web ACL, WAF evaluates each request
  /// against the rules in order based on the value of <code>Priority</code>.
  final int? priority;

  /// The ID for a rule.
  final String? ruleId;

  /// The type of rule in the rule group.
  final String? type;

  AwsWafRegionalRuleGroupRulesDetails({
    this.action,
    this.priority,
    this.ruleId,
    this.type,
  });

  factory AwsWafRegionalRuleGroupRulesDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalRuleGroupRulesDetails(
      action: json['Action'] != null
          ? AwsWafRegionalRuleGroupRulesActionDetails.fromJson(
              json['Action'] as Map<String, dynamic>)
          : null,
      priority: json['Priority'] as int?,
      ruleId: json['RuleId'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final action = this.action;
    final priority = this.priority;
    final ruleId = this.ruleId;
    final type = this.type;
    return {
      if (action != null) 'Action': action,
      if (priority != null) 'Priority': priority,
      if (ruleId != null) 'RuleId': ruleId,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides details about the <code>ByteMatchSet</code>, <code>IPSet</code>,
/// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
/// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and
/// <code>SizeConstraintSet</code> objects that you want to add to a rule and,
/// for each object, indicates whether you want to negate the settings.
class AwsWafRegionalRulePredicateListDetails {
  /// A unique identifier for a predicate in a rule, such as
  /// <code>ByteMatchSetId</code> or <code>IPSetId</code>.
  final String? dataId;

  /// Specifies if you want WAF to allow, block, or count requests based on the
  /// settings in the <code>ByteMatchSet</code>, <code>IPSet</code>,
  /// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
  /// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or
  /// <code>SizeConstraintSet</code>.
  final bool? negated;

  /// The type of predicate in a rule, such as <code>ByteMatch</code> or
  /// <code>IPSet</code>.
  final String? type;

  AwsWafRegionalRulePredicateListDetails({
    this.dataId,
    this.negated,
    this.type,
  });

  factory AwsWafRegionalRulePredicateListDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalRulePredicateListDetails(
      dataId: json['DataId'] as String?,
      negated: json['Negated'] as bool?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataId = this.dataId;
    final negated = this.negated;
    final type = this.type;
    return {
      if (dataId != null) 'DataId': dataId,
      if (negated != null) 'Negated': negated,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about the web access control list (web ACL). The web
/// ACL contains the rules that identify the requests that you want to allow,
/// block, or count.
class AwsWafRegionalWebAclDetails {
  /// The action to perform if none of the rules contained in the web ACL match.
  final String? defaultAction;

  /// A name for the metrics for this web ACL.
  final String? metricName;

  /// A descriptive name for the web ACL.
  final String? name;

  /// An array that contains the action for each rule in a web ACL, the priority
  /// of the rule, and the ID of the rule.
  final List<AwsWafRegionalWebAclRulesListDetails>? rulesList;

  /// The ID of the web ACL.
  final String? webAclId;

  AwsWafRegionalWebAclDetails({
    this.defaultAction,
    this.metricName,
    this.name,
    this.rulesList,
    this.webAclId,
  });

  factory AwsWafRegionalWebAclDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRegionalWebAclDetails(
      defaultAction: json['DefaultAction'] as String?,
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      rulesList: (json['RulesList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafRegionalWebAclRulesListDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      webAclId: json['WebAclId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultAction = this.defaultAction;
    final metricName = this.metricName;
    final name = this.name;
    final rulesList = this.rulesList;
    final webAclId = this.webAclId;
    return {
      if (defaultAction != null) 'DefaultAction': defaultAction,
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (rulesList != null) 'RulesList': rulesList,
      if (webAclId != null) 'WebAclId': webAclId,
    };
  }
}

/// The action that WAF takes when a web request matches all conditions in the
/// rule, such as allow, block, or count the request.
class AwsWafRegionalWebAclRulesListActionDetails {
  /// For actions that are associated with a rule, the action that WAF takes when
  /// a web request matches all conditions in a rule.
  final String? type;

  AwsWafRegionalWebAclRulesListActionDetails({
    this.type,
  });

  factory AwsWafRegionalWebAclRulesListActionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalWebAclRulesListActionDetails(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// A combination of <code>ByteMatchSet</code>, <code>IPSet</code>, and/or
/// <code>SqlInjectionMatchSet</code> objects that identify the web requests
/// that you want to allow, block, or count.
class AwsWafRegionalWebAclRulesListDetails {
  /// The action that WAF takes when a web request matches all conditions in the
  /// rule, such as allow, block, or count the request.
  final AwsWafRegionalWebAclRulesListActionDetails? action;

  /// Overrides the rule evaluation result in the rule group.
  final AwsWafRegionalWebAclRulesListOverrideActionDetails? overrideAction;

  /// The order in which WAF evaluates the rules in a web ACL.
  final int? priority;

  /// The ID of an WAF Regional rule to associate with a web ACL.
  final String? ruleId;

  /// For actions that are associated with a rule, the action that WAF takes when
  /// a web request matches all conditions in a rule.
  final String? type;

  AwsWafRegionalWebAclRulesListDetails({
    this.action,
    this.overrideAction,
    this.priority,
    this.ruleId,
    this.type,
  });

  factory AwsWafRegionalWebAclRulesListDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalWebAclRulesListDetails(
      action: json['Action'] != null
          ? AwsWafRegionalWebAclRulesListActionDetails.fromJson(
              json['Action'] as Map<String, dynamic>)
          : null,
      overrideAction: json['OverrideAction'] != null
          ? AwsWafRegionalWebAclRulesListOverrideActionDetails.fromJson(
              json['OverrideAction'] as Map<String, dynamic>)
          : null,
      priority: json['Priority'] as int?,
      ruleId: json['RuleId'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final action = this.action;
    final overrideAction = this.overrideAction;
    final priority = this.priority;
    final ruleId = this.ruleId;
    final type = this.type;
    return {
      if (action != null) 'Action': action,
      if (overrideAction != null) 'OverrideAction': overrideAction,
      if (priority != null) 'Priority': priority,
      if (ruleId != null) 'RuleId': ruleId,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides details about the action to use in the place of the action that
/// results from the rule group evaluation.
class AwsWafRegionalWebAclRulesListOverrideActionDetails {
  /// Overrides the rule evaluation result in the rule group.
  final String? type;

  AwsWafRegionalWebAclRulesListOverrideActionDetails({
    this.type,
  });

  factory AwsWafRegionalWebAclRulesListOverrideActionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRegionalWebAclRulesListOverrideActionDetails(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about a WAF rule. This rule specifies the web requests
/// that you want to allow, block, or count.
class AwsWafRuleDetails {
  /// The name of the metrics for this rule.
  final String? metricName;

  /// A descriptive name for the rule.
  final String? name;

  /// Specifies the <code>ByteMatchSet</code>, <code>IPSet</code>,
  /// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
  /// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and
  /// <code>SizeConstraintSet</code> objects that you want to add to a rule and,
  /// for each object, indicates whether you want to negate the settings.
  final List<AwsWafRulePredicateListDetails>? predicateList;

  /// The ID of the WAF rule.
  final String? ruleId;

  AwsWafRuleDetails({
    this.metricName,
    this.name,
    this.predicateList,
    this.ruleId,
  });

  factory AwsWafRuleDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRuleDetails(
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      predicateList: (json['PredicateList'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafRulePredicateListDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      ruleId: json['RuleId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final metricName = this.metricName;
    final name = this.name;
    final predicateList = this.predicateList;
    final ruleId = this.ruleId;
    return {
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (predicateList != null) 'PredicateList': predicateList,
      if (ruleId != null) 'RuleId': ruleId,
    };
  }
}

/// Provides information about an WAF rule group. A rule group is a collection
/// of rules for inspecting and controlling web requests.
class AwsWafRuleGroupDetails {
  /// The name of the metrics for this rule group.
  final String? metricName;

  /// The name of the rule group.
  final String? name;

  /// The ID of the rule group.
  final String? ruleGroupId;

  /// Provides information about the rules attached to the rule group. These rules
  /// identify the web requests that you want to allow, block, or count.
  final List<AwsWafRuleGroupRulesDetails>? rules;

  AwsWafRuleGroupDetails({
    this.metricName,
    this.name,
    this.ruleGroupId,
    this.rules,
  });

  factory AwsWafRuleGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRuleGroupDetails(
      metricName: json['MetricName'] as String?,
      name: json['Name'] as String?,
      ruleGroupId: json['RuleGroupId'] as String?,
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsWafRuleGroupRulesDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final metricName = this.metricName;
    final name = this.name;
    final ruleGroupId = this.ruleGroupId;
    final rules = this.rules;
    return {
      if (metricName != null) 'MetricName': metricName,
      if (name != null) 'Name': name,
      if (ruleGroupId != null) 'RuleGroupId': ruleGroupId,
      if (rules != null) 'Rules': rules,
    };
  }
}

/// Provides information about what action WAF should take on a web request when
/// it matches the criteria defined in the rule.
class AwsWafRuleGroupRulesActionDetails {
  /// The action that WAF should take on a web request when it matches the rule's
  /// statement.
  final String? type;

  AwsWafRuleGroupRulesActionDetails({
    this.type,
  });

  factory AwsWafRuleGroupRulesActionDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafRuleGroupRulesActionDetails(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about the rules attached to the rule group. These rules
/// identify the web requests that you want to allow, block, or count.
class AwsWafRuleGroupRulesDetails {
  /// Provides information about what action WAF should take on a web request when
  /// it matches the criteria defined in the rule.
  final AwsWafRuleGroupRulesActionDetails? action;

  /// If you define more than one rule in a web ACL, WAF evaluates each request
  /// against the rules in order based on the value of <code>Priority</code>.
  final int? priority;

  /// The rule ID for a rule.
  final String? ruleId;

  /// The type of rule.
  final String? type;

  AwsWafRuleGroupRulesDetails({
    this.action,
    this.priority,
    this.ruleId,
    this.type,
  });

  factory AwsWafRuleGroupRulesDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRuleGroupRulesDetails(
      action: json['Action'] != null
          ? AwsWafRuleGroupRulesActionDetails.fromJson(
              json['Action'] as Map<String, dynamic>)
          : null,
      priority: json['Priority'] as int?,
      ruleId: json['RuleId'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final action = this.action;
    final priority = this.priority;
    final ruleId = this.ruleId;
    final type = this.type;
    return {
      if (action != null) 'Action': action,
      if (priority != null) 'Priority': priority,
      if (ruleId != null) 'RuleId': ruleId,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides details about the <code>ByteMatchSet</code>, <code>IPSet</code>,
/// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
/// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, and
/// <code>SizeConstraintSet</code> objects that you want to add to a rule and,
/// for each object, indicates whether you want to negate the settings.
class AwsWafRulePredicateListDetails {
  /// A unique identifier for a predicate in a rule, such as
  /// <code>ByteMatchSetId</code> or <code>IPSetId</code>.
  final String? dataId;

  /// Specifies if you want WAF to allow, block, or count requests based on the
  /// settings in the <code>ByteMatchSet</code>, <code>IPSet</code>,
  /// <code>SqlInjectionMatchSet</code>, <code>XssMatchSet</code>,
  /// <code>RegexMatchSet</code>, <code>GeoMatchSet</code>, or
  /// <code>SizeConstraintSet</code>.
  final bool? negated;

  /// The type of predicate in a rule, such as <code>ByteMatch</code> or
  /// <code>IPSet</code>.
  final String? type;

  AwsWafRulePredicateListDetails({
    this.dataId,
    this.negated,
    this.type,
  });

  factory AwsWafRulePredicateListDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafRulePredicateListDetails(
      dataId: json['DataId'] as String?,
      negated: json['Negated'] as bool?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataId = this.dataId;
    final negated = this.negated;
    final type = this.type;
    return {
      if (dataId != null) 'DataId': dataId,
      if (negated != null) 'Negated': negated,
      if (type != null) 'Type': type,
    };
  }
}

/// Provides information about an WAF web access control list (web ACL).
class AwsWafWebAclDetails {
  /// The action to perform if none of the rules contained in the web ACL match.
  final String? defaultAction;

  /// A friendly name or description of the web ACL. You can't change the name of
  /// a web ACL after you create it.
  final String? name;

  /// An array that contains the action for each rule in a web ACL, the priority
  /// of the rule, and the ID of the rule.
  final List<AwsWafWebAclRule>? rules;

  /// A unique identifier for a web ACL.
  final String? webAclId;

  AwsWafWebAclDetails({
    this.defaultAction,
    this.name,
    this.rules,
    this.webAclId,
  });

  factory AwsWafWebAclDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafWebAclDetails(
      defaultAction: json['DefaultAction'] as String?,
      name: json['Name'] as String?,
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafWebAclRule.fromJson(e as Map<String, dynamic>))
          .toList(),
      webAclId: json['WebAclId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultAction = this.defaultAction;
    final name = this.name;
    final rules = this.rules;
    final webAclId = this.webAclId;
    return {
      if (defaultAction != null) 'DefaultAction': defaultAction,
      if (name != null) 'Name': name,
      if (rules != null) 'Rules': rules,
      if (webAclId != null) 'WebAclId': webAclId,
    };
  }
}

/// Details for a rule in an WAF web ACL.
class AwsWafWebAclRule {
  /// Specifies the action that CloudFront or WAF takes when a web request matches
  /// the conditions in the rule.
  final WafAction? action;

  /// Rules to exclude from a rule group.
  final List<WafExcludedRule>? excludedRules;

  /// Use the <code>OverrideAction</code> to test your <code>RuleGroup</code>.
  ///
  /// Any rule in a <code>RuleGroup</code> can potentially block a request. If you
  /// set the <code>OverrideAction</code> to <code>None</code>, the
  /// <code>RuleGroup</code> blocks a request if any individual rule in the
  /// <code>RuleGroup</code> matches the request and is configured to block that
  /// request.
  ///
  /// However, if you first want to test the <code>RuleGroup</code>, set the
  /// <code>OverrideAction</code> to <code>Count</code>. The
  /// <code>RuleGroup</code> then overrides any block action specified by
  /// individual rules contained within the group. Instead of blocking matching
  /// requests, those requests are counted.
  ///
  /// <code>ActivatedRule</code>|<code>OverrideAction</code> applies only when
  /// updating or adding a <code>RuleGroup</code> to a web ACL. In this case you
  /// do not use <code>ActivatedRule</code> <code>Action</code>. For all other
  /// update requests, <code>ActivatedRule</code> <code>Action</code> is used
  /// instead of <code>ActivatedRule</code> <code>OverrideAction</code>.
  final WafOverrideAction? overrideAction;

  /// Specifies the order in which the rules in a web ACL are evaluated. Rules
  /// with a lower value for <code>Priority</code> are evaluated before rules with
  /// a higher value. The value must be a unique integer. If you add multiple
  /// rules to a web ACL, the values do not need to be consecutive.
  final int? priority;

  /// The identifier for a rule.
  final String? ruleId;

  /// The rule type.
  ///
  /// Valid values: <code>REGULAR</code> | <code>RATE_BASED</code> |
  /// <code>GROUP</code>
  ///
  /// The default is <code>REGULAR</code>.
  final String? type;

  AwsWafWebAclRule({
    this.action,
    this.excludedRules,
    this.overrideAction,
    this.priority,
    this.ruleId,
    this.type,
  });

  factory AwsWafWebAclRule.fromJson(Map<String, dynamic> json) {
    return AwsWafWebAclRule(
      action: json['Action'] != null
          ? WafAction.fromJson(json['Action'] as Map<String, dynamic>)
          : null,
      excludedRules: (json['ExcludedRules'] as List?)
          ?.whereNotNull()
          .map((e) => WafExcludedRule.fromJson(e as Map<String, dynamic>))
          .toList(),
      overrideAction: json['OverrideAction'] != null
          ? WafOverrideAction.fromJson(
              json['OverrideAction'] as Map<String, dynamic>)
          : null,
      priority: json['Priority'] as int?,
      ruleId: json['RuleId'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final action = this.action;
    final excludedRules = this.excludedRules;
    final overrideAction = this.overrideAction;
    final priority = this.priority;
    final ruleId = this.ruleId;
    final type = this.type;
    return {
      if (action != null) 'Action': action,
      if (excludedRules != null) 'ExcludedRules': excludedRules,
      if (overrideAction != null) 'OverrideAction': overrideAction,
      if (priority != null) 'Priority': priority,
      if (ruleId != null) 'RuleId': ruleId,
      if (type != null) 'Type': type,
    };
  }
}

/// Specifies that WAF should allow the request and optionally defines
/// additional custom handling for the request.
class AwsWafv2ActionAllowDetails {
  /// Defines custom handling for the web request. For information about
  /// customizing web requests and responses, see <a
  /// href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing
  /// web requests and responses in WAF</a> in the <i>WAF Developer Guide.</i>.
  final AwsWafv2CustomRequestHandlingDetails? customRequestHandling;

  AwsWafv2ActionAllowDetails({
    this.customRequestHandling,
  });

  factory AwsWafv2ActionAllowDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2ActionAllowDetails(
      customRequestHandling: json['CustomRequestHandling'] != null
          ? AwsWafv2CustomRequestHandlingDetails.fromJson(
              json['CustomRequestHandling'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customRequestHandling = this.customRequestHandling;
    return {
      if (customRequestHandling != null)
        'CustomRequestHandling': customRequestHandling,
    };
  }
}

/// Specifies that WAF should block the request and optionally defines
/// additional custom handling for the response to the web request.
class AwsWafv2ActionBlockDetails {
  /// Defines a custom response for the web request. For information, see <a
  /// href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing
  /// web requests and responses in WAF</a> in the <i>WAF Developer Guide.</i>.
  final AwsWafv2CustomResponseDetails? customResponse;

  AwsWafv2ActionBlockDetails({
    this.customResponse,
  });

  factory AwsWafv2ActionBlockDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2ActionBlockDetails(
      customResponse: json['CustomResponse'] != null
          ? AwsWafv2CustomResponseDetails.fromJson(
              json['CustomResponse'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customResponse = this.customResponse;
    return {
      if (customResponse != null) 'CustomResponse': customResponse,
    };
  }
}

/// A custom header for custom request and response handling.
class AwsWafv2CustomHttpHeader {
  /// The name of the custom header.
  final String? name;

  /// The value of the custom header.
  final String? value;

  AwsWafv2CustomHttpHeader({
    this.name,
    this.value,
  });

  factory AwsWafv2CustomHttpHeader.fromJson(Map<String, dynamic> json) {
    return AwsWafv2CustomHttpHeader(
      name: json['Name'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// Custom request handling behavior that inserts custom headers into a web
/// request. WAF uses custom request handling when the rule action doesn't block
/// the request.
class AwsWafv2CustomRequestHandlingDetails {
  /// The HTTP headers to insert into the request.
  final List<AwsWafv2CustomHttpHeader>? insertHeaders;

  AwsWafv2CustomRequestHandlingDetails({
    this.insertHeaders,
  });

  factory AwsWafv2CustomRequestHandlingDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafv2CustomRequestHandlingDetails(
      insertHeaders: (json['InsertHeaders'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsWafv2CustomHttpHeader.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final insertHeaders = this.insertHeaders;
    return {
      if (insertHeaders != null) 'InsertHeaders': insertHeaders,
    };
  }
}

/// A custom response to send to the client. You can define a custom response
/// for rule actions and default web ACL actions that are set to block.
class AwsWafv2CustomResponseDetails {
  /// References the response body that you want WAF to return to the web request
  /// client. You can define a custom response for a rule action or a default web
  /// ACL action that is set to block.
  final String? customResponseBodyKey;

  /// The HTTP status code to return to the client. For a list of status codes
  /// that you can use in your custom responses, see <a
  /// href="https://docs.aws.amazon.com/waf/latest/developerguide/customizing-the-response-status-codes.html">Supported
  /// status codes for custom response</a> in the <i>WAF Developer Guide.</i>
  final int? responseCode;

  /// The HTTP headers to use in the response.
  final List<AwsWafv2CustomHttpHeader>? responseHeaders;

  AwsWafv2CustomResponseDetails({
    this.customResponseBodyKey,
    this.responseCode,
    this.responseHeaders,
  });

  factory AwsWafv2CustomResponseDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2CustomResponseDetails(
      customResponseBodyKey: json['CustomResponseBodyKey'] as String?,
      responseCode: json['ResponseCode'] as int?,
      responseHeaders: (json['ResponseHeaders'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AwsWafv2CustomHttpHeader.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final customResponseBodyKey = this.customResponseBodyKey;
    final responseCode = this.responseCode;
    final responseHeaders = this.responseHeaders;
    return {
      if (customResponseBodyKey != null)
        'CustomResponseBodyKey': customResponseBodyKey,
      if (responseCode != null) 'ResponseCode': responseCode,
      if (responseHeaders != null) 'ResponseHeaders': responseHeaders,
    };
  }
}

/// Details about an WAFv2 rule group.
class AwsWafv2RuleGroupDetails {
  /// The Amazon Resource Name (ARN) of the entity.
  final String? arn;

  /// The web ACL capacity units (WCUs) required for this rule group.
  final int? capacity;

  /// A description of the rule group that helps with identification.
  final String? description;

  /// A unique identifier for the rule group.
  final String? id;

  /// The name of the rule group. You cannot change the name of a rule group after
  /// you create it.
  final String? name;

  /// The Rule statements used to identify the web requests that you want to
  /// allow, block, or count. Each rule includes one top-level statement that WAF
  /// uses to identify matching web requests, and parameters that govern how WAF
  /// handles them.
  final List<AwsWafv2RulesDetails>? rules;

  /// Specifies whether the rule group is for an Amazon CloudFront distribution or
  /// for a regional application. A regional application can be an Application
  /// Load Balancer (ALB), an Amazon API Gateway REST API, an AppSync GraphQL API,
  /// or an Amazon Cognito user pool.
  final String? scope;

  /// Defines and enables Amazon CloudWatch metrics and web request sample
  /// collection.
  final AwsWafv2VisibilityConfigDetails? visibilityConfig;

  AwsWafv2RuleGroupDetails({
    this.arn,
    this.capacity,
    this.description,
    this.id,
    this.name,
    this.rules,
    this.scope,
    this.visibilityConfig,
  });

  factory AwsWafv2RuleGroupDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2RuleGroupDetails(
      arn: json['Arn'] as String?,
      capacity: json['Capacity'] as int?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafv2RulesDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      scope: json['Scope'] as String?,
      visibilityConfig: json['VisibilityConfig'] != null
          ? AwsWafv2VisibilityConfigDetails.fromJson(
              json['VisibilityConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final capacity = this.capacity;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final rules = this.rules;
    final scope = this.scope;
    final visibilityConfig = this.visibilityConfig;
    return {
      if (arn != null) 'Arn': arn,
      if (capacity != null) 'Capacity': capacity,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (rules != null) 'Rules': rules,
      if (scope != null) 'Scope': scope,
      if (visibilityConfig != null) 'VisibilityConfig': visibilityConfig,
    };
  }
}

/// Specifies that WAF should run a CAPTCHA check against the request.
class AwsWafv2RulesActionCaptchaDetails {
  /// Defines custom handling for the web request, used when the CAPTCHA
  /// inspection determines that the request's token is valid and unexpired. For
  /// more information, see <a
  /// href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing
  /// web requests and responses in WAF</a> in the <i>WAF Developer Guide.</i>.
  final AwsWafv2CustomRequestHandlingDetails? customRequestHandling;

  AwsWafv2RulesActionCaptchaDetails({
    this.customRequestHandling,
  });

  factory AwsWafv2RulesActionCaptchaDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafv2RulesActionCaptchaDetails(
      customRequestHandling: json['CustomRequestHandling'] != null
          ? AwsWafv2CustomRequestHandlingDetails.fromJson(
              json['CustomRequestHandling'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customRequestHandling = this.customRequestHandling;
    return {
      if (customRequestHandling != null)
        'CustomRequestHandling': customRequestHandling,
    };
  }
}

/// Specifies that WAF should count the request.
class AwsWafv2RulesActionCountDetails {
  /// Defines custom handling for the web request. For more information, see <a
  /// href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-custom-request-response.html">Customizing
  /// web requests and responses in WAF</a> in the <i>WAF Developer Guide.</i>.
  final AwsWafv2CustomRequestHandlingDetails? customRequestHandling;

  AwsWafv2RulesActionCountDetails({
    this.customRequestHandling,
  });

  factory AwsWafv2RulesActionCountDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2RulesActionCountDetails(
      customRequestHandling: json['CustomRequestHandling'] != null
          ? AwsWafv2CustomRequestHandlingDetails.fromJson(
              json['CustomRequestHandling'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customRequestHandling = this.customRequestHandling;
    return {
      if (customRequestHandling != null)
        'CustomRequestHandling': customRequestHandling,
    };
  }
}

/// The action that WAF should take on a web request when it matches a rule's
/// statement. Settings at the web ACL level can override the rule action
/// setting.
class AwsWafv2RulesActionDetails {
  /// Instructs WAF to allow the web request.
  final AwsWafv2ActionAllowDetails? allow;

  /// Instructs WAF to block the web request.
  final AwsWafv2ActionBlockDetails? block;

  /// Instructs WAF to run a CAPTCHA check against the web request.
  final AwsWafv2RulesActionCaptchaDetails? captcha;

  /// Instructs WAF to count the web request and then continue evaluating the
  /// request using the remaining rules in the web ACL.
  final AwsWafv2RulesActionCountDetails? count;

  AwsWafv2RulesActionDetails({
    this.allow,
    this.block,
    this.captcha,
    this.count,
  });

  factory AwsWafv2RulesActionDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2RulesActionDetails(
      allow: json['Allow'] != null
          ? AwsWafv2ActionAllowDetails.fromJson(
              json['Allow'] as Map<String, dynamic>)
          : null,
      block: json['Block'] != null
          ? AwsWafv2ActionBlockDetails.fromJson(
              json['Block'] as Map<String, dynamic>)
          : null,
      captcha: json['Captcha'] != null
          ? AwsWafv2RulesActionCaptchaDetails.fromJson(
              json['Captcha'] as Map<String, dynamic>)
          : null,
      count: json['Count'] != null
          ? AwsWafv2RulesActionCountDetails.fromJson(
              json['Count'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final allow = this.allow;
    final block = this.block;
    final captcha = this.captcha;
    final count = this.count;
    return {
      if (allow != null) 'Allow': allow,
      if (block != null) 'Block': block,
      if (captcha != null) 'Captcha': captcha,
      if (count != null) 'Count': count,
    };
  }
}

/// Provides details about rules in a rule group. A rule identifies web requests
/// that you want to allow, block, or count. Each rule includes one top-level
/// Statement that WAF uses to identify matching web requests, and parameters
/// that govern how WAF handles them.
class AwsWafv2RulesDetails {
  /// The action that WAF should take on a web request when it matches the rule
  /// statement. Settings at the web ACL level can override the rule action
  /// setting.
  final AwsWafv2RulesActionDetails? action;

  /// The name of the rule.
  final String? name;

  /// The action to use in the place of the action that results from the rule
  /// group evaluation.
  final String? overrideAction;

  /// If you define more than one Rule in a WebACL, WAF evaluates each request
  /// against the Rules in order based on the value of <code>Priority</code>. WAF
  /// processes rules with lower priority first. The priorities don't need to be
  /// consecutive, but they must all be different.
  final int? priority;

  /// Defines and enables Amazon CloudWatch metrics and web request sample
  /// collection.
  final AwsWafv2VisibilityConfigDetails? visibilityConfig;

  AwsWafv2RulesDetails({
    this.action,
    this.name,
    this.overrideAction,
    this.priority,
    this.visibilityConfig,
  });

  factory AwsWafv2RulesDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2RulesDetails(
      action: json['Action'] != null
          ? AwsWafv2RulesActionDetails.fromJson(
              json['Action'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      overrideAction: json['OverrideAction'] as String?,
      priority: json['Priority'] as int?,
      visibilityConfig: json['VisibilityConfig'] != null
          ? AwsWafv2VisibilityConfigDetails.fromJson(
              json['VisibilityConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final action = this.action;
    final name = this.name;
    final overrideAction = this.overrideAction;
    final priority = this.priority;
    final visibilityConfig = this.visibilityConfig;
    return {
      if (action != null) 'Action': action,
      if (name != null) 'Name': name,
      if (overrideAction != null) 'OverrideAction': overrideAction,
      if (priority != null) 'Priority': priority,
      if (visibilityConfig != null) 'VisibilityConfig': visibilityConfig,
    };
  }
}

/// Defines and enables Amazon CloudWatch metrics and web request sample
/// collection.
class AwsWafv2VisibilityConfigDetails {
  /// A boolean indicating whether the associated resource sends metrics to Amazon
  /// CloudWatch. For the list of available metrics, see <a
  /// href="https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#waf-metrics">WAF
  /// metrics and dimensions</a> in the <i>WAF Developer Guide</i>.
  final bool? cloudWatchMetricsEnabled;

  /// A name of the Amazon CloudWatch metric.
  final String? metricName;

  /// A boolean indicating whether WAF should store a sampling of the web requests
  /// that match the rules. You can view the sampled requests through the WAF
  /// console.
  final bool? sampledRequestsEnabled;

  AwsWafv2VisibilityConfigDetails({
    this.cloudWatchMetricsEnabled,
    this.metricName,
    this.sampledRequestsEnabled,
  });

  factory AwsWafv2VisibilityConfigDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2VisibilityConfigDetails(
      cloudWatchMetricsEnabled: json['CloudWatchMetricsEnabled'] as bool?,
      metricName: json['MetricName'] as String?,
      sampledRequestsEnabled: json['SampledRequestsEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchMetricsEnabled = this.cloudWatchMetricsEnabled;
    final metricName = this.metricName;
    final sampledRequestsEnabled = this.sampledRequestsEnabled;
    return {
      if (cloudWatchMetricsEnabled != null)
        'CloudWatchMetricsEnabled': cloudWatchMetricsEnabled,
      if (metricName != null) 'MetricName': metricName,
      if (sampledRequestsEnabled != null)
        'SampledRequestsEnabled': sampledRequestsEnabled,
    };
  }
}

/// Specifies the action that Amazon CloudFront or WAF takes when a web request
/// matches the conditions in the rule.
class AwsWafv2WebAclActionDetails {
  /// Specifies that WAF should allow requests by default.
  final AwsWafv2ActionAllowDetails? allow;

  /// Specifies that WAF should block requests by default.
  final AwsWafv2ActionBlockDetails? block;

  AwsWafv2WebAclActionDetails({
    this.allow,
    this.block,
  });

  factory AwsWafv2WebAclActionDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2WebAclActionDetails(
      allow: json['Allow'] != null
          ? AwsWafv2ActionAllowDetails.fromJson(
              json['Allow'] as Map<String, dynamic>)
          : null,
      block: json['Block'] != null
          ? AwsWafv2ActionBlockDetails.fromJson(
              json['Block'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final allow = this.allow;
    final block = this.block;
    return {
      if (allow != null) 'Allow': allow,
      if (block != null) 'Block': block,
    };
  }
}

/// Specifies how WAF should handle CAPTCHA evaluations for rules that don't
/// have their own <code>CaptchaConfig</code> settings.
class AwsWafv2WebAclCaptchaConfigDetails {
  /// Determines how long a CAPTCHA timestamp in the token remains valid after the
  /// client successfully solves a CAPTCHA puzzle.
  final AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails?
      immunityTimeProperty;

  AwsWafv2WebAclCaptchaConfigDetails({
    this.immunityTimeProperty,
  });

  factory AwsWafv2WebAclCaptchaConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafv2WebAclCaptchaConfigDetails(
      immunityTimeProperty: json['ImmunityTimeProperty'] != null
          ? AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails.fromJson(
              json['ImmunityTimeProperty'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final immunityTimeProperty = this.immunityTimeProperty;
    return {
      if (immunityTimeProperty != null)
        'ImmunityTimeProperty': immunityTimeProperty,
    };
  }
}

/// Used for CAPTCHA and challenge token settings. Determines how long a CAPTCHA
/// or challenge timestamp remains valid after WAF updates it for a successful
/// CAPTCHA or challenge response.
class AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails {
  /// The amount of time, in seconds, that a CAPTCHA or challenge timestamp is
  /// considered valid by WAF.
  final int? immunityTime;

  AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails({
    this.immunityTime,
  });

  factory AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails.fromJson(
      Map<String, dynamic> json) {
    return AwsWafv2WebAclCaptchaConfigImmunityTimePropertyDetails(
      immunityTime: json['ImmunityTime'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final immunityTime = this.immunityTime;
    return {
      if (immunityTime != null) 'ImmunityTime': immunityTime,
    };
  }
}

/// Details about an WAFv2 web Access Control List (ACL).
class AwsWafv2WebAclDetails {
  /// The Amazon Resource Name (ARN) of the web ACL that you want to associate
  /// with the resource.
  final String? arn;

  /// The web ACL capacity units (WCUs) currently being used by this web ACL.
  final int? capacity;

  /// Specifies how WAF should handle CAPTCHA evaluations for rules that don't
  /// have their own <code>CaptchaConfig</code> settings.
  final AwsWafv2WebAclCaptchaConfigDetails? captchaConfig;

  /// The action to perform if none of the Rules contained in the web ACL match.
  final AwsWafv2WebAclActionDetails? defaultAction;

  /// A description of the web ACL that helps with identification.
  final String? description;

  /// A unique identifier for the web ACL.
  final String? id;

  /// Indicates whether this web ACL is managed by Firewall Manager.
  final bool? managedbyFirewallManager;

  /// The name of the web ACL.
  final String? name;

  /// The Rule statements used to identify the web requests that you want to
  /// allow, block, or count. Each rule includes one top-level statement that WAF
  /// uses to identify matching web requests, and parameters that govern how WAF
  /// handles them.
  final List<AwsWafv2RulesDetails>? rules;

  /// Defines and enables Amazon CloudWatch metrics and web request sample
  /// collection.
  final AwsWafv2VisibilityConfigDetails? visibilityConfig;

  AwsWafv2WebAclDetails({
    this.arn,
    this.capacity,
    this.captchaConfig,
    this.defaultAction,
    this.description,
    this.id,
    this.managedbyFirewallManager,
    this.name,
    this.rules,
    this.visibilityConfig,
  });

  factory AwsWafv2WebAclDetails.fromJson(Map<String, dynamic> json) {
    return AwsWafv2WebAclDetails(
      arn: json['Arn'] as String?,
      capacity: json['Capacity'] as int?,
      captchaConfig: json['CaptchaConfig'] != null
          ? AwsWafv2WebAclCaptchaConfigDetails.fromJson(
              json['CaptchaConfig'] as Map<String, dynamic>)
          : null,
      defaultAction: json['DefaultAction'] != null
          ? AwsWafv2WebAclActionDetails.fromJson(
              json['DefaultAction'] as Map<String, dynamic>)
          : null,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      managedbyFirewallManager: json['ManagedbyFirewallManager'] as bool?,
      name: json['Name'] as String?,
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) => AwsWafv2RulesDetails.fromJson(e as Map<String, dynamic>))
          .toList(),
      visibilityConfig: json['VisibilityConfig'] != null
          ? AwsWafv2VisibilityConfigDetails.fromJson(
              json['VisibilityConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final capacity = this.capacity;
    final captchaConfig = this.captchaConfig;
    final defaultAction = this.defaultAction;
    final description = this.description;
    final id = this.id;
    final managedbyFirewallManager = this.managedbyFirewallManager;
    final name = this.name;
    final rules = this.rules;
    final visibilityConfig = this.visibilityConfig;
    return {
      if (arn != null) 'Arn': arn,
      if (capacity != null) 'Capacity': capacity,
      if (captchaConfig != null) 'CaptchaConfig': captchaConfig,
      if (defaultAction != null) 'DefaultAction': defaultAction,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (managedbyFirewallManager != null)
        'ManagedbyFirewallManager': managedbyFirewallManager,
      if (name != null) 'Name': name,
      if (rules != null) 'Rules': rules,
      if (visibilityConfig != null) 'VisibilityConfig': visibilityConfig,
    };
  }
}

/// Information about the encryption configuration for X-Ray.
class AwsXrayEncryptionConfigDetails {
  /// The identifier of the KMS key that is used for encryption. Provided if
  /// <code>Type</code> is <code>KMS</code>.
  final String? keyId;

  /// The current status of the encryption configuration. Valid values are
  /// <code>ACTIVE</code> or <code>UPDATING</code>.
  ///
  /// When <code>Status</code> is equal to <code>UPDATING</code>, X-Ray might use
  /// both the old and new encryption.
  final String? status;

  /// The type of encryption. <code>KMS</code> indicates that the encryption uses
  /// KMS keys. <code>NONE</code> indicates the default encryption.
  final String? type;

  AwsXrayEncryptionConfigDetails({
    this.keyId,
    this.status,
    this.type,
  });

  factory AwsXrayEncryptionConfigDetails.fromJson(Map<String, dynamic> json) {
    return AwsXrayEncryptionConfigDetails(
      keyId: json['KeyId'] as String?,
      status: json['Status'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final keyId = this.keyId;
    final status = this.status;
    final type = this.type;
    return {
      if (keyId != null) 'KeyId': keyId,
      if (status != null) 'Status': status,
      if (type != null) 'Type': type,
    };
  }
}

class BatchDeleteAutomationRulesResponse {
  /// A list of properly processed rule ARNs.
  final List<String>? processedAutomationRules;

  /// A list of objects containing <code>RuleArn</code>, <code>ErrorCode</code>,
  /// and <code>ErrorMessage</code>. This parameter tells you which automation
  /// rules the request didn't delete and why.
  final List<UnprocessedAutomationRule>? unprocessedAutomationRules;

  BatchDeleteAutomationRulesResponse({
    this.processedAutomationRules,
    this.unprocessedAutomationRules,
  });

  factory BatchDeleteAutomationRulesResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchDeleteAutomationRulesResponse(
      processedAutomationRules: (json['ProcessedAutomationRules'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      unprocessedAutomationRules: (json['UnprocessedAutomationRules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              UnprocessedAutomationRule.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final processedAutomationRules = this.processedAutomationRules;
    final unprocessedAutomationRules = this.unprocessedAutomationRules;
    return {
      if (processedAutomationRules != null)
        'ProcessedAutomationRules': processedAutomationRules,
      if (unprocessedAutomationRules != null)
        'UnprocessedAutomationRules': unprocessedAutomationRules,
    };
  }
}

class BatchDisableStandardsResponse {
  /// The details of the standards subscriptions that were disabled.
  final List<StandardsSubscription>? standardsSubscriptions;

  BatchDisableStandardsResponse({
    this.standardsSubscriptions,
  });

  factory BatchDisableStandardsResponse.fromJson(Map<String, dynamic> json) {
    return BatchDisableStandardsResponse(
      standardsSubscriptions: (json['StandardsSubscriptions'] as List?)
          ?.whereNotNull()
          .map((e) => StandardsSubscription.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final standardsSubscriptions = this.standardsSubscriptions;
    return {
      if (standardsSubscriptions != null)
        'StandardsSubscriptions': standardsSubscriptions,
    };
  }
}

class BatchEnableStandardsResponse {
  /// The details of the standards subscriptions that were enabled.
  final List<StandardsSubscription>? standardsSubscriptions;

  BatchEnableStandardsResponse({
    this.standardsSubscriptions,
  });

  factory BatchEnableStandardsResponse.fromJson(Map<String, dynamic> json) {
    return BatchEnableStandardsResponse(
      standardsSubscriptions: (json['StandardsSubscriptions'] as List?)
          ?.whereNotNull()
          .map((e) => StandardsSubscription.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final standardsSubscriptions = this.standardsSubscriptions;
    return {
      if (standardsSubscriptions != null)
        'StandardsSubscriptions': standardsSubscriptions,
    };
  }
}

class BatchGetAutomationRulesResponse {
  /// A list of rule details for the provided rule ARNs.
  final List<AutomationRulesConfig>? rules;

  /// A list of objects containing <code>RuleArn</code>, <code>ErrorCode</code>,
  /// and <code>ErrorMessage</code>. This parameter tells you which automation
  /// rules the request didn't retrieve and why.
  final List<UnprocessedAutomationRule>? unprocessedAutomationRules;

  BatchGetAutomationRulesResponse({
    this.rules,
    this.unprocessedAutomationRules,
  });

  factory BatchGetAutomationRulesResponse.fromJson(Map<String, dynamic> json) {
    return BatchGetAutomationRulesResponse(
      rules: (json['Rules'] as List?)
          ?.whereNotNull()
          .map((e) => AutomationRulesConfig.fromJson(e as Map<String, dynamic>))
          .toList(),
      unprocessedAutomationRules: (json['UnprocessedAutomationRules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              UnprocessedAutomationRule.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final rules = this.rules;
    final unprocessedAutomationRules = this.unprocessedAutomationRules;
    return {
      if (rules != null) 'Rules': rules,
      if (unprocessedAutomationRules != null)
        'UnprocessedAutomationRules': unprocessedAutomationRules,
    };
  }
}

class BatchGetConfigurationPolicyAssociationsResponse {
  /// Describes associations for the target accounts, OUs, or the root.
  final List<ConfigurationPolicyAssociationSummary>?
      configurationPolicyAssociations;

  /// An array of configuration policy associations, one for each configuration
  /// policy association identifier, that was specified in the request but
  /// couldn’t be processed due to an error.
  final List<UnprocessedConfigurationPolicyAssociation>?
      unprocessedConfigurationPolicyAssociations;

  BatchGetConfigurationPolicyAssociationsResponse({
    this.configurationPolicyAssociations,
    this.unprocessedConfigurationPolicyAssociations,
  });

  factory BatchGetConfigurationPolicyAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchGetConfigurationPolicyAssociationsResponse(
      configurationPolicyAssociations:
          (json['ConfigurationPolicyAssociations'] as List?)
              ?.whereNotNull()
              .map((e) => ConfigurationPolicyAssociationSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      unprocessedConfigurationPolicyAssociations:
          (json['UnprocessedConfigurationPolicyAssociations'] as List?)
              ?.whereNotNull()
              .map((e) => UnprocessedConfigurationPolicyAssociation.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final configurationPolicyAssociations =
        this.configurationPolicyAssociations;
    final unprocessedConfigurationPolicyAssociations =
        this.unprocessedConfigurationPolicyAssociations;
    return {
      if (configurationPolicyAssociations != null)
        'ConfigurationPolicyAssociations': configurationPolicyAssociations,
      if (unprocessedConfigurationPolicyAssociations != null)
        'UnprocessedConfigurationPolicyAssociations':
            unprocessedConfigurationPolicyAssociations,
    };
  }
}

class BatchGetSecurityControlsResponse {
  /// An array that returns the identifier, Amazon Resource Name (ARN), and other
  /// details about a security control. The same information is returned whether
  /// the request includes <code>SecurityControlId</code> or
  /// <code>SecurityControlArn</code>.
  final List<SecurityControl> securityControls;

  /// A security control (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) for which
  /// details cannot be returned.
  final List<UnprocessedSecurityControl>? unprocessedIds;

  BatchGetSecurityControlsResponse({
    required this.securityControls,
    this.unprocessedIds,
  });

  factory BatchGetSecurityControlsResponse.fromJson(Map<String, dynamic> json) {
    return BatchGetSecurityControlsResponse(
      securityControls: (json['SecurityControls'] as List)
          .whereNotNull()
          .map((e) => SecurityControl.fromJson(e as Map<String, dynamic>))
          .toList(),
      unprocessedIds: (json['UnprocessedIds'] as List?)
          ?.whereNotNull()
          .map((e) =>
              UnprocessedSecurityControl.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final securityControls = this.securityControls;
    final unprocessedIds = this.unprocessedIds;
    return {
      'SecurityControls': securityControls,
      if (unprocessedIds != null) 'UnprocessedIds': unprocessedIds,
    };
  }
}

class BatchGetStandardsControlAssociationsResponse {
  /// Provides the enablement status of a security control in a specified standard
  /// and other details for the control in relation to the specified standard.
  final List<StandardsControlAssociationDetail>
      standardsControlAssociationDetails;

  /// A security control (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) whose
  /// enablement status in a specified standard cannot be returned.
  final List<UnprocessedStandardsControlAssociation>? unprocessedAssociations;

  BatchGetStandardsControlAssociationsResponse({
    required this.standardsControlAssociationDetails,
    this.unprocessedAssociations,
  });

  factory BatchGetStandardsControlAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchGetStandardsControlAssociationsResponse(
      standardsControlAssociationDetails:
          (json['StandardsControlAssociationDetails'] as List)
              .whereNotNull()
              .map((e) => StandardsControlAssociationDetail.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      unprocessedAssociations: (json['UnprocessedAssociations'] as List?)
          ?.whereNotNull()
          .map((e) => UnprocessedStandardsControlAssociation.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final standardsControlAssociationDetails =
        this.standardsControlAssociationDetails;
    final unprocessedAssociations = this.unprocessedAssociations;
    return {
      'StandardsControlAssociationDetails': standardsControlAssociationDetails,
      if (unprocessedAssociations != null)
        'UnprocessedAssociations': unprocessedAssociations,
    };
  }
}

class BatchImportFindingsResponse {
  /// The number of findings that failed to import.
  final int failedCount;

  /// The number of findings that were successfully imported.
  final int successCount;

  /// The list of findings that failed to import.
  final List<ImportFindingsError>? failedFindings;

  BatchImportFindingsResponse({
    required this.failedCount,
    required this.successCount,
    this.failedFindings,
  });

  factory BatchImportFindingsResponse.fromJson(Map<String, dynamic> json) {
    return BatchImportFindingsResponse(
      failedCount: json['FailedCount'] as int,
      successCount: json['SuccessCount'] as int,
      failedFindings: (json['FailedFindings'] as List?)
          ?.whereNotNull()
          .map((e) => ImportFindingsError.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final failedCount = this.failedCount;
    final successCount = this.successCount;
    final failedFindings = this.failedFindings;
    return {
      'FailedCount': failedCount,
      'SuccessCount': successCount,
      if (failedFindings != null) 'FailedFindings': failedFindings,
    };
  }
}

class BatchUpdateAutomationRulesResponse {
  /// A list of properly processed rule ARNs.
  final List<String>? processedAutomationRules;

  /// A list of objects containing <code>RuleArn</code>, <code>ErrorCode</code>,
  /// and <code>ErrorMessage</code>. This parameter tells you which automation
  /// rules the request didn't update and why.
  final List<UnprocessedAutomationRule>? unprocessedAutomationRules;

  BatchUpdateAutomationRulesResponse({
    this.processedAutomationRules,
    this.unprocessedAutomationRules,
  });

  factory BatchUpdateAutomationRulesResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchUpdateAutomationRulesResponse(
      processedAutomationRules: (json['ProcessedAutomationRules'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      unprocessedAutomationRules: (json['UnprocessedAutomationRules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              UnprocessedAutomationRule.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final processedAutomationRules = this.processedAutomationRules;
    final unprocessedAutomationRules = this.unprocessedAutomationRules;
    return {
      if (processedAutomationRules != null)
        'ProcessedAutomationRules': processedAutomationRules,
      if (unprocessedAutomationRules != null)
        'UnprocessedAutomationRules': unprocessedAutomationRules,
    };
  }
}

class BatchUpdateFindingsResponse {
  /// The list of findings that were updated successfully.
  final List<AwsSecurityFindingIdentifier> processedFindings;

  /// The list of findings that were not updated.
  final List<BatchUpdateFindingsUnprocessedFinding> unprocessedFindings;

  BatchUpdateFindingsResponse({
    required this.processedFindings,
    required this.unprocessedFindings,
  });

  factory BatchUpdateFindingsResponse.fromJson(Map<String, dynamic> json) {
    return BatchUpdateFindingsResponse(
      processedFindings: (json['ProcessedFindings'] as List)
          .whereNotNull()
          .map((e) =>
              AwsSecurityFindingIdentifier.fromJson(e as Map<String, dynamic>))
          .toList(),
      unprocessedFindings: (json['UnprocessedFindings'] as List)
          .whereNotNull()
          .map((e) => BatchUpdateFindingsUnprocessedFinding.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final processedFindings = this.processedFindings;
    final unprocessedFindings = this.unprocessedFindings;
    return {
      'ProcessedFindings': processedFindings,
      'UnprocessedFindings': unprocessedFindings,
    };
  }
}

/// A finding from a <code>BatchUpdateFindings</code> request that Security Hub
/// was unable to update.
class BatchUpdateFindingsUnprocessedFinding {
  /// The code associated with the error. Possible values are:
  ///
  /// <ul>
  /// <li>
  /// <code>ConcurrentUpdateError</code> - Another request attempted to update the
  /// finding while this request was being processed. This error may also occur if
  /// you call <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html">
  /// <code>BatchUpdateFindings</code> </a> and <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html">
  /// <code>BatchImportFindings</code> </a> at the same time.
  /// </li>
  /// <li>
  /// <code>DuplicatedFindingIdentifier</code> - The request included two or more
  /// findings with the same <code>FindingIdentifier</code>.
  /// </li>
  /// <li>
  /// <code>FindingNotFound</code> - The <code>FindingIdentifier</code> included
  /// in the request did not match an existing finding.
  /// </li>
  /// <li>
  /// <code>FindingSizeExceeded</code> - The finding size was greater than the
  /// permissible value of 240 KB.
  /// </li>
  /// <li>
  /// <code>InternalFailure</code> - An internal service failure occurred when
  /// updating the finding.
  /// </li>
  /// <li>
  /// <code>InvalidInput</code> - The finding update contained an invalid value
  /// that did not satisfy the <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-findings-format.html">Amazon
  /// Web Services Security Finding Format</a> syntax.
  /// </li>
  /// </ul>
  final String errorCode;

  /// The message associated with the error. Possible values are:
  ///
  /// <ul>
  /// <li>
  /// <code>Concurrent finding updates detected</code>
  /// </li>
  /// <li>
  /// <code>Finding Identifier is duplicated</code>
  /// </li>
  /// <li>
  /// <code>Finding Not Found</code>
  /// </li>
  /// <li>
  /// <code>Finding size exceeded 240 KB</code>
  /// </li>
  /// <li>
  /// <code>Internal service failure</code>
  /// </li>
  /// <li>
  /// <code>Invalid Input</code>
  /// </li>
  /// </ul>
  final String errorMessage;

  /// The identifier of the finding that was not updated.
  final AwsSecurityFindingIdentifier findingIdentifier;

  BatchUpdateFindingsUnprocessedFinding({
    required this.errorCode,
    required this.errorMessage,
    required this.findingIdentifier,
  });

  factory BatchUpdateFindingsUnprocessedFinding.fromJson(
      Map<String, dynamic> json) {
    return BatchUpdateFindingsUnprocessedFinding(
      errorCode: json['ErrorCode'] as String,
      errorMessage: json['ErrorMessage'] as String,
      findingIdentifier: AwsSecurityFindingIdentifier.fromJson(
          json['FindingIdentifier'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final errorMessage = this.errorMessage;
    final findingIdentifier = this.findingIdentifier;
    return {
      'ErrorCode': errorCode,
      'ErrorMessage': errorMessage,
      'FindingIdentifier': findingIdentifier,
    };
  }
}

class BatchUpdateStandardsControlAssociationsResponse {
  /// A security control (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) whose
  /// enablement status in a specified standard couldn't be updated.
  final List<UnprocessedStandardsControlAssociationUpdate>?
      unprocessedAssociationUpdates;

  BatchUpdateStandardsControlAssociationsResponse({
    this.unprocessedAssociationUpdates,
  });

  factory BatchUpdateStandardsControlAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return BatchUpdateStandardsControlAssociationsResponse(
      unprocessedAssociationUpdates:
          (json['UnprocessedAssociationUpdates'] as List?)
              ?.whereNotNull()
              .map((e) => UnprocessedStandardsControlAssociationUpdate.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final unprocessedAssociationUpdates = this.unprocessedAssociationUpdates;
    return {
      if (unprocessedAssociationUpdates != null)
        'UnprocessedAssociationUpdates': unprocessedAssociationUpdates,
    };
  }
}

/// The options for customizing a security control parameter with a boolean. For
/// a boolean parameter, the options are <code>true</code> and
/// <code>false</code>.
class BooleanConfigurationOptions {
  /// The Security Hub default value for a boolean parameter.
  final bool? defaultValue;

  BooleanConfigurationOptions({
    this.defaultValue,
  });

  factory BooleanConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return BooleanConfigurationOptions(
      defaultValue: json['DefaultValue'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
    };
  }
}

/// Boolean filter for querying findings.
class BooleanFilter {
  /// The value of the boolean.
  final bool? value;

  BooleanFilter({
    this.value,
  });

  factory BooleanFilter.fromJson(Map<String, dynamic> json) {
    return BooleanFilter(
      value: json['Value'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

/// An occurrence of sensitive data detected in a Microsoft Excel workbook,
/// comma-separated value (CSV) file, or tab-separated value (TSV) file.
class Cell {
  /// For a Microsoft Excel workbook, provides the location of the cell, as an
  /// absolute cell reference, that contains the data. For example, Sheet2!C5 for
  /// cell C5 on Sheet2.
  final String? cellReference;

  /// The column number of the column that contains the data. For a Microsoft
  /// Excel workbook, the column number corresponds to the alphabetical column
  /// identifiers. For example, a value of 1 for Column corresponds to the A
  /// column in the workbook.
  final int? column;

  /// The name of the column that contains the data.
  final String? columnName;

  /// The row number of the row that contains the data.
  final int? row;

  Cell({
    this.cellReference,
    this.column,
    this.columnName,
    this.row,
  });

  factory Cell.fromJson(Map<String, dynamic> json) {
    return Cell(
      cellReference: json['CellReference'] as String?,
      column: json['Column'] as int?,
      columnName: json['ColumnName'] as String?,
      row: json['Row'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final cellReference = this.cellReference;
    final column = this.column;
    final columnName = this.columnName;
    final row = this.row;
    return {
      if (cellReference != null) 'CellReference': cellReference,
      if (column != null) 'Column': column,
      if (columnName != null) 'ColumnName': columnName,
      if (row != null) 'Row': row,
    };
  }
}

/// An IPv4 CIDR block association.
class CidrBlockAssociation {
  /// The association ID for the IPv4 CIDR block.
  final String? associationId;

  /// The IPv4 CIDR block.
  final String? cidrBlock;

  /// Information about the state of the IPv4 CIDR block.
  final String? cidrBlockState;

  CidrBlockAssociation({
    this.associationId,
    this.cidrBlock,
    this.cidrBlockState,
  });

  factory CidrBlockAssociation.fromJson(Map<String, dynamic> json) {
    return CidrBlockAssociation(
      associationId: json['AssociationId'] as String?,
      cidrBlock: json['CidrBlock'] as String?,
      cidrBlockState: json['CidrBlockState'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationId = this.associationId;
    final cidrBlock = this.cidrBlock;
    final cidrBlockState = this.cidrBlockState;
    return {
      if (associationId != null) 'AssociationId': associationId,
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
      if (cidrBlockState != null) 'CidrBlockState': cidrBlockState,
    };
  }
}

/// Information about a city.
class City {
  /// The name of the city.
  final String? cityName;

  City({
    this.cityName,
  });

  factory City.fromJson(Map<String, dynamic> json) {
    return City(
      cityName: json['CityName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cityName = this.cityName;
    return {
      if (cityName != null) 'CityName': cityName,
    };
  }
}

/// Details about the sensitive data that was detected on the resource.
class ClassificationResult {
  /// Indicates whether there are additional occurrences of sensitive data that
  /// are not included in the finding. This occurs when the number of occurrences
  /// exceeds the maximum that can be included.
  final bool? additionalOccurrences;

  /// Provides details about sensitive data that was identified based on
  /// customer-defined configuration.
  final CustomDataIdentifiersResult? customDataIdentifiers;

  /// The type of content that the finding applies to.
  final String? mimeType;

  /// Provides details about sensitive data that was identified based on built-in
  /// configuration.
  final List<SensitiveDataResult>? sensitiveData;

  /// The total size in bytes of the affected data.
  final int? sizeClassified;

  /// The current status of the sensitive data detection.
  final ClassificationStatus? status;

  ClassificationResult({
    this.additionalOccurrences,
    this.customDataIdentifiers,
    this.mimeType,
    this.sensitiveData,
    this.sizeClassified,
    this.status,
  });

  factory ClassificationResult.fromJson(Map<String, dynamic> json) {
    return ClassificationResult(
      additionalOccurrences: json['AdditionalOccurrences'] as bool?,
      customDataIdentifiers: json['CustomDataIdentifiers'] != null
          ? CustomDataIdentifiersResult.fromJson(
              json['CustomDataIdentifiers'] as Map<String, dynamic>)
          : null,
      mimeType: json['MimeType'] as String?,
      sensitiveData: (json['SensitiveData'] as List?)
          ?.whereNotNull()
          .map((e) => SensitiveDataResult.fromJson(e as Map<String, dynamic>))
          .toList(),
      sizeClassified: json['SizeClassified'] as int?,
      status: json['Status'] != null
          ? ClassificationStatus.fromJson(
              json['Status'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final additionalOccurrences = this.additionalOccurrences;
    final customDataIdentifiers = this.customDataIdentifiers;
    final mimeType = this.mimeType;
    final sensitiveData = this.sensitiveData;
    final sizeClassified = this.sizeClassified;
    final status = this.status;
    return {
      if (additionalOccurrences != null)
        'AdditionalOccurrences': additionalOccurrences,
      if (customDataIdentifiers != null)
        'CustomDataIdentifiers': customDataIdentifiers,
      if (mimeType != null) 'MimeType': mimeType,
      if (sensitiveData != null) 'SensitiveData': sensitiveData,
      if (sizeClassified != null) 'SizeClassified': sizeClassified,
      if (status != null) 'Status': status,
    };
  }
}

/// Provides details about the current status of the sensitive data detection.
class ClassificationStatus {
  /// The code that represents the status of the sensitive data detection.
  final String? code;

  /// A longer description of the current status of the sensitive data detection.
  final String? reason;

  ClassificationStatus({
    this.code,
    this.reason,
  });

  factory ClassificationStatus.fromJson(Map<String, dynamic> json) {
    return ClassificationStatus(
      code: json['Code'] as String?,
      reason: json['Reason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final code = this.code;
    final reason = this.reason;
    return {
      if (code != null) 'Code': code,
      if (reason != null) 'Reason': reason,
    };
  }
}

/// The Amazon Resource Name (ARN) and other details of the Amazon CloudWatch
/// Logs log group that Amazon Route 53 is publishing logs to.
class CloudWatchLogsLogGroupArnConfigDetails {
  /// The ARN of the CloudWatch Logs log group that Route 53 is publishing logs
  /// to.
  final String? cloudWatchLogsLogGroupArn;

  /// The ID of the hosted zone that CloudWatch Logs is logging queries for.
  final String? hostedZoneId;

  /// The ID for a DNS query logging configuration.
  final String? id;

  CloudWatchLogsLogGroupArnConfigDetails({
    this.cloudWatchLogsLogGroupArn,
    this.hostedZoneId,
    this.id,
  });

  factory CloudWatchLogsLogGroupArnConfigDetails.fromJson(
      Map<String, dynamic> json) {
    return CloudWatchLogsLogGroupArnConfigDetails(
      cloudWatchLogsLogGroupArn: json['CloudWatchLogsLogGroupArn'] as String?,
      hostedZoneId: json['HostedZoneId'] as String?,
      id: json['Id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsLogGroupArn = this.cloudWatchLogsLogGroupArn;
    final hostedZoneId = this.hostedZoneId;
    final id = this.id;
    return {
      if (cloudWatchLogsLogGroupArn != null)
        'CloudWatchLogsLogGroupArn': cloudWatchLogsLogGroupArn,
      if (hostedZoneId != null) 'HostedZoneId': hostedZoneId,
      if (id != null) 'Id': id,
    };
  }
}

/// Provides details about where a code vulnerability is located in your Lambda
/// function.
class CodeVulnerabilitiesFilePath {
  /// The line number of the last line of code in which the vulnerability is
  /// located.
  final int? endLine;

  /// The name of the file in which the code vulnerability is located.
  final String? fileName;

  /// The file path to the code in which the vulnerability is located.
  final String? filePath;

  /// The line number of the first line of code in which the vulnerability is
  /// located.
  final int? startLine;

  CodeVulnerabilitiesFilePath({
    this.endLine,
    this.fileName,
    this.filePath,
    this.startLine,
  });

  factory CodeVulnerabilitiesFilePath.fromJson(Map<String, dynamic> json) {
    return CodeVulnerabilitiesFilePath(
      endLine: json['EndLine'] as int?,
      fileName: json['FileName'] as String?,
      filePath: json['FilePath'] as String?,
      startLine: json['StartLine'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final endLine = this.endLine;
    final fileName = this.fileName;
    final filePath = this.filePath;
    final startLine = this.startLine;
    return {
      if (endLine != null) 'EndLine': endLine,
      if (fileName != null) 'FileName': fileName,
      if (filePath != null) 'FilePath': filePath,
      if (startLine != null) 'StartLine': startLine,
    };
  }
}

/// Contains finding details that are specific to control-based findings. Only
/// returned for findings generated from controls.
class Compliance {
  /// The enabled security standards in which a security control is currently
  /// enabled.
  final List<AssociatedStandard>? associatedStandards;

  /// For a control, the industry or regulatory framework requirements that are
  /// related to the control. The check for that control is aligned with these
  /// requirements.
  ///
  /// Array Members: Maximum number of 32 items.
  final List<String>? relatedRequirements;

  /// The unique identifier of a control across standards. Values for this field
  /// typically consist of an Amazon Web Service and a number, such as
  /// APIGateway.5.
  final String? securityControlId;

  /// An object that includes security control parameter names and values.
  final List<SecurityControlParameter>? securityControlParameters;

  /// The result of a standards check.
  ///
  /// The valid values for <code>Status</code> are as follows.
  ///
  /// <ul>
  /// <li>
  /// <ul>
  /// <li>
  /// <code>PASSED</code> - Standards check passed for all evaluated resources.
  /// </li>
  /// <li>
  /// <code>WARNING</code> - Some information is missing or this check is not
  /// supported for your configuration.
  /// </li>
  /// <li>
  /// <code>FAILED</code> - Standards check failed for at least one evaluated
  /// resource.
  /// </li>
  /// <li>
  /// <code>NOT_AVAILABLE</code> - Check could not be performed due to a service
  /// outage, API error, or because the result of the Config evaluation was
  /// <code>NOT_APPLICABLE</code>. If the Config evaluation result was
  /// <code>NOT_APPLICABLE</code> for a Security Hub control, Security Hub
  /// automatically archives the finding after 3 days.
  /// </li>
  /// </ul> </li>
  /// </ul>
  final ComplianceStatus? status;

  /// For findings generated from controls, a list of reasons behind the value of
  /// <code>Status</code>. For the list of status reason codes and their meanings,
  /// see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related
  /// information in the ASFF</a> in the <i>Security Hub User Guide</i>.
  final List<StatusReason>? statusReasons;

  Compliance({
    this.associatedStandards,
    this.relatedRequirements,
    this.securityControlId,
    this.securityControlParameters,
    this.status,
    this.statusReasons,
  });

  factory Compliance.fromJson(Map<String, dynamic> json) {
    return Compliance(
      associatedStandards: (json['AssociatedStandards'] as List?)
          ?.whereNotNull()
          .map((e) => AssociatedStandard.fromJson(e as Map<String, dynamic>))
          .toList(),
      relatedRequirements: (json['RelatedRequirements'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      securityControlId: json['SecurityControlId'] as String?,
      securityControlParameters: (json['SecurityControlParameters'] as List?)
          ?.whereNotNull()
          .map((e) =>
              SecurityControlParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      status: (json['Status'] as String?)?.toComplianceStatus(),
      statusReasons: (json['StatusReasons'] as List?)
          ?.whereNotNull()
          .map((e) => StatusReason.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final associatedStandards = this.associatedStandards;
    final relatedRequirements = this.relatedRequirements;
    final securityControlId = this.securityControlId;
    final securityControlParameters = this.securityControlParameters;
    final status = this.status;
    final statusReasons = this.statusReasons;
    return {
      if (associatedStandards != null)
        'AssociatedStandards': associatedStandards,
      if (relatedRequirements != null)
        'RelatedRequirements': relatedRequirements,
      if (securityControlId != null) 'SecurityControlId': securityControlId,
      if (securityControlParameters != null)
        'SecurityControlParameters': securityControlParameters,
      if (status != null) 'Status': status.toValue(),
      if (statusReasons != null) 'StatusReasons': statusReasons,
    };
  }
}

enum ComplianceStatus {
  passed,
  warning,
  failed,
  notAvailable,
}

extension ComplianceStatusValueExtension on ComplianceStatus {
  String toValue() {
    switch (this) {
      case ComplianceStatus.passed:
        return 'PASSED';
      case ComplianceStatus.warning:
        return 'WARNING';
      case ComplianceStatus.failed:
        return 'FAILED';
      case ComplianceStatus.notAvailable:
        return 'NOT_AVAILABLE';
    }
  }
}

extension ComplianceStatusFromString on String {
  ComplianceStatus toComplianceStatus() {
    switch (this) {
      case 'PASSED':
        return ComplianceStatus.passed;
      case 'WARNING':
        return ComplianceStatus.warning;
      case 'FAILED':
        return ComplianceStatus.failed;
      case 'NOT_AVAILABLE':
        return ComplianceStatus.notAvailable;
    }
    throw Exception('$this is not known in enum ComplianceStatus');
  }
}

/// The options for customizing a security control parameter.
class ConfigurationOptions {
  /// The options for customizing a security control parameter that is a boolean.
  /// For a boolean parameter, the options are <code>true</code> and
  /// <code>false</code>.
  final BooleanConfigurationOptions? boolean;

  /// The options for customizing a security control parameter that is a double.
  final DoubleConfigurationOptions? doubleValue;

  /// The options for customizing a security control parameter that is an enum.
  final EnumConfigurationOptions? enumValue;

  /// The options for customizing a security control parameter that is a list of
  /// enums.
  final EnumListConfigurationOptions? enumList;

  /// The options for customizing a security control parameter that is an integer.
  final IntegerConfigurationOptions? integer;

  /// The options for customizing a security control parameter that is a list of
  /// integers.
  final IntegerListConfigurationOptions? integerList;

  /// The options for customizing a security control parameter that is a string
  /// data type.
  final StringConfigurationOptions? string;

  /// The options for customizing a security control parameter that is a list of
  /// strings.
  final StringListConfigurationOptions? stringList;

  ConfigurationOptions({
    this.boolean,
    this.doubleValue,
    this.enumValue,
    this.enumList,
    this.integer,
    this.integerList,
    this.string,
    this.stringList,
  });

  factory ConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return ConfigurationOptions(
      boolean: json['Boolean'] != null
          ? BooleanConfigurationOptions.fromJson(
              json['Boolean'] as Map<String, dynamic>)
          : null,
      doubleValue: json['Double'] != null
          ? DoubleConfigurationOptions.fromJson(
              json['Double'] as Map<String, dynamic>)
          : null,
      enumValue: json['Enum'] != null
          ? EnumConfigurationOptions.fromJson(
              json['Enum'] as Map<String, dynamic>)
          : null,
      enumList: json['EnumList'] != null
          ? EnumListConfigurationOptions.fromJson(
              json['EnumList'] as Map<String, dynamic>)
          : null,
      integer: json['Integer'] != null
          ? IntegerConfigurationOptions.fromJson(
              json['Integer'] as Map<String, dynamic>)
          : null,
      integerList: json['IntegerList'] != null
          ? IntegerListConfigurationOptions.fromJson(
              json['IntegerList'] as Map<String, dynamic>)
          : null,
      string: json['String'] != null
          ? StringConfigurationOptions.fromJson(
              json['String'] as Map<String, dynamic>)
          : null,
      stringList: json['StringList'] != null
          ? StringListConfigurationOptions.fromJson(
              json['StringList'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final boolean = this.boolean;
    final doubleValue = this.doubleValue;
    final enumValue = this.enumValue;
    final enumList = this.enumList;
    final integer = this.integer;
    final integerList = this.integerList;
    final string = this.string;
    final stringList = this.stringList;
    return {
      if (boolean != null) 'Boolean': boolean,
      if (doubleValue != null) 'Double': doubleValue,
      if (enumValue != null) 'Enum': enumValue,
      if (enumList != null) 'EnumList': enumList,
      if (integer != null) 'Integer': integer,
      if (integerList != null) 'IntegerList': integerList,
      if (string != null) 'String': string,
      if (stringList != null) 'StringList': stringList,
    };
  }
}

/// Provides details about the association between an Security Hub configuration
/// and a target account, organizational unit, or the root. An association can
/// exist between a target and a configuration policy, or between a target and
/// self-managed behavior.
class ConfigurationPolicyAssociation {
  /// The target account, organizational unit, or the root.
  final Target? target;

  ConfigurationPolicyAssociation({
    this.target,
  });

  factory ConfigurationPolicyAssociation.fromJson(Map<String, dynamic> json) {
    return ConfigurationPolicyAssociation(
      target: json['Target'] != null
          ? Target.fromJson(json['Target'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final target = this.target;
    return {
      if (target != null) 'Target': target,
    };
  }
}

enum ConfigurationPolicyAssociationStatus {
  pending,
  success,
  failed,
}

extension ConfigurationPolicyAssociationStatusValueExtension
    on ConfigurationPolicyAssociationStatus {
  String toValue() {
    switch (this) {
      case ConfigurationPolicyAssociationStatus.pending:
        return 'PENDING';
      case ConfigurationPolicyAssociationStatus.success:
        return 'SUCCESS';
      case ConfigurationPolicyAssociationStatus.failed:
        return 'FAILED';
    }
  }
}

extension ConfigurationPolicyAssociationStatusFromString on String {
  ConfigurationPolicyAssociationStatus
      toConfigurationPolicyAssociationStatus() {
    switch (this) {
      case 'PENDING':
        return ConfigurationPolicyAssociationStatus.pending;
      case 'SUCCESS':
        return ConfigurationPolicyAssociationStatus.success;
      case 'FAILED':
        return ConfigurationPolicyAssociationStatus.failed;
    }
    throw Exception(
        '$this is not known in enum ConfigurationPolicyAssociationStatus');
  }
}

/// An object that contains the details of a configuration policy association
/// that’s returned in a <code>ListConfigurationPolicyAssociations</code>
/// request.
class ConfigurationPolicyAssociationSummary {
  /// The current status of the association between the specified target and the
  /// configuration.
  final ConfigurationPolicyAssociationStatus? associationStatus;

  /// The explanation for a <code>FAILED</code> value for
  /// <code>AssociationStatus</code>.
  final String? associationStatusMessage;

  /// Indicates whether the association between the specified target and the
  /// configuration was directly applied by the Security Hub delegated
  /// administrator or inherited from a parent.
  final AssociationType? associationType;

  /// The universally unique identifier (UUID) of the configuration policy.
  final String? configurationPolicyId;

  /// The identifier of the target account, organizational unit, or the root.
  final String? targetId;

  /// Specifies whether the target is an Amazon Web Services account,
  /// organizational unit, or the root.
  final TargetType? targetType;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// association was last updated.
  final DateTime? updatedAt;

  ConfigurationPolicyAssociationSummary({
    this.associationStatus,
    this.associationStatusMessage,
    this.associationType,
    this.configurationPolicyId,
    this.targetId,
    this.targetType,
    this.updatedAt,
  });

  factory ConfigurationPolicyAssociationSummary.fromJson(
      Map<String, dynamic> json) {
    return ConfigurationPolicyAssociationSummary(
      associationStatus: (json['AssociationStatus'] as String?)
          ?.toConfigurationPolicyAssociationStatus(),
      associationStatusMessage: json['AssociationStatusMessage'] as String?,
      associationType:
          (json['AssociationType'] as String?)?.toAssociationType(),
      configurationPolicyId: json['ConfigurationPolicyId'] as String?,
      targetId: json['TargetId'] as String?,
      targetType: (json['TargetType'] as String?)?.toTargetType(),
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final associationStatusMessage = this.associationStatusMessage;
    final associationType = this.associationType;
    final configurationPolicyId = this.configurationPolicyId;
    final targetId = this.targetId;
    final targetType = this.targetType;
    final updatedAt = this.updatedAt;
    return {
      if (associationStatus != null)
        'AssociationStatus': associationStatus.toValue(),
      if (associationStatusMessage != null)
        'AssociationStatusMessage': associationStatusMessage,
      if (associationType != null) 'AssociationType': associationType.toValue(),
      if (configurationPolicyId != null)
        'ConfigurationPolicyId': configurationPolicyId,
      if (targetId != null) 'TargetId': targetId,
      if (targetType != null) 'TargetType': targetType.toValue(),
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

/// An object that contains the details of an Security Hub configuration policy
/// that’s returned in a <code>ListConfigurationPolicies</code> request.
class ConfigurationPolicySummary {
  /// The Amazon Resource Name (ARN) of the configuration policy.
  final String? arn;

  /// The description of the configuration policy.
  final String? description;

  /// The universally unique identifier (UUID) of the configuration policy.
  final String? id;

  /// The name of the configuration policy. Alphanumeric characters and the
  /// following ASCII characters are permitted: <code>-, ., !, *, /</code>.
  final String? name;

  /// Indicates whether the service that the configuration policy applies to is
  /// enabled in the policy.
  final bool? serviceEnabled;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was last updated.
  final DateTime? updatedAt;

  ConfigurationPolicySummary({
    this.arn,
    this.description,
    this.id,
    this.name,
    this.serviceEnabled,
    this.updatedAt,
  });

  factory ConfigurationPolicySummary.fromJson(Map<String, dynamic> json) {
    return ConfigurationPolicySummary(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      serviceEnabled: json['ServiceEnabled'] as bool?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final serviceEnabled = this.serviceEnabled;
    final updatedAt = this.updatedAt;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (serviceEnabled != null) 'ServiceEnabled': serviceEnabled,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

/// Container details related to a finding.
class ContainerDetails {
  /// The runtime of the container.
  final String? containerRuntime;

  /// The identifier of the container image related to a finding.
  final String? imageId;

  /// The name of the container image related to a finding.
  final String? imageName;

  /// Indicates when the container started.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? launchedAt;

  /// The name of the container related to a finding.
  final String? name;

  /// When this parameter is <code>true</code>, the container is given elevated
  /// privileges on the host container instance (similar to the root user).
  final bool? privileged;

  /// Provides information about the mounting of a volume in a container.
  final List<VolumeMount>? volumeMounts;

  ContainerDetails({
    this.containerRuntime,
    this.imageId,
    this.imageName,
    this.launchedAt,
    this.name,
    this.privileged,
    this.volumeMounts,
  });

  factory ContainerDetails.fromJson(Map<String, dynamic> json) {
    return ContainerDetails(
      containerRuntime: json['ContainerRuntime'] as String?,
      imageId: json['ImageId'] as String?,
      imageName: json['ImageName'] as String?,
      launchedAt: json['LaunchedAt'] as String?,
      name: json['Name'] as String?,
      privileged: json['Privileged'] as bool?,
      volumeMounts: (json['VolumeMounts'] as List?)
          ?.whereNotNull()
          .map((e) => VolumeMount.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final containerRuntime = this.containerRuntime;
    final imageId = this.imageId;
    final imageName = this.imageName;
    final launchedAt = this.launchedAt;
    final name = this.name;
    final privileged = this.privileged;
    final volumeMounts = this.volumeMounts;
    return {
      if (containerRuntime != null) 'ContainerRuntime': containerRuntime,
      if (imageId != null) 'ImageId': imageId,
      if (imageName != null) 'ImageName': imageName,
      if (launchedAt != null) 'LaunchedAt': launchedAt,
      if (name != null) 'Name': name,
      if (privileged != null) 'Privileged': privileged,
      if (volumeMounts != null) 'VolumeMounts': volumeMounts,
    };
  }
}

enum ControlFindingGenerator {
  standardControl,
  securityControl,
}

extension ControlFindingGeneratorValueExtension on ControlFindingGenerator {
  String toValue() {
    switch (this) {
      case ControlFindingGenerator.standardControl:
        return 'STANDARD_CONTROL';
      case ControlFindingGenerator.securityControl:
        return 'SECURITY_CONTROL';
    }
  }
}

extension ControlFindingGeneratorFromString on String {
  ControlFindingGenerator toControlFindingGenerator() {
    switch (this) {
      case 'STANDARD_CONTROL':
        return ControlFindingGenerator.standardControl;
      case 'SECURITY_CONTROL':
        return ControlFindingGenerator.securityControl;
    }
    throw Exception('$this is not known in enum ControlFindingGenerator');
  }
}

enum ControlStatus {
  enabled,
  disabled,
}

extension ControlStatusValueExtension on ControlStatus {
  String toValue() {
    switch (this) {
      case ControlStatus.enabled:
        return 'ENABLED';
      case ControlStatus.disabled:
        return 'DISABLED';
    }
  }
}

extension ControlStatusFromString on String {
  ControlStatus toControlStatus() {
    switch (this) {
      case 'ENABLED':
        return ControlStatus.enabled;
      case 'DISABLED':
        return ControlStatus.disabled;
    }
    throw Exception('$this is not known in enum ControlStatus');
  }
}

/// Information about a country.
class Country {
  /// The 2-letter ISO 3166 country code for the country.
  final String? countryCode;

  /// The name of the country.
  final String? countryName;

  Country({
    this.countryCode,
    this.countryName,
  });

  factory Country.fromJson(Map<String, dynamic> json) {
    return Country(
      countryCode: json['CountryCode'] as String?,
      countryName: json['CountryName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final countryCode = this.countryCode;
    final countryName = this.countryName;
    return {
      if (countryCode != null) 'CountryCode': countryCode,
      if (countryName != null) 'CountryName': countryName,
    };
  }
}

class CreateActionTargetResponse {
  /// The Amazon Resource Name (ARN) for the custom action target.
  final String actionTargetArn;

  CreateActionTargetResponse({
    required this.actionTargetArn,
  });

  factory CreateActionTargetResponse.fromJson(Map<String, dynamic> json) {
    return CreateActionTargetResponse(
      actionTargetArn: json['ActionTargetArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final actionTargetArn = this.actionTargetArn;
    return {
      'ActionTargetArn': actionTargetArn,
    };
  }
}

class CreateAutomationRuleResponse {
  /// The Amazon Resource Name (ARN) of the automation rule that you created.
  final String? ruleArn;

  CreateAutomationRuleResponse({
    this.ruleArn,
  });

  factory CreateAutomationRuleResponse.fromJson(Map<String, dynamic> json) {
    return CreateAutomationRuleResponse(
      ruleArn: json['RuleArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ruleArn = this.ruleArn;
    return {
      if (ruleArn != null) 'RuleArn': ruleArn,
    };
  }
}

class CreateConfigurationPolicyResponse {
  /// The Amazon Resource Name (ARN) of the configuration policy.
  final String? arn;

  /// An object that defines how Security Hub is configured. It includes whether
  /// Security Hub is enabled or disabled, a list of enabled security standards, a
  /// list of enabled or disabled security controls, and a list of custom
  /// parameter values for specified controls. If the request included a list of
  /// security controls that are enabled in the configuration policy, Security Hub
  /// disables all other controls (including newly released controls). If the
  /// request included a list of security controls that are disabled in the
  /// configuration policy, Security Hub enables all other controls (including
  /// newly released controls).
  final Policy? configurationPolicy;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was created.
  final DateTime? createdAt;

  /// The description of the configuration policy.
  final String? description;

  /// The universally unique identifier (UUID) of the configuration policy.
  final String? id;

  /// The name of the configuration policy.
  final String? name;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was last updated.
  final DateTime? updatedAt;

  CreateConfigurationPolicyResponse({
    this.arn,
    this.configurationPolicy,
    this.createdAt,
    this.description,
    this.id,
    this.name,
    this.updatedAt,
  });

  factory CreateConfigurationPolicyResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateConfigurationPolicyResponse(
      arn: json['Arn'] as String?,
      configurationPolicy: json['ConfigurationPolicy'] != null
          ? Policy.fromJson(json['ConfigurationPolicy'] as Map<String, dynamic>)
          : null,
      createdAt: timeStampFromJson(json['CreatedAt']),
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final configurationPolicy = this.configurationPolicy;
    final createdAt = this.createdAt;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final updatedAt = this.updatedAt;
    return {
      if (arn != null) 'Arn': arn,
      if (configurationPolicy != null)
        'ConfigurationPolicy': configurationPolicy,
      if (createdAt != null) 'CreatedAt': iso8601ToJson(createdAt),
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

class CreateFindingAggregatorResponse {
  /// The aggregation Region.
  final String? findingAggregationRegion;

  /// The ARN of the finding aggregator. You use the finding aggregator ARN to
  /// retrieve details for, update, and stop finding aggregation.
  final String? findingAggregatorArn;

  /// Indicates whether to link all Regions, all Regions except for a list of
  /// excluded Regions, or a list of included Regions.
  final String? regionLinkingMode;

  /// The list of excluded Regions or included Regions.
  final List<String>? regions;

  CreateFindingAggregatorResponse({
    this.findingAggregationRegion,
    this.findingAggregatorArn,
    this.regionLinkingMode,
    this.regions,
  });

  factory CreateFindingAggregatorResponse.fromJson(Map<String, dynamic> json) {
    return CreateFindingAggregatorResponse(
      findingAggregationRegion: json['FindingAggregationRegion'] as String?,
      findingAggregatorArn: json['FindingAggregatorArn'] as String?,
      regionLinkingMode: json['RegionLinkingMode'] as String?,
      regions: (json['Regions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final findingAggregationRegion = this.findingAggregationRegion;
    final findingAggregatorArn = this.findingAggregatorArn;
    final regionLinkingMode = this.regionLinkingMode;
    final regions = this.regions;
    return {
      if (findingAggregationRegion != null)
        'FindingAggregationRegion': findingAggregationRegion,
      if (findingAggregatorArn != null)
        'FindingAggregatorArn': findingAggregatorArn,
      if (regionLinkingMode != null) 'RegionLinkingMode': regionLinkingMode,
      if (regions != null) 'Regions': regions,
    };
  }
}

class CreateInsightResponse {
  /// The ARN of the insight created.
  final String insightArn;

  CreateInsightResponse({
    required this.insightArn,
  });

  factory CreateInsightResponse.fromJson(Map<String, dynamic> json) {
    return CreateInsightResponse(
      insightArn: json['InsightArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final insightArn = this.insightArn;
    return {
      'InsightArn': insightArn,
    };
  }
}

class CreateMembersResponse {
  /// The list of Amazon Web Services accounts that were not processed. For each
  /// account, the list includes the account ID and the email address.
  final List<Result>? unprocessedAccounts;

  CreateMembersResponse({
    this.unprocessedAccounts,
  });

  factory CreateMembersResponse.fromJson(Map<String, dynamic> json) {
    return CreateMembersResponse(
      unprocessedAccounts: (json['UnprocessedAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final unprocessedAccounts = this.unprocessedAccounts;
    return {
      if (unprocessedAccounts != null)
        'UnprocessedAccounts': unprocessedAccounts,
    };
  }
}

/// The list of detected instances of sensitive data.
class CustomDataIdentifiersDetections {
  /// The ARN of the custom identifier that was used to detect the sensitive data.
  final String? arn;

  /// The total number of occurrences of sensitive data that were detected.
  final int? count;

  /// he name of the custom identifier that detected the sensitive data.
  final String? name;

  /// Details about the sensitive data that was detected.
  final Occurrences? occurrences;

  CustomDataIdentifiersDetections({
    this.arn,
    this.count,
    this.name,
    this.occurrences,
  });

  factory CustomDataIdentifiersDetections.fromJson(Map<String, dynamic> json) {
    return CustomDataIdentifiersDetections(
      arn: json['Arn'] as String?,
      count: json['Count'] as int?,
      name: json['Name'] as String?,
      occurrences: json['Occurrences'] != null
          ? Occurrences.fromJson(json['Occurrences'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final count = this.count;
    final name = this.name;
    final occurrences = this.occurrences;
    return {
      if (arn != null) 'Arn': arn,
      if (count != null) 'Count': count,
      if (name != null) 'Name': name,
      if (occurrences != null) 'Occurrences': occurrences,
    };
  }
}

/// Contains an instance of sensitive data that was detected by a
/// customer-defined identifier.
class CustomDataIdentifiersResult {
  /// The list of detected instances of sensitive data.
  final List<CustomDataIdentifiersDetections>? detections;

  /// The total number of occurrences of sensitive data.
  final int? totalCount;

  CustomDataIdentifiersResult({
    this.detections,
    this.totalCount,
  });

  factory CustomDataIdentifiersResult.fromJson(Map<String, dynamic> json) {
    return CustomDataIdentifiersResult(
      detections: (json['Detections'] as List?)
          ?.whereNotNull()
          .map((e) => CustomDataIdentifiersDetections.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      totalCount: json['TotalCount'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final detections = this.detections;
    final totalCount = this.totalCount;
    return {
      if (detections != null) 'Detections': detections,
      if (totalCount != null) 'TotalCount': totalCount,
    };
  }
}

/// CVSS scores from the advisory related to the vulnerability.
class Cvss {
  /// Adjustments to the CVSS metrics.
  final List<Adjustment>? adjustments;

  /// The base CVSS score.
  final double? baseScore;

  /// The base scoring vector for the CVSS score.
  final String? baseVector;

  /// The origin of the original CVSS score and vector.
  final String? source;

  /// The version of CVSS for the CVSS score.
  final String? version;

  Cvss({
    this.adjustments,
    this.baseScore,
    this.baseVector,
    this.source,
    this.version,
  });

  factory Cvss.fromJson(Map<String, dynamic> json) {
    return Cvss(
      adjustments: (json['Adjustments'] as List?)
          ?.whereNotNull()
          .map((e) => Adjustment.fromJson(e as Map<String, dynamic>))
          .toList(),
      baseScore: json['BaseScore'] as double?,
      baseVector: json['BaseVector'] as String?,
      source: json['Source'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final adjustments = this.adjustments;
    final baseScore = this.baseScore;
    final baseVector = this.baseVector;
    final source = this.source;
    final version = this.version;
    return {
      if (adjustments != null) 'Adjustments': adjustments,
      if (baseScore != null) 'BaseScore': baseScore,
      if (baseVector != null) 'BaseVector': baseVector,
      if (source != null) 'Source': source,
      if (version != null) 'Version': version,
    };
  }
}

/// Provides details about sensitive data that was detected on a resource.
class DataClassificationDetails {
  /// The path to the folder or file that contains the sensitive data.
  final String? detailedResultsLocation;

  /// The details about the sensitive data that was detected on the resource.
  final ClassificationResult? result;

  DataClassificationDetails({
    this.detailedResultsLocation,
    this.result,
  });

  factory DataClassificationDetails.fromJson(Map<String, dynamic> json) {
    return DataClassificationDetails(
      detailedResultsLocation: json['DetailedResultsLocation'] as String?,
      result: json['Result'] != null
          ? ClassificationResult.fromJson(
              json['Result'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final detailedResultsLocation = this.detailedResultsLocation;
    final result = this.result;
    return {
      if (detailedResultsLocation != null)
        'DetailedResultsLocation': detailedResultsLocation,
      if (result != null) 'Result': result,
    };
  }
}

/// A date filter for querying findings.
class DateFilter {
  /// A date range for the date filter.
  final DateRange? dateRange;

  /// A timestamp that provides the end date for the date filter.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? end;

  /// A timestamp that provides the start date for the date filter.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? start;

  DateFilter({
    this.dateRange,
    this.end,
    this.start,
  });

  factory DateFilter.fromJson(Map<String, dynamic> json) {
    return DateFilter(
      dateRange: json['DateRange'] != null
          ? DateRange.fromJson(json['DateRange'] as Map<String, dynamic>)
          : null,
      end: json['End'] as String?,
      start: json['Start'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dateRange = this.dateRange;
    final end = this.end;
    final start = this.start;
    return {
      if (dateRange != null) 'DateRange': dateRange,
      if (end != null) 'End': end,
      if (start != null) 'Start': start,
    };
  }
}

/// A date range for the date filter.
class DateRange {
  /// A date range unit for the date filter.
  final DateRangeUnit? unit;

  /// A date range value for the date filter.
  final int? value;

  DateRange({
    this.unit,
    this.value,
  });

  factory DateRange.fromJson(Map<String, dynamic> json) {
    return DateRange(
      unit: (json['Unit'] as String?)?.toDateRangeUnit(),
      value: json['Value'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final unit = this.unit;
    final value = this.value;
    return {
      if (unit != null) 'Unit': unit.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

enum DateRangeUnit {
  days,
}

extension DateRangeUnitValueExtension on DateRangeUnit {
  String toValue() {
    switch (this) {
      case DateRangeUnit.days:
        return 'DAYS';
    }
  }
}

extension DateRangeUnitFromString on String {
  DateRangeUnit toDateRangeUnit() {
    switch (this) {
      case 'DAYS':
        return DateRangeUnit.days;
    }
    throw Exception('$this is not known in enum DateRangeUnit');
  }
}

class DeclineInvitationsResponse {
  /// The list of Amazon Web Services accounts that were not processed. For each
  /// account, the list includes the account ID and the email address.
  final List<Result>? unprocessedAccounts;

  DeclineInvitationsResponse({
    this.unprocessedAccounts,
  });

  factory DeclineInvitationsResponse.fromJson(Map<String, dynamic> json) {
    return DeclineInvitationsResponse(
      unprocessedAccounts: (json['UnprocessedAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final unprocessedAccounts = this.unprocessedAccounts;
    return {
      if (unprocessedAccounts != null)
        'UnprocessedAccounts': unprocessedAccounts,
    };
  }
}

class DeleteActionTargetResponse {
  /// The ARN of the custom action target that was deleted.
  final String actionTargetArn;

  DeleteActionTargetResponse({
    required this.actionTargetArn,
  });

  factory DeleteActionTargetResponse.fromJson(Map<String, dynamic> json) {
    return DeleteActionTargetResponse(
      actionTargetArn: json['ActionTargetArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final actionTargetArn = this.actionTargetArn;
    return {
      'ActionTargetArn': actionTargetArn,
    };
  }
}

class DeleteConfigurationPolicyResponse {
  DeleteConfigurationPolicyResponse();

  factory DeleteConfigurationPolicyResponse.fromJson(Map<String, dynamic> _) {
    return DeleteConfigurationPolicyResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteFindingAggregatorResponse {
  DeleteFindingAggregatorResponse();

  factory DeleteFindingAggregatorResponse.fromJson(Map<String, dynamic> _) {
    return DeleteFindingAggregatorResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteInsightResponse {
  /// The ARN of the insight that was deleted.
  final String insightArn;

  DeleteInsightResponse({
    required this.insightArn,
  });

  factory DeleteInsightResponse.fromJson(Map<String, dynamic> json) {
    return DeleteInsightResponse(
      insightArn: json['InsightArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final insightArn = this.insightArn;
    return {
      'InsightArn': insightArn,
    };
  }
}

class DeleteInvitationsResponse {
  /// The list of Amazon Web Services accounts for which the invitations were not
  /// deleted. For each account, the list includes the account ID and the email
  /// address.
  final List<Result>? unprocessedAccounts;

  DeleteInvitationsResponse({
    this.unprocessedAccounts,
  });

  factory DeleteInvitationsResponse.fromJson(Map<String, dynamic> json) {
    return DeleteInvitationsResponse(
      unprocessedAccounts: (json['UnprocessedAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final unprocessedAccounts = this.unprocessedAccounts;
    return {
      if (unprocessedAccounts != null)
        'UnprocessedAccounts': unprocessedAccounts,
    };
  }
}

class DeleteMembersResponse {
  /// The list of Amazon Web Services accounts that were not deleted. For each
  /// account, the list includes the account ID and the email address.
  final List<Result>? unprocessedAccounts;

  DeleteMembersResponse({
    this.unprocessedAccounts,
  });

  factory DeleteMembersResponse.fromJson(Map<String, dynamic> json) {
    return DeleteMembersResponse(
      unprocessedAccounts: (json['UnprocessedAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final unprocessedAccounts = this.unprocessedAccounts;
    return {
      if (unprocessedAccounts != null)
        'UnprocessedAccounts': unprocessedAccounts,
    };
  }
}

class DescribeActionTargetsResponse {
  /// A list of <code>ActionTarget</code> objects. Each object includes the
  /// <code>ActionTargetArn</code>, <code>Description</code>, and
  /// <code>Name</code> of a custom action target available in Security Hub.
  final List<ActionTarget> actionTargets;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  DescribeActionTargetsResponse({
    required this.actionTargets,
    this.nextToken,
  });

  factory DescribeActionTargetsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeActionTargetsResponse(
      actionTargets: (json['ActionTargets'] as List)
          .whereNotNull()
          .map((e) => ActionTarget.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final actionTargets = this.actionTargets;
    final nextToken = this.nextToken;
    return {
      'ActionTargets': actionTargets,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class DescribeHubResponse {
  /// Whether to automatically enable new controls when they are added to
  /// standards that are enabled.
  ///
  /// If set to <code>true</code>, then new controls for enabled standards are
  /// enabled automatically. If set to <code>false</code>, then new controls are
  /// not enabled.
  final bool? autoEnableControls;

  /// Specifies whether the calling account has consolidated control findings
  /// turned on. If the value for this field is set to
  /// <code>SECURITY_CONTROL</code>, Security Hub generates a single finding for a
  /// control check even when the check applies to multiple enabled standards.
  ///
  /// If the value for this field is set to <code>STANDARD_CONTROL</code>,
  /// Security Hub generates separate findings for a control check when the check
  /// applies to multiple enabled standards.
  ///
  /// The value for this field in a member account matches the value in the
  /// administrator account. For accounts that aren't part of an organization, the
  /// default value of this field is <code>SECURITY_CONTROL</code> if you enabled
  /// Security Hub on or after February 23, 2023.
  final ControlFindingGenerator? controlFindingGenerator;

  /// The ARN of the Hub resource that was retrieved.
  final String? hubArn;

  /// The date and time when Security Hub was enabled in the account.
  final String? subscribedAt;

  DescribeHubResponse({
    this.autoEnableControls,
    this.controlFindingGenerator,
    this.hubArn,
    this.subscribedAt,
  });

  factory DescribeHubResponse.fromJson(Map<String, dynamic> json) {
    return DescribeHubResponse(
      autoEnableControls: json['AutoEnableControls'] as bool?,
      controlFindingGenerator: (json['ControlFindingGenerator'] as String?)
          ?.toControlFindingGenerator(),
      hubArn: json['HubArn'] as String?,
      subscribedAt: json['SubscribedAt'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final autoEnableControls = this.autoEnableControls;
    final controlFindingGenerator = this.controlFindingGenerator;
    final hubArn = this.hubArn;
    final subscribedAt = this.subscribedAt;
    return {
      if (autoEnableControls != null) 'AutoEnableControls': autoEnableControls,
      if (controlFindingGenerator != null)
        'ControlFindingGenerator': controlFindingGenerator.toValue(),
      if (hubArn != null) 'HubArn': hubArn,
      if (subscribedAt != null) 'SubscribedAt': subscribedAt,
    };
  }
}

class DescribeOrganizationConfigurationResponse {
  /// Whether to automatically enable Security Hub in new member accounts when
  /// they join the organization.
  ///
  /// If set to <code>true</code>, then Security Hub is automatically enabled in
  /// new accounts. If set to <code>false</code>, then Security Hub isn't enabled
  /// in new accounts automatically. The default value is <code>false</code>.
  ///
  /// If the <code>ConfigurationType</code> of your organization is set to
  /// <code>CENTRAL</code>, then this field is set to <code>false</code> and can't
  /// be changed in the home Region and linked Regions. However, in that case, the
  /// delegated administrator can create a configuration policy in which Security
  /// Hub is enabled and associate the policy with new organization accounts.
  final bool? autoEnable;

  /// Whether to automatically enable Security Hub <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-enable-disable.html">default
  /// standards</a> in new member accounts when they join the organization.
  ///
  /// If equal to <code>DEFAULT</code>, then Security Hub default standards are
  /// automatically enabled for new member accounts. If equal to
  /// <code>NONE</code>, then default standards are not automatically enabled for
  /// new member accounts. The default value of this parameter is equal to
  /// <code>DEFAULT</code>.
  ///
  /// If the <code>ConfigurationType</code> of your organization is set to
  /// <code>CENTRAL</code>, then this field is set to <code>NONE</code> and can't
  /// be changed in the home Region and linked Regions. However, in that case, the
  /// delegated administrator can create a configuration policy in which specific
  /// security standards are enabled and associate the policy with new
  /// organization accounts.
  final AutoEnableStandards? autoEnableStandards;

  /// Whether the maximum number of allowed member accounts are already associated
  /// with the Security Hub administrator account.
  final bool? memberAccountLimitReached;
  final OrganizationConfiguration? organizationConfiguration;

  DescribeOrganizationConfigurationResponse({
    this.autoEnable,
    this.autoEnableStandards,
    this.memberAccountLimitReached,
    this.organizationConfiguration,
  });

  factory DescribeOrganizationConfigurationResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeOrganizationConfigurationResponse(
      autoEnable: json['AutoEnable'] as bool?,
      autoEnableStandards:
          (json['AutoEnableStandards'] as String?)?.toAutoEnableStandards(),
      memberAccountLimitReached: json['MemberAccountLimitReached'] as bool?,
      organizationConfiguration: json['OrganizationConfiguration'] != null
          ? OrganizationConfiguration.fromJson(
              json['OrganizationConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final autoEnable = this.autoEnable;
    final autoEnableStandards = this.autoEnableStandards;
    final memberAccountLimitReached = this.memberAccountLimitReached;
    final organizationConfiguration = this.organizationConfiguration;
    return {
      if (autoEnable != null) 'AutoEnable': autoEnable,
      if (autoEnableStandards != null)
        'AutoEnableStandards': autoEnableStandards.toValue(),
      if (memberAccountLimitReached != null)
        'MemberAccountLimitReached': memberAccountLimitReached,
      if (organizationConfiguration != null)
        'OrganizationConfiguration': organizationConfiguration,
    };
  }
}

class DescribeProductsResponse {
  /// A list of products, including details for each product.
  final List<Product> products;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  DescribeProductsResponse({
    required this.products,
    this.nextToken,
  });

  factory DescribeProductsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeProductsResponse(
      products: (json['Products'] as List)
          .whereNotNull()
          .map((e) => Product.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final products = this.products;
    final nextToken = this.nextToken;
    return {
      'Products': products,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class DescribeStandardsControlsResponse {
  /// A list of security standards controls.
  final List<StandardsControl>? controls;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  DescribeStandardsControlsResponse({
    this.controls,
    this.nextToken,
  });

  factory DescribeStandardsControlsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeStandardsControlsResponse(
      controls: (json['Controls'] as List?)
          ?.whereNotNull()
          .map((e) => StandardsControl.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final controls = this.controls;
    final nextToken = this.nextToken;
    return {
      if (controls != null) 'Controls': controls,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class DescribeStandardsResponse {
  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  /// A list of available standards.
  final List<Standard>? standards;

  DescribeStandardsResponse({
    this.nextToken,
    this.standards,
  });

  factory DescribeStandardsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeStandardsResponse(
      nextToken: json['NextToken'] as String?,
      standards: (json['Standards'] as List?)
          ?.whereNotNull()
          .map((e) => Standard.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final standards = this.standards;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (standards != null) 'Standards': standards,
    };
  }
}

class DisableImportFindingsForProductResponse {
  DisableImportFindingsForProductResponse();

  factory DisableImportFindingsForProductResponse.fromJson(
      Map<String, dynamic> _) {
    return DisableImportFindingsForProductResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisableOrganizationAdminAccountResponse {
  DisableOrganizationAdminAccountResponse();

  factory DisableOrganizationAdminAccountResponse.fromJson(
      Map<String, dynamic> _) {
    return DisableOrganizationAdminAccountResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisableSecurityHubResponse {
  DisableSecurityHubResponse();

  factory DisableSecurityHubResponse.fromJson(Map<String, dynamic> _) {
    return DisableSecurityHubResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisassociateFromAdministratorAccountResponse {
  DisassociateFromAdministratorAccountResponse();

  factory DisassociateFromAdministratorAccountResponse.fromJson(
      Map<String, dynamic> _) {
    return DisassociateFromAdministratorAccountResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisassociateFromMasterAccountResponse {
  DisassociateFromMasterAccountResponse();

  factory DisassociateFromMasterAccountResponse.fromJson(
      Map<String, dynamic> _) {
    return DisassociateFromMasterAccountResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisassociateMembersResponse {
  DisassociateMembersResponse();

  factory DisassociateMembersResponse.fromJson(Map<String, dynamic> _) {
    return DisassociateMembersResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Provided if <code>ActionType</code> is <code>DNS_REQUEST</code>. It provides
/// details about the DNS request that was detected.
class DnsRequestAction {
  /// Indicates whether the DNS request was blocked.
  final bool? blocked;

  /// The DNS domain that is associated with the DNS request.
  ///
  /// Length Constraints: 128.
  final String? domain;

  /// The protocol that was used for the DNS request.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 64.
  final String? protocol;

  DnsRequestAction({
    this.blocked,
    this.domain,
    this.protocol,
  });

  factory DnsRequestAction.fromJson(Map<String, dynamic> json) {
    return DnsRequestAction(
      blocked: json['Blocked'] as bool?,
      domain: json['Domain'] as String?,
      protocol: json['Protocol'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final blocked = this.blocked;
    final domain = this.domain;
    final protocol = this.protocol;
    return {
      if (blocked != null) 'Blocked': blocked,
      if (domain != null) 'Domain': domain,
      if (protocol != null) 'Protocol': protocol,
    };
  }
}

/// The options for customizing a security control parameter that is a double.
class DoubleConfigurationOptions {
  /// The Security Hub default value for a control parameter that is a double.
  final double? defaultValue;

  /// The maximum valid value for a control parameter that is a double.
  final double? max;

  /// The minimum valid value for a control parameter that is a double.
  final double? min;

  DoubleConfigurationOptions({
    this.defaultValue,
    this.max,
    this.min,
  });

  factory DoubleConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return DoubleConfigurationOptions(
      defaultValue: json['DefaultValue'] as double?,
      max: json['Max'] as double?,
      min: json['Min'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    final max = this.max;
    final min = this.min;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

class EnableImportFindingsForProductResponse {
  /// The ARN of your subscription to the product to enable integrations for.
  final String? productSubscriptionArn;

  EnableImportFindingsForProductResponse({
    this.productSubscriptionArn,
  });

  factory EnableImportFindingsForProductResponse.fromJson(
      Map<String, dynamic> json) {
    return EnableImportFindingsForProductResponse(
      productSubscriptionArn: json['ProductSubscriptionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final productSubscriptionArn = this.productSubscriptionArn;
    return {
      if (productSubscriptionArn != null)
        'ProductSubscriptionArn': productSubscriptionArn,
    };
  }
}

class EnableOrganizationAdminAccountResponse {
  EnableOrganizationAdminAccountResponse();

  factory EnableOrganizationAdminAccountResponse.fromJson(
      Map<String, dynamic> _) {
    return EnableOrganizationAdminAccountResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class EnableSecurityHubResponse {
  EnableSecurityHubResponse();

  factory EnableSecurityHubResponse.fromJson(Map<String, dynamic> _) {
    return EnableSecurityHubResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The options for customizing a security control parameter that is an enum.
class EnumConfigurationOptions {
  /// The valid values for a control parameter that is an enum.
  final List<String>? allowedValues;

  /// The Security Hub default value for a control parameter that is an enum.
  final String? defaultValue;

  EnumConfigurationOptions({
    this.allowedValues,
    this.defaultValue,
  });

  factory EnumConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return EnumConfigurationOptions(
      allowedValues: (json['AllowedValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      defaultValue: json['DefaultValue'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final allowedValues = this.allowedValues;
    final defaultValue = this.defaultValue;
    return {
      if (allowedValues != null) 'AllowedValues': allowedValues,
      if (defaultValue != null) 'DefaultValue': defaultValue,
    };
  }
}

/// The options for customizing a security control parameter that is a list of
/// enums.
class EnumListConfigurationOptions {
  /// The valid values for a control parameter that is a list of enums.
  final List<String>? allowedValues;

  /// The Security Hub default value for a control parameter that is a list of
  /// enums.
  final List<String>? defaultValue;

  /// The maximum number of list items that an enum list control parameter can
  /// accept.
  final int? maxItems;

  EnumListConfigurationOptions({
    this.allowedValues,
    this.defaultValue,
    this.maxItems,
  });

  factory EnumListConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return EnumListConfigurationOptions(
      allowedValues: (json['AllowedValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      defaultValue: (json['DefaultValue'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      maxItems: json['MaxItems'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final allowedValues = this.allowedValues;
    final defaultValue = this.defaultValue;
    final maxItems = this.maxItems;
    return {
      if (allowedValues != null) 'AllowedValues': allowedValues,
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (maxItems != null) 'MaxItems': maxItems,
    };
  }
}

/// Provides information about the file paths that were affected by the threat.
class FilePaths {
  /// The name of the infected or suspicious file corresponding to the hash.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 128 length.
  final String? fileName;

  /// Path to the infected or suspicious file on the resource it was detected on.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 128 length.
  final String? filePath;

  /// The hash value for the infected or suspicious file.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 128 length.
  final String? hash;

  /// The Amazon Resource Name (ARN) of the resource on which the threat was
  /// detected.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 128 length.
  final String? resourceId;

  FilePaths({
    this.fileName,
    this.filePath,
    this.hash,
    this.resourceId,
  });

  factory FilePaths.fromJson(Map<String, dynamic> json) {
    return FilePaths(
      fileName: json['FileName'] as String?,
      filePath: json['FilePath'] as String?,
      hash: json['Hash'] as String?,
      resourceId: json['ResourceId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fileName = this.fileName;
    final filePath = this.filePath;
    final hash = this.hash;
    final resourceId = this.resourceId;
    return {
      if (fileName != null) 'FileName': fileName,
      if (filePath != null) 'FilePath': filePath,
      if (hash != null) 'Hash': hash,
      if (resourceId != null) 'ResourceId': resourceId,
    };
  }
}

/// A finding aggregator. A finding aggregator contains the configuration for
/// finding aggregation.
class FindingAggregator {
  /// The ARN of the finding aggregator. You use the finding aggregator ARN to
  /// retrieve details for, update, and delete the finding aggregator.
  final String? findingAggregatorArn;

  FindingAggregator({
    this.findingAggregatorArn,
  });

  factory FindingAggregator.fromJson(Map<String, dynamic> json) {
    return FindingAggregator(
      findingAggregatorArn: json['FindingAggregatorArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final findingAggregatorArn = this.findingAggregatorArn;
    return {
      if (findingAggregatorArn != null)
        'FindingAggregatorArn': findingAggregatorArn,
    };
  }
}

/// A list of events that changed the specified finding during the specified
/// time period. Each record represents a single finding change event.
class FindingHistoryRecord {
  /// Identifies whether the event marks the creation of a new finding. A value of
  /// <code>True</code> means that the finding is newly created. A value of
  /// <code>False</code> means that the finding isn’t newly created.
  final bool? findingCreated;
  final AwsSecurityFindingIdentifier? findingIdentifier;

  /// A token for pagination purposes. Provide this token in the subsequent
  /// request to <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_GetFindingsHistory.html">
  /// <code>GetFindingsHistory</code> </a> to get up to an additional 100 results
  /// of history for the same finding that you specified in your initial request.
  final String? nextToken;

  /// Identifies the source of the event that changed the finding. For example, an
  /// integrated Amazon Web Service or third-party partner integration may call <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html">
  /// <code>BatchImportFindings</code> </a>, or an Security Hub customer may call
  /// <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html">
  /// <code>BatchUpdateFindings</code> </a>.
  final FindingHistoryUpdateSource? updateSource;

  /// A timestamp that indicates when Security Hub processed the updated finding
  /// record.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final DateTime? updateTime;

  /// An array of objects that provides details about the finding change event,
  /// including the Amazon Web Services Security Finding Format (ASFF) field that
  /// changed, the value of the field before the change, and the value of the
  /// field after the change.
  final List<FindingHistoryUpdate>? updates;

  FindingHistoryRecord({
    this.findingCreated,
    this.findingIdentifier,
    this.nextToken,
    this.updateSource,
    this.updateTime,
    this.updates,
  });

  factory FindingHistoryRecord.fromJson(Map<String, dynamic> json) {
    return FindingHistoryRecord(
      findingCreated: json['FindingCreated'] as bool?,
      findingIdentifier: json['FindingIdentifier'] != null
          ? AwsSecurityFindingIdentifier.fromJson(
              json['FindingIdentifier'] as Map<String, dynamic>)
          : null,
      nextToken: json['NextToken'] as String?,
      updateSource: json['UpdateSource'] != null
          ? FindingHistoryUpdateSource.fromJson(
              json['UpdateSource'] as Map<String, dynamic>)
          : null,
      updateTime: timeStampFromJson(json['UpdateTime']),
      updates: (json['Updates'] as List?)
          ?.whereNotNull()
          .map((e) => FindingHistoryUpdate.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final findingCreated = this.findingCreated;
    final findingIdentifier = this.findingIdentifier;
    final nextToken = this.nextToken;
    final updateSource = this.updateSource;
    final updateTime = this.updateTime;
    final updates = this.updates;
    return {
      if (findingCreated != null) 'FindingCreated': findingCreated,
      if (findingIdentifier != null) 'FindingIdentifier': findingIdentifier,
      if (nextToken != null) 'NextToken': nextToken,
      if (updateSource != null) 'UpdateSource': updateSource,
      if (updateTime != null) 'UpdateTime': iso8601ToJson(updateTime),
      if (updates != null) 'Updates': updates,
    };
  }
}

/// An array of objects that provides details about a change to a finding,
/// including the Amazon Web Services Security Finding Format (ASFF) field that
/// changed, the value of the field before the change, and the value of the
/// field after the change.
class FindingHistoryUpdate {
  /// The value of the ASFF field after the finding change event. To preserve
  /// storage and readability, Security Hub omits this value if <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_FindingHistoryRecord.html">
  /// <code>FindingHistoryRecord</code> </a> exceeds database limits.
  final String? newValue;

  /// The value of the ASFF field before the finding change event.
  final String? oldValue;

  /// The ASFF field that changed during the finding change event.
  final String? updatedField;

  FindingHistoryUpdate({
    this.newValue,
    this.oldValue,
    this.updatedField,
  });

  factory FindingHistoryUpdate.fromJson(Map<String, dynamic> json) {
    return FindingHistoryUpdate(
      newValue: json['NewValue'] as String?,
      oldValue: json['OldValue'] as String?,
      updatedField: json['UpdatedField'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final newValue = this.newValue;
    final oldValue = this.oldValue;
    final updatedField = this.updatedField;
    return {
      if (newValue != null) 'NewValue': newValue,
      if (oldValue != null) 'OldValue': oldValue,
      if (updatedField != null) 'UpdatedField': updatedField,
    };
  }
}

/// Identifies the source of the finding change event.
class FindingHistoryUpdateSource {
  /// The identity of the source that initiated the finding change event. For
  /// example, the Amazon Resource Name (ARN) of a partner that calls
  /// BatchImportFindings or of a customer that calls BatchUpdateFindings.
  final String? identity;

  /// Describes the type of finding change event, such as a call to <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchImportFindings.html">
  /// <code>BatchImportFindings</code> </a> (by an integrated Amazon Web Service
  /// or third party partner integration) or <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateFindings.html">
  /// <code>BatchUpdateFindings</code> </a> (by a Security Hub customer).
  final FindingHistoryUpdateSourceType? type;

  FindingHistoryUpdateSource({
    this.identity,
    this.type,
  });

  factory FindingHistoryUpdateSource.fromJson(Map<String, dynamic> json) {
    return FindingHistoryUpdateSource(
      identity: json['Identity'] as String?,
      type: (json['Type'] as String?)?.toFindingHistoryUpdateSourceType(),
    );
  }

  Map<String, dynamic> toJson() {
    final identity = this.identity;
    final type = this.type;
    return {
      if (identity != null) 'Identity': identity,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum FindingHistoryUpdateSourceType {
  batchUpdateFindings,
  batchImportFindings,
}

extension FindingHistoryUpdateSourceTypeValueExtension
    on FindingHistoryUpdateSourceType {
  String toValue() {
    switch (this) {
      case FindingHistoryUpdateSourceType.batchUpdateFindings:
        return 'BATCH_UPDATE_FINDINGS';
      case FindingHistoryUpdateSourceType.batchImportFindings:
        return 'BATCH_IMPORT_FINDINGS';
    }
  }
}

extension FindingHistoryUpdateSourceTypeFromString on String {
  FindingHistoryUpdateSourceType toFindingHistoryUpdateSourceType() {
    switch (this) {
      case 'BATCH_UPDATE_FINDINGS':
        return FindingHistoryUpdateSourceType.batchUpdateFindings;
      case 'BATCH_IMPORT_FINDINGS':
        return FindingHistoryUpdateSourceType.batchImportFindings;
    }
    throw Exception(
        '$this is not known in enum FindingHistoryUpdateSourceType');
  }
}

/// In a <code>BatchImportFindings</code> request, finding providers use
/// <code>FindingProviderFields</code> to provide and update values for
/// confidence, criticality, related findings, severity, and types.
class FindingProviderFields {
  /// A finding's confidence. Confidence is defined as the likelihood that a
  /// finding accurately identifies the behavior or issue that it was intended to
  /// identify.
  ///
  /// Confidence is scored on a 0-100 basis using a ratio scale, where 0 means
  /// zero percent confidence and 100 means 100 percent confidence.
  final int? confidence;

  /// The level of importance assigned to the resources associated with the
  /// finding.
  ///
  /// A score of 0 means that the underlying resources have no criticality, and a
  /// score of 100 is reserved for the most critical resources.
  final int? criticality;

  /// A list of findings that are related to the current finding.
  final List<RelatedFinding>? relatedFindings;

  /// The severity of a finding.
  final FindingProviderSeverity? severity;

  /// One or more finding types in the format of
  /// <code>namespace/category/classifier</code> that classify a finding.
  ///
  /// Valid namespace values are: Software and Configuration Checks | TTPs |
  /// Effects | Unusual Behaviors | Sensitive Data Identifications
  final List<String>? types;

  FindingProviderFields({
    this.confidence,
    this.criticality,
    this.relatedFindings,
    this.severity,
    this.types,
  });

  factory FindingProviderFields.fromJson(Map<String, dynamic> json) {
    return FindingProviderFields(
      confidence: json['Confidence'] as int?,
      criticality: json['Criticality'] as int?,
      relatedFindings: (json['RelatedFindings'] as List?)
          ?.whereNotNull()
          .map((e) => RelatedFinding.fromJson(e as Map<String, dynamic>))
          .toList(),
      severity: json['Severity'] != null
          ? FindingProviderSeverity.fromJson(
              json['Severity'] as Map<String, dynamic>)
          : null,
      types: (json['Types'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final confidence = this.confidence;
    final criticality = this.criticality;
    final relatedFindings = this.relatedFindings;
    final severity = this.severity;
    final types = this.types;
    return {
      if (confidence != null) 'Confidence': confidence,
      if (criticality != null) 'Criticality': criticality,
      if (relatedFindings != null) 'RelatedFindings': relatedFindings,
      if (severity != null) 'Severity': severity,
      if (types != null) 'Types': types,
    };
  }
}

/// The severity assigned to the finding by the finding provider.
class FindingProviderSeverity {
  /// The severity label assigned to the finding by the finding provider.
  final SeverityLabel? label;

  /// The finding provider's original value for the severity.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 64.
  final String? original;

  FindingProviderSeverity({
    this.label,
    this.original,
  });

  factory FindingProviderSeverity.fromJson(Map<String, dynamic> json) {
    return FindingProviderSeverity(
      label: (json['Label'] as String?)?.toSeverityLabel(),
      original: json['Original'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final label = this.label;
    final original = this.original;
    return {
      if (label != null) 'Label': label.toValue(),
      if (original != null) 'Original': original,
    };
  }
}

/// Defines the behavior of the firewall.
class FirewallPolicyDetails {
  /// The stateful rule groups that are used in the firewall policy.
  final List<FirewallPolicyStatefulRuleGroupReferencesDetails>?
      statefulRuleGroupReferences;

  /// The custom action definitions that are available to use in the firewall
  /// policy's <code>StatelessDefaultActions</code> setting.
  final List<FirewallPolicyStatelessCustomActionsDetails>?
      statelessCustomActions;

  /// The actions to take on a packet if it doesn't match any of the stateless
  /// rules in the policy.
  ///
  /// You must specify a standard action (<code>aws:pass</code>,
  /// <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally
  /// include a custom action from <code>StatelessCustomActions</code>.
  final List<String>? statelessDefaultActions;

  /// The actions to take on a fragmented UDP packet if it doesn't match any of
  /// the stateless rules in the policy.
  ///
  /// You must specify a standard action (<code>aws:pass</code>,
  /// <code>aws:drop</code>, <code>aws:forward_to_sfe</code>), and can optionally
  /// include a custom action from <code>StatelessCustomActions</code>.
  final List<String>? statelessFragmentDefaultActions;

  /// The stateless rule groups that are used in the firewall policy.
  final List<FirewallPolicyStatelessRuleGroupReferencesDetails>?
      statelessRuleGroupReferences;

  FirewallPolicyDetails({
    this.statefulRuleGroupReferences,
    this.statelessCustomActions,
    this.statelessDefaultActions,
    this.statelessFragmentDefaultActions,
    this.statelessRuleGroupReferences,
  });

  factory FirewallPolicyDetails.fromJson(Map<String, dynamic> json) {
    return FirewallPolicyDetails(
      statefulRuleGroupReferences: (json['StatefulRuleGroupReferences']
              as List?)
          ?.whereNotNull()
          .map((e) => FirewallPolicyStatefulRuleGroupReferencesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      statelessCustomActions: (json['StatelessCustomActions'] as List?)
          ?.whereNotNull()
          .map((e) => FirewallPolicyStatelessCustomActionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      statelessDefaultActions: (json['StatelessDefaultActions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      statelessFragmentDefaultActions:
          (json['StatelessFragmentDefaultActions'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      statelessRuleGroupReferences:
          (json['StatelessRuleGroupReferences'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  FirewallPolicyStatelessRuleGroupReferencesDetails.fromJson(
                      e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final statefulRuleGroupReferences = this.statefulRuleGroupReferences;
    final statelessCustomActions = this.statelessCustomActions;
    final statelessDefaultActions = this.statelessDefaultActions;
    final statelessFragmentDefaultActions =
        this.statelessFragmentDefaultActions;
    final statelessRuleGroupReferences = this.statelessRuleGroupReferences;
    return {
      if (statefulRuleGroupReferences != null)
        'StatefulRuleGroupReferences': statefulRuleGroupReferences,
      if (statelessCustomActions != null)
        'StatelessCustomActions': statelessCustomActions,
      if (statelessDefaultActions != null)
        'StatelessDefaultActions': statelessDefaultActions,
      if (statelessFragmentDefaultActions != null)
        'StatelessFragmentDefaultActions': statelessFragmentDefaultActions,
      if (statelessRuleGroupReferences != null)
        'StatelessRuleGroupReferences': statelessRuleGroupReferences,
    };
  }
}

/// A stateful rule group that is used by the firewall policy.
class FirewallPolicyStatefulRuleGroupReferencesDetails {
  /// The ARN of the stateful rule group.
  final String? resourceArn;

  FirewallPolicyStatefulRuleGroupReferencesDetails({
    this.resourceArn,
  });

  factory FirewallPolicyStatefulRuleGroupReferencesDetails.fromJson(
      Map<String, dynamic> json) {
    return FirewallPolicyStatefulRuleGroupReferencesDetails(
      resourceArn: json['ResourceArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final resourceArn = this.resourceArn;
    return {
      if (resourceArn != null) 'ResourceArn': resourceArn,
    };
  }
}

/// A custom action that can be used for stateless packet handling.
class FirewallPolicyStatelessCustomActionsDetails {
  /// The definition of the custom action.
  final StatelessCustomActionDefinition? actionDefinition;

  /// The name of the custom action.
  final String? actionName;

  FirewallPolicyStatelessCustomActionsDetails({
    this.actionDefinition,
    this.actionName,
  });

  factory FirewallPolicyStatelessCustomActionsDetails.fromJson(
      Map<String, dynamic> json) {
    return FirewallPolicyStatelessCustomActionsDetails(
      actionDefinition: json['ActionDefinition'] != null
          ? StatelessCustomActionDefinition.fromJson(
              json['ActionDefinition'] as Map<String, dynamic>)
          : null,
      actionName: json['ActionName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final actionDefinition = this.actionDefinition;
    final actionName = this.actionName;
    return {
      if (actionDefinition != null) 'ActionDefinition': actionDefinition,
      if (actionName != null) 'ActionName': actionName,
    };
  }
}

/// A stateless rule group that is used by the firewall policy.
class FirewallPolicyStatelessRuleGroupReferencesDetails {
  /// The order in which to run the stateless rule group.
  final int? priority;

  /// The ARN of the stateless rule group.
  final String? resourceArn;

  FirewallPolicyStatelessRuleGroupReferencesDetails({
    this.priority,
    this.resourceArn,
  });

  factory FirewallPolicyStatelessRuleGroupReferencesDetails.fromJson(
      Map<String, dynamic> json) {
    return FirewallPolicyStatelessRuleGroupReferencesDetails(
      priority: json['Priority'] as int?,
      resourceArn: json['ResourceArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final priority = this.priority;
    final resourceArn = this.resourceArn;
    return {
      if (priority != null) 'Priority': priority,
      if (resourceArn != null) 'ResourceArn': resourceArn,
    };
  }
}

/// Provides metadata for the Amazon CodeGuru detector associated with a
/// finding. This field pertains to findings that relate to Lambda functions.
/// Amazon Inspector identifies policy violations and vulnerabilities in Lambda
/// function code based on internal detectors developed in collaboration with
/// Amazon CodeGuru. Security Hub receives those findings.
class GeneratorDetails {
  /// The description of the detector used to identify the code vulnerability.
  final String? description;

  /// An array of tags used to identify the detector associated with the finding.
  ///
  /// Array Members: Minimum number of 0 items. Maximum number of 10 items.
  final List<String>? labels;

  /// The name of the detector used to identify the code vulnerability.
  final String? name;

  GeneratorDetails({
    this.description,
    this.labels,
    this.name,
  });

  factory GeneratorDetails.fromJson(Map<String, dynamic> json) {
    return GeneratorDetails(
      description: json['Description'] as String?,
      labels: (json['Labels'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final labels = this.labels;
    final name = this.name;
    return {
      if (description != null) 'Description': description,
      if (labels != null) 'Labels': labels,
      if (name != null) 'Name': name,
    };
  }
}

/// Provides the latitude and longitude coordinates of a location.
class GeoLocation {
  /// The latitude of the location.
  final double? lat;

  /// The longitude of the location.
  final double? lon;

  GeoLocation({
    this.lat,
    this.lon,
  });

  factory GeoLocation.fromJson(Map<String, dynamic> json) {
    return GeoLocation(
      lat: json['Lat'] as double?,
      lon: json['Lon'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final lat = this.lat;
    final lon = this.lon;
    return {
      if (lat != null) 'Lat': lat,
      if (lon != null) 'Lon': lon,
    };
  }
}

class GetAdministratorAccountResponse {
  final Invitation? administrator;

  GetAdministratorAccountResponse({
    this.administrator,
  });

  factory GetAdministratorAccountResponse.fromJson(Map<String, dynamic> json) {
    return GetAdministratorAccountResponse(
      administrator: json['Administrator'] != null
          ? Invitation.fromJson(json['Administrator'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final administrator = this.administrator;
    return {
      if (administrator != null) 'Administrator': administrator,
    };
  }
}

class GetConfigurationPolicyAssociationResponse {
  /// The current status of the association between the specified target and the
  /// configuration.
  final ConfigurationPolicyAssociationStatus? associationStatus;

  /// The explanation for a <code>FAILED</code> value for
  /// <code>AssociationStatus</code>.
  final String? associationStatusMessage;

  /// Indicates whether the association between the specified target and the
  /// configuration was directly applied by the Security Hub delegated
  /// administrator or inherited from a parent.
  final AssociationType? associationType;

  /// The universally unique identifier (UUID) of a configuration policy. For
  /// self-managed behavior, the value is <code>SELF_MANAGED_SECURITY_HUB</code>.
  final String? configurationPolicyId;

  /// The target account ID, organizational unit ID, or the root ID for which the
  /// association is retrieved.
  final String? targetId;

  /// Specifies whether the target is an Amazon Web Services account,
  /// organizational unit, or the organization root.
  final TargetType? targetType;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// association was last updated.
  final DateTime? updatedAt;

  GetConfigurationPolicyAssociationResponse({
    this.associationStatus,
    this.associationStatusMessage,
    this.associationType,
    this.configurationPolicyId,
    this.targetId,
    this.targetType,
    this.updatedAt,
  });

  factory GetConfigurationPolicyAssociationResponse.fromJson(
      Map<String, dynamic> json) {
    return GetConfigurationPolicyAssociationResponse(
      associationStatus: (json['AssociationStatus'] as String?)
          ?.toConfigurationPolicyAssociationStatus(),
      associationStatusMessage: json['AssociationStatusMessage'] as String?,
      associationType:
          (json['AssociationType'] as String?)?.toAssociationType(),
      configurationPolicyId: json['ConfigurationPolicyId'] as String?,
      targetId: json['TargetId'] as String?,
      targetType: (json['TargetType'] as String?)?.toTargetType(),
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final associationStatusMessage = this.associationStatusMessage;
    final associationType = this.associationType;
    final configurationPolicyId = this.configurationPolicyId;
    final targetId = this.targetId;
    final targetType = this.targetType;
    final updatedAt = this.updatedAt;
    return {
      if (associationStatus != null)
        'AssociationStatus': associationStatus.toValue(),
      if (associationStatusMessage != null)
        'AssociationStatusMessage': associationStatusMessage,
      if (associationType != null) 'AssociationType': associationType.toValue(),
      if (configurationPolicyId != null)
        'ConfigurationPolicyId': configurationPolicyId,
      if (targetId != null) 'TargetId': targetId,
      if (targetType != null) 'TargetType': targetType.toValue(),
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

class GetConfigurationPolicyResponse {
  /// The ARN of the configuration policy.
  final String? arn;

  /// An object that defines how Security Hub is configured. It includes whether
  /// Security Hub is enabled or disabled, a list of enabled security standards, a
  /// list of enabled or disabled security controls, and a list of custom
  /// parameter values for specified controls. If the policy includes a list of
  /// security controls that are enabled, Security Hub disables all other controls
  /// (including newly released controls). If the policy includes a list of
  /// security controls that are disabled, Security Hub enables all other controls
  /// (including newly released controls).
  final Policy? configurationPolicy;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was created.
  final DateTime? createdAt;

  /// The description of the configuration policy.
  final String? description;

  /// The UUID of the configuration policy.
  final String? id;

  /// The name of the configuration policy.
  final String? name;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was last updated.
  final DateTime? updatedAt;

  GetConfigurationPolicyResponse({
    this.arn,
    this.configurationPolicy,
    this.createdAt,
    this.description,
    this.id,
    this.name,
    this.updatedAt,
  });

  factory GetConfigurationPolicyResponse.fromJson(Map<String, dynamic> json) {
    return GetConfigurationPolicyResponse(
      arn: json['Arn'] as String?,
      configurationPolicy: json['ConfigurationPolicy'] != null
          ? Policy.fromJson(json['ConfigurationPolicy'] as Map<String, dynamic>)
          : null,
      createdAt: timeStampFromJson(json['CreatedAt']),
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final configurationPolicy = this.configurationPolicy;
    final createdAt = this.createdAt;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final updatedAt = this.updatedAt;
    return {
      if (arn != null) 'Arn': arn,
      if (configurationPolicy != null)
        'ConfigurationPolicy': configurationPolicy,
      if (createdAt != null) 'CreatedAt': iso8601ToJson(createdAt),
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

class GetEnabledStandardsResponse {
  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  /// The list of <code>StandardsSubscriptions</code> objects that include
  /// information about the enabled standards.
  final List<StandardsSubscription>? standardsSubscriptions;

  GetEnabledStandardsResponse({
    this.nextToken,
    this.standardsSubscriptions,
  });

  factory GetEnabledStandardsResponse.fromJson(Map<String, dynamic> json) {
    return GetEnabledStandardsResponse(
      nextToken: json['NextToken'] as String?,
      standardsSubscriptions: (json['StandardsSubscriptions'] as List?)
          ?.whereNotNull()
          .map((e) => StandardsSubscription.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final standardsSubscriptions = this.standardsSubscriptions;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (standardsSubscriptions != null)
        'StandardsSubscriptions': standardsSubscriptions,
    };
  }
}

class GetFindingAggregatorResponse {
  /// The aggregation Region.
  final String? findingAggregationRegion;

  /// The ARN of the finding aggregator.
  final String? findingAggregatorArn;

  /// Indicates whether to link all Regions, all Regions except for a list of
  /// excluded Regions, or a list of included Regions.
  final String? regionLinkingMode;

  /// The list of excluded Regions or included Regions.
  final List<String>? regions;

  GetFindingAggregatorResponse({
    this.findingAggregationRegion,
    this.findingAggregatorArn,
    this.regionLinkingMode,
    this.regions,
  });

  factory GetFindingAggregatorResponse.fromJson(Map<String, dynamic> json) {
    return GetFindingAggregatorResponse(
      findingAggregationRegion: json['FindingAggregationRegion'] as String?,
      findingAggregatorArn: json['FindingAggregatorArn'] as String?,
      regionLinkingMode: json['RegionLinkingMode'] as String?,
      regions: (json['Regions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final findingAggregationRegion = this.findingAggregationRegion;
    final findingAggregatorArn = this.findingAggregatorArn;
    final regionLinkingMode = this.regionLinkingMode;
    final regions = this.regions;
    return {
      if (findingAggregationRegion != null)
        'FindingAggregationRegion': findingAggregationRegion,
      if (findingAggregatorArn != null)
        'FindingAggregatorArn': findingAggregatorArn,
      if (regionLinkingMode != null) 'RegionLinkingMode': regionLinkingMode,
      if (regions != null) 'Regions': regions,
    };
  }
}

class GetFindingHistoryResponse {
  /// A token for pagination purposes. Provide this token in the subsequent
  /// request to <code>GetFindingsHistory</code> to get up to an additional 100
  /// results of history for the same finding that you specified in your initial
  /// request.
  final String? nextToken;

  /// A list of events that altered the specified finding during the specified
  /// time period.
  final List<FindingHistoryRecord>? records;

  GetFindingHistoryResponse({
    this.nextToken,
    this.records,
  });

  factory GetFindingHistoryResponse.fromJson(Map<String, dynamic> json) {
    return GetFindingHistoryResponse(
      nextToken: json['NextToken'] as String?,
      records: (json['Records'] as List?)
          ?.whereNotNull()
          .map((e) => FindingHistoryRecord.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final records = this.records;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (records != null) 'Records': records,
    };
  }
}

class GetFindingsResponse {
  /// The findings that matched the filters specified in the request.
  final List<AwsSecurityFinding> findings;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  GetFindingsResponse({
    required this.findings,
    this.nextToken,
  });

  factory GetFindingsResponse.fromJson(Map<String, dynamic> json) {
    return GetFindingsResponse(
      findings: (json['Findings'] as List)
          .whereNotNull()
          .map((e) => AwsSecurityFinding.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final findings = this.findings;
    final nextToken = this.nextToken;
    return {
      'Findings': findings,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class GetInsightResultsResponse {
  /// The insight results returned by the operation.
  final InsightResults insightResults;

  GetInsightResultsResponse({
    required this.insightResults,
  });

  factory GetInsightResultsResponse.fromJson(Map<String, dynamic> json) {
    return GetInsightResultsResponse(
      insightResults: InsightResults.fromJson(
          json['InsightResults'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final insightResults = this.insightResults;
    return {
      'InsightResults': insightResults,
    };
  }
}

class GetInsightsResponse {
  /// The insights returned by the operation.
  final List<Insight> insights;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  GetInsightsResponse({
    required this.insights,
    this.nextToken,
  });

  factory GetInsightsResponse.fromJson(Map<String, dynamic> json) {
    return GetInsightsResponse(
      insights: (json['Insights'] as List)
          .whereNotNull()
          .map((e) => Insight.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final insights = this.insights;
    final nextToken = this.nextToken;
    return {
      'Insights': insights,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class GetInvitationsCountResponse {
  /// The number of all membership invitations sent to this Security Hub member
  /// account, not including the currently accepted invitation.
  final int? invitationsCount;

  GetInvitationsCountResponse({
    this.invitationsCount,
  });

  factory GetInvitationsCountResponse.fromJson(Map<String, dynamic> json) {
    return GetInvitationsCountResponse(
      invitationsCount: json['InvitationsCount'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final invitationsCount = this.invitationsCount;
    return {
      if (invitationsCount != null) 'InvitationsCount': invitationsCount,
    };
  }
}

class GetMasterAccountResponse {
  /// A list of details about the Security Hub administrator account for the
  /// current member account.
  final Invitation? master;

  GetMasterAccountResponse({
    this.master,
  });

  factory GetMasterAccountResponse.fromJson(Map<String, dynamic> json) {
    return GetMasterAccountResponse(
      master: json['Master'] != null
          ? Invitation.fromJson(json['Master'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final master = this.master;
    return {
      if (master != null) 'Master': master,
    };
  }
}

class GetMembersResponse {
  /// The list of details about the Security Hub member accounts.
  final List<Member>? members;

  /// The list of Amazon Web Services accounts that could not be processed. For
  /// each account, the list includes the account ID and the email address.
  final List<Result>? unprocessedAccounts;

  GetMembersResponse({
    this.members,
    this.unprocessedAccounts,
  });

  factory GetMembersResponse.fromJson(Map<String, dynamic> json) {
    return GetMembersResponse(
      members: (json['Members'] as List?)
          ?.whereNotNull()
          .map((e) => Member.fromJson(e as Map<String, dynamic>))
          .toList(),
      unprocessedAccounts: (json['UnprocessedAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final members = this.members;
    final unprocessedAccounts = this.unprocessedAccounts;
    return {
      if (members != null) 'Members': members,
      if (unprocessedAccounts != null)
        'UnprocessedAccounts': unprocessedAccounts,
    };
  }
}

class GetSecurityControlDefinitionResponse {
  final SecurityControlDefinition securityControlDefinition;

  GetSecurityControlDefinitionResponse({
    required this.securityControlDefinition,
  });

  factory GetSecurityControlDefinitionResponse.fromJson(
      Map<String, dynamic> json) {
    return GetSecurityControlDefinitionResponse(
      securityControlDefinition: SecurityControlDefinition.fromJson(
          json['SecurityControlDefinition'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final securityControlDefinition = this.securityControlDefinition;
    return {
      'SecurityControlDefinition': securityControlDefinition,
    };
  }
}

/// An Internet Control Message Protocol (ICMP) type and code.
class IcmpTypeCode {
  /// The ICMP code for which to deny or allow access. To deny or allow all codes,
  /// use the value <code>-1</code>.
  final int? code;

  /// The ICMP type for which to deny or allow access. To deny or allow all types,
  /// use the value <code>-1</code>.
  final int? type;

  IcmpTypeCode({
    this.code,
    this.type,
  });

  factory IcmpTypeCode.fromJson(Map<String, dynamic> json) {
    return IcmpTypeCode(
      code: json['Code'] as int?,
      type: json['Type'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final code = this.code;
    final type = this.type;
    return {
      if (code != null) 'Code': code,
      if (type != null) 'Type': type,
    };
  }
}

/// The list of the findings that cannot be imported. For each finding, the list
/// provides the error.
class ImportFindingsError {
  /// The code of the error returned by the <code>BatchImportFindings</code>
  /// operation.
  final String errorCode;

  /// The message of the error returned by the <code>BatchImportFindings</code>
  /// operation.
  final String errorMessage;

  /// The identifier of the finding that could not be updated.
  final String id;

  ImportFindingsError({
    required this.errorCode,
    required this.errorMessage,
    required this.id,
  });

  factory ImportFindingsError.fromJson(Map<String, dynamic> json) {
    return ImportFindingsError(
      errorCode: json['ErrorCode'] as String,
      errorMessage: json['ErrorMessage'] as String,
      id: json['Id'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final errorMessage = this.errorMessage;
    final id = this.id;
    return {
      'ErrorCode': errorCode,
      'ErrorMessage': errorMessage,
      'Id': id,
    };
  }
}

/// Contains information about a Security Hub insight.
class Insight {
  /// One or more attributes used to filter the findings included in the insight.
  /// You can filter by up to ten finding attributes. For each attribute, you can
  /// provide up to 20 filter values. The insight only includes findings that
  /// match the criteria defined in the filters.
  final AwsSecurityFindingFilters filters;

  /// The grouping attribute for the insight's findings. Indicates how to group
  /// the matching findings, and identifies the type of item that the insight
  /// applies to. For example, if an insight is grouped by resource identifier,
  /// then the insight produces a list of resource identifiers.
  final String groupByAttribute;

  /// The ARN of a Security Hub insight.
  final String insightArn;

  /// The name of a Security Hub insight.
  final String name;

  Insight({
    required this.filters,
    required this.groupByAttribute,
    required this.insightArn,
    required this.name,
  });

  factory Insight.fromJson(Map<String, dynamic> json) {
    return Insight(
      filters: AwsSecurityFindingFilters.fromJson(
          json['Filters'] as Map<String, dynamic>),
      groupByAttribute: json['GroupByAttribute'] as String,
      insightArn: json['InsightArn'] as String,
      name: json['Name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final filters = this.filters;
    final groupByAttribute = this.groupByAttribute;
    final insightArn = this.insightArn;
    final name = this.name;
    return {
      'Filters': filters,
      'GroupByAttribute': groupByAttribute,
      'InsightArn': insightArn,
      'Name': name,
    };
  }
}

/// The insight result values returned by the <code>GetInsightResults</code>
/// operation.
class InsightResultValue {
  /// The number of findings returned for each <code>GroupByAttributeValue</code>.
  final int count;

  /// The value of the attribute that the findings are grouped by for the insight
  /// whose results are returned by the <code>GetInsightResults</code> operation.
  final String groupByAttributeValue;

  InsightResultValue({
    required this.count,
    required this.groupByAttributeValue,
  });

  factory InsightResultValue.fromJson(Map<String, dynamic> json) {
    return InsightResultValue(
      count: json['Count'] as int,
      groupByAttributeValue: json['GroupByAttributeValue'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final count = this.count;
    final groupByAttributeValue = this.groupByAttributeValue;
    return {
      'Count': count,
      'GroupByAttributeValue': groupByAttributeValue,
    };
  }
}

/// The insight results returned by the <code>GetInsightResults</code>
/// operation.
class InsightResults {
  /// The attribute that the findings are grouped by for the insight whose results
  /// are returned by the <code>GetInsightResults</code> operation.
  final String groupByAttribute;

  /// The ARN of the insight whose results are returned by the
  /// <code>GetInsightResults</code> operation.
  final String insightArn;

  /// The list of insight result values returned by the
  /// <code>GetInsightResults</code> operation.
  final List<InsightResultValue> resultValues;

  InsightResults({
    required this.groupByAttribute,
    required this.insightArn,
    required this.resultValues,
  });

  factory InsightResults.fromJson(Map<String, dynamic> json) {
    return InsightResults(
      groupByAttribute: json['GroupByAttribute'] as String,
      insightArn: json['InsightArn'] as String,
      resultValues: (json['ResultValues'] as List)
          .whereNotNull()
          .map((e) => InsightResultValue.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final groupByAttribute = this.groupByAttribute;
    final insightArn = this.insightArn;
    final resultValues = this.resultValues;
    return {
      'GroupByAttribute': groupByAttribute,
      'InsightArn': insightArn,
      'ResultValues': resultValues,
    };
  }
}

/// The options for customizing a security control parameter that is an integer.
class IntegerConfigurationOptions {
  /// The Security Hub default value for a control parameter that is an integer.
  final int? defaultValue;

  /// The maximum valid value for a control parameter that is an integer.
  final int? max;

  /// The minimum valid value for a control parameter that is an integer.
  final int? min;

  IntegerConfigurationOptions({
    this.defaultValue,
    this.max,
    this.min,
  });

  factory IntegerConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return IntegerConfigurationOptions(
      defaultValue: json['DefaultValue'] as int?,
      max: json['Max'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    final max = this.max;
    final min = this.min;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The options for customizing a security control parameter that is a list of
/// integers.
class IntegerListConfigurationOptions {
  /// The Security Hub default value for a control parameter that is a list of
  /// integers.
  final List<int>? defaultValue;

  /// The maximum valid value for a control parameter that is a list of integers.
  final int? max;

  /// The maximum number of list items that an interger list control parameter can
  /// accept.
  final int? maxItems;

  /// The minimum valid value for a control parameter that is a list of integers.
  final int? min;

  IntegerListConfigurationOptions({
    this.defaultValue,
    this.max,
    this.maxItems,
    this.min,
  });

  factory IntegerListConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return IntegerListConfigurationOptions(
      defaultValue: (json['DefaultValue'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      max: json['Max'] as int?,
      maxItems: json['MaxItems'] as int?,
      min: json['Min'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    final max = this.max;
    final maxItems = this.maxItems;
    final min = this.min;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (max != null) 'Max': max,
      if (maxItems != null) 'MaxItems': maxItems,
      if (min != null) 'Min': min,
    };
  }
}

enum IntegrationType {
  sendFindingsToSecurityHub,
  receiveFindingsFromSecurityHub,
  updateFindingsInSecurityHub,
}

extension IntegrationTypeValueExtension on IntegrationType {
  String toValue() {
    switch (this) {
      case IntegrationType.sendFindingsToSecurityHub:
        return 'SEND_FINDINGS_TO_SECURITY_HUB';
      case IntegrationType.receiveFindingsFromSecurityHub:
        return 'RECEIVE_FINDINGS_FROM_SECURITY_HUB';
      case IntegrationType.updateFindingsInSecurityHub:
        return 'UPDATE_FINDINGS_IN_SECURITY_HUB';
    }
  }
}

extension IntegrationTypeFromString on String {
  IntegrationType toIntegrationType() {
    switch (this) {
      case 'SEND_FINDINGS_TO_SECURITY_HUB':
        return IntegrationType.sendFindingsToSecurityHub;
      case 'RECEIVE_FINDINGS_FROM_SECURITY_HUB':
        return IntegrationType.receiveFindingsFromSecurityHub;
      case 'UPDATE_FINDINGS_IN_SECURITY_HUB':
        return IntegrationType.updateFindingsInSecurityHub;
    }
    throw Exception('$this is not known in enum IntegrationType');
  }
}

/// Details about an invitation.
class Invitation {
  /// The account ID of the Security Hub administrator account that the invitation
  /// was sent from.
  final String? accountId;

  /// The ID of the invitation sent to the member account.
  final String? invitationId;

  /// The timestamp of when the invitation was sent.
  final DateTime? invitedAt;

  /// The current status of the association between the member and administrator
  /// accounts.
  final String? memberStatus;

  Invitation({
    this.accountId,
    this.invitationId,
    this.invitedAt,
    this.memberStatus,
  });

  factory Invitation.fromJson(Map<String, dynamic> json) {
    return Invitation(
      accountId: json['AccountId'] as String?,
      invitationId: json['InvitationId'] as String?,
      invitedAt: timeStampFromJson(json['InvitedAt']),
      memberStatus: json['MemberStatus'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final invitationId = this.invitationId;
    final invitedAt = this.invitedAt;
    final memberStatus = this.memberStatus;
    return {
      if (accountId != null) 'AccountId': accountId,
      if (invitationId != null) 'InvitationId': invitationId,
      if (invitedAt != null) 'InvitedAt': iso8601ToJson(invitedAt),
      if (memberStatus != null) 'MemberStatus': memberStatus,
    };
  }
}

class InviteMembersResponse {
  /// The list of Amazon Web Services accounts that could not be processed. For
  /// each account, the list includes the account ID and the email address.
  final List<Result>? unprocessedAccounts;

  InviteMembersResponse({
    this.unprocessedAccounts,
  });

  factory InviteMembersResponse.fromJson(Map<String, dynamic> json) {
    return InviteMembersResponse(
      unprocessedAccounts: (json['UnprocessedAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final unprocessedAccounts = this.unprocessedAccounts;
    return {
      if (unprocessedAccounts != null)
        'UnprocessedAccounts': unprocessedAccounts,
    };
  }
}

/// The IP filter for querying findings.
class IpFilter {
  /// A finding's CIDR value.
  final String? cidr;

  IpFilter({
    this.cidr,
  });

  factory IpFilter.fromJson(Map<String, dynamic> json) {
    return IpFilter(
      cidr: json['Cidr'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidr = this.cidr;
    return {
      if (cidr != null) 'Cidr': cidr,
    };
  }
}

/// Provides information about an internet provider.
class IpOrganizationDetails {
  /// The Autonomous System Number (ASN) of the internet provider
  final int? asn;

  /// The name of the organization that registered the ASN.
  final String? asnOrg;

  /// The ISP information for the internet provider.
  final String? isp;

  /// The name of the internet provider.
  final String? org;

  IpOrganizationDetails({
    this.asn,
    this.asnOrg,
    this.isp,
    this.org,
  });

  factory IpOrganizationDetails.fromJson(Map<String, dynamic> json) {
    return IpOrganizationDetails(
      asn: json['Asn'] as int?,
      asnOrg: json['AsnOrg'] as String?,
      isp: json['Isp'] as String?,
      org: json['Org'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final asn = this.asn;
    final asnOrg = this.asnOrg;
    final isp = this.isp;
    final org = this.org;
    return {
      if (asn != null) 'Asn': asn,
      if (asnOrg != null) 'AsnOrg': asnOrg,
      if (isp != null) 'Isp': isp,
      if (org != null) 'Org': org,
    };
  }
}

/// An IPV6 CIDR block association.
class Ipv6CidrBlockAssociation {
  /// The association ID for the IPv6 CIDR block.
  final String? associationId;

  /// Information about the state of the CIDR block. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>associating</code>
  /// </li>
  /// <li>
  /// <code>associated</code>
  /// </li>
  /// <li>
  /// <code>disassociating</code>
  /// </li>
  /// <li>
  /// <code>disassociated</code>
  /// </li>
  /// <li>
  /// <code>failed</code>
  /// </li>
  /// <li>
  /// <code>failing</code>
  /// </li>
  /// </ul>
  final String? cidrBlockState;

  /// The IPv6 CIDR block.
  final String? ipv6CidrBlock;

  Ipv6CidrBlockAssociation({
    this.associationId,
    this.cidrBlockState,
    this.ipv6CidrBlock,
  });

  factory Ipv6CidrBlockAssociation.fromJson(Map<String, dynamic> json) {
    return Ipv6CidrBlockAssociation(
      associationId: json['AssociationId'] as String?,
      cidrBlockState: json['CidrBlockState'] as String?,
      ipv6CidrBlock: json['Ipv6CidrBlock'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationId = this.associationId;
    final cidrBlockState = this.cidrBlockState;
    final ipv6CidrBlock = this.ipv6CidrBlock;
    return {
      if (associationId != null) 'AssociationId': associationId,
      if (cidrBlockState != null) 'CidrBlockState': cidrBlockState,
      if (ipv6CidrBlock != null) 'Ipv6CidrBlock': ipv6CidrBlock,
    };
  }
}

/// A keyword filter for querying findings.
class KeywordFilter {
  /// A value for the keyword.
  final String? value;

  KeywordFilter({
    this.value,
  });

  factory KeywordFilter.fromJson(Map<String, dynamic> json) {
    return KeywordFilter(
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

class ListAutomationRulesResponse {
  /// Metadata for rules in the calling account. The response includes rules with
  /// a <code>RuleStatus</code> of <code>ENABLED</code> and <code>DISABLED</code>.
  final List<AutomationRulesMetadata>? automationRulesMetadata;

  /// A pagination token for the response.
  final String? nextToken;

  ListAutomationRulesResponse({
    this.automationRulesMetadata,
    this.nextToken,
  });

  factory ListAutomationRulesResponse.fromJson(Map<String, dynamic> json) {
    return ListAutomationRulesResponse(
      automationRulesMetadata: (json['AutomationRulesMetadata'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AutomationRulesMetadata.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final automationRulesMetadata = this.automationRulesMetadata;
    final nextToken = this.nextToken;
    return {
      if (automationRulesMetadata != null)
        'AutomationRulesMetadata': automationRulesMetadata,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListConfigurationPoliciesResponse {
  /// Provides metadata for each of your configuration policies.
  final List<ConfigurationPolicySummary>? configurationPolicySummaries;

  /// The <code>NextToken</code> value to include in the next
  /// <code>ListConfigurationPolicies</code> request. When the results of a
  /// <code>ListConfigurationPolicies</code> request exceed
  /// <code>MaxResults</code>, this value can be used to retrieve the next page of
  /// results. This value is <code>null</code> when there are no more results to
  /// return.
  final String? nextToken;

  ListConfigurationPoliciesResponse({
    this.configurationPolicySummaries,
    this.nextToken,
  });

  factory ListConfigurationPoliciesResponse.fromJson(
      Map<String, dynamic> json) {
    return ListConfigurationPoliciesResponse(
      configurationPolicySummaries: (json['ConfigurationPolicySummaries']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              ConfigurationPolicySummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final configurationPolicySummaries = this.configurationPolicySummaries;
    final nextToken = this.nextToken;
    return {
      if (configurationPolicySummaries != null)
        'ConfigurationPolicySummaries': configurationPolicySummaries,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListConfigurationPolicyAssociationsResponse {
  /// An object that contains the details of each configuration policy association
  /// that’s returned in a <code>ListConfigurationPolicyAssociations</code>
  /// request.
  final List<ConfigurationPolicyAssociationSummary>?
      configurationPolicyAssociationSummaries;

  /// The <code>NextToken</code> value to include in the next
  /// <code>ListConfigurationPolicyAssociations</code> request. When the results
  /// of a <code>ListConfigurationPolicyAssociations</code> request exceed
  /// <code>MaxResults</code>, this value can be used to retrieve the next page of
  /// results. This value is <code>null</code> when there are no more results to
  /// return.
  final String? nextToken;

  ListConfigurationPolicyAssociationsResponse({
    this.configurationPolicyAssociationSummaries,
    this.nextToken,
  });

  factory ListConfigurationPolicyAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListConfigurationPolicyAssociationsResponse(
      configurationPolicyAssociationSummaries:
          (json['ConfigurationPolicyAssociationSummaries'] as List?)
              ?.whereNotNull()
              .map((e) => ConfigurationPolicyAssociationSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final configurationPolicyAssociationSummaries =
        this.configurationPolicyAssociationSummaries;
    final nextToken = this.nextToken;
    return {
      if (configurationPolicyAssociationSummaries != null)
        'ConfigurationPolicyAssociationSummaries':
            configurationPolicyAssociationSummaries,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListEnabledProductsForImportResponse {
  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  /// The list of ARNs for the resources that represent your subscriptions to
  /// products.
  final List<String>? productSubscriptions;

  ListEnabledProductsForImportResponse({
    this.nextToken,
    this.productSubscriptions,
  });

  factory ListEnabledProductsForImportResponse.fromJson(
      Map<String, dynamic> json) {
    return ListEnabledProductsForImportResponse(
      nextToken: json['NextToken'] as String?,
      productSubscriptions: (json['ProductSubscriptions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final productSubscriptions = this.productSubscriptions;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (productSubscriptions != null)
        'ProductSubscriptions': productSubscriptions,
    };
  }
}

class ListFindingAggregatorsResponse {
  /// The list of finding aggregators. This operation currently only returns a
  /// single result.
  final List<FindingAggregator>? findingAggregators;

  /// If there are more results, this is the token to provide in the next call to
  /// <code>ListFindingAggregators</code>.
  ///
  /// This operation currently only returns a single result.
  final String? nextToken;

  ListFindingAggregatorsResponse({
    this.findingAggregators,
    this.nextToken,
  });

  factory ListFindingAggregatorsResponse.fromJson(Map<String, dynamic> json) {
    return ListFindingAggregatorsResponse(
      findingAggregators: (json['FindingAggregators'] as List?)
          ?.whereNotNull()
          .map((e) => FindingAggregator.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final findingAggregators = this.findingAggregators;
    final nextToken = this.nextToken;
    return {
      if (findingAggregators != null) 'FindingAggregators': findingAggregators,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListInvitationsResponse {
  /// The details of the invitations returned by the operation.
  final List<Invitation>? invitations;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  ListInvitationsResponse({
    this.invitations,
    this.nextToken,
  });

  factory ListInvitationsResponse.fromJson(Map<String, dynamic> json) {
    return ListInvitationsResponse(
      invitations: (json['Invitations'] as List?)
          ?.whereNotNull()
          .map((e) => Invitation.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final invitations = this.invitations;
    final nextToken = this.nextToken;
    return {
      if (invitations != null) 'Invitations': invitations,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListMembersResponse {
  /// Member details returned by the operation.
  final List<Member>? members;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  ListMembersResponse({
    this.members,
    this.nextToken,
  });

  factory ListMembersResponse.fromJson(Map<String, dynamic> json) {
    return ListMembersResponse(
      members: (json['Members'] as List?)
          ?.whereNotNull()
          .map((e) => Member.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final members = this.members;
    final nextToken = this.nextToken;
    return {
      if (members != null) 'Members': members,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListOrganizationAdminAccountsResponse {
  /// The list of Security Hub administrator accounts.
  final List<AdminAccount>? adminAccounts;

  /// The pagination token to use to request the next page of results.
  final String? nextToken;

  ListOrganizationAdminAccountsResponse({
    this.adminAccounts,
    this.nextToken,
  });

  factory ListOrganizationAdminAccountsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListOrganizationAdminAccountsResponse(
      adminAccounts: (json['AdminAccounts'] as List?)
          ?.whereNotNull()
          .map((e) => AdminAccount.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final adminAccounts = this.adminAccounts;
    final nextToken = this.nextToken;
    return {
      if (adminAccounts != null) 'AdminAccounts': adminAccounts,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListSecurityControlDefinitionsResponse {
  /// An array of controls that apply to the specified standard.
  final List<SecurityControlDefinition> securityControlDefinitions;

  /// A pagination parameter that's included in the response only if it was
  /// included in the request.
  final String? nextToken;

  ListSecurityControlDefinitionsResponse({
    required this.securityControlDefinitions,
    this.nextToken,
  });

  factory ListSecurityControlDefinitionsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListSecurityControlDefinitionsResponse(
      securityControlDefinitions: (json['SecurityControlDefinitions'] as List)
          .whereNotNull()
          .map((e) =>
              SecurityControlDefinition.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final securityControlDefinitions = this.securityControlDefinitions;
    final nextToken = this.nextToken;
    return {
      'SecurityControlDefinitions': securityControlDefinitions,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListStandardsControlAssociationsResponse {
  /// An array that provides the enablement status and other details for each
  /// security control that applies to each enabled standard.
  final List<StandardsControlAssociationSummary>
      standardsControlAssociationSummaries;

  /// A pagination parameter that's included in the response only if it was
  /// included in the request.
  final String? nextToken;

  ListStandardsControlAssociationsResponse({
    required this.standardsControlAssociationSummaries,
    this.nextToken,
  });

  factory ListStandardsControlAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListStandardsControlAssociationsResponse(
      standardsControlAssociationSummaries:
          (json['StandardsControlAssociationSummaries'] as List)
              .whereNotNull()
              .map((e) => StandardsControlAssociationSummary.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final standardsControlAssociationSummaries =
        this.standardsControlAssociationSummaries;
    final nextToken = this.nextToken;
    return {
      'StandardsControlAssociationSummaries':
          standardsControlAssociationSummaries,
      if (nextToken != null) 'NextToken': nextToken,
    };
  }
}

class ListTagsForResourceResponse {
  /// The tags associated with a resource.
  final Map<String, String>? tags;

  ListTagsForResourceResponse({
    this.tags,
  });

  factory ListTagsForResourceResponse.fromJson(Map<String, dynamic> json) {
    return ListTagsForResourceResponse(
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final tags = this.tags;
    return {
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Information about the state of the load balancer.
class LoadBalancerState {
  /// The state code. The initial state of the load balancer is provisioning.
  ///
  /// After the load balancer is fully set up and ready to route traffic, its
  /// state is active.
  ///
  /// If the load balancer could not be set up, its state is failed.
  final String? code;

  /// A description of the state.
  final String? reason;

  LoadBalancerState({
    this.code,
    this.reason,
  });

  factory LoadBalancerState.fromJson(Map<String, dynamic> json) {
    return LoadBalancerState(
      code: json['Code'] as String?,
      reason: json['Reason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final code = this.code;
    final reason = this.reason;
    return {
      if (code != null) 'Code': code,
      if (reason != null) 'Reason': reason,
    };
  }
}

/// A list of malware related to a finding.
class Malware {
  /// The name of the malware that was observed.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 64.
  final String name;

  /// The file system path of the malware that was observed.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 512.
  final String? path;

  /// The state of the malware that was observed.
  final MalwareState? state;

  /// The type of the malware that was observed.
  final MalwareType? type;

  Malware({
    required this.name,
    this.path,
    this.state,
    this.type,
  });

  factory Malware.fromJson(Map<String, dynamic> json) {
    return Malware(
      name: json['Name'] as String,
      path: json['Path'] as String?,
      state: (json['State'] as String?)?.toMalwareState(),
      type: (json['Type'] as String?)?.toMalwareType(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final path = this.path;
    final state = this.state;
    final type = this.type;
    return {
      'Name': name,
      if (path != null) 'Path': path,
      if (state != null) 'State': state.toValue(),
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum MalwareState {
  observed,
  removalFailed,
  removed,
}

extension MalwareStateValueExtension on MalwareState {
  String toValue() {
    switch (this) {
      case MalwareState.observed:
        return 'OBSERVED';
      case MalwareState.removalFailed:
        return 'REMOVAL_FAILED';
      case MalwareState.removed:
        return 'REMOVED';
    }
  }
}

extension MalwareStateFromString on String {
  MalwareState toMalwareState() {
    switch (this) {
      case 'OBSERVED':
        return MalwareState.observed;
      case 'REMOVAL_FAILED':
        return MalwareState.removalFailed;
      case 'REMOVED':
        return MalwareState.removed;
    }
    throw Exception('$this is not known in enum MalwareState');
  }
}

enum MalwareType {
  adware,
  blendedThreat,
  botnetAgent,
  coinMiner,
  exploitKit,
  keylogger,
  macro,
  potentiallyUnwanted,
  spyware,
  ransomware,
  remoteAccess,
  rootkit,
  trojan,
  virus,
  worm,
}

extension MalwareTypeValueExtension on MalwareType {
  String toValue() {
    switch (this) {
      case MalwareType.adware:
        return 'ADWARE';
      case MalwareType.blendedThreat:
        return 'BLENDED_THREAT';
      case MalwareType.botnetAgent:
        return 'BOTNET_AGENT';
      case MalwareType.coinMiner:
        return 'COIN_MINER';
      case MalwareType.exploitKit:
        return 'EXPLOIT_KIT';
      case MalwareType.keylogger:
        return 'KEYLOGGER';
      case MalwareType.macro:
        return 'MACRO';
      case MalwareType.potentiallyUnwanted:
        return 'POTENTIALLY_UNWANTED';
      case MalwareType.spyware:
        return 'SPYWARE';
      case MalwareType.ransomware:
        return 'RANSOMWARE';
      case MalwareType.remoteAccess:
        return 'REMOTE_ACCESS';
      case MalwareType.rootkit:
        return 'ROOTKIT';
      case MalwareType.trojan:
        return 'TROJAN';
      case MalwareType.virus:
        return 'VIRUS';
      case MalwareType.worm:
        return 'WORM';
    }
  }
}

extension MalwareTypeFromString on String {
  MalwareType toMalwareType() {
    switch (this) {
      case 'ADWARE':
        return MalwareType.adware;
      case 'BLENDED_THREAT':
        return MalwareType.blendedThreat;
      case 'BOTNET_AGENT':
        return MalwareType.botnetAgent;
      case 'COIN_MINER':
        return MalwareType.coinMiner;
      case 'EXPLOIT_KIT':
        return MalwareType.exploitKit;
      case 'KEYLOGGER':
        return MalwareType.keylogger;
      case 'MACRO':
        return MalwareType.macro;
      case 'POTENTIALLY_UNWANTED':
        return MalwareType.potentiallyUnwanted;
      case 'SPYWARE':
        return MalwareType.spyware;
      case 'RANSOMWARE':
        return MalwareType.ransomware;
      case 'REMOTE_ACCESS':
        return MalwareType.remoteAccess;
      case 'ROOTKIT':
        return MalwareType.rootkit;
      case 'TROJAN':
        return MalwareType.trojan;
      case 'VIRUS':
        return MalwareType.virus;
      case 'WORM':
        return MalwareType.worm;
    }
    throw Exception('$this is not known in enum MalwareType');
  }
}

/// A map filter for filtering Security Hub findings. Each map filter provides
/// the field to check for, the value to check for, and the comparison operator.
class MapFilter {
  /// The condition to apply to the key value when filtering Security Hub findings
  /// with a map filter.
  ///
  /// To search for values that have the filter value, use one of the following
  /// comparison operators:
  ///
  /// <ul>
  /// <li>
  /// To search for values that include the filter value, use
  /// <code>CONTAINS</code>. For example, for the <code>ResourceTags</code> field,
  /// the filter <code>Department CONTAINS Security</code> matches findings that
  /// include the value <code>Security</code> for the <code>Department</code> tag.
  /// In the same example, a finding with a value of <code>Security team</code>
  /// for the <code>Department</code> tag is a match.
  /// </li>
  /// <li>
  /// To search for values that exactly match the filter value, use
  /// <code>EQUALS</code>. For example, for the <code>ResourceTags</code> field,
  /// the filter <code>Department EQUALS Security</code> matches findings that
  /// have the value <code>Security</code> for the <code>Department</code> tag.
  /// </li>
  /// </ul>
  /// <code>CONTAINS</code> and <code>EQUALS</code> filters on the same field are
  /// joined by <code>OR</code>. A finding matches if it matches any one of those
  /// filters. For example, the filters <code>Department CONTAINS Security OR
  /// Department CONTAINS Finance</code> match a finding that includes either
  /// <code>Security</code>, <code>Finance</code>, or both values.
  ///
  /// To search for values that don't have the filter value, use one of the
  /// following comparison operators:
  ///
  /// <ul>
  /// <li>
  /// To search for values that exclude the filter value, use
  /// <code>NOT_CONTAINS</code>. For example, for the <code>ResourceTags</code>
  /// field, the filter <code>Department NOT_CONTAINS Finance</code> matches
  /// findings that exclude the value <code>Finance</code> for the
  /// <code>Department</code> tag.
  /// </li>
  /// <li>
  /// To search for values other than the filter value, use
  /// <code>NOT_EQUALS</code>. For example, for the <code>ResourceTags</code>
  /// field, the filter <code>Department NOT_EQUALS Finance</code> matches
  /// findings that don’t have the value <code>Finance</code> for the
  /// <code>Department</code> tag.
  /// </li>
  /// </ul>
  /// <code>NOT_CONTAINS</code> and <code>NOT_EQUALS</code> filters on the same
  /// field are joined by <code>AND</code>. A finding matches only if it matches
  /// all of those filters. For example, the filters <code>Department NOT_CONTAINS
  /// Security AND Department NOT_CONTAINS Finance</code> match a finding that
  /// excludes both the <code>Security</code> and <code>Finance</code> values.
  ///
  /// <code>CONTAINS</code> filters can only be used with other
  /// <code>CONTAINS</code> filters. <code>NOT_CONTAINS</code> filters can only be
  /// used with other <code>NOT_CONTAINS</code> filters.
  ///
  /// You can’t have both a <code>CONTAINS</code> filter and a
  /// <code>NOT_CONTAINS</code> filter on the same field. Similarly, you can’t
  /// have both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> filter
  /// on the same field. Combining filters in this way returns an error.
  ///
  /// <code>CONTAINS</code> and <code>NOT_CONTAINS</code> operators can be used
  /// only with automation rules. For more information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/automation-rules.html">Automation
  /// rules</a> in the <i>Security Hub User Guide</i>.
  final MapFilterComparison? comparison;

  /// The key of the map filter. For example, for <code>ResourceTags</code>,
  /// <code>Key</code> identifies the name of the tag. For
  /// <code>UserDefinedFields</code>, <code>Key</code> is the name of the field.
  final String? key;

  /// The value for the key in the map filter. Filter values are case sensitive.
  /// For example, one of the values for a tag called <code>Department</code>
  /// might be <code>Security</code>. If you provide <code>security</code> as the
  /// filter value, then there's no match.
  final String? value;

  MapFilter({
    this.comparison,
    this.key,
    this.value,
  });

  factory MapFilter.fromJson(Map<String, dynamic> json) {
    return MapFilter(
      comparison: (json['Comparison'] as String?)?.toMapFilterComparison(),
      key: json['Key'] as String?,
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final comparison = this.comparison;
    final key = this.key;
    final value = this.value;
    return {
      if (comparison != null) 'Comparison': comparison.toValue(),
      if (key != null) 'Key': key,
      if (value != null) 'Value': value,
    };
  }
}

enum MapFilterComparison {
  equals,
  notEquals,
  contains,
  notContains,
}

extension MapFilterComparisonValueExtension on MapFilterComparison {
  String toValue() {
    switch (this) {
      case MapFilterComparison.equals:
        return 'EQUALS';
      case MapFilterComparison.notEquals:
        return 'NOT_EQUALS';
      case MapFilterComparison.contains:
        return 'CONTAINS';
      case MapFilterComparison.notContains:
        return 'NOT_CONTAINS';
    }
  }
}

extension MapFilterComparisonFromString on String {
  MapFilterComparison toMapFilterComparison() {
    switch (this) {
      case 'EQUALS':
        return MapFilterComparison.equals;
      case 'NOT_EQUALS':
        return MapFilterComparison.notEquals;
      case 'CONTAINS':
        return MapFilterComparison.contains;
      case 'NOT_CONTAINS':
        return MapFilterComparison.notContains;
    }
    throw Exception('$this is not known in enum MapFilterComparison');
  }
}

/// The details about a member account.
class Member {
  /// The Amazon Web Services account ID of the member account.
  final String? accountId;

  /// The Amazon Web Services account ID of the Security Hub administrator account
  /// associated with this member account.
  final String? administratorId;

  /// The email address of the member account.
  final String? email;

  /// A timestamp for the date and time when the invitation was sent to the member
  /// account.
  final DateTime? invitedAt;

  /// This is replaced by <code>AdministratorID</code>.
  ///
  /// The Amazon Web Services account ID of the Security Hub administrator account
  /// associated with this member account.
  final String? masterId;

  /// The status of the relationship between the member account and its
  /// administrator account.
  ///
  /// The status can have one of the following values:
  ///
  /// <ul>
  /// <li>
  /// <code>Created</code> - Indicates that the administrator account added the
  /// member account, but has not yet invited the member account.
  /// </li>
  /// <li>
  /// <code>Invited</code> - Indicates that the administrator account invited the
  /// member account. The member account has not yet responded to the invitation.
  /// </li>
  /// <li>
  /// <code>Enabled</code> - Indicates that the member account is currently
  /// active. For manually invited member accounts, indicates that the member
  /// account accepted the invitation.
  /// </li>
  /// <li>
  /// <code>Removed</code> - Indicates that the administrator account
  /// disassociated the member account.
  /// </li>
  /// <li>
  /// <code>Resigned</code> - Indicates that the member account disassociated
  /// themselves from the administrator account.
  /// </li>
  /// <li>
  /// <code>Deleted</code> - Indicates that the administrator account deleted the
  /// member account.
  /// </li>
  /// <li>
  /// <code>AccountSuspended</code> - Indicates that an organization account was
  /// suspended from Amazon Web Services at the same time that the administrator
  /// account tried to enable the organization account as a member account.
  /// </li>
  /// </ul>
  final String? memberStatus;

  /// The timestamp for the date and time when the member account was updated.
  final DateTime? updatedAt;

  Member({
    this.accountId,
    this.administratorId,
    this.email,
    this.invitedAt,
    this.masterId,
    this.memberStatus,
    this.updatedAt,
  });

  factory Member.fromJson(Map<String, dynamic> json) {
    return Member(
      accountId: json['AccountId'] as String?,
      administratorId: json['AdministratorId'] as String?,
      email: json['Email'] as String?,
      invitedAt: timeStampFromJson(json['InvitedAt']),
      masterId: json['MasterId'] as String?,
      memberStatus: json['MemberStatus'] as String?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final administratorId = this.administratorId;
    final email = this.email;
    final invitedAt = this.invitedAt;
    final masterId = this.masterId;
    final memberStatus = this.memberStatus;
    final updatedAt = this.updatedAt;
    return {
      if (accountId != null) 'AccountId': accountId,
      if (administratorId != null) 'AdministratorId': administratorId,
      if (email != null) 'Email': email,
      if (invitedAt != null) 'InvitedAt': iso8601ToJson(invitedAt),
      if (masterId != null) 'MasterId': masterId,
      if (memberStatus != null) 'MemberStatus': memberStatus,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

/// The details of network-related information about a finding.
class Network {
  /// The destination domain of network-related information about a finding.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 128.
  final String? destinationDomain;

  /// The destination IPv4 address of network-related information about a finding.
  final String? destinationIpV4;

  /// The destination IPv6 address of network-related information about a finding.
  final String? destinationIpV6;

  /// The destination port of network-related information about a finding.
  final int? destinationPort;

  /// The direction of network traffic associated with a finding.
  final NetworkDirection? direction;

  /// The range of open ports that is present on the network.
  final PortRange? openPortRange;

  /// The protocol of network-related information about a finding.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 16.
  final String? protocol;

  /// The source domain of network-related information about a finding.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 128.
  final String? sourceDomain;

  /// The source IPv4 address of network-related information about a finding.
  final String? sourceIpV4;

  /// The source IPv6 address of network-related information about a finding.
  final String? sourceIpV6;

  /// The source media access control (MAC) address of network-related information
  /// about a finding.
  final String? sourceMac;

  /// The source port of network-related information about a finding.
  final int? sourcePort;

  Network({
    this.destinationDomain,
    this.destinationIpV4,
    this.destinationIpV6,
    this.destinationPort,
    this.direction,
    this.openPortRange,
    this.protocol,
    this.sourceDomain,
    this.sourceIpV4,
    this.sourceIpV6,
    this.sourceMac,
    this.sourcePort,
  });

  factory Network.fromJson(Map<String, dynamic> json) {
    return Network(
      destinationDomain: json['DestinationDomain'] as String?,
      destinationIpV4: json['DestinationIpV4'] as String?,
      destinationIpV6: json['DestinationIpV6'] as String?,
      destinationPort: json['DestinationPort'] as int?,
      direction: (json['Direction'] as String?)?.toNetworkDirection(),
      openPortRange: json['OpenPortRange'] != null
          ? PortRange.fromJson(json['OpenPortRange'] as Map<String, dynamic>)
          : null,
      protocol: json['Protocol'] as String?,
      sourceDomain: json['SourceDomain'] as String?,
      sourceIpV4: json['SourceIpV4'] as String?,
      sourceIpV6: json['SourceIpV6'] as String?,
      sourceMac: json['SourceMac'] as String?,
      sourcePort: json['SourcePort'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final destinationDomain = this.destinationDomain;
    final destinationIpV4 = this.destinationIpV4;
    final destinationIpV6 = this.destinationIpV6;
    final destinationPort = this.destinationPort;
    final direction = this.direction;
    final openPortRange = this.openPortRange;
    final protocol = this.protocol;
    final sourceDomain = this.sourceDomain;
    final sourceIpV4 = this.sourceIpV4;
    final sourceIpV6 = this.sourceIpV6;
    final sourceMac = this.sourceMac;
    final sourcePort = this.sourcePort;
    return {
      if (destinationDomain != null) 'DestinationDomain': destinationDomain,
      if (destinationIpV4 != null) 'DestinationIpV4': destinationIpV4,
      if (destinationIpV6 != null) 'DestinationIpV6': destinationIpV6,
      if (destinationPort != null) 'DestinationPort': destinationPort,
      if (direction != null) 'Direction': direction.toValue(),
      if (openPortRange != null) 'OpenPortRange': openPortRange,
      if (protocol != null) 'Protocol': protocol,
      if (sourceDomain != null) 'SourceDomain': sourceDomain,
      if (sourceIpV4 != null) 'SourceIpV4': sourceIpV4,
      if (sourceIpV6 != null) 'SourceIpV6': sourceIpV6,
      if (sourceMac != null) 'SourceMac': sourceMac,
      if (sourcePort != null) 'SourcePort': sourcePort,
    };
  }
}

/// Provided if <code>ActionType</code> is <code>NETWORK_CONNECTION</code>. It
/// provides details about the attempted network connection that was detected.
class NetworkConnectionAction {
  /// Indicates whether the network connection attempt was blocked.
  final bool? blocked;

  /// The direction of the network connection request (<code>IN</code> or
  /// <code>OUT</code>).
  final String? connectionDirection;

  /// Information about the port on the EC2 instance.
  final ActionLocalPortDetails? localPortDetails;

  /// The protocol used to make the network connection request.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 64.
  final String? protocol;

  /// Information about the remote IP address that issued the network connection
  /// request.
  final ActionRemoteIpDetails? remoteIpDetails;

  /// Information about the port on the remote IP address.
  final ActionRemotePortDetails? remotePortDetails;

  NetworkConnectionAction({
    this.blocked,
    this.connectionDirection,
    this.localPortDetails,
    this.protocol,
    this.remoteIpDetails,
    this.remotePortDetails,
  });

  factory NetworkConnectionAction.fromJson(Map<String, dynamic> json) {
    return NetworkConnectionAction(
      blocked: json['Blocked'] as bool?,
      connectionDirection: json['ConnectionDirection'] as String?,
      localPortDetails: json['LocalPortDetails'] != null
          ? ActionLocalPortDetails.fromJson(
              json['LocalPortDetails'] as Map<String, dynamic>)
          : null,
      protocol: json['Protocol'] as String?,
      remoteIpDetails: json['RemoteIpDetails'] != null
          ? ActionRemoteIpDetails.fromJson(
              json['RemoteIpDetails'] as Map<String, dynamic>)
          : null,
      remotePortDetails: json['RemotePortDetails'] != null
          ? ActionRemotePortDetails.fromJson(
              json['RemotePortDetails'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final blocked = this.blocked;
    final connectionDirection = this.connectionDirection;
    final localPortDetails = this.localPortDetails;
    final protocol = this.protocol;
    final remoteIpDetails = this.remoteIpDetails;
    final remotePortDetails = this.remotePortDetails;
    return {
      if (blocked != null) 'Blocked': blocked,
      if (connectionDirection != null)
        'ConnectionDirection': connectionDirection,
      if (localPortDetails != null) 'LocalPortDetails': localPortDetails,
      if (protocol != null) 'Protocol': protocol,
      if (remoteIpDetails != null) 'RemoteIpDetails': remoteIpDetails,
      if (remotePortDetails != null) 'RemotePortDetails': remotePortDetails,
    };
  }
}

enum NetworkDirection {
  $in,
  out,
}

extension NetworkDirectionValueExtension on NetworkDirection {
  String toValue() {
    switch (this) {
      case NetworkDirection.$in:
        return 'IN';
      case NetworkDirection.out:
        return 'OUT';
    }
  }
}

extension NetworkDirectionFromString on String {
  NetworkDirection toNetworkDirection() {
    switch (this) {
      case 'IN':
        return NetworkDirection.$in;
      case 'OUT':
        return NetworkDirection.out;
    }
    throw Exception('$this is not known in enum NetworkDirection');
  }
}

/// Details about a network path component that occurs before or after the
/// current component.
class NetworkHeader {
  /// Information about the destination of the component.
  final NetworkPathComponentDetails? destination;

  /// The protocol used for the component.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 16.
  final String? protocol;

  /// Information about the origin of the component.
  final NetworkPathComponentDetails? source;

  NetworkHeader({
    this.destination,
    this.protocol,
    this.source,
  });

  factory NetworkHeader.fromJson(Map<String, dynamic> json) {
    return NetworkHeader(
      destination: json['Destination'] != null
          ? NetworkPathComponentDetails.fromJson(
              json['Destination'] as Map<String, dynamic>)
          : null,
      protocol: json['Protocol'] as String?,
      source: json['Source'] != null
          ? NetworkPathComponentDetails.fromJson(
              json['Source'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final destination = this.destination;
    final protocol = this.protocol;
    final source = this.source;
    return {
      if (destination != null) 'Destination': destination,
      if (protocol != null) 'Protocol': protocol,
      if (source != null) 'Source': source,
    };
  }
}

/// Information about a network path component.
class NetworkPathComponent {
  /// The identifier of a component in the network path.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 32.
  final String? componentId;

  /// The type of component.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 32.
  final String? componentType;

  /// Information about the component that comes after the current component in
  /// the network path.
  final NetworkHeader? egress;

  /// Information about the component that comes before the current node in the
  /// network path.
  final NetworkHeader? ingress;

  NetworkPathComponent({
    this.componentId,
    this.componentType,
    this.egress,
    this.ingress,
  });

  factory NetworkPathComponent.fromJson(Map<String, dynamic> json) {
    return NetworkPathComponent(
      componentId: json['ComponentId'] as String?,
      componentType: json['ComponentType'] as String?,
      egress: json['Egress'] != null
          ? NetworkHeader.fromJson(json['Egress'] as Map<String, dynamic>)
          : null,
      ingress: json['Ingress'] != null
          ? NetworkHeader.fromJson(json['Ingress'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final componentId = this.componentId;
    final componentType = this.componentType;
    final egress = this.egress;
    final ingress = this.ingress;
    return {
      if (componentId != null) 'ComponentId': componentId,
      if (componentType != null) 'ComponentType': componentType,
      if (egress != null) 'Egress': egress,
      if (ingress != null) 'Ingress': ingress,
    };
  }
}

/// Information about the destination of the next component in the network path.
class NetworkPathComponentDetails {
  /// The IP addresses of the destination.
  final List<String>? address;

  /// A list of port ranges for the destination.
  final List<PortRange>? portRanges;

  NetworkPathComponentDetails({
    this.address,
    this.portRanges,
  });

  factory NetworkPathComponentDetails.fromJson(Map<String, dynamic> json) {
    return NetworkPathComponentDetails(
      address: (json['Address'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      portRanges: (json['PortRanges'] as List?)
          ?.whereNotNull()
          .map((e) => PortRange.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final address = this.address;
    final portRanges = this.portRanges;
    return {
      if (address != null) 'Address': address,
      if (portRanges != null) 'PortRanges': portRanges,
    };
  }
}

/// A user-defined note added to a finding.
class Note {
  /// The text of a note.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 512.
  final String text;

  /// A timestamp that indicates when the note was updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String updatedAt;

  /// The principal that created a note.
  final String updatedBy;

  Note({
    required this.text,
    required this.updatedAt,
    required this.updatedBy,
  });

  factory Note.fromJson(Map<String, dynamic> json) {
    return Note(
      text: json['Text'] as String,
      updatedAt: json['UpdatedAt'] as String,
      updatedBy: json['UpdatedBy'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final text = this.text;
    final updatedAt = this.updatedAt;
    final updatedBy = this.updatedBy;
    return {
      'Text': text,
      'UpdatedAt': updatedAt,
      'UpdatedBy': updatedBy,
    };
  }
}

/// The updated note.
class NoteUpdate {
  /// The updated note text.
  final String text;

  /// The principal that updated the note.
  final String updatedBy;

  NoteUpdate({
    required this.text,
    required this.updatedBy,
  });

  factory NoteUpdate.fromJson(Map<String, dynamic> json) {
    return NoteUpdate(
      text: json['Text'] as String,
      updatedBy: json['UpdatedBy'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final text = this.text;
    final updatedBy = this.updatedBy;
    return {
      'Text': text,
      'UpdatedBy': updatedBy,
    };
  }
}

/// A number filter for querying findings.
class NumberFilter {
  /// The equal-to condition to be applied to a single field when querying for
  /// findings.
  final double? eq;

  /// The greater-than condition to be applied to a single field when querying for
  /// findings.
  final double? gt;

  /// The greater-than-equal condition to be applied to a single field when
  /// querying for findings.
  final double? gte;

  /// The less-than condition to be applied to a single field when querying for
  /// findings.
  final double? lt;

  /// The less-than-equal condition to be applied to a single field when querying
  /// for findings.
  final double? lte;

  NumberFilter({
    this.eq,
    this.gt,
    this.gte,
    this.lt,
    this.lte,
  });

  factory NumberFilter.fromJson(Map<String, dynamic> json) {
    return NumberFilter(
      eq: json['Eq'] as double?,
      gt: json['Gt'] as double?,
      gte: json['Gte'] as double?,
      lt: json['Lt'] as double?,
      lte: json['Lte'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final eq = this.eq;
    final gt = this.gt;
    final gte = this.gte;
    final lt = this.lt;
    final lte = this.lte;
    return {
      if (eq != null) 'Eq': eq,
      if (gt != null) 'Gt': gt,
      if (gte != null) 'Gte': gte,
      if (lt != null) 'Lt': lt,
      if (lte != null) 'Lte': lte,
    };
  }
}

/// The detected occurrences of sensitive data.
class Occurrences {
  /// Occurrences of sensitive data detected in Microsoft Excel workbooks,
  /// comma-separated value (CSV) files, or tab-separated value (TSV) files.
  final List<Cell>? cells;

  /// Occurrences of sensitive data detected in a non-binary text file or a
  /// Microsoft Word file. Non-binary text files include files such as HTML, XML,
  /// JSON, and TXT files.
  final List<Range>? lineRanges;

  /// Occurrences of sensitive data detected in a binary text file.
  final List<Range>? offsetRanges;

  /// Occurrences of sensitive data in an Adobe Portable Document Format (PDF)
  /// file.
  final List<Page>? pages;

  /// Occurrences of sensitive data in an Apache Avro object container or an
  /// Apache Parquet file.
  final List<Record>? records;

  Occurrences({
    this.cells,
    this.lineRanges,
    this.offsetRanges,
    this.pages,
    this.records,
  });

  factory Occurrences.fromJson(Map<String, dynamic> json) {
    return Occurrences(
      cells: (json['Cells'] as List?)
          ?.whereNotNull()
          .map((e) => Cell.fromJson(e as Map<String, dynamic>))
          .toList(),
      lineRanges: (json['LineRanges'] as List?)
          ?.whereNotNull()
          .map((e) => Range.fromJson(e as Map<String, dynamic>))
          .toList(),
      offsetRanges: (json['OffsetRanges'] as List?)
          ?.whereNotNull()
          .map((e) => Range.fromJson(e as Map<String, dynamic>))
          .toList(),
      pages: (json['Pages'] as List?)
          ?.whereNotNull()
          .map((e) => Page.fromJson(e as Map<String, dynamic>))
          .toList(),
      records: (json['Records'] as List?)
          ?.whereNotNull()
          .map((e) => Record.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final cells = this.cells;
    final lineRanges = this.lineRanges;
    final offsetRanges = this.offsetRanges;
    final pages = this.pages;
    final records = this.records;
    return {
      if (cells != null) 'Cells': cells,
      if (lineRanges != null) 'LineRanges': lineRanges,
      if (offsetRanges != null) 'OffsetRanges': offsetRanges,
      if (pages != null) 'Pages': pages,
      if (records != null) 'Records': records,
    };
  }
}

/// Provides information about the way an organization is configured in Security
/// Hub.
class OrganizationConfiguration {
  /// Indicates whether the organization uses local or central configuration.
  ///
  /// If you use local configuration, the Security Hub delegated administrator can
  /// set <code>AutoEnable</code> to <code>true</code> and
  /// <code>AutoEnableStandards</code> to <code>DEFAULT</code>. This automatically
  /// enables Security Hub and default security standards in new organization
  /// accounts. These new account settings must be set separately in each Amazon
  /// Web Services Region, and settings may be different in each Region.
  ///
  /// If you use central configuration, the delegated administrator can create
  /// configuration policies. Configuration policies can be used to configure
  /// Security Hub, security standards, and security controls in multiple accounts
  /// and Regions. If you want new organization accounts to use a specific
  /// configuration, you can create a configuration policy and associate it with
  /// the root or specific organizational units (OUs). New accounts will inherit
  /// the policy from the root or their assigned OU.
  final OrganizationConfigurationConfigurationType? configurationType;

  /// Describes whether central configuration could be enabled as the
  /// <code>ConfigurationType</code> for the organization. If your
  /// <code>ConfigurationType</code> is local configuration, then the value of
  /// <code>Status</code> is always <code>ENABLED</code>.
  final OrganizationConfigurationStatus? status;

  /// Provides an explanation if the value of <code>Status</code> is equal to
  /// <code>FAILED</code> when <code>ConfigurationType</code> is equal to
  /// <code>CENTRAL</code>.
  final String? statusMessage;

  OrganizationConfiguration({
    this.configurationType,
    this.status,
    this.statusMessage,
  });

  factory OrganizationConfiguration.fromJson(Map<String, dynamic> json) {
    return OrganizationConfiguration(
      configurationType: (json['ConfigurationType'] as String?)
          ?.toOrganizationConfigurationConfigurationType(),
      status: (json['Status'] as String?)?.toOrganizationConfigurationStatus(),
      statusMessage: json['StatusMessage'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final configurationType = this.configurationType;
    final status = this.status;
    final statusMessage = this.statusMessage;
    return {
      if (configurationType != null)
        'ConfigurationType': configurationType.toValue(),
      if (status != null) 'Status': status.toValue(),
      if (statusMessage != null) 'StatusMessage': statusMessage,
    };
  }
}

enum OrganizationConfigurationConfigurationType {
  central,
  local,
}

extension OrganizationConfigurationConfigurationTypeValueExtension
    on OrganizationConfigurationConfigurationType {
  String toValue() {
    switch (this) {
      case OrganizationConfigurationConfigurationType.central:
        return 'CENTRAL';
      case OrganizationConfigurationConfigurationType.local:
        return 'LOCAL';
    }
  }
}

extension OrganizationConfigurationConfigurationTypeFromString on String {
  OrganizationConfigurationConfigurationType
      toOrganizationConfigurationConfigurationType() {
    switch (this) {
      case 'CENTRAL':
        return OrganizationConfigurationConfigurationType.central;
      case 'LOCAL':
        return OrganizationConfigurationConfigurationType.local;
    }
    throw Exception(
        '$this is not known in enum OrganizationConfigurationConfigurationType');
  }
}

enum OrganizationConfigurationStatus {
  pending,
  enabled,
  failed,
}

extension OrganizationConfigurationStatusValueExtension
    on OrganizationConfigurationStatus {
  String toValue() {
    switch (this) {
      case OrganizationConfigurationStatus.pending:
        return 'PENDING';
      case OrganizationConfigurationStatus.enabled:
        return 'ENABLED';
      case OrganizationConfigurationStatus.failed:
        return 'FAILED';
    }
  }
}

extension OrganizationConfigurationStatusFromString on String {
  OrganizationConfigurationStatus toOrganizationConfigurationStatus() {
    switch (this) {
      case 'PENDING':
        return OrganizationConfigurationStatus.pending;
      case 'ENABLED':
        return OrganizationConfigurationStatus.enabled;
      case 'FAILED':
        return OrganizationConfigurationStatus.failed;
    }
    throw Exception(
        '$this is not known in enum OrganizationConfigurationStatus');
  }
}

/// An occurrence of sensitive data in an Adobe Portable Document Format (PDF)
/// file.
class Page {
  /// An occurrence of sensitive data detected in a non-binary text file or a
  /// Microsoft Word file. Non-binary text files include files such as HTML, XML,
  /// JSON, and TXT files.
  final Range? lineRange;

  /// An occurrence of sensitive data detected in a binary text file.
  final Range? offsetRange;

  /// The page number of the page that contains the sensitive data.
  final int? pageNumber;

  Page({
    this.lineRange,
    this.offsetRange,
    this.pageNumber,
  });

  factory Page.fromJson(Map<String, dynamic> json) {
    return Page(
      lineRange: json['LineRange'] != null
          ? Range.fromJson(json['LineRange'] as Map<String, dynamic>)
          : null,
      offsetRange: json['OffsetRange'] != null
          ? Range.fromJson(json['OffsetRange'] as Map<String, dynamic>)
          : null,
      pageNumber: json['PageNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final lineRange = this.lineRange;
    final offsetRange = this.offsetRange;
    final pageNumber = this.pageNumber;
    return {
      if (lineRange != null) 'LineRange': lineRange,
      if (offsetRange != null) 'OffsetRange': offsetRange,
      if (pageNumber != null) 'PageNumber': pageNumber,
    };
  }
}

/// An object that provides the current value of a security control parameter
/// and identifies whether it has been customized.
class ParameterConfiguration {
  /// Identifies whether a control parameter uses a custom user-defined value or
  /// subscribes to the default Security Hub behavior.
  ///
  /// When <code>ValueType</code> is set equal to <code>DEFAULT</code>, the
  /// default behavior can be a specific Security Hub default value, or the
  /// default behavior can be to ignore a specific parameter. When
  /// <code>ValueType</code> is set equal to <code>DEFAULT</code>, Security Hub
  /// ignores user-provided input for the <code>Value</code> field.
  ///
  /// When <code>ValueType</code> is set equal to <code>CUSTOM</code>, the
  /// <code>Value</code> field can't be empty.
  final ParameterValueType valueType;

  /// The current value of a control parameter.
  final ParameterValue? value;

  ParameterConfiguration({
    required this.valueType,
    this.value,
  });

  factory ParameterConfiguration.fromJson(Map<String, dynamic> json) {
    return ParameterConfiguration(
      valueType: (json['ValueType'] as String).toParameterValueType(),
      value: json['Value'] != null
          ? ParameterValue.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final valueType = this.valueType;
    final value = this.value;
    return {
      'ValueType': valueType.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

/// An object that describes a security control parameter and the options for
/// customizing it.
class ParameterDefinition {
  /// The options for customizing a control parameter. Customization options vary
  /// based on the data type of the parameter.
  final ConfigurationOptions configurationOptions;

  /// Description of a control parameter.
  final String description;

  ParameterDefinition({
    required this.configurationOptions,
    required this.description,
  });

  factory ParameterDefinition.fromJson(Map<String, dynamic> json) {
    return ParameterDefinition(
      configurationOptions: ConfigurationOptions.fromJson(
          json['ConfigurationOptions'] as Map<String, dynamic>),
      description: json['Description'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final configurationOptions = this.configurationOptions;
    final description = this.description;
    return {
      'ConfigurationOptions': configurationOptions,
      'Description': description,
    };
  }
}

/// An object that includes the data type of a security control parameter and
/// its current value.
class ParameterValue {
  /// A control parameter that is a boolean.
  final bool? boolean;

  /// A control parameter that is a double.
  final double? doubleValue;

  /// A control parameter that is an enum.
  final String? enumValue;

  /// A control parameter that is a list of enums.
  final List<String>? enumList;

  /// A control parameter that is an integer.
  final int? integer;

  /// A control parameter that is a list of integers.
  final List<int>? integerList;

  /// A control parameter that is a string.
  final String? string;

  /// A control parameter that is a list of strings.
  final List<String>? stringList;

  ParameterValue({
    this.boolean,
    this.doubleValue,
    this.enumValue,
    this.enumList,
    this.integer,
    this.integerList,
    this.string,
    this.stringList,
  });

  factory ParameterValue.fromJson(Map<String, dynamic> json) {
    return ParameterValue(
      boolean: json['Boolean'] as bool?,
      doubleValue: json['Double'] as double?,
      enumValue: json['Enum'] as String?,
      enumList: (json['EnumList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      integer: json['Integer'] as int?,
      integerList: (json['IntegerList'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      string: json['String'] as String?,
      stringList: (json['StringList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final boolean = this.boolean;
    final doubleValue = this.doubleValue;
    final enumValue = this.enumValue;
    final enumList = this.enumList;
    final integer = this.integer;
    final integerList = this.integerList;
    final string = this.string;
    final stringList = this.stringList;
    return {
      if (boolean != null) 'Boolean': boolean,
      if (doubleValue != null) 'Double': doubleValue,
      if (enumValue != null) 'Enum': enumValue,
      if (enumList != null) 'EnumList': enumList,
      if (integer != null) 'Integer': integer,
      if (integerList != null) 'IntegerList': integerList,
      if (string != null) 'String': string,
      if (stringList != null) 'StringList': stringList,
    };
  }
}

enum ParameterValueType {
  $default,
  custom,
}

extension ParameterValueTypeValueExtension on ParameterValueType {
  String toValue() {
    switch (this) {
      case ParameterValueType.$default:
        return 'DEFAULT';
      case ParameterValueType.custom:
        return 'CUSTOM';
    }
  }
}

extension ParameterValueTypeFromString on String {
  ParameterValueType toParameterValueType() {
    switch (this) {
      case 'DEFAULT':
        return ParameterValueType.$default;
      case 'CUSTOM':
        return ParameterValueType.custom;
    }
    throw Exception('$this is not known in enum ParameterValueType');
  }
}

enum Partition {
  aws,
  awsCn,
  awsUsGov,
}

extension PartitionValueExtension on Partition {
  String toValue() {
    switch (this) {
      case Partition.aws:
        return 'aws';
      case Partition.awsCn:
        return 'aws-cn';
      case Partition.awsUsGov:
        return 'aws-us-gov';
    }
  }
}

extension PartitionFromString on String {
  Partition toPartition() {
    switch (this) {
      case 'aws':
        return Partition.aws;
      case 'aws-cn':
        return Partition.awsCn;
      case 'aws-us-gov':
        return Partition.awsUsGov;
    }
    throw Exception('$this is not known in enum Partition');
  }
}

/// Provides an overview of the patch compliance status for an instance against
/// a selected compliance standard.
class PatchSummary {
  /// The identifier of the compliance standard that was used to determine the
  /// patch compliance status.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256.
  final String id;

  /// The number of patches from the compliance standard that failed to install.
  ///
  /// The value can be an integer from <code>0</code> to <code>100000</code>.
  final int? failedCount;

  /// The number of patches from the compliance standard that were installed
  /// successfully.
  ///
  /// The value can be an integer from <code>0</code> to <code>100000</code>.
  final int? installedCount;

  /// The number of installed patches that are not part of the compliance
  /// standard.
  ///
  /// The value can be an integer from <code>0</code> to <code>100000</code>.
  final int? installedOtherCount;

  /// The number of patches that were applied, but that require the instance to be
  /// rebooted in order to be marked as installed.
  ///
  /// The value can be an integer from <code>0</code> to <code>100000</code>.
  final int? installedPendingReboot;

  /// The number of patches that are installed but are also on a list of patches
  /// that the customer rejected.
  ///
  /// The value can be an integer from <code>0</code> to <code>100000</code>.
  final int? installedRejectedCount;

  /// The number of patches that are part of the compliance standard but are not
  /// installed. The count includes patches that failed to install.
  ///
  /// The value can be an integer from <code>0</code> to <code>100000</code>.
  final int? missingCount;

  /// The type of patch operation performed. For Patch Manager, the values are
  /// <code>SCAN</code> and <code>INSTALL</code>.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256.
  final String? operation;

  /// Indicates when the operation completed.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? operationEndTime;

  /// Indicates when the operation started.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? operationStartTime;

  /// The reboot option specified for the instance.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256.
  final String? rebootOption;

  PatchSummary({
    required this.id,
    this.failedCount,
    this.installedCount,
    this.installedOtherCount,
    this.installedPendingReboot,
    this.installedRejectedCount,
    this.missingCount,
    this.operation,
    this.operationEndTime,
    this.operationStartTime,
    this.rebootOption,
  });

  factory PatchSummary.fromJson(Map<String, dynamic> json) {
    return PatchSummary(
      id: json['Id'] as String,
      failedCount: json['FailedCount'] as int?,
      installedCount: json['InstalledCount'] as int?,
      installedOtherCount: json['InstalledOtherCount'] as int?,
      installedPendingReboot: json['InstalledPendingReboot'] as int?,
      installedRejectedCount: json['InstalledRejectedCount'] as int?,
      missingCount: json['MissingCount'] as int?,
      operation: json['Operation'] as String?,
      operationEndTime: json['OperationEndTime'] as String?,
      operationStartTime: json['OperationStartTime'] as String?,
      rebootOption: json['RebootOption'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final failedCount = this.failedCount;
    final installedCount = this.installedCount;
    final installedOtherCount = this.installedOtherCount;
    final installedPendingReboot = this.installedPendingReboot;
    final installedRejectedCount = this.installedRejectedCount;
    final missingCount = this.missingCount;
    final operation = this.operation;
    final operationEndTime = this.operationEndTime;
    final operationStartTime = this.operationStartTime;
    final rebootOption = this.rebootOption;
    return {
      'Id': id,
      if (failedCount != null) 'FailedCount': failedCount,
      if (installedCount != null) 'InstalledCount': installedCount,
      if (installedOtherCount != null)
        'InstalledOtherCount': installedOtherCount,
      if (installedPendingReboot != null)
        'InstalledPendingReboot': installedPendingReboot,
      if (installedRejectedCount != null)
        'InstalledRejectedCount': installedRejectedCount,
      if (missingCount != null) 'MissingCount': missingCount,
      if (operation != null) 'Operation': operation,
      if (operationEndTime != null) 'OperationEndTime': operationEndTime,
      if (operationStartTime != null) 'OperationStartTime': operationStartTime,
      if (rebootOption != null) 'RebootOption': rebootOption,
    };
  }
}

/// An object that defines how Security Hub is configured. It includes whether
/// Security Hub is enabled or disabled, a list of enabled security standards, a
/// list of enabled or disabled security controls, and a list of custom
/// parameter values for specified controls. If you provide a list of security
/// controls that are enabled in the configuration policy, Security Hub disables
/// all other controls (including newly released controls). If you provide a
/// list of security controls that are disabled in the configuration policy,
/// Security Hub enables all other controls (including newly released controls).
class Policy {
  /// The Amazon Web Service that the configuration policy applies to.
  final SecurityHubPolicy? securityHub;

  Policy({
    this.securityHub,
  });

  factory Policy.fromJson(Map<String, dynamic> json) {
    return Policy(
      securityHub: json['SecurityHub'] != null
          ? SecurityHubPolicy.fromJson(
              json['SecurityHub'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final securityHub = this.securityHub;
    return {
      if (securityHub != null) 'SecurityHub': securityHub,
    };
  }
}

/// Provided if <code>ActionType</code> is <code>PORT_PROBE</code>. It provides
/// details about the attempted port probe that was detected.
class PortProbeAction {
  /// Indicates whether the port probe was blocked.
  final bool? blocked;

  /// Information about the ports affected by the port probe.
  final List<PortProbeDetail>? portProbeDetails;

  PortProbeAction({
    this.blocked,
    this.portProbeDetails,
  });

  factory PortProbeAction.fromJson(Map<String, dynamic> json) {
    return PortProbeAction(
      blocked: json['Blocked'] as bool?,
      portProbeDetails: (json['PortProbeDetails'] as List?)
          ?.whereNotNull()
          .map((e) => PortProbeDetail.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final blocked = this.blocked;
    final portProbeDetails = this.portProbeDetails;
    return {
      if (blocked != null) 'Blocked': blocked,
      if (portProbeDetails != null) 'PortProbeDetails': portProbeDetails,
    };
  }
}

/// A port scan that was part of the port probe. For each scan, PortProbeDetails
/// provides information about the local IP address and port that were scanned,
/// and the remote IP address that the scan originated from.
class PortProbeDetail {
  /// Provides information about the IP address where the scanned port is located.
  final ActionLocalIpDetails? localIpDetails;

  /// Provides information about the port that was scanned.
  final ActionLocalPortDetails? localPortDetails;

  /// Provides information about the remote IP address that performed the scan.
  final ActionRemoteIpDetails? remoteIpDetails;

  PortProbeDetail({
    this.localIpDetails,
    this.localPortDetails,
    this.remoteIpDetails,
  });

  factory PortProbeDetail.fromJson(Map<String, dynamic> json) {
    return PortProbeDetail(
      localIpDetails: json['LocalIpDetails'] != null
          ? ActionLocalIpDetails.fromJson(
              json['LocalIpDetails'] as Map<String, dynamic>)
          : null,
      localPortDetails: json['LocalPortDetails'] != null
          ? ActionLocalPortDetails.fromJson(
              json['LocalPortDetails'] as Map<String, dynamic>)
          : null,
      remoteIpDetails: json['RemoteIpDetails'] != null
          ? ActionRemoteIpDetails.fromJson(
              json['RemoteIpDetails'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final localIpDetails = this.localIpDetails;
    final localPortDetails = this.localPortDetails;
    final remoteIpDetails = this.remoteIpDetails;
    return {
      if (localIpDetails != null) 'LocalIpDetails': localIpDetails,
      if (localPortDetails != null) 'LocalPortDetails': localPortDetails,
      if (remoteIpDetails != null) 'RemoteIpDetails': remoteIpDetails,
    };
  }
}

/// A range of ports.
class PortRange {
  /// The first port in the port range.
  final int? begin;

  /// The last port in the port range.
  final int? end;

  PortRange({
    this.begin,
    this.end,
  });

  factory PortRange.fromJson(Map<String, dynamic> json) {
    return PortRange(
      begin: json['Begin'] as int?,
      end: json['End'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final begin = this.begin;
    final end = this.end;
    return {
      if (begin != null) 'Begin': begin,
      if (end != null) 'End': end,
    };
  }
}

/// A range of ports.
class PortRangeFromTo {
  /// The first port in the port range.
  final int? from;

  /// The last port in the port range.
  final int? to;

  PortRangeFromTo({
    this.from,
    this.to,
  });

  factory PortRangeFromTo.fromJson(Map<String, dynamic> json) {
    return PortRangeFromTo(
      from: json['From'] as int?,
      to: json['To'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final from = this.from;
    final to = this.to;
    return {
      if (from != null) 'From': from,
      if (to != null) 'To': to,
    };
  }
}

/// The details of process-related information about a finding.
class ProcessDetails {
  /// Indicates when the process was launched.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? launchedAt;

  /// The name of the process.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 64.
  final String? name;

  /// The parent process ID. This field accepts positive integers between
  /// <code>O</code> and <code>2147483647</code>.
  final int? parentPid;

  /// The path to the process executable.
  ///
  /// Length Constraints: Minimum of 1. Maximum of 512.
  final String? path;

  /// The process ID.
  final int? pid;

  /// Indicates when the process was terminated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? terminatedAt;

  ProcessDetails({
    this.launchedAt,
    this.name,
    this.parentPid,
    this.path,
    this.pid,
    this.terminatedAt,
  });

  factory ProcessDetails.fromJson(Map<String, dynamic> json) {
    return ProcessDetails(
      launchedAt: json['LaunchedAt'] as String?,
      name: json['Name'] as String?,
      parentPid: json['ParentPid'] as int?,
      path: json['Path'] as String?,
      pid: json['Pid'] as int?,
      terminatedAt: json['TerminatedAt'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final launchedAt = this.launchedAt;
    final name = this.name;
    final parentPid = this.parentPid;
    final path = this.path;
    final pid = this.pid;
    final terminatedAt = this.terminatedAt;
    return {
      if (launchedAt != null) 'LaunchedAt': launchedAt,
      if (name != null) 'Name': name,
      if (parentPid != null) 'ParentPid': parentPid,
      if (path != null) 'Path': path,
      if (pid != null) 'Pid': pid,
      if (terminatedAt != null) 'TerminatedAt': terminatedAt,
    };
  }
}

/// Contains details about a product.
class Product {
  /// The ARN assigned to the product.
  final String productArn;

  /// The URL to the service or product documentation about the integration with
  /// Security Hub, including how to activate the integration.
  final String? activationUrl;

  /// The categories assigned to the product.
  final List<String>? categories;

  /// The name of the company that provides the product.
  final String? companyName;

  /// A description of the product.
  final String? description;

  /// The types of integration that the product supports. Available values are the
  /// following.
  ///
  /// <ul>
  /// <li>
  /// <code>SEND_FINDINGS_TO_SECURITY_HUB</code> - The integration sends findings
  /// to Security Hub.
  /// </li>
  /// <li>
  /// <code>RECEIVE_FINDINGS_FROM_SECURITY_HUB</code> - The integration receives
  /// findings from Security Hub.
  /// </li>
  /// <li>
  /// <code>UPDATE_FINDINGS_IN_SECURITY_HUB</code> - The integration does not send
  /// new findings to Security Hub, but does make updates to the findings that it
  /// receives from Security Hub.
  /// </li>
  /// </ul>
  final List<IntegrationType>? integrationTypes;

  /// For integrations with Amazon Web Services services, the Amazon Web Services
  /// Console URL from which to activate the service.
  ///
  /// For integrations with third-party products, the Amazon Web Services
  /// Marketplace URL from which to subscribe to or purchase the product.
  final String? marketplaceUrl;

  /// The name of the product.
  final String? productName;

  /// The resource policy associated with the product.
  final String? productSubscriptionResourcePolicy;

  Product({
    required this.productArn,
    this.activationUrl,
    this.categories,
    this.companyName,
    this.description,
    this.integrationTypes,
    this.marketplaceUrl,
    this.productName,
    this.productSubscriptionResourcePolicy,
  });

  factory Product.fromJson(Map<String, dynamic> json) {
    return Product(
      productArn: json['ProductArn'] as String,
      activationUrl: json['ActivationUrl'] as String?,
      categories: (json['Categories'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      companyName: json['CompanyName'] as String?,
      description: json['Description'] as String?,
      integrationTypes: (json['IntegrationTypes'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toIntegrationType())
          .toList(),
      marketplaceUrl: json['MarketplaceUrl'] as String?,
      productName: json['ProductName'] as String?,
      productSubscriptionResourcePolicy:
          json['ProductSubscriptionResourcePolicy'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final productArn = this.productArn;
    final activationUrl = this.activationUrl;
    final categories = this.categories;
    final companyName = this.companyName;
    final description = this.description;
    final integrationTypes = this.integrationTypes;
    final marketplaceUrl = this.marketplaceUrl;
    final productName = this.productName;
    final productSubscriptionResourcePolicy =
        this.productSubscriptionResourcePolicy;
    return {
      'ProductArn': productArn,
      if (activationUrl != null) 'ActivationUrl': activationUrl,
      if (categories != null) 'Categories': categories,
      if (companyName != null) 'CompanyName': companyName,
      if (description != null) 'Description': description,
      if (integrationTypes != null)
        'IntegrationTypes': integrationTypes.map((e) => e.toValue()).toList(),
      if (marketplaceUrl != null) 'MarketplaceUrl': marketplaceUrl,
      if (productName != null) 'ProductName': productName,
      if (productSubscriptionResourcePolicy != null)
        'ProductSubscriptionResourcePolicy': productSubscriptionResourcePolicy,
    };
  }
}

/// Describes a virtual private gateway propagating route.
class PropagatingVgwSetDetails {
  /// The ID of the virtual private gateway.
  final String? gatewayId;

  PropagatingVgwSetDetails({
    this.gatewayId,
  });

  factory PropagatingVgwSetDetails.fromJson(Map<String, dynamic> json) {
    return PropagatingVgwSetDetails(
      gatewayId: json['GatewayId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final gatewayId = this.gatewayId;
    return {
      if (gatewayId != null) 'GatewayId': gatewayId,
    };
  }
}

/// Identifies where the sensitive data begins and ends.
class Range {
  /// The number of lines (for a line range) or characters (for an offset range)
  /// from the beginning of the file to the end of the sensitive data.
  final int? end;

  /// The number of lines (for a line range) or characters (for an offset range)
  /// from the beginning of the file to the end of the sensitive data.
  final int? start;

  /// In the line where the sensitive data starts, the column within the line
  /// where the sensitive data starts.
  final int? startColumn;

  Range({
    this.end,
    this.start,
    this.startColumn,
  });

  factory Range.fromJson(Map<String, dynamic> json) {
    return Range(
      end: json['End'] as int?,
      start: json['Start'] as int?,
      startColumn: json['StartColumn'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final end = this.end;
    final start = this.start;
    final startColumn = this.startColumn;
    return {
      if (end != null) 'End': end,
      if (start != null) 'Start': start,
      if (startColumn != null) 'StartColumn': startColumn,
    };
  }
}

/// A recommendation on how to remediate the issue identified in a finding.
class Recommendation {
  /// Describes the recommended steps to take to remediate an issue identified in
  /// a finding.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 512 length.
  final String? text;

  /// A URL to a page or site that contains information about how to remediate a
  /// finding.
  final String? url;

  Recommendation({
    this.text,
    this.url,
  });

  factory Recommendation.fromJson(Map<String, dynamic> json) {
    return Recommendation(
      text: json['Text'] as String?,
      url: json['Url'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final text = this.text;
    final url = this.url;
    return {
      if (text != null) 'Text': text,
      if (url != null) 'Url': url,
    };
  }
}

/// An occurrence of sensitive data in an Apache Avro object container or an
/// Apache Parquet file.
class Record {
  /// The path, as a JSONPath expression, to the field in the record that contains
  /// the data. If the field name is longer than 20 characters, it is truncated.
  /// If the path is longer than 250 characters, it is truncated.
  final String? jsonPath;

  /// The record index, starting from 0, for the record that contains the data.
  final int? recordIndex;

  Record({
    this.jsonPath,
    this.recordIndex,
  });

  factory Record.fromJson(Map<String, dynamic> json) {
    return Record(
      jsonPath: json['JsonPath'] as String?,
      recordIndex: json['RecordIndex'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final jsonPath = this.jsonPath;
    final recordIndex = this.recordIndex;
    return {
      if (jsonPath != null) 'JsonPath': jsonPath,
      if (recordIndex != null) 'RecordIndex': recordIndex,
    };
  }
}

enum RecordState {
  active,
  archived,
}

extension RecordStateValueExtension on RecordState {
  String toValue() {
    switch (this) {
      case RecordState.active:
        return 'ACTIVE';
      case RecordState.archived:
        return 'ARCHIVED';
    }
  }
}

extension RecordStateFromString on String {
  RecordState toRecordState() {
    switch (this) {
      case 'ACTIVE':
        return RecordState.active;
      case 'ARCHIVED':
        return RecordState.archived;
    }
    throw Exception('$this is not known in enum RecordState');
  }
}

enum RegionAvailabilityStatus {
  available,
  unavailable,
}

extension RegionAvailabilityStatusValueExtension on RegionAvailabilityStatus {
  String toValue() {
    switch (this) {
      case RegionAvailabilityStatus.available:
        return 'AVAILABLE';
      case RegionAvailabilityStatus.unavailable:
        return 'UNAVAILABLE';
    }
  }
}

extension RegionAvailabilityStatusFromString on String {
  RegionAvailabilityStatus toRegionAvailabilityStatus() {
    switch (this) {
      case 'AVAILABLE':
        return RegionAvailabilityStatus.available;
      case 'UNAVAILABLE':
        return RegionAvailabilityStatus.unavailable;
    }
    throw Exception('$this is not known in enum RegionAvailabilityStatus');
  }
}

/// Details about a related finding.
class RelatedFinding {
  /// The product-generated identifier for a related finding.
  final String id;

  /// The ARN of the product that generated a related finding.
  final String productArn;

  RelatedFinding({
    required this.id,
    required this.productArn,
  });

  factory RelatedFinding.fromJson(Map<String, dynamic> json) {
    return RelatedFinding(
      id: json['Id'] as String,
      productArn: json['ProductArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final productArn = this.productArn;
    return {
      'Id': id,
      'ProductArn': productArn,
    };
  }
}

/// Details about the remediation steps for a finding.
class Remediation {
  /// A recommendation on the steps to take to remediate the issue identified by a
  /// finding.
  final Recommendation? recommendation;

  Remediation({
    this.recommendation,
  });

  factory Remediation.fromJson(Map<String, dynamic> json) {
    return Remediation(
      recommendation: json['Recommendation'] != null
          ? Recommendation.fromJson(
              json['Recommendation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final recommendation = this.recommendation;
    return {
      if (recommendation != null) 'Recommendation': recommendation,
    };
  }
}

/// A resource related to a finding.
class Resource {
  /// The canonical identifier for the given resource type.
  final String id;

  /// The type of the resource that details are provided for. If possible, set
  /// <code>Type</code> to one of the supported resource types. For example, if
  /// the resource is an EC2 instance, then set <code>Type</code> to
  /// <code>AwsEc2Instance</code>.
  ///
  /// If the resource does not match any of the provided types, then set
  /// <code>Type</code> to <code>Other</code>.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 256.
  final String type;

  /// The Amazon Resource Name (ARN) of the application that is related to a
  /// finding.
  final String? applicationArn;

  /// The name of the application that is related to a finding.
  final String? applicationName;

  /// Contains information about sensitive data that was detected on the resource.
  final DataClassificationDetails? dataClassification;

  /// Additional details about the resource related to a finding.
  final ResourceDetails? details;

  /// The canonical Amazon Web Services partition name that the Region is assigned
  /// to.
  final Partition? partition;

  /// The canonical Amazon Web Services external Region name where this resource
  /// is located.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 16.
  final String? region;

  /// Identifies the role of the resource in the finding. A resource is either the
  /// actor or target of the finding activity,
  final String? resourceRole;

  /// A list of Amazon Web Services tags associated with a resource at the time
  /// the finding was processed. Tags must follow <a
  /// href="https://docs.aws.amazon.com/tag-editor/latest/userguide/tagging.html#tag-conventions">Amazon
  /// Web Services tag naming limits and requirements</a>.
  final Map<String, String>? tags;

  Resource({
    required this.id,
    required this.type,
    this.applicationArn,
    this.applicationName,
    this.dataClassification,
    this.details,
    this.partition,
    this.region,
    this.resourceRole,
    this.tags,
  });

  factory Resource.fromJson(Map<String, dynamic> json) {
    return Resource(
      id: json['Id'] as String,
      type: json['Type'] as String,
      applicationArn: json['ApplicationArn'] as String?,
      applicationName: json['ApplicationName'] as String?,
      dataClassification: json['DataClassification'] != null
          ? DataClassificationDetails.fromJson(
              json['DataClassification'] as Map<String, dynamic>)
          : null,
      details: json['Details'] != null
          ? ResourceDetails.fromJson(json['Details'] as Map<String, dynamic>)
          : null,
      partition: (json['Partition'] as String?)?.toPartition(),
      region: json['Region'] as String?,
      resourceRole: json['ResourceRole'] as String?,
      tags: (json['Tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final type = this.type;
    final applicationArn = this.applicationArn;
    final applicationName = this.applicationName;
    final dataClassification = this.dataClassification;
    final details = this.details;
    final partition = this.partition;
    final region = this.region;
    final resourceRole = this.resourceRole;
    final tags = this.tags;
    return {
      'Id': id,
      'Type': type,
      if (applicationArn != null) 'ApplicationArn': applicationArn,
      if (applicationName != null) 'ApplicationName': applicationName,
      if (dataClassification != null) 'DataClassification': dataClassification,
      if (details != null) 'Details': details,
      if (partition != null) 'Partition': partition.toValue(),
      if (region != null) 'Region': region,
      if (resourceRole != null) 'ResourceRole': resourceRole,
      if (tags != null) 'Tags': tags,
    };
  }
}

/// Additional details about a resource related to a finding.
///
/// To provide the details, use the object that corresponds to the resource
/// type. For example, if the resource type is <code>AwsEc2Instance</code>, then
/// you use the <code>AwsEc2Instance</code> object to provide the details.
///
/// If the type-specific object does not contain all of the fields you want to
/// populate, then you use the <code>Other</code> object to populate those
/// additional fields.
///
/// You also use the <code>Other</code> object to populate the details when the
/// selected type does not have a corresponding object.
class ResourceDetails {
  /// Provides details about AppSync message broker. A message broker allows
  /// software applications and components to communicate using various
  /// programming languages, operating systems, and formal messaging protocols.
  final AwsAmazonMqBrokerDetails? awsAmazonMqBroker;

  /// Provides information about a REST API in version 1 of Amazon API Gateway.
  final AwsApiGatewayRestApiDetails? awsApiGatewayRestApi;

  /// Provides information about a version 1 Amazon API Gateway stage.
  final AwsApiGatewayStageDetails? awsApiGatewayStage;

  /// Provides information about a version 2 API in Amazon API Gateway.
  final AwsApiGatewayV2ApiDetails? awsApiGatewayV2Api;

  /// Provides information about a version 2 stage for Amazon API Gateway.
  final AwsApiGatewayV2StageDetails? awsApiGatewayV2Stage;

  /// Provides details about an AppSync Graph QL API, which lets you query
  /// multiple databases, microservices, and APIs from a single GraphQL endpoint.
  final AwsAppSyncGraphQlApiDetails? awsAppSyncGraphQlApi;

  /// Provides information about an Amazon Athena workgroup. A workgroup helps you
  /// separate users, teams, applications, or workloads. It also helps you set
  /// limits on data processing and track costs.
  final AwsAthenaWorkGroupDetails? awsAthenaWorkGroup;

  /// Details for an autoscaling group.
  final AwsAutoScalingAutoScalingGroupDetails? awsAutoScalingAutoScalingGroup;

  /// Provides details about a launch configuration.
  final AwsAutoScalingLaunchConfigurationDetails?
      awsAutoScalingLaunchConfiguration;

  /// Provides details about an Backup backup plan.
  final AwsBackupBackupPlanDetails? awsBackupBackupPlan;

  /// Provides details about an Backup backup vault.
  final AwsBackupBackupVaultDetails? awsBackupBackupVault;

  /// Provides details about an Backup backup, or recovery point.
  final AwsBackupRecoveryPointDetails? awsBackupRecoveryPoint;

  /// Provides details about an Certificate Manager certificate.
  final AwsCertificateManagerCertificateDetails?
      awsCertificateManagerCertificate;

  /// Details about an CloudFormation stack. A stack is a collection of Amazon Web
  /// Services resources that you can manage as a single unit.
  final AwsCloudFormationStackDetails? awsCloudFormationStack;

  /// Details about a CloudFront distribution.
  final AwsCloudFrontDistributionDetails? awsCloudFrontDistribution;

  /// Provides details about a CloudTrail trail.
  final AwsCloudTrailTrailDetails? awsCloudTrailTrail;

  /// Details about an Amazon CloudWatch alarm. An alarm allows you to monitor and
  /// receive alerts about your Amazon Web Services resources and applications
  /// across multiple Regions.
  final AwsCloudWatchAlarmDetails? awsCloudWatchAlarm;

  /// Details for an CodeBuild project.
  final AwsCodeBuildProjectDetails? awsCodeBuildProject;

  /// Provides details about an Database Migration Service (DMS) endpoint. An
  /// endpoint provides connection, data store type, and location information
  /// about your data store.
  final AwsDmsEndpointDetails? awsDmsEndpoint;

  /// Provides details about an DMS replication instance. DMS uses a replication
  /// instance to connect to your source data store, read the source data, and
  /// format the data for consumption by the target data store.
  final AwsDmsReplicationInstanceDetails? awsDmsReplicationInstance;

  /// Provides details about an DMS replication task. A replication task moves a
  /// set of data from the source endpoint to the target endpoint.
  final AwsDmsReplicationTaskDetails? awsDmsReplicationTask;

  /// Details about a DynamoDB table.
  final AwsDynamoDbTableDetails? awsDynamoDbTable;

  /// Provides details about an Client VPN endpoint. A Client VPN endpoint is the
  /// resource that you create and configure to enable and manage client VPN
  /// sessions. It's the termination point for all client VPN sessions.
  final AwsEc2ClientVpnEndpointDetails? awsEc2ClientVpnEndpoint;

  /// Details about an Elastic IP address.
  final AwsEc2EipDetails? awsEc2Eip;

  /// Details about an EC2 instance related to a finding.
  final AwsEc2InstanceDetails? awsEc2Instance;
  final AwsEc2LaunchTemplateDetails? awsEc2LaunchTemplate;

  /// Details about an EC2 network access control list (ACL).
  final AwsEc2NetworkAclDetails? awsEc2NetworkAcl;

  /// Details for an EC2 network interface.
  final AwsEc2NetworkInterfaceDetails? awsEc2NetworkInterface;

  /// Provides details about a route table. A route table contains a set of rules,
  /// called routes, that determine where to direct network traffic from your
  /// subnet or gateway.
  final AwsEc2RouteTableDetails? awsEc2RouteTable;

  /// Details for an EC2 security group.
  final AwsEc2SecurityGroupDetails? awsEc2SecurityGroup;

  /// Details about a subnet in Amazon EC2.
  final AwsEc2SubnetDetails? awsEc2Subnet;

  /// Details about an Amazon EC2 transit gateway that interconnects your virtual
  /// private clouds (VPC) and on-premises networks.
  final AwsEc2TransitGatewayDetails? awsEc2TransitGateway;

  /// Details for an Amazon EC2 volume.
  final AwsEc2VolumeDetails? awsEc2Volume;

  /// Details for an Amazon EC2 VPC.
  final AwsEc2VpcDetails? awsEc2Vpc;

  /// Details about the service configuration for a VPC endpoint service.
  final AwsEc2VpcEndpointServiceDetails? awsEc2VpcEndpointService;

  /// Details about an Amazon EC2 VPC peering connection. A VPC peering connection
  /// is a networking connection between two VPCs that enables you to route
  /// traffic between them privately.
  final AwsEc2VpcPeeringConnectionDetails? awsEc2VpcPeeringConnection;

  /// Details about an Amazon EC2 VPN connection.
  final AwsEc2VpnConnectionDetails? awsEc2VpnConnection;

  /// Information about an Amazon ECR image.
  final AwsEcrContainerImageDetails? awsEcrContainerImage;

  /// Information about an Amazon Elastic Container Registry repository.
  final AwsEcrRepositoryDetails? awsEcrRepository;

  /// Details about an Amazon ECS cluster.
  final AwsEcsClusterDetails? awsEcsCluster;

  /// Provides information about a Docker container that's part of a task.
  final AwsEcsContainerDetails? awsEcsContainer;

  /// Details about a service within an ECS cluster.
  final AwsEcsServiceDetails? awsEcsService;

  /// Details about a task in a cluster.
  final AwsEcsTaskDetails? awsEcsTask;

  /// Details about a task definition. A task definition describes the container
  /// and volume definitions of an Amazon Elastic Container Service task.
  final AwsEcsTaskDefinitionDetails? awsEcsTaskDefinition;

  /// Details about an Amazon EFS access point. An access point is an
  /// application-specific view into an EFS file system that applies an operating
  /// system user and group, and a file system path, to any file system request
  /// made through the access point.
  final AwsEfsAccessPointDetails? awsEfsAccessPoint;

  /// Details about an Amazon EKS cluster.
  final AwsEksClusterDetails? awsEksCluster;

  /// Details about an Elastic Beanstalk environment.
  final AwsElasticBeanstalkEnvironmentDetails? awsElasticBeanstalkEnvironment;

  /// Details for an Elasticsearch domain.
  final AwsElasticsearchDomainDetails? awsElasticsearchDomain;

  /// Contains details about a Classic Load Balancer.
  final AwsElbLoadBalancerDetails? awsElbLoadBalancer;

  /// Details about a load balancer.
  final AwsElbv2LoadBalancerDetails? awsElbv2LoadBalancer;

  /// A schema defines the structure of events that are sent to Amazon
  /// EventBridge. Schema registries are containers for schemas. They collect and
  /// organize schemas so that your schemas are in logical groups.
  final AwsEventSchemasRegistryDetails? awsEventSchemasRegistry;

  /// Provides details about an Amazon EventBridge global endpoint. The endpoint
  /// can improve your application’s availability by making it Regional-fault
  /// tolerant.
  final AwsEventsEndpointDetails? awsEventsEndpoint;

  /// Provides details about Amazon EventBridge event bus for an endpoint. An
  /// event bus is a router that receives events and delivers them to zero or more
  /// destinations, or targets.
  final AwsEventsEventbusDetails? awsEventsEventbus;

  /// Provides details about an Amazon GuardDuty detector. A detector is an object
  /// that represents the GuardDuty service. A detector is required for GuardDuty
  /// to become operational.
  final AwsGuardDutyDetectorDetails? awsGuardDutyDetector;

  /// Details about an IAM access key related to a finding.
  final AwsIamAccessKeyDetails? awsIamAccessKey;

  /// Contains details about an IAM group.
  final AwsIamGroupDetails? awsIamGroup;

  /// Details about an IAM permissions policy.
  final AwsIamPolicyDetails? awsIamPolicy;

  /// Details about an IAM role.
  final AwsIamRoleDetails? awsIamRole;

  /// Details about an IAM user.
  final AwsIamUserDetails? awsIamUser;

  /// Details about an Amazon Kinesis data stream.
  final AwsKinesisStreamDetails? awsKinesisStream;

  /// Details about an KMS key.
  final AwsKmsKeyDetails? awsKmsKey;

  /// Details about a Lambda function.
  final AwsLambdaFunctionDetails? awsLambdaFunction;

  /// Details for a Lambda layer version.
  final AwsLambdaLayerVersionDetails? awsLambdaLayerVersion;

  /// Provides details about an Amazon Managed Streaming for Apache Kafka (Amazon
  /// MSK) cluster.
  final AwsMskClusterDetails? awsMskCluster;

  /// Details about an Network Firewall firewall.
  final AwsNetworkFirewallFirewallDetails? awsNetworkFirewallFirewall;

  /// Details about an Network Firewall firewall policy.
  final AwsNetworkFirewallFirewallPolicyDetails?
      awsNetworkFirewallFirewallPolicy;

  /// Details about an Network Firewall rule group.
  final AwsNetworkFirewallRuleGroupDetails? awsNetworkFirewallRuleGroup;

  /// Details about an Amazon OpenSearch Service domain.
  final AwsOpenSearchServiceDomainDetails? awsOpenSearchServiceDomain;

  /// Details about an Amazon RDS database cluster.
  final AwsRdsDbClusterDetails? awsRdsDbCluster;

  /// Details about an Amazon RDS database cluster snapshot.
  final AwsRdsDbClusterSnapshotDetails? awsRdsDbClusterSnapshot;

  /// Details about an Amazon RDS database instance.
  final AwsRdsDbInstanceDetails? awsRdsDbInstance;

  /// Details about an Amazon RDS DB security group.
  final AwsRdsDbSecurityGroupDetails? awsRdsDbSecurityGroup;

  /// Details about an Amazon RDS database snapshot.
  final AwsRdsDbSnapshotDetails? awsRdsDbSnapshot;

  /// Details about an RDS event notification subscription.
  final AwsRdsEventSubscriptionDetails? awsRdsEventSubscription;

  /// Contains details about an Amazon Redshift cluster.
  final AwsRedshiftClusterDetails? awsRedshiftCluster;

  /// Provides details about an Amazon Route 53 hosted zone, including the four
  /// name servers assigned to the hosted zone. A hosted zone represents a
  /// collection of records that can be managed together, belonging to a single
  /// parent domain name.
  final AwsRoute53HostedZoneDetails? awsRoute53HostedZone;

  /// Provides details about an Amazon Simple Storage Service (Amazon S3) access
  /// point. S3 access points are named network endpoints that are attached to S3
  /// buckets that you can use to perform S3 object operations.
  final AwsS3AccessPointDetails? awsS3AccessPoint;

  /// Details about the Amazon S3 Public Access Block configuration for an
  /// account.
  final AwsS3AccountPublicAccessBlockDetails? awsS3AccountPublicAccessBlock;

  /// Details about an S3 bucket related to a finding.
  final AwsS3BucketDetails? awsS3Bucket;

  /// Details about an S3 object related to a finding.
  final AwsS3ObjectDetails? awsS3Object;
  final AwsSageMakerNotebookInstanceDetails? awsSageMakerNotebookInstance;

  /// Details about a Secrets Manager secret.
  final AwsSecretsManagerSecretDetails? awsSecretsManagerSecret;

  /// Details about an SNS topic.
  final AwsSnsTopicDetails? awsSnsTopic;

  /// Details about an SQS queue.
  final AwsSqsQueueDetails? awsSqsQueue;

  /// Provides information about the state of a patch on an instance based on the
  /// patch baseline that was used to patch the instance.
  final AwsSsmPatchComplianceDetails? awsSsmPatchCompliance;

  /// Provides details about an Step Functions state machine, which is a workflow
  /// consisting of a series of event-driven steps.
  final AwsStepFunctionStateMachineDetails? awsStepFunctionStateMachine;

  /// Details about a rate-based rule for global resources.
  final AwsWafRateBasedRuleDetails? awsWafRateBasedRule;

  /// Details about a rate-based rule for Regional resources.
  final AwsWafRegionalRateBasedRuleDetails? awsWafRegionalRateBasedRule;

  /// Details about an WAF rule for Regional resources.
  final AwsWafRegionalRuleDetails? awsWafRegionalRule;

  /// Details about an WAF rule group for Regional resources.
  final AwsWafRegionalRuleGroupDetails? awsWafRegionalRuleGroup;

  /// Details about an WAF web access control list (web ACL) for Regional
  /// resources.
  final AwsWafRegionalWebAclDetails? awsWafRegionalWebAcl;

  /// Details about an WAF rule for global resources.
  final AwsWafRuleDetails? awsWafRule;

  /// Details about an WAF rule group for global resources.
  final AwsWafRuleGroupDetails? awsWafRuleGroup;

  /// Details for an WAF web ACL.
  final AwsWafWebAclDetails? awsWafWebAcl;
  final AwsWafv2RuleGroupDetails? awsWafv2RuleGroup;
  final AwsWafv2WebAclDetails? awsWafv2WebAcl;

  /// Information about the encryption configuration for X-Ray.
  final AwsXrayEncryptionConfigDetails? awsXrayEncryptionConfig;

  /// Details about a container resource related to a finding.
  final ContainerDetails? container;

  /// Details about a resource that are not available in a type-specific details
  /// object. Use the <code>Other</code> object in the following cases.
  ///
  /// <ul>
  /// <li>
  /// The type-specific object does not contain all of the fields that you want to
  /// populate. In this case, first use the type-specific object to populate those
  /// fields. Use the <code>Other</code> object to populate the fields that are
  /// missing from the type-specific object.
  /// </li>
  /// <li>
  /// The resource type does not have a corresponding object. This includes
  /// resources for which the type is <code>Other</code>.
  /// </li>
  /// </ul>
  final Map<String, String>? other;

  ResourceDetails({
    this.awsAmazonMqBroker,
    this.awsApiGatewayRestApi,
    this.awsApiGatewayStage,
    this.awsApiGatewayV2Api,
    this.awsApiGatewayV2Stage,
    this.awsAppSyncGraphQlApi,
    this.awsAthenaWorkGroup,
    this.awsAutoScalingAutoScalingGroup,
    this.awsAutoScalingLaunchConfiguration,
    this.awsBackupBackupPlan,
    this.awsBackupBackupVault,
    this.awsBackupRecoveryPoint,
    this.awsCertificateManagerCertificate,
    this.awsCloudFormationStack,
    this.awsCloudFrontDistribution,
    this.awsCloudTrailTrail,
    this.awsCloudWatchAlarm,
    this.awsCodeBuildProject,
    this.awsDmsEndpoint,
    this.awsDmsReplicationInstance,
    this.awsDmsReplicationTask,
    this.awsDynamoDbTable,
    this.awsEc2ClientVpnEndpoint,
    this.awsEc2Eip,
    this.awsEc2Instance,
    this.awsEc2LaunchTemplate,
    this.awsEc2NetworkAcl,
    this.awsEc2NetworkInterface,
    this.awsEc2RouteTable,
    this.awsEc2SecurityGroup,
    this.awsEc2Subnet,
    this.awsEc2TransitGateway,
    this.awsEc2Volume,
    this.awsEc2Vpc,
    this.awsEc2VpcEndpointService,
    this.awsEc2VpcPeeringConnection,
    this.awsEc2VpnConnection,
    this.awsEcrContainerImage,
    this.awsEcrRepository,
    this.awsEcsCluster,
    this.awsEcsContainer,
    this.awsEcsService,
    this.awsEcsTask,
    this.awsEcsTaskDefinition,
    this.awsEfsAccessPoint,
    this.awsEksCluster,
    this.awsElasticBeanstalkEnvironment,
    this.awsElasticsearchDomain,
    this.awsElbLoadBalancer,
    this.awsElbv2LoadBalancer,
    this.awsEventSchemasRegistry,
    this.awsEventsEndpoint,
    this.awsEventsEventbus,
    this.awsGuardDutyDetector,
    this.awsIamAccessKey,
    this.awsIamGroup,
    this.awsIamPolicy,
    this.awsIamRole,
    this.awsIamUser,
    this.awsKinesisStream,
    this.awsKmsKey,
    this.awsLambdaFunction,
    this.awsLambdaLayerVersion,
    this.awsMskCluster,
    this.awsNetworkFirewallFirewall,
    this.awsNetworkFirewallFirewallPolicy,
    this.awsNetworkFirewallRuleGroup,
    this.awsOpenSearchServiceDomain,
    this.awsRdsDbCluster,
    this.awsRdsDbClusterSnapshot,
    this.awsRdsDbInstance,
    this.awsRdsDbSecurityGroup,
    this.awsRdsDbSnapshot,
    this.awsRdsEventSubscription,
    this.awsRedshiftCluster,
    this.awsRoute53HostedZone,
    this.awsS3AccessPoint,
    this.awsS3AccountPublicAccessBlock,
    this.awsS3Bucket,
    this.awsS3Object,
    this.awsSageMakerNotebookInstance,
    this.awsSecretsManagerSecret,
    this.awsSnsTopic,
    this.awsSqsQueue,
    this.awsSsmPatchCompliance,
    this.awsStepFunctionStateMachine,
    this.awsWafRateBasedRule,
    this.awsWafRegionalRateBasedRule,
    this.awsWafRegionalRule,
    this.awsWafRegionalRuleGroup,
    this.awsWafRegionalWebAcl,
    this.awsWafRule,
    this.awsWafRuleGroup,
    this.awsWafWebAcl,
    this.awsWafv2RuleGroup,
    this.awsWafv2WebAcl,
    this.awsXrayEncryptionConfig,
    this.container,
    this.other,
  });

  factory ResourceDetails.fromJson(Map<String, dynamic> json) {
    return ResourceDetails(
      awsAmazonMqBroker: json['AwsAmazonMqBroker'] != null
          ? AwsAmazonMqBrokerDetails.fromJson(
              json['AwsAmazonMqBroker'] as Map<String, dynamic>)
          : null,
      awsApiGatewayRestApi: json['AwsApiGatewayRestApi'] != null
          ? AwsApiGatewayRestApiDetails.fromJson(
              json['AwsApiGatewayRestApi'] as Map<String, dynamic>)
          : null,
      awsApiGatewayStage: json['AwsApiGatewayStage'] != null
          ? AwsApiGatewayStageDetails.fromJson(
              json['AwsApiGatewayStage'] as Map<String, dynamic>)
          : null,
      awsApiGatewayV2Api: json['AwsApiGatewayV2Api'] != null
          ? AwsApiGatewayV2ApiDetails.fromJson(
              json['AwsApiGatewayV2Api'] as Map<String, dynamic>)
          : null,
      awsApiGatewayV2Stage: json['AwsApiGatewayV2Stage'] != null
          ? AwsApiGatewayV2StageDetails.fromJson(
              json['AwsApiGatewayV2Stage'] as Map<String, dynamic>)
          : null,
      awsAppSyncGraphQlApi: json['AwsAppSyncGraphQlApi'] != null
          ? AwsAppSyncGraphQlApiDetails.fromJson(
              json['AwsAppSyncGraphQlApi'] as Map<String, dynamic>)
          : null,
      awsAthenaWorkGroup: json['AwsAthenaWorkGroup'] != null
          ? AwsAthenaWorkGroupDetails.fromJson(
              json['AwsAthenaWorkGroup'] as Map<String, dynamic>)
          : null,
      awsAutoScalingAutoScalingGroup: json['AwsAutoScalingAutoScalingGroup'] !=
              null
          ? AwsAutoScalingAutoScalingGroupDetails.fromJson(
              json['AwsAutoScalingAutoScalingGroup'] as Map<String, dynamic>)
          : null,
      awsAutoScalingLaunchConfiguration:
          json['AwsAutoScalingLaunchConfiguration'] != null
              ? AwsAutoScalingLaunchConfigurationDetails.fromJson(
                  json['AwsAutoScalingLaunchConfiguration']
                      as Map<String, dynamic>)
              : null,
      awsBackupBackupPlan: json['AwsBackupBackupPlan'] != null
          ? AwsBackupBackupPlanDetails.fromJson(
              json['AwsBackupBackupPlan'] as Map<String, dynamic>)
          : null,
      awsBackupBackupVault: json['AwsBackupBackupVault'] != null
          ? AwsBackupBackupVaultDetails.fromJson(
              json['AwsBackupBackupVault'] as Map<String, dynamic>)
          : null,
      awsBackupRecoveryPoint: json['AwsBackupRecoveryPoint'] != null
          ? AwsBackupRecoveryPointDetails.fromJson(
              json['AwsBackupRecoveryPoint'] as Map<String, dynamic>)
          : null,
      awsCertificateManagerCertificate:
          json['AwsCertificateManagerCertificate'] != null
              ? AwsCertificateManagerCertificateDetails.fromJson(
                  json['AwsCertificateManagerCertificate']
                      as Map<String, dynamic>)
              : null,
      awsCloudFormationStack: json['AwsCloudFormationStack'] != null
          ? AwsCloudFormationStackDetails.fromJson(
              json['AwsCloudFormationStack'] as Map<String, dynamic>)
          : null,
      awsCloudFrontDistribution: json['AwsCloudFrontDistribution'] != null
          ? AwsCloudFrontDistributionDetails.fromJson(
              json['AwsCloudFrontDistribution'] as Map<String, dynamic>)
          : null,
      awsCloudTrailTrail: json['AwsCloudTrailTrail'] != null
          ? AwsCloudTrailTrailDetails.fromJson(
              json['AwsCloudTrailTrail'] as Map<String, dynamic>)
          : null,
      awsCloudWatchAlarm: json['AwsCloudWatchAlarm'] != null
          ? AwsCloudWatchAlarmDetails.fromJson(
              json['AwsCloudWatchAlarm'] as Map<String, dynamic>)
          : null,
      awsCodeBuildProject: json['AwsCodeBuildProject'] != null
          ? AwsCodeBuildProjectDetails.fromJson(
              json['AwsCodeBuildProject'] as Map<String, dynamic>)
          : null,
      awsDmsEndpoint: json['AwsDmsEndpoint'] != null
          ? AwsDmsEndpointDetails.fromJson(
              json['AwsDmsEndpoint'] as Map<String, dynamic>)
          : null,
      awsDmsReplicationInstance: json['AwsDmsReplicationInstance'] != null
          ? AwsDmsReplicationInstanceDetails.fromJson(
              json['AwsDmsReplicationInstance'] as Map<String, dynamic>)
          : null,
      awsDmsReplicationTask: json['AwsDmsReplicationTask'] != null
          ? AwsDmsReplicationTaskDetails.fromJson(
              json['AwsDmsReplicationTask'] as Map<String, dynamic>)
          : null,
      awsDynamoDbTable: json['AwsDynamoDbTable'] != null
          ? AwsDynamoDbTableDetails.fromJson(
              json['AwsDynamoDbTable'] as Map<String, dynamic>)
          : null,
      awsEc2ClientVpnEndpoint: json['AwsEc2ClientVpnEndpoint'] != null
          ? AwsEc2ClientVpnEndpointDetails.fromJson(
              json['AwsEc2ClientVpnEndpoint'] as Map<String, dynamic>)
          : null,
      awsEc2Eip: json['AwsEc2Eip'] != null
          ? AwsEc2EipDetails.fromJson(json['AwsEc2Eip'] as Map<String, dynamic>)
          : null,
      awsEc2Instance: json['AwsEc2Instance'] != null
          ? AwsEc2InstanceDetails.fromJson(
              json['AwsEc2Instance'] as Map<String, dynamic>)
          : null,
      awsEc2LaunchTemplate: json['AwsEc2LaunchTemplate'] != null
          ? AwsEc2LaunchTemplateDetails.fromJson(
              json['AwsEc2LaunchTemplate'] as Map<String, dynamic>)
          : null,
      awsEc2NetworkAcl: json['AwsEc2NetworkAcl'] != null
          ? AwsEc2NetworkAclDetails.fromJson(
              json['AwsEc2NetworkAcl'] as Map<String, dynamic>)
          : null,
      awsEc2NetworkInterface: json['AwsEc2NetworkInterface'] != null
          ? AwsEc2NetworkInterfaceDetails.fromJson(
              json['AwsEc2NetworkInterface'] as Map<String, dynamic>)
          : null,
      awsEc2RouteTable: json['AwsEc2RouteTable'] != null
          ? AwsEc2RouteTableDetails.fromJson(
              json['AwsEc2RouteTable'] as Map<String, dynamic>)
          : null,
      awsEc2SecurityGroup: json['AwsEc2SecurityGroup'] != null
          ? AwsEc2SecurityGroupDetails.fromJson(
              json['AwsEc2SecurityGroup'] as Map<String, dynamic>)
          : null,
      awsEc2Subnet: json['AwsEc2Subnet'] != null
          ? AwsEc2SubnetDetails.fromJson(
              json['AwsEc2Subnet'] as Map<String, dynamic>)
          : null,
      awsEc2TransitGateway: json['AwsEc2TransitGateway'] != null
          ? AwsEc2TransitGatewayDetails.fromJson(
              json['AwsEc2TransitGateway'] as Map<String, dynamic>)
          : null,
      awsEc2Volume: json['AwsEc2Volume'] != null
          ? AwsEc2VolumeDetails.fromJson(
              json['AwsEc2Volume'] as Map<String, dynamic>)
          : null,
      awsEc2Vpc: json['AwsEc2Vpc'] != null
          ? AwsEc2VpcDetails.fromJson(json['AwsEc2Vpc'] as Map<String, dynamic>)
          : null,
      awsEc2VpcEndpointService: json['AwsEc2VpcEndpointService'] != null
          ? AwsEc2VpcEndpointServiceDetails.fromJson(
              json['AwsEc2VpcEndpointService'] as Map<String, dynamic>)
          : null,
      awsEc2VpcPeeringConnection: json['AwsEc2VpcPeeringConnection'] != null
          ? AwsEc2VpcPeeringConnectionDetails.fromJson(
              json['AwsEc2VpcPeeringConnection'] as Map<String, dynamic>)
          : null,
      awsEc2VpnConnection: json['AwsEc2VpnConnection'] != null
          ? AwsEc2VpnConnectionDetails.fromJson(
              json['AwsEc2VpnConnection'] as Map<String, dynamic>)
          : null,
      awsEcrContainerImage: json['AwsEcrContainerImage'] != null
          ? AwsEcrContainerImageDetails.fromJson(
              json['AwsEcrContainerImage'] as Map<String, dynamic>)
          : null,
      awsEcrRepository: json['AwsEcrRepository'] != null
          ? AwsEcrRepositoryDetails.fromJson(
              json['AwsEcrRepository'] as Map<String, dynamic>)
          : null,
      awsEcsCluster: json['AwsEcsCluster'] != null
          ? AwsEcsClusterDetails.fromJson(
              json['AwsEcsCluster'] as Map<String, dynamic>)
          : null,
      awsEcsContainer: json['AwsEcsContainer'] != null
          ? AwsEcsContainerDetails.fromJson(
              json['AwsEcsContainer'] as Map<String, dynamic>)
          : null,
      awsEcsService: json['AwsEcsService'] != null
          ? AwsEcsServiceDetails.fromJson(
              json['AwsEcsService'] as Map<String, dynamic>)
          : null,
      awsEcsTask: json['AwsEcsTask'] != null
          ? AwsEcsTaskDetails.fromJson(
              json['AwsEcsTask'] as Map<String, dynamic>)
          : null,
      awsEcsTaskDefinition: json['AwsEcsTaskDefinition'] != null
          ? AwsEcsTaskDefinitionDetails.fromJson(
              json['AwsEcsTaskDefinition'] as Map<String, dynamic>)
          : null,
      awsEfsAccessPoint: json['AwsEfsAccessPoint'] != null
          ? AwsEfsAccessPointDetails.fromJson(
              json['AwsEfsAccessPoint'] as Map<String, dynamic>)
          : null,
      awsEksCluster: json['AwsEksCluster'] != null
          ? AwsEksClusterDetails.fromJson(
              json['AwsEksCluster'] as Map<String, dynamic>)
          : null,
      awsElasticBeanstalkEnvironment: json['AwsElasticBeanstalkEnvironment'] !=
              null
          ? AwsElasticBeanstalkEnvironmentDetails.fromJson(
              json['AwsElasticBeanstalkEnvironment'] as Map<String, dynamic>)
          : null,
      awsElasticsearchDomain: json['AwsElasticsearchDomain'] != null
          ? AwsElasticsearchDomainDetails.fromJson(
              json['AwsElasticsearchDomain'] as Map<String, dynamic>)
          : null,
      awsElbLoadBalancer: json['AwsElbLoadBalancer'] != null
          ? AwsElbLoadBalancerDetails.fromJson(
              json['AwsElbLoadBalancer'] as Map<String, dynamic>)
          : null,
      awsElbv2LoadBalancer: json['AwsElbv2LoadBalancer'] != null
          ? AwsElbv2LoadBalancerDetails.fromJson(
              json['AwsElbv2LoadBalancer'] as Map<String, dynamic>)
          : null,
      awsEventSchemasRegistry: json['AwsEventSchemasRegistry'] != null
          ? AwsEventSchemasRegistryDetails.fromJson(
              json['AwsEventSchemasRegistry'] as Map<String, dynamic>)
          : null,
      awsEventsEndpoint: json['AwsEventsEndpoint'] != null
          ? AwsEventsEndpointDetails.fromJson(
              json['AwsEventsEndpoint'] as Map<String, dynamic>)
          : null,
      awsEventsEventbus: json['AwsEventsEventbus'] != null
          ? AwsEventsEventbusDetails.fromJson(
              json['AwsEventsEventbus'] as Map<String, dynamic>)
          : null,
      awsGuardDutyDetector: json['AwsGuardDutyDetector'] != null
          ? AwsGuardDutyDetectorDetails.fromJson(
              json['AwsGuardDutyDetector'] as Map<String, dynamic>)
          : null,
      awsIamAccessKey: json['AwsIamAccessKey'] != null
          ? AwsIamAccessKeyDetails.fromJson(
              json['AwsIamAccessKey'] as Map<String, dynamic>)
          : null,
      awsIamGroup: json['AwsIamGroup'] != null
          ? AwsIamGroupDetails.fromJson(
              json['AwsIamGroup'] as Map<String, dynamic>)
          : null,
      awsIamPolicy: json['AwsIamPolicy'] != null
          ? AwsIamPolicyDetails.fromJson(
              json['AwsIamPolicy'] as Map<String, dynamic>)
          : null,
      awsIamRole: json['AwsIamRole'] != null
          ? AwsIamRoleDetails.fromJson(
              json['AwsIamRole'] as Map<String, dynamic>)
          : null,
      awsIamUser: json['AwsIamUser'] != null
          ? AwsIamUserDetails.fromJson(
              json['AwsIamUser'] as Map<String, dynamic>)
          : null,
      awsKinesisStream: json['AwsKinesisStream'] != null
          ? AwsKinesisStreamDetails.fromJson(
              json['AwsKinesisStream'] as Map<String, dynamic>)
          : null,
      awsKmsKey: json['AwsKmsKey'] != null
          ? AwsKmsKeyDetails.fromJson(json['AwsKmsKey'] as Map<String, dynamic>)
          : null,
      awsLambdaFunction: json['AwsLambdaFunction'] != null
          ? AwsLambdaFunctionDetails.fromJson(
              json['AwsLambdaFunction'] as Map<String, dynamic>)
          : null,
      awsLambdaLayerVersion: json['AwsLambdaLayerVersion'] != null
          ? AwsLambdaLayerVersionDetails.fromJson(
              json['AwsLambdaLayerVersion'] as Map<String, dynamic>)
          : null,
      awsMskCluster: json['AwsMskCluster'] != null
          ? AwsMskClusterDetails.fromJson(
              json['AwsMskCluster'] as Map<String, dynamic>)
          : null,
      awsNetworkFirewallFirewall: json['AwsNetworkFirewallFirewall'] != null
          ? AwsNetworkFirewallFirewallDetails.fromJson(
              json['AwsNetworkFirewallFirewall'] as Map<String, dynamic>)
          : null,
      awsNetworkFirewallFirewallPolicy:
          json['AwsNetworkFirewallFirewallPolicy'] != null
              ? AwsNetworkFirewallFirewallPolicyDetails.fromJson(
                  json['AwsNetworkFirewallFirewallPolicy']
                      as Map<String, dynamic>)
              : null,
      awsNetworkFirewallRuleGroup: json['AwsNetworkFirewallRuleGroup'] != null
          ? AwsNetworkFirewallRuleGroupDetails.fromJson(
              json['AwsNetworkFirewallRuleGroup'] as Map<String, dynamic>)
          : null,
      awsOpenSearchServiceDomain: json['AwsOpenSearchServiceDomain'] != null
          ? AwsOpenSearchServiceDomainDetails.fromJson(
              json['AwsOpenSearchServiceDomain'] as Map<String, dynamic>)
          : null,
      awsRdsDbCluster: json['AwsRdsDbCluster'] != null
          ? AwsRdsDbClusterDetails.fromJson(
              json['AwsRdsDbCluster'] as Map<String, dynamic>)
          : null,
      awsRdsDbClusterSnapshot: json['AwsRdsDbClusterSnapshot'] != null
          ? AwsRdsDbClusterSnapshotDetails.fromJson(
              json['AwsRdsDbClusterSnapshot'] as Map<String, dynamic>)
          : null,
      awsRdsDbInstance: json['AwsRdsDbInstance'] != null
          ? AwsRdsDbInstanceDetails.fromJson(
              json['AwsRdsDbInstance'] as Map<String, dynamic>)
          : null,
      awsRdsDbSecurityGroup: json['AwsRdsDbSecurityGroup'] != null
          ? AwsRdsDbSecurityGroupDetails.fromJson(
              json['AwsRdsDbSecurityGroup'] as Map<String, dynamic>)
          : null,
      awsRdsDbSnapshot: json['AwsRdsDbSnapshot'] != null
          ? AwsRdsDbSnapshotDetails.fromJson(
              json['AwsRdsDbSnapshot'] as Map<String, dynamic>)
          : null,
      awsRdsEventSubscription: json['AwsRdsEventSubscription'] != null
          ? AwsRdsEventSubscriptionDetails.fromJson(
              json['AwsRdsEventSubscription'] as Map<String, dynamic>)
          : null,
      awsRedshiftCluster: json['AwsRedshiftCluster'] != null
          ? AwsRedshiftClusterDetails.fromJson(
              json['AwsRedshiftCluster'] as Map<String, dynamic>)
          : null,
      awsRoute53HostedZone: json['AwsRoute53HostedZone'] != null
          ? AwsRoute53HostedZoneDetails.fromJson(
              json['AwsRoute53HostedZone'] as Map<String, dynamic>)
          : null,
      awsS3AccessPoint: json['AwsS3AccessPoint'] != null
          ? AwsS3AccessPointDetails.fromJson(
              json['AwsS3AccessPoint'] as Map<String, dynamic>)
          : null,
      awsS3AccountPublicAccessBlock:
          json['AwsS3AccountPublicAccessBlock'] != null
              ? AwsS3AccountPublicAccessBlockDetails.fromJson(
                  json['AwsS3AccountPublicAccessBlock'] as Map<String, dynamic>)
              : null,
      awsS3Bucket: json['AwsS3Bucket'] != null
          ? AwsS3BucketDetails.fromJson(
              json['AwsS3Bucket'] as Map<String, dynamic>)
          : null,
      awsS3Object: json['AwsS3Object'] != null
          ? AwsS3ObjectDetails.fromJson(
              json['AwsS3Object'] as Map<String, dynamic>)
          : null,
      awsSageMakerNotebookInstance: json['AwsSageMakerNotebookInstance'] != null
          ? AwsSageMakerNotebookInstanceDetails.fromJson(
              json['AwsSageMakerNotebookInstance'] as Map<String, dynamic>)
          : null,
      awsSecretsManagerSecret: json['AwsSecretsManagerSecret'] != null
          ? AwsSecretsManagerSecretDetails.fromJson(
              json['AwsSecretsManagerSecret'] as Map<String, dynamic>)
          : null,
      awsSnsTopic: json['AwsSnsTopic'] != null
          ? AwsSnsTopicDetails.fromJson(
              json['AwsSnsTopic'] as Map<String, dynamic>)
          : null,
      awsSqsQueue: json['AwsSqsQueue'] != null
          ? AwsSqsQueueDetails.fromJson(
              json['AwsSqsQueue'] as Map<String, dynamic>)
          : null,
      awsSsmPatchCompliance: json['AwsSsmPatchCompliance'] != null
          ? AwsSsmPatchComplianceDetails.fromJson(
              json['AwsSsmPatchCompliance'] as Map<String, dynamic>)
          : null,
      awsStepFunctionStateMachine: json['AwsStepFunctionStateMachine'] != null
          ? AwsStepFunctionStateMachineDetails.fromJson(
              json['AwsStepFunctionStateMachine'] as Map<String, dynamic>)
          : null,
      awsWafRateBasedRule: json['AwsWafRateBasedRule'] != null
          ? AwsWafRateBasedRuleDetails.fromJson(
              json['AwsWafRateBasedRule'] as Map<String, dynamic>)
          : null,
      awsWafRegionalRateBasedRule: json['AwsWafRegionalRateBasedRule'] != null
          ? AwsWafRegionalRateBasedRuleDetails.fromJson(
              json['AwsWafRegionalRateBasedRule'] as Map<String, dynamic>)
          : null,
      awsWafRegionalRule: json['AwsWafRegionalRule'] != null
          ? AwsWafRegionalRuleDetails.fromJson(
              json['AwsWafRegionalRule'] as Map<String, dynamic>)
          : null,
      awsWafRegionalRuleGroup: json['AwsWafRegionalRuleGroup'] != null
          ? AwsWafRegionalRuleGroupDetails.fromJson(
              json['AwsWafRegionalRuleGroup'] as Map<String, dynamic>)
          : null,
      awsWafRegionalWebAcl: json['AwsWafRegionalWebAcl'] != null
          ? AwsWafRegionalWebAclDetails.fromJson(
              json['AwsWafRegionalWebAcl'] as Map<String, dynamic>)
          : null,
      awsWafRule: json['AwsWafRule'] != null
          ? AwsWafRuleDetails.fromJson(
              json['AwsWafRule'] as Map<String, dynamic>)
          : null,
      awsWafRuleGroup: json['AwsWafRuleGroup'] != null
          ? AwsWafRuleGroupDetails.fromJson(
              json['AwsWafRuleGroup'] as Map<String, dynamic>)
          : null,
      awsWafWebAcl: json['AwsWafWebAcl'] != null
          ? AwsWafWebAclDetails.fromJson(
              json['AwsWafWebAcl'] as Map<String, dynamic>)
          : null,
      awsWafv2RuleGroup: json['AwsWafv2RuleGroup'] != null
          ? AwsWafv2RuleGroupDetails.fromJson(
              json['AwsWafv2RuleGroup'] as Map<String, dynamic>)
          : null,
      awsWafv2WebAcl: json['AwsWafv2WebAcl'] != null
          ? AwsWafv2WebAclDetails.fromJson(
              json['AwsWafv2WebAcl'] as Map<String, dynamic>)
          : null,
      awsXrayEncryptionConfig: json['AwsXrayEncryptionConfig'] != null
          ? AwsXrayEncryptionConfigDetails.fromJson(
              json['AwsXrayEncryptionConfig'] as Map<String, dynamic>)
          : null,
      container: json['Container'] != null
          ? ContainerDetails.fromJson(json['Container'] as Map<String, dynamic>)
          : null,
      other: (json['Other'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final awsAmazonMqBroker = this.awsAmazonMqBroker;
    final awsApiGatewayRestApi = this.awsApiGatewayRestApi;
    final awsApiGatewayStage = this.awsApiGatewayStage;
    final awsApiGatewayV2Api = this.awsApiGatewayV2Api;
    final awsApiGatewayV2Stage = this.awsApiGatewayV2Stage;
    final awsAppSyncGraphQlApi = this.awsAppSyncGraphQlApi;
    final awsAthenaWorkGroup = this.awsAthenaWorkGroup;
    final awsAutoScalingAutoScalingGroup = this.awsAutoScalingAutoScalingGroup;
    final awsAutoScalingLaunchConfiguration =
        this.awsAutoScalingLaunchConfiguration;
    final awsBackupBackupPlan = this.awsBackupBackupPlan;
    final awsBackupBackupVault = this.awsBackupBackupVault;
    final awsBackupRecoveryPoint = this.awsBackupRecoveryPoint;
    final awsCertificateManagerCertificate =
        this.awsCertificateManagerCertificate;
    final awsCloudFormationStack = this.awsCloudFormationStack;
    final awsCloudFrontDistribution = this.awsCloudFrontDistribution;
    final awsCloudTrailTrail = this.awsCloudTrailTrail;
    final awsCloudWatchAlarm = this.awsCloudWatchAlarm;
    final awsCodeBuildProject = this.awsCodeBuildProject;
    final awsDmsEndpoint = this.awsDmsEndpoint;
    final awsDmsReplicationInstance = this.awsDmsReplicationInstance;
    final awsDmsReplicationTask = this.awsDmsReplicationTask;
    final awsDynamoDbTable = this.awsDynamoDbTable;
    final awsEc2ClientVpnEndpoint = this.awsEc2ClientVpnEndpoint;
    final awsEc2Eip = this.awsEc2Eip;
    final awsEc2Instance = this.awsEc2Instance;
    final awsEc2LaunchTemplate = this.awsEc2LaunchTemplate;
    final awsEc2NetworkAcl = this.awsEc2NetworkAcl;
    final awsEc2NetworkInterface = this.awsEc2NetworkInterface;
    final awsEc2RouteTable = this.awsEc2RouteTable;
    final awsEc2SecurityGroup = this.awsEc2SecurityGroup;
    final awsEc2Subnet = this.awsEc2Subnet;
    final awsEc2TransitGateway = this.awsEc2TransitGateway;
    final awsEc2Volume = this.awsEc2Volume;
    final awsEc2Vpc = this.awsEc2Vpc;
    final awsEc2VpcEndpointService = this.awsEc2VpcEndpointService;
    final awsEc2VpcPeeringConnection = this.awsEc2VpcPeeringConnection;
    final awsEc2VpnConnection = this.awsEc2VpnConnection;
    final awsEcrContainerImage = this.awsEcrContainerImage;
    final awsEcrRepository = this.awsEcrRepository;
    final awsEcsCluster = this.awsEcsCluster;
    final awsEcsContainer = this.awsEcsContainer;
    final awsEcsService = this.awsEcsService;
    final awsEcsTask = this.awsEcsTask;
    final awsEcsTaskDefinition = this.awsEcsTaskDefinition;
    final awsEfsAccessPoint = this.awsEfsAccessPoint;
    final awsEksCluster = this.awsEksCluster;
    final awsElasticBeanstalkEnvironment = this.awsElasticBeanstalkEnvironment;
    final awsElasticsearchDomain = this.awsElasticsearchDomain;
    final awsElbLoadBalancer = this.awsElbLoadBalancer;
    final awsElbv2LoadBalancer = this.awsElbv2LoadBalancer;
    final awsEventSchemasRegistry = this.awsEventSchemasRegistry;
    final awsEventsEndpoint = this.awsEventsEndpoint;
    final awsEventsEventbus = this.awsEventsEventbus;
    final awsGuardDutyDetector = this.awsGuardDutyDetector;
    final awsIamAccessKey = this.awsIamAccessKey;
    final awsIamGroup = this.awsIamGroup;
    final awsIamPolicy = this.awsIamPolicy;
    final awsIamRole = this.awsIamRole;
    final awsIamUser = this.awsIamUser;
    final awsKinesisStream = this.awsKinesisStream;
    final awsKmsKey = this.awsKmsKey;
    final awsLambdaFunction = this.awsLambdaFunction;
    final awsLambdaLayerVersion = this.awsLambdaLayerVersion;
    final awsMskCluster = this.awsMskCluster;
    final awsNetworkFirewallFirewall = this.awsNetworkFirewallFirewall;
    final awsNetworkFirewallFirewallPolicy =
        this.awsNetworkFirewallFirewallPolicy;
    final awsNetworkFirewallRuleGroup = this.awsNetworkFirewallRuleGroup;
    final awsOpenSearchServiceDomain = this.awsOpenSearchServiceDomain;
    final awsRdsDbCluster = this.awsRdsDbCluster;
    final awsRdsDbClusterSnapshot = this.awsRdsDbClusterSnapshot;
    final awsRdsDbInstance = this.awsRdsDbInstance;
    final awsRdsDbSecurityGroup = this.awsRdsDbSecurityGroup;
    final awsRdsDbSnapshot = this.awsRdsDbSnapshot;
    final awsRdsEventSubscription = this.awsRdsEventSubscription;
    final awsRedshiftCluster = this.awsRedshiftCluster;
    final awsRoute53HostedZone = this.awsRoute53HostedZone;
    final awsS3AccessPoint = this.awsS3AccessPoint;
    final awsS3AccountPublicAccessBlock = this.awsS3AccountPublicAccessBlock;
    final awsS3Bucket = this.awsS3Bucket;
    final awsS3Object = this.awsS3Object;
    final awsSageMakerNotebookInstance = this.awsSageMakerNotebookInstance;
    final awsSecretsManagerSecret = this.awsSecretsManagerSecret;
    final awsSnsTopic = this.awsSnsTopic;
    final awsSqsQueue = this.awsSqsQueue;
    final awsSsmPatchCompliance = this.awsSsmPatchCompliance;
    final awsStepFunctionStateMachine = this.awsStepFunctionStateMachine;
    final awsWafRateBasedRule = this.awsWafRateBasedRule;
    final awsWafRegionalRateBasedRule = this.awsWafRegionalRateBasedRule;
    final awsWafRegionalRule = this.awsWafRegionalRule;
    final awsWafRegionalRuleGroup = this.awsWafRegionalRuleGroup;
    final awsWafRegionalWebAcl = this.awsWafRegionalWebAcl;
    final awsWafRule = this.awsWafRule;
    final awsWafRuleGroup = this.awsWafRuleGroup;
    final awsWafWebAcl = this.awsWafWebAcl;
    final awsWafv2RuleGroup = this.awsWafv2RuleGroup;
    final awsWafv2WebAcl = this.awsWafv2WebAcl;
    final awsXrayEncryptionConfig = this.awsXrayEncryptionConfig;
    final container = this.container;
    final other = this.other;
    return {
      if (awsAmazonMqBroker != null) 'AwsAmazonMqBroker': awsAmazonMqBroker,
      if (awsApiGatewayRestApi != null)
        'AwsApiGatewayRestApi': awsApiGatewayRestApi,
      if (awsApiGatewayStage != null) 'AwsApiGatewayStage': awsApiGatewayStage,
      if (awsApiGatewayV2Api != null) 'AwsApiGatewayV2Api': awsApiGatewayV2Api,
      if (awsApiGatewayV2Stage != null)
        'AwsApiGatewayV2Stage': awsApiGatewayV2Stage,
      if (awsAppSyncGraphQlApi != null)
        'AwsAppSyncGraphQlApi': awsAppSyncGraphQlApi,
      if (awsAthenaWorkGroup != null) 'AwsAthenaWorkGroup': awsAthenaWorkGroup,
      if (awsAutoScalingAutoScalingGroup != null)
        'AwsAutoScalingAutoScalingGroup': awsAutoScalingAutoScalingGroup,
      if (awsAutoScalingLaunchConfiguration != null)
        'AwsAutoScalingLaunchConfiguration': awsAutoScalingLaunchConfiguration,
      if (awsBackupBackupPlan != null)
        'AwsBackupBackupPlan': awsBackupBackupPlan,
      if (awsBackupBackupVault != null)
        'AwsBackupBackupVault': awsBackupBackupVault,
      if (awsBackupRecoveryPoint != null)
        'AwsBackupRecoveryPoint': awsBackupRecoveryPoint,
      if (awsCertificateManagerCertificate != null)
        'AwsCertificateManagerCertificate': awsCertificateManagerCertificate,
      if (awsCloudFormationStack != null)
        'AwsCloudFormationStack': awsCloudFormationStack,
      if (awsCloudFrontDistribution != null)
        'AwsCloudFrontDistribution': awsCloudFrontDistribution,
      if (awsCloudTrailTrail != null) 'AwsCloudTrailTrail': awsCloudTrailTrail,
      if (awsCloudWatchAlarm != null) 'AwsCloudWatchAlarm': awsCloudWatchAlarm,
      if (awsCodeBuildProject != null)
        'AwsCodeBuildProject': awsCodeBuildProject,
      if (awsDmsEndpoint != null) 'AwsDmsEndpoint': awsDmsEndpoint,
      if (awsDmsReplicationInstance != null)
        'AwsDmsReplicationInstance': awsDmsReplicationInstance,
      if (awsDmsReplicationTask != null)
        'AwsDmsReplicationTask': awsDmsReplicationTask,
      if (awsDynamoDbTable != null) 'AwsDynamoDbTable': awsDynamoDbTable,
      if (awsEc2ClientVpnEndpoint != null)
        'AwsEc2ClientVpnEndpoint': awsEc2ClientVpnEndpoint,
      if (awsEc2Eip != null) 'AwsEc2Eip': awsEc2Eip,
      if (awsEc2Instance != null) 'AwsEc2Instance': awsEc2Instance,
      if (awsEc2LaunchTemplate != null)
        'AwsEc2LaunchTemplate': awsEc2LaunchTemplate,
      if (awsEc2NetworkAcl != null) 'AwsEc2NetworkAcl': awsEc2NetworkAcl,
      if (awsEc2NetworkInterface != null)
        'AwsEc2NetworkInterface': awsEc2NetworkInterface,
      if (awsEc2RouteTable != null) 'AwsEc2RouteTable': awsEc2RouteTable,
      if (awsEc2SecurityGroup != null)
        'AwsEc2SecurityGroup': awsEc2SecurityGroup,
      if (awsEc2Subnet != null) 'AwsEc2Subnet': awsEc2Subnet,
      if (awsEc2TransitGateway != null)
        'AwsEc2TransitGateway': awsEc2TransitGateway,
      if (awsEc2Volume != null) 'AwsEc2Volume': awsEc2Volume,
      if (awsEc2Vpc != null) 'AwsEc2Vpc': awsEc2Vpc,
      if (awsEc2VpcEndpointService != null)
        'AwsEc2VpcEndpointService': awsEc2VpcEndpointService,
      if (awsEc2VpcPeeringConnection != null)
        'AwsEc2VpcPeeringConnection': awsEc2VpcPeeringConnection,
      if (awsEc2VpnConnection != null)
        'AwsEc2VpnConnection': awsEc2VpnConnection,
      if (awsEcrContainerImage != null)
        'AwsEcrContainerImage': awsEcrContainerImage,
      if (awsEcrRepository != null) 'AwsEcrRepository': awsEcrRepository,
      if (awsEcsCluster != null) 'AwsEcsCluster': awsEcsCluster,
      if (awsEcsContainer != null) 'AwsEcsContainer': awsEcsContainer,
      if (awsEcsService != null) 'AwsEcsService': awsEcsService,
      if (awsEcsTask != null) 'AwsEcsTask': awsEcsTask,
      if (awsEcsTaskDefinition != null)
        'AwsEcsTaskDefinition': awsEcsTaskDefinition,
      if (awsEfsAccessPoint != null) 'AwsEfsAccessPoint': awsEfsAccessPoint,
      if (awsEksCluster != null) 'AwsEksCluster': awsEksCluster,
      if (awsElasticBeanstalkEnvironment != null)
        'AwsElasticBeanstalkEnvironment': awsElasticBeanstalkEnvironment,
      if (awsElasticsearchDomain != null)
        'AwsElasticsearchDomain': awsElasticsearchDomain,
      if (awsElbLoadBalancer != null) 'AwsElbLoadBalancer': awsElbLoadBalancer,
      if (awsElbv2LoadBalancer != null)
        'AwsElbv2LoadBalancer': awsElbv2LoadBalancer,
      if (awsEventSchemasRegistry != null)
        'AwsEventSchemasRegistry': awsEventSchemasRegistry,
      if (awsEventsEndpoint != null) 'AwsEventsEndpoint': awsEventsEndpoint,
      if (awsEventsEventbus != null) 'AwsEventsEventbus': awsEventsEventbus,
      if (awsGuardDutyDetector != null)
        'AwsGuardDutyDetector': awsGuardDutyDetector,
      if (awsIamAccessKey != null) 'AwsIamAccessKey': awsIamAccessKey,
      if (awsIamGroup != null) 'AwsIamGroup': awsIamGroup,
      if (awsIamPolicy != null) 'AwsIamPolicy': awsIamPolicy,
      if (awsIamRole != null) 'AwsIamRole': awsIamRole,
      if (awsIamUser != null) 'AwsIamUser': awsIamUser,
      if (awsKinesisStream != null) 'AwsKinesisStream': awsKinesisStream,
      if (awsKmsKey != null) 'AwsKmsKey': awsKmsKey,
      if (awsLambdaFunction != null) 'AwsLambdaFunction': awsLambdaFunction,
      if (awsLambdaLayerVersion != null)
        'AwsLambdaLayerVersion': awsLambdaLayerVersion,
      if (awsMskCluster != null) 'AwsMskCluster': awsMskCluster,
      if (awsNetworkFirewallFirewall != null)
        'AwsNetworkFirewallFirewall': awsNetworkFirewallFirewall,
      if (awsNetworkFirewallFirewallPolicy != null)
        'AwsNetworkFirewallFirewallPolicy': awsNetworkFirewallFirewallPolicy,
      if (awsNetworkFirewallRuleGroup != null)
        'AwsNetworkFirewallRuleGroup': awsNetworkFirewallRuleGroup,
      if (awsOpenSearchServiceDomain != null)
        'AwsOpenSearchServiceDomain': awsOpenSearchServiceDomain,
      if (awsRdsDbCluster != null) 'AwsRdsDbCluster': awsRdsDbCluster,
      if (awsRdsDbClusterSnapshot != null)
        'AwsRdsDbClusterSnapshot': awsRdsDbClusterSnapshot,
      if (awsRdsDbInstance != null) 'AwsRdsDbInstance': awsRdsDbInstance,
      if (awsRdsDbSecurityGroup != null)
        'AwsRdsDbSecurityGroup': awsRdsDbSecurityGroup,
      if (awsRdsDbSnapshot != null) 'AwsRdsDbSnapshot': awsRdsDbSnapshot,
      if (awsRdsEventSubscription != null)
        'AwsRdsEventSubscription': awsRdsEventSubscription,
      if (awsRedshiftCluster != null) 'AwsRedshiftCluster': awsRedshiftCluster,
      if (awsRoute53HostedZone != null)
        'AwsRoute53HostedZone': awsRoute53HostedZone,
      if (awsS3AccessPoint != null) 'AwsS3AccessPoint': awsS3AccessPoint,
      if (awsS3AccountPublicAccessBlock != null)
        'AwsS3AccountPublicAccessBlock': awsS3AccountPublicAccessBlock,
      if (awsS3Bucket != null) 'AwsS3Bucket': awsS3Bucket,
      if (awsS3Object != null) 'AwsS3Object': awsS3Object,
      if (awsSageMakerNotebookInstance != null)
        'AwsSageMakerNotebookInstance': awsSageMakerNotebookInstance,
      if (awsSecretsManagerSecret != null)
        'AwsSecretsManagerSecret': awsSecretsManagerSecret,
      if (awsSnsTopic != null) 'AwsSnsTopic': awsSnsTopic,
      if (awsSqsQueue != null) 'AwsSqsQueue': awsSqsQueue,
      if (awsSsmPatchCompliance != null)
        'AwsSsmPatchCompliance': awsSsmPatchCompliance,
      if (awsStepFunctionStateMachine != null)
        'AwsStepFunctionStateMachine': awsStepFunctionStateMachine,
      if (awsWafRateBasedRule != null)
        'AwsWafRateBasedRule': awsWafRateBasedRule,
      if (awsWafRegionalRateBasedRule != null)
        'AwsWafRegionalRateBasedRule': awsWafRegionalRateBasedRule,
      if (awsWafRegionalRule != null) 'AwsWafRegionalRule': awsWafRegionalRule,
      if (awsWafRegionalRuleGroup != null)
        'AwsWafRegionalRuleGroup': awsWafRegionalRuleGroup,
      if (awsWafRegionalWebAcl != null)
        'AwsWafRegionalWebAcl': awsWafRegionalWebAcl,
      if (awsWafRule != null) 'AwsWafRule': awsWafRule,
      if (awsWafRuleGroup != null) 'AwsWafRuleGroup': awsWafRuleGroup,
      if (awsWafWebAcl != null) 'AwsWafWebAcl': awsWafWebAcl,
      if (awsWafv2RuleGroup != null) 'AwsWafv2RuleGroup': awsWafv2RuleGroup,
      if (awsWafv2WebAcl != null) 'AwsWafv2WebAcl': awsWafv2WebAcl,
      if (awsXrayEncryptionConfig != null)
        'AwsXrayEncryptionConfig': awsXrayEncryptionConfig,
      if (container != null) 'Container': container,
      if (other != null) 'Other': other,
    };
  }
}

/// Details about the account that was not processed.
class Result {
  /// An Amazon Web Services account ID of the account that was not processed.
  final String? accountId;

  /// The reason that the account was not processed.
  final String? processingResult;

  Result({
    this.accountId,
    this.processingResult,
  });

  factory Result.fromJson(Map<String, dynamic> json) {
    return Result(
      accountId: json['AccountId'] as String?,
      processingResult: json['ProcessingResult'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final processingResult = this.processingResult;
    return {
      if (accountId != null) 'AccountId': accountId,
      if (processingResult != null) 'ProcessingResult': processingResult,
    };
  }
}

/// Provides details about the routes in the route table.
class RouteSetDetails {
  /// The ID of the carrier gateway.
  final String? carrierGatewayId;

  /// The Amazon Resource Name (ARN) of the core network.
  final String? coreNetworkArn;

  /// The IPv4 CIDR block used for the destination match.
  final String? destinationCidrBlock;

  /// The IPv6 CIDR block used for the destination match.
  final String? destinationIpv6CidrBlock;

  /// The prefix of the destination Amazon Web Service.
  final String? destinationPrefixListId;

  /// The ID of the egress-only internet gateway.
  final String? egressOnlyInternetGatewayId;

  /// The ID of a gateway attached to your VPC.
  final String? gatewayId;

  /// The ID of a NAT instance in your VPC.
  final String? instanceId;

  /// The ID of the Amazon Web Services account that owns the instance.
  final String? instanceOwnerId;

  /// The ID of the local gateway.
  final String? localGatewayId;

  /// The ID of a NAT gateway.
  final String? natGatewayId;

  /// The ID of the network interface.
  final String? networkInterfaceId;

  /// Describes how the route was created.
  final String? origin;

  /// The state of the route.
  final String? state;

  /// The ID of a transit gateway.
  final String? transitGatewayId;

  /// The ID of a VPC peering connection.
  final String? vpcPeeringConnectionId;

  RouteSetDetails({
    this.carrierGatewayId,
    this.coreNetworkArn,
    this.destinationCidrBlock,
    this.destinationIpv6CidrBlock,
    this.destinationPrefixListId,
    this.egressOnlyInternetGatewayId,
    this.gatewayId,
    this.instanceId,
    this.instanceOwnerId,
    this.localGatewayId,
    this.natGatewayId,
    this.networkInterfaceId,
    this.origin,
    this.state,
    this.transitGatewayId,
    this.vpcPeeringConnectionId,
  });

  factory RouteSetDetails.fromJson(Map<String, dynamic> json) {
    return RouteSetDetails(
      carrierGatewayId: json['CarrierGatewayId'] as String?,
      coreNetworkArn: json['CoreNetworkArn'] as String?,
      destinationCidrBlock: json['DestinationCidrBlock'] as String?,
      destinationIpv6CidrBlock: json['DestinationIpv6CidrBlock'] as String?,
      destinationPrefixListId: json['DestinationPrefixListId'] as String?,
      egressOnlyInternetGatewayId:
          json['EgressOnlyInternetGatewayId'] as String?,
      gatewayId: json['GatewayId'] as String?,
      instanceId: json['InstanceId'] as String?,
      instanceOwnerId: json['InstanceOwnerId'] as String?,
      localGatewayId: json['LocalGatewayId'] as String?,
      natGatewayId: json['NatGatewayId'] as String?,
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
      origin: json['Origin'] as String?,
      state: json['State'] as String?,
      transitGatewayId: json['TransitGatewayId'] as String?,
      vpcPeeringConnectionId: json['VpcPeeringConnectionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final carrierGatewayId = this.carrierGatewayId;
    final coreNetworkArn = this.coreNetworkArn;
    final destinationCidrBlock = this.destinationCidrBlock;
    final destinationIpv6CidrBlock = this.destinationIpv6CidrBlock;
    final destinationPrefixListId = this.destinationPrefixListId;
    final egressOnlyInternetGatewayId = this.egressOnlyInternetGatewayId;
    final gatewayId = this.gatewayId;
    final instanceId = this.instanceId;
    final instanceOwnerId = this.instanceOwnerId;
    final localGatewayId = this.localGatewayId;
    final natGatewayId = this.natGatewayId;
    final networkInterfaceId = this.networkInterfaceId;
    final origin = this.origin;
    final state = this.state;
    final transitGatewayId = this.transitGatewayId;
    final vpcPeeringConnectionId = this.vpcPeeringConnectionId;
    return {
      if (carrierGatewayId != null) 'CarrierGatewayId': carrierGatewayId,
      if (coreNetworkArn != null) 'CoreNetworkArn': coreNetworkArn,
      if (destinationCidrBlock != null)
        'DestinationCidrBlock': destinationCidrBlock,
      if (destinationIpv6CidrBlock != null)
        'DestinationIpv6CidrBlock': destinationIpv6CidrBlock,
      if (destinationPrefixListId != null)
        'DestinationPrefixListId': destinationPrefixListId,
      if (egressOnlyInternetGatewayId != null)
        'EgressOnlyInternetGatewayId': egressOnlyInternetGatewayId,
      if (gatewayId != null) 'GatewayId': gatewayId,
      if (instanceId != null) 'InstanceId': instanceId,
      if (instanceOwnerId != null) 'InstanceOwnerId': instanceOwnerId,
      if (localGatewayId != null) 'LocalGatewayId': localGatewayId,
      if (natGatewayId != null) 'NatGatewayId': natGatewayId,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (origin != null) 'Origin': origin,
      if (state != null) 'State': state,
      if (transitGatewayId != null) 'TransitGatewayId': transitGatewayId,
      if (vpcPeeringConnectionId != null)
        'VpcPeeringConnectionId': vpcPeeringConnectionId,
    };
  }
}

/// Details about the rule group.
class RuleGroupDetails {
  /// Additional settings to use in the specified rules.
  final RuleGroupVariables? ruleVariables;

  /// The rules and actions for the rule group.
  ///
  /// For stateful rule groups, can contain <code>RulesString</code>,
  /// <code>RulesSourceList</code>, or <code>StatefulRules</code>.
  ///
  /// For stateless rule groups, contains
  /// <code>StatelessRulesAndCustomActions</code>.
  final RuleGroupSource? rulesSource;

  RuleGroupDetails({
    this.ruleVariables,
    this.rulesSource,
  });

  factory RuleGroupDetails.fromJson(Map<String, dynamic> json) {
    return RuleGroupDetails(
      ruleVariables: json['RuleVariables'] != null
          ? RuleGroupVariables.fromJson(
              json['RuleVariables'] as Map<String, dynamic>)
          : null,
      rulesSource: json['RulesSource'] != null
          ? RuleGroupSource.fromJson(
              json['RulesSource'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final ruleVariables = this.ruleVariables;
    final rulesSource = this.rulesSource;
    return {
      if (ruleVariables != null) 'RuleVariables': ruleVariables,
      if (rulesSource != null) 'RulesSource': rulesSource,
    };
  }
}

/// The rules and actions for the rule group.
class RuleGroupSource {
  /// Stateful inspection criteria for a domain list rule group. A domain list
  /// rule group determines access by specific protocols to specific domains.
  final RuleGroupSourceListDetails? rulesSourceList;

  /// Stateful inspection criteria, provided in Suricata compatible intrusion
  /// prevention system (IPS) rules.
  final String? rulesString;

  /// Suricata rule specifications.
  final List<RuleGroupSourceStatefulRulesDetails>? statefulRules;

  /// The stateless rules and custom actions used by a stateless rule group.
  final RuleGroupSourceStatelessRulesAndCustomActionsDetails?
      statelessRulesAndCustomActions;

  RuleGroupSource({
    this.rulesSourceList,
    this.rulesString,
    this.statefulRules,
    this.statelessRulesAndCustomActions,
  });

  factory RuleGroupSource.fromJson(Map<String, dynamic> json) {
    return RuleGroupSource(
      rulesSourceList: json['RulesSourceList'] != null
          ? RuleGroupSourceListDetails.fromJson(
              json['RulesSourceList'] as Map<String, dynamic>)
          : null,
      rulesString: json['RulesString'] as String?,
      statefulRules: (json['StatefulRules'] as List?)
          ?.whereNotNull()
          .map((e) => RuleGroupSourceStatefulRulesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      statelessRulesAndCustomActions: json['StatelessRulesAndCustomActions'] !=
              null
          ? RuleGroupSourceStatelessRulesAndCustomActionsDetails.fromJson(
              json['StatelessRulesAndCustomActions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final rulesSourceList = this.rulesSourceList;
    final rulesString = this.rulesString;
    final statefulRules = this.statefulRules;
    final statelessRulesAndCustomActions = this.statelessRulesAndCustomActions;
    return {
      if (rulesSourceList != null) 'RulesSourceList': rulesSourceList,
      if (rulesString != null) 'RulesString': rulesString,
      if (statefulRules != null) 'StatefulRules': statefulRules,
      if (statelessRulesAndCustomActions != null)
        'StatelessRulesAndCustomActions': statelessRulesAndCustomActions,
    };
  }
}

/// A custom action definition. A custom action is an optional, non-standard
/// action to use for stateless packet handling.
class RuleGroupSourceCustomActionsDetails {
  /// The definition of a custom action.
  final StatelessCustomActionDefinition? actionDefinition;

  /// A descriptive name of the custom action.
  final String? actionName;

  RuleGroupSourceCustomActionsDetails({
    this.actionDefinition,
    this.actionName,
  });

  factory RuleGroupSourceCustomActionsDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceCustomActionsDetails(
      actionDefinition: json['ActionDefinition'] != null
          ? StatelessCustomActionDefinition.fromJson(
              json['ActionDefinition'] as Map<String, dynamic>)
          : null,
      actionName: json['ActionName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final actionDefinition = this.actionDefinition;
    final actionName = this.actionName;
    return {
      if (actionDefinition != null) 'ActionDefinition': actionDefinition,
      if (actionName != null) 'ActionName': actionName,
    };
  }
}

/// Stateful inspection criteria for a domain list rule group.
class RuleGroupSourceListDetails {
  /// Indicates whether to allow or deny access to the domains listed in
  /// <code>Targets</code>.
  final String? generatedRulesType;

  /// The protocols that you want to inspect. Specify <code>LS_SNI</code> for
  /// HTTPS. Specify <code>HTTP_HOST</code> for HTTP. You can specify either or
  /// both.
  final List<String>? targetTypes;

  /// The domains that you want to inspect for in your traffic flows. You can
  /// provide full domain names, or use the '.' prefix as a wildcard. For example,
  /// <code>.example.com</code> matches all domains that end with
  /// <code>example.com</code>.
  final List<String>? targets;

  RuleGroupSourceListDetails({
    this.generatedRulesType,
    this.targetTypes,
    this.targets,
  });

  factory RuleGroupSourceListDetails.fromJson(Map<String, dynamic> json) {
    return RuleGroupSourceListDetails(
      generatedRulesType: json['GeneratedRulesType'] as String?,
      targetTypes: (json['TargetTypes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      targets: (json['Targets'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final generatedRulesType = this.generatedRulesType;
    final targetTypes = this.targetTypes;
    final targets = this.targets;
    return {
      if (generatedRulesType != null) 'GeneratedRulesType': generatedRulesType,
      if (targetTypes != null) 'TargetTypes': targetTypes,
      if (targets != null) 'Targets': targets,
    };
  }
}

/// A Suricata rule specification.
class RuleGroupSourceStatefulRulesDetails {
  /// Defines what Network Firewall should do with the packets in a traffic flow
  /// when the flow matches the stateful rule criteria.
  final String? action;

  /// The stateful inspection criteria for the rule.
  final RuleGroupSourceStatefulRulesHeaderDetails? header;

  /// Additional options for the rule.
  final List<RuleGroupSourceStatefulRulesOptionsDetails>? ruleOptions;

  RuleGroupSourceStatefulRulesDetails({
    this.action,
    this.header,
    this.ruleOptions,
  });

  factory RuleGroupSourceStatefulRulesDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatefulRulesDetails(
      action: json['Action'] as String?,
      header: json['Header'] != null
          ? RuleGroupSourceStatefulRulesHeaderDetails.fromJson(
              json['Header'] as Map<String, dynamic>)
          : null,
      ruleOptions: (json['RuleOptions'] as List?)
          ?.whereNotNull()
          .map((e) => RuleGroupSourceStatefulRulesOptionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final action = this.action;
    final header = this.header;
    final ruleOptions = this.ruleOptions;
    return {
      if (action != null) 'Action': action,
      if (header != null) 'Header': header,
      if (ruleOptions != null) 'RuleOptions': ruleOptions,
    };
  }
}

/// The inspection criteria for a stateful rule.
class RuleGroupSourceStatefulRulesHeaderDetails {
  /// The destination IP address or address range to inspect for, in CIDR
  /// notation. To match with any address, specify <code>ANY</code>.
  final String? destination;

  /// The destination port to inspect for. You can specify an individual port,
  /// such as <code>1994</code>. You also can specify a port range, such as
  /// <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.
  final String? destinationPort;

  /// The direction of traffic flow to inspect. If set to <code>ANY</code>, the
  /// inspection matches bidirectional traffic, both from the source to the
  /// destination and from the destination to the source. If set to
  /// <code>FORWARD</code>, the inspection only matches traffic going from the
  /// source to the destination.
  final String? direction;

  /// The protocol to inspect for. To inspector for all protocols, use
  /// <code>IP</code>.
  final String? protocol;

  /// The source IP address or address range to inspect for, in CIDR notation. To
  /// match with any address, specify <code>ANY</code>.
  final String? source;

  /// The source port to inspect for. You can specify an individual port, such as
  /// <code>1994</code>. You also can specify a port range, such as
  /// <code>1990:1994</code>. To match with any port, specify <code>ANY</code>.
  final String? sourcePort;

  RuleGroupSourceStatefulRulesHeaderDetails({
    this.destination,
    this.destinationPort,
    this.direction,
    this.protocol,
    this.source,
    this.sourcePort,
  });

  factory RuleGroupSourceStatefulRulesHeaderDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatefulRulesHeaderDetails(
      destination: json['Destination'] as String?,
      destinationPort: json['DestinationPort'] as String?,
      direction: json['Direction'] as String?,
      protocol: json['Protocol'] as String?,
      source: json['Source'] as String?,
      sourcePort: json['SourcePort'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final destination = this.destination;
    final destinationPort = this.destinationPort;
    final direction = this.direction;
    final protocol = this.protocol;
    final source = this.source;
    final sourcePort = this.sourcePort;
    return {
      if (destination != null) 'Destination': destination,
      if (destinationPort != null) 'DestinationPort': destinationPort,
      if (direction != null) 'Direction': direction,
      if (protocol != null) 'Protocol': protocol,
      if (source != null) 'Source': source,
      if (sourcePort != null) 'SourcePort': sourcePort,
    };
  }
}

/// A rule option for a stateful rule.
class RuleGroupSourceStatefulRulesOptionsDetails {
  /// A keyword to look for.
  final String? keyword;

  /// A list of settings.
  final List<String>? settings;

  RuleGroupSourceStatefulRulesOptionsDetails({
    this.keyword,
    this.settings,
  });

  factory RuleGroupSourceStatefulRulesOptionsDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatefulRulesOptionsDetails(
      keyword: json['Keyword'] as String?,
      settings: (json['Settings'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final keyword = this.keyword;
    final settings = this.settings;
    return {
      if (keyword != null) 'Keyword': keyword,
      if (settings != null) 'Settings': settings,
    };
  }
}

/// The definition of the stateless rule.
class RuleGroupSourceStatelessRuleDefinition {
  /// The actions to take on a packet that matches one of the stateless rule
  /// definition's match attributes. You must specify a standard action
  /// (<code>aws:pass</code>, <code>aws:drop</code>, or
  /// <code>aws:forward_to_sfe</code>). You can then add custom actions.
  final List<String>? actions;

  /// The criteria for Network Firewall to use to inspect an individual packet in
  /// a stateless rule inspection.
  final RuleGroupSourceStatelessRuleMatchAttributes? matchAttributes;

  RuleGroupSourceStatelessRuleDefinition({
    this.actions,
    this.matchAttributes,
  });

  factory RuleGroupSourceStatelessRuleDefinition.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleDefinition(
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      matchAttributes: json['MatchAttributes'] != null
          ? RuleGroupSourceStatelessRuleMatchAttributes.fromJson(
              json['MatchAttributes'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final matchAttributes = this.matchAttributes;
    return {
      if (actions != null) 'Actions': actions,
      if (matchAttributes != null) 'MatchAttributes': matchAttributes,
    };
  }
}

/// Criteria for the stateless rule.
class RuleGroupSourceStatelessRuleMatchAttributes {
  /// A list of port ranges to specify the destination ports to inspect for.
  final List<RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts>?
      destinationPorts;

  /// The destination IP addresses and address ranges to inspect for, in CIDR
  /// notation.
  final List<RuleGroupSourceStatelessRuleMatchAttributesDestinations>?
      destinations;

  /// The protocols to inspect for.
  final List<int>? protocols;

  /// A list of port ranges to specify the source ports to inspect for.
  final List<RuleGroupSourceStatelessRuleMatchAttributesSourcePorts>?
      sourcePorts;

  /// The source IP addresses and address ranges to inspect for, in CIDR notation.
  final List<RuleGroupSourceStatelessRuleMatchAttributesSources>? sources;

  /// The TCP flags and masks to inspect for.
  final List<RuleGroupSourceStatelessRuleMatchAttributesTcpFlags>? tcpFlags;

  RuleGroupSourceStatelessRuleMatchAttributes({
    this.destinationPorts,
    this.destinations,
    this.protocols,
    this.sourcePorts,
    this.sources,
    this.tcpFlags,
  });

  factory RuleGroupSourceStatelessRuleMatchAttributes.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleMatchAttributes(
      destinationPorts: (json['DestinationPorts'] as List?)
          ?.whereNotNull()
          .map((e) =>
              RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts
                  .fromJson(e as Map<String, dynamic>))
          .toList(),
      destinations: (json['Destinations'] as List?)
          ?.whereNotNull()
          .map((e) =>
              RuleGroupSourceStatelessRuleMatchAttributesDestinations.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      protocols: (json['Protocols'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      sourcePorts: (json['SourcePorts'] as List?)
          ?.whereNotNull()
          .map((e) =>
              RuleGroupSourceStatelessRuleMatchAttributesSourcePorts.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      sources: (json['Sources'] as List?)
          ?.whereNotNull()
          .map((e) =>
              RuleGroupSourceStatelessRuleMatchAttributesSources.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      tcpFlags: (json['TcpFlags'] as List?)
          ?.whereNotNull()
          .map((e) =>
              RuleGroupSourceStatelessRuleMatchAttributesTcpFlags.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final destinationPorts = this.destinationPorts;
    final destinations = this.destinations;
    final protocols = this.protocols;
    final sourcePorts = this.sourcePorts;
    final sources = this.sources;
    final tcpFlags = this.tcpFlags;
    return {
      if (destinationPorts != null) 'DestinationPorts': destinationPorts,
      if (destinations != null) 'Destinations': destinations,
      if (protocols != null) 'Protocols': protocols,
      if (sourcePorts != null) 'SourcePorts': sourcePorts,
      if (sources != null) 'Sources': sources,
      if (tcpFlags != null) 'TcpFlags': tcpFlags,
    };
  }
}

/// A port range to specify the destination ports to inspect for.
class RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts {
  /// The starting port value for the port range.
  final int? fromPort;

  /// The ending port value for the port range.
  final int? toPort;

  RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts({
    this.fromPort,
    this.toPort,
  });

  factory RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleMatchAttributesDestinationPorts(
      fromPort: json['FromPort'] as int?,
      toPort: json['ToPort'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final fromPort = this.fromPort;
    final toPort = this.toPort;
    return {
      if (fromPort != null) 'FromPort': fromPort,
      if (toPort != null) 'ToPort': toPort,
    };
  }
}

/// A destination IP address or range.
class RuleGroupSourceStatelessRuleMatchAttributesDestinations {
  /// An IP address or a block of IP addresses.
  final String? addressDefinition;

  RuleGroupSourceStatelessRuleMatchAttributesDestinations({
    this.addressDefinition,
  });

  factory RuleGroupSourceStatelessRuleMatchAttributesDestinations.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleMatchAttributesDestinations(
      addressDefinition: json['AddressDefinition'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final addressDefinition = this.addressDefinition;
    return {
      if (addressDefinition != null) 'AddressDefinition': addressDefinition,
    };
  }
}

/// A port range to specify the source ports to inspect for.
class RuleGroupSourceStatelessRuleMatchAttributesSourcePorts {
  /// The starting port value for the port range.
  final int? fromPort;

  /// The ending port value for the port range.
  final int? toPort;

  RuleGroupSourceStatelessRuleMatchAttributesSourcePorts({
    this.fromPort,
    this.toPort,
  });

  factory RuleGroupSourceStatelessRuleMatchAttributesSourcePorts.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleMatchAttributesSourcePorts(
      fromPort: json['FromPort'] as int?,
      toPort: json['ToPort'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final fromPort = this.fromPort;
    final toPort = this.toPort;
    return {
      if (fromPort != null) 'FromPort': fromPort,
      if (toPort != null) 'ToPort': toPort,
    };
  }
}

/// A source IP addresses and address range to inspect for.
class RuleGroupSourceStatelessRuleMatchAttributesSources {
  /// An IP address or a block of IP addresses.
  final String? addressDefinition;

  RuleGroupSourceStatelessRuleMatchAttributesSources({
    this.addressDefinition,
  });

  factory RuleGroupSourceStatelessRuleMatchAttributesSources.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleMatchAttributesSources(
      addressDefinition: json['AddressDefinition'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final addressDefinition = this.addressDefinition;
    return {
      if (addressDefinition != null) 'AddressDefinition': addressDefinition,
    };
  }
}

/// A set of TCP flags and masks to inspect for.
class RuleGroupSourceStatelessRuleMatchAttributesTcpFlags {
  /// Defines the flags from the <code>Masks</code> setting that must be set in
  /// order for the packet to match. Flags that are listed must be set. Flags that
  /// are not listed must not be set.
  final List<String>? flags;

  /// The set of flags to consider in the inspection. If not specified, then all
  /// flags are inspected.
  final List<String>? masks;

  RuleGroupSourceStatelessRuleMatchAttributesTcpFlags({
    this.flags,
    this.masks,
  });

  factory RuleGroupSourceStatelessRuleMatchAttributesTcpFlags.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRuleMatchAttributesTcpFlags(
      flags: (json['Flags'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      masks: (json['Masks'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final flags = this.flags;
    final masks = this.masks;
    return {
      if (flags != null) 'Flags': flags,
      if (masks != null) 'Masks': masks,
    };
  }
}

/// Stateless rules and custom actions for a stateless rule group.
class RuleGroupSourceStatelessRulesAndCustomActionsDetails {
  /// Custom actions for the rule group.
  final List<RuleGroupSourceCustomActionsDetails>? customActions;

  /// Stateless rules for the rule group.
  final List<RuleGroupSourceStatelessRulesDetails>? statelessRules;

  RuleGroupSourceStatelessRulesAndCustomActionsDetails({
    this.customActions,
    this.statelessRules,
  });

  factory RuleGroupSourceStatelessRulesAndCustomActionsDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRulesAndCustomActionsDetails(
      customActions: (json['CustomActions'] as List?)
          ?.whereNotNull()
          .map((e) => RuleGroupSourceCustomActionsDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      statelessRules: (json['StatelessRules'] as List?)
          ?.whereNotNull()
          .map((e) => RuleGroupSourceStatelessRulesDetails.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final customActions = this.customActions;
    final statelessRules = this.statelessRules;
    return {
      if (customActions != null) 'CustomActions': customActions,
      if (statelessRules != null) 'StatelessRules': statelessRules,
    };
  }
}

/// A stateless rule in the rule group.
class RuleGroupSourceStatelessRulesDetails {
  /// Indicates the order in which to run this rule relative to all of the rules
  /// in the stateless rule group.
  final int? priority;

  /// Provides the definition of the stateless rule.
  final RuleGroupSourceStatelessRuleDefinition? ruleDefinition;

  RuleGroupSourceStatelessRulesDetails({
    this.priority,
    this.ruleDefinition,
  });

  factory RuleGroupSourceStatelessRulesDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupSourceStatelessRulesDetails(
      priority: json['Priority'] as int?,
      ruleDefinition: json['RuleDefinition'] != null
          ? RuleGroupSourceStatelessRuleDefinition.fromJson(
              json['RuleDefinition'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final priority = this.priority;
    final ruleDefinition = this.ruleDefinition;
    return {
      if (priority != null) 'Priority': priority,
      if (ruleDefinition != null) 'RuleDefinition': ruleDefinition,
    };
  }
}

/// Additional settings to use in the specified rules.
class RuleGroupVariables {
  /// A list of IP addresses and address ranges, in CIDR notation.
  final RuleGroupVariablesIpSetsDetails? ipSets;

  /// A list of port ranges.
  final RuleGroupVariablesPortSetsDetails? portSets;

  RuleGroupVariables({
    this.ipSets,
    this.portSets,
  });

  factory RuleGroupVariables.fromJson(Map<String, dynamic> json) {
    return RuleGroupVariables(
      ipSets: json['IpSets'] != null
          ? RuleGroupVariablesIpSetsDetails.fromJson(
              json['IpSets'] as Map<String, dynamic>)
          : null,
      portSets: json['PortSets'] != null
          ? RuleGroupVariablesPortSetsDetails.fromJson(
              json['PortSets'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final ipSets = this.ipSets;
    final portSets = this.portSets;
    return {
      if (ipSets != null) 'IpSets': ipSets,
      if (portSets != null) 'PortSets': portSets,
    };
  }
}

/// A list of IP addresses and address ranges, in CIDR notation.
class RuleGroupVariablesIpSetsDetails {
  /// The list of IP addresses and ranges.
  final List<String>? definition;

  RuleGroupVariablesIpSetsDetails({
    this.definition,
  });

  factory RuleGroupVariablesIpSetsDetails.fromJson(Map<String, dynamic> json) {
    return RuleGroupVariablesIpSetsDetails(
      definition: (json['Definition'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final definition = this.definition;
    return {
      if (definition != null) 'Definition': definition,
    };
  }
}

/// A list of port ranges.
class RuleGroupVariablesPortSetsDetails {
  /// The list of port ranges.
  final List<String>? definition;

  RuleGroupVariablesPortSetsDetails({
    this.definition,
  });

  factory RuleGroupVariablesPortSetsDetails.fromJson(
      Map<String, dynamic> json) {
    return RuleGroupVariablesPortSetsDetails(
      definition: (json['Definition'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final definition = this.definition;
    return {
      if (definition != null) 'Definition': definition,
    };
  }
}

enum RuleStatus {
  enabled,
  disabled,
}

extension RuleStatusValueExtension on RuleStatus {
  String toValue() {
    switch (this) {
      case RuleStatus.enabled:
        return 'ENABLED';
      case RuleStatus.disabled:
        return 'DISABLED';
    }
  }
}

extension RuleStatusFromString on String {
  RuleStatus toRuleStatus() {
    switch (this) {
      case 'ENABLED':
        return RuleStatus.enabled;
      case 'DISABLED':
        return RuleStatus.disabled;
    }
    throw Exception('$this is not known in enum RuleStatus');
  }
}

/// A security control in Security Hub describes a security best practice
/// related to a specific resource.
class SecurityControl {
  /// The description of a security control across standards. This typically
  /// summarizes how Security Hub evaluates the control and the conditions under
  /// which it produces a failed finding. This parameter doesn't reference a
  /// specific standard.
  final String description;

  /// A link to Security Hub documentation that explains how to remediate a failed
  /// finding for a security control.
  final String remediationUrl;

  /// The Amazon Resource Name (ARN) for a security control across standards, such
  /// as
  /// <code>arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1</code>.
  /// This parameter doesn't mention a specific standard.
  final String securityControlArn;

  /// The unique identifier of a security control across standards. Values for
  /// this field typically consist of an Amazon Web Service name and a number,
  /// such as APIGateway.3.
  final String securityControlId;

  /// The enablement status of a security control in a specific standard.
  final ControlStatus securityControlStatus;

  /// The severity of a security control. For more information about how Security
  /// Hub determines control severity, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/controls-findings-create-update.html#control-findings-severity">Assigning
  /// severity to control findings</a> in the <i>Security Hub User Guide</i>.
  final SeverityRating severityRating;

  /// The title of a security control.
  final String title;

  /// The most recent reason for updating the customizable properties of a
  /// security control. This differs from the <code>UpdateReason</code> field of
  /// the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html">
  /// <code>BatchUpdateStandardsControlAssociations</code> </a> API, which tracks
  /// the reason for updating the enablement status of a control. This field
  /// accepts alphanumeric characters in addition to white spaces, dashes, and
  /// underscores.
  final String? lastUpdateReason;

  /// An object that identifies the name of a control parameter, its current
  /// value, and whether it has been customized.
  final Map<String, ParameterConfiguration>? parameters;

  /// Identifies whether customizable properties of a security control are
  /// reflected in Security Hub findings. A status of <code>READY</code> indicates
  /// findings include the current parameter values. A status of
  /// <code>UPDATING</code> indicates that all findings may not include the
  /// current parameter values.
  final UpdateStatus? updateStatus;

  SecurityControl({
    required this.description,
    required this.remediationUrl,
    required this.securityControlArn,
    required this.securityControlId,
    required this.securityControlStatus,
    required this.severityRating,
    required this.title,
    this.lastUpdateReason,
    this.parameters,
    this.updateStatus,
  });

  factory SecurityControl.fromJson(Map<String, dynamic> json) {
    return SecurityControl(
      description: json['Description'] as String,
      remediationUrl: json['RemediationUrl'] as String,
      securityControlArn: json['SecurityControlArn'] as String,
      securityControlId: json['SecurityControlId'] as String,
      securityControlStatus:
          (json['SecurityControlStatus'] as String).toControlStatus(),
      severityRating: (json['SeverityRating'] as String).toSeverityRating(),
      title: json['Title'] as String,
      lastUpdateReason: json['LastUpdateReason'] as String?,
      parameters: (json['Parameters'] as Map<String, dynamic>?)?.map((k, e) =>
          MapEntry(
              k, ParameterConfiguration.fromJson(e as Map<String, dynamic>))),
      updateStatus: (json['UpdateStatus'] as String?)?.toUpdateStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final remediationUrl = this.remediationUrl;
    final securityControlArn = this.securityControlArn;
    final securityControlId = this.securityControlId;
    final securityControlStatus = this.securityControlStatus;
    final severityRating = this.severityRating;
    final title = this.title;
    final lastUpdateReason = this.lastUpdateReason;
    final parameters = this.parameters;
    final updateStatus = this.updateStatus;
    return {
      'Description': description,
      'RemediationUrl': remediationUrl,
      'SecurityControlArn': securityControlArn,
      'SecurityControlId': securityControlId,
      'SecurityControlStatus': securityControlStatus.toValue(),
      'SeverityRating': severityRating.toValue(),
      'Title': title,
      if (lastUpdateReason != null) 'LastUpdateReason': lastUpdateReason,
      if (parameters != null) 'Parameters': parameters,
      if (updateStatus != null) 'UpdateStatus': updateStatus.toValue(),
    };
  }
}

/// A list of security controls and control parameter values that are included
/// in a configuration policy.
class SecurityControlCustomParameter {
  /// An object that specifies parameter values for a control in a configuration
  /// policy.
  final Map<String, ParameterConfiguration>? parameters;

  /// The ID of the security control.
  final String? securityControlId;

  SecurityControlCustomParameter({
    this.parameters,
    this.securityControlId,
  });

  factory SecurityControlCustomParameter.fromJson(Map<String, dynamic> json) {
    return SecurityControlCustomParameter(
      parameters: (json['Parameters'] as Map<String, dynamic>?)?.map((k, e) =>
          MapEntry(
              k, ParameterConfiguration.fromJson(e as Map<String, dynamic>))),
      securityControlId: json['SecurityControlId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final parameters = this.parameters;
    final securityControlId = this.securityControlId;
    return {
      if (parameters != null) 'Parameters': parameters,
      if (securityControlId != null) 'SecurityControlId': securityControlId,
    };
  }
}

/// Provides metadata for a security control, including its unique
/// standard-agnostic identifier, title, description, severity, availability in
/// Amazon Web Services Regions, and a link to remediation steps.
class SecurityControlDefinition {
  /// Specifies whether a security control is available in the current Amazon Web
  /// Services Region.
  final RegionAvailabilityStatus currentRegionAvailability;

  /// The description of a security control across standards. This typically
  /// summarizes how Security Hub evaluates the control and the conditions under
  /// which it produces a failed finding. This parameter doesn't reference a
  /// specific standard.
  final String description;

  /// A link to Security Hub documentation that explains how to remediate a failed
  /// finding for a security control.
  final String remediationUrl;

  /// The unique identifier of a security control across standards. Values for
  /// this field typically consist of an Amazon Web Service name and a number (for
  /// example, APIGateway.3). This parameter differs from
  /// <code>SecurityControlArn</code>, which is a unique Amazon Resource Name
  /// (ARN) assigned to a control. The ARN references the security control ID (for
  /// example,
  /// arn:aws:securityhub:eu-central-1:123456789012:security-control/APIGateway.3).
  final String securityControlId;

  /// The severity of a security control. For more information about how Security
  /// Hub determines control severity, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/controls-findings-create-update.html#control-findings-severity">Assigning
  /// severity to control findings</a> in the <i>Security Hub User Guide</i>.
  final SeverityRating severityRating;

  /// The title of a security control.
  final String title;

  /// Security control properties that you can customize. Currently, only
  /// parameter customization is supported for select controls. An empty array is
  /// returned for controls that don’t support custom properties.
  final List<SecurityControlProperty>? customizableProperties;

  /// An object that provides a security control parameter name, description, and
  /// the options for customizing it. This object is excluded for a control that
  /// doesn't support custom parameters.
  final Map<String, ParameterDefinition>? parameterDefinitions;

  SecurityControlDefinition({
    required this.currentRegionAvailability,
    required this.description,
    required this.remediationUrl,
    required this.securityControlId,
    required this.severityRating,
    required this.title,
    this.customizableProperties,
    this.parameterDefinitions,
  });

  factory SecurityControlDefinition.fromJson(Map<String, dynamic> json) {
    return SecurityControlDefinition(
      currentRegionAvailability: (json['CurrentRegionAvailability'] as String)
          .toRegionAvailabilityStatus(),
      description: json['Description'] as String,
      remediationUrl: json['RemediationUrl'] as String,
      securityControlId: json['SecurityControlId'] as String,
      severityRating: (json['SeverityRating'] as String).toSeverityRating(),
      title: json['Title'] as String,
      customizableProperties: (json['CustomizableProperties'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toSecurityControlProperty())
          .toList(),
      parameterDefinitions:
          (json['ParameterDefinitions'] as Map<String, dynamic>?)?.map((k, e) =>
              MapEntry(
                  k, ParameterDefinition.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final currentRegionAvailability = this.currentRegionAvailability;
    final description = this.description;
    final remediationUrl = this.remediationUrl;
    final securityControlId = this.securityControlId;
    final severityRating = this.severityRating;
    final title = this.title;
    final customizableProperties = this.customizableProperties;
    final parameterDefinitions = this.parameterDefinitions;
    return {
      'CurrentRegionAvailability': currentRegionAvailability.toValue(),
      'Description': description,
      'RemediationUrl': remediationUrl,
      'SecurityControlId': securityControlId,
      'SeverityRating': severityRating.toValue(),
      'Title': title,
      if (customizableProperties != null)
        'CustomizableProperties':
            customizableProperties.map((e) => e.toValue()).toList(),
      if (parameterDefinitions != null)
        'ParameterDefinitions': parameterDefinitions,
    };
  }
}

/// A parameter that a security control accepts.
class SecurityControlParameter {
  /// The name of a
  final String? name;

  /// The current value of a control parameter.
  final List<String>? value;

  SecurityControlParameter({
    this.name,
    this.value,
  });

  factory SecurityControlParameter.fromJson(Map<String, dynamic> json) {
    return SecurityControlParameter(
      name: json['Name'] as String?,
      value: (json['Value'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final value = this.value;
    return {
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

enum SecurityControlProperty {
  parameters,
}

extension SecurityControlPropertyValueExtension on SecurityControlProperty {
  String toValue() {
    switch (this) {
      case SecurityControlProperty.parameters:
        return 'Parameters';
    }
  }
}

extension SecurityControlPropertyFromString on String {
  SecurityControlProperty toSecurityControlProperty() {
    switch (this) {
      case 'Parameters':
        return SecurityControlProperty.parameters;
    }
    throw Exception('$this is not known in enum SecurityControlProperty');
  }
}

/// An object that defines which security controls are enabled in an Security
/// Hub configuration policy. The enablement status of a control is aligned
/// across all of the enabled standards in an account.
class SecurityControlsConfiguration {
  /// A list of security controls that are disabled in the configuration policy.
  /// Security Hub enables all other controls (including newly released controls)
  /// other than the listed controls.
  final List<String>? disabledSecurityControlIdentifiers;

  /// A list of security controls that are enabled in the configuration policy.
  /// Security Hub disables all other controls (including newly released controls)
  /// other than the listed controls.
  final List<String>? enabledSecurityControlIdentifiers;

  /// A list of security controls and control parameter values that are included
  /// in a configuration policy.
  final List<SecurityControlCustomParameter>? securityControlCustomParameters;

  SecurityControlsConfiguration({
    this.disabledSecurityControlIdentifiers,
    this.enabledSecurityControlIdentifiers,
    this.securityControlCustomParameters,
  });

  factory SecurityControlsConfiguration.fromJson(Map<String, dynamic> json) {
    return SecurityControlsConfiguration(
      disabledSecurityControlIdentifiers:
          (json['DisabledSecurityControlIdentifiers'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      enabledSecurityControlIdentifiers:
          (json['EnabledSecurityControlIdentifiers'] as List?)
              ?.whereNotNull()
              .map((e) => e as String)
              .toList(),
      securityControlCustomParameters:
          (json['SecurityControlCustomParameters'] as List?)
              ?.whereNotNull()
              .map((e) => SecurityControlCustomParameter.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final disabledSecurityControlIdentifiers =
        this.disabledSecurityControlIdentifiers;
    final enabledSecurityControlIdentifiers =
        this.enabledSecurityControlIdentifiers;
    final securityControlCustomParameters =
        this.securityControlCustomParameters;
    return {
      if (disabledSecurityControlIdentifiers != null)
        'DisabledSecurityControlIdentifiers':
            disabledSecurityControlIdentifiers,
      if (enabledSecurityControlIdentifiers != null)
        'EnabledSecurityControlIdentifiers': enabledSecurityControlIdentifiers,
      if (securityControlCustomParameters != null)
        'SecurityControlCustomParameters': securityControlCustomParameters,
    };
  }
}

/// An object that defines how Security Hub is configured. The configuration
/// policy includes whether Security Hub is enabled or disabled, a list of
/// enabled security standards, a list of enabled or disabled security controls,
/// and a list of custom parameter values for specified controls. If you provide
/// a list of security controls that are enabled in the configuration policy,
/// Security Hub disables all other controls (including newly released
/// controls). If you provide a list of security controls that are disabled in
/// the configuration policy, Security Hub enables all other controls (including
/// newly released controls).
class SecurityHubPolicy {
  /// A list that defines which security standards are enabled in the
  /// configuration policy.
  final List<String>? enabledStandardIdentifiers;

  /// An object that defines which security controls are enabled in the
  /// configuration policy. The enablement status of a control is aligned across
  /// all of the enabled standards in an account.
  final SecurityControlsConfiguration? securityControlsConfiguration;

  /// Indicates whether Security Hub is enabled in the policy.
  final bool? serviceEnabled;

  SecurityHubPolicy({
    this.enabledStandardIdentifiers,
    this.securityControlsConfiguration,
    this.serviceEnabled,
  });

  factory SecurityHubPolicy.fromJson(Map<String, dynamic> json) {
    return SecurityHubPolicy(
      enabledStandardIdentifiers: (json['EnabledStandardIdentifiers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      securityControlsConfiguration:
          json['SecurityControlsConfiguration'] != null
              ? SecurityControlsConfiguration.fromJson(
                  json['SecurityControlsConfiguration'] as Map<String, dynamic>)
              : null,
      serviceEnabled: json['ServiceEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enabledStandardIdentifiers = this.enabledStandardIdentifiers;
    final securityControlsConfiguration = this.securityControlsConfiguration;
    final serviceEnabled = this.serviceEnabled;
    return {
      if (enabledStandardIdentifiers != null)
        'EnabledStandardIdentifiers': enabledStandardIdentifiers,
      if (securityControlsConfiguration != null)
        'SecurityControlsConfiguration': securityControlsConfiguration,
      if (serviceEnabled != null) 'ServiceEnabled': serviceEnabled,
    };
  }
}

/// The list of detected instances of sensitive data.
class SensitiveDataDetections {
  /// The total number of occurrences of sensitive data that were detected.
  final int? count;

  /// Details about the sensitive data that was detected.
  final Occurrences? occurrences;

  /// The type of sensitive data that was detected. For example, the type might
  /// indicate that the data is an email address.
  final String? type;

  SensitiveDataDetections({
    this.count,
    this.occurrences,
    this.type,
  });

  factory SensitiveDataDetections.fromJson(Map<String, dynamic> json) {
    return SensitiveDataDetections(
      count: json['Count'] as int?,
      occurrences: json['Occurrences'] != null
          ? Occurrences.fromJson(json['Occurrences'] as Map<String, dynamic>)
          : null,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final count = this.count;
    final occurrences = this.occurrences;
    final type = this.type;
    return {
      if (count != null) 'Count': count,
      if (occurrences != null) 'Occurrences': occurrences,
      if (type != null) 'Type': type,
    };
  }
}

/// Contains a detected instance of sensitive data that are based on built-in
/// identifiers.
class SensitiveDataResult {
  /// The category of sensitive data that was detected. For example, the category
  /// can indicate that the sensitive data involved credentials, financial
  /// information, or personal information.
  final String? category;

  /// The list of detected instances of sensitive data.
  final List<SensitiveDataDetections>? detections;

  /// The total number of occurrences of sensitive data.
  final int? totalCount;

  SensitiveDataResult({
    this.category,
    this.detections,
    this.totalCount,
  });

  factory SensitiveDataResult.fromJson(Map<String, dynamic> json) {
    return SensitiveDataResult(
      category: json['Category'] as String?,
      detections: (json['Detections'] as List?)
          ?.whereNotNull()
          .map((e) =>
              SensitiveDataDetections.fromJson(e as Map<String, dynamic>))
          .toList(),
      totalCount: json['TotalCount'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final detections = this.detections;
    final totalCount = this.totalCount;
    return {
      if (category != null) 'Category': category,
      if (detections != null) 'Detections': detections,
      if (totalCount != null) 'TotalCount': totalCount,
    };
  }
}

/// The severity of the finding.
///
/// The finding provider can provide the initial severity. The finding provider
/// can only update the severity if it hasn't been updated using
/// <code>BatchUpdateFindings</code>.
///
/// The finding must have either <code>Label</code> or <code>Normalized</code>
/// populated. If only one of these attributes is populated, then Security Hub
/// automatically populates the other one. If neither attribute is populated,
/// then the finding is invalid. <code>Label</code> is the preferred attribute.
class Severity {
  /// The severity value of the finding. The allowed values are the following.
  ///
  /// <ul>
  /// <li>
  /// <code>INFORMATIONAL</code> - No issue was found.
  /// </li>
  /// <li>
  /// <code>LOW</code> - The issue does not require action on its own.
  /// </li>
  /// <li>
  /// <code>MEDIUM</code> - The issue must be addressed but not urgently.
  /// </li>
  /// <li>
  /// <code>HIGH</code> - The issue must be addressed as a priority.
  /// </li>
  /// <li>
  /// <code>CRITICAL</code> - The issue must be remediated immediately to avoid it
  /// escalating.
  /// </li>
  /// </ul>
  /// If you provide <code>Normalized</code> and do not provide
  /// <code>Label</code>, then <code>Label</code> is set automatically as follows.
  ///
  /// <ul>
  /// <li>
  /// 0 - <code>INFORMATIONAL</code>
  /// </li>
  /// <li>
  /// 1–39 - <code>LOW</code>
  /// </li>
  /// <li>
  /// 40–69 - <code>MEDIUM</code>
  /// </li>
  /// <li>
  /// 70–89 - <code>HIGH</code>
  /// </li>
  /// <li>
  /// 90–100 - <code>CRITICAL</code>
  /// </li>
  /// </ul>
  final SeverityLabel? label;

  /// Deprecated. The normalized severity of a finding. Instead of providing
  /// <code>Normalized</code>, provide <code>Label</code>.
  ///
  /// The value of <code>Normalized</code> can be an integer between
  /// <code>0</code> and <code>100</code>.
  ///
  /// If you provide <code>Label</code> and do not provide
  /// <code>Normalized</code>, then <code>Normalized</code> is set automatically
  /// as follows.
  ///
  /// <ul>
  /// <li>
  /// <code>INFORMATIONAL</code> - 0
  /// </li>
  /// <li>
  /// <code>LOW</code> - 1
  /// </li>
  /// <li>
  /// <code>MEDIUM</code> - 40
  /// </li>
  /// <li>
  /// <code>HIGH</code> - 70
  /// </li>
  /// <li>
  /// <code>CRITICAL</code> - 90
  /// </li>
  /// </ul>
  final int? normalized;

  /// The native severity from the finding product that generated the finding.
  ///
  /// Length Constraints: Minimum length of 1. Maximum length of 64.
  final String? original;

  /// Deprecated. This attribute isn't included in findings. Instead of providing
  /// <code>Product</code>, provide <code>Original</code>.
  ///
  /// The native severity as defined by the Amazon Web Services service or
  /// integrated partner product that generated the finding.
  final double? product;

  Severity({
    this.label,
    this.normalized,
    this.original,
    this.product,
  });

  factory Severity.fromJson(Map<String, dynamic> json) {
    return Severity(
      label: (json['Label'] as String?)?.toSeverityLabel(),
      normalized: json['Normalized'] as int?,
      original: json['Original'] as String?,
      product: json['Product'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final label = this.label;
    final normalized = this.normalized;
    final original = this.original;
    final product = this.product;
    return {
      if (label != null) 'Label': label.toValue(),
      if (normalized != null) 'Normalized': normalized,
      if (original != null) 'Original': original,
      if (product != null) 'Product': product,
    };
  }
}

enum SeverityLabel {
  informational,
  low,
  medium,
  high,
  critical,
}

extension SeverityLabelValueExtension on SeverityLabel {
  String toValue() {
    switch (this) {
      case SeverityLabel.informational:
        return 'INFORMATIONAL';
      case SeverityLabel.low:
        return 'LOW';
      case SeverityLabel.medium:
        return 'MEDIUM';
      case SeverityLabel.high:
        return 'HIGH';
      case SeverityLabel.critical:
        return 'CRITICAL';
    }
  }
}

extension SeverityLabelFromString on String {
  SeverityLabel toSeverityLabel() {
    switch (this) {
      case 'INFORMATIONAL':
        return SeverityLabel.informational;
      case 'LOW':
        return SeverityLabel.low;
      case 'MEDIUM':
        return SeverityLabel.medium;
      case 'HIGH':
        return SeverityLabel.high;
      case 'CRITICAL':
        return SeverityLabel.critical;
    }
    throw Exception('$this is not known in enum SeverityLabel');
  }
}

enum SeverityRating {
  low,
  medium,
  high,
  critical,
}

extension SeverityRatingValueExtension on SeverityRating {
  String toValue() {
    switch (this) {
      case SeverityRating.low:
        return 'LOW';
      case SeverityRating.medium:
        return 'MEDIUM';
      case SeverityRating.high:
        return 'HIGH';
      case SeverityRating.critical:
        return 'CRITICAL';
    }
  }
}

extension SeverityRatingFromString on String {
  SeverityRating toSeverityRating() {
    switch (this) {
      case 'LOW':
        return SeverityRating.low;
      case 'MEDIUM':
        return SeverityRating.medium;
      case 'HIGH':
        return SeverityRating.high;
      case 'CRITICAL':
        return SeverityRating.critical;
    }
    throw Exception('$this is not known in enum SeverityRating');
  }
}

/// Updates to the severity information for a finding.
class SeverityUpdate {
  /// The severity value of the finding. The allowed values are the following.
  ///
  /// <ul>
  /// <li>
  /// <code>INFORMATIONAL</code> - No issue was found.
  /// </li>
  /// <li>
  /// <code>LOW</code> - The issue does not require action on its own.
  /// </li>
  /// <li>
  /// <code>MEDIUM</code> - The issue must be addressed but not urgently.
  /// </li>
  /// <li>
  /// <code>HIGH</code> - The issue must be addressed as a priority.
  /// </li>
  /// <li>
  /// <code>CRITICAL</code> - The issue must be remediated immediately to avoid it
  /// escalating.
  /// </li>
  /// </ul>
  final SeverityLabel? label;

  /// The normalized severity for the finding. This attribute is to be deprecated
  /// in favor of <code>Label</code>.
  ///
  /// If you provide <code>Normalized</code> and do not provide
  /// <code>Label</code>, <code>Label</code> is set automatically as follows.
  ///
  /// <ul>
  /// <li>
  /// 0 - <code>INFORMATIONAL</code>
  /// </li>
  /// <li>
  /// 1–39 - <code>LOW</code>
  /// </li>
  /// <li>
  /// 40–69 - <code>MEDIUM</code>
  /// </li>
  /// <li>
  /// 70–89 - <code>HIGH</code>
  /// </li>
  /// <li>
  /// 90–100 - <code>CRITICAL</code>
  /// </li>
  /// </ul>
  final int? normalized;

  /// The native severity as defined by the Amazon Web Services service or
  /// integrated partner product that generated the finding.
  final double? product;

  SeverityUpdate({
    this.label,
    this.normalized,
    this.product,
  });

  factory SeverityUpdate.fromJson(Map<String, dynamic> json) {
    return SeverityUpdate(
      label: (json['Label'] as String?)?.toSeverityLabel(),
      normalized: json['Normalized'] as int?,
      product: json['Product'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final label = this.label;
    final normalized = this.normalized;
    final product = this.product;
    return {
      if (label != null) 'Label': label.toValue(),
      if (normalized != null) 'Normalized': normalized,
      if (product != null) 'Product': product,
    };
  }
}

/// Information about a software package.
class SoftwarePackage {
  /// The architecture used for the software package.
  final String? architecture;

  /// The epoch of the software package.
  final String? epoch;

  /// The file system path to the package manager inventory file.
  final String? filePath;

  /// The version of the software package in which the vulnerability has been
  /// resolved.
  final String? fixedInVersion;

  /// The name of the software package.
  final String? name;

  /// The source of the package.
  final String? packageManager;

  /// The release of the software package.
  final String? release;

  /// Describes the actions a customer can take to resolve the vulnerability in
  /// the software package.
  final String? remediation;

  /// The Amazon Resource Name (ARN) of the source layer.
  final String? sourceLayerArn;

  /// The source layer hash of the vulnerable package.
  final String? sourceLayerHash;

  /// The version of the software package.
  final String? version;

  SoftwarePackage({
    this.architecture,
    this.epoch,
    this.filePath,
    this.fixedInVersion,
    this.name,
    this.packageManager,
    this.release,
    this.remediation,
    this.sourceLayerArn,
    this.sourceLayerHash,
    this.version,
  });

  factory SoftwarePackage.fromJson(Map<String, dynamic> json) {
    return SoftwarePackage(
      architecture: json['Architecture'] as String?,
      epoch: json['Epoch'] as String?,
      filePath: json['FilePath'] as String?,
      fixedInVersion: json['FixedInVersion'] as String?,
      name: json['Name'] as String?,
      packageManager: json['PackageManager'] as String?,
      release: json['Release'] as String?,
      remediation: json['Remediation'] as String?,
      sourceLayerArn: json['SourceLayerArn'] as String?,
      sourceLayerHash: json['SourceLayerHash'] as String?,
      version: json['Version'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final architecture = this.architecture;
    final epoch = this.epoch;
    final filePath = this.filePath;
    final fixedInVersion = this.fixedInVersion;
    final name = this.name;
    final packageManager = this.packageManager;
    final release = this.release;
    final remediation = this.remediation;
    final sourceLayerArn = this.sourceLayerArn;
    final sourceLayerHash = this.sourceLayerHash;
    final version = this.version;
    return {
      if (architecture != null) 'Architecture': architecture,
      if (epoch != null) 'Epoch': epoch,
      if (filePath != null) 'FilePath': filePath,
      if (fixedInVersion != null) 'FixedInVersion': fixedInVersion,
      if (name != null) 'Name': name,
      if (packageManager != null) 'PackageManager': packageManager,
      if (release != null) 'Release': release,
      if (remediation != null) 'Remediation': remediation,
      if (sourceLayerArn != null) 'SourceLayerArn': sourceLayerArn,
      if (sourceLayerHash != null) 'SourceLayerHash': sourceLayerHash,
      if (version != null) 'Version': version,
    };
  }
}

/// A collection of finding attributes used to sort findings.
class SortCriterion {
  /// The finding attribute used to sort findings.
  final String? field;

  /// The order used to sort findings.
  final SortOrder? sortOrder;

  SortCriterion({
    this.field,
    this.sortOrder,
  });

  Map<String, dynamic> toJson() {
    final field = this.field;
    final sortOrder = this.sortOrder;
    return {
      if (field != null) 'Field': field,
      if (sortOrder != null) 'SortOrder': sortOrder.toValue(),
    };
  }
}

enum SortOrder {
  asc,
  desc,
}

extension SortOrderValueExtension on SortOrder {
  String toValue() {
    switch (this) {
      case SortOrder.asc:
        return 'asc';
      case SortOrder.desc:
        return 'desc';
    }
  }
}

extension SortOrderFromString on String {
  SortOrder toSortOrder() {
    switch (this) {
      case 'asc':
        return SortOrder.asc;
      case 'desc':
        return SortOrder.desc;
    }
    throw Exception('$this is not known in enum SortOrder');
  }
}

/// Provides information about a specific security standard.
class Standard {
  /// A description of the standard.
  final String? description;

  /// Whether the standard is enabled by default. When Security Hub is enabled
  /// from the console, if a standard is enabled by default, the check box for
  /// that standard is selected by default.
  ///
  /// When Security Hub is enabled using the <code>EnableSecurityHub</code> API
  /// operation, the standard is enabled by default unless
  /// <code>EnableDefaultStandards</code> is set to <code>false</code>.
  final bool? enabledByDefault;

  /// The name of the standard.
  final String? name;

  /// The ARN of a standard.
  final String? standardsArn;

  /// Provides details about the management of a standard.
  final StandardsManagedBy? standardsManagedBy;

  Standard({
    this.description,
    this.enabledByDefault,
    this.name,
    this.standardsArn,
    this.standardsManagedBy,
  });

  factory Standard.fromJson(Map<String, dynamic> json) {
    return Standard(
      description: json['Description'] as String?,
      enabledByDefault: json['EnabledByDefault'] as bool?,
      name: json['Name'] as String?,
      standardsArn: json['StandardsArn'] as String?,
      standardsManagedBy: json['StandardsManagedBy'] != null
          ? StandardsManagedBy.fromJson(
              json['StandardsManagedBy'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final enabledByDefault = this.enabledByDefault;
    final name = this.name;
    final standardsArn = this.standardsArn;
    final standardsManagedBy = this.standardsManagedBy;
    return {
      if (description != null) 'Description': description,
      if (enabledByDefault != null) 'EnabledByDefault': enabledByDefault,
      if (name != null) 'Name': name,
      if (standardsArn != null) 'StandardsArn': standardsArn,
      if (standardsManagedBy != null) 'StandardsManagedBy': standardsManagedBy,
    };
  }
}

/// Details for an individual security standard control.
class StandardsControl {
  /// The identifier of the security standard control.
  final String? controlId;

  /// The current status of the security standard control. Indicates whether the
  /// control is enabled or disabled. Security Hub does not check against disabled
  /// controls.
  final ControlStatus? controlStatus;

  /// The date and time that the status of the security standard control was most
  /// recently updated.
  final DateTime? controlStatusUpdatedAt;

  /// The longer description of the security standard control. Provides
  /// information about what the control is checking for.
  final String? description;

  /// The reason provided for the most recent change in status for the control.
  final String? disabledReason;

  /// The list of requirements that are related to this control.
  final List<String>? relatedRequirements;

  /// A link to remediation information for the control in the Security Hub user
  /// documentation.
  final String? remediationUrl;

  /// The severity of findings generated from this security standard control.
  ///
  /// The finding severity is based on an assessment of how easy it would be to
  /// compromise Amazon Web Services resources if the issue is detected.
  final SeverityRating? severityRating;

  /// The ARN of the security standard control.
  final String? standardsControlArn;

  /// The title of the security standard control.
  final String? title;

  StandardsControl({
    this.controlId,
    this.controlStatus,
    this.controlStatusUpdatedAt,
    this.description,
    this.disabledReason,
    this.relatedRequirements,
    this.remediationUrl,
    this.severityRating,
    this.standardsControlArn,
    this.title,
  });

  factory StandardsControl.fromJson(Map<String, dynamic> json) {
    return StandardsControl(
      controlId: json['ControlId'] as String?,
      controlStatus: (json['ControlStatus'] as String?)?.toControlStatus(),
      controlStatusUpdatedAt: timeStampFromJson(json['ControlStatusUpdatedAt']),
      description: json['Description'] as String?,
      disabledReason: json['DisabledReason'] as String?,
      relatedRequirements: (json['RelatedRequirements'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      remediationUrl: json['RemediationUrl'] as String?,
      severityRating: (json['SeverityRating'] as String?)?.toSeverityRating(),
      standardsControlArn: json['StandardsControlArn'] as String?,
      title: json['Title'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final controlId = this.controlId;
    final controlStatus = this.controlStatus;
    final controlStatusUpdatedAt = this.controlStatusUpdatedAt;
    final description = this.description;
    final disabledReason = this.disabledReason;
    final relatedRequirements = this.relatedRequirements;
    final remediationUrl = this.remediationUrl;
    final severityRating = this.severityRating;
    final standardsControlArn = this.standardsControlArn;
    final title = this.title;
    return {
      if (controlId != null) 'ControlId': controlId,
      if (controlStatus != null) 'ControlStatus': controlStatus.toValue(),
      if (controlStatusUpdatedAt != null)
        'ControlStatusUpdatedAt': iso8601ToJson(controlStatusUpdatedAt),
      if (description != null) 'Description': description,
      if (disabledReason != null) 'DisabledReason': disabledReason,
      if (relatedRequirements != null)
        'RelatedRequirements': relatedRequirements,
      if (remediationUrl != null) 'RemediationUrl': remediationUrl,
      if (severityRating != null) 'SeverityRating': severityRating.toValue(),
      if (standardsControlArn != null)
        'StandardsControlArn': standardsControlArn,
      if (title != null) 'Title': title,
    };
  }
}

/// Provides details about a control's enablement status in a specified
/// standard.
class StandardsControlAssociationDetail {
  /// Specifies whether a control is enabled or disabled in a specified standard.
  final AssociationStatus associationStatus;

  /// The ARN of a security control across standards, such as
  /// <code>arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1</code>.
  /// This parameter doesn't mention a specific standard.
  final String securityControlArn;

  /// The unique identifier of a security control across standards. Values for
  /// this field typically consist of an Amazon Web Service name and a number,
  /// such as APIGateway.3.
  final String securityControlId;

  /// The Amazon Resource Name (ARN) of a security standard.
  final String standardsArn;

  /// The requirement that underlies a control in the compliance framework related
  /// to the standard.
  final List<String>? relatedRequirements;

  /// Provides the input parameter that Security Hub uses to call the <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_UpdateStandardsControl.html">UpdateStandardsControl</a>
  /// API. This API can be used to enable or disable a control in a specified
  /// standard.
  final List<String>? standardsControlArns;

  /// The description of a control. This typically summarizes how Security Hub
  /// evaluates the control and the conditions under which it produces a failed
  /// finding. This parameter may reference a specific standard.
  final String? standardsControlDescription;

  /// The title of a control. This field may reference a specific standard.
  final String? standardsControlTitle;

  /// The time at which the enablement status of the control in the specified
  /// standard was last updated.
  final DateTime? updatedAt;

  /// The reason for updating the enablement status of a control in a specified
  /// standard.
  final String? updatedReason;

  StandardsControlAssociationDetail({
    required this.associationStatus,
    required this.securityControlArn,
    required this.securityControlId,
    required this.standardsArn,
    this.relatedRequirements,
    this.standardsControlArns,
    this.standardsControlDescription,
    this.standardsControlTitle,
    this.updatedAt,
    this.updatedReason,
  });

  factory StandardsControlAssociationDetail.fromJson(
      Map<String, dynamic> json) {
    return StandardsControlAssociationDetail(
      associationStatus:
          (json['AssociationStatus'] as String).toAssociationStatus(),
      securityControlArn: json['SecurityControlArn'] as String,
      securityControlId: json['SecurityControlId'] as String,
      standardsArn: json['StandardsArn'] as String,
      relatedRequirements: (json['RelatedRequirements'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      standardsControlArns: (json['StandardsControlArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      standardsControlDescription:
          json['StandardsControlDescription'] as String?,
      standardsControlTitle: json['StandardsControlTitle'] as String?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
      updatedReason: json['UpdatedReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final securityControlArn = this.securityControlArn;
    final securityControlId = this.securityControlId;
    final standardsArn = this.standardsArn;
    final relatedRequirements = this.relatedRequirements;
    final standardsControlArns = this.standardsControlArns;
    final standardsControlDescription = this.standardsControlDescription;
    final standardsControlTitle = this.standardsControlTitle;
    final updatedAt = this.updatedAt;
    final updatedReason = this.updatedReason;
    return {
      'AssociationStatus': associationStatus.toValue(),
      'SecurityControlArn': securityControlArn,
      'SecurityControlId': securityControlId,
      'StandardsArn': standardsArn,
      if (relatedRequirements != null)
        'RelatedRequirements': relatedRequirements,
      if (standardsControlArns != null)
        'StandardsControlArns': standardsControlArns,
      if (standardsControlDescription != null)
        'StandardsControlDescription': standardsControlDescription,
      if (standardsControlTitle != null)
        'StandardsControlTitle': standardsControlTitle,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
      if (updatedReason != null) 'UpdatedReason': updatedReason,
    };
  }
}

/// An array with one or more objects that includes a security control
/// (identified with <code>SecurityControlId</code>,
/// <code>SecurityControlArn</code>, or a mix of both parameters) and the Amazon
/// Resource Name (ARN) of a standard. The security control ID or ARN is the
/// same across standards.
class StandardsControlAssociationId {
  /// The unique identifier (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) of a security
  /// control across standards.
  final String securityControlId;

  /// The ARN of a standard.
  final String standardsArn;

  StandardsControlAssociationId({
    required this.securityControlId,
    required this.standardsArn,
  });

  factory StandardsControlAssociationId.fromJson(Map<String, dynamic> json) {
    return StandardsControlAssociationId(
      securityControlId: json['SecurityControlId'] as String,
      standardsArn: json['StandardsArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final securityControlId = this.securityControlId;
    final standardsArn = this.standardsArn;
    return {
      'SecurityControlId': securityControlId,
      'StandardsArn': standardsArn,
    };
  }
}

/// An array that provides the enablement status and other details for each
/// control that applies to each enabled standard.
class StandardsControlAssociationSummary {
  /// The enablement status of a control in a specific standard.
  final AssociationStatus associationStatus;

  /// The ARN of a control, such as
  /// <code>arn:aws:securityhub:eu-central-1:123456789012:security-control/S3.1</code>.
  /// This parameter doesn't mention a specific standard.
  final String securityControlArn;

  /// A unique standard-agnostic identifier for a control. Values for this field
  /// typically consist of an Amazon Web Service and a number, such as
  /// APIGateway.5. This field doesn't reference a specific standard.
  final String securityControlId;

  /// The Amazon Resource Name (ARN) of a standard.
  final String standardsArn;

  /// The requirement that underlies this control in the compliance framework
  /// related to the standard.
  final List<String>? relatedRequirements;

  /// The description of a control. This typically summarizes how Security Hub
  /// evaluates the control and the conditions under which it produces a failed
  /// finding. The parameter may reference a specific standard.
  final String? standardsControlDescription;

  /// The title of a control.
  final String? standardsControlTitle;

  /// The last time that a control's enablement status in a specified standard was
  /// updated.
  final DateTime? updatedAt;

  /// The reason for updating a control's enablement status in a specified
  /// standard.
  final String? updatedReason;

  StandardsControlAssociationSummary({
    required this.associationStatus,
    required this.securityControlArn,
    required this.securityControlId,
    required this.standardsArn,
    this.relatedRequirements,
    this.standardsControlDescription,
    this.standardsControlTitle,
    this.updatedAt,
    this.updatedReason,
  });

  factory StandardsControlAssociationSummary.fromJson(
      Map<String, dynamic> json) {
    return StandardsControlAssociationSummary(
      associationStatus:
          (json['AssociationStatus'] as String).toAssociationStatus(),
      securityControlArn: json['SecurityControlArn'] as String,
      securityControlId: json['SecurityControlId'] as String,
      standardsArn: json['StandardsArn'] as String,
      relatedRequirements: (json['RelatedRequirements'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      standardsControlDescription:
          json['StandardsControlDescription'] as String?,
      standardsControlTitle: json['StandardsControlTitle'] as String?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
      updatedReason: json['UpdatedReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final securityControlArn = this.securityControlArn;
    final securityControlId = this.securityControlId;
    final standardsArn = this.standardsArn;
    final relatedRequirements = this.relatedRequirements;
    final standardsControlDescription = this.standardsControlDescription;
    final standardsControlTitle = this.standardsControlTitle;
    final updatedAt = this.updatedAt;
    final updatedReason = this.updatedReason;
    return {
      'AssociationStatus': associationStatus.toValue(),
      'SecurityControlArn': securityControlArn,
      'SecurityControlId': securityControlId,
      'StandardsArn': standardsArn,
      if (relatedRequirements != null)
        'RelatedRequirements': relatedRequirements,
      if (standardsControlDescription != null)
        'StandardsControlDescription': standardsControlDescription,
      if (standardsControlTitle != null)
        'StandardsControlTitle': standardsControlTitle,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
      if (updatedReason != null) 'UpdatedReason': updatedReason,
    };
  }
}

/// An array of requested updates to the enablement status of controls in
/// specified standards. The objects in the array include a security control ID,
/// the Amazon Resource Name (ARN) of the standard, the requested enablement
/// status, and the reason for updating the enablement status.
class StandardsControlAssociationUpdate {
  /// The desired enablement status of the control in the standard.
  final AssociationStatus associationStatus;

  /// The unique identifier for the security control whose enablement status you
  /// want to update.
  final String securityControlId;

  /// The Amazon Resource Name (ARN) of the standard in which you want to update
  /// the control's enablement status.
  final String standardsArn;

  /// The reason for updating the control's enablement status in the standard.
  final String? updatedReason;

  StandardsControlAssociationUpdate({
    required this.associationStatus,
    required this.securityControlId,
    required this.standardsArn,
    this.updatedReason,
  });

  factory StandardsControlAssociationUpdate.fromJson(
      Map<String, dynamic> json) {
    return StandardsControlAssociationUpdate(
      associationStatus:
          (json['AssociationStatus'] as String).toAssociationStatus(),
      securityControlId: json['SecurityControlId'] as String,
      standardsArn: json['StandardsArn'] as String,
      updatedReason: json['UpdatedReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final securityControlId = this.securityControlId;
    final standardsArn = this.standardsArn;
    final updatedReason = this.updatedReason;
    return {
      'AssociationStatus': associationStatus.toValue(),
      'SecurityControlId': securityControlId,
      'StandardsArn': standardsArn,
      if (updatedReason != null) 'UpdatedReason': updatedReason,
    };
  }
}

/// Provides details about the management of a security standard.
class StandardsManagedBy {
  /// An identifier for the company that manages a specific security standard. For
  /// existing standards, the value is equal to <code>Amazon Web Services</code>.
  final String? company;

  /// An identifier for the product that manages a specific security standard. For
  /// existing standards, the value is equal to the Amazon Web Services service
  /// that manages the standard.
  final String? product;

  StandardsManagedBy({
    this.company,
    this.product,
  });

  factory StandardsManagedBy.fromJson(Map<String, dynamic> json) {
    return StandardsManagedBy(
      company: json['Company'] as String?,
      product: json['Product'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final company = this.company;
    final product = this.product;
    return {
      if (company != null) 'Company': company,
      if (product != null) 'Product': product,
    };
  }
}

enum StandardsStatus {
  pending,
  ready,
  failed,
  deleting,
  incomplete,
}

extension StandardsStatusValueExtension on StandardsStatus {
  String toValue() {
    switch (this) {
      case StandardsStatus.pending:
        return 'PENDING';
      case StandardsStatus.ready:
        return 'READY';
      case StandardsStatus.failed:
        return 'FAILED';
      case StandardsStatus.deleting:
        return 'DELETING';
      case StandardsStatus.incomplete:
        return 'INCOMPLETE';
    }
  }
}

extension StandardsStatusFromString on String {
  StandardsStatus toStandardsStatus() {
    switch (this) {
      case 'PENDING':
        return StandardsStatus.pending;
      case 'READY':
        return StandardsStatus.ready;
      case 'FAILED':
        return StandardsStatus.failed;
      case 'DELETING':
        return StandardsStatus.deleting;
      case 'INCOMPLETE':
        return StandardsStatus.incomplete;
    }
    throw Exception('$this is not known in enum StandardsStatus');
  }
}

/// The reason for the current status of a standard subscription.
class StandardsStatusReason {
  /// The reason code that represents the reason for the current status of a
  /// standard subscription.
  final StatusReasonCode statusReasonCode;

  StandardsStatusReason({
    required this.statusReasonCode,
  });

  factory StandardsStatusReason.fromJson(Map<String, dynamic> json) {
    return StandardsStatusReason(
      statusReasonCode:
          (json['StatusReasonCode'] as String).toStatusReasonCode(),
    );
  }

  Map<String, dynamic> toJson() {
    final statusReasonCode = this.statusReasonCode;
    return {
      'StatusReasonCode': statusReasonCode.toValue(),
    };
  }
}

/// A resource that represents your subscription to a supported standard.
class StandardsSubscription {
  /// The ARN of a standard.
  final String standardsArn;

  /// A key-value pair of input for the standard.
  final Map<String, String> standardsInput;

  /// The status of the standard subscription.
  ///
  /// The status values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>PENDING</code> - Standard is in the process of being enabled.
  /// </li>
  /// <li>
  /// <code>READY</code> - Standard is enabled.
  /// </li>
  /// <li>
  /// <code>INCOMPLETE</code> - Standard could not be enabled completely. Some
  /// controls may not be available.
  /// </li>
  /// <li>
  /// <code>DELETING</code> - Standard is in the process of being disabled.
  /// </li>
  /// <li>
  /// <code>FAILED</code> - Standard could not be disabled.
  /// </li>
  /// </ul>
  final StandardsStatus standardsStatus;

  /// The ARN of a resource that represents your subscription to a supported
  /// standard.
  final String standardsSubscriptionArn;

  /// The reason for the current status.
  final StandardsStatusReason? standardsStatusReason;

  StandardsSubscription({
    required this.standardsArn,
    required this.standardsInput,
    required this.standardsStatus,
    required this.standardsSubscriptionArn,
    this.standardsStatusReason,
  });

  factory StandardsSubscription.fromJson(Map<String, dynamic> json) {
    return StandardsSubscription(
      standardsArn: json['StandardsArn'] as String,
      standardsInput: (json['StandardsInput'] as Map<String, dynamic>)
          .map((k, e) => MapEntry(k, e as String)),
      standardsStatus: (json['StandardsStatus'] as String).toStandardsStatus(),
      standardsSubscriptionArn: json['StandardsSubscriptionArn'] as String,
      standardsStatusReason: json['StandardsStatusReason'] != null
          ? StandardsStatusReason.fromJson(
              json['StandardsStatusReason'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final standardsArn = this.standardsArn;
    final standardsInput = this.standardsInput;
    final standardsStatus = this.standardsStatus;
    final standardsSubscriptionArn = this.standardsSubscriptionArn;
    final standardsStatusReason = this.standardsStatusReason;
    return {
      'StandardsArn': standardsArn,
      'StandardsInput': standardsInput,
      'StandardsStatus': standardsStatus.toValue(),
      'StandardsSubscriptionArn': standardsSubscriptionArn,
      if (standardsStatusReason != null)
        'StandardsStatusReason': standardsStatusReason,
    };
  }
}

/// The standard that you want to enable.
class StandardsSubscriptionRequest {
  /// The ARN of the standard that you want to enable. To view the list of
  /// available standards and their ARNs, use the <code>DescribeStandards</code>
  /// operation.
  final String standardsArn;

  /// A key-value pair of input for the standard.
  final Map<String, String>? standardsInput;

  StandardsSubscriptionRequest({
    required this.standardsArn,
    this.standardsInput,
  });

  Map<String, dynamic> toJson() {
    final standardsArn = this.standardsArn;
    final standardsInput = this.standardsInput;
    return {
      'StandardsArn': standardsArn,
      if (standardsInput != null) 'StandardsInput': standardsInput,
    };
  }
}

class StartConfigurationPolicyAssociationResponse {
  /// The current status of the association between the specified target and the
  /// configuration.
  final ConfigurationPolicyAssociationStatus? associationStatus;

  /// An explanation for a <code>FAILED</code> value for
  /// <code>AssociationStatus</code>.
  final String? associationStatusMessage;

  /// Indicates whether the association between the specified target and the
  /// configuration was directly applied by the Security Hub delegated
  /// administrator or inherited from a parent.
  final AssociationType? associationType;

  /// The UUID of the configuration policy.
  final String? configurationPolicyId;

  /// The identifier of the target account, organizational unit, or the
  /// organization root with which the configuration is associated.
  final String? targetId;

  /// Indicates whether the target is an Amazon Web Services account,
  /// organizational unit, or the organization root.
  final TargetType? targetType;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// association was last updated.
  final DateTime? updatedAt;

  StartConfigurationPolicyAssociationResponse({
    this.associationStatus,
    this.associationStatusMessage,
    this.associationType,
    this.configurationPolicyId,
    this.targetId,
    this.targetType,
    this.updatedAt,
  });

  factory StartConfigurationPolicyAssociationResponse.fromJson(
      Map<String, dynamic> json) {
    return StartConfigurationPolicyAssociationResponse(
      associationStatus: (json['AssociationStatus'] as String?)
          ?.toConfigurationPolicyAssociationStatus(),
      associationStatusMessage: json['AssociationStatusMessage'] as String?,
      associationType:
          (json['AssociationType'] as String?)?.toAssociationType(),
      configurationPolicyId: json['ConfigurationPolicyId'] as String?,
      targetId: json['TargetId'] as String?,
      targetType: (json['TargetType'] as String?)?.toTargetType(),
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final associationStatus = this.associationStatus;
    final associationStatusMessage = this.associationStatusMessage;
    final associationType = this.associationType;
    final configurationPolicyId = this.configurationPolicyId;
    final targetId = this.targetId;
    final targetType = this.targetType;
    final updatedAt = this.updatedAt;
    return {
      if (associationStatus != null)
        'AssociationStatus': associationStatus.toValue(),
      if (associationStatusMessage != null)
        'AssociationStatusMessage': associationStatusMessage,
      if (associationType != null) 'AssociationType': associationType.toValue(),
      if (configurationPolicyId != null)
        'ConfigurationPolicyId': configurationPolicyId,
      if (targetId != null) 'TargetId': targetId,
      if (targetType != null) 'TargetType': targetType.toValue(),
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

class StartConfigurationPolicyDisassociationResponse {
  StartConfigurationPolicyDisassociationResponse();

  factory StartConfigurationPolicyDisassociationResponse.fromJson(
      Map<String, dynamic> _) {
    return StartConfigurationPolicyDisassociationResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The definition of a custom action that can be used for stateless packet
/// handling.
class StatelessCustomActionDefinition {
  /// Information about metrics to publish to CloudWatch.
  final StatelessCustomPublishMetricAction? publishMetricAction;

  StatelessCustomActionDefinition({
    this.publishMetricAction,
  });

  factory StatelessCustomActionDefinition.fromJson(Map<String, dynamic> json) {
    return StatelessCustomActionDefinition(
      publishMetricAction: json['PublishMetricAction'] != null
          ? StatelessCustomPublishMetricAction.fromJson(
              json['PublishMetricAction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final publishMetricAction = this.publishMetricAction;
    return {
      if (publishMetricAction != null)
        'PublishMetricAction': publishMetricAction,
    };
  }
}

/// Information about metrics to publish to CloudWatch.
class StatelessCustomPublishMetricAction {
  /// Defines CloudWatch dimension values to publish.
  final List<StatelessCustomPublishMetricActionDimension>? dimensions;

  StatelessCustomPublishMetricAction({
    this.dimensions,
  });

  factory StatelessCustomPublishMetricAction.fromJson(
      Map<String, dynamic> json) {
    return StatelessCustomPublishMetricAction(
      dimensions: (json['Dimensions'] as List?)
          ?.whereNotNull()
          .map((e) => StatelessCustomPublishMetricActionDimension.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dimensions = this.dimensions;
    return {
      if (dimensions != null) 'Dimensions': dimensions,
    };
  }
}

/// Defines a CloudWatch dimension value to publish.
class StatelessCustomPublishMetricActionDimension {
  /// The value to use for the custom metric dimension.
  final String? value;

  StatelessCustomPublishMetricActionDimension({
    this.value,
  });

  factory StatelessCustomPublishMetricActionDimension.fromJson(
      Map<String, dynamic> json) {
    return StatelessCustomPublishMetricActionDimension(
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

/// Provides additional context for the value of <code>Compliance.Status</code>.
class StatusReason {
  /// A code that represents a reason for the control status. For the list of
  /// status reason codes and their meanings, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/securityhub-standards-results.html#securityhub-standards-results-asff">Standards-related
  /// information in the ASFF</a> in the <i>Security Hub User Guide</i>.
  final String reasonCode;

  /// The corresponding description for the status reason code.
  final String? description;

  StatusReason({
    required this.reasonCode,
    this.description,
  });

  factory StatusReason.fromJson(Map<String, dynamic> json) {
    return StatusReason(
      reasonCode: json['ReasonCode'] as String,
      description: json['Description'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final reasonCode = this.reasonCode;
    final description = this.description;
    return {
      'ReasonCode': reasonCode,
      if (description != null) 'Description': description,
    };
  }
}

enum StatusReasonCode {
  noAvailableConfigurationRecorder,
  internalError,
}

extension StatusReasonCodeValueExtension on StatusReasonCode {
  String toValue() {
    switch (this) {
      case StatusReasonCode.noAvailableConfigurationRecorder:
        return 'NO_AVAILABLE_CONFIGURATION_RECORDER';
      case StatusReasonCode.internalError:
        return 'INTERNAL_ERROR';
    }
  }
}

extension StatusReasonCodeFromString on String {
  StatusReasonCode toStatusReasonCode() {
    switch (this) {
      case 'NO_AVAILABLE_CONFIGURATION_RECORDER':
        return StatusReasonCode.noAvailableConfigurationRecorder;
      case 'INTERNAL_ERROR':
        return StatusReasonCode.internalError;
    }
    throw Exception('$this is not known in enum StatusReasonCode');
  }
}

/// The options for customizing a security control parameter that is a string.
class StringConfigurationOptions {
  /// The Security Hub default value for a control parameter that is a string.
  final String? defaultValue;

  /// The description of the RE2 regular expression.
  final String? expressionDescription;

  /// An RE2 regular expression that Security Hub uses to validate a user-provided
  /// control parameter string.
  final String? re2Expression;

  StringConfigurationOptions({
    this.defaultValue,
    this.expressionDescription,
    this.re2Expression,
  });

  factory StringConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return StringConfigurationOptions(
      defaultValue: json['DefaultValue'] as String?,
      expressionDescription: json['ExpressionDescription'] as String?,
      re2Expression: json['Re2Expression'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    final expressionDescription = this.expressionDescription;
    final re2Expression = this.re2Expression;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (expressionDescription != null)
        'ExpressionDescription': expressionDescription,
      if (re2Expression != null) 'Re2Expression': re2Expression,
    };
  }
}

/// A string filter for filtering Security Hub findings.
class StringFilter {
  /// The condition to apply to a string value when filtering Security Hub
  /// findings.
  ///
  /// To search for values that have the filter value, use one of the following
  /// comparison operators:
  ///
  /// <ul>
  /// <li>
  /// To search for values that include the filter value, use
  /// <code>CONTAINS</code>. For example, the filter <code>Title CONTAINS
  /// CloudFront</code> matches findings that have a <code>Title</code> that
  /// includes the string CloudFront.
  /// </li>
  /// <li>
  /// To search for values that exactly match the filter value, use
  /// <code>EQUALS</code>. For example, the filter <code>AwsAccountId EQUALS
  /// 123456789012</code> only matches findings that have an account ID of
  /// <code>123456789012</code>.
  /// </li>
  /// <li>
  /// To search for values that start with the filter value, use
  /// <code>PREFIX</code>. For example, the filter <code>ResourceRegion PREFIX
  /// us</code> matches findings that have a <code>ResourceRegion</code> that
  /// starts with <code>us</code>. A <code>ResourceRegion</code> that starts with
  /// a different value, such as <code>af</code>, <code>ap</code>, or
  /// <code>ca</code>, doesn't match.
  /// </li>
  /// </ul>
  /// <code>CONTAINS</code>, <code>EQUALS</code>, and <code>PREFIX</code> filters
  /// on the same field are joined by <code>OR</code>. A finding matches if it
  /// matches any one of those filters. For example, the filters <code>Title
  /// CONTAINS CloudFront OR Title CONTAINS CloudWatch</code> match a finding that
  /// includes either <code>CloudFront</code>, <code>CloudWatch</code>, or both
  /// strings in the title.
  ///
  /// To search for values that don’t have the filter value, use one of the
  /// following comparison operators:
  ///
  /// <ul>
  /// <li>
  /// To search for values that exclude the filter value, use
  /// <code>NOT_CONTAINS</code>. For example, the filter <code>Title NOT_CONTAINS
  /// CloudFront</code> matches findings that have a <code>Title</code> that
  /// excludes the string CloudFront.
  /// </li>
  /// <li>
  /// To search for values other than the filter value, use
  /// <code>NOT_EQUALS</code>. For example, the filter <code>AwsAccountId
  /// NOT_EQUALS 123456789012</code> only matches findings that have an account ID
  /// other than <code>123456789012</code>.
  /// </li>
  /// <li>
  /// To search for values that don't start with the filter value, use
  /// <code>PREFIX_NOT_EQUALS</code>. For example, the filter <code>ResourceRegion
  /// PREFIX_NOT_EQUALS us</code> matches findings with a
  /// <code>ResourceRegion</code> that starts with a value other than
  /// <code>us</code>.
  /// </li>
  /// </ul>
  /// <code>NOT_CONTAINS</code>, <code>NOT_EQUALS</code>, and
  /// <code>PREFIX_NOT_EQUALS</code> filters on the same field are joined by
  /// <code>AND</code>. A finding matches only if it matches all of those filters.
  /// For example, the filters <code>Title NOT_CONTAINS CloudFront AND Title
  /// NOT_CONTAINS CloudWatch</code> match a finding that excludes both
  /// <code>CloudFront</code> and <code>CloudWatch</code> in the title.
  ///
  /// You can’t have both a <code>CONTAINS</code> filter and a
  /// <code>NOT_CONTAINS</code> filter on the same field. Similarly, you can't
  /// provide both an <code>EQUALS</code> filter and a <code>NOT_EQUALS</code> or
  /// <code>PREFIX_NOT_EQUALS</code> filter on the same field. Combining filters
  /// in this way returns an error. <code>CONTAINS</code> filters can only be used
  /// with other <code>CONTAINS</code> filters. <code>NOT_CONTAINS</code> filters
  /// can only be used with other <code>NOT_CONTAINS</code> filters.
  ///
  /// You can combine <code>PREFIX</code> filters with <code>NOT_EQUALS</code> or
  /// <code>PREFIX_NOT_EQUALS</code> filters for the same field. Security Hub
  /// first processes the <code>PREFIX</code> filters, and then the
  /// <code>NOT_EQUALS</code> or <code>PREFIX_NOT_EQUALS</code> filters.
  ///
  /// For example, for the following filters, Security Hub first identifies
  /// findings that have resource types that start with either <code>AwsIam</code>
  /// or <code>AwsEc2</code>. It then excludes findings that have a resource type
  /// of <code>AwsIamPolicy</code> and findings that have a resource type of
  /// <code>AwsEc2NetworkInterface</code>.
  ///
  /// <ul>
  /// <li>
  /// <code>ResourceType PREFIX AwsIam</code>
  /// </li>
  /// <li>
  /// <code>ResourceType PREFIX AwsEc2</code>
  /// </li>
  /// <li>
  /// <code>ResourceType NOT_EQUALS AwsIamPolicy</code>
  /// </li>
  /// <li>
  /// <code>ResourceType NOT_EQUALS AwsEc2NetworkInterface</code>
  /// </li>
  /// </ul>
  /// <code>CONTAINS</code> and <code>NOT_CONTAINS</code> operators can be used
  /// only with automation rules. For more information, see <a
  /// href="https://docs.aws.amazon.com/securityhub/latest/userguide/automation-rules.html">Automation
  /// rules</a> in the <i>Security Hub User Guide</i>.
  final StringFilterComparison? comparison;

  /// The string filter value. Filter values are case sensitive. For example, the
  /// product name for control-based findings is <code>Security Hub</code>. If you
  /// provide <code>security hub</code> as the filter value, there's no match.
  final String? value;

  StringFilter({
    this.comparison,
    this.value,
  });

  factory StringFilter.fromJson(Map<String, dynamic> json) {
    return StringFilter(
      comparison: (json['Comparison'] as String?)?.toStringFilterComparison(),
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final comparison = this.comparison;
    final value = this.value;
    return {
      if (comparison != null) 'Comparison': comparison.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

enum StringFilterComparison {
  equals,
  prefix,
  notEquals,
  prefixNotEquals,
  contains,
  notContains,
}

extension StringFilterComparisonValueExtension on StringFilterComparison {
  String toValue() {
    switch (this) {
      case StringFilterComparison.equals:
        return 'EQUALS';
      case StringFilterComparison.prefix:
        return 'PREFIX';
      case StringFilterComparison.notEquals:
        return 'NOT_EQUALS';
      case StringFilterComparison.prefixNotEquals:
        return 'PREFIX_NOT_EQUALS';
      case StringFilterComparison.contains:
        return 'CONTAINS';
      case StringFilterComparison.notContains:
        return 'NOT_CONTAINS';
    }
  }
}

extension StringFilterComparisonFromString on String {
  StringFilterComparison toStringFilterComparison() {
    switch (this) {
      case 'EQUALS':
        return StringFilterComparison.equals;
      case 'PREFIX':
        return StringFilterComparison.prefix;
      case 'NOT_EQUALS':
        return StringFilterComparison.notEquals;
      case 'PREFIX_NOT_EQUALS':
        return StringFilterComparison.prefixNotEquals;
      case 'CONTAINS':
        return StringFilterComparison.contains;
      case 'NOT_CONTAINS':
        return StringFilterComparison.notContains;
    }
    throw Exception('$this is not known in enum StringFilterComparison');
  }
}

/// The options for customizing a security control parameter that is a list of
/// strings.
class StringListConfigurationOptions {
  /// The Security Hub default value for a control parameter that is a list of
  /// strings.
  final List<String>? defaultValue;

  /// The description of the RE2 regular expression.
  final String? expressionDescription;

  /// The maximum number of list items that a string list control parameter can
  /// accept.
  final int? maxItems;

  /// An RE2 regular expression that Security Hub uses to validate a user-provided
  /// list of strings for a control parameter.
  final String? re2Expression;

  StringListConfigurationOptions({
    this.defaultValue,
    this.expressionDescription,
    this.maxItems,
    this.re2Expression,
  });

  factory StringListConfigurationOptions.fromJson(Map<String, dynamic> json) {
    return StringListConfigurationOptions(
      defaultValue: (json['DefaultValue'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      expressionDescription: json['ExpressionDescription'] as String?,
      maxItems: json['MaxItems'] as int?,
      re2Expression: json['Re2Expression'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValue = this.defaultValue;
    final expressionDescription = this.expressionDescription;
    final maxItems = this.maxItems;
    final re2Expression = this.re2Expression;
    return {
      if (defaultValue != null) 'DefaultValue': defaultValue,
      if (expressionDescription != null)
        'ExpressionDescription': expressionDescription,
      if (maxItems != null) 'MaxItems': maxItems,
      if (re2Expression != null) 'Re2Expression': re2Expression,
    };
  }
}

class TagResourceResponse {
  TagResourceResponse();

  factory TagResourceResponse.fromJson(Map<String, dynamic> _) {
    return TagResourceResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The target account, organizational unit, or the root that is associated with
/// an Security Hub configuration. The configuration can be a configuration
/// policy or self-managed behavior.
class Target {
  /// The Amazon Web Services account ID of the target account.
  final String? accountId;

  /// The organizational unit ID of the target organizational unit.
  final String? organizationalUnitId;

  /// The ID of the organization root.
  final String? rootId;

  Target({
    this.accountId,
    this.organizationalUnitId,
    this.rootId,
  });

  factory Target.fromJson(Map<String, dynamic> json) {
    return Target(
      accountId: json['AccountId'] as String?,
      organizationalUnitId: json['OrganizationalUnitId'] as String?,
      rootId: json['RootId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountId = this.accountId;
    final organizationalUnitId = this.organizationalUnitId;
    final rootId = this.rootId;
    return {
      if (accountId != null) 'AccountId': accountId,
      if (organizationalUnitId != null)
        'OrganizationalUnitId': organizationalUnitId,
      if (rootId != null) 'RootId': rootId,
    };
  }
}

enum TargetType {
  account,
  organizationalUnit,
  root,
}

extension TargetTypeValueExtension on TargetType {
  String toValue() {
    switch (this) {
      case TargetType.account:
        return 'ACCOUNT';
      case TargetType.organizationalUnit:
        return 'ORGANIZATIONAL_UNIT';
      case TargetType.root:
        return 'ROOT';
    }
  }
}

extension TargetTypeFromString on String {
  TargetType toTargetType() {
    switch (this) {
      case 'ACCOUNT':
        return TargetType.account;
      case 'ORGANIZATIONAL_UNIT':
        return TargetType.organizationalUnit;
      case 'ROOT':
        return TargetType.root;
    }
    throw Exception('$this is not known in enum TargetType');
  }
}

/// Provides information about the threat detected in a security finding and the
/// file paths that were affected by the threat.
class Threat {
  /// Provides information about the file paths that were affected by the threat.
  ///
  /// Array Members: Minimum number of 1 item. Maximum number of 5 items.
  final List<FilePaths>? filePaths;

  /// This total number of items in which the threat has been detected.
  final int? itemCount;

  /// The name of the threat.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 128 length.
  final String? name;

  /// The severity of the threat.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 128 length.
  final String? severity;

  Threat({
    this.filePaths,
    this.itemCount,
    this.name,
    this.severity,
  });

  factory Threat.fromJson(Map<String, dynamic> json) {
    return Threat(
      filePaths: (json['FilePaths'] as List?)
          ?.whereNotNull()
          .map((e) => FilePaths.fromJson(e as Map<String, dynamic>))
          .toList(),
      itemCount: json['ItemCount'] as int?,
      name: json['Name'] as String?,
      severity: json['Severity'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final filePaths = this.filePaths;
    final itemCount = this.itemCount;
    final name = this.name;
    final severity = this.severity;
    return {
      if (filePaths != null) 'FilePaths': filePaths,
      if (itemCount != null) 'ItemCount': itemCount,
      if (name != null) 'Name': name,
      if (severity != null) 'Severity': severity,
    };
  }
}

/// Details about the threat intelligence related to a finding.
class ThreatIntelIndicator {
  /// The category of a threat intelligence indicator.
  final ThreatIntelIndicatorCategory? category;

  /// Indicates when the most recent instance of a threat intelligence indicator
  /// was observed.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? lastObservedAt;

  /// The source of the threat intelligence indicator.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 64 length.
  final String? source;

  /// The URL to the page or site where you can get more information about the
  /// threat intelligence indicator.
  final String? sourceUrl;

  /// The type of threat intelligence indicator.
  final ThreatIntelIndicatorType? type;

  /// The value of a threat intelligence indicator.
  ///
  /// Length Constraints: Minimum of 1 length. Maximum of 512 length.
  final String? value;

  ThreatIntelIndicator({
    this.category,
    this.lastObservedAt,
    this.source,
    this.sourceUrl,
    this.type,
    this.value,
  });

  factory ThreatIntelIndicator.fromJson(Map<String, dynamic> json) {
    return ThreatIntelIndicator(
      category: (json['Category'] as String?)?.toThreatIntelIndicatorCategory(),
      lastObservedAt: json['LastObservedAt'] as String?,
      source: json['Source'] as String?,
      sourceUrl: json['SourceUrl'] as String?,
      type: (json['Type'] as String?)?.toThreatIntelIndicatorType(),
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final lastObservedAt = this.lastObservedAt;
    final source = this.source;
    final sourceUrl = this.sourceUrl;
    final type = this.type;
    final value = this.value;
    return {
      if (category != null) 'Category': category.toValue(),
      if (lastObservedAt != null) 'LastObservedAt': lastObservedAt,
      if (source != null) 'Source': source,
      if (sourceUrl != null) 'SourceUrl': sourceUrl,
      if (type != null) 'Type': type.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

enum ThreatIntelIndicatorCategory {
  backdoor,
  cardStealer,
  commandAndControl,
  dropSite,
  exploitSite,
  keylogger,
}

extension ThreatIntelIndicatorCategoryValueExtension
    on ThreatIntelIndicatorCategory {
  String toValue() {
    switch (this) {
      case ThreatIntelIndicatorCategory.backdoor:
        return 'BACKDOOR';
      case ThreatIntelIndicatorCategory.cardStealer:
        return 'CARD_STEALER';
      case ThreatIntelIndicatorCategory.commandAndControl:
        return 'COMMAND_AND_CONTROL';
      case ThreatIntelIndicatorCategory.dropSite:
        return 'DROP_SITE';
      case ThreatIntelIndicatorCategory.exploitSite:
        return 'EXPLOIT_SITE';
      case ThreatIntelIndicatorCategory.keylogger:
        return 'KEYLOGGER';
    }
  }
}

extension ThreatIntelIndicatorCategoryFromString on String {
  ThreatIntelIndicatorCategory toThreatIntelIndicatorCategory() {
    switch (this) {
      case 'BACKDOOR':
        return ThreatIntelIndicatorCategory.backdoor;
      case 'CARD_STEALER':
        return ThreatIntelIndicatorCategory.cardStealer;
      case 'COMMAND_AND_CONTROL':
        return ThreatIntelIndicatorCategory.commandAndControl;
      case 'DROP_SITE':
        return ThreatIntelIndicatorCategory.dropSite;
      case 'EXPLOIT_SITE':
        return ThreatIntelIndicatorCategory.exploitSite;
      case 'KEYLOGGER':
        return ThreatIntelIndicatorCategory.keylogger;
    }
    throw Exception('$this is not known in enum ThreatIntelIndicatorCategory');
  }
}

enum ThreatIntelIndicatorType {
  domain,
  emailAddress,
  hashMd5,
  hashSha1,
  hashSha256,
  hashSha512,
  ipv4Address,
  ipv6Address,
  mutex,
  process,
  url,
}

extension ThreatIntelIndicatorTypeValueExtension on ThreatIntelIndicatorType {
  String toValue() {
    switch (this) {
      case ThreatIntelIndicatorType.domain:
        return 'DOMAIN';
      case ThreatIntelIndicatorType.emailAddress:
        return 'EMAIL_ADDRESS';
      case ThreatIntelIndicatorType.hashMd5:
        return 'HASH_MD5';
      case ThreatIntelIndicatorType.hashSha1:
        return 'HASH_SHA1';
      case ThreatIntelIndicatorType.hashSha256:
        return 'HASH_SHA256';
      case ThreatIntelIndicatorType.hashSha512:
        return 'HASH_SHA512';
      case ThreatIntelIndicatorType.ipv4Address:
        return 'IPV4_ADDRESS';
      case ThreatIntelIndicatorType.ipv6Address:
        return 'IPV6_ADDRESS';
      case ThreatIntelIndicatorType.mutex:
        return 'MUTEX';
      case ThreatIntelIndicatorType.process:
        return 'PROCESS';
      case ThreatIntelIndicatorType.url:
        return 'URL';
    }
  }
}

extension ThreatIntelIndicatorTypeFromString on String {
  ThreatIntelIndicatorType toThreatIntelIndicatorType() {
    switch (this) {
      case 'DOMAIN':
        return ThreatIntelIndicatorType.domain;
      case 'EMAIL_ADDRESS':
        return ThreatIntelIndicatorType.emailAddress;
      case 'HASH_MD5':
        return ThreatIntelIndicatorType.hashMd5;
      case 'HASH_SHA1':
        return ThreatIntelIndicatorType.hashSha1;
      case 'HASH_SHA256':
        return ThreatIntelIndicatorType.hashSha256;
      case 'HASH_SHA512':
        return ThreatIntelIndicatorType.hashSha512;
      case 'IPV4_ADDRESS':
        return ThreatIntelIndicatorType.ipv4Address;
      case 'IPV6_ADDRESS':
        return ThreatIntelIndicatorType.ipv6Address;
      case 'MUTEX':
        return ThreatIntelIndicatorType.mutex;
      case 'PROCESS':
        return ThreatIntelIndicatorType.process;
      case 'URL':
        return ThreatIntelIndicatorType.url;
    }
    throw Exception('$this is not known in enum ThreatIntelIndicatorType');
  }
}

/// A list of objects containing <code>RuleArn</code>, <code>ErrorCode</code>,
/// and <code>ErrorMessage</code>. This parameter tells you which automation
/// rules the request didn't process and why.
class UnprocessedAutomationRule {
  /// The error code associated with the unprocessed automation rule.
  final int? errorCode;

  /// An error message describing why a request didn't process a specific rule.
  final String? errorMessage;

  /// The Amazon Resource Name (ARN) for the unprocessed automation rule.
  final String? ruleArn;

  UnprocessedAutomationRule({
    this.errorCode,
    this.errorMessage,
    this.ruleArn,
  });

  factory UnprocessedAutomationRule.fromJson(Map<String, dynamic> json) {
    return UnprocessedAutomationRule(
      errorCode: json['ErrorCode'] as int?,
      errorMessage: json['ErrorMessage'] as String?,
      ruleArn: json['RuleArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final errorMessage = this.errorMessage;
    final ruleArn = this.ruleArn;
    return {
      if (errorCode != null) 'ErrorCode': errorCode,
      if (errorMessage != null) 'ErrorMessage': errorMessage,
      if (ruleArn != null) 'RuleArn': ruleArn,
    };
  }
}

/// An array of configuration policy associations, one for each configuration
/// policy association identifier, that was specified in a
/// <code>BatchGetConfigurationPolicyAssociations</code> request but couldn’t be
/// processed due to an error.
class UnprocessedConfigurationPolicyAssociation {
  /// Configuration policy association identifiers that were specified in a
  /// <code>BatchGetConfigurationPolicyAssociations</code> request but couldn’t be
  /// processed due to an error.
  final ConfigurationPolicyAssociation?
      configurationPolicyAssociationIdentifiers;

  /// An HTTP status code that identifies why the configuration policy association
  /// failed.
  final String? errorCode;

  /// A string that identifies why the configuration policy association failed.
  final String? errorReason;

  UnprocessedConfigurationPolicyAssociation({
    this.configurationPolicyAssociationIdentifiers,
    this.errorCode,
    this.errorReason,
  });

  factory UnprocessedConfigurationPolicyAssociation.fromJson(
      Map<String, dynamic> json) {
    return UnprocessedConfigurationPolicyAssociation(
      configurationPolicyAssociationIdentifiers:
          json['ConfigurationPolicyAssociationIdentifiers'] != null
              ? ConfigurationPolicyAssociation.fromJson(
                  json['ConfigurationPolicyAssociationIdentifiers']
                      as Map<String, dynamic>)
              : null,
      errorCode: json['ErrorCode'] as String?,
      errorReason: json['ErrorReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final configurationPolicyAssociationIdentifiers =
        this.configurationPolicyAssociationIdentifiers;
    final errorCode = this.errorCode;
    final errorReason = this.errorReason;
    return {
      if (configurationPolicyAssociationIdentifiers != null)
        'ConfigurationPolicyAssociationIdentifiers':
            configurationPolicyAssociationIdentifiers,
      if (errorCode != null) 'ErrorCode': errorCode,
      if (errorReason != null) 'ErrorReason': errorReason,
    };
  }
}

enum UnprocessedErrorCode {
  invalidInput,
  accessDenied,
  notFound,
  limitExceeded,
}

extension UnprocessedErrorCodeValueExtension on UnprocessedErrorCode {
  String toValue() {
    switch (this) {
      case UnprocessedErrorCode.invalidInput:
        return 'INVALID_INPUT';
      case UnprocessedErrorCode.accessDenied:
        return 'ACCESS_DENIED';
      case UnprocessedErrorCode.notFound:
        return 'NOT_FOUND';
      case UnprocessedErrorCode.limitExceeded:
        return 'LIMIT_EXCEEDED';
    }
  }
}

extension UnprocessedErrorCodeFromString on String {
  UnprocessedErrorCode toUnprocessedErrorCode() {
    switch (this) {
      case 'INVALID_INPUT':
        return UnprocessedErrorCode.invalidInput;
      case 'ACCESS_DENIED':
        return UnprocessedErrorCode.accessDenied;
      case 'NOT_FOUND':
        return UnprocessedErrorCode.notFound;
      case 'LIMIT_EXCEEDED':
        return UnprocessedErrorCode.limitExceeded;
    }
    throw Exception('$this is not known in enum UnprocessedErrorCode');
  }
}

/// Provides details about a security control for which a response couldn't be
/// returned.
class UnprocessedSecurityControl {
  /// The error code for the unprocessed security control.
  final UnprocessedErrorCode errorCode;

  /// The control (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) for which a
  /// response couldn't be returned.
  final String securityControlId;

  /// The reason why the security control was unprocessed.
  final String? errorReason;

  UnprocessedSecurityControl({
    required this.errorCode,
    required this.securityControlId,
    this.errorReason,
  });

  factory UnprocessedSecurityControl.fromJson(Map<String, dynamic> json) {
    return UnprocessedSecurityControl(
      errorCode: (json['ErrorCode'] as String).toUnprocessedErrorCode(),
      securityControlId: json['SecurityControlId'] as String,
      errorReason: json['ErrorReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final securityControlId = this.securityControlId;
    final errorReason = this.errorReason;
    return {
      'ErrorCode': errorCode.toValue(),
      'SecurityControlId': securityControlId,
      if (errorReason != null) 'ErrorReason': errorReason,
    };
  }
}

/// Provides details about which control's enablement status couldn't be
/// retrieved in a specified standard when calling <a
/// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html">BatchUpdateStandardsControlAssociations</a>.
/// This parameter also provides details about why the request was unprocessed.
class UnprocessedStandardsControlAssociation {
  /// The error code for the unprocessed standard and control association.
  final UnprocessedErrorCode errorCode;

  /// An array with one or more objects that includes a security control
  /// (identified with <code>SecurityControlId</code>,
  /// <code>SecurityControlArn</code>, or a mix of both parameters) and the Amazon
  /// Resource Name (ARN) of a standard. This parameter shows the specific
  /// controls for which the enablement status couldn't be retrieved in specified
  /// standards when calling <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html">BatchUpdateStandardsControlAssociations</a>.
  final StandardsControlAssociationId standardsControlAssociationId;

  /// The reason why the standard and control association was unprocessed.
  final String? errorReason;

  UnprocessedStandardsControlAssociation({
    required this.errorCode,
    required this.standardsControlAssociationId,
    this.errorReason,
  });

  factory UnprocessedStandardsControlAssociation.fromJson(
      Map<String, dynamic> json) {
    return UnprocessedStandardsControlAssociation(
      errorCode: (json['ErrorCode'] as String).toUnprocessedErrorCode(),
      standardsControlAssociationId: StandardsControlAssociationId.fromJson(
          json['StandardsControlAssociationId'] as Map<String, dynamic>),
      errorReason: json['ErrorReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final standardsControlAssociationId = this.standardsControlAssociationId;
    final errorReason = this.errorReason;
    return {
      'ErrorCode': errorCode.toValue(),
      'StandardsControlAssociationId': standardsControlAssociationId,
      if (errorReason != null) 'ErrorReason': errorReason,
    };
  }
}

/// Provides details about which control's enablement status could not be
/// updated in a specified standard when calling the <a
/// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html">BatchUpdateStandardsControlAssociations</a>
/// API. This parameter also provides details about why the request was
/// unprocessed.
class UnprocessedStandardsControlAssociationUpdate {
  /// The error code for the unprocessed update of the control's enablement status
  /// in the specified standard.
  final UnprocessedErrorCode errorCode;

  /// An array of control and standard associations for which an update failed
  /// when calling <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateStandardsControlAssociations.html">BatchUpdateStandardsControlAssociations</a>.
  final StandardsControlAssociationUpdate standardsControlAssociationUpdate;

  /// The reason why a control's enablement status in the specified standard
  /// couldn't be updated.
  final String? errorReason;

  UnprocessedStandardsControlAssociationUpdate({
    required this.errorCode,
    required this.standardsControlAssociationUpdate,
    this.errorReason,
  });

  factory UnprocessedStandardsControlAssociationUpdate.fromJson(
      Map<String, dynamic> json) {
    return UnprocessedStandardsControlAssociationUpdate(
      errorCode: (json['ErrorCode'] as String).toUnprocessedErrorCode(),
      standardsControlAssociationUpdate:
          StandardsControlAssociationUpdate.fromJson(
              json['StandardsControlAssociationUpdate']
                  as Map<String, dynamic>),
      errorReason: json['ErrorReason'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorCode = this.errorCode;
    final standardsControlAssociationUpdate =
        this.standardsControlAssociationUpdate;
    final errorReason = this.errorReason;
    return {
      'ErrorCode': errorCode.toValue(),
      'StandardsControlAssociationUpdate': standardsControlAssociationUpdate,
      if (errorReason != null) 'ErrorReason': errorReason,
    };
  }
}

class UntagResourceResponse {
  UntagResourceResponse();

  factory UntagResourceResponse.fromJson(Map<String, dynamic> _) {
    return UntagResourceResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateActionTargetResponse {
  UpdateActionTargetResponse();

  factory UpdateActionTargetResponse.fromJson(Map<String, dynamic> _) {
    return UpdateActionTargetResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Specifies the parameters to update in an existing automation rule.
class UpdateAutomationRulesRequestItem {
  /// The Amazon Resource Name (ARN) for the rule.
  final String ruleArn;

  /// One or more actions to update finding fields if a finding matches the
  /// conditions specified in <code>Criteria</code>.
  final List<AutomationRulesAction>? actions;

  /// A set of ASFF finding field attributes and corresponding expected values
  /// that Security Hub uses to filter findings. If a rule is enabled and a
  /// finding matches the conditions specified in this parameter, Security Hub
  /// applies the rule action to the finding.
  final AutomationRulesFindingFilters? criteria;

  /// A description of the rule.
  final String? description;

  /// Specifies whether a rule is the last to be applied with respect to a finding
  /// that matches the rule criteria. This is useful when a finding matches the
  /// criteria for multiple rules, and each rule has different actions. If a rule
  /// is terminal, Security Hub applies the rule action to a finding that matches
  /// the rule criteria and doesn't evaluate other rules for the finding. By
  /// default, a rule isn't terminal.
  final bool? isTerminal;

  /// The name of the rule.
  final String? ruleName;

  /// An integer ranging from 1 to 1000 that represents the order in which the
  /// rule action is applied to findings. Security Hub applies rules with lower
  /// values for this parameter first.
  final int? ruleOrder;

  /// Whether the rule is active after it is created. If this parameter is equal
  /// to <code>ENABLED</code>, Security Hub starts applying the rule to findings
  /// and finding updates after the rule is created. To change the value of this
  /// parameter after creating a rule, use <a
  /// href="https://docs.aws.amazon.com/securityhub/1.0/APIReference/API_BatchUpdateAutomationRules.html">
  /// <code>BatchUpdateAutomationRules</code> </a>.
  final RuleStatus? ruleStatus;

  UpdateAutomationRulesRequestItem({
    required this.ruleArn,
    this.actions,
    this.criteria,
    this.description,
    this.isTerminal,
    this.ruleName,
    this.ruleOrder,
    this.ruleStatus,
  });

  Map<String, dynamic> toJson() {
    final ruleArn = this.ruleArn;
    final actions = this.actions;
    final criteria = this.criteria;
    final description = this.description;
    final isTerminal = this.isTerminal;
    final ruleName = this.ruleName;
    final ruleOrder = this.ruleOrder;
    final ruleStatus = this.ruleStatus;
    return {
      'RuleArn': ruleArn,
      if (actions != null) 'Actions': actions,
      if (criteria != null) 'Criteria': criteria,
      if (description != null) 'Description': description,
      if (isTerminal != null) 'IsTerminal': isTerminal,
      if (ruleName != null) 'RuleName': ruleName,
      if (ruleOrder != null) 'RuleOrder': ruleOrder,
      if (ruleStatus != null) 'RuleStatus': ruleStatus.toValue(),
    };
  }
}

class UpdateConfigurationPolicyResponse {
  /// The ARN of the configuration policy.
  final String? arn;

  /// An object that defines how Security Hub is configured. It includes whether
  /// Security Hub is enabled or disabled, a list of enabled security standards, a
  /// list of enabled or disabled security controls, and a list of custom
  /// parameter values for specified controls. If the request included a list of
  /// security controls that are enabled in the configuration policy, Security Hub
  /// disables all other controls (including newly released controls). If the
  /// request included a list of security controls that are disabled in the
  /// configuration policy, Security Hub enables all other controls (including
  /// newly released controls).
  final Policy? configurationPolicy;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was created.
  final DateTime? createdAt;

  /// The description of the configuration policy.
  final String? description;

  /// The UUID of the configuration policy.
  final String? id;

  /// The name of the configuration policy.
  final String? name;

  /// The date and time, in UTC and ISO 8601 format, that the configuration policy
  /// was last updated.
  final DateTime? updatedAt;

  UpdateConfigurationPolicyResponse({
    this.arn,
    this.configurationPolicy,
    this.createdAt,
    this.description,
    this.id,
    this.name,
    this.updatedAt,
  });

  factory UpdateConfigurationPolicyResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateConfigurationPolicyResponse(
      arn: json['Arn'] as String?,
      configurationPolicy: json['ConfigurationPolicy'] != null
          ? Policy.fromJson(json['ConfigurationPolicy'] as Map<String, dynamic>)
          : null,
      createdAt: timeStampFromJson(json['CreatedAt']),
      description: json['Description'] as String?,
      id: json['Id'] as String?,
      name: json['Name'] as String?,
      updatedAt: timeStampFromJson(json['UpdatedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final configurationPolicy = this.configurationPolicy;
    final createdAt = this.createdAt;
    final description = this.description;
    final id = this.id;
    final name = this.name;
    final updatedAt = this.updatedAt;
    return {
      if (arn != null) 'Arn': arn,
      if (configurationPolicy != null)
        'ConfigurationPolicy': configurationPolicy,
      if (createdAt != null) 'CreatedAt': iso8601ToJson(createdAt),
      if (description != null) 'Description': description,
      if (id != null) 'Id': id,
      if (name != null) 'Name': name,
      if (updatedAt != null) 'UpdatedAt': iso8601ToJson(updatedAt),
    };
  }
}

class UpdateFindingAggregatorResponse {
  /// The aggregation Region.
  final String? findingAggregationRegion;

  /// The ARN of the finding aggregator.
  final String? findingAggregatorArn;

  /// Indicates whether to link all Regions, all Regions except for a list of
  /// excluded Regions, or a list of included Regions.
  final String? regionLinkingMode;

  /// The list of excluded Regions or included Regions.
  final List<String>? regions;

  UpdateFindingAggregatorResponse({
    this.findingAggregationRegion,
    this.findingAggregatorArn,
    this.regionLinkingMode,
    this.regions,
  });

  factory UpdateFindingAggregatorResponse.fromJson(Map<String, dynamic> json) {
    return UpdateFindingAggregatorResponse(
      findingAggregationRegion: json['FindingAggregationRegion'] as String?,
      findingAggregatorArn: json['FindingAggregatorArn'] as String?,
      regionLinkingMode: json['RegionLinkingMode'] as String?,
      regions: (json['Regions'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final findingAggregationRegion = this.findingAggregationRegion;
    final findingAggregatorArn = this.findingAggregatorArn;
    final regionLinkingMode = this.regionLinkingMode;
    final regions = this.regions;
    return {
      if (findingAggregationRegion != null)
        'FindingAggregationRegion': findingAggregationRegion,
      if (findingAggregatorArn != null)
        'FindingAggregatorArn': findingAggregatorArn,
      if (regionLinkingMode != null) 'RegionLinkingMode': regionLinkingMode,
      if (regions != null) 'Regions': regions,
    };
  }
}

class UpdateFindingsResponse {
  UpdateFindingsResponse();

  factory UpdateFindingsResponse.fromJson(Map<String, dynamic> _) {
    return UpdateFindingsResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateInsightResponse {
  UpdateInsightResponse();

  factory UpdateInsightResponse.fromJson(Map<String, dynamic> _) {
    return UpdateInsightResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateOrganizationConfigurationResponse {
  UpdateOrganizationConfigurationResponse();

  factory UpdateOrganizationConfigurationResponse.fromJson(
      Map<String, dynamic> _) {
    return UpdateOrganizationConfigurationResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateSecurityControlResponse {
  UpdateSecurityControlResponse();

  factory UpdateSecurityControlResponse.fromJson(Map<String, dynamic> _) {
    return UpdateSecurityControlResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateSecurityHubConfigurationResponse {
  UpdateSecurityHubConfigurationResponse();

  factory UpdateSecurityHubConfigurationResponse.fromJson(
      Map<String, dynamic> _) {
    return UpdateSecurityHubConfigurationResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class UpdateStandardsControlResponse {
  UpdateStandardsControlResponse();

  factory UpdateStandardsControlResponse.fromJson(Map<String, dynamic> _) {
    return UpdateStandardsControlResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

enum UpdateStatus {
  ready,
  updating,
}

extension UpdateStatusValueExtension on UpdateStatus {
  String toValue() {
    switch (this) {
      case UpdateStatus.ready:
        return 'READY';
      case UpdateStatus.updating:
        return 'UPDATING';
    }
  }
}

extension UpdateStatusFromString on String {
  UpdateStatus toUpdateStatus() {
    switch (this) {
      case 'READY':
        return UpdateStatus.ready;
      case 'UPDATING':
        return UpdateStatus.updating;
    }
    throw Exception('$this is not known in enum UpdateStatus');
  }
}

enum VerificationState {
  unknown,
  truePositive,
  falsePositive,
  benignPositive,
}

extension VerificationStateValueExtension on VerificationState {
  String toValue() {
    switch (this) {
      case VerificationState.unknown:
        return 'UNKNOWN';
      case VerificationState.truePositive:
        return 'TRUE_POSITIVE';
      case VerificationState.falsePositive:
        return 'FALSE_POSITIVE';
      case VerificationState.benignPositive:
        return 'BENIGN_POSITIVE';
    }
  }
}

extension VerificationStateFromString on String {
  VerificationState toVerificationState() {
    switch (this) {
      case 'UNKNOWN':
        return VerificationState.unknown;
      case 'TRUE_POSITIVE':
        return VerificationState.truePositive;
      case 'FALSE_POSITIVE':
        return VerificationState.falsePositive;
      case 'BENIGN_POSITIVE':
        return VerificationState.benignPositive;
    }
    throw Exception('$this is not known in enum VerificationState');
  }
}

/// Describes the mounting of a volume in a container.
class VolumeMount {
  /// The path in the container at which the volume should be mounted.
  final String? mountPath;

  /// The name of the volume.
  final String? name;

  VolumeMount({
    this.mountPath,
    this.name,
  });

  factory VolumeMount.fromJson(Map<String, dynamic> json) {
    return VolumeMount(
      mountPath: json['MountPath'] as String?,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final mountPath = this.mountPath;
    final name = this.name;
    return {
      if (mountPath != null) 'MountPath': mountPath,
      if (name != null) 'Name': name,
    };
  }
}

/// Provides details about the IPv4 CIDR blocks for the VPC.
class VpcInfoCidrBlockSetDetails {
  /// The IPv4 CIDR block for the VPC.
  final String? cidrBlock;

  VpcInfoCidrBlockSetDetails({
    this.cidrBlock,
  });

  factory VpcInfoCidrBlockSetDetails.fromJson(Map<String, dynamic> json) {
    return VpcInfoCidrBlockSetDetails(
      cidrBlock: json['CidrBlock'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cidrBlock = this.cidrBlock;
    return {
      if (cidrBlock != null) 'CidrBlock': cidrBlock,
    };
  }
}

/// Provides details about the IPv6 CIDR blocks for the VPC.
class VpcInfoIpv6CidrBlockSetDetails {
  /// The IPv6 CIDR block for the VPC.
  final String? ipv6CidrBlock;

  VpcInfoIpv6CidrBlockSetDetails({
    this.ipv6CidrBlock,
  });

  factory VpcInfoIpv6CidrBlockSetDetails.fromJson(Map<String, dynamic> json) {
    return VpcInfoIpv6CidrBlockSetDetails(
      ipv6CidrBlock: json['Ipv6CidrBlock'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipv6CidrBlock = this.ipv6CidrBlock;
    return {
      if (ipv6CidrBlock != null) 'Ipv6CidrBlock': ipv6CidrBlock,
    };
  }
}

/// Provides information about the VPC peering connection options for the
/// accepter or requester VPC.
class VpcInfoPeeringOptionsDetails {
  /// Indicates whether a local VPC can resolve public DNS hostnames to private IP
  /// addresses when queried from instances in a peer VPC.
  final bool? allowDnsResolutionFromRemoteVpc;

  /// Indicates whether a local ClassicLink connection can communicate with the
  /// peer VPC over the VPC peering connection.
  final bool? allowEgressFromLocalClassicLinkToRemoteVpc;

  /// Indicates whether a local VPC can communicate with a ClassicLink connection
  /// in the peer VPC over the VPC peering connection.
  final bool? allowEgressFromLocalVpcToRemoteClassicLink;

  VpcInfoPeeringOptionsDetails({
    this.allowDnsResolutionFromRemoteVpc,
    this.allowEgressFromLocalClassicLinkToRemoteVpc,
    this.allowEgressFromLocalVpcToRemoteClassicLink,
  });

  factory VpcInfoPeeringOptionsDetails.fromJson(Map<String, dynamic> json) {
    return VpcInfoPeeringOptionsDetails(
      allowDnsResolutionFromRemoteVpc:
          json['AllowDnsResolutionFromRemoteVpc'] as bool?,
      allowEgressFromLocalClassicLinkToRemoteVpc:
          json['AllowEgressFromLocalClassicLinkToRemoteVpc'] as bool?,
      allowEgressFromLocalVpcToRemoteClassicLink:
          json['AllowEgressFromLocalVpcToRemoteClassicLink'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final allowDnsResolutionFromRemoteVpc =
        this.allowDnsResolutionFromRemoteVpc;
    final allowEgressFromLocalClassicLinkToRemoteVpc =
        this.allowEgressFromLocalClassicLinkToRemoteVpc;
    final allowEgressFromLocalVpcToRemoteClassicLink =
        this.allowEgressFromLocalVpcToRemoteClassicLink;
    return {
      if (allowDnsResolutionFromRemoteVpc != null)
        'AllowDnsResolutionFromRemoteVpc': allowDnsResolutionFromRemoteVpc,
      if (allowEgressFromLocalClassicLinkToRemoteVpc != null)
        'AllowEgressFromLocalClassicLinkToRemoteVpc':
            allowEgressFromLocalClassicLinkToRemoteVpc,
      if (allowEgressFromLocalVpcToRemoteClassicLink != null)
        'AllowEgressFromLocalVpcToRemoteClassicLink':
            allowEgressFromLocalVpcToRemoteClassicLink,
    };
  }
}

/// A vulnerability associated with a finding.
class Vulnerability {
  /// The identifier of the vulnerability.
  final String id;

  /// The vulnerabilities found in your Lambda function code. This field pertains
  /// to findings that Security Hub receives from Amazon Inspector.
  final List<VulnerabilityCodeVulnerabilities>? codeVulnerabilities;

  /// CVSS scores from the advisory related to the vulnerability.
  final List<Cvss>? cvss;

  /// The Exploit Prediction Scoring System (EPSS) score for a finding.
  final double? epssScore;

  /// Whether an exploit is available for a finding.
  final VulnerabilityExploitAvailable? exploitAvailable;

  /// Specifies if all vulnerable packages in a finding have a value for
  /// <code>FixedInVersion</code> and <code>Remediation</code>. This field is
  /// evaluated for each vulnerability <code>Id</code> based on the number of
  /// vulnerable packages that have a value for both <code>FixedInVersion</code>
  /// and <code>Remediation</code>. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>YES</code> if all vulnerable packages have a value for both
  /// <code>FixedInVersion</code> and <code>Remediation</code>
  /// </li>
  /// <li>
  /// <code>NO</code> if no vulnerable packages have a value for
  /// <code>FixedInVersion</code> and <code>Remediation</code>
  /// </li>
  /// <li>
  /// <code>PARTIAL</code> otherwise
  /// </li>
  /// </ul>
  final VulnerabilityFixAvailable? fixAvailable;

  /// The date and time of the last exploit associated with a finding discovered
  /// in your environment.
  final String? lastKnownExploitAt;

  /// A list of URLs that provide additional information about the vulnerability.
  final List<String>? referenceUrls;

  /// List of vulnerabilities that are related to this vulnerability.
  final List<String>? relatedVulnerabilities;

  /// Information about the vendor that generates the vulnerability report.
  final VulnerabilityVendor? vendor;

  /// List of software packages that have the vulnerability.
  final List<SoftwarePackage>? vulnerablePackages;

  Vulnerability({
    required this.id,
    this.codeVulnerabilities,
    this.cvss,
    this.epssScore,
    this.exploitAvailable,
    this.fixAvailable,
    this.lastKnownExploitAt,
    this.referenceUrls,
    this.relatedVulnerabilities,
    this.vendor,
    this.vulnerablePackages,
  });

  factory Vulnerability.fromJson(Map<String, dynamic> json) {
    return Vulnerability(
      id: json['Id'] as String,
      codeVulnerabilities: (json['CodeVulnerabilities'] as List?)
          ?.whereNotNull()
          .map((e) => VulnerabilityCodeVulnerabilities.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      cvss: (json['Cvss'] as List?)
          ?.whereNotNull()
          .map((e) => Cvss.fromJson(e as Map<String, dynamic>))
          .toList(),
      epssScore: json['EpssScore'] as double?,
      exploitAvailable: (json['ExploitAvailable'] as String?)
          ?.toVulnerabilityExploitAvailable(),
      fixAvailable:
          (json['FixAvailable'] as String?)?.toVulnerabilityFixAvailable(),
      lastKnownExploitAt: json['LastKnownExploitAt'] as String?,
      referenceUrls: (json['ReferenceUrls'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      relatedVulnerabilities: (json['RelatedVulnerabilities'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      vendor: json['Vendor'] != null
          ? VulnerabilityVendor.fromJson(json['Vendor'] as Map<String, dynamic>)
          : null,
      vulnerablePackages: (json['VulnerablePackages'] as List?)
          ?.whereNotNull()
          .map((e) => SoftwarePackage.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final codeVulnerabilities = this.codeVulnerabilities;
    final cvss = this.cvss;
    final epssScore = this.epssScore;
    final exploitAvailable = this.exploitAvailable;
    final fixAvailable = this.fixAvailable;
    final lastKnownExploitAt = this.lastKnownExploitAt;
    final referenceUrls = this.referenceUrls;
    final relatedVulnerabilities = this.relatedVulnerabilities;
    final vendor = this.vendor;
    final vulnerablePackages = this.vulnerablePackages;
    return {
      'Id': id,
      if (codeVulnerabilities != null)
        'CodeVulnerabilities': codeVulnerabilities,
      if (cvss != null) 'Cvss': cvss,
      if (epssScore != null) 'EpssScore': epssScore,
      if (exploitAvailable != null)
        'ExploitAvailable': exploitAvailable.toValue(),
      if (fixAvailable != null) 'FixAvailable': fixAvailable.toValue(),
      if (lastKnownExploitAt != null) 'LastKnownExploitAt': lastKnownExploitAt,
      if (referenceUrls != null) 'ReferenceUrls': referenceUrls,
      if (relatedVulnerabilities != null)
        'RelatedVulnerabilities': relatedVulnerabilities,
      if (vendor != null) 'Vendor': vendor,
      if (vulnerablePackages != null) 'VulnerablePackages': vulnerablePackages,
    };
  }
}

/// Provides details about the vulnerabilities found in your Lambda function
/// code. This field pertains to findings that Security Hub receives from Amazon
/// Inspector.
class VulnerabilityCodeVulnerabilities {
  /// The Common Weakness Enumeration (CWE) item associated with the detected code
  /// vulnerability.
  final List<String>? cwes;

  /// Provides details about where a code vulnerability is located in your Lambda
  /// function.
  final CodeVulnerabilitiesFilePath? filePath;

  /// The Amazon Resource Name (ARN) of the Lambda layer in which the code
  /// vulnerability is located.
  final String? sourceArn;

  VulnerabilityCodeVulnerabilities({
    this.cwes,
    this.filePath,
    this.sourceArn,
  });

  factory VulnerabilityCodeVulnerabilities.fromJson(Map<String, dynamic> json) {
    return VulnerabilityCodeVulnerabilities(
      cwes: (json['Cwes'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      filePath: json['FilePath'] != null
          ? CodeVulnerabilitiesFilePath.fromJson(
              json['FilePath'] as Map<String, dynamic>)
          : null,
      sourceArn: json['SourceArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cwes = this.cwes;
    final filePath = this.filePath;
    final sourceArn = this.sourceArn;
    return {
      if (cwes != null) 'Cwes': cwes,
      if (filePath != null) 'FilePath': filePath,
      if (sourceArn != null) 'SourceArn': sourceArn,
    };
  }
}

enum VulnerabilityExploitAvailable {
  yes,
  no,
}

extension VulnerabilityExploitAvailableValueExtension
    on VulnerabilityExploitAvailable {
  String toValue() {
    switch (this) {
      case VulnerabilityExploitAvailable.yes:
        return 'YES';
      case VulnerabilityExploitAvailable.no:
        return 'NO';
    }
  }
}

extension VulnerabilityExploitAvailableFromString on String {
  VulnerabilityExploitAvailable toVulnerabilityExploitAvailable() {
    switch (this) {
      case 'YES':
        return VulnerabilityExploitAvailable.yes;
      case 'NO':
        return VulnerabilityExploitAvailable.no;
    }
    throw Exception('$this is not known in enum VulnerabilityExploitAvailable');
  }
}

enum VulnerabilityFixAvailable {
  yes,
  no,
  partial,
}

extension VulnerabilityFixAvailableValueExtension on VulnerabilityFixAvailable {
  String toValue() {
    switch (this) {
      case VulnerabilityFixAvailable.yes:
        return 'YES';
      case VulnerabilityFixAvailable.no:
        return 'NO';
      case VulnerabilityFixAvailable.partial:
        return 'PARTIAL';
    }
  }
}

extension VulnerabilityFixAvailableFromString on String {
  VulnerabilityFixAvailable toVulnerabilityFixAvailable() {
    switch (this) {
      case 'YES':
        return VulnerabilityFixAvailable.yes;
      case 'NO':
        return VulnerabilityFixAvailable.no;
      case 'PARTIAL':
        return VulnerabilityFixAvailable.partial;
    }
    throw Exception('$this is not known in enum VulnerabilityFixAvailable');
  }
}

/// A vendor that generates a vulnerability report.
class VulnerabilityVendor {
  /// The name of the vendor.
  final String name;

  /// The URL of the vulnerability advisory.
  final String? url;

  /// Indicates when the vulnerability advisory was created.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? vendorCreatedAt;

  /// The severity that the vendor assigned to the vulnerability.
  final String? vendorSeverity;

  /// Indicates when the vulnerability advisory was last updated.
  ///
  /// This field accepts only the specified formats. Timestamps can end with
  /// <code>Z</code> or <code>("+" / "-") time-hour [":" time-minute]</code>. The
  /// time-secfrac after seconds is limited to a maximum of 9 digits. The offset
  /// is bounded by +/-18:00. Here are valid timestamp formats with examples:
  ///
  /// <ul>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SSZ</code> (for example,
  /// <code>2019-01-31T23:00:00Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmmZ</code> (for example,
  /// <code>2019-01-31T23:00:00.123456789Z</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10+17:59</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS-HHMM</code> (for example,
  /// <code>2024-01-04T15:25:10-1759</code>)
  /// </li>
  /// <li>
  /// <code>YYYY-MM-DDTHH:MM:SS.mmmmmmmmm+HH:MM</code> (for example,
  /// <code>2024-01-04T15:25:10.123456789+17:59</code>)
  /// </li>
  /// </ul>
  final String? vendorUpdatedAt;

  VulnerabilityVendor({
    required this.name,
    this.url,
    this.vendorCreatedAt,
    this.vendorSeverity,
    this.vendorUpdatedAt,
  });

  factory VulnerabilityVendor.fromJson(Map<String, dynamic> json) {
    return VulnerabilityVendor(
      name: json['Name'] as String,
      url: json['Url'] as String?,
      vendorCreatedAt: json['VendorCreatedAt'] as String?,
      vendorSeverity: json['VendorSeverity'] as String?,
      vendorUpdatedAt: json['VendorUpdatedAt'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final url = this.url;
    final vendorCreatedAt = this.vendorCreatedAt;
    final vendorSeverity = this.vendorSeverity;
    final vendorUpdatedAt = this.vendorUpdatedAt;
    return {
      'Name': name,
      if (url != null) 'Url': url,
      if (vendorCreatedAt != null) 'VendorCreatedAt': vendorCreatedAt,
      if (vendorSeverity != null) 'VendorSeverity': vendorSeverity,
      if (vendorUpdatedAt != null) 'VendorUpdatedAt': vendorUpdatedAt,
    };
  }
}

/// Details about the action that CloudFront or WAF takes when a web request
/// matches the conditions in the rule.
class WafAction {
  /// Specifies how you want WAF to respond to requests that match the settings in
  /// a rule.
  ///
  /// Valid settings include the following:
  ///
  /// <ul>
  /// <li>
  /// <code>ALLOW</code> - WAF allows requests
  /// </li>
  /// <li>
  /// <code>BLOCK</code> - WAF blocks requests
  /// </li>
  /// <li>
  /// <code>COUNT</code> - WAF increments a counter of the requests that match all
  /// of the conditions in the rule. WAF then continues to inspect the web request
  /// based on the remaining rules in the web ACL. You can't specify
  /// <code>COUNT</code> for the default action for a web ACL.
  /// </li>
  /// </ul>
  final String? type;

  WafAction({
    this.type,
  });

  factory WafAction.fromJson(Map<String, dynamic> json) {
    return WafAction(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Details about a rule to exclude from a rule group.
class WafExcludedRule {
  /// The unique identifier for the rule to exclude from the rule group.
  final String? ruleId;

  WafExcludedRule({
    this.ruleId,
  });

  factory WafExcludedRule.fromJson(Map<String, dynamic> json) {
    return WafExcludedRule(
      ruleId: json['RuleId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ruleId = this.ruleId;
    return {
      if (ruleId != null) 'RuleId': ruleId,
    };
  }
}

/// Details about an override action for a rule.
class WafOverrideAction {
  /// <code>COUNT</code> overrides the action specified by the individual rule
  /// within a <code>RuleGroup</code> .
  ///
  /// If set to <code>NONE</code>, the rule's action takes place.
  final String? type;

  WafOverrideAction({
    this.type,
  });

  factory WafOverrideAction.fromJson(Map<String, dynamic> json) {
    return WafOverrideAction(
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'Type': type,
    };
  }
}

/// Provides details about the status of the investigation into a finding.
class Workflow {
  /// The status of the investigation into the finding. The workflow status is
  /// specific to an individual finding. It does not affect the generation of new
  /// findings. For example, setting the workflow status to
  /// <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new
  /// finding for the same issue.
  ///
  /// The allowed values are the following.
  ///
  /// <ul>
  /// <li>
  /// <code>NEW</code> - The initial state of a finding, before it is reviewed.
  ///
  /// Security Hub also resets the workflow status from <code>NOTIFIED</code> or
  /// <code>RESOLVED</code> to <code>NEW</code> in the following cases:
  ///
  /// <ul>
  /// <li>
  /// <code>RecordState</code> changes from <code>ARCHIVED</code> to
  /// <code>ACTIVE</code>.
  /// </li>
  /// <li>
  /// <code>ComplianceStatus</code> changes from <code>PASSED</code> to either
  /// <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>NOTIFIED</code> - Indicates that you notified the resource owner about
  /// the security issue. Used when the initial reviewer is not the resource
  /// owner, and needs intervention from the resource owner.
  /// </li>
  /// <li>
  /// <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not
  /// believe that any action is needed. The finding is no longer updated.
  /// </li>
  /// <li>
  /// <code>RESOLVED</code> - The finding was reviewed and remediated and is now
  /// considered resolved.
  /// </li>
  /// </ul>
  final WorkflowStatus? status;

  Workflow({
    this.status,
  });

  factory Workflow.fromJson(Map<String, dynamic> json) {
    return Workflow(
      status: (json['Status'] as String?)?.toWorkflowStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status.toValue(),
    };
  }
}

@Deprecated(
    'This filter is deprecated. Instead, use SeverityLabel or FindingProviderFieldsSeverityLabel.')
enum WorkflowState {
  $new,
  assigned,
  inProgress,
  deferred,
  resolved,
}

extension WorkflowStateValueExtension on WorkflowState {
  String toValue() {
    switch (this) {
      case WorkflowState.$new:
        return 'NEW';
      case WorkflowState.assigned:
        return 'ASSIGNED';
      case WorkflowState.inProgress:
        return 'IN_PROGRESS';
      case WorkflowState.deferred:
        return 'DEFERRED';
      case WorkflowState.resolved:
        return 'RESOLVED';
    }
  }
}

extension WorkflowStateFromString on String {
  WorkflowState toWorkflowState() {
    switch (this) {
      case 'NEW':
        return WorkflowState.$new;
      case 'ASSIGNED':
        return WorkflowState.assigned;
      case 'IN_PROGRESS':
        return WorkflowState.inProgress;
      case 'DEFERRED':
        return WorkflowState.deferred;
      case 'RESOLVED':
        return WorkflowState.resolved;
    }
    throw Exception('$this is not known in enum WorkflowState');
  }
}

enum WorkflowStatus {
  $new,
  notified,
  resolved,
  suppressed,
}

extension WorkflowStatusValueExtension on WorkflowStatus {
  String toValue() {
    switch (this) {
      case WorkflowStatus.$new:
        return 'NEW';
      case WorkflowStatus.notified:
        return 'NOTIFIED';
      case WorkflowStatus.resolved:
        return 'RESOLVED';
      case WorkflowStatus.suppressed:
        return 'SUPPRESSED';
    }
  }
}

extension WorkflowStatusFromString on String {
  WorkflowStatus toWorkflowStatus() {
    switch (this) {
      case 'NEW':
        return WorkflowStatus.$new;
      case 'NOTIFIED':
        return WorkflowStatus.notified;
      case 'RESOLVED':
        return WorkflowStatus.resolved;
      case 'SUPPRESSED':
        return WorkflowStatus.suppressed;
    }
    throw Exception('$this is not known in enum WorkflowStatus');
  }
}

/// Used to update information about the investigation into the finding.
class WorkflowUpdate {
  /// The status of the investigation into the finding. The workflow status is
  /// specific to an individual finding. It does not affect the generation of new
  /// findings. For example, setting the workflow status to
  /// <code>SUPPRESSED</code> or <code>RESOLVED</code> does not prevent a new
  /// finding for the same issue.
  ///
  /// The allowed values are the following.
  ///
  /// <ul>
  /// <li>
  /// <code>NEW</code> - The initial state of a finding, before it is reviewed.
  ///
  /// Security Hub also resets <code>WorkFlowStatus</code> from
  /// <code>NOTIFIED</code> or <code>RESOLVED</code> to <code>NEW</code> in the
  /// following cases:
  ///
  /// <ul>
  /// <li>
  /// The record state changes from <code>ARCHIVED</code> to <code>ACTIVE</code>.
  /// </li>
  /// <li>
  /// The compliance status changes from <code>PASSED</code> to either
  /// <code>WARNING</code>, <code>FAILED</code>, or <code>NOT_AVAILABLE</code>.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>NOTIFIED</code> - Indicates that you notified the resource owner about
  /// the security issue. Used when the initial reviewer is not the resource
  /// owner, and needs intervention from the resource owner.
  /// </li>
  /// <li>
  /// <code>RESOLVED</code> - The finding was reviewed and remediated and is now
  /// considered resolved.
  /// </li>
  /// <li>
  /// <code>SUPPRESSED</code> - Indicates that you reviewed the finding and do not
  /// believe that any action is needed. The finding is no longer updated.
  /// </li>
  /// </ul>
  final WorkflowStatus? status;

  WorkflowUpdate({
    this.status,
  });

  factory WorkflowUpdate.fromJson(Map<String, dynamic> json) {
    return WorkflowUpdate(
      status: (json['Status'] as String?)?.toWorkflowStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status.toValue(),
    };
  }
}

class AccessDeniedException extends _s.GenericAwsException {
  AccessDeniedException({String? type, String? message})
      : super(type: type, code: 'AccessDeniedException', message: message);
}

class InternalException extends _s.GenericAwsException {
  InternalException({String? type, String? message})
      : super(type: type, code: 'InternalException', message: message);
}

class InvalidAccessException extends _s.GenericAwsException {
  InvalidAccessException({String? type, String? message})
      : super(type: type, code: 'InvalidAccessException', message: message);
}

class InvalidInputException extends _s.GenericAwsException {
  InvalidInputException({String? type, String? message})
      : super(type: type, code: 'InvalidInputException', message: message);
}

class LimitExceededException extends _s.GenericAwsException {
  LimitExceededException({String? type, String? message})
      : super(type: type, code: 'LimitExceededException', message: message);
}

class ResourceConflictException extends _s.GenericAwsException {
  ResourceConflictException({String? type, String? message})
      : super(type: type, code: 'ResourceConflictException', message: message);
}

class ResourceInUseException extends _s.GenericAwsException {
  ResourceInUseException({String? type, String? message})
      : super(type: type, code: 'ResourceInUseException', message: message);
}

class ResourceNotFoundException extends _s.GenericAwsException {
  ResourceNotFoundException({String? type, String? message})
      : super(type: type, code: 'ResourceNotFoundException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'AccessDeniedException': (type, message) =>
      AccessDeniedException(type: type, message: message),
  'InternalException': (type, message) =>
      InternalException(type: type, message: message),
  'InvalidAccessException': (type, message) =>
      InvalidAccessException(type: type, message: message),
  'InvalidInputException': (type, message) =>
      InvalidInputException(type: type, message: message),
  'LimitExceededException': (type, message) =>
      LimitExceededException(type: type, message: message),
  'ResourceConflictException': (type, message) =>
      ResourceConflictException(type: type, message: message),
  'ResourceInUseException': (type, message) =>
      ResourceInUseException(type: type, message: message),
  'ResourceNotFoundException': (type, message) =>
      ResourceNotFoundException(type: type, message: message),
};
