// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: camel_case_types

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        nonNullableTimeStampFromJson,
        timeStampFromJson;

export '../../shared/shared.dart' show AwsClientCredentials;

/// Amazon Inspector enables you to analyze the behavior of your AWS resources
/// and to identify potential security issues. For more information, see <a
/// href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_introduction.html">
/// Amazon Inspector User Guide</a>.
class Inspector {
  final _s.JsonProtocol _protocol;
  Inspector({
    required String region,
    _s.AwsClientCredentials? credentials,
    _s.Client? client,
    String? endpointUrl,
  }) : _protocol = _s.JsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'inspector',
          ),
          region: region,
          credentials: credentials,
          endpointUrl: endpointUrl,
        );

  /// Assigns attributes (key and value pairs) to the findings that are
  /// specified by the ARNs of the findings.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [attributes] :
  /// The array of attributes that you want to assign to specified findings.
  ///
  /// Parameter [findingArns] :
  /// The ARNs that specify the findings that you want to assign attributes to.
  Future<AddAttributesToFindingsResponse> addAttributesToFindings({
    required List<Attribute> attributes,
    required List<String> findingArns,
  }) async {
    ArgumentError.checkNotNull(attributes, 'attributes');
    ArgumentError.checkNotNull(findingArns, 'findingArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.AddAttributesToFindings'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'attributes': attributes,
        'findingArns': findingArns,
      },
    );

    return AddAttributesToFindingsResponse.fromJson(jsonResponse.body);
  }

  /// Creates a new assessment target using the ARN of the resource group that
  /// is generated by <a>CreateResourceGroup</a>. If resourceGroupArn is not
  /// specified, all EC2 instances in the current AWS account and region are
  /// included in the assessment target. If the <a
  /// href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_slr.html">service-linked
  /// role</a> isn’t already registered, this action also creates and registers
  /// a service-linked role to grant Amazon Inspector access to AWS Services
  /// needed to perform security assessments. You can create up to 50 assessment
  /// targets per AWS account. You can run up to 500 concurrent agents per AWS
  /// account. For more information, see <a
  /// href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_applications.html">
  /// Amazon Inspector Assessment Targets</a>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [InvalidCrossAccountRoleException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTargetName] :
  /// The user-defined name that identifies the assessment target that you want
  /// to create. The name must be unique within the AWS account.
  ///
  /// Parameter [resourceGroupArn] :
  /// The ARN that specifies the resource group that is used to create the
  /// assessment target. If resourceGroupArn is not specified, all EC2 instances
  /// in the current AWS account and region are included in the assessment
  /// target.
  Future<CreateAssessmentTargetResponse> createAssessmentTarget({
    required String assessmentTargetName,
    String? resourceGroupArn,
  }) async {
    ArgumentError.checkNotNull(assessmentTargetName, 'assessmentTargetName');
    _s.validateStringLength(
      'assessmentTargetName',
      assessmentTargetName,
      1,
      140,
      isRequired: true,
    );
    _s.validateStringLength(
      'resourceGroupArn',
      resourceGroupArn,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.CreateAssessmentTarget'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTargetName': assessmentTargetName,
        if (resourceGroupArn != null) 'resourceGroupArn': resourceGroupArn,
      },
    );

    return CreateAssessmentTargetResponse.fromJson(jsonResponse.body);
  }

  /// Creates an assessment template for the assessment target that is specified
  /// by the ARN of the assessment target. If the <a
  /// href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_slr.html">service-linked
  /// role</a> isn’t already registered, this action also creates and registers
  /// a service-linked role to grant Amazon Inspector access to AWS Services
  /// needed to perform security assessments.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTargetArn] :
  /// The ARN that specifies the assessment target for which you want to create
  /// the assessment template.
  ///
  /// Parameter [assessmentTemplateName] :
  /// The user-defined name that identifies the assessment template that you
  /// want to create. You can create several assessment templates for an
  /// assessment target. The names of the assessment templates that correspond
  /// to a particular assessment target must be unique.
  ///
  /// Parameter [durationInSeconds] :
  /// The duration of the assessment run in seconds.
  ///
  /// Parameter [rulesPackageArns] :
  /// The ARNs that specify the rules packages that you want to attach to the
  /// assessment template.
  ///
  /// Parameter [userAttributesForFindings] :
  /// The user-defined attributes that are assigned to every finding that is
  /// generated by the assessment run that uses this assessment template. An
  /// attribute is a key and value pair (an <a>Attribute</a> object). Within an
  /// assessment template, each key must be unique.
  Future<CreateAssessmentTemplateResponse> createAssessmentTemplate({
    required String assessmentTargetArn,
    required String assessmentTemplateName,
    required int durationInSeconds,
    required List<String> rulesPackageArns,
    List<Attribute>? userAttributesForFindings,
  }) async {
    ArgumentError.checkNotNull(assessmentTargetArn, 'assessmentTargetArn');
    _s.validateStringLength(
      'assessmentTargetArn',
      assessmentTargetArn,
      1,
      300,
      isRequired: true,
    );
    ArgumentError.checkNotNull(
        assessmentTemplateName, 'assessmentTemplateName');
    _s.validateStringLength(
      'assessmentTemplateName',
      assessmentTemplateName,
      1,
      140,
      isRequired: true,
    );
    ArgumentError.checkNotNull(durationInSeconds, 'durationInSeconds');
    _s.validateNumRange(
      'durationInSeconds',
      durationInSeconds,
      180,
      86400,
      isRequired: true,
    );
    ArgumentError.checkNotNull(rulesPackageArns, 'rulesPackageArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.CreateAssessmentTemplate'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTargetArn': assessmentTargetArn,
        'assessmentTemplateName': assessmentTemplateName,
        'durationInSeconds': durationInSeconds,
        'rulesPackageArns': rulesPackageArns,
        if (userAttributesForFindings != null)
          'userAttributesForFindings': userAttributesForFindings,
      },
    );

    return CreateAssessmentTemplateResponse.fromJson(jsonResponse.body);
  }

  /// Starts the generation of an exclusions preview for the specified
  /// assessment template. The exclusions preview lists the potential exclusions
  /// (ExclusionPreview) that Inspector can detect before it runs the
  /// assessment.
  ///
  /// May throw [InvalidInputException].
  /// May throw [PreviewGenerationInProgressException].
  /// May throw [InternalException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTemplateArn] :
  /// The ARN that specifies the assessment template for which you want to
  /// create an exclusions preview.
  Future<CreateExclusionsPreviewResponse> createExclusionsPreview({
    required String assessmentTemplateArn,
  }) async {
    ArgumentError.checkNotNull(assessmentTemplateArn, 'assessmentTemplateArn');
    _s.validateStringLength(
      'assessmentTemplateArn',
      assessmentTemplateArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.CreateExclusionsPreview'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTemplateArn': assessmentTemplateArn,
      },
    );

    return CreateExclusionsPreviewResponse.fromJson(jsonResponse.body);
  }

  /// Creates a resource group using the specified set of tags (key and value
  /// pairs) that are used to select the EC2 instances to be included in an
  /// Amazon Inspector assessment target. The created resource group is then
  /// used to create an Amazon Inspector assessment target. For more
  /// information, see <a>CreateAssessmentTarget</a>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [resourceGroupTags] :
  /// A collection of keys and an array of possible values,
  /// '[{"key":"key1","values":["Value1","Value2"]},{"key":"Key2","values":["Value3"]}]'.
  ///
  /// For example,'[{"key":"Name","values":["TestEC2Instance"]}]'.
  Future<CreateResourceGroupResponse> createResourceGroup({
    required List<ResourceGroupTag> resourceGroupTags,
  }) async {
    ArgumentError.checkNotNull(resourceGroupTags, 'resourceGroupTags');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.CreateResourceGroup'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'resourceGroupTags': resourceGroupTags,
      },
    );

    return CreateResourceGroupResponse.fromJson(jsonResponse.body);
  }

  /// Deletes the assessment run that is specified by the ARN of the assessment
  /// run.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AssessmentRunInProgressException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentRunArn] :
  /// The ARN that specifies the assessment run that you want to delete.
  Future<void> deleteAssessmentRun({
    required String assessmentRunArn,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArn, 'assessmentRunArn');
    _s.validateStringLength(
      'assessmentRunArn',
      assessmentRunArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DeleteAssessmentRun'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArn': assessmentRunArn,
      },
    );
  }

  /// Deletes the assessment target that is specified by the ARN of the
  /// assessment target.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AssessmentRunInProgressException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTargetArn] :
  /// The ARN that specifies the assessment target that you want to delete.
  Future<void> deleteAssessmentTarget({
    required String assessmentTargetArn,
  }) async {
    ArgumentError.checkNotNull(assessmentTargetArn, 'assessmentTargetArn');
    _s.validateStringLength(
      'assessmentTargetArn',
      assessmentTargetArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DeleteAssessmentTarget'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTargetArn': assessmentTargetArn,
      },
    );
  }

  /// Deletes the assessment template that is specified by the ARN of the
  /// assessment template.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AssessmentRunInProgressException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTemplateArn] :
  /// The ARN that specifies the assessment template that you want to delete.
  Future<void> deleteAssessmentTemplate({
    required String assessmentTemplateArn,
  }) async {
    ArgumentError.checkNotNull(assessmentTemplateArn, 'assessmentTemplateArn');
    _s.validateStringLength(
      'assessmentTemplateArn',
      assessmentTemplateArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DeleteAssessmentTemplate'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTemplateArn': assessmentTemplateArn,
      },
    );
  }

  /// Describes the assessment runs that are specified by the ARNs of the
  /// assessment runs.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [assessmentRunArns] :
  /// The ARN that specifies the assessment run that you want to describe.
  Future<DescribeAssessmentRunsResponse> describeAssessmentRuns({
    required List<String> assessmentRunArns,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArns, 'assessmentRunArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeAssessmentRuns'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArns': assessmentRunArns,
      },
    );

    return DescribeAssessmentRunsResponse.fromJson(jsonResponse.body);
  }

  /// Describes the assessment targets that are specified by the ARNs of the
  /// assessment targets.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [assessmentTargetArns] :
  /// The ARNs that specifies the assessment targets that you want to describe.
  Future<DescribeAssessmentTargetsResponse> describeAssessmentTargets({
    required List<String> assessmentTargetArns,
  }) async {
    ArgumentError.checkNotNull(assessmentTargetArns, 'assessmentTargetArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeAssessmentTargets'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTargetArns': assessmentTargetArns,
      },
    );

    return DescribeAssessmentTargetsResponse.fromJson(jsonResponse.body);
  }

  /// Describes the assessment templates that are specified by the ARNs of the
  /// assessment templates.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  Future<DescribeAssessmentTemplatesResponse> describeAssessmentTemplates({
    required List<String> assessmentTemplateArns,
  }) async {
    ArgumentError.checkNotNull(
        assessmentTemplateArns, 'assessmentTemplateArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeAssessmentTemplates'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTemplateArns': assessmentTemplateArns,
      },
    );

    return DescribeAssessmentTemplatesResponse.fromJson(jsonResponse.body);
  }

  /// Describes the IAM role that enables Amazon Inspector to access your AWS
  /// account.
  ///
  /// May throw [InternalException].
  Future<DescribeCrossAccountAccessRoleResponse>
      describeCrossAccountAccessRole() async {
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeCrossAccountAccessRole'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
    );

    return DescribeCrossAccountAccessRoleResponse.fromJson(jsonResponse.body);
  }

  /// Describes the exclusions that are specified by the exclusions' ARNs.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [exclusionArns] :
  /// The list of ARNs that specify the exclusions that you want to describe.
  ///
  /// Parameter [locale] :
  /// The locale into which you want to translate the exclusion's title,
  /// description, and recommendation.
  Future<DescribeExclusionsResponse> describeExclusions({
    required List<String> exclusionArns,
    Locale? locale,
  }) async {
    ArgumentError.checkNotNull(exclusionArns, 'exclusionArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeExclusions'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'exclusionArns': exclusionArns,
        if (locale != null) 'locale': locale.toValue(),
      },
    );

    return DescribeExclusionsResponse.fromJson(jsonResponse.body);
  }

  /// Describes the findings that are specified by the ARNs of the findings.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [findingArns] :
  /// The ARN that specifies the finding that you want to describe.
  ///
  /// Parameter [locale] :
  /// The locale into which you want to translate a finding description,
  /// recommendation, and the short description that identifies the finding.
  Future<DescribeFindingsResponse> describeFindings({
    required List<String> findingArns,
    Locale? locale,
  }) async {
    ArgumentError.checkNotNull(findingArns, 'findingArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeFindings'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'findingArns': findingArns,
        if (locale != null) 'locale': locale.toValue(),
      },
    );

    return DescribeFindingsResponse.fromJson(jsonResponse.body);
  }

  /// Describes the resource groups that are specified by the ARNs of the
  /// resource groups.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [resourceGroupArns] :
  /// The ARN that specifies the resource group that you want to describe.
  Future<DescribeResourceGroupsResponse> describeResourceGroups({
    required List<String> resourceGroupArns,
  }) async {
    ArgumentError.checkNotNull(resourceGroupArns, 'resourceGroupArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeResourceGroups'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'resourceGroupArns': resourceGroupArns,
      },
    );

    return DescribeResourceGroupsResponse.fromJson(jsonResponse.body);
  }

  /// Describes the rules packages that are specified by the ARNs of the rules
  /// packages.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  ///
  /// Parameter [rulesPackageArns] :
  /// The ARN that specifies the rules package that you want to describe.
  ///
  /// Parameter [locale] :
  /// The locale that you want to translate a rules package description into.
  Future<DescribeRulesPackagesResponse> describeRulesPackages({
    required List<String> rulesPackageArns,
    Locale? locale,
  }) async {
    ArgumentError.checkNotNull(rulesPackageArns, 'rulesPackageArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.DescribeRulesPackages'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'rulesPackageArns': rulesPackageArns,
        if (locale != null) 'locale': locale.toValue(),
      },
    );

    return DescribeRulesPackagesResponse.fromJson(jsonResponse.body);
  }

  /// Produces an assessment report that includes detailed and comprehensive
  /// results of a specified assessment run.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [AssessmentRunInProgressException].
  /// May throw [UnsupportedFeatureException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentRunArn] :
  /// The ARN that specifies the assessment run for which you want to generate a
  /// report.
  ///
  /// Parameter [reportFileFormat] :
  /// Specifies the file format (html or pdf) of the assessment report that you
  /// want to generate.
  ///
  /// Parameter [reportType] :
  /// Specifies the type of the assessment report that you want to generate.
  /// There are two types of assessment reports: a finding report and a full
  /// report. For more information, see <a
  /// href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_reports.html">Assessment
  /// Reports</a>.
  Future<GetAssessmentReportResponse> getAssessmentReport({
    required String assessmentRunArn,
    required ReportFileFormat reportFileFormat,
    required ReportType reportType,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArn, 'assessmentRunArn');
    _s.validateStringLength(
      'assessmentRunArn',
      assessmentRunArn,
      1,
      300,
      isRequired: true,
    );
    ArgumentError.checkNotNull(reportFileFormat, 'reportFileFormat');
    ArgumentError.checkNotNull(reportType, 'reportType');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.GetAssessmentReport'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArn': assessmentRunArn,
        'reportFileFormat': reportFileFormat.toValue(),
        'reportType': reportType.toValue(),
      },
    );

    return GetAssessmentReportResponse.fromJson(jsonResponse.body);
  }

  /// Retrieves the exclusions preview (a list of ExclusionPreview objects)
  /// specified by the preview token. You can obtain the preview token by
  /// running the CreateExclusionsPreview API.
  ///
  /// May throw [InvalidInputException].
  /// May throw [InternalException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentTemplateArn] :
  /// The ARN that specifies the assessment template for which the exclusions
  /// preview was requested.
  ///
  /// Parameter [previewToken] :
  /// The unique identifier associated of the exclusions preview.
  ///
  /// Parameter [locale] :
  /// The locale into which you want to translate the exclusion's title,
  /// description, and recommendation.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 100. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the GetExclusionsPreviewRequest
  /// action. Subsequent calls to the action fill nextToken in the request with
  /// the value of nextToken from the previous response to continue listing
  /// data.
  Future<GetExclusionsPreviewResponse> getExclusionsPreview({
    required String assessmentTemplateArn,
    required String previewToken,
    Locale? locale,
    int? maxResults,
    String? nextToken,
  }) async {
    ArgumentError.checkNotNull(assessmentTemplateArn, 'assessmentTemplateArn');
    _s.validateStringLength(
      'assessmentTemplateArn',
      assessmentTemplateArn,
      1,
      300,
      isRequired: true,
    );
    ArgumentError.checkNotNull(previewToken, 'previewToken');
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.GetExclusionsPreview'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTemplateArn': assessmentTemplateArn,
        'previewToken': previewToken,
        if (locale != null) 'locale': locale.toValue(),
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return GetExclusionsPreviewResponse.fromJson(jsonResponse.body);
  }

  /// Information about the data that is collected for the specified assessment
  /// run.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentRunArn] :
  /// The ARN that specifies the assessment run that has the telemetry data that
  /// you want to obtain.
  Future<GetTelemetryMetadataResponse> getTelemetryMetadata({
    required String assessmentRunArn,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArn, 'assessmentRunArn');
    _s.validateStringLength(
      'assessmentRunArn',
      assessmentRunArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.GetTelemetryMetadata'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArn': assessmentRunArn,
      },
    );

    return GetTelemetryMetadataResponse.fromJson(jsonResponse.body);
  }

  /// Lists the agents of the assessment runs that are specified by the ARNs of
  /// the assessment runs.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentRunArn] :
  /// The ARN that specifies the assessment run whose agents you want to list.
  ///
  /// Parameter [filter] :
  /// You can use this parameter to specify a subset of data to be included in
  /// the action's response.
  ///
  /// For a record to match a filter, all specified filter attributes must
  /// match. When multiple values are specified for a filter attribute, any of
  /// the values can match.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items that
  /// you want in the response. The default value is 10. The maximum value is
  /// 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListAssessmentRunAgents</b>
  /// action. Subsequent calls to the action fill <b>nextToken</b> in the
  /// request with the value of <b>NextToken</b> from the previous response to
  /// continue listing data.
  Future<ListAssessmentRunAgentsResponse> listAssessmentRunAgents({
    required String assessmentRunArn,
    AgentFilter? filter,
    int? maxResults,
    String? nextToken,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArn, 'assessmentRunArn');
    _s.validateStringLength(
      'assessmentRunArn',
      assessmentRunArn,
      1,
      300,
      isRequired: true,
    );
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListAssessmentRunAgents'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArn': assessmentRunArn,
        if (filter != null) 'filter': filter,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListAssessmentRunAgentsResponse.fromJson(jsonResponse.body);
  }

  /// Lists the assessment runs that correspond to the assessment templates that
  /// are specified by the ARNs of the assessment templates.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentTemplateArns] :
  /// The ARNs that specify the assessment templates whose assessment runs you
  /// want to list.
  ///
  /// Parameter [filter] :
  /// You can use this parameter to specify a subset of data to be included in
  /// the action's response.
  ///
  /// For a record to match a filter, all specified filter attributes must
  /// match. When multiple values are specified for a filter attribute, any of
  /// the values can match.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items that
  /// you want in the response. The default value is 10. The maximum value is
  /// 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListAssessmentRuns</b>
  /// action. Subsequent calls to the action fill <b>nextToken</b> in the
  /// request with the value of <b>NextToken</b> from the previous response to
  /// continue listing data.
  Future<ListAssessmentRunsResponse> listAssessmentRuns({
    List<String>? assessmentTemplateArns,
    AssessmentRunFilter? filter,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListAssessmentRuns'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (assessmentTemplateArns != null)
          'assessmentTemplateArns': assessmentTemplateArns,
        if (filter != null) 'filter': filter,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListAssessmentRunsResponse.fromJson(jsonResponse.body);
  }

  /// Lists the ARNs of the assessment targets within this AWS account. For more
  /// information about assessment targets, see <a
  /// href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_applications.html">Amazon
  /// Inspector Assessment Targets</a>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [filter] :
  /// You can use this parameter to specify a subset of data to be included in
  /// the action's response.
  ///
  /// For a record to match a filter, all specified filter attributes must
  /// match. When multiple values are specified for a filter attribute, any of
  /// the values can match.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 10. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListAssessmentTargets</b>
  /// action. Subsequent calls to the action fill <b>nextToken</b> in the
  /// request with the value of <b>NextToken</b> from the previous response to
  /// continue listing data.
  Future<ListAssessmentTargetsResponse> listAssessmentTargets({
    AssessmentTargetFilter? filter,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListAssessmentTargets'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (filter != null) 'filter': filter,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListAssessmentTargetsResponse.fromJson(jsonResponse.body);
  }

  /// Lists the assessment templates that correspond to the assessment targets
  /// that are specified by the ARNs of the assessment targets.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentTargetArns] :
  /// A list of ARNs that specifies the assessment targets whose assessment
  /// templates you want to list.
  ///
  /// Parameter [filter] :
  /// You can use this parameter to specify a subset of data to be included in
  /// the action's response.
  ///
  /// For a record to match a filter, all specified filter attributes must
  /// match. When multiple values are specified for a filter attribute, any of
  /// the values can match.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 10. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListAssessmentTemplates</b>
  /// action. Subsequent calls to the action fill <b>nextToken</b> in the
  /// request with the value of <b>NextToken</b> from the previous response to
  /// continue listing data.
  Future<ListAssessmentTemplatesResponse> listAssessmentTemplates({
    List<String>? assessmentTargetArns,
    AssessmentTemplateFilter? filter,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListAssessmentTemplates'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (assessmentTargetArns != null)
          'assessmentTargetArns': assessmentTargetArns,
        if (filter != null) 'filter': filter,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListAssessmentTemplatesResponse.fromJson(jsonResponse.body);
  }

  /// Lists all the event subscriptions for the assessment template that is
  /// specified by the ARN of the assessment template. For more information, see
  /// <a>SubscribeToEvent</a> and <a>UnsubscribeFromEvent</a>.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 10. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListEventSubscriptions</b>
  /// action. Subsequent calls to the action fill <b>nextToken</b> in the
  /// request with the value of <b>NextToken</b> from the previous response to
  /// continue listing data.
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the assessment template for which you want to list the existing
  /// event subscriptions.
  Future<ListEventSubscriptionsResponse> listEventSubscriptions({
    int? maxResults,
    String? nextToken,
    String? resourceArn,
  }) async {
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    _s.validateStringLength(
      'resourceArn',
      resourceArn,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListEventSubscriptions'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
        if (resourceArn != null) 'resourceArn': resourceArn,
      },
    );

    return ListEventSubscriptionsResponse.fromJson(jsonResponse.body);
  }

  /// List exclusions that are generated by the assessment run.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentRunArn] :
  /// The ARN of the assessment run that generated the exclusions that you want
  /// to list.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 100. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the ListExclusionsRequest action.
  /// Subsequent calls to the action fill nextToken in the request with the
  /// value of nextToken from the previous response to continue listing data.
  Future<ListExclusionsResponse> listExclusions({
    required String assessmentRunArn,
    int? maxResults,
    String? nextToken,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArn, 'assessmentRunArn');
    _s.validateStringLength(
      'assessmentRunArn',
      assessmentRunArn,
      1,
      300,
      isRequired: true,
    );
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListExclusions'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArn': assessmentRunArn,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListExclusionsResponse.fromJson(jsonResponse.body);
  }

  /// Lists findings that are generated by the assessment runs that are
  /// specified by the ARNs of the assessment runs.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [assessmentRunArns] :
  /// The ARNs of the assessment runs that generate the findings that you want
  /// to list.
  ///
  /// Parameter [filter] :
  /// You can use this parameter to specify a subset of data to be included in
  /// the action's response.
  ///
  /// For a record to match a filter, all specified filter attributes must
  /// match. When multiple values are specified for a filter attribute, any of
  /// the values can match.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 10. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListFindings</b> action.
  /// Subsequent calls to the action fill <b>nextToken</b> in the request with
  /// the value of <b>NextToken</b> from the previous response to continue
  /// listing data.
  Future<ListFindingsResponse> listFindings({
    List<String>? assessmentRunArns,
    FindingFilter? filter,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListFindings'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (assessmentRunArns != null) 'assessmentRunArns': assessmentRunArns,
        if (filter != null) 'filter': filter,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListFindingsResponse.fromJson(jsonResponse.body);
  }

  /// Lists all available Amazon Inspector rules packages.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 10. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>ListRulesPackages</b>
  /// action. Subsequent calls to the action fill <b>nextToken</b> in the
  /// request with the value of <b>NextToken</b> from the previous response to
  /// continue listing data.
  Future<ListRulesPackagesResponse> listRulesPackages({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListRulesPackages'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return ListRulesPackagesResponse.fromJson(jsonResponse.body);
  }

  /// Lists all tags associated with an assessment template.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  ///
  /// Parameter [resourceArn] :
  /// The ARN that specifies the assessment template whose tags you want to
  /// list.
  Future<ListTagsForResourceResponse> listTagsForResource({
    required String resourceArn,
  }) async {
    ArgumentError.checkNotNull(resourceArn, 'resourceArn');
    _s.validateStringLength(
      'resourceArn',
      resourceArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.ListTagsForResource'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'resourceArn': resourceArn,
      },
    );

    return ListTagsForResourceResponse.fromJson(jsonResponse.body);
  }

  /// Previews the agents installed on the EC2 instances that are part of the
  /// specified assessment target.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [InvalidCrossAccountRoleException].
  ///
  /// Parameter [previewAgentsArn] :
  /// The ARN of the assessment target whose agents you want to preview.
  ///
  /// Parameter [maxResults] :
  /// You can use this parameter to indicate the maximum number of items you
  /// want in the response. The default value is 10. The maximum value is 500.
  ///
  /// Parameter [nextToken] :
  /// You can use this parameter when paginating results. Set the value of this
  /// parameter to null on your first call to the <b>PreviewAgents</b> action.
  /// Subsequent calls to the action fill <b>nextToken</b> in the request with
  /// the value of <b>NextToken</b> from the previous response to continue
  /// listing data.
  Future<PreviewAgentsResponse> previewAgents({
    required String previewAgentsArn,
    int? maxResults,
    String? nextToken,
  }) async {
    ArgumentError.checkNotNull(previewAgentsArn, 'previewAgentsArn');
    _s.validateStringLength(
      'previewAgentsArn',
      previewAgentsArn,
      1,
      300,
      isRequired: true,
    );
    _s.validateStringLength(
      'nextToken',
      nextToken,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.PreviewAgents'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'previewAgentsArn': previewAgentsArn,
        if (maxResults != null) 'maxResults': maxResults,
        if (nextToken != null) 'nextToken': nextToken,
      },
    );

    return PreviewAgentsResponse.fromJson(jsonResponse.body);
  }

  /// Registers the IAM role that grants Amazon Inspector access to AWS Services
  /// needed to perform security assessments.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidCrossAccountRoleException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [roleArn] :
  /// The ARN of the IAM role that grants Amazon Inspector access to AWS
  /// Services needed to perform security assessments.
  Future<void> registerCrossAccountAccessRole({
    required String roleArn,
  }) async {
    ArgumentError.checkNotNull(roleArn, 'roleArn');
    _s.validateStringLength(
      'roleArn',
      roleArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.RegisterCrossAccountAccessRole'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'roleArn': roleArn,
      },
    );
  }

  /// Removes entire attributes (key and value pairs) from the findings that are
  /// specified by the ARNs of the findings where an attribute with the
  /// specified key exists.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [attributeKeys] :
  /// The array of attribute keys that you want to remove from specified
  /// findings.
  ///
  /// Parameter [findingArns] :
  /// The ARNs that specify the findings that you want to remove attributes
  /// from.
  Future<RemoveAttributesFromFindingsResponse> removeAttributesFromFindings({
    required List<String> attributeKeys,
    required List<String> findingArns,
  }) async {
    ArgumentError.checkNotNull(attributeKeys, 'attributeKeys');
    ArgumentError.checkNotNull(findingArns, 'findingArns');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.RemoveAttributesFromFindings'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'attributeKeys': attributeKeys,
        'findingArns': findingArns,
      },
    );

    return RemoveAttributesFromFindingsResponse.fromJson(jsonResponse.body);
  }

  /// Sets tags (key and value pairs) to the assessment template that is
  /// specified by the ARN of the assessment template.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the assessment template that you want to set tags to.
  ///
  /// Parameter [tags] :
  /// A collection of key and value pairs that you want to set to the assessment
  /// template.
  Future<void> setTagsForResource({
    required String resourceArn,
    List<Tag>? tags,
  }) async {
    ArgumentError.checkNotNull(resourceArn, 'resourceArn');
    _s.validateStringLength(
      'resourceArn',
      resourceArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.SetTagsForResource'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'resourceArn': resourceArn,
        if (tags != null) 'tags': tags,
      },
    );
  }

  /// Starts the assessment run specified by the ARN of the assessment template.
  /// For this API to function properly, you must not exceed the limit of
  /// running up to 500 concurrent agents per AWS account.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [InvalidCrossAccountRoleException].
  /// May throw [AgentsAlreadyRunningAssessmentException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTemplateArn] :
  /// The ARN of the assessment template of the assessment run that you want to
  /// start.
  ///
  /// Parameter [assessmentRunName] :
  /// You can specify the name for the assessment run. The name must be unique
  /// for the assessment template whose ARN is used to start the assessment run.
  Future<StartAssessmentRunResponse> startAssessmentRun({
    required String assessmentTemplateArn,
    String? assessmentRunName,
  }) async {
    ArgumentError.checkNotNull(assessmentTemplateArn, 'assessmentTemplateArn');
    _s.validateStringLength(
      'assessmentTemplateArn',
      assessmentTemplateArn,
      1,
      300,
      isRequired: true,
    );
    _s.validateStringLength(
      'assessmentRunName',
      assessmentRunName,
      1,
      140,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.StartAssessmentRun'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTemplateArn': assessmentTemplateArn,
        if (assessmentRunName != null) 'assessmentRunName': assessmentRunName,
      },
    );

    return StartAssessmentRunResponse.fromJson(jsonResponse.body);
  }

  /// Stops the assessment run that is specified by the ARN of the assessment
  /// run.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentRunArn] :
  /// The ARN of the assessment run that you want to stop.
  ///
  /// Parameter [stopAction] :
  /// An input option that can be set to either START_EVALUATION or
  /// SKIP_EVALUATION. START_EVALUATION (the default value), stops the AWS agent
  /// from collecting data and begins the results evaluation and the findings
  /// generation process. SKIP_EVALUATION cancels the assessment run
  /// immediately, after which no findings are generated.
  Future<void> stopAssessmentRun({
    required String assessmentRunArn,
    StopAction? stopAction,
  }) async {
    ArgumentError.checkNotNull(assessmentRunArn, 'assessmentRunArn');
    _s.validateStringLength(
      'assessmentRunArn',
      assessmentRunArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.StopAssessmentRun'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentRunArn': assessmentRunArn,
        if (stopAction != null) 'stopAction': stopAction.toValue(),
      },
    );
  }

  /// Enables the process of sending Amazon Simple Notification Service (SNS)
  /// notifications about a specified event to a specified SNS topic.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [event] :
  /// The event for which you want to receive SNS notifications.
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the assessment template that is used during the event for which
  /// you want to receive SNS notifications.
  ///
  /// Parameter [topicArn] :
  /// The ARN of the SNS topic to which the SNS notifications are sent.
  Future<void> subscribeToEvent({
    required InspectorEvent event,
    required String resourceArn,
    required String topicArn,
  }) async {
    ArgumentError.checkNotNull(event, 'event');
    ArgumentError.checkNotNull(resourceArn, 'resourceArn');
    _s.validateStringLength(
      'resourceArn',
      resourceArn,
      1,
      300,
      isRequired: true,
    );
    ArgumentError.checkNotNull(topicArn, 'topicArn');
    _s.validateStringLength(
      'topicArn',
      topicArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.SubscribeToEvent'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'event': event.toValue(),
        'resourceArn': resourceArn,
        'topicArn': topicArn,
      },
    );
  }

  /// Disables the process of sending Amazon Simple Notification Service (SNS)
  /// notifications about a specified event to a specified SNS topic.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [event] :
  /// The event for which you want to stop receiving SNS notifications.
  ///
  /// Parameter [resourceArn] :
  /// The ARN of the assessment template that is used during the event for which
  /// you want to stop receiving SNS notifications.
  ///
  /// Parameter [topicArn] :
  /// The ARN of the SNS topic to which SNS notifications are sent.
  Future<void> unsubscribeFromEvent({
    required InspectorEvent event,
    required String resourceArn,
    required String topicArn,
  }) async {
    ArgumentError.checkNotNull(event, 'event');
    ArgumentError.checkNotNull(resourceArn, 'resourceArn');
    _s.validateStringLength(
      'resourceArn',
      resourceArn,
      1,
      300,
      isRequired: true,
    );
    ArgumentError.checkNotNull(topicArn, 'topicArn');
    _s.validateStringLength(
      'topicArn',
      topicArn,
      1,
      300,
      isRequired: true,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.UnsubscribeFromEvent'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'event': event.toValue(),
        'resourceArn': resourceArn,
        'topicArn': topicArn,
      },
    );
  }

  /// Updates the assessment target that is specified by the ARN of the
  /// assessment target.
  ///
  /// If resourceGroupArn is not specified, all EC2 instances in the current AWS
  /// account and region are included in the assessment target.
  ///
  /// May throw [InternalException].
  /// May throw [InvalidInputException].
  /// May throw [AccessDeniedException].
  /// May throw [NoSuchEntityException].
  /// May throw [ServiceTemporarilyUnavailableException].
  ///
  /// Parameter [assessmentTargetArn] :
  /// The ARN of the assessment target that you want to update.
  ///
  /// Parameter [assessmentTargetName] :
  /// The name of the assessment target that you want to update.
  ///
  /// Parameter [resourceGroupArn] :
  /// The ARN of the resource group that is used to specify the new resource
  /// group to associate with the assessment target.
  Future<void> updateAssessmentTarget({
    required String assessmentTargetArn,
    required String assessmentTargetName,
    String? resourceGroupArn,
  }) async {
    ArgumentError.checkNotNull(assessmentTargetArn, 'assessmentTargetArn');
    _s.validateStringLength(
      'assessmentTargetArn',
      assessmentTargetArn,
      1,
      300,
      isRequired: true,
    );
    ArgumentError.checkNotNull(assessmentTargetName, 'assessmentTargetName');
    _s.validateStringLength(
      'assessmentTargetName',
      assessmentTargetName,
      1,
      140,
      isRequired: true,
    );
    _s.validateStringLength(
      'resourceGroupArn',
      resourceGroupArn,
      1,
      300,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'InspectorService.UpdateAssessmentTarget'
    };
    await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'assessmentTargetArn': assessmentTargetArn,
        'assessmentTargetName': assessmentTargetName,
        if (resourceGroupArn != null) 'resourceGroupArn': resourceGroupArn,
      },
    );
  }
}

class AddAttributesToFindingsResponse {
  /// Attribute details that cannot be described. An error code is provided for
  /// each failed item.
  final Map<String, FailedItemDetails> failedItems;

  AddAttributesToFindingsResponse({
    required this.failedItems,
  });

  factory AddAttributesToFindingsResponse.fromJson(Map<String, dynamic> json) {
    return AddAttributesToFindingsResponse(
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final failedItems = this.failedItems;
    return {
      'failedItems': failedItems,
    };
  }
}

/// Contains information about an Amazon Inspector agent. This data type is used
/// as a request parameter in the <a>ListAssessmentRunAgents</a> action.
class AgentFilter {
  /// The detailed health state of the agent. Values can be set to <b>IDLE</b>,
  /// <b>RUNNING</b>, <b>SHUTDOWN</b>, <b>UNHEALTHY</b>, <b>THROTTLED</b>, and
  /// <b>UNKNOWN</b>.
  final List<AgentHealthCode> agentHealthCodes;

  /// The current health state of the agent. Values can be set to <b>HEALTHY</b>
  /// or <b>UNHEALTHY</b>.
  final List<AgentHealth> agentHealths;

  AgentFilter({
    required this.agentHealthCodes,
    required this.agentHealths,
  });

  factory AgentFilter.fromJson(Map<String, dynamic> json) {
    return AgentFilter(
      agentHealthCodes: (json['agentHealthCodes'] as List)
          .whereNotNull()
          .map((e) => (e as String).toAgentHealthCode())
          .toList(),
      agentHealths: (json['agentHealths'] as List)
          .whereNotNull()
          .map((e) => (e as String).toAgentHealth())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final agentHealthCodes = this.agentHealthCodes;
    final agentHealths = this.agentHealths;
    return {
      'agentHealthCodes': agentHealthCodes.map((e) => e.toValue()).toList(),
      'agentHealths': agentHealths.map((e) => e.toValue()).toList(),
    };
  }
}

enum AgentHealth {
  healthy,
  unhealthy,
  unknown,
}

extension on AgentHealth {
  String toValue() {
    switch (this) {
      case AgentHealth.healthy:
        return 'HEALTHY';
      case AgentHealth.unhealthy:
        return 'UNHEALTHY';
      case AgentHealth.unknown:
        return 'UNKNOWN';
    }
  }
}

extension on String {
  AgentHealth toAgentHealth() {
    switch (this) {
      case 'HEALTHY':
        return AgentHealth.healthy;
      case 'UNHEALTHY':
        return AgentHealth.unhealthy;
      case 'UNKNOWN':
        return AgentHealth.unknown;
    }
    throw Exception('$this is not known in enum AgentHealth');
  }
}

enum AgentHealthCode {
  idle,
  running,
  shutdown,
  unhealthy,
  throttled,
  unknown,
}

extension on AgentHealthCode {
  String toValue() {
    switch (this) {
      case AgentHealthCode.idle:
        return 'IDLE';
      case AgentHealthCode.running:
        return 'RUNNING';
      case AgentHealthCode.shutdown:
        return 'SHUTDOWN';
      case AgentHealthCode.unhealthy:
        return 'UNHEALTHY';
      case AgentHealthCode.throttled:
        return 'THROTTLED';
      case AgentHealthCode.unknown:
        return 'UNKNOWN';
    }
  }
}

extension on String {
  AgentHealthCode toAgentHealthCode() {
    switch (this) {
      case 'IDLE':
        return AgentHealthCode.idle;
      case 'RUNNING':
        return AgentHealthCode.running;
      case 'SHUTDOWN':
        return AgentHealthCode.shutdown;
      case 'UNHEALTHY':
        return AgentHealthCode.unhealthy;
      case 'THROTTLED':
        return AgentHealthCode.throttled;
      case 'UNKNOWN':
        return AgentHealthCode.unknown;
    }
    throw Exception('$this is not known in enum AgentHealthCode');
  }
}

/// Used as a response element in the <a>PreviewAgents</a> action.
class AgentPreview {
  /// The ID of the EC2 instance where the agent is installed.
  final String agentId;

  /// The health status of the Amazon Inspector Agent.
  final AgentHealth? agentHealth;

  /// The version of the Amazon Inspector Agent.
  final String? agentVersion;

  /// The Auto Scaling group for the EC2 instance where the agent is installed.
  final String? autoScalingGroup;

  /// The hostname of the EC2 instance on which the Amazon Inspector Agent is
  /// installed.
  final String? hostname;

  /// The IP address of the EC2 instance on which the Amazon Inspector Agent is
  /// installed.
  final String? ipv4Address;

  /// The kernel version of the operating system running on the EC2 instance on
  /// which the Amazon Inspector Agent is installed.
  final String? kernelVersion;

  /// The operating system running on the EC2 instance on which the Amazon
  /// Inspector Agent is installed.
  final String? operatingSystem;

  AgentPreview({
    required this.agentId,
    this.agentHealth,
    this.agentVersion,
    this.autoScalingGroup,
    this.hostname,
    this.ipv4Address,
    this.kernelVersion,
    this.operatingSystem,
  });

  factory AgentPreview.fromJson(Map<String, dynamic> json) {
    return AgentPreview(
      agentId: json['agentId'] as String,
      agentHealth: (json['agentHealth'] as String?)?.toAgentHealth(),
      agentVersion: json['agentVersion'] as String?,
      autoScalingGroup: json['autoScalingGroup'] as String?,
      hostname: json['hostname'] as String?,
      ipv4Address: json['ipv4Address'] as String?,
      kernelVersion: json['kernelVersion'] as String?,
      operatingSystem: json['operatingSystem'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final agentId = this.agentId;
    final agentHealth = this.agentHealth;
    final agentVersion = this.agentVersion;
    final autoScalingGroup = this.autoScalingGroup;
    final hostname = this.hostname;
    final ipv4Address = this.ipv4Address;
    final kernelVersion = this.kernelVersion;
    final operatingSystem = this.operatingSystem;
    return {
      'agentId': agentId,
      if (agentHealth != null) 'agentHealth': agentHealth.toValue(),
      if (agentVersion != null) 'agentVersion': agentVersion,
      if (autoScalingGroup != null) 'autoScalingGroup': autoScalingGroup,
      if (hostname != null) 'hostname': hostname,
      if (ipv4Address != null) 'ipv4Address': ipv4Address,
      if (kernelVersion != null) 'kernelVersion': kernelVersion,
      if (operatingSystem != null) 'operatingSystem': operatingSystem,
    };
  }
}

/// A snapshot of an Amazon Inspector assessment run that contains the findings
/// of the assessment run .
///
/// Used as the response element in the <a>DescribeAssessmentRuns</a> action.
class AssessmentRun {
  /// The ARN of the assessment run.
  final String arn;

  /// The ARN of the assessment template that is associated with the assessment
  /// run.
  final String assessmentTemplateArn;

  /// The time when <a>StartAssessmentRun</a> was called.
  final DateTime createdAt;

  /// A Boolean value (true or false) that specifies whether the process of
  /// collecting data from the agents is completed.
  final bool dataCollected;

  /// The duration of the assessment run.
  final int durationInSeconds;

  /// Provides a total count of generated findings per severity.
  final Map<Severity, int> findingCounts;

  /// The auto-generated name for the assessment run.
  final String name;

  /// A list of notifications for the event subscriptions. A notification about a
  /// particular generated finding is added to this list only once.
  final List<AssessmentRunNotification> notifications;

  /// The rules packages selected for the assessment run.
  final List<String> rulesPackageArns;

  /// The state of the assessment run.
  final AssessmentRunState state;

  /// The last time when the assessment run's state changed.
  final DateTime stateChangedAt;

  /// A list of the assessment run state changes.
  final List<AssessmentRunStateChange> stateChanges;

  /// The user-defined attributes that are assigned to every generated finding.
  final List<Attribute> userAttributesForFindings;

  /// The assessment run completion time that corresponds to the rules packages
  /// evaluation completion time or failure.
  final DateTime? completedAt;

  /// The time when <a>StartAssessmentRun</a> was called.
  final DateTime? startedAt;

  AssessmentRun({
    required this.arn,
    required this.assessmentTemplateArn,
    required this.createdAt,
    required this.dataCollected,
    required this.durationInSeconds,
    required this.findingCounts,
    required this.name,
    required this.notifications,
    required this.rulesPackageArns,
    required this.state,
    required this.stateChangedAt,
    required this.stateChanges,
    required this.userAttributesForFindings,
    this.completedAt,
    this.startedAt,
  });

  factory AssessmentRun.fromJson(Map<String, dynamic> json) {
    return AssessmentRun(
      arn: json['arn'] as String,
      assessmentTemplateArn: json['assessmentTemplateArn'] as String,
      createdAt: nonNullableTimeStampFromJson(json['createdAt'] as Object),
      dataCollected: json['dataCollected'] as bool,
      durationInSeconds: json['durationInSeconds'] as int,
      findingCounts: (json['findingCounts'] as Map<String, dynamic>)
          .map((k, e) => MapEntry(k.toSeverity(), e as int)),
      name: json['name'] as String,
      notifications: (json['notifications'] as List)
          .whereNotNull()
          .map((e) =>
              AssessmentRunNotification.fromJson(e as Map<String, dynamic>))
          .toList(),
      rulesPackageArns: (json['rulesPackageArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      state: (json['state'] as String).toAssessmentRunState(),
      stateChangedAt:
          nonNullableTimeStampFromJson(json['stateChangedAt'] as Object),
      stateChanges: (json['stateChanges'] as List)
          .whereNotNull()
          .map((e) =>
              AssessmentRunStateChange.fromJson(e as Map<String, dynamic>))
          .toList(),
      userAttributesForFindings: (json['userAttributesForFindings'] as List)
          .whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      completedAt: timeStampFromJson(json['completedAt']),
      startedAt: timeStampFromJson(json['startedAt']),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assessmentTemplateArn = this.assessmentTemplateArn;
    final createdAt = this.createdAt;
    final dataCollected = this.dataCollected;
    final durationInSeconds = this.durationInSeconds;
    final findingCounts = this.findingCounts;
    final name = this.name;
    final notifications = this.notifications;
    final rulesPackageArns = this.rulesPackageArns;
    final state = this.state;
    final stateChangedAt = this.stateChangedAt;
    final stateChanges = this.stateChanges;
    final userAttributesForFindings = this.userAttributesForFindings;
    final completedAt = this.completedAt;
    final startedAt = this.startedAt;
    return {
      'arn': arn,
      'assessmentTemplateArn': assessmentTemplateArn,
      'createdAt': unixTimestampToJson(createdAt),
      'dataCollected': dataCollected,
      'durationInSeconds': durationInSeconds,
      'findingCounts': findingCounts.map((k, e) => MapEntry(k.toValue(), e)),
      'name': name,
      'notifications': notifications,
      'rulesPackageArns': rulesPackageArns,
      'state': state.toValue(),
      'stateChangedAt': unixTimestampToJson(stateChangedAt),
      'stateChanges': stateChanges,
      'userAttributesForFindings': userAttributesForFindings,
      if (completedAt != null) 'completedAt': unixTimestampToJson(completedAt),
      if (startedAt != null) 'startedAt': unixTimestampToJson(startedAt),
    };
  }
}

/// Contains information about an Amazon Inspector agent. This data type is used
/// as a response element in the <a>ListAssessmentRunAgents</a> action.
class AssessmentRunAgent {
  /// The current health state of the agent.
  final AgentHealth agentHealth;

  /// The detailed health state of the agent.
  final AgentHealthCode agentHealthCode;

  /// The AWS account of the EC2 instance where the agent is installed.
  final String agentId;

  /// The ARN of the assessment run that is associated with the agent.
  final String assessmentRunArn;

  /// The Amazon Inspector application data metrics that are collected by the
  /// agent.
  final List<TelemetryMetadata> telemetryMetadata;

  /// The description for the agent health code.
  final String? agentHealthDetails;

  /// The Auto Scaling group of the EC2 instance that is specified by the agent
  /// ID.
  final String? autoScalingGroup;

  AssessmentRunAgent({
    required this.agentHealth,
    required this.agentHealthCode,
    required this.agentId,
    required this.assessmentRunArn,
    required this.telemetryMetadata,
    this.agentHealthDetails,
    this.autoScalingGroup,
  });

  factory AssessmentRunAgent.fromJson(Map<String, dynamic> json) {
    return AssessmentRunAgent(
      agentHealth: (json['agentHealth'] as String).toAgentHealth(),
      agentHealthCode: (json['agentHealthCode'] as String).toAgentHealthCode(),
      agentId: json['agentId'] as String,
      assessmentRunArn: json['assessmentRunArn'] as String,
      telemetryMetadata: (json['telemetryMetadata'] as List)
          .whereNotNull()
          .map((e) => TelemetryMetadata.fromJson(e as Map<String, dynamic>))
          .toList(),
      agentHealthDetails: json['agentHealthDetails'] as String?,
      autoScalingGroup: json['autoScalingGroup'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final agentHealth = this.agentHealth;
    final agentHealthCode = this.agentHealthCode;
    final agentId = this.agentId;
    final assessmentRunArn = this.assessmentRunArn;
    final telemetryMetadata = this.telemetryMetadata;
    final agentHealthDetails = this.agentHealthDetails;
    final autoScalingGroup = this.autoScalingGroup;
    return {
      'agentHealth': agentHealth.toValue(),
      'agentHealthCode': agentHealthCode.toValue(),
      'agentId': agentId,
      'assessmentRunArn': assessmentRunArn,
      'telemetryMetadata': telemetryMetadata,
      if (agentHealthDetails != null) 'agentHealthDetails': agentHealthDetails,
      if (autoScalingGroup != null) 'autoScalingGroup': autoScalingGroup,
    };
  }
}

/// Used as the request parameter in the <a>ListAssessmentRuns</a> action.
class AssessmentRunFilter {
  /// For a record to match a filter, the value that is specified for this data
  /// type property must inclusively match any value between the specified minimum
  /// and maximum values of the <b>completedAt</b> property of the
  /// <a>AssessmentRun</a> data type.
  final TimestampRange? completionTimeRange;

  /// For a record to match a filter, the value that is specified for this data
  /// type property must inclusively match any value between the specified minimum
  /// and maximum values of the <b>durationInSeconds</b> property of the
  /// <a>AssessmentRun</a> data type.
  final DurationRange? durationRange;

  /// For a record to match a filter, an explicit value or a string containing a
  /// wildcard that is specified for this data type property must match the value
  /// of the <b>assessmentRunName</b> property of the <a>AssessmentRun</a> data
  /// type.
  final String? namePattern;

  /// For a record to match a filter, the value that is specified for this data
  /// type property must be contained in the list of values of the
  /// <b>rulesPackages</b> property of the <a>AssessmentRun</a> data type.
  final List<String>? rulesPackageArns;

  /// For a record to match a filter, the value that is specified for this data
  /// type property must inclusively match any value between the specified minimum
  /// and maximum values of the <b>startTime</b> property of the
  /// <a>AssessmentRun</a> data type.
  final TimestampRange? startTimeRange;

  /// For a record to match a filter, the value that is specified for this data
  /// type property must match the <b>stateChangedAt</b> property of the
  /// <a>AssessmentRun</a> data type.
  final TimestampRange? stateChangeTimeRange;

  /// For a record to match a filter, one of the values specified for this data
  /// type property must be the exact match of the value of the
  /// <b>assessmentRunState</b> property of the <a>AssessmentRun</a> data type.
  final List<AssessmentRunState>? states;

  AssessmentRunFilter({
    this.completionTimeRange,
    this.durationRange,
    this.namePattern,
    this.rulesPackageArns,
    this.startTimeRange,
    this.stateChangeTimeRange,
    this.states,
  });

  factory AssessmentRunFilter.fromJson(Map<String, dynamic> json) {
    return AssessmentRunFilter(
      completionTimeRange: json['completionTimeRange'] != null
          ? TimestampRange.fromJson(
              json['completionTimeRange'] as Map<String, dynamic>)
          : null,
      durationRange: json['durationRange'] != null
          ? DurationRange.fromJson(
              json['durationRange'] as Map<String, dynamic>)
          : null,
      namePattern: json['namePattern'] as String?,
      rulesPackageArns: (json['rulesPackageArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      startTimeRange: json['startTimeRange'] != null
          ? TimestampRange.fromJson(
              json['startTimeRange'] as Map<String, dynamic>)
          : null,
      stateChangeTimeRange: json['stateChangeTimeRange'] != null
          ? TimestampRange.fromJson(
              json['stateChangeTimeRange'] as Map<String, dynamic>)
          : null,
      states: (json['states'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toAssessmentRunState())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final completionTimeRange = this.completionTimeRange;
    final durationRange = this.durationRange;
    final namePattern = this.namePattern;
    final rulesPackageArns = this.rulesPackageArns;
    final startTimeRange = this.startTimeRange;
    final stateChangeTimeRange = this.stateChangeTimeRange;
    final states = this.states;
    return {
      if (completionTimeRange != null)
        'completionTimeRange': completionTimeRange,
      if (durationRange != null) 'durationRange': durationRange,
      if (namePattern != null) 'namePattern': namePattern,
      if (rulesPackageArns != null) 'rulesPackageArns': rulesPackageArns,
      if (startTimeRange != null) 'startTimeRange': startTimeRange,
      if (stateChangeTimeRange != null)
        'stateChangeTimeRange': stateChangeTimeRange,
      if (states != null) 'states': states.map((e) => e.toValue()).toList(),
    };
  }
}

/// Used as one of the elements of the <a>AssessmentRun</a> data type.
class AssessmentRunNotification {
  /// The date of the notification.
  final DateTime date;

  /// The Boolean value that specifies whether the notification represents an
  /// error.
  final bool error;

  /// The event for which a notification is sent.
  final InspectorEvent event;

  /// The message included in the notification.
  final String? message;

  /// The status code of the SNS notification.
  final AssessmentRunNotificationSnsStatusCode? snsPublishStatusCode;

  /// The SNS topic to which the SNS notification is sent.
  final String? snsTopicArn;

  AssessmentRunNotification({
    required this.date,
    required this.error,
    required this.event,
    this.message,
    this.snsPublishStatusCode,
    this.snsTopicArn,
  });

  factory AssessmentRunNotification.fromJson(Map<String, dynamic> json) {
    return AssessmentRunNotification(
      date: nonNullableTimeStampFromJson(json['date'] as Object),
      error: json['error'] as bool,
      event: (json['event'] as String).toInspectorEvent(),
      message: json['message'] as String?,
      snsPublishStatusCode: (json['snsPublishStatusCode'] as String?)
          ?.toAssessmentRunNotificationSnsStatusCode(),
      snsTopicArn: json['snsTopicArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final date = this.date;
    final error = this.error;
    final event = this.event;
    final message = this.message;
    final snsPublishStatusCode = this.snsPublishStatusCode;
    final snsTopicArn = this.snsTopicArn;
    return {
      'date': unixTimestampToJson(date),
      'error': error,
      'event': event.toValue(),
      if (message != null) 'message': message,
      if (snsPublishStatusCode != null)
        'snsPublishStatusCode': snsPublishStatusCode.toValue(),
      if (snsTopicArn != null) 'snsTopicArn': snsTopicArn,
    };
  }
}

enum AssessmentRunNotificationSnsStatusCode {
  success,
  topicDoesNotExist,
  accessDenied,
  internalError,
}

extension on AssessmentRunNotificationSnsStatusCode {
  String toValue() {
    switch (this) {
      case AssessmentRunNotificationSnsStatusCode.success:
        return 'SUCCESS';
      case AssessmentRunNotificationSnsStatusCode.topicDoesNotExist:
        return 'TOPIC_DOES_NOT_EXIST';
      case AssessmentRunNotificationSnsStatusCode.accessDenied:
        return 'ACCESS_DENIED';
      case AssessmentRunNotificationSnsStatusCode.internalError:
        return 'INTERNAL_ERROR';
    }
  }
}

extension on String {
  AssessmentRunNotificationSnsStatusCode
      toAssessmentRunNotificationSnsStatusCode() {
    switch (this) {
      case 'SUCCESS':
        return AssessmentRunNotificationSnsStatusCode.success;
      case 'TOPIC_DOES_NOT_EXIST':
        return AssessmentRunNotificationSnsStatusCode.topicDoesNotExist;
      case 'ACCESS_DENIED':
        return AssessmentRunNotificationSnsStatusCode.accessDenied;
      case 'INTERNAL_ERROR':
        return AssessmentRunNotificationSnsStatusCode.internalError;
    }
    throw Exception(
        '$this is not known in enum AssessmentRunNotificationSnsStatusCode');
  }
}

enum AssessmentRunState {
  created,
  startDataCollectionPending,
  startDataCollectionInProgress,
  collectingData,
  stopDataCollectionPending,
  dataCollected,
  startEvaluatingRulesPending,
  evaluatingRules,
  failed,
  error,
  completed,
  completedWithErrors,
  canceled,
}

extension on AssessmentRunState {
  String toValue() {
    switch (this) {
      case AssessmentRunState.created:
        return 'CREATED';
      case AssessmentRunState.startDataCollectionPending:
        return 'START_DATA_COLLECTION_PENDING';
      case AssessmentRunState.startDataCollectionInProgress:
        return 'START_DATA_COLLECTION_IN_PROGRESS';
      case AssessmentRunState.collectingData:
        return 'COLLECTING_DATA';
      case AssessmentRunState.stopDataCollectionPending:
        return 'STOP_DATA_COLLECTION_PENDING';
      case AssessmentRunState.dataCollected:
        return 'DATA_COLLECTED';
      case AssessmentRunState.startEvaluatingRulesPending:
        return 'START_EVALUATING_RULES_PENDING';
      case AssessmentRunState.evaluatingRules:
        return 'EVALUATING_RULES';
      case AssessmentRunState.failed:
        return 'FAILED';
      case AssessmentRunState.error:
        return 'ERROR';
      case AssessmentRunState.completed:
        return 'COMPLETED';
      case AssessmentRunState.completedWithErrors:
        return 'COMPLETED_WITH_ERRORS';
      case AssessmentRunState.canceled:
        return 'CANCELED';
    }
  }
}

extension on String {
  AssessmentRunState toAssessmentRunState() {
    switch (this) {
      case 'CREATED':
        return AssessmentRunState.created;
      case 'START_DATA_COLLECTION_PENDING':
        return AssessmentRunState.startDataCollectionPending;
      case 'START_DATA_COLLECTION_IN_PROGRESS':
        return AssessmentRunState.startDataCollectionInProgress;
      case 'COLLECTING_DATA':
        return AssessmentRunState.collectingData;
      case 'STOP_DATA_COLLECTION_PENDING':
        return AssessmentRunState.stopDataCollectionPending;
      case 'DATA_COLLECTED':
        return AssessmentRunState.dataCollected;
      case 'START_EVALUATING_RULES_PENDING':
        return AssessmentRunState.startEvaluatingRulesPending;
      case 'EVALUATING_RULES':
        return AssessmentRunState.evaluatingRules;
      case 'FAILED':
        return AssessmentRunState.failed;
      case 'ERROR':
        return AssessmentRunState.error;
      case 'COMPLETED':
        return AssessmentRunState.completed;
      case 'COMPLETED_WITH_ERRORS':
        return AssessmentRunState.completedWithErrors;
      case 'CANCELED':
        return AssessmentRunState.canceled;
    }
    throw Exception('$this is not known in enum AssessmentRunState');
  }
}

/// Used as one of the elements of the <a>AssessmentRun</a> data type.
class AssessmentRunStateChange {
  /// The assessment run state.
  final AssessmentRunState state;

  /// The last time the assessment run state changed.
  final DateTime stateChangedAt;

  AssessmentRunStateChange({
    required this.state,
    required this.stateChangedAt,
  });

  factory AssessmentRunStateChange.fromJson(Map<String, dynamic> json) {
    return AssessmentRunStateChange(
      state: (json['state'] as String).toAssessmentRunState(),
      stateChangedAt:
          nonNullableTimeStampFromJson(json['stateChangedAt'] as Object),
    );
  }

  Map<String, dynamic> toJson() {
    final state = this.state;
    final stateChangedAt = this.stateChangedAt;
    return {
      'state': state.toValue(),
      'stateChangedAt': unixTimestampToJson(stateChangedAt),
    };
  }
}

/// Contains information about an Amazon Inspector application. This data type
/// is used as the response element in the <a>DescribeAssessmentTargets</a>
/// action.
class AssessmentTarget {
  /// The ARN that specifies the Amazon Inspector assessment target.
  final String arn;

  /// The time at which the assessment target is created.
  final DateTime createdAt;

  /// The name of the Amazon Inspector assessment target.
  final String name;

  /// The time at which <a>UpdateAssessmentTarget</a> is called.
  final DateTime updatedAt;

  /// The ARN that specifies the resource group that is associated with the
  /// assessment target.
  final String? resourceGroupArn;

  AssessmentTarget({
    required this.arn,
    required this.createdAt,
    required this.name,
    required this.updatedAt,
    this.resourceGroupArn,
  });

  factory AssessmentTarget.fromJson(Map<String, dynamic> json) {
    return AssessmentTarget(
      arn: json['arn'] as String,
      createdAt: nonNullableTimeStampFromJson(json['createdAt'] as Object),
      name: json['name'] as String,
      updatedAt: nonNullableTimeStampFromJson(json['updatedAt'] as Object),
      resourceGroupArn: json['resourceGroupArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdAt = this.createdAt;
    final name = this.name;
    final updatedAt = this.updatedAt;
    final resourceGroupArn = this.resourceGroupArn;
    return {
      'arn': arn,
      'createdAt': unixTimestampToJson(createdAt),
      'name': name,
      'updatedAt': unixTimestampToJson(updatedAt),
      if (resourceGroupArn != null) 'resourceGroupArn': resourceGroupArn,
    };
  }
}

/// Used as the request parameter in the <a>ListAssessmentTargets</a> action.
class AssessmentTargetFilter {
  /// For a record to match a filter, an explicit value or a string that contains
  /// a wildcard that is specified for this data type property must match the
  /// value of the <b>assessmentTargetName</b> property of the
  /// <a>AssessmentTarget</a> data type.
  final String? assessmentTargetNamePattern;

  AssessmentTargetFilter({
    this.assessmentTargetNamePattern,
  });

  factory AssessmentTargetFilter.fromJson(Map<String, dynamic> json) {
    return AssessmentTargetFilter(
      assessmentTargetNamePattern:
          json['assessmentTargetNamePattern'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTargetNamePattern = this.assessmentTargetNamePattern;
    return {
      if (assessmentTargetNamePattern != null)
        'assessmentTargetNamePattern': assessmentTargetNamePattern,
    };
  }
}

/// Contains information about an Amazon Inspector assessment template. This
/// data type is used as the response element in the
/// <a>DescribeAssessmentTemplates</a> action.
class AssessmentTemplate {
  /// The ARN of the assessment template.
  final String arn;

  /// The number of existing assessment runs associated with this assessment
  /// template. This value can be zero or a positive integer.
  final int assessmentRunCount;

  /// The ARN of the assessment target that corresponds to this assessment
  /// template.
  final String assessmentTargetArn;

  /// The time at which the assessment template is created.
  final DateTime createdAt;

  /// The duration in seconds specified for this assessment template. The default
  /// value is 3600 seconds (one hour). The maximum value is 86400 seconds (one
  /// day).
  final int durationInSeconds;

  /// The name of the assessment template.
  final String name;

  /// The rules packages that are specified for this assessment template.
  final List<String> rulesPackageArns;

  /// The user-defined attributes that are assigned to every generated finding
  /// from the assessment run that uses this assessment template.
  final List<Attribute> userAttributesForFindings;

  /// The Amazon Resource Name (ARN) of the most recent assessment run associated
  /// with this assessment template. This value exists only when the value of
  /// assessmentRunCount is greaterpa than zero.
  final String? lastAssessmentRunArn;

  AssessmentTemplate({
    required this.arn,
    required this.assessmentRunCount,
    required this.assessmentTargetArn,
    required this.createdAt,
    required this.durationInSeconds,
    required this.name,
    required this.rulesPackageArns,
    required this.userAttributesForFindings,
    this.lastAssessmentRunArn,
  });

  factory AssessmentTemplate.fromJson(Map<String, dynamic> json) {
    return AssessmentTemplate(
      arn: json['arn'] as String,
      assessmentRunCount: json['assessmentRunCount'] as int,
      assessmentTargetArn: json['assessmentTargetArn'] as String,
      createdAt: nonNullableTimeStampFromJson(json['createdAt'] as Object),
      durationInSeconds: json['durationInSeconds'] as int,
      name: json['name'] as String,
      rulesPackageArns: (json['rulesPackageArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      userAttributesForFindings: (json['userAttributesForFindings'] as List)
          .whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      lastAssessmentRunArn: json['lastAssessmentRunArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assessmentRunCount = this.assessmentRunCount;
    final assessmentTargetArn = this.assessmentTargetArn;
    final createdAt = this.createdAt;
    final durationInSeconds = this.durationInSeconds;
    final name = this.name;
    final rulesPackageArns = this.rulesPackageArns;
    final userAttributesForFindings = this.userAttributesForFindings;
    final lastAssessmentRunArn = this.lastAssessmentRunArn;
    return {
      'arn': arn,
      'assessmentRunCount': assessmentRunCount,
      'assessmentTargetArn': assessmentTargetArn,
      'createdAt': unixTimestampToJson(createdAt),
      'durationInSeconds': durationInSeconds,
      'name': name,
      'rulesPackageArns': rulesPackageArns,
      'userAttributesForFindings': userAttributesForFindings,
      if (lastAssessmentRunArn != null)
        'lastAssessmentRunArn': lastAssessmentRunArn,
    };
  }
}

/// Used as the request parameter in the <a>ListAssessmentTemplates</a> action.
class AssessmentTemplateFilter {
  /// For a record to match a filter, the value specified for this data type
  /// property must inclusively match any value between the specified minimum and
  /// maximum values of the <b>durationInSeconds</b> property of the
  /// <a>AssessmentTemplate</a> data type.
  final DurationRange? durationRange;

  /// For a record to match a filter, an explicit value or a string that contains
  /// a wildcard that is specified for this data type property must match the
  /// value of the <b>assessmentTemplateName</b> property of the
  /// <a>AssessmentTemplate</a> data type.
  final String? namePattern;

  /// For a record to match a filter, the values that are specified for this data
  /// type property must be contained in the list of values of the
  /// <b>rulesPackageArns</b> property of the <a>AssessmentTemplate</a> data type.
  final List<String>? rulesPackageArns;

  AssessmentTemplateFilter({
    this.durationRange,
    this.namePattern,
    this.rulesPackageArns,
  });

  factory AssessmentTemplateFilter.fromJson(Map<String, dynamic> json) {
    return AssessmentTemplateFilter(
      durationRange: json['durationRange'] != null
          ? DurationRange.fromJson(
              json['durationRange'] as Map<String, dynamic>)
          : null,
      namePattern: json['namePattern'] as String?,
      rulesPackageArns: (json['rulesPackageArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final durationRange = this.durationRange;
    final namePattern = this.namePattern;
    final rulesPackageArns = this.rulesPackageArns;
    return {
      if (durationRange != null) 'durationRange': durationRange,
      if (namePattern != null) 'namePattern': namePattern,
      if (rulesPackageArns != null) 'rulesPackageArns': rulesPackageArns,
    };
  }
}

/// A collection of attributes of the host from which the finding is generated.
class AssetAttributes {
  /// The schema version of this data type.
  final int schemaVersion;

  /// The ID of the agent that is installed on the EC2 instance where the finding
  /// is generated.
  final String? agentId;

  /// The ID of the Amazon Machine Image (AMI) that is installed on the EC2
  /// instance where the finding is generated.
  final String? amiId;

  /// The Auto Scaling group of the EC2 instance where the finding is generated.
  final String? autoScalingGroup;

  /// The hostname of the EC2 instance where the finding is generated.
  final String? hostname;

  /// The list of IP v4 addresses of the EC2 instance where the finding is
  /// generated.
  final List<String>? ipv4Addresses;

  /// An array of the network interfaces interacting with the EC2 instance where
  /// the finding is generated.
  final List<NetworkInterface>? networkInterfaces;

  /// The tags related to the EC2 instance where the finding is generated.
  final List<Tag>? tags;

  AssetAttributes({
    required this.schemaVersion,
    this.agentId,
    this.amiId,
    this.autoScalingGroup,
    this.hostname,
    this.ipv4Addresses,
    this.networkInterfaces,
    this.tags,
  });

  factory AssetAttributes.fromJson(Map<String, dynamic> json) {
    return AssetAttributes(
      schemaVersion: json['schemaVersion'] as int,
      agentId: json['agentId'] as String?,
      amiId: json['amiId'] as String?,
      autoScalingGroup: json['autoScalingGroup'] as String?,
      hostname: json['hostname'] as String?,
      ipv4Addresses: (json['ipv4Addresses'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      networkInterfaces: (json['networkInterfaces'] as List?)
          ?.whereNotNull()
          .map((e) => NetworkInterface.fromJson(e as Map<String, dynamic>))
          .toList(),
      tags: (json['tags'] as List?)
          ?.whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final schemaVersion = this.schemaVersion;
    final agentId = this.agentId;
    final amiId = this.amiId;
    final autoScalingGroup = this.autoScalingGroup;
    final hostname = this.hostname;
    final ipv4Addresses = this.ipv4Addresses;
    final networkInterfaces = this.networkInterfaces;
    final tags = this.tags;
    return {
      'schemaVersion': schemaVersion,
      if (agentId != null) 'agentId': agentId,
      if (amiId != null) 'amiId': amiId,
      if (autoScalingGroup != null) 'autoScalingGroup': autoScalingGroup,
      if (hostname != null) 'hostname': hostname,
      if (ipv4Addresses != null) 'ipv4Addresses': ipv4Addresses,
      if (networkInterfaces != null) 'networkInterfaces': networkInterfaces,
      if (tags != null) 'tags': tags,
    };
  }
}

enum AssetType {
  ec2Instance,
}

extension on AssetType {
  String toValue() {
    switch (this) {
      case AssetType.ec2Instance:
        return 'ec2-instance';
    }
  }
}

extension on String {
  AssetType toAssetType() {
    switch (this) {
      case 'ec2-instance':
        return AssetType.ec2Instance;
    }
    throw Exception('$this is not known in enum AssetType');
  }
}

/// This data type is used as a request parameter in the
/// <a>AddAttributesToFindings</a> and <a>CreateAssessmentTemplate</a> actions.
class Attribute {
  /// The attribute key.
  final String key;

  /// The value assigned to the attribute key.
  final String? value;

  Attribute({
    required this.key,
    this.value,
  });

  factory Attribute.fromJson(Map<String, dynamic> json) {
    return Attribute(
      key: json['key'] as String,
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      'key': key,
      if (value != null) 'value': value,
    };
  }
}

class CreateAssessmentTargetResponse {
  /// The ARN that specifies the assessment target that is created.
  final String assessmentTargetArn;

  CreateAssessmentTargetResponse({
    required this.assessmentTargetArn,
  });

  factory CreateAssessmentTargetResponse.fromJson(Map<String, dynamic> json) {
    return CreateAssessmentTargetResponse(
      assessmentTargetArn: json['assessmentTargetArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTargetArn = this.assessmentTargetArn;
    return {
      'assessmentTargetArn': assessmentTargetArn,
    };
  }
}

class CreateAssessmentTemplateResponse {
  /// The ARN that specifies the assessment template that is created.
  final String assessmentTemplateArn;

  CreateAssessmentTemplateResponse({
    required this.assessmentTemplateArn,
  });

  factory CreateAssessmentTemplateResponse.fromJson(Map<String, dynamic> json) {
    return CreateAssessmentTemplateResponse(
      assessmentTemplateArn: json['assessmentTemplateArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTemplateArn = this.assessmentTemplateArn;
    return {
      'assessmentTemplateArn': assessmentTemplateArn,
    };
  }
}

class CreateExclusionsPreviewResponse {
  /// Specifies the unique identifier of the requested exclusions preview. You can
  /// use the unique identifier to retrieve the exclusions preview when running
  /// the GetExclusionsPreview API.
  final String previewToken;

  CreateExclusionsPreviewResponse({
    required this.previewToken,
  });

  factory CreateExclusionsPreviewResponse.fromJson(Map<String, dynamic> json) {
    return CreateExclusionsPreviewResponse(
      previewToken: json['previewToken'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final previewToken = this.previewToken;
    return {
      'previewToken': previewToken,
    };
  }
}

class CreateResourceGroupResponse {
  /// The ARN that specifies the resource group that is created.
  final String resourceGroupArn;

  CreateResourceGroupResponse({
    required this.resourceGroupArn,
  });

  factory CreateResourceGroupResponse.fromJson(Map<String, dynamic> json) {
    return CreateResourceGroupResponse(
      resourceGroupArn: json['resourceGroupArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final resourceGroupArn = this.resourceGroupArn;
    return {
      'resourceGroupArn': resourceGroupArn,
    };
  }
}

class DescribeAssessmentRunsResponse {
  /// Information about the assessment run.
  final List<AssessmentRun> assessmentRuns;

  /// Assessment run details that cannot be described. An error code is provided
  /// for each failed item.
  final Map<String, FailedItemDetails> failedItems;

  DescribeAssessmentRunsResponse({
    required this.assessmentRuns,
    required this.failedItems,
  });

  factory DescribeAssessmentRunsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeAssessmentRunsResponse(
      assessmentRuns: (json['assessmentRuns'] as List)
          .whereNotNull()
          .map((e) => AssessmentRun.fromJson(e as Map<String, dynamic>))
          .toList(),
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentRuns = this.assessmentRuns;
    final failedItems = this.failedItems;
    return {
      'assessmentRuns': assessmentRuns,
      'failedItems': failedItems,
    };
  }
}

class DescribeAssessmentTargetsResponse {
  /// Information about the assessment targets.
  final List<AssessmentTarget> assessmentTargets;

  /// Assessment target details that cannot be described. An error code is
  /// provided for each failed item.
  final Map<String, FailedItemDetails> failedItems;

  DescribeAssessmentTargetsResponse({
    required this.assessmentTargets,
    required this.failedItems,
  });

  factory DescribeAssessmentTargetsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAssessmentTargetsResponse(
      assessmentTargets: (json['assessmentTargets'] as List)
          .whereNotNull()
          .map((e) => AssessmentTarget.fromJson(e as Map<String, dynamic>))
          .toList(),
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTargets = this.assessmentTargets;
    final failedItems = this.failedItems;
    return {
      'assessmentTargets': assessmentTargets,
      'failedItems': failedItems,
    };
  }
}

class DescribeAssessmentTemplatesResponse {
  /// Information about the assessment templates.
  final List<AssessmentTemplate> assessmentTemplates;

  /// Assessment template details that cannot be described. An error code is
  /// provided for each failed item.
  final Map<String, FailedItemDetails> failedItems;

  DescribeAssessmentTemplatesResponse({
    required this.assessmentTemplates,
    required this.failedItems,
  });

  factory DescribeAssessmentTemplatesResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAssessmentTemplatesResponse(
      assessmentTemplates: (json['assessmentTemplates'] as List)
          .whereNotNull()
          .map((e) => AssessmentTemplate.fromJson(e as Map<String, dynamic>))
          .toList(),
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTemplates = this.assessmentTemplates;
    final failedItems = this.failedItems;
    return {
      'assessmentTemplates': assessmentTemplates,
      'failedItems': failedItems,
    };
  }
}

class DescribeCrossAccountAccessRoleResponse {
  /// The date when the cross-account access role was registered.
  final DateTime registeredAt;

  /// The ARN that specifies the IAM role that Amazon Inspector uses to access
  /// your AWS account.
  final String roleArn;

  /// A Boolean value that specifies whether the IAM role has the necessary
  /// policies attached to enable Amazon Inspector to access your AWS account.
  final bool valid;

  DescribeCrossAccountAccessRoleResponse({
    required this.registeredAt,
    required this.roleArn,
    required this.valid,
  });

  factory DescribeCrossAccountAccessRoleResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeCrossAccountAccessRoleResponse(
      registeredAt:
          nonNullableTimeStampFromJson(json['registeredAt'] as Object),
      roleArn: json['roleArn'] as String,
      valid: json['valid'] as bool,
    );
  }

  Map<String, dynamic> toJson() {
    final registeredAt = this.registeredAt;
    final roleArn = this.roleArn;
    final valid = this.valid;
    return {
      'registeredAt': unixTimestampToJson(registeredAt),
      'roleArn': roleArn,
      'valid': valid,
    };
  }
}

class DescribeExclusionsResponse {
  /// Information about the exclusions.
  final Map<String, Exclusion> exclusions;

  /// Exclusion details that cannot be described. An error code is provided for
  /// each failed item.
  final Map<String, FailedItemDetails> failedItems;

  DescribeExclusionsResponse({
    required this.exclusions,
    required this.failedItems,
  });

  factory DescribeExclusionsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeExclusionsResponse(
      exclusions: (json['exclusions'] as Map<String, dynamic>).map(
          (k, e) => MapEntry(k, Exclusion.fromJson(e as Map<String, dynamic>))),
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final exclusions = this.exclusions;
    final failedItems = this.failedItems;
    return {
      'exclusions': exclusions,
      'failedItems': failedItems,
    };
  }
}

class DescribeFindingsResponse {
  /// Finding details that cannot be described. An error code is provided for each
  /// failed item.
  final Map<String, FailedItemDetails> failedItems;

  /// Information about the finding.
  final List<Finding> findings;

  DescribeFindingsResponse({
    required this.failedItems,
    required this.findings,
  });

  factory DescribeFindingsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeFindingsResponse(
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
      findings: (json['findings'] as List)
          .whereNotNull()
          .map((e) => Finding.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final failedItems = this.failedItems;
    final findings = this.findings;
    return {
      'failedItems': failedItems,
      'findings': findings,
    };
  }
}

class DescribeResourceGroupsResponse {
  /// Resource group details that cannot be described. An error code is provided
  /// for each failed item.
  final Map<String, FailedItemDetails> failedItems;

  /// Information about a resource group.
  final List<ResourceGroup> resourceGroups;

  DescribeResourceGroupsResponse({
    required this.failedItems,
    required this.resourceGroups,
  });

  factory DescribeResourceGroupsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeResourceGroupsResponse(
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
      resourceGroups: (json['resourceGroups'] as List)
          .whereNotNull()
          .map((e) => ResourceGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final failedItems = this.failedItems;
    final resourceGroups = this.resourceGroups;
    return {
      'failedItems': failedItems,
      'resourceGroups': resourceGroups,
    };
  }
}

class DescribeRulesPackagesResponse {
  /// Rules package details that cannot be described. An error code is provided
  /// for each failed item.
  final Map<String, FailedItemDetails> failedItems;

  /// Information about the rules package.
  final List<RulesPackage> rulesPackages;

  DescribeRulesPackagesResponse({
    required this.failedItems,
    required this.rulesPackages,
  });

  factory DescribeRulesPackagesResponse.fromJson(Map<String, dynamic> json) {
    return DescribeRulesPackagesResponse(
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
      rulesPackages: (json['rulesPackages'] as List)
          .whereNotNull()
          .map((e) => RulesPackage.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final failedItems = this.failedItems;
    final rulesPackages = this.rulesPackages;
    return {
      'failedItems': failedItems,
      'rulesPackages': rulesPackages,
    };
  }
}

/// This data type is used in the <a>AssessmentTemplateFilter</a> data type.
class DurationRange {
  /// The maximum value of the duration range. Must be less than or equal to
  /// 604800 seconds (1 week).
  final int? maxSeconds;

  /// The minimum value of the duration range. Must be greater than zero.
  final int? minSeconds;

  DurationRange({
    this.maxSeconds,
    this.minSeconds,
  });

  factory DurationRange.fromJson(Map<String, dynamic> json) {
    return DurationRange(
      maxSeconds: json['maxSeconds'] as int?,
      minSeconds: json['minSeconds'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final maxSeconds = this.maxSeconds;
    final minSeconds = this.minSeconds;
    return {
      if (maxSeconds != null) 'maxSeconds': maxSeconds,
      if (minSeconds != null) 'minSeconds': minSeconds,
    };
  }
}

/// This data type is used in the <a>Subscription</a> data type.
class EventSubscription {
  /// The event for which Amazon Simple Notification Service (SNS) notifications
  /// are sent.
  final InspectorEvent event;

  /// The time at which <a>SubscribeToEvent</a> is called.
  final DateTime subscribedAt;

  EventSubscription({
    required this.event,
    required this.subscribedAt,
  });

  factory EventSubscription.fromJson(Map<String, dynamic> json) {
    return EventSubscription(
      event: (json['event'] as String).toInspectorEvent(),
      subscribedAt:
          nonNullableTimeStampFromJson(json['subscribedAt'] as Object),
    );
  }

  Map<String, dynamic> toJson() {
    final event = this.event;
    final subscribedAt = this.subscribedAt;
    return {
      'event': event.toValue(),
      'subscribedAt': unixTimestampToJson(subscribedAt),
    };
  }
}

/// Contains information about what was excluded from an assessment run.
class Exclusion {
  /// The ARN that specifies the exclusion.
  final String arn;

  /// The description of the exclusion.
  final String description;

  /// The recommendation for the exclusion.
  final String recommendation;

  /// The AWS resources for which the exclusion pertains.
  final List<Scope> scopes;

  /// The name of the exclusion.
  final String title;

  /// The system-defined attributes for the exclusion.
  final List<Attribute>? attributes;

  Exclusion({
    required this.arn,
    required this.description,
    required this.recommendation,
    required this.scopes,
    required this.title,
    this.attributes,
  });

  factory Exclusion.fromJson(Map<String, dynamic> json) {
    return Exclusion(
      arn: json['arn'] as String,
      description: json['description'] as String,
      recommendation: json['recommendation'] as String,
      scopes: (json['scopes'] as List)
          .whereNotNull()
          .map((e) => Scope.fromJson(e as Map<String, dynamic>))
          .toList(),
      title: json['title'] as String,
      attributes: (json['attributes'] as List?)
          ?.whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final recommendation = this.recommendation;
    final scopes = this.scopes;
    final title = this.title;
    final attributes = this.attributes;
    return {
      'arn': arn,
      'description': description,
      'recommendation': recommendation,
      'scopes': scopes,
      'title': title,
      if (attributes != null) 'attributes': attributes,
    };
  }
}

/// Contains information about what is excluded from an assessment run given the
/// current state of the assessment template.
class ExclusionPreview {
  /// The description of the exclusion preview.
  final String description;

  /// The recommendation for the exclusion preview.
  final String recommendation;

  /// The AWS resources for which the exclusion preview pertains.
  final List<Scope> scopes;

  /// The name of the exclusion preview.
  final String title;

  /// The system-defined attributes for the exclusion preview.
  final List<Attribute>? attributes;

  ExclusionPreview({
    required this.description,
    required this.recommendation,
    required this.scopes,
    required this.title,
    this.attributes,
  });

  factory ExclusionPreview.fromJson(Map<String, dynamic> json) {
    return ExclusionPreview(
      description: json['description'] as String,
      recommendation: json['recommendation'] as String,
      scopes: (json['scopes'] as List)
          .whereNotNull()
          .map((e) => Scope.fromJson(e as Map<String, dynamic>))
          .toList(),
      title: json['title'] as String,
      attributes: (json['attributes'] as List?)
          ?.whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final recommendation = this.recommendation;
    final scopes = this.scopes;
    final title = this.title;
    final attributes = this.attributes;
    return {
      'description': description,
      'recommendation': recommendation,
      'scopes': scopes,
      'title': title,
      if (attributes != null) 'attributes': attributes,
    };
  }
}

/// Includes details about the failed items.
class FailedItemDetails {
  /// The status code of a failed item.
  final FailedItemErrorCode failureCode;

  /// Indicates whether you can immediately retry a request for this item for a
  /// specified resource.
  final bool retryable;

  FailedItemDetails({
    required this.failureCode,
    required this.retryable,
  });

  factory FailedItemDetails.fromJson(Map<String, dynamic> json) {
    return FailedItemDetails(
      failureCode: (json['failureCode'] as String).toFailedItemErrorCode(),
      retryable: json['retryable'] as bool,
    );
  }

  Map<String, dynamic> toJson() {
    final failureCode = this.failureCode;
    final retryable = this.retryable;
    return {
      'failureCode': failureCode.toValue(),
      'retryable': retryable,
    };
  }
}

enum FailedItemErrorCode {
  invalidArn,
  duplicateArn,
  itemDoesNotExist,
  accessDenied,
  limitExceeded,
  internalError,
}

extension on FailedItemErrorCode {
  String toValue() {
    switch (this) {
      case FailedItemErrorCode.invalidArn:
        return 'INVALID_ARN';
      case FailedItemErrorCode.duplicateArn:
        return 'DUPLICATE_ARN';
      case FailedItemErrorCode.itemDoesNotExist:
        return 'ITEM_DOES_NOT_EXIST';
      case FailedItemErrorCode.accessDenied:
        return 'ACCESS_DENIED';
      case FailedItemErrorCode.limitExceeded:
        return 'LIMIT_EXCEEDED';
      case FailedItemErrorCode.internalError:
        return 'INTERNAL_ERROR';
    }
  }
}

extension on String {
  FailedItemErrorCode toFailedItemErrorCode() {
    switch (this) {
      case 'INVALID_ARN':
        return FailedItemErrorCode.invalidArn;
      case 'DUPLICATE_ARN':
        return FailedItemErrorCode.duplicateArn;
      case 'ITEM_DOES_NOT_EXIST':
        return FailedItemErrorCode.itemDoesNotExist;
      case 'ACCESS_DENIED':
        return FailedItemErrorCode.accessDenied;
      case 'LIMIT_EXCEEDED':
        return FailedItemErrorCode.limitExceeded;
      case 'INTERNAL_ERROR':
        return FailedItemErrorCode.internalError;
    }
    throw Exception('$this is not known in enum FailedItemErrorCode');
  }
}

/// Contains information about an Amazon Inspector finding. This data type is
/// used as the response element in the <a>DescribeFindings</a> action.
class Finding {
  /// The ARN that specifies the finding.
  final String arn;

  /// The system-defined attributes for the finding.
  final List<Attribute> attributes;

  /// The time when the finding was generated.
  final DateTime createdAt;

  /// The time when <a>AddAttributesToFindings</a> is called.
  final DateTime updatedAt;

  /// The user-defined attributes that are assigned to the finding.
  final List<Attribute> userAttributes;

  /// A collection of attributes of the host from which the finding is generated.
  final AssetAttributes? assetAttributes;

  /// The type of the host from which the finding is generated.
  final AssetType? assetType;

  /// This data element is currently not used.
  final int? confidence;

  /// The description of the finding.
  final String? description;

  /// The ID of the finding.
  final String? id;

  /// This data element is currently not used.
  final bool? indicatorOfCompromise;

  /// The numeric value of the finding severity.
  final double? numericSeverity;

  /// The recommendation for the finding.
  final String? recommendation;

  /// The schema version of this data type.
  final int? schemaVersion;

  /// The data element is set to "Inspector".
  final String? service;

  /// This data type is used in the <a>Finding</a> data type.
  final InspectorServiceAttributes? serviceAttributes;

  /// The finding severity. Values can be set to High, Medium, Low, and
  /// Informational.
  final Severity? severity;

  /// The name of the finding.
  final String? title;

  Finding({
    required this.arn,
    required this.attributes,
    required this.createdAt,
    required this.updatedAt,
    required this.userAttributes,
    this.assetAttributes,
    this.assetType,
    this.confidence,
    this.description,
    this.id,
    this.indicatorOfCompromise,
    this.numericSeverity,
    this.recommendation,
    this.schemaVersion,
    this.service,
    this.serviceAttributes,
    this.severity,
    this.title,
  });

  factory Finding.fromJson(Map<String, dynamic> json) {
    return Finding(
      arn: json['arn'] as String,
      attributes: (json['attributes'] as List)
          .whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      createdAt: nonNullableTimeStampFromJson(json['createdAt'] as Object),
      updatedAt: nonNullableTimeStampFromJson(json['updatedAt'] as Object),
      userAttributes: (json['userAttributes'] as List)
          .whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      assetAttributes: json['assetAttributes'] != null
          ? AssetAttributes.fromJson(
              json['assetAttributes'] as Map<String, dynamic>)
          : null,
      assetType: (json['assetType'] as String?)?.toAssetType(),
      confidence: json['confidence'] as int?,
      description: json['description'] as String?,
      id: json['id'] as String?,
      indicatorOfCompromise: json['indicatorOfCompromise'] as bool?,
      numericSeverity: json['numericSeverity'] as double?,
      recommendation: json['recommendation'] as String?,
      schemaVersion: json['schemaVersion'] as int?,
      service: json['service'] as String?,
      serviceAttributes: json['serviceAttributes'] != null
          ? InspectorServiceAttributes.fromJson(
              json['serviceAttributes'] as Map<String, dynamic>)
          : null,
      severity: (json['severity'] as String?)?.toSeverity(),
      title: json['title'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final attributes = this.attributes;
    final createdAt = this.createdAt;
    final updatedAt = this.updatedAt;
    final userAttributes = this.userAttributes;
    final assetAttributes = this.assetAttributes;
    final assetType = this.assetType;
    final confidence = this.confidence;
    final description = this.description;
    final id = this.id;
    final indicatorOfCompromise = this.indicatorOfCompromise;
    final numericSeverity = this.numericSeverity;
    final recommendation = this.recommendation;
    final schemaVersion = this.schemaVersion;
    final service = this.service;
    final serviceAttributes = this.serviceAttributes;
    final severity = this.severity;
    final title = this.title;
    return {
      'arn': arn,
      'attributes': attributes,
      'createdAt': unixTimestampToJson(createdAt),
      'updatedAt': unixTimestampToJson(updatedAt),
      'userAttributes': userAttributes,
      if (assetAttributes != null) 'assetAttributes': assetAttributes,
      if (assetType != null) 'assetType': assetType.toValue(),
      if (confidence != null) 'confidence': confidence,
      if (description != null) 'description': description,
      if (id != null) 'id': id,
      if (indicatorOfCompromise != null)
        'indicatorOfCompromise': indicatorOfCompromise,
      if (numericSeverity != null) 'numericSeverity': numericSeverity,
      if (recommendation != null) 'recommendation': recommendation,
      if (schemaVersion != null) 'schemaVersion': schemaVersion,
      if (service != null) 'service': service,
      if (serviceAttributes != null) 'serviceAttributes': serviceAttributes,
      if (severity != null) 'severity': severity.toValue(),
      if (title != null) 'title': title,
    };
  }
}

/// This data type is used as a request parameter in the <a>ListFindings</a>
/// action.
class FindingFilter {
  /// For a record to match a filter, one of the values that is specified for this
  /// data type property must be the exact match of the value of the
  /// <b>agentId</b> property of the <a>Finding</a> data type.
  final List<String>? agentIds;

  /// For a record to match a filter, the list of values that are specified for
  /// this data type property must be contained in the list of values of the
  /// <b>attributes</b> property of the <a>Finding</a> data type.
  final List<Attribute>? attributes;

  /// For a record to match a filter, one of the values that is specified for this
  /// data type property must be the exact match of the value of the
  /// <b>autoScalingGroup</b> property of the <a>Finding</a> data type.
  final List<String>? autoScalingGroups;

  /// The time range during which the finding is generated.
  final TimestampRange? creationTimeRange;

  /// For a record to match a filter, one of the values that is specified for this
  /// data type property must be the exact match of the value of the
  /// <b>ruleName</b> property of the <a>Finding</a> data type.
  final List<String>? ruleNames;

  /// For a record to match a filter, one of the values that is specified for this
  /// data type property must be the exact match of the value of the
  /// <b>rulesPackageArn</b> property of the <a>Finding</a> data type.
  final List<String>? rulesPackageArns;

  /// For a record to match a filter, one of the values that is specified for this
  /// data type property must be the exact match of the value of the
  /// <b>severity</b> property of the <a>Finding</a> data type.
  final List<Severity>? severities;

  /// For a record to match a filter, the value that is specified for this data
  /// type property must be contained in the list of values of the
  /// <b>userAttributes</b> property of the <a>Finding</a> data type.
  final List<Attribute>? userAttributes;

  FindingFilter({
    this.agentIds,
    this.attributes,
    this.autoScalingGroups,
    this.creationTimeRange,
    this.ruleNames,
    this.rulesPackageArns,
    this.severities,
    this.userAttributes,
  });

  factory FindingFilter.fromJson(Map<String, dynamic> json) {
    return FindingFilter(
      agentIds: (json['agentIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      attributes: (json['attributes'] as List?)
          ?.whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
      autoScalingGroups: (json['autoScalingGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      creationTimeRange: json['creationTimeRange'] != null
          ? TimestampRange.fromJson(
              json['creationTimeRange'] as Map<String, dynamic>)
          : null,
      ruleNames: (json['ruleNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      rulesPackageArns: (json['rulesPackageArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      severities: (json['severities'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toSeverity())
          .toList(),
      userAttributes: (json['userAttributes'] as List?)
          ?.whereNotNull()
          .map((e) => Attribute.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final agentIds = this.agentIds;
    final attributes = this.attributes;
    final autoScalingGroups = this.autoScalingGroups;
    final creationTimeRange = this.creationTimeRange;
    final ruleNames = this.ruleNames;
    final rulesPackageArns = this.rulesPackageArns;
    final severities = this.severities;
    final userAttributes = this.userAttributes;
    return {
      if (agentIds != null) 'agentIds': agentIds,
      if (attributes != null) 'attributes': attributes,
      if (autoScalingGroups != null) 'autoScalingGroups': autoScalingGroups,
      if (creationTimeRange != null) 'creationTimeRange': creationTimeRange,
      if (ruleNames != null) 'ruleNames': ruleNames,
      if (rulesPackageArns != null) 'rulesPackageArns': rulesPackageArns,
      if (severities != null)
        'severities': severities.map((e) => e.toValue()).toList(),
      if (userAttributes != null) 'userAttributes': userAttributes,
    };
  }
}

class GetAssessmentReportResponse {
  /// Specifies the status of the request to generate an assessment report.
  final ReportStatus status;

  /// Specifies the URL where you can find the generated assessment report. This
  /// parameter is only returned if the report is successfully generated.
  final String? url;

  GetAssessmentReportResponse({
    required this.status,
    this.url,
  });

  factory GetAssessmentReportResponse.fromJson(Map<String, dynamic> json) {
    return GetAssessmentReportResponse(
      status: (json['status'] as String).toReportStatus(),
      url: json['url'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    final url = this.url;
    return {
      'status': status.toValue(),
      if (url != null) 'url': url,
    };
  }
}

class GetExclusionsPreviewResponse {
  /// Specifies the status of the request to generate an exclusions preview.
  final PreviewStatus previewStatus;

  /// Information about the exclusions included in the preview.
  final List<ExclusionPreview>? exclusionPreviews;

  /// When a response is generated, if there is more data to be listed, this
  /// parameters is present in the response and contains the value to use for the
  /// nextToken parameter in a subsequent pagination request. If there is no more
  /// data to be listed, this parameter is set to null.
  final String? nextToken;

  GetExclusionsPreviewResponse({
    required this.previewStatus,
    this.exclusionPreviews,
    this.nextToken,
  });

  factory GetExclusionsPreviewResponse.fromJson(Map<String, dynamic> json) {
    return GetExclusionsPreviewResponse(
      previewStatus: (json['previewStatus'] as String).toPreviewStatus(),
      exclusionPreviews: (json['exclusionPreviews'] as List?)
          ?.whereNotNull()
          .map((e) => ExclusionPreview.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final previewStatus = this.previewStatus;
    final exclusionPreviews = this.exclusionPreviews;
    final nextToken = this.nextToken;
    return {
      'previewStatus': previewStatus.toValue(),
      if (exclusionPreviews != null) 'exclusionPreviews': exclusionPreviews,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class GetTelemetryMetadataResponse {
  /// Telemetry details.
  final List<TelemetryMetadata> telemetryMetadata;

  GetTelemetryMetadataResponse({
    required this.telemetryMetadata,
  });

  factory GetTelemetryMetadataResponse.fromJson(Map<String, dynamic> json) {
    return GetTelemetryMetadataResponse(
      telemetryMetadata: (json['telemetryMetadata'] as List)
          .whereNotNull()
          .map((e) => TelemetryMetadata.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final telemetryMetadata = this.telemetryMetadata;
    return {
      'telemetryMetadata': telemetryMetadata,
    };
  }
}

enum InspectorEvent {
  assessmentRunStarted,
  assessmentRunCompleted,
  assessmentRunStateChanged,
  findingReported,
  other,
}

extension on InspectorEvent {
  String toValue() {
    switch (this) {
      case InspectorEvent.assessmentRunStarted:
        return 'ASSESSMENT_RUN_STARTED';
      case InspectorEvent.assessmentRunCompleted:
        return 'ASSESSMENT_RUN_COMPLETED';
      case InspectorEvent.assessmentRunStateChanged:
        return 'ASSESSMENT_RUN_STATE_CHANGED';
      case InspectorEvent.findingReported:
        return 'FINDING_REPORTED';
      case InspectorEvent.other:
        return 'OTHER';
    }
  }
}

extension on String {
  InspectorEvent toInspectorEvent() {
    switch (this) {
      case 'ASSESSMENT_RUN_STARTED':
        return InspectorEvent.assessmentRunStarted;
      case 'ASSESSMENT_RUN_COMPLETED':
        return InspectorEvent.assessmentRunCompleted;
      case 'ASSESSMENT_RUN_STATE_CHANGED':
        return InspectorEvent.assessmentRunStateChanged;
      case 'FINDING_REPORTED':
        return InspectorEvent.findingReported;
      case 'OTHER':
        return InspectorEvent.other;
    }
    throw Exception('$this is not known in enum InspectorEvent');
  }
}

/// This data type is used in the <a>Finding</a> data type.
class InspectorServiceAttributes {
  /// The schema version of this data type.
  final int schemaVersion;

  /// The ARN of the assessment run during which the finding is generated.
  final String? assessmentRunArn;

  /// The ARN of the rules package that is used to generate the finding.
  final String? rulesPackageArn;

  InspectorServiceAttributes({
    required this.schemaVersion,
    this.assessmentRunArn,
    this.rulesPackageArn,
  });

  factory InspectorServiceAttributes.fromJson(Map<String, dynamic> json) {
    return InspectorServiceAttributes(
      schemaVersion: json['schemaVersion'] as int,
      assessmentRunArn: json['assessmentRunArn'] as String?,
      rulesPackageArn: json['rulesPackageArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final schemaVersion = this.schemaVersion;
    final assessmentRunArn = this.assessmentRunArn;
    final rulesPackageArn = this.rulesPackageArn;
    return {
      'schemaVersion': schemaVersion,
      if (assessmentRunArn != null) 'assessmentRunArn': assessmentRunArn,
      if (rulesPackageArn != null) 'rulesPackageArn': rulesPackageArn,
    };
  }
}

class ListAssessmentRunAgentsResponse {
  /// A list of ARNs that specifies the agents returned by the action.
  final List<AssessmentRunAgent> assessmentRunAgents;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListAssessmentRunAgentsResponse({
    required this.assessmentRunAgents,
    this.nextToken,
  });

  factory ListAssessmentRunAgentsResponse.fromJson(Map<String, dynamic> json) {
    return ListAssessmentRunAgentsResponse(
      assessmentRunAgents: (json['assessmentRunAgents'] as List)
          .whereNotNull()
          .map((e) => AssessmentRunAgent.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentRunAgents = this.assessmentRunAgents;
    final nextToken = this.nextToken;
    return {
      'assessmentRunAgents': assessmentRunAgents,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListAssessmentRunsResponse {
  /// A list of ARNs that specifies the assessment runs that are returned by the
  /// action.
  final List<String> assessmentRunArns;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListAssessmentRunsResponse({
    required this.assessmentRunArns,
    this.nextToken,
  });

  factory ListAssessmentRunsResponse.fromJson(Map<String, dynamic> json) {
    return ListAssessmentRunsResponse(
      assessmentRunArns: (json['assessmentRunArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentRunArns = this.assessmentRunArns;
    final nextToken = this.nextToken;
    return {
      'assessmentRunArns': assessmentRunArns,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListAssessmentTargetsResponse {
  /// A list of ARNs that specifies the assessment targets that are returned by
  /// the action.
  final List<String> assessmentTargetArns;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListAssessmentTargetsResponse({
    required this.assessmentTargetArns,
    this.nextToken,
  });

  factory ListAssessmentTargetsResponse.fromJson(Map<String, dynamic> json) {
    return ListAssessmentTargetsResponse(
      assessmentTargetArns: (json['assessmentTargetArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTargetArns = this.assessmentTargetArns;
    final nextToken = this.nextToken;
    return {
      'assessmentTargetArns': assessmentTargetArns,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListAssessmentTemplatesResponse {
  /// A list of ARNs that specifies the assessment templates returned by the
  /// action.
  final List<String> assessmentTemplateArns;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListAssessmentTemplatesResponse({
    required this.assessmentTemplateArns,
    this.nextToken,
  });

  factory ListAssessmentTemplatesResponse.fromJson(Map<String, dynamic> json) {
    return ListAssessmentTemplatesResponse(
      assessmentTemplateArns: (json['assessmentTemplateArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentTemplateArns = this.assessmentTemplateArns;
    final nextToken = this.nextToken;
    return {
      'assessmentTemplateArns': assessmentTemplateArns,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListEventSubscriptionsResponse {
  /// Details of the returned event subscriptions.
  final List<Subscription> subscriptions;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListEventSubscriptionsResponse({
    required this.subscriptions,
    this.nextToken,
  });

  factory ListEventSubscriptionsResponse.fromJson(Map<String, dynamic> json) {
    return ListEventSubscriptionsResponse(
      subscriptions: (json['subscriptions'] as List)
          .whereNotNull()
          .map((e) => Subscription.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final subscriptions = this.subscriptions;
    final nextToken = this.nextToken;
    return {
      'subscriptions': subscriptions,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListExclusionsResponse {
  /// A list of exclusions' ARNs returned by the action.
  final List<String> exclusionArns;

  /// When a response is generated, if there is more data to be listed, this
  /// parameters is present in the response and contains the value to use for the
  /// nextToken parameter in a subsequent pagination request. If there is no more
  /// data to be listed, this parameter is set to null.
  final String? nextToken;

  ListExclusionsResponse({
    required this.exclusionArns,
    this.nextToken,
  });

  factory ListExclusionsResponse.fromJson(Map<String, dynamic> json) {
    return ListExclusionsResponse(
      exclusionArns: (json['exclusionArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final exclusionArns = this.exclusionArns;
    final nextToken = this.nextToken;
    return {
      'exclusionArns': exclusionArns,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListFindingsResponse {
  /// A list of ARNs that specifies the findings returned by the action.
  final List<String> findingArns;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListFindingsResponse({
    required this.findingArns,
    this.nextToken,
  });

  factory ListFindingsResponse.fromJson(Map<String, dynamic> json) {
    return ListFindingsResponse(
      findingArns: (json['findingArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final findingArns = this.findingArns;
    final nextToken = this.nextToken;
    return {
      'findingArns': findingArns,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListRulesPackagesResponse {
  /// The list of ARNs that specifies the rules packages returned by the action.
  final List<String> rulesPackageArns;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  ListRulesPackagesResponse({
    required this.rulesPackageArns,
    this.nextToken,
  });

  factory ListRulesPackagesResponse.fromJson(Map<String, dynamic> json) {
    return ListRulesPackagesResponse(
      rulesPackageArns: (json['rulesPackageArns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final rulesPackageArns = this.rulesPackageArns;
    final nextToken = this.nextToken;
    return {
      'rulesPackageArns': rulesPackageArns,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListTagsForResourceResponse {
  /// A collection of key and value pairs.
  final List<Tag> tags;

  ListTagsForResourceResponse({
    required this.tags,
  });

  factory ListTagsForResourceResponse.fromJson(Map<String, dynamic> json) {
    return ListTagsForResourceResponse(
      tags: (json['tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final tags = this.tags;
    return {
      'tags': tags,
    };
  }
}

enum Locale {
  enUs,
}

extension on Locale {
  String toValue() {
    switch (this) {
      case Locale.enUs:
        return 'EN_US';
    }
  }
}

extension on String {
  Locale toLocale() {
    switch (this) {
      case 'EN_US':
        return Locale.enUs;
    }
    throw Exception('$this is not known in enum Locale');
  }
}

/// Contains information about the network interfaces interacting with an EC2
/// instance. This data type is used as one of the elements of the
/// <a>AssetAttributes</a> data type.
class NetworkInterface {
  /// The IP addresses associated with the network interface.
  final List<String>? ipv6Addresses;

  /// The ID of the network interface.
  final String? networkInterfaceId;

  /// The name of a private DNS associated with the network interface.
  final String? privateDnsName;

  /// The private IP address associated with the network interface.
  final String? privateIpAddress;

  /// A list of the private IP addresses associated with the network interface.
  /// Includes the privateDnsName and privateIpAddress.
  final List<PrivateIp>? privateIpAddresses;

  /// The name of a public DNS associated with the network interface.
  final String? publicDnsName;

  /// The public IP address from which the network interface is reachable.
  final String? publicIp;

  /// A list of the security groups associated with the network interface.
  /// Includes the groupId and groupName.
  final List<SecurityGroup>? securityGroups;

  /// The ID of a subnet associated with the network interface.
  final String? subnetId;

  /// The ID of a VPC associated with the network interface.
  final String? vpcId;

  NetworkInterface({
    this.ipv6Addresses,
    this.networkInterfaceId,
    this.privateDnsName,
    this.privateIpAddress,
    this.privateIpAddresses,
    this.publicDnsName,
    this.publicIp,
    this.securityGroups,
    this.subnetId,
    this.vpcId,
  });

  factory NetworkInterface.fromJson(Map<String, dynamic> json) {
    return NetworkInterface(
      ipv6Addresses: (json['ipv6Addresses'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      networkInterfaceId: json['networkInterfaceId'] as String?,
      privateDnsName: json['privateDnsName'] as String?,
      privateIpAddress: json['privateIpAddress'] as String?,
      privateIpAddresses: (json['privateIpAddresses'] as List?)
          ?.whereNotNull()
          .map((e) => PrivateIp.fromJson(e as Map<String, dynamic>))
          .toList(),
      publicDnsName: json['publicDnsName'] as String?,
      publicIp: json['publicIp'] as String?,
      securityGroups: (json['securityGroups'] as List?)
          ?.whereNotNull()
          .map((e) => SecurityGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      subnetId: json['subnetId'] as String?,
      vpcId: json['vpcId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final ipv6Addresses = this.ipv6Addresses;
    final networkInterfaceId = this.networkInterfaceId;
    final privateDnsName = this.privateDnsName;
    final privateIpAddress = this.privateIpAddress;
    final privateIpAddresses = this.privateIpAddresses;
    final publicDnsName = this.publicDnsName;
    final publicIp = this.publicIp;
    final securityGroups = this.securityGroups;
    final subnetId = this.subnetId;
    final vpcId = this.vpcId;
    return {
      if (ipv6Addresses != null) 'ipv6Addresses': ipv6Addresses,
      if (networkInterfaceId != null) 'networkInterfaceId': networkInterfaceId,
      if (privateDnsName != null) 'privateDnsName': privateDnsName,
      if (privateIpAddress != null) 'privateIpAddress': privateIpAddress,
      if (privateIpAddresses != null) 'privateIpAddresses': privateIpAddresses,
      if (publicDnsName != null) 'publicDnsName': publicDnsName,
      if (publicIp != null) 'publicIp': publicIp,
      if (securityGroups != null) 'securityGroups': securityGroups,
      if (subnetId != null) 'subnetId': subnetId,
      if (vpcId != null) 'vpcId': vpcId,
    };
  }
}

class PreviewAgentsResponse {
  /// The resulting list of agents.
  final List<AgentPreview> agentPreviews;

  /// When a response is generated, if there is more data to be listed, this
  /// parameter is present in the response and contains the value to use for the
  /// <b>nextToken</b> parameter in a subsequent pagination request. If there is
  /// no more data to be listed, this parameter is set to null.
  final String? nextToken;

  PreviewAgentsResponse({
    required this.agentPreviews,
    this.nextToken,
  });

  factory PreviewAgentsResponse.fromJson(Map<String, dynamic> json) {
    return PreviewAgentsResponse(
      agentPreviews: (json['agentPreviews'] as List)
          .whereNotNull()
          .map((e) => AgentPreview.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final agentPreviews = this.agentPreviews;
    final nextToken = this.nextToken;
    return {
      'agentPreviews': agentPreviews,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

enum PreviewStatus {
  workInProgress,
  completed,
}

extension on PreviewStatus {
  String toValue() {
    switch (this) {
      case PreviewStatus.workInProgress:
        return 'WORK_IN_PROGRESS';
      case PreviewStatus.completed:
        return 'COMPLETED';
    }
  }
}

extension on String {
  PreviewStatus toPreviewStatus() {
    switch (this) {
      case 'WORK_IN_PROGRESS':
        return PreviewStatus.workInProgress;
      case 'COMPLETED':
        return PreviewStatus.completed;
    }
    throw Exception('$this is not known in enum PreviewStatus');
  }
}

/// Contains information about a private IP address associated with a network
/// interface. This data type is used as a response element in the
/// <a>DescribeFindings</a> action.
class PrivateIp {
  /// The DNS name of the private IP address.
  final String? privateDnsName;

  /// The full IP address of the network inteface.
  final String? privateIpAddress;

  PrivateIp({
    this.privateDnsName,
    this.privateIpAddress,
  });

  factory PrivateIp.fromJson(Map<String, dynamic> json) {
    return PrivateIp(
      privateDnsName: json['privateDnsName'] as String?,
      privateIpAddress: json['privateIpAddress'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final privateDnsName = this.privateDnsName;
    final privateIpAddress = this.privateIpAddress;
    return {
      if (privateDnsName != null) 'privateDnsName': privateDnsName,
      if (privateIpAddress != null) 'privateIpAddress': privateIpAddress,
    };
  }
}

class RemoveAttributesFromFindingsResponse {
  /// Attributes details that cannot be described. An error code is provided for
  /// each failed item.
  final Map<String, FailedItemDetails> failedItems;

  RemoveAttributesFromFindingsResponse({
    required this.failedItems,
  });

  factory RemoveAttributesFromFindingsResponse.fromJson(
      Map<String, dynamic> json) {
    return RemoveAttributesFromFindingsResponse(
      failedItems: (json['failedItems'] as Map<String, dynamic>).map((k, e) =>
          MapEntry(k, FailedItemDetails.fromJson(e as Map<String, dynamic>))),
    );
  }

  Map<String, dynamic> toJson() {
    final failedItems = this.failedItems;
    return {
      'failedItems': failedItems,
    };
  }
}

enum ReportFileFormat {
  html,
  pdf,
}

extension on ReportFileFormat {
  String toValue() {
    switch (this) {
      case ReportFileFormat.html:
        return 'HTML';
      case ReportFileFormat.pdf:
        return 'PDF';
    }
  }
}

extension on String {
  ReportFileFormat toReportFileFormat() {
    switch (this) {
      case 'HTML':
        return ReportFileFormat.html;
      case 'PDF':
        return ReportFileFormat.pdf;
    }
    throw Exception('$this is not known in enum ReportFileFormat');
  }
}

enum ReportStatus {
  workInProgress,
  failed,
  completed,
}

extension on ReportStatus {
  String toValue() {
    switch (this) {
      case ReportStatus.workInProgress:
        return 'WORK_IN_PROGRESS';
      case ReportStatus.failed:
        return 'FAILED';
      case ReportStatus.completed:
        return 'COMPLETED';
    }
  }
}

extension on String {
  ReportStatus toReportStatus() {
    switch (this) {
      case 'WORK_IN_PROGRESS':
        return ReportStatus.workInProgress;
      case 'FAILED':
        return ReportStatus.failed;
      case 'COMPLETED':
        return ReportStatus.completed;
    }
    throw Exception('$this is not known in enum ReportStatus');
  }
}

enum ReportType {
  finding,
  full,
}

extension on ReportType {
  String toValue() {
    switch (this) {
      case ReportType.finding:
        return 'FINDING';
      case ReportType.full:
        return 'FULL';
    }
  }
}

extension on String {
  ReportType toReportType() {
    switch (this) {
      case 'FINDING':
        return ReportType.finding;
      case 'FULL':
        return ReportType.full;
    }
    throw Exception('$this is not known in enum ReportType');
  }
}

/// Contains information about a resource group. The resource group defines a
/// set of tags that, when queried, identify the AWS resources that make up the
/// assessment target. This data type is used as the response element in the
/// <a>DescribeResourceGroups</a> action.
class ResourceGroup {
  /// The ARN of the resource group.
  final String arn;

  /// The time at which resource group is created.
  final DateTime createdAt;

  /// The tags (key and value pairs) of the resource group. This data type
  /// property is used in the <a>CreateResourceGroup</a> action.
  final List<ResourceGroupTag> tags;

  ResourceGroup({
    required this.arn,
    required this.createdAt,
    required this.tags,
  });

  factory ResourceGroup.fromJson(Map<String, dynamic> json) {
    return ResourceGroup(
      arn: json['arn'] as String,
      createdAt: nonNullableTimeStampFromJson(json['createdAt'] as Object),
      tags: (json['tags'] as List)
          .whereNotNull()
          .map((e) => ResourceGroupTag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdAt = this.createdAt;
    final tags = this.tags;
    return {
      'arn': arn,
      'createdAt': unixTimestampToJson(createdAt),
      'tags': tags,
    };
  }
}

/// This data type is used as one of the elements of the <a>ResourceGroup</a>
/// data type.
class ResourceGroupTag {
  /// A tag key.
  final String key;

  /// The value assigned to a tag key.
  final String? value;

  ResourceGroupTag({
    required this.key,
    this.value,
  });

  factory ResourceGroupTag.fromJson(Map<String, dynamic> json) {
    return ResourceGroupTag(
      key: json['key'] as String,
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      'key': key,
      if (value != null) 'value': value,
    };
  }
}

/// Contains information about an Amazon Inspector rules package. This data type
/// is used as the response element in the <a>DescribeRulesPackages</a> action.
class RulesPackage {
  /// The ARN of the rules package.
  final String arn;

  /// The name of the rules package.
  final String name;

  /// The provider of the rules package.
  final String provider;

  /// The version ID of the rules package.
  final String version;

  /// The description of the rules package.
  final String? description;

  RulesPackage({
    required this.arn,
    required this.name,
    required this.provider,
    required this.version,
    this.description,
  });

  factory RulesPackage.fromJson(Map<String, dynamic> json) {
    return RulesPackage(
      arn: json['arn'] as String,
      name: json['name'] as String,
      provider: json['provider'] as String,
      version: json['version'] as String,
      description: json['description'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final name = this.name;
    final provider = this.provider;
    final version = this.version;
    final description = this.description;
    return {
      'arn': arn,
      'name': name,
      'provider': provider,
      'version': version,
      if (description != null) 'description': description,
    };
  }
}

/// This data type contains key-value pairs that identify various Amazon
/// resources.
class Scope {
  /// The type of the scope.
  final ScopeType? key;

  /// The resource identifier for the specified scope type.
  final String? value;

  Scope({
    this.key,
    this.value,
  });

  factory Scope.fromJson(Map<String, dynamic> json) {
    return Scope(
      key: (json['key'] as String?)?.toScopeType(),
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      if (key != null) 'key': key.toValue(),
      if (value != null) 'value': value,
    };
  }
}

enum ScopeType {
  instanceId,
  rulesPackageArn,
}

extension on ScopeType {
  String toValue() {
    switch (this) {
      case ScopeType.instanceId:
        return 'INSTANCE_ID';
      case ScopeType.rulesPackageArn:
        return 'RULES_PACKAGE_ARN';
    }
  }
}

extension on String {
  ScopeType toScopeType() {
    switch (this) {
      case 'INSTANCE_ID':
        return ScopeType.instanceId;
      case 'RULES_PACKAGE_ARN':
        return ScopeType.rulesPackageArn;
    }
    throw Exception('$this is not known in enum ScopeType');
  }
}

/// Contains information about a security group associated with a network
/// interface. This data type is used as one of the elements of the
/// <a>NetworkInterface</a> data type.
class SecurityGroup {
  /// The ID of the security group.
  final String? groupId;

  /// The name of the security group.
  final String? groupName;

  SecurityGroup({
    this.groupId,
    this.groupName,
  });

  factory SecurityGroup.fromJson(Map<String, dynamic> json) {
    return SecurityGroup(
      groupId: json['groupId'] as String?,
      groupName: json['groupName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupId = this.groupId;
    final groupName = this.groupName;
    return {
      if (groupId != null) 'groupId': groupId,
      if (groupName != null) 'groupName': groupName,
    };
  }
}

enum Severity {
  low,
  medium,
  high,
  informational,
  undefined,
}

extension on Severity {
  String toValue() {
    switch (this) {
      case Severity.low:
        return 'Low';
      case Severity.medium:
        return 'Medium';
      case Severity.high:
        return 'High';
      case Severity.informational:
        return 'Informational';
      case Severity.undefined:
        return 'Undefined';
    }
  }
}

extension on String {
  Severity toSeverity() {
    switch (this) {
      case 'Low':
        return Severity.low;
      case 'Medium':
        return Severity.medium;
      case 'High':
        return Severity.high;
      case 'Informational':
        return Severity.informational;
      case 'Undefined':
        return Severity.undefined;
    }
    throw Exception('$this is not known in enum Severity');
  }
}

class StartAssessmentRunResponse {
  /// The ARN of the assessment run that has been started.
  final String assessmentRunArn;

  StartAssessmentRunResponse({
    required this.assessmentRunArn,
  });

  factory StartAssessmentRunResponse.fromJson(Map<String, dynamic> json) {
    return StartAssessmentRunResponse(
      assessmentRunArn: json['assessmentRunArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final assessmentRunArn = this.assessmentRunArn;
    return {
      'assessmentRunArn': assessmentRunArn,
    };
  }
}

enum StopAction {
  startEvaluation,
  skipEvaluation,
}

extension on StopAction {
  String toValue() {
    switch (this) {
      case StopAction.startEvaluation:
        return 'START_EVALUATION';
      case StopAction.skipEvaluation:
        return 'SKIP_EVALUATION';
    }
  }
}

extension on String {
  StopAction toStopAction() {
    switch (this) {
      case 'START_EVALUATION':
        return StopAction.startEvaluation;
      case 'SKIP_EVALUATION':
        return StopAction.skipEvaluation;
    }
    throw Exception('$this is not known in enum StopAction');
  }
}

/// This data type is used as a response element in the
/// <a>ListEventSubscriptions</a> action.
class Subscription {
  /// The list of existing event subscriptions.
  final List<EventSubscription> eventSubscriptions;

  /// The ARN of the assessment template that is used during the event for which
  /// the SNS notification is sent.
  final String resourceArn;

  /// The ARN of the Amazon Simple Notification Service (SNS) topic to which the
  /// SNS notifications are sent.
  final String topicArn;

  Subscription({
    required this.eventSubscriptions,
    required this.resourceArn,
    required this.topicArn,
  });

  factory Subscription.fromJson(Map<String, dynamic> json) {
    return Subscription(
      eventSubscriptions: (json['eventSubscriptions'] as List)
          .whereNotNull()
          .map((e) => EventSubscription.fromJson(e as Map<String, dynamic>))
          .toList(),
      resourceArn: json['resourceArn'] as String,
      topicArn: json['topicArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final eventSubscriptions = this.eventSubscriptions;
    final resourceArn = this.resourceArn;
    final topicArn = this.topicArn;
    return {
      'eventSubscriptions': eventSubscriptions,
      'resourceArn': resourceArn,
      'topicArn': topicArn,
    };
  }
}

/// A key and value pair. This data type is used as a request parameter in the
/// <a>SetTagsForResource</a> action and a response element in the
/// <a>ListTagsForResource</a> action.
class Tag {
  /// A tag key.
  final String key;

  /// A value assigned to a tag key.
  final String? value;

  Tag({
    required this.key,
    this.value,
  });

  factory Tag.fromJson(Map<String, dynamic> json) {
    return Tag(
      key: json['key'] as String,
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      'key': key,
      if (value != null) 'value': value,
    };
  }
}

/// The metadata about the Amazon Inspector application data metrics collected
/// by the agent. This data type is used as the response element in the
/// <a>GetTelemetryMetadata</a> action.
class TelemetryMetadata {
  /// The count of messages that the agent sends to the Amazon Inspector service.
  final int count;

  /// A specific type of behavioral data that is collected by the agent.
  final String messageType;

  /// The data size of messages that the agent sends to the Amazon Inspector
  /// service.
  final int? dataSize;

  TelemetryMetadata({
    required this.count,
    required this.messageType,
    this.dataSize,
  });

  factory TelemetryMetadata.fromJson(Map<String, dynamic> json) {
    return TelemetryMetadata(
      count: json['count'] as int,
      messageType: json['messageType'] as String,
      dataSize: json['dataSize'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final count = this.count;
    final messageType = this.messageType;
    final dataSize = this.dataSize;
    return {
      'count': count,
      'messageType': messageType,
      if (dataSize != null) 'dataSize': dataSize,
    };
  }
}

/// This data type is used in the <a>AssessmentRunFilter</a> data type.
class TimestampRange {
  /// The minimum value of the timestamp range.
  final DateTime? beginDate;

  /// The maximum value of the timestamp range.
  final DateTime? endDate;

  TimestampRange({
    this.beginDate,
    this.endDate,
  });

  factory TimestampRange.fromJson(Map<String, dynamic> json) {
    return TimestampRange(
      beginDate: timeStampFromJson(json['beginDate']),
      endDate: timeStampFromJson(json['endDate']),
    );
  }

  Map<String, dynamic> toJson() {
    final beginDate = this.beginDate;
    final endDate = this.endDate;
    return {
      if (beginDate != null) 'beginDate': unixTimestampToJson(beginDate),
      if (endDate != null) 'endDate': unixTimestampToJson(endDate),
    };
  }
}

class AccessDeniedException extends _s.GenericAwsException {
  AccessDeniedException({String? type, String? message})
      : super(type: type, code: 'AccessDeniedException', message: message);
}

class AgentsAlreadyRunningAssessmentException extends _s.GenericAwsException {
  AgentsAlreadyRunningAssessmentException({String? type, String? message})
      : super(
            type: type,
            code: 'AgentsAlreadyRunningAssessmentException',
            message: message);
}

class AssessmentRunInProgressException extends _s.GenericAwsException {
  AssessmentRunInProgressException({String? type, String? message})
      : super(
            type: type,
            code: 'AssessmentRunInProgressException',
            message: message);
}

class InternalException extends _s.GenericAwsException {
  InternalException({String? type, String? message})
      : super(type: type, code: 'InternalException', message: message);
}

class InvalidCrossAccountRoleException extends _s.GenericAwsException {
  InvalidCrossAccountRoleException({String? type, String? message})
      : super(
            type: type,
            code: 'InvalidCrossAccountRoleException',
            message: message);
}

class InvalidInputException extends _s.GenericAwsException {
  InvalidInputException({String? type, String? message})
      : super(type: type, code: 'InvalidInputException', message: message);
}

class LimitExceededException extends _s.GenericAwsException {
  LimitExceededException({String? type, String? message})
      : super(type: type, code: 'LimitExceededException', message: message);
}

class NoSuchEntityException extends _s.GenericAwsException {
  NoSuchEntityException({String? type, String? message})
      : super(type: type, code: 'NoSuchEntityException', message: message);
}

class PreviewGenerationInProgressException extends _s.GenericAwsException {
  PreviewGenerationInProgressException({String? type, String? message})
      : super(
            type: type,
            code: 'PreviewGenerationInProgressException',
            message: message);
}

class ServiceTemporarilyUnavailableException extends _s.GenericAwsException {
  ServiceTemporarilyUnavailableException({String? type, String? message})
      : super(
            type: type,
            code: 'ServiceTemporarilyUnavailableException',
            message: message);
}

class UnsupportedFeatureException extends _s.GenericAwsException {
  UnsupportedFeatureException({String? type, String? message})
      : super(
            type: type, code: 'UnsupportedFeatureException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'AccessDeniedException': (type, message) =>
      AccessDeniedException(type: type, message: message),
  'AgentsAlreadyRunningAssessmentException': (type, message) =>
      AgentsAlreadyRunningAssessmentException(type: type, message: message),
  'AssessmentRunInProgressException': (type, message) =>
      AssessmentRunInProgressException(type: type, message: message),
  'InternalException': (type, message) =>
      InternalException(type: type, message: message),
  'InvalidCrossAccountRoleException': (type, message) =>
      InvalidCrossAccountRoleException(type: type, message: message),
  'InvalidInputException': (type, message) =>
      InvalidInputException(type: type, message: message),
  'LimitExceededException': (type, message) =>
      LimitExceededException(type: type, message: message),
  'NoSuchEntityException': (type, message) =>
      NoSuchEntityException(type: type, message: message),
  'PreviewGenerationInProgressException': (type, message) =>
      PreviewGenerationInProgressException(type: type, message: message),
  'ServiceTemporarilyUnavailableException': (type, message) =>
      ServiceTemporarilyUnavailableException(type: type, message: message),
  'UnsupportedFeatureException': (type, message) =>
      UnsupportedFeatureException(type: type, message: message),
};
