// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        nonNullableTimeStampFromJson,
        timeStampFromJson;

export '../../shared/shared.dart' show AwsClientCredentials;

/// The Amazon EKS Auth API and the <code>AssumeRoleForPodIdentity</code> action
/// are only used by the EKS Pod Identity Agent.
class EksAuth {
  final _s.RestJsonProtocol _protocol;
  EksAuth({
    required String region,
    _s.AwsClientCredentials? credentials,
    _s.AwsClientCredentialsProvider? credentialsProvider,
    _s.Client? client,
    String? endpointUrl,
  }) : _protocol = _s.RestJsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'eks-auth',
            signingName: 'eks-auth',
          ),
          region: region,
          credentials: credentials,
          credentialsProvider: credentialsProvider,
          endpointUrl: endpointUrl,
        );

  /// Closes the internal HTTP client if none was provided at creation.
  /// If a client was passed as a constructor argument, this becomes a noop.
  ///
  /// It's important to close all clients when it's done being used; failing to
  /// do so can cause the Dart process to hang.
  void close() {
    _protocol.close();
  }

  /// The Amazon EKS Auth API and the <code>AssumeRoleForPodIdentity</code>
  /// action are only used by the EKS Pod Identity Agent.
  ///
  /// We recommend that applications use the Amazon Web Services SDKs to connect
  /// to Amazon Web Services services; if credentials from an EKS Pod Identity
  /// association are available in the pod, the latest versions of the SDKs use
  /// them automatically.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidRequestException].
  /// May throw [AccessDeniedException].
  /// May throw [InternalServerException].
  /// May throw [InvalidTokenException].
  /// May throw [InvalidParameterException].
  /// May throw [ExpiredTokenException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ServiceUnavailableException].
  ///
  /// Parameter [clusterName] :
  /// The name of the cluster for the request.
  ///
  /// Parameter [token] :
  /// The token of the Kubernetes service account for the pod.
  Future<AssumeRoleForPodIdentityResponse> assumeRoleForPodIdentity({
    required String clusterName,
    required String token,
  }) async {
    final $payload = <String, dynamic>{
      'token': token,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/clusters/${Uri.encodeComponent(clusterName)}/assume-role-for-pod-identity',
      exceptionFnMap: _exceptionFns,
    );
    return AssumeRoleForPodIdentityResponse.fromJson(response);
  }
}

class AssumeRoleForPodIdentityResponse {
  /// An object with the permanent IAM role identity and the temporary session
  /// name.
  ///
  /// The ARN of the IAM role that the temporary credentials authenticate to.
  ///
  /// The session name of the temporary session requested to STS. The value is a
  /// unique identifier that contains the role ID, a colon (<code>:</code>), and
  /// the role session name of the role that is being assumed. The role ID is
  /// generated by IAM when the role is created. The role session name part of the
  /// value follows this format:
  /// <code>eks-<i>clustername</i>-<i>podname</i>-<i>random UUID</i> </code>
  final AssumedRoleUser assumedRoleUser;

  /// The identity that is allowed to use the credentials. This value is always
  /// <code>pods.eks.amazonaws.com</code>.
  final String audience;

  /// The <i>Amazon Web Services Signature Version 4</i> type of temporary
  /// credentials.
  final Credentials credentials;

  /// The Amazon Resource Name (ARN) and ID of the EKS Pod Identity association.
  final PodIdentityAssociation podIdentityAssociation;

  /// The name of the Kubernetes service account inside the cluster to associate
  /// the IAM credentials with.
  final Subject subject;

  AssumeRoleForPodIdentityResponse({
    required this.assumedRoleUser,
    required this.audience,
    required this.credentials,
    required this.podIdentityAssociation,
    required this.subject,
  });

  factory AssumeRoleForPodIdentityResponse.fromJson(Map<String, dynamic> json) {
    return AssumeRoleForPodIdentityResponse(
      assumedRoleUser: AssumedRoleUser.fromJson(
          json['assumedRoleUser'] as Map<String, dynamic>),
      audience: json['audience'] as String,
      credentials:
          Credentials.fromJson(json['credentials'] as Map<String, dynamic>),
      podIdentityAssociation: PodIdentityAssociation.fromJson(
          json['podIdentityAssociation'] as Map<String, dynamic>),
      subject: Subject.fromJson(json['subject'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final assumedRoleUser = this.assumedRoleUser;
    final audience = this.audience;
    final credentials = this.credentials;
    final podIdentityAssociation = this.podIdentityAssociation;
    final subject = this.subject;
    return {
      'assumedRoleUser': assumedRoleUser,
      'audience': audience,
      'credentials': credentials,
      'podIdentityAssociation': podIdentityAssociation,
      'subject': subject,
    };
  }
}

/// An object with the permanent IAM role identity and the temporary session
/// name.
class AssumedRoleUser {
  /// The ARN of the IAM role that the temporary credentials authenticate to.
  final String arn;

  /// The session name of the temporary session requested to STS. The value is a
  /// unique identifier that contains the role ID, a colon (<code>:</code>), and
  /// the role session name of the role that is being assumed. The role ID is
  /// generated by IAM when the role is created. The role session name part of the
  /// value follows this format:
  /// <code>eks-<i>clustername</i>-<i>podname</i>-<i>random UUID</i> </code>
  final String assumeRoleId;

  AssumedRoleUser({
    required this.arn,
    required this.assumeRoleId,
  });

  factory AssumedRoleUser.fromJson(Map<String, dynamic> json) {
    return AssumedRoleUser(
      arn: json['arn'] as String,
      assumeRoleId: json['assumeRoleId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assumeRoleId = this.assumeRoleId;
    return {
      'arn': arn,
      'assumeRoleId': assumeRoleId,
    };
  }
}

/// The <i>Amazon Web Services Signature Version 4</i> type of temporary
/// credentials.
class Credentials {
  /// The access key ID that identifies the temporary security credentials.
  final String accessKeyId;

  /// The Unix epoch timestamp in seconds when the current credentials expire.
  final DateTime expiration;

  /// The secret access key that applications inside the pods use to sign
  /// requests.
  final String secretAccessKey;

  /// The token that applications inside the pods must pass to any service API to
  /// use the temporary credentials.
  final String sessionToken;

  Credentials({
    required this.accessKeyId,
    required this.expiration,
    required this.secretAccessKey,
    required this.sessionToken,
  });

  factory Credentials.fromJson(Map<String, dynamic> json) {
    return Credentials(
      accessKeyId: json['accessKeyId'] as String,
      expiration: nonNullableTimeStampFromJson(json['expiration'] as Object),
      secretAccessKey: json['secretAccessKey'] as String,
      sessionToken: json['sessionToken'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final accessKeyId = this.accessKeyId;
    final expiration = this.expiration;
    final secretAccessKey = this.secretAccessKey;
    final sessionToken = this.sessionToken;
    return {
      'accessKeyId': accessKeyId,
      'expiration': unixTimestampToJson(expiration),
      'secretAccessKey': secretAccessKey,
      'sessionToken': sessionToken,
    };
  }
}

/// Amazon EKS Pod Identity associations provide the ability to manage
/// credentials for your applications, similar to the way that Amazon EC2
/// instance profiles provide credentials to Amazon EC2 instances.
class PodIdentityAssociation {
  /// The Amazon Resource Name (ARN) of the EKS Pod Identity association.
  final String associationArn;

  /// The ID of the association.
  final String associationId;

  PodIdentityAssociation({
    required this.associationArn,
    required this.associationId,
  });

  factory PodIdentityAssociation.fromJson(Map<String, dynamic> json) {
    return PodIdentityAssociation(
      associationArn: json['associationArn'] as String,
      associationId: json['associationId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final associationArn = this.associationArn;
    final associationId = this.associationId;
    return {
      'associationArn': associationArn,
      'associationId': associationId,
    };
  }
}

/// An object containing the name of the Kubernetes service account inside the
/// cluster to associate the IAM credentials with.
class Subject {
  /// The name of the Kubernetes namespace inside the cluster to create the
  /// association in. The service account and the pods that use the service
  /// account must be in this namespace.
  final String namespace;

  /// The name of the Kubernetes service account inside the cluster to associate
  /// the IAM credentials with.
  final String serviceAccount;

  Subject({
    required this.namespace,
    required this.serviceAccount,
  });

  factory Subject.fromJson(Map<String, dynamic> json) {
    return Subject(
      namespace: json['namespace'] as String,
      serviceAccount: json['serviceAccount'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final namespace = this.namespace;
    final serviceAccount = this.serviceAccount;
    return {
      'namespace': namespace,
      'serviceAccount': serviceAccount,
    };
  }
}

class AccessDeniedException extends _s.GenericAwsException {
  AccessDeniedException({String? type, String? message})
      : super(type: type, code: 'AccessDeniedException', message: message);
}

class ExpiredTokenException extends _s.GenericAwsException {
  ExpiredTokenException({String? type, String? message})
      : super(type: type, code: 'ExpiredTokenException', message: message);
}

class InternalServerException extends _s.GenericAwsException {
  InternalServerException({String? type, String? message})
      : super(type: type, code: 'InternalServerException', message: message);
}

class InvalidParameterException extends _s.GenericAwsException {
  InvalidParameterException({String? type, String? message})
      : super(type: type, code: 'InvalidParameterException', message: message);
}

class InvalidRequestException extends _s.GenericAwsException {
  InvalidRequestException({String? type, String? message})
      : super(type: type, code: 'InvalidRequestException', message: message);
}

class InvalidTokenException extends _s.GenericAwsException {
  InvalidTokenException({String? type, String? message})
      : super(type: type, code: 'InvalidTokenException', message: message);
}

class ResourceNotFoundException extends _s.GenericAwsException {
  ResourceNotFoundException({String? type, String? message})
      : super(type: type, code: 'ResourceNotFoundException', message: message);
}

class ServiceUnavailableException extends _s.GenericAwsException {
  ServiceUnavailableException({String? type, String? message})
      : super(
            type: type, code: 'ServiceUnavailableException', message: message);
}

class ThrottlingException extends _s.GenericAwsException {
  ThrottlingException({String? type, String? message})
      : super(type: type, code: 'ThrottlingException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'AccessDeniedException': (type, message) =>
      AccessDeniedException(type: type, message: message),
  'ExpiredTokenException': (type, message) =>
      ExpiredTokenException(type: type, message: message),
  'InternalServerException': (type, message) =>
      InternalServerException(type: type, message: message),
  'InvalidParameterException': (type, message) =>
      InvalidParameterException(type: type, message: message),
  'InvalidRequestException': (type, message) =>
      InvalidRequestException(type: type, message: message),
  'InvalidTokenException': (type, message) =>
      InvalidTokenException(type: type, message: message),
  'ResourceNotFoundException': (type, message) =>
      ResourceNotFoundException(type: type, message: message),
  'ServiceUnavailableException': (type, message) =>
      ServiceUnavailableException(type: type, message: message),
  'ThrottlingException': (type, message) =>
      ThrottlingException(type: type, message: message),
};
