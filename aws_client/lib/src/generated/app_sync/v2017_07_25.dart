// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        nonNullableTimeStampFromJson,
        timeStampFromJson;

export '../../shared/shared.dart' show AwsClientCredentials;

/// AppSync provides API actions for creating and interacting with data sources
/// using GraphQL from your application.
class AppSync {
  final _s.RestJsonProtocol _protocol;
  AppSync({
    required String region,
    _s.AwsClientCredentials? credentials,
    _s.AwsClientCredentialsProvider? credentialsProvider,
    _s.Client? client,
    String? endpointUrl,
  }) : _protocol = _s.RestJsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'appsync',
            signingName: 'appsync',
          ),
          region: region,
          credentials: credentials,
          credentialsProvider: credentialsProvider,
          endpointUrl: endpointUrl,
        );

  /// Closes the internal HTTP client if none was provided at creation.
  /// If a client was passed as a constructor argument, this becomes a noop.
  ///
  /// It's important to close all clients when it's done being used; failing to
  /// do so can cause the Dart process to hang.
  void close() {
    _protocol.close();
  }

  /// Maps an endpoint to your custom domain.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [apiId] :
  /// The API ID. Private APIs can not be associated with custom domains.
  ///
  /// Parameter [domainName] :
  /// The domain name.
  Future<AssociateApiResponse> associateApi({
    required String apiId,
    required String domainName,
  }) async {
    final $payload = <String, dynamic>{
      'apiId': apiId,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/domainnames/${Uri.encodeComponent(domainName)}/apiassociation',
      exceptionFnMap: _exceptionFns,
    );
    return AssociateApiResponse.fromJson(response);
  }

  /// Creates an association between a Merged API and source API using the
  /// source API's identifier.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ConcurrentModificationException].
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  ///
  /// Parameter [sourceApiIdentifier] :
  /// The identifier of the AppSync Source API. This is generated by the AppSync
  /// service. In most cases, source APIs (especially in your account) only
  /// require the API ID value or ARN of the source API. However, source APIs
  /// from other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the source API.
  ///
  /// Parameter [description] :
  /// The description field.
  ///
  /// Parameter [sourceApiAssociationConfig] :
  /// The <code>SourceApiAssociationConfig</code> object data.
  Future<AssociateMergedGraphqlApiResponse> associateMergedGraphqlApi({
    required String mergedApiIdentifier,
    required String sourceApiIdentifier,
    String? description,
    SourceApiAssociationConfig? sourceApiAssociationConfig,
  }) async {
    final $payload = <String, dynamic>{
      'mergedApiIdentifier': mergedApiIdentifier,
      if (description != null) 'description': description,
      if (sourceApiAssociationConfig != null)
        'sourceApiAssociationConfig': sourceApiAssociationConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/sourceApis/${Uri.encodeComponent(sourceApiIdentifier)}/mergedApiAssociations',
      exceptionFnMap: _exceptionFns,
    );
    return AssociateMergedGraphqlApiResponse.fromJson(response);
  }

  /// Creates an association between a Merged API and source API using the
  /// Merged API's identifier.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [ConcurrentModificationException].
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  ///
  /// Parameter [sourceApiIdentifier] :
  /// The identifier of the AppSync Source API. This is generated by the AppSync
  /// service. In most cases, source APIs (especially in your account) only
  /// require the API ID value or ARN of the source API. However, source APIs
  /// from other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the source API.
  ///
  /// Parameter [description] :
  /// The description field.
  ///
  /// Parameter [sourceApiAssociationConfig] :
  /// The <code>SourceApiAssociationConfig</code> object data.
  Future<AssociateSourceGraphqlApiResponse> associateSourceGraphqlApi({
    required String mergedApiIdentifier,
    required String sourceApiIdentifier,
    String? description,
    SourceApiAssociationConfig? sourceApiAssociationConfig,
  }) async {
    final $payload = <String, dynamic>{
      'sourceApiIdentifier': sourceApiIdentifier,
      if (description != null) 'description': description,
      if (sourceApiAssociationConfig != null)
        'sourceApiAssociationConfig': sourceApiAssociationConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/mergedApis/${Uri.encodeComponent(mergedApiIdentifier)}/sourceApiAssociations',
      exceptionFnMap: _exceptionFns,
    );
    return AssociateSourceGraphqlApiResponse.fromJson(response);
  }

  /// Creates a cache for the GraphQL API.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiCachingBehavior] :
  /// Caching behavior.
  ///
  /// <ul>
  /// <li>
  /// <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.
  /// </li>
  /// <li>
  /// <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are
  /// cached.
  /// </li>
  /// </ul>
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [ttl] :
  /// TTL in seconds for cache entries.
  ///
  /// Valid values are 1â€“3,600 seconds.
  ///
  /// Parameter [type] :
  /// The cache instance type. Valid values are
  ///
  /// <ul>
  /// <li>
  /// <code>SMALL</code>
  /// </li>
  /// <li>
  /// <code>MEDIUM</code>
  /// </li>
  /// <li>
  /// <code>LARGE</code>
  /// </li>
  /// <li>
  /// <code>XLARGE</code>
  /// </li>
  /// <li>
  /// <code>LARGE_2X</code>
  /// </li>
  /// <li>
  /// <code>LARGE_4X</code>
  /// </li>
  /// <li>
  /// <code>LARGE_8X</code> (not available in all regions)
  /// </li>
  /// <li>
  /// <code>LARGE_12X</code>
  /// </li>
  /// </ul>
  /// Historically, instance types were identified by an EC2-style value. As of
  /// July 2020, this is deprecated, and the generic identifiers above should be
  /// used.
  ///
  /// The following legacy instance types are available, but their use is
  /// discouraged:
  ///
  /// <ul>
  /// <li>
  /// <b>T2_SMALL</b>: A t2.small instance type.
  /// </li>
  /// <li>
  /// <b>T2_MEDIUM</b>: A t2.medium instance type.
  /// </li>
  /// <li>
  /// <b>R4_LARGE</b>: A r4.large instance type.
  /// </li>
  /// <li>
  /// <b>R4_XLARGE</b>: A r4.xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_2XLARGE</b>: A r4.2xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_4XLARGE</b>: A r4.4xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_8XLARGE</b>: A r4.8xlarge instance type.
  /// </li>
  /// </ul>
  ///
  /// Parameter [atRestEncryptionEnabled] :
  /// At-rest encryption flag for cache. You cannot update this setting after
  /// creation.
  ///
  /// Parameter [healthMetricsConfig] :
  /// Controls how cache health metrics will be emitted to CloudWatch. Cache
  /// health metrics include:
  ///
  /// <ul>
  /// <li>
  /// NetworkBandwidthOutAllowanceExceeded: The network packets dropped because
  /// the throughput exceeded the aggregated bandwidth limit. This is useful for
  /// diagnosing bottlenecks in a cache configuration.
  /// </li>
  /// <li>
  /// EngineCPUUtilization: The CPU utilization (percentage) allocated to the
  /// Redis process. This is useful for diagnosing bottlenecks in a cache
  /// configuration.
  /// </li>
  /// </ul>
  /// Metrics will be recorded by API ID. You can set the value to
  /// <code>ENABLED</code> or <code>DISABLED</code>.
  ///
  /// Parameter [transitEncryptionEnabled] :
  /// Transit encryption flag when connecting to cache. You cannot update this
  /// setting after creation.
  Future<CreateApiCacheResponse> createApiCache({
    required ApiCachingBehavior apiCachingBehavior,
    required String apiId,
    required int ttl,
    required ApiCacheType type,
    bool? atRestEncryptionEnabled,
    CacheHealthMetricsConfig? healthMetricsConfig,
    bool? transitEncryptionEnabled,
  }) async {
    final $payload = <String, dynamic>{
      'apiCachingBehavior': apiCachingBehavior.value,
      'ttl': ttl,
      'type': type.value,
      if (atRestEncryptionEnabled != null)
        'atRestEncryptionEnabled': atRestEncryptionEnabled,
      if (healthMetricsConfig != null)
        'healthMetricsConfig': healthMetricsConfig.value,
      if (transitEncryptionEnabled != null)
        'transitEncryptionEnabled': transitEncryptionEnabled,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/ApiCaches',
      exceptionFnMap: _exceptionFns,
    );
    return CreateApiCacheResponse.fromJson(response);
  }

  /// Creates a unique key that you can distribute to clients who invoke your
  /// API.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [UnauthorizedException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  /// May throw [ApiKeyLimitExceededException].
  /// May throw [ApiKeyValidityOutOfBoundsException].
  ///
  /// Parameter [apiId] :
  /// The ID for your GraphQL API.
  ///
  /// Parameter [description] :
  /// A description of the purpose of the API key.
  ///
  /// Parameter [expires] :
  /// From the creation time, the time after which the API key expires. The date
  /// is represented as seconds since the epoch, rounded down to the nearest
  /// hour. The default value for this parameter is 7 days from creation time.
  /// For more information, see .
  Future<CreateApiKeyResponse> createApiKey({
    required String apiId,
    String? description,
    int? expires,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'description': description,
      if (expires != null) 'expires': expires,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/apikeys',
      exceptionFnMap: _exceptionFns,
    );
    return CreateApiKeyResponse.fromJson(response);
  }

  /// Creates a <code>DataSource</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID for the GraphQL API for the <code>DataSource</code>.
  ///
  /// Parameter [name] :
  /// A user-supplied name for the <code>DataSource</code>.
  ///
  /// Parameter [type] :
  /// The type of the <code>DataSource</code>.
  ///
  /// Parameter [description] :
  /// A description of the <code>DataSource</code>.
  ///
  /// Parameter [dynamodbConfig] :
  /// Amazon DynamoDB settings.
  ///
  /// Parameter [elasticsearchConfig] :
  /// Amazon OpenSearch Service settings.
  ///
  /// As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch
  /// Service. This configuration is deprecated. For new data sources, use
  /// <a>CreateDataSourceRequest$openSearchServiceConfig</a> to create an
  /// OpenSearch data source.
  ///
  /// Parameter [eventBridgeConfig] :
  /// Amazon EventBridge settings.
  ///
  /// Parameter [httpConfig] :
  /// HTTP endpoint settings.
  ///
  /// Parameter [lambdaConfig] :
  /// Lambda settings.
  ///
  /// Parameter [metricsConfig] :
  /// Enables or disables enhanced data source metrics for specified data
  /// sources. Note that <code>metricsConfig</code> won't be used unless the
  /// <code>dataSourceLevelMetricsBehavior</code> value is set to
  /// <code>PER_DATA_SOURCE_METRICS</code>. If the
  /// <code>dataSourceLevelMetricsBehavior</code> is set to
  /// <code>FULL_REQUEST_DATA_SOURCE_METRICS</code> instead,
  /// <code>metricsConfig</code> will be ignored. However, you can still set its
  /// value.
  ///
  /// <code>metricsConfig</code> can be <code>ENABLED</code> or
  /// <code>DISABLED</code>.
  ///
  /// Parameter [openSearchServiceConfig] :
  /// Amazon OpenSearch Service settings.
  ///
  /// Parameter [relationalDatabaseConfig] :
  /// Relational database settings.
  ///
  /// Parameter [serviceRoleArn] :
  /// The Identity and Access Management (IAM) service role Amazon Resource Name
  /// (ARN) for the data source. The system assumes this role when accessing the
  /// data source.
  Future<CreateDataSourceResponse> createDataSource({
    required String apiId,
    required String name,
    required DataSourceType type,
    String? description,
    DynamodbDataSourceConfig? dynamodbConfig,
    ElasticsearchDataSourceConfig? elasticsearchConfig,
    EventBridgeDataSourceConfig? eventBridgeConfig,
    HttpDataSourceConfig? httpConfig,
    LambdaDataSourceConfig? lambdaConfig,
    DataSourceLevelMetricsConfig? metricsConfig,
    OpenSearchServiceDataSourceConfig? openSearchServiceConfig,
    RelationalDatabaseDataSourceConfig? relationalDatabaseConfig,
    String? serviceRoleArn,
  }) async {
    final $payload = <String, dynamic>{
      'name': name,
      'type': type.value,
      if (description != null) 'description': description,
      if (dynamodbConfig != null) 'dynamodbConfig': dynamodbConfig,
      if (elasticsearchConfig != null)
        'elasticsearchConfig': elasticsearchConfig,
      if (eventBridgeConfig != null) 'eventBridgeConfig': eventBridgeConfig,
      if (httpConfig != null) 'httpConfig': httpConfig,
      if (lambdaConfig != null) 'lambdaConfig': lambdaConfig,
      if (metricsConfig != null) 'metricsConfig': metricsConfig.value,
      if (openSearchServiceConfig != null)
        'openSearchServiceConfig': openSearchServiceConfig,
      if (relationalDatabaseConfig != null)
        'relationalDatabaseConfig': relationalDatabaseConfig,
      if (serviceRoleArn != null) 'serviceRoleArn': serviceRoleArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/datasources',
      exceptionFnMap: _exceptionFns,
    );
    return CreateDataSourceResponse.fromJson(response);
  }

  /// Creates a custom <code>DomainName</code> object.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [certificateArn] :
  /// The Amazon Resource Name (ARN) of the certificate. This can be an
  /// Certificate Manager (ACM) certificate or an Identity and Access Management
  /// (IAM) server certificate.
  ///
  /// Parameter [domainName] :
  /// The domain name.
  ///
  /// Parameter [description] :
  /// A description of the <code>DomainName</code>.
  Future<CreateDomainNameResponse> createDomainName({
    required String certificateArn,
    required String domainName,
    String? description,
  }) async {
    final $payload = <String, dynamic>{
      'certificateArn': certificateArn,
      'domainName': domainName,
      if (description != null) 'description': description,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/domainnames',
      exceptionFnMap: _exceptionFns,
    );
    return CreateDomainNameResponse.fromJson(response);
  }

  /// Creates a <code>Function</code> object.
  ///
  /// A function is a reusable entity. You can use multiple functions to compose
  /// the resolver logic.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [dataSourceName] :
  /// The <code>Function</code> <code>DataSource</code> name.
  ///
  /// Parameter [name] :
  /// The <code>Function</code> name. The function name does not have to be
  /// unique.
  ///
  /// Parameter [code] :
  /// The <code>function</code> code that contains the request and response
  /// functions. When code is used, the <code>runtime</code> is required. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  ///
  /// Parameter [description] :
  /// The <code>Function</code> description.
  ///
  /// Parameter [functionVersion] :
  /// The <code>version</code> of the request mapping template. Currently, the
  /// supported value is 2018-05-29. Note that when using VTL and mapping
  /// templates, the <code>functionVersion</code> is required.
  ///
  /// Parameter [maxBatchSize] :
  /// The maximum batching size for a resolver.
  ///
  /// Parameter [requestMappingTemplate] :
  /// The <code>Function</code> request mapping template. Functions support only
  /// the 2018-05-29 version of the request mapping template.
  ///
  /// Parameter [responseMappingTemplate] :
  /// The <code>Function</code> response mapping template.
  Future<CreateFunctionResponse> createFunction({
    required String apiId,
    required String dataSourceName,
    required String name,
    String? code,
    String? description,
    String? functionVersion,
    int? maxBatchSize,
    String? requestMappingTemplate,
    String? responseMappingTemplate,
    AppSyncRuntime? runtime,
    SyncConfig? syncConfig,
  }) async {
    _s.validateNumRange(
      'maxBatchSize',
      maxBatchSize,
      0,
      2000,
    );
    final $payload = <String, dynamic>{
      'dataSourceName': dataSourceName,
      'name': name,
      if (code != null) 'code': code,
      if (description != null) 'description': description,
      if (functionVersion != null) 'functionVersion': functionVersion,
      if (maxBatchSize != null) 'maxBatchSize': maxBatchSize,
      if (requestMappingTemplate != null)
        'requestMappingTemplate': requestMappingTemplate,
      if (responseMappingTemplate != null)
        'responseMappingTemplate': responseMappingTemplate,
      if (runtime != null) 'runtime': runtime,
      if (syncConfig != null) 'syncConfig': syncConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/functions',
      exceptionFnMap: _exceptionFns,
    );
    return CreateFunctionResponse.fromJson(response);
  }

  /// Creates a <code>GraphqlApi</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [LimitExceededException].
  /// May throw [ConcurrentModificationException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [ApiLimitExceededException].
  ///
  /// Parameter [authenticationType] :
  /// The authentication type: API key, Identity and Access Management (IAM),
  /// OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
  ///
  /// Parameter [name] :
  /// A user-supplied name for the <code>GraphqlApi</code>.
  ///
  /// Parameter [additionalAuthenticationProviders] :
  /// A list of additional authentication providers for the
  /// <code>GraphqlApi</code> API.
  ///
  /// Parameter [apiType] :
  /// The value that indicates whether the GraphQL API is a standard API
  /// (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).
  ///
  /// Parameter [enhancedMetricsConfig] :
  /// The <code>enhancedMetricsConfig</code> object.
  ///
  /// Parameter [introspectionConfig] :
  /// Sets the value of the GraphQL API to enable (<code>ENABLED</code>) or
  /// disable (<code>DISABLED</code>) introspection. If no value is provided,
  /// the introspection configuration will be set to <code>ENABLED</code> by
  /// default. This field will produce an error if the operation attempts to use
  /// the introspection feature while this field is disabled.
  ///
  /// For more information about introspection, see <a
  /// href="https://graphql.org/learn/introspection/">GraphQL introspection</a>.
  ///
  /// Parameter [lambdaAuthorizerConfig] :
  /// Configuration for Lambda function authorization.
  ///
  /// Parameter [logConfig] :
  /// The Amazon CloudWatch Logs configuration.
  ///
  /// Parameter [mergedApiExecutionRoleArn] :
  /// The Identity and Access Management service role ARN for a merged API. The
  /// AppSync service assumes this role on behalf of the Merged API to validate
  /// access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code>
  /// to update the merged API endpoint with the source API changes
  /// automatically.
  ///
  /// Parameter [openIDConnectConfig] :
  /// The OIDC configuration.
  ///
  /// Parameter [ownerContact] :
  /// The owner contact information for an API resource.
  ///
  /// This field accepts any string input with a length of 0 - 256 characters.
  ///
  /// Parameter [queryDepthLimit] :
  /// The maximum depth a query can have in a single request. Depth refers to
  /// the amount of nested levels allowed in the body of query. The default
  /// value is <code>0</code> (or unspecified), which indicates there's no depth
  /// limit. If you set a limit, it can be between <code>1</code> and
  /// <code>75</code> nested levels. This field will produce a limit error if
  /// the operation falls out of bounds.
  ///
  /// Note that fields can still be set to nullable or non-nullable. If a
  /// non-nullable field produces an error, the error will be thrown upwards to
  /// the first nullable field available.
  ///
  /// Parameter [resolverCountLimit] :
  /// The maximum number of resolvers that can be invoked in a single request.
  /// The default value is <code>0</code> (or unspecified), which will set the
  /// limit to <code>10000</code>. When specified, the limit value can be
  /// between <code>1</code> and <code>10000</code>. This field will produce a
  /// limit error if the operation falls out of bounds.
  ///
  /// Parameter [tags] :
  /// A <code>TagMap</code> object.
  ///
  /// Parameter [userPoolConfig] :
  /// The Amazon Cognito user pool configuration.
  ///
  /// Parameter [visibility] :
  /// Sets the value of the GraphQL API to public (<code>GLOBAL</code>) or
  /// private (<code>PRIVATE</code>). If no value is provided, the visibility
  /// will be set to <code>GLOBAL</code> by default. This value cannot be
  /// changed once the API has been created.
  ///
  /// Parameter [xrayEnabled] :
  /// A flag indicating whether to use X-Ray tracing for the
  /// <code>GraphqlApi</code>.
  Future<CreateGraphqlApiResponse> createGraphqlApi({
    required AuthenticationType authenticationType,
    required String name,
    List<AdditionalAuthenticationProvider>? additionalAuthenticationProviders,
    GraphQLApiType? apiType,
    EnhancedMetricsConfig? enhancedMetricsConfig,
    GraphQLApiIntrospectionConfig? introspectionConfig,
    LambdaAuthorizerConfig? lambdaAuthorizerConfig,
    LogConfig? logConfig,
    String? mergedApiExecutionRoleArn,
    OpenIDConnectConfig? openIDConnectConfig,
    String? ownerContact,
    int? queryDepthLimit,
    int? resolverCountLimit,
    Map<String, String>? tags,
    UserPoolConfig? userPoolConfig,
    GraphQLApiVisibility? visibility,
    bool? xrayEnabled,
  }) async {
    _s.validateNumRange(
      'queryDepthLimit',
      queryDepthLimit,
      0,
      75,
    );
    _s.validateNumRange(
      'resolverCountLimit',
      resolverCountLimit,
      0,
      10000,
    );
    final $payload = <String, dynamic>{
      'authenticationType': authenticationType.value,
      'name': name,
      if (additionalAuthenticationProviders != null)
        'additionalAuthenticationProviders': additionalAuthenticationProviders,
      if (apiType != null) 'apiType': apiType.value,
      if (enhancedMetricsConfig != null)
        'enhancedMetricsConfig': enhancedMetricsConfig,
      if (introspectionConfig != null)
        'introspectionConfig': introspectionConfig.value,
      if (lambdaAuthorizerConfig != null)
        'lambdaAuthorizerConfig': lambdaAuthorizerConfig,
      if (logConfig != null) 'logConfig': logConfig,
      if (mergedApiExecutionRoleArn != null)
        'mergedApiExecutionRoleArn': mergedApiExecutionRoleArn,
      if (openIDConnectConfig != null)
        'openIDConnectConfig': openIDConnectConfig,
      if (ownerContact != null) 'ownerContact': ownerContact,
      if (queryDepthLimit != null) 'queryDepthLimit': queryDepthLimit,
      if (resolverCountLimit != null) 'resolverCountLimit': resolverCountLimit,
      if (tags != null) 'tags': tags,
      if (userPoolConfig != null) 'userPoolConfig': userPoolConfig,
      if (visibility != null) 'visibility': visibility.value,
      if (xrayEnabled != null) 'xrayEnabled': xrayEnabled,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis',
      exceptionFnMap: _exceptionFns,
    );
    return CreateGraphqlApiResponse.fromJson(response);
  }

  /// Creates a <code>Resolver</code> object.
  ///
  /// A resolver converts incoming requests into a format that a data source can
  /// understand, and converts the data source's responses into GraphQL.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [apiId] :
  /// The ID for the GraphQL API for which the resolver is being created.
  ///
  /// Parameter [fieldName] :
  /// The name of the field to attach the resolver to.
  ///
  /// Parameter [typeName] :
  /// The name of the <code>Type</code>.
  ///
  /// Parameter [cachingConfig] :
  /// The caching configuration for the resolver.
  ///
  /// Parameter [code] :
  /// The <code>resolver</code> code that contains the request and response
  /// functions. When code is used, the <code>runtime</code> is required. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  ///
  /// Parameter [dataSourceName] :
  /// The name of the data source for which the resolver is being created.
  ///
  /// Parameter [kind] :
  /// The resolver type.
  ///
  /// <ul>
  /// <li>
  /// <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver
  /// type. You can use a UNIT resolver to run a GraphQL query against a single
  /// data source.
  /// </li>
  /// <li>
  /// <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver
  /// to invoke a series of <code>Function</code> objects in a serial manner.
  /// You can use a pipeline resolver to run a GraphQL query against multiple
  /// data sources.
  /// </li>
  /// </ul>
  ///
  /// Parameter [maxBatchSize] :
  /// The maximum batching size for a resolver.
  ///
  /// Parameter [metricsConfig] :
  /// Enables or disables enhanced resolver metrics for specified resolvers.
  /// Note that <code>metricsConfig</code> won't be used unless the
  /// <code>resolverLevelMetricsBehavior</code> value is set to
  /// <code>PER_RESOLVER_METRICS</code>. If the
  /// <code>resolverLevelMetricsBehavior</code> is set to
  /// <code>FULL_REQUEST_RESOLVER_METRICS</code> instead,
  /// <code>metricsConfig</code> will be ignored. However, you can still set its
  /// value.
  ///
  /// <code>metricsConfig</code> can be <code>ENABLED</code> or
  /// <code>DISABLED</code>.
  ///
  /// Parameter [pipelineConfig] :
  /// The <code>PipelineConfig</code>.
  ///
  /// Parameter [requestMappingTemplate] :
  /// The mapping template to use for requests.
  ///
  /// A resolver uses a request mapping template to convert a GraphQL expression
  /// into a format that a data source can understand. Mapping templates are
  /// written in Apache Velocity Template Language (VTL).
  ///
  /// VTL request mapping templates are optional when using an Lambda data
  /// source. For all other data sources, VTL request and response mapping
  /// templates are required.
  ///
  /// Parameter [responseMappingTemplate] :
  /// The mapping template to use for responses from the data source.
  ///
  /// Parameter [syncConfig] :
  /// The <code>SyncConfig</code> for a resolver attached to a versioned data
  /// source.
  Future<CreateResolverResponse> createResolver({
    required String apiId,
    required String fieldName,
    required String typeName,
    CachingConfig? cachingConfig,
    String? code,
    String? dataSourceName,
    ResolverKind? kind,
    int? maxBatchSize,
    ResolverLevelMetricsConfig? metricsConfig,
    PipelineConfig? pipelineConfig,
    String? requestMappingTemplate,
    String? responseMappingTemplate,
    AppSyncRuntime? runtime,
    SyncConfig? syncConfig,
  }) async {
    _s.validateNumRange(
      'maxBatchSize',
      maxBatchSize,
      0,
      2000,
    );
    final $payload = <String, dynamic>{
      'fieldName': fieldName,
      if (cachingConfig != null) 'cachingConfig': cachingConfig,
      if (code != null) 'code': code,
      if (dataSourceName != null) 'dataSourceName': dataSourceName,
      if (kind != null) 'kind': kind.value,
      if (maxBatchSize != null) 'maxBatchSize': maxBatchSize,
      if (metricsConfig != null) 'metricsConfig': metricsConfig.value,
      if (pipelineConfig != null) 'pipelineConfig': pipelineConfig,
      if (requestMappingTemplate != null)
        'requestMappingTemplate': requestMappingTemplate,
      if (responseMappingTemplate != null)
        'responseMappingTemplate': responseMappingTemplate,
      if (runtime != null) 'runtime': runtime,
      if (syncConfig != null) 'syncConfig': syncConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}/resolvers',
      exceptionFnMap: _exceptionFns,
    );
    return CreateResolverResponse.fromJson(response);
  }

  /// Creates a <code>Type</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [definition] :
  /// The type definition, in GraphQL Schema Definition Language (SDL) format.
  ///
  /// For more information, see the <a
  /// href="http://graphql.org/learn/schema/">GraphQL SDL documentation</a>.
  ///
  /// Parameter [format] :
  /// The type format: SDL or JSON.
  Future<CreateTypeResponse> createType({
    required String apiId,
    required String definition,
    required TypeDefinitionFormat format,
  }) async {
    final $payload = <String, dynamic>{
      'definition': definition,
      'format': format.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/types',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTypeResponse.fromJson(response);
  }

  /// Deletes an <code>ApiCache</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  Future<void> deleteApiCache({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/ApiCaches',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes an API key.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [id] :
  /// The ID for the API key.
  Future<void> deleteApiKey({
    required String apiId,
    required String id,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/apikeys/${Uri.encodeComponent(id)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a <code>DataSource</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [name] :
  /// The name of the data source.
  Future<void> deleteDataSource({
    required String apiId,
    required String name,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/datasources/${Uri.encodeComponent(name)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a custom <code>DomainName</code> object.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [domainName] :
  /// The domain name.
  Future<void> deleteDomainName({
    required String domainName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/v1/domainnames/${Uri.encodeComponent(domainName)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a <code>Function</code>.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [functionId] :
  /// The <code>Function</code> ID.
  Future<void> deleteFunction({
    required String apiId,
    required String functionId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/functions/${Uri.encodeComponent(functionId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a <code>GraphqlApi</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  Future<void> deleteGraphqlApi({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a <code>Resolver</code> object.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [fieldName] :
  /// The resolver field name.
  ///
  /// Parameter [typeName] :
  /// The name of the resolver type.
  Future<void> deleteResolver({
    required String apiId,
    required String fieldName,
    required String typeName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}/resolvers/${Uri.encodeComponent(fieldName)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes a <code>Type</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [typeName] :
  /// The type name.
  Future<void> deleteType({
    required String apiId,
    required String typeName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Removes an <code>ApiAssociation</code> object from a custom domain.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [domainName] :
  /// The domain name.
  Future<void> disassociateApi({
    required String domainName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/domainnames/${Uri.encodeComponent(domainName)}/apiassociation',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Deletes an association between a Merged API and source API using the
  /// source API's identifier and the association ID.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  /// May throw [ConcurrentModificationException].
  ///
  /// Parameter [associationId] :
  /// The ID generated by the AppSync service for the source API association.
  ///
  /// Parameter [sourceApiIdentifier] :
  /// The identifier of the AppSync Source API. This is generated by the AppSync
  /// service. In most cases, source APIs (especially in your account) only
  /// require the API ID value or ARN of the source API. However, source APIs
  /// from other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the source API.
  Future<DisassociateMergedGraphqlApiResponse> disassociateMergedGraphqlApi({
    required String associationId,
    required String sourceApiIdentifier,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/sourceApis/${Uri.encodeComponent(sourceApiIdentifier)}/mergedApiAssociations/${Uri.encodeComponent(associationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DisassociateMergedGraphqlApiResponse.fromJson(response);
  }

  /// Deletes an association between a Merged API and source API using the
  /// Merged API's identifier and the association ID.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  /// May throw [ConcurrentModificationException].
  ///
  /// Parameter [associationId] :
  /// The ID generated by the AppSync service for the source API association.
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  Future<DisassociateSourceGraphqlApiResponse> disassociateSourceGraphqlApi({
    required String associationId,
    required String mergedApiIdentifier,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/v1/mergedApis/${Uri.encodeComponent(mergedApiIdentifier)}/sourceApiAssociations/${Uri.encodeComponent(associationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DisassociateSourceGraphqlApiResponse.fromJson(response);
  }

  /// Evaluates the given code and returns the response. The code definition
  /// requirements depend on the specified runtime. For <code>APPSYNC_JS</code>
  /// runtimes, the code defines the request and response functions. The request
  /// function takes the incoming request after a GraphQL operation is parsed
  /// and converts it into a request configuration for the selected data source
  /// operation. The response function interprets responses from the data source
  /// and maps it to the shape of the GraphQL field output type.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [code] :
  /// The code definition to be evaluated. Note that <code>code</code> and
  /// <code>runtime</code> are both required for this action. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  ///
  /// Parameter [context] :
  /// The map that holds all of the contextual information for your resolver
  /// invocation. A <code>context</code> is required for this action.
  ///
  /// Parameter [runtime] :
  /// The runtime to be used when evaluating the code. Currently, only the
  /// <code>APPSYNC_JS</code> runtime is supported.
  ///
  /// Parameter [function] :
  /// The function within the code to be evaluated. If provided, the valid
  /// values are <code>request</code> and <code>response</code>.
  Future<EvaluateCodeResponse> evaluateCode({
    required String code,
    required String context,
    required AppSyncRuntime runtime,
    String? function,
  }) async {
    final $payload = <String, dynamic>{
      'code': code,
      'context': context,
      'runtime': runtime,
      if (function != null) 'function': function,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/dataplane-evaluatecode',
      exceptionFnMap: _exceptionFns,
    );
    return EvaluateCodeResponse.fromJson(response);
  }

  /// Evaluates a given template and returns the response. The mapping template
  /// can be a request or response template.
  ///
  /// Request templates take the incoming request after a GraphQL operation is
  /// parsed and convert it into a request configuration for the selected data
  /// source operation. Response templates interpret responses from the data
  /// source and map it to the shape of the GraphQL field output type.
  ///
  /// Mapping templates are written in the Apache Velocity Template Language
  /// (VTL).
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [context] :
  /// The map that holds all of the contextual information for your resolver
  /// invocation. A <code>context</code> is required for this action.
  ///
  /// Parameter [template] :
  /// The mapping template; this can be a request or response template. A
  /// <code>template</code> is required for this action.
  Future<EvaluateMappingTemplateResponse> evaluateMappingTemplate({
    required String context,
    required String template,
  }) async {
    final $payload = <String, dynamic>{
      'context': context,
      'template': template,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/dataplane-evaluatetemplate',
      exceptionFnMap: _exceptionFns,
    );
    return EvaluateMappingTemplateResponse.fromJson(response);
  }

  /// Flushes an <code>ApiCache</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  Future<void> flushApiCache({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/FlushCache',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Retrieves an <code>ApiAssociation</code> object.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [domainName] :
  /// The domain name.
  Future<GetApiAssociationResponse> getApiAssociation({
    required String domainName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/domainnames/${Uri.encodeComponent(domainName)}/apiassociation',
      exceptionFnMap: _exceptionFns,
    );
    return GetApiAssociationResponse.fromJson(response);
  }

  /// Retrieves an <code>ApiCache</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  Future<GetApiCacheResponse> getApiCache({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/ApiCaches',
      exceptionFnMap: _exceptionFns,
    );
    return GetApiCacheResponse.fromJson(response);
  }

  /// Retrieves a <code>DataSource</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [name] :
  /// The name of the data source.
  Future<GetDataSourceResponse> getDataSource({
    required String apiId,
    required String name,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/datasources/${Uri.encodeComponent(name)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetDataSourceResponse.fromJson(response);
  }

  /// Retrieves the record of an existing introspection. If the retrieval is
  /// successful, the result of the instrospection will also be returned. If the
  /// retrieval fails the operation, an error message will be returned instead.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [introspectionId] :
  /// The introspection ID. Each introspection contains a unique ID that can be
  /// used to reference the instrospection record.
  ///
  /// Parameter [includeModelsSDL] :
  /// A boolean flag that determines whether SDL should be generated for
  /// introspected types or not. If set to <code>true</code>, each model will
  /// contain an <code>sdl</code> property that contains the SDL for that type.
  /// The SDL only contains the type data and no additional metadata or
  /// directives.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of introspected types that will be returned in a single
  /// response.
  ///
  /// Parameter [nextToken] :
  /// Determines the number of types to be returned in a single response before
  /// paginating. This value is typically taken from <code>nextToken</code>
  /// value from the previous response.
  Future<GetDataSourceIntrospectionResponse> getDataSourceIntrospection({
    required String introspectionId,
    bool? includeModelsSDL,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (includeModelsSDL != null)
        'includeModelsSDL': [includeModelsSDL.toString()],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/datasources/introspections/${Uri.encodeComponent(introspectionId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetDataSourceIntrospectionResponse.fromJson(response);
  }

  /// Retrieves a custom <code>DomainName</code> object.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [domainName] :
  /// The domain name.
  Future<GetDomainNameResponse> getDomainName({
    required String domainName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/domainnames/${Uri.encodeComponent(domainName)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetDomainNameResponse.fromJson(response);
  }

  /// Get a <code>Function</code>.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [functionId] :
  /// The <code>Function</code> ID.
  Future<GetFunctionResponse> getFunction({
    required String apiId,
    required String functionId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/functions/${Uri.encodeComponent(functionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetFunctionResponse.fromJson(response);
  }

  /// Retrieves a <code>GraphqlApi</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [apiId] :
  /// The API ID for the GraphQL API.
  Future<GetGraphqlApiResponse> getGraphqlApi({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetGraphqlApiResponse.fromJson(response);
  }

  /// Retrieves the list of environmental variable key-value pairs associated
  /// with an API by its ID value.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [apiId] :
  /// The ID of the API from which the environmental variable list will be
  /// retrieved.
  Future<GetGraphqlApiEnvironmentVariablesResponse>
      getGraphqlApiEnvironmentVariables({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/environmentVariables',
      exceptionFnMap: _exceptionFns,
    );
    return GetGraphqlApiEnvironmentVariablesResponse.fromJson(response);
  }

  /// Retrieves the introspection schema for a GraphQL API.
  ///
  /// May throw [GraphQLSchemaException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [format] :
  /// The schema format: SDL or JSON.
  ///
  /// Parameter [includeDirectives] :
  /// A flag that specifies whether the schema introspection should contain
  /// directives.
  Future<GetIntrospectionSchemaResponse> getIntrospectionSchema({
    required String apiId,
    required OutputType format,
    bool? includeDirectives,
  }) async {
    final $query = <String, List<String>>{
      'format': [format.value],
      if (includeDirectives != null)
        'includeDirectives': [includeDirectives.toString()],
    };
    final response = await _protocol.sendRaw(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/schema',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetIntrospectionSchemaResponse(
      schema: await response.stream.toBytes(),
    );
  }

  /// Retrieves a <code>Resolver</code> object.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [fieldName] :
  /// The resolver field name.
  ///
  /// Parameter [typeName] :
  /// The resolver type name.
  Future<GetResolverResponse> getResolver({
    required String apiId,
    required String fieldName,
    required String typeName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}/resolvers/${Uri.encodeComponent(fieldName)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetResolverResponse.fromJson(response);
  }

  /// Retrieves the current status of a schema creation operation.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  Future<GetSchemaCreationStatusResponse> getSchemaCreationStatus({
    required String apiId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/schemacreation',
      exceptionFnMap: _exceptionFns,
    );
    return GetSchemaCreationStatusResponse.fromJson(response);
  }

  /// Retrieves a <code>SourceApiAssociation</code> object.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [associationId] :
  /// The ID generated by the AppSync service for the source API association.
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  Future<GetSourceApiAssociationResponse> getSourceApiAssociation({
    required String associationId,
    required String mergedApiIdentifier,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/mergedApis/${Uri.encodeComponent(mergedApiIdentifier)}/sourceApiAssociations/${Uri.encodeComponent(associationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return GetSourceApiAssociationResponse.fromJson(response);
  }

  /// Retrieves a <code>Type</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [format] :
  /// The type format: SDL or JSON.
  ///
  /// Parameter [typeName] :
  /// The type name.
  Future<GetTypeResponse> getType({
    required String apiId,
    required TypeDefinitionFormat format,
    required String typeName,
  }) async {
    final $query = <String, List<String>>{
      'format': [format.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetTypeResponse.fromJson(response);
  }

  /// Lists the API keys for a given API.
  /// <note>
  /// API keys are deleted automatically 60 days after they expire. However,
  /// they may still be included in the response until they have actually been
  /// deleted. You can safely call <code>DeleteApiKey</code> to manually delete
  /// a key before it's automatically deleted.
  /// </note>
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListApiKeysResponse> listApiKeys({
    required String apiId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/apikeys',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListApiKeysResponse.fromJson(response);
  }

  /// Lists the data sources for a given API.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListDataSourcesResponse> listDataSources({
    required String apiId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/datasources',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListDataSourcesResponse.fromJson(response);
  }

  /// Lists multiple custom domain names.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListDomainNamesResponse> listDomainNames({
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/domainnames',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListDomainNamesResponse.fromJson(response);
  }

  /// List multiple functions.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListFunctionsResponse> listFunctions({
    required String apiId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/functions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListFunctionsResponse.fromJson(response);
  }

  /// Lists your GraphQL APIs.
  ///
  /// May throw [BadRequestException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiType] :
  /// The value that indicates whether the GraphQL API is a standard API
  /// (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  ///
  /// Parameter [owner] :
  /// The account owner of the GraphQL API.
  Future<ListGraphqlApisResponse> listGraphqlApis({
    GraphQLApiType? apiType,
    int? maxResults,
    String? nextToken,
    Ownership? owner,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (apiType != null) 'apiType': [apiType.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
      if (owner != null) 'owner': [owner.value],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListGraphqlApisResponse.fromJson(response);
  }

  /// Lists the resolvers for a given API and type.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [typeName] :
  /// The type name.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListResolversResponse> listResolvers({
    required String apiId,
    required String typeName,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}/resolvers',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListResolversResponse.fromJson(response);
  }

  /// List the resolvers that are associated with a specific function.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [functionId] :
  /// The function ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListResolversByFunctionResponse> listResolversByFunction({
    required String apiId,
    required String functionId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/functions/${Uri.encodeComponent(functionId)}/resolvers',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListResolversByFunctionResponse.fromJson(response);
  }

  /// Lists the <code>SourceApiAssociationSummary</code> data.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListSourceApiAssociationsResponse> listSourceApiAssociations({
    required String apiId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/sourceApiAssociations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListSourceApiAssociationsResponse.fromJson(response);
  }

  /// Lists the tags for a resource.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [resourceArn] :
  /// The <code>GraphqlApi</code> Amazon Resource Name (ARN).
  Future<ListTagsForResourceResponse> listTagsForResource({
    required String resourceArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/tags/${Uri.encodeComponent(resourceArn)}',
      exceptionFnMap: _exceptionFns,
    );
    return ListTagsForResourceResponse.fromJson(response);
  }

  /// Lists the types for a given API.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [format] :
  /// The type format: SDL or JSON.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListTypesResponse> listTypes({
    required String apiId,
    required TypeDefinitionFormat format,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      'format': [format.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/types',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTypesResponse.fromJson(response);
  }

  /// Lists <code>Type</code> objects by the source API association ID.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [associationId] :
  /// The ID generated by the AppSync service for the source API association.
  ///
  /// Parameter [format] :
  /// The format type.
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results that you want the request to return.
  ///
  /// Parameter [nextToken] :
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  Future<ListTypesByAssociationResponse> listTypesByAssociation({
    required String associationId,
    required TypeDefinitionFormat format,
    required String mergedApiIdentifier,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      25,
    );
    final $query = <String, List<String>>{
      'format': [format.value],
      if (maxResults != null) 'maxResults': [maxResults.toString()],
      if (nextToken != null) 'nextToken': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/v1/mergedApis/${Uri.encodeComponent(mergedApiIdentifier)}/sourceApiAssociations/${Uri.encodeComponent(associationId)}/types',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTypesByAssociationResponse.fromJson(response);
  }

  /// Creates a list of environmental variables in an API by its ID value.
  ///
  /// When creating an environmental variable, it must follow the constraints
  /// below:
  ///
  /// <ul>
  /// <li>
  /// Both JavaScript and VTL templates support environmental variables.
  /// </li>
  /// <li>
  /// Environmental variables are not evaluated before function invocation.
  /// </li>
  /// <li>
  /// Environmental variables only support string values.
  /// </li>
  /// <li>
  /// Any defined value in an environmental variable is considered a string
  /// literal and not expanded.
  /// </li>
  /// <li>
  /// Variable evaluations should ideally be performed in the function code.
  /// </li>
  /// </ul>
  /// When creating an environmental variable key-value pair, it must follow the
  /// additional constraints below:
  ///
  /// <ul>
  /// <li>
  /// Keys must begin with a letter.
  /// </li>
  /// <li>
  /// Keys must be at least two characters long.
  /// </li>
  /// <li>
  /// Keys can only contain letters, numbers, and the underscore character (_).
  /// </li>
  /// <li>
  /// Values can be up to 512 characters long.
  /// </li>
  /// <li>
  /// You can configure up to 50 key-value pairs in a GraphQL API.
  /// </li>
  /// </ul>
  /// You can create a list of environmental variables by adding it to the
  /// <code>environmentVariables</code> payload as a list in the format
  /// <code>{"key1":"value1","key2":"value2", â€¦}</code>. Note that each call of
  /// the <code>PutGraphqlApiEnvironmentVariables</code> action will result in
  /// the overwriting of the existing environmental variable list of that API.
  /// This means the existing environmental variables will be lost. To avoid
  /// this, you must include all existing and new environmental variables in the
  /// list each time you call this action.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [apiId] :
  /// The ID of the API to which the environmental variable list will be
  /// written.
  ///
  /// Parameter [environmentVariables] :
  /// The list of environmental variables to add to the API.
  ///
  /// When creating an environmental variable key-value pair, it must follow the
  /// additional constraints below:
  ///
  /// <ul>
  /// <li>
  /// Keys must begin with a letter.
  /// </li>
  /// <li>
  /// Keys must be at least two characters long.
  /// </li>
  /// <li>
  /// Keys can only contain letters, numbers, and the underscore character (_).
  /// </li>
  /// <li>
  /// Values can be up to 512 characters long.
  /// </li>
  /// <li>
  /// You can configure up to 50 key-value pairs in a GraphQL API.
  /// </li>
  /// </ul>
  /// You can create a list of environmental variables by adding it to the
  /// <code>environmentVariables</code> payload as a list in the format
  /// <code>{"key1":"value1","key2":"value2", â€¦}</code>. Note that each call of
  /// the <code>PutGraphqlApiEnvironmentVariables</code> action will result in
  /// the overwriting of the existing environmental variable list of that API.
  /// This means the existing environmental variables will be lost. To avoid
  /// this, you must include all existing and new environmental variables in the
  /// list each time you call this action.
  Future<PutGraphqlApiEnvironmentVariablesResponse>
      putGraphqlApiEnvironmentVariables({
    required String apiId,
    required Map<String, String> environmentVariables,
  }) async {
    final $payload = <String, dynamic>{
      'environmentVariables': environmentVariables,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/environmentVariables',
      exceptionFnMap: _exceptionFns,
    );
    return PutGraphqlApiEnvironmentVariablesResponse.fromJson(response);
  }

  /// Creates a new introspection. Returns the <code>introspectionId</code> of
  /// the new introspection after its creation.
  ///
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [rdsDataApiConfig] :
  /// The <code>rdsDataApiConfig</code> object data.
  Future<StartDataSourceIntrospectionResponse> startDataSourceIntrospection({
    RdsDataApiConfig? rdsDataApiConfig,
  }) async {
    final $payload = <String, dynamic>{
      if (rdsDataApiConfig != null) 'rdsDataApiConfig': rdsDataApiConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/datasources/introspections',
      exceptionFnMap: _exceptionFns,
    );
    return StartDataSourceIntrospectionResponse.fromJson(response);
  }

  /// Adds a new schema to your GraphQL API.
  ///
  /// This operation is asynchronous. Use to determine when it has completed.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [definition] :
  /// The schema definition, in GraphQL schema language format.
  Future<StartSchemaCreationResponse> startSchemaCreation({
    required String apiId,
    required Uint8List definition,
  }) async {
    final $payload = <String, dynamic>{
      'definition': base64Encode(definition),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/schemacreation',
      exceptionFnMap: _exceptionFns,
    );
    return StartSchemaCreationResponse.fromJson(response);
  }

  /// Initiates a merge operation. Returns a status that shows the result of the
  /// merge operation.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  /// May throw [ConcurrentModificationException].
  ///
  /// Parameter [associationId] :
  /// The ID generated by the AppSync service for the source API association.
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  Future<StartSchemaMergeResponse> startSchemaMerge({
    required String associationId,
    required String mergedApiIdentifier,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri:
          '/v1/mergedApis/${Uri.encodeComponent(mergedApiIdentifier)}/sourceApiAssociations/${Uri.encodeComponent(associationId)}/merge',
      exceptionFnMap: _exceptionFns,
    );
    return StartSchemaMergeResponse.fromJson(response);
  }

  /// Tags a resource with user-supplied tags.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [resourceArn] :
  /// The <code>GraphqlApi</code> Amazon Resource Name (ARN).
  ///
  /// Parameter [tags] :
  /// A <code>TagMap</code> object.
  Future<void> tagResource({
    required String resourceArn,
    required Map<String, String> tags,
  }) async {
    final $payload = <String, dynamic>{
      'tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/tags/${Uri.encodeComponent(resourceArn)}',
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Untags a resource.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [LimitExceededException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [resourceArn] :
  /// The <code>GraphqlApi</code> Amazon Resource Name (ARN).
  ///
  /// Parameter [tagKeys] :
  /// A list of <code>TagKey</code> objects.
  Future<void> untagResource({
    required String resourceArn,
    required List<String> tagKeys,
  }) async {
    final $query = <String, List<String>>{
      'tagKeys': tagKeys,
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/v1/tags/${Uri.encodeComponent(resourceArn)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
  }

  /// Updates the cache for the GraphQL API.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiCachingBehavior] :
  /// Caching behavior.
  ///
  /// <ul>
  /// <li>
  /// <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.
  /// </li>
  /// <li>
  /// <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are
  /// cached.
  /// </li>
  /// </ul>
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [ttl] :
  /// TTL in seconds for cache entries.
  ///
  /// Valid values are 1â€“3,600 seconds.
  ///
  /// Parameter [type] :
  /// The cache instance type. Valid values are
  ///
  /// <ul>
  /// <li>
  /// <code>SMALL</code>
  /// </li>
  /// <li>
  /// <code>MEDIUM</code>
  /// </li>
  /// <li>
  /// <code>LARGE</code>
  /// </li>
  /// <li>
  /// <code>XLARGE</code>
  /// </li>
  /// <li>
  /// <code>LARGE_2X</code>
  /// </li>
  /// <li>
  /// <code>LARGE_4X</code>
  /// </li>
  /// <li>
  /// <code>LARGE_8X</code> (not available in all regions)
  /// </li>
  /// <li>
  /// <code>LARGE_12X</code>
  /// </li>
  /// </ul>
  /// Historically, instance types were identified by an EC2-style value. As of
  /// July 2020, this is deprecated, and the generic identifiers above should be
  /// used.
  ///
  /// The following legacy instance types are available, but their use is
  /// discouraged:
  ///
  /// <ul>
  /// <li>
  /// <b>T2_SMALL</b>: A t2.small instance type.
  /// </li>
  /// <li>
  /// <b>T2_MEDIUM</b>: A t2.medium instance type.
  /// </li>
  /// <li>
  /// <b>R4_LARGE</b>: A r4.large instance type.
  /// </li>
  /// <li>
  /// <b>R4_XLARGE</b>: A r4.xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_2XLARGE</b>: A r4.2xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_4XLARGE</b>: A r4.4xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_8XLARGE</b>: A r4.8xlarge instance type.
  /// </li>
  /// </ul>
  ///
  /// Parameter [healthMetricsConfig] :
  /// Controls how cache health metrics will be emitted to CloudWatch. Cache
  /// health metrics include:
  ///
  /// <ul>
  /// <li>
  /// NetworkBandwidthOutAllowanceExceeded: The network packets dropped because
  /// the throughput exceeded the aggregated bandwidth limit. This is useful for
  /// diagnosing bottlenecks in a cache configuration.
  /// </li>
  /// <li>
  /// EngineCPUUtilization: The CPU utilization (percentage) allocated to the
  /// Redis process. This is useful for diagnosing bottlenecks in a cache
  /// configuration.
  /// </li>
  /// </ul>
  /// Metrics will be recorded by API ID. You can set the value to
  /// <code>ENABLED</code> or <code>DISABLED</code>.
  Future<UpdateApiCacheResponse> updateApiCache({
    required ApiCachingBehavior apiCachingBehavior,
    required String apiId,
    required int ttl,
    required ApiCacheType type,
    CacheHealthMetricsConfig? healthMetricsConfig,
  }) async {
    final $payload = <String, dynamic>{
      'apiCachingBehavior': apiCachingBehavior.value,
      'ttl': ttl,
      'type': type.value,
      if (healthMetricsConfig != null)
        'healthMetricsConfig': healthMetricsConfig.value,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}/ApiCaches/update',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateApiCacheResponse.fromJson(response);
  }

  /// Updates an API key. You can update the key as long as it's not deleted.
  ///
  /// May throw [BadRequestException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  /// May throw [ApiKeyValidityOutOfBoundsException].
  ///
  /// Parameter [apiId] :
  /// The ID for the GraphQL API.
  ///
  /// Parameter [id] :
  /// The API key ID.
  ///
  /// Parameter [description] :
  /// A description of the purpose of the API key.
  ///
  /// Parameter [expires] :
  /// From the update time, the time after which the API key expires. The date
  /// is represented as seconds since the epoch. For more information, see .
  Future<UpdateApiKeyResponse> updateApiKey({
    required String apiId,
    required String id,
    String? description,
    int? expires,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'description': description,
      if (expires != null) 'expires': expires,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/apikeys/${Uri.encodeComponent(id)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateApiKeyResponse.fromJson(response);
  }

  /// Updates a <code>DataSource</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [name] :
  /// The new name for the data source.
  ///
  /// Parameter [type] :
  /// The new data source type.
  ///
  /// Parameter [description] :
  /// The new description for the data source.
  ///
  /// Parameter [dynamodbConfig] :
  /// The new Amazon DynamoDB configuration.
  ///
  /// Parameter [elasticsearchConfig] :
  /// The new OpenSearch configuration.
  ///
  /// As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch
  /// Service. This configuration is deprecated. Instead, use
  /// <a>UpdateDataSourceRequest$openSearchServiceConfig</a> to update an
  /// OpenSearch data source.
  ///
  /// Parameter [eventBridgeConfig] :
  /// The new Amazon EventBridge settings.
  ///
  /// Parameter [httpConfig] :
  /// The new HTTP endpoint configuration.
  ///
  /// Parameter [lambdaConfig] :
  /// The new Lambda configuration.
  ///
  /// Parameter [metricsConfig] :
  /// Enables or disables enhanced data source metrics for specified data
  /// sources. Note that <code>metricsConfig</code> won't be used unless the
  /// <code>dataSourceLevelMetricsBehavior</code> value is set to
  /// <code>PER_DATA_SOURCE_METRICS</code>. If the
  /// <code>dataSourceLevelMetricsBehavior</code> is set to
  /// <code>FULL_REQUEST_DATA_SOURCE_METRICS</code> instead,
  /// <code>metricsConfig</code> will be ignored. However, you can still set its
  /// value.
  ///
  /// <code>metricsConfig</code> can be <code>ENABLED</code> or
  /// <code>DISABLED</code>.
  ///
  /// Parameter [openSearchServiceConfig] :
  /// The new OpenSearch configuration.
  ///
  /// Parameter [relationalDatabaseConfig] :
  /// The new relational database configuration.
  ///
  /// Parameter [serviceRoleArn] :
  /// The new service role Amazon Resource Name (ARN) for the data source.
  Future<UpdateDataSourceResponse> updateDataSource({
    required String apiId,
    required String name,
    required DataSourceType type,
    String? description,
    DynamodbDataSourceConfig? dynamodbConfig,
    ElasticsearchDataSourceConfig? elasticsearchConfig,
    EventBridgeDataSourceConfig? eventBridgeConfig,
    HttpDataSourceConfig? httpConfig,
    LambdaDataSourceConfig? lambdaConfig,
    DataSourceLevelMetricsConfig? metricsConfig,
    OpenSearchServiceDataSourceConfig? openSearchServiceConfig,
    RelationalDatabaseDataSourceConfig? relationalDatabaseConfig,
    String? serviceRoleArn,
  }) async {
    final $payload = <String, dynamic>{
      'type': type.value,
      if (description != null) 'description': description,
      if (dynamodbConfig != null) 'dynamodbConfig': dynamodbConfig,
      if (elasticsearchConfig != null)
        'elasticsearchConfig': elasticsearchConfig,
      if (eventBridgeConfig != null) 'eventBridgeConfig': eventBridgeConfig,
      if (httpConfig != null) 'httpConfig': httpConfig,
      if (lambdaConfig != null) 'lambdaConfig': lambdaConfig,
      if (metricsConfig != null) 'metricsConfig': metricsConfig.value,
      if (openSearchServiceConfig != null)
        'openSearchServiceConfig': openSearchServiceConfig,
      if (relationalDatabaseConfig != null)
        'relationalDatabaseConfig': relationalDatabaseConfig,
      if (serviceRoleArn != null) 'serviceRoleArn': serviceRoleArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/datasources/${Uri.encodeComponent(name)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDataSourceResponse.fromJson(response);
  }

  /// Updates a custom <code>DomainName</code> object.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  ///
  /// Parameter [domainName] :
  /// The domain name.
  ///
  /// Parameter [description] :
  /// A description of the <code>DomainName</code>.
  Future<UpdateDomainNameResponse> updateDomainName({
    required String domainName,
    String? description,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'description': description,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/domainnames/${Uri.encodeComponent(domainName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDomainNameResponse.fromJson(response);
  }

  /// Updates a <code>Function</code> object.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [apiId] :
  /// The GraphQL API ID.
  ///
  /// Parameter [dataSourceName] :
  /// The <code>Function</code> <code>DataSource</code> name.
  ///
  /// Parameter [functionId] :
  /// The function ID.
  ///
  /// Parameter [name] :
  /// The <code>Function</code> name.
  ///
  /// Parameter [code] :
  /// The <code>function</code> code that contains the request and response
  /// functions. When code is used, the <code>runtime</code> is required. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  ///
  /// Parameter [description] :
  /// The <code>Function</code> description.
  ///
  /// Parameter [functionVersion] :
  /// The <code>version</code> of the request mapping template. Currently, the
  /// supported value is 2018-05-29. Note that when using VTL and mapping
  /// templates, the <code>functionVersion</code> is required.
  ///
  /// Parameter [maxBatchSize] :
  /// The maximum batching size for a resolver.
  ///
  /// Parameter [requestMappingTemplate] :
  /// The <code>Function</code> request mapping template. Functions support only
  /// the 2018-05-29 version of the request mapping template.
  ///
  /// Parameter [responseMappingTemplate] :
  /// The <code>Function</code> request mapping template.
  Future<UpdateFunctionResponse> updateFunction({
    required String apiId,
    required String dataSourceName,
    required String functionId,
    required String name,
    String? code,
    String? description,
    String? functionVersion,
    int? maxBatchSize,
    String? requestMappingTemplate,
    String? responseMappingTemplate,
    AppSyncRuntime? runtime,
    SyncConfig? syncConfig,
  }) async {
    _s.validateNumRange(
      'maxBatchSize',
      maxBatchSize,
      0,
      2000,
    );
    final $payload = <String, dynamic>{
      'dataSourceName': dataSourceName,
      'name': name,
      if (code != null) 'code': code,
      if (description != null) 'description': description,
      if (functionVersion != null) 'functionVersion': functionVersion,
      if (maxBatchSize != null) 'maxBatchSize': maxBatchSize,
      if (requestMappingTemplate != null)
        'requestMappingTemplate': requestMappingTemplate,
      if (responseMappingTemplate != null)
        'responseMappingTemplate': responseMappingTemplate,
      if (runtime != null) 'runtime': runtime,
      if (syncConfig != null) 'syncConfig': syncConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/functions/${Uri.encodeComponent(functionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateFunctionResponse.fromJson(response);
  }

  /// Updates a <code>GraphqlApi</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [AccessDeniedException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [authenticationType] :
  /// The new authentication type for the <code>GraphqlApi</code> object.
  ///
  /// Parameter [name] :
  /// The new name for the <code>GraphqlApi</code> object.
  ///
  /// Parameter [additionalAuthenticationProviders] :
  /// A list of additional authentication providers for the
  /// <code>GraphqlApi</code> API.
  ///
  /// Parameter [enhancedMetricsConfig] :
  /// The <code>enhancedMetricsConfig</code> object.
  ///
  /// Parameter [introspectionConfig] :
  /// Sets the value of the GraphQL API to enable (<code>ENABLED</code>) or
  /// disable (<code>DISABLED</code>) introspection. If no value is provided,
  /// the introspection configuration will be set to <code>ENABLED</code> by
  /// default. This field will produce an error if the operation attempts to use
  /// the introspection feature while this field is disabled.
  ///
  /// For more information about introspection, see <a
  /// href="https://graphql.org/learn/introspection/">GraphQL introspection</a>.
  ///
  /// Parameter [lambdaAuthorizerConfig] :
  /// Configuration for Lambda function authorization.
  ///
  /// Parameter [logConfig] :
  /// The Amazon CloudWatch Logs configuration for the <code>GraphqlApi</code>
  /// object.
  ///
  /// Parameter [mergedApiExecutionRoleArn] :
  /// The Identity and Access Management service role ARN for a merged API. The
  /// AppSync service assumes this role on behalf of the Merged API to validate
  /// access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code>
  /// to update the merged API endpoint with the source API changes
  /// automatically.
  ///
  /// Parameter [openIDConnectConfig] :
  /// The OpenID Connect configuration for the <code>GraphqlApi</code> object.
  ///
  /// Parameter [ownerContact] :
  /// The owner contact information for an API resource.
  ///
  /// This field accepts any string input with a length of 0 - 256 characters.
  ///
  /// Parameter [queryDepthLimit] :
  /// The maximum depth a query can have in a single request. Depth refers to
  /// the amount of nested levels allowed in the body of query. The default
  /// value is <code>0</code> (or unspecified), which indicates there's no depth
  /// limit. If you set a limit, it can be between <code>1</code> and
  /// <code>75</code> nested levels. This field will produce a limit error if
  /// the operation falls out of bounds.
  ///
  /// Note that fields can still be set to nullable or non-nullable. If a
  /// non-nullable field produces an error, the error will be thrown upwards to
  /// the first nullable field available.
  ///
  /// Parameter [resolverCountLimit] :
  /// The maximum number of resolvers that can be invoked in a single request.
  /// The default value is <code>0</code> (or unspecified), which will set the
  /// limit to <code>10000</code>. When specified, the limit value can be
  /// between <code>1</code> and <code>10000</code>. This field will produce a
  /// limit error if the operation falls out of bounds.
  ///
  /// Parameter [userPoolConfig] :
  /// The new Amazon Cognito user pool configuration for the
  /// <code>~GraphqlApi</code> object.
  ///
  /// Parameter [xrayEnabled] :
  /// A flag indicating whether to use X-Ray tracing for the
  /// <code>GraphqlApi</code>.
  Future<UpdateGraphqlApiResponse> updateGraphqlApi({
    required String apiId,
    required AuthenticationType authenticationType,
    required String name,
    List<AdditionalAuthenticationProvider>? additionalAuthenticationProviders,
    EnhancedMetricsConfig? enhancedMetricsConfig,
    GraphQLApiIntrospectionConfig? introspectionConfig,
    LambdaAuthorizerConfig? lambdaAuthorizerConfig,
    LogConfig? logConfig,
    String? mergedApiExecutionRoleArn,
    OpenIDConnectConfig? openIDConnectConfig,
    String? ownerContact,
    int? queryDepthLimit,
    int? resolverCountLimit,
    UserPoolConfig? userPoolConfig,
    bool? xrayEnabled,
  }) async {
    _s.validateNumRange(
      'queryDepthLimit',
      queryDepthLimit,
      0,
      75,
    );
    _s.validateNumRange(
      'resolverCountLimit',
      resolverCountLimit,
      0,
      10000,
    );
    final $payload = <String, dynamic>{
      'authenticationType': authenticationType.value,
      'name': name,
      if (additionalAuthenticationProviders != null)
        'additionalAuthenticationProviders': additionalAuthenticationProviders,
      if (enhancedMetricsConfig != null)
        'enhancedMetricsConfig': enhancedMetricsConfig,
      if (introspectionConfig != null)
        'introspectionConfig': introspectionConfig.value,
      if (lambdaAuthorizerConfig != null)
        'lambdaAuthorizerConfig': lambdaAuthorizerConfig,
      if (logConfig != null) 'logConfig': logConfig,
      if (mergedApiExecutionRoleArn != null)
        'mergedApiExecutionRoleArn': mergedApiExecutionRoleArn,
      if (openIDConnectConfig != null)
        'openIDConnectConfig': openIDConnectConfig,
      if (ownerContact != null) 'ownerContact': ownerContact,
      if (queryDepthLimit != null) 'queryDepthLimit': queryDepthLimit,
      if (resolverCountLimit != null) 'resolverCountLimit': resolverCountLimit,
      if (userPoolConfig != null) 'userPoolConfig': userPoolConfig,
      if (xrayEnabled != null) 'xrayEnabled': xrayEnabled,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/v1/apis/${Uri.encodeComponent(apiId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateGraphqlApiResponse.fromJson(response);
  }

  /// Updates a <code>Resolver</code> object.
  ///
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  /// May throw [BadRequestException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [fieldName] :
  /// The new field name.
  ///
  /// Parameter [typeName] :
  /// The new type name.
  ///
  /// Parameter [cachingConfig] :
  /// The caching configuration for the resolver.
  ///
  /// Parameter [code] :
  /// The <code>resolver</code> code that contains the request and response
  /// functions. When code is used, the <code>runtime</code> is required. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  ///
  /// Parameter [dataSourceName] :
  /// The new data source name.
  ///
  /// Parameter [kind] :
  /// The resolver type.
  ///
  /// <ul>
  /// <li>
  /// <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver
  /// type. You can use a UNIT resolver to run a GraphQL query against a single
  /// data source.
  /// </li>
  /// <li>
  /// <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver
  /// to invoke a series of <code>Function</code> objects in a serial manner.
  /// You can use a pipeline resolver to run a GraphQL query against multiple
  /// data sources.
  /// </li>
  /// </ul>
  ///
  /// Parameter [maxBatchSize] :
  /// The maximum batching size for a resolver.
  ///
  /// Parameter [metricsConfig] :
  /// Enables or disables enhanced resolver metrics for specified resolvers.
  /// Note that <code>metricsConfig</code> won't be used unless the
  /// <code>resolverLevelMetricsBehavior</code> value is set to
  /// <code>PER_RESOLVER_METRICS</code>. If the
  /// <code>resolverLevelMetricsBehavior</code> is set to
  /// <code>FULL_REQUEST_RESOLVER_METRICS</code> instead,
  /// <code>metricsConfig</code> will be ignored. However, you can still set its
  /// value.
  ///
  /// <code>metricsConfig</code> can be <code>ENABLED</code> or
  /// <code>DISABLED</code>.
  ///
  /// Parameter [pipelineConfig] :
  /// The <code>PipelineConfig</code>.
  ///
  /// Parameter [requestMappingTemplate] :
  /// The new request mapping template.
  ///
  /// A resolver uses a request mapping template to convert a GraphQL expression
  /// into a format that a data source can understand. Mapping templates are
  /// written in Apache Velocity Template Language (VTL).
  ///
  /// VTL request mapping templates are optional when using an Lambda data
  /// source. For all other data sources, VTL request and response mapping
  /// templates are required.
  ///
  /// Parameter [responseMappingTemplate] :
  /// The new response mapping template.
  ///
  /// Parameter [syncConfig] :
  /// The <code>SyncConfig</code> for a resolver attached to a versioned data
  /// source.
  Future<UpdateResolverResponse> updateResolver({
    required String apiId,
    required String fieldName,
    required String typeName,
    CachingConfig? cachingConfig,
    String? code,
    String? dataSourceName,
    ResolverKind? kind,
    int? maxBatchSize,
    ResolverLevelMetricsConfig? metricsConfig,
    PipelineConfig? pipelineConfig,
    String? requestMappingTemplate,
    String? responseMappingTemplate,
    AppSyncRuntime? runtime,
    SyncConfig? syncConfig,
  }) async {
    _s.validateNumRange(
      'maxBatchSize',
      maxBatchSize,
      0,
      2000,
    );
    final $payload = <String, dynamic>{
      if (cachingConfig != null) 'cachingConfig': cachingConfig,
      if (code != null) 'code': code,
      if (dataSourceName != null) 'dataSourceName': dataSourceName,
      if (kind != null) 'kind': kind.value,
      if (maxBatchSize != null) 'maxBatchSize': maxBatchSize,
      if (metricsConfig != null) 'metricsConfig': metricsConfig.value,
      if (pipelineConfig != null) 'pipelineConfig': pipelineConfig,
      if (requestMappingTemplate != null)
        'requestMappingTemplate': requestMappingTemplate,
      if (responseMappingTemplate != null)
        'responseMappingTemplate': responseMappingTemplate,
      if (runtime != null) 'runtime': runtime,
      if (syncConfig != null) 'syncConfig': syncConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}/resolvers/${Uri.encodeComponent(fieldName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateResolverResponse.fromJson(response);
  }

  /// Updates some of the configuration choices of a particular source API
  /// association.
  ///
  /// May throw [UnauthorizedException].
  /// May throw [BadRequestException].
  /// May throw [InternalFailureException].
  /// May throw [NotFoundException].
  /// May throw [ConcurrentModificationException].
  ///
  /// Parameter [associationId] :
  /// The ID generated by the AppSync service for the source API association.
  ///
  /// Parameter [mergedApiIdentifier] :
  /// The identifier of the AppSync Merged API. This is generated by the AppSync
  /// service. In most cases, Merged APIs (especially in your account) only
  /// require the API ID value or ARN of the merged API. However, Merged APIs in
  /// other accounts (cross-account use cases) strictly require the full
  /// resource ARN of the merged API.
  ///
  /// Parameter [description] :
  /// The description field.
  ///
  /// Parameter [sourceApiAssociationConfig] :
  /// The <code>SourceApiAssociationConfig</code> object data.
  Future<UpdateSourceApiAssociationResponse> updateSourceApiAssociation({
    required String associationId,
    required String mergedApiIdentifier,
    String? description,
    SourceApiAssociationConfig? sourceApiAssociationConfig,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'description': description,
      if (sourceApiAssociationConfig != null)
        'sourceApiAssociationConfig': sourceApiAssociationConfig,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/mergedApis/${Uri.encodeComponent(mergedApiIdentifier)}/sourceApiAssociations/${Uri.encodeComponent(associationId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateSourceApiAssociationResponse.fromJson(response);
  }

  /// Updates a <code>Type</code> object.
  ///
  /// May throw [BadRequestException].
  /// May throw [ConcurrentModificationException].
  /// May throw [NotFoundException].
  /// May throw [UnauthorizedException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [apiId] :
  /// The API ID.
  ///
  /// Parameter [format] :
  /// The new type format: SDL or JSON.
  ///
  /// Parameter [typeName] :
  /// The new type name.
  ///
  /// Parameter [definition] :
  /// The new definition.
  Future<UpdateTypeResponse> updateType({
    required String apiId,
    required TypeDefinitionFormat format,
    required String typeName,
    String? definition,
  }) async {
    final $payload = <String, dynamic>{
      'format': format.value,
      if (definition != null) 'definition': definition,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/v1/apis/${Uri.encodeComponent(apiId)}/types/${Uri.encodeComponent(typeName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTypeResponse.fromJson(response);
  }
}

/// Describes an additional authentication provider.
class AdditionalAuthenticationProvider {
  /// The authentication type: API key, Identity and Access Management (IAM),
  /// OpenID Connect (OIDC), Amazon Cognito user pools, or Lambda.
  final AuthenticationType? authenticationType;

  /// Configuration for Lambda function authorization.
  final LambdaAuthorizerConfig? lambdaAuthorizerConfig;

  /// The OIDC configuration.
  final OpenIDConnectConfig? openIDConnectConfig;

  /// The Amazon Cognito user pool configuration.
  final CognitoUserPoolConfig? userPoolConfig;

  AdditionalAuthenticationProvider({
    this.authenticationType,
    this.lambdaAuthorizerConfig,
    this.openIDConnectConfig,
    this.userPoolConfig,
  });

  factory AdditionalAuthenticationProvider.fromJson(Map<String, dynamic> json) {
    return AdditionalAuthenticationProvider(
      authenticationType: (json['authenticationType'] as String?)
          ?.let(AuthenticationType.fromString),
      lambdaAuthorizerConfig: json['lambdaAuthorizerConfig'] != null
          ? LambdaAuthorizerConfig.fromJson(
              json['lambdaAuthorizerConfig'] as Map<String, dynamic>)
          : null,
      openIDConnectConfig: json['openIDConnectConfig'] != null
          ? OpenIDConnectConfig.fromJson(
              json['openIDConnectConfig'] as Map<String, dynamic>)
          : null,
      userPoolConfig: json['userPoolConfig'] != null
          ? CognitoUserPoolConfig.fromJson(
              json['userPoolConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final authenticationType = this.authenticationType;
    final lambdaAuthorizerConfig = this.lambdaAuthorizerConfig;
    final openIDConnectConfig = this.openIDConnectConfig;
    final userPoolConfig = this.userPoolConfig;
    return {
      if (authenticationType != null)
        'authenticationType': authenticationType.value,
      if (lambdaAuthorizerConfig != null)
        'lambdaAuthorizerConfig': lambdaAuthorizerConfig,
      if (openIDConnectConfig != null)
        'openIDConnectConfig': openIDConnectConfig,
      if (userPoolConfig != null) 'userPoolConfig': userPoolConfig,
    };
  }
}

/// Describes an <code>ApiAssociation</code> object.
class ApiAssociation {
  /// The API ID.
  final String? apiId;

  /// Identifies the status of an association.
  ///
  /// <ul>
  /// <li>
  /// <b>PROCESSING</b>: The API association is being created. You cannot modify
  /// association requests during processing.
  /// </li>
  /// <li>
  /// <b>SUCCESS</b>: The API association was successful. You can modify
  /// associations after success.
  /// </li>
  /// <li>
  /// <b>FAILED</b>: The API association has failed. You can modify associations
  /// after failure.
  /// </li>
  /// </ul>
  final AssociationStatus? associationStatus;

  /// Details about the last deployment status.
  final String? deploymentDetail;

  /// The domain name.
  final String? domainName;

  ApiAssociation({
    this.apiId,
    this.associationStatus,
    this.deploymentDetail,
    this.domainName,
  });

  factory ApiAssociation.fromJson(Map<String, dynamic> json) {
    return ApiAssociation(
      apiId: json['apiId'] as String?,
      associationStatus: (json['associationStatus'] as String?)
          ?.let(AssociationStatus.fromString),
      deploymentDetail: json['deploymentDetail'] as String?,
      domainName: json['domainName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final apiId = this.apiId;
    final associationStatus = this.associationStatus;
    final deploymentDetail = this.deploymentDetail;
    final domainName = this.domainName;
    return {
      if (apiId != null) 'apiId': apiId,
      if (associationStatus != null)
        'associationStatus': associationStatus.value,
      if (deploymentDetail != null) 'deploymentDetail': deploymentDetail,
      if (domainName != null) 'domainName': domainName,
    };
  }
}

/// The <code>ApiCache</code> object.
class ApiCache {
  /// Caching behavior.
  ///
  /// <ul>
  /// <li>
  /// <b>FULL_REQUEST_CACHING</b>: All requests are fully cached.
  /// </li>
  /// <li>
  /// <b>PER_RESOLVER_CACHING</b>: Individual resolvers that you specify are
  /// cached.
  /// </li>
  /// </ul>
  final ApiCachingBehavior? apiCachingBehavior;

  /// At-rest encryption flag for cache. You cannot update this setting after
  /// creation.
  final bool? atRestEncryptionEnabled;

  /// Controls how cache health metrics will be emitted to CloudWatch. Cache
  /// health metrics include:
  ///
  /// <ul>
  /// <li>
  /// NetworkBandwidthOutAllowanceExceeded: The network packets dropped because
  /// the throughput exceeded the aggregated bandwidth limit. This is useful for
  /// diagnosing bottlenecks in a cache configuration.
  /// </li>
  /// <li>
  /// EngineCPUUtilization: The CPU utilization (percentage) allocated to the
  /// Redis process. This is useful for diagnosing bottlenecks in a cache
  /// configuration.
  /// </li>
  /// </ul>
  /// Metrics will be recorded by API ID. You can set the value to
  /// <code>ENABLED</code> or <code>DISABLED</code>.
  final CacheHealthMetricsConfig? healthMetricsConfig;

  /// The cache instance status.
  ///
  /// <ul>
  /// <li>
  /// <b>AVAILABLE</b>: The instance is available for use.
  /// </li>
  /// <li>
  /// <b>CREATING</b>: The instance is currently creating.
  /// </li>
  /// <li>
  /// <b>DELETING</b>: The instance is currently deleting.
  /// </li>
  /// <li>
  /// <b>MODIFYING</b>: The instance is currently modifying.
  /// </li>
  /// <li>
  /// <b>FAILED</b>: The instance has failed creation.
  /// </li>
  /// </ul>
  final ApiCacheStatus? status;

  /// Transit encryption flag when connecting to cache. You cannot update this
  /// setting after creation.
  final bool? transitEncryptionEnabled;

  /// TTL in seconds for cache entries.
  ///
  /// Valid values are 1â€“3,600 seconds.
  final int? ttl;

  /// The cache instance type. Valid values are
  ///
  /// <ul>
  /// <li>
  /// <code>SMALL</code>
  /// </li>
  /// <li>
  /// <code>MEDIUM</code>
  /// </li>
  /// <li>
  /// <code>LARGE</code>
  /// </li>
  /// <li>
  /// <code>XLARGE</code>
  /// </li>
  /// <li>
  /// <code>LARGE_2X</code>
  /// </li>
  /// <li>
  /// <code>LARGE_4X</code>
  /// </li>
  /// <li>
  /// <code>LARGE_8X</code> (not available in all regions)
  /// </li>
  /// <li>
  /// <code>LARGE_12X</code>
  /// </li>
  /// </ul>
  /// Historically, instance types were identified by an EC2-style value. As of
  /// July 2020, this is deprecated, and the generic identifiers above should be
  /// used.
  ///
  /// The following legacy instance types are available, but their use is
  /// discouraged:
  ///
  /// <ul>
  /// <li>
  /// <b>T2_SMALL</b>: A t2.small instance type.
  /// </li>
  /// <li>
  /// <b>T2_MEDIUM</b>: A t2.medium instance type.
  /// </li>
  /// <li>
  /// <b>R4_LARGE</b>: A r4.large instance type.
  /// </li>
  /// <li>
  /// <b>R4_XLARGE</b>: A r4.xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_2XLARGE</b>: A r4.2xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_4XLARGE</b>: A r4.4xlarge instance type.
  /// </li>
  /// <li>
  /// <b>R4_8XLARGE</b>: A r4.8xlarge instance type.
  /// </li>
  /// </ul>
  final ApiCacheType? type;

  ApiCache({
    this.apiCachingBehavior,
    this.atRestEncryptionEnabled,
    this.healthMetricsConfig,
    this.status,
    this.transitEncryptionEnabled,
    this.ttl,
    this.type,
  });

  factory ApiCache.fromJson(Map<String, dynamic> json) {
    return ApiCache(
      apiCachingBehavior: (json['apiCachingBehavior'] as String?)
          ?.let(ApiCachingBehavior.fromString),
      atRestEncryptionEnabled: json['atRestEncryptionEnabled'] as bool?,
      healthMetricsConfig: (json['healthMetricsConfig'] as String?)
          ?.let(CacheHealthMetricsConfig.fromString),
      status: (json['status'] as String?)?.let(ApiCacheStatus.fromString),
      transitEncryptionEnabled: json['transitEncryptionEnabled'] as bool?,
      ttl: json['ttl'] as int?,
      type: (json['type'] as String?)?.let(ApiCacheType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final apiCachingBehavior = this.apiCachingBehavior;
    final atRestEncryptionEnabled = this.atRestEncryptionEnabled;
    final healthMetricsConfig = this.healthMetricsConfig;
    final status = this.status;
    final transitEncryptionEnabled = this.transitEncryptionEnabled;
    final ttl = this.ttl;
    final type = this.type;
    return {
      if (apiCachingBehavior != null)
        'apiCachingBehavior': apiCachingBehavior.value,
      if (atRestEncryptionEnabled != null)
        'atRestEncryptionEnabled': atRestEncryptionEnabled,
      if (healthMetricsConfig != null)
        'healthMetricsConfig': healthMetricsConfig.value,
      if (status != null) 'status': status.value,
      if (transitEncryptionEnabled != null)
        'transitEncryptionEnabled': transitEncryptionEnabled,
      if (ttl != null) 'ttl': ttl,
      if (type != null) 'type': type.value,
    };
  }
}

enum ApiCacheStatus {
  available('AVAILABLE'),
  creating('CREATING'),
  deleting('DELETING'),
  modifying('MODIFYING'),
  failed('FAILED'),
  ;

  final String value;

  const ApiCacheStatus(this.value);

  static ApiCacheStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ApiCacheStatus'));
}

enum ApiCacheType {
  t2Small('T2_SMALL'),
  t2Medium('T2_MEDIUM'),
  r4Large('R4_LARGE'),
  r4Xlarge('R4_XLARGE'),
  r4_2xlarge('R4_2XLARGE'),
  r4_4xlarge('R4_4XLARGE'),
  r4_8xlarge('R4_8XLARGE'),
  small('SMALL'),
  medium('MEDIUM'),
  large('LARGE'),
  xlarge('XLARGE'),
  large_2x('LARGE_2X'),
  large_4x('LARGE_4X'),
  large_8x('LARGE_8X'),
  large_12x('LARGE_12X'),
  ;

  final String value;

  const ApiCacheType(this.value);

  static ApiCacheType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ApiCacheType'));
}

enum ApiCachingBehavior {
  fullRequestCaching('FULL_REQUEST_CACHING'),
  perResolverCaching('PER_RESOLVER_CACHING'),
  ;

  final String value;

  const ApiCachingBehavior(this.value);

  static ApiCachingBehavior fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum ApiCachingBehavior'));
}

/// Describes an API key.
///
/// Customers invoke AppSync GraphQL API operations with API keys as an identity
/// mechanism. There are two key versions:
///
/// <b>da1</b>: We introduced this version at launch in November 2017. These
/// keys always expire after 7 days. Amazon DynamoDB TTL manages key expiration.
/// These keys ceased to be valid after February 21, 2018, and they should no
/// longer be used.
///
/// <ul>
/// <li>
/// <code>ListApiKeys</code> returns the expiration time in milliseconds.
/// </li>
/// <li>
/// <code>CreateApiKey</code> returns the expiration time in milliseconds.
/// </li>
/// <li>
/// <code>UpdateApiKey</code> is not available for this key version.
/// </li>
/// <li>
/// <code>DeleteApiKey</code> deletes the item from the table.
/// </li>
/// <li>
/// Expiration is stored in DynamoDB as milliseconds. This results in a bug
/// where keys are not automatically deleted because DynamoDB expects the TTL to
/// be stored in seconds. As a one-time action, we deleted these keys from the
/// table on February 21, 2018.
/// </li>
/// </ul>
/// <b>da2</b>: We introduced this version in February 2018 when AppSync added
/// support to extend key expiration.
///
/// <ul>
/// <li>
/// <code>ListApiKeys</code> returns the expiration time and deletion time in
/// seconds.
/// </li>
/// <li>
/// <code>CreateApiKey</code> returns the expiration time and deletion time in
/// seconds and accepts a user-provided expiration time in seconds.
/// </li>
/// <li>
/// <code>UpdateApiKey</code> returns the expiration time and and deletion time
/// in seconds and accepts a user-provided expiration time in seconds. Expired
/// API keys are kept for 60 days after the expiration time. You can update the
/// key expiration time as long as the key isn't deleted.
/// </li>
/// <li>
/// <code>DeleteApiKey</code> deletes the item from the table.
/// </li>
/// <li>
/// Expiration is stored in DynamoDB as seconds. After the expiration time,
/// using the key to authenticate will fail. However, you can reinstate the key
/// before deletion.
/// </li>
/// <li>
/// Deletion is stored in DynamoDB as seconds. The key is deleted after deletion
/// time.
/// </li>
/// </ul>
class ApiKey {
  /// The time after which the API key is deleted. The date is represented as
  /// seconds since the epoch, rounded down to the nearest hour.
  final int? deletes;

  /// A description of the purpose of the API key.
  final String? description;

  /// The time after which the API key expires. The date is represented as seconds
  /// since the epoch, rounded down to the nearest hour.
  final int? expires;

  /// The API key ID.
  final String? id;

  ApiKey({
    this.deletes,
    this.description,
    this.expires,
    this.id,
  });

  factory ApiKey.fromJson(Map<String, dynamic> json) {
    return ApiKey(
      deletes: json['deletes'] as int?,
      description: json['description'] as String?,
      expires: json['expires'] as int?,
      id: json['id'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final deletes = this.deletes;
    final description = this.description;
    final expires = this.expires;
    final id = this.id;
    return {
      if (deletes != null) 'deletes': deletes,
      if (description != null) 'description': description,
      if (expires != null) 'expires': expires,
      if (id != null) 'id': id,
    };
  }
}

/// Describes a runtime used by an Amazon Web Services AppSync pipeline resolver
/// or Amazon Web Services AppSync function. Specifies the name and version of
/// the runtime to use. Note that if a runtime is specified, code must also be
/// specified.
class AppSyncRuntime {
  /// The <code>name</code> of the runtime to use. Currently, the only allowed
  /// value is <code>APPSYNC_JS</code>.
  final RuntimeName name;

  /// The <code>version</code> of the runtime to use. Currently, the only allowed
  /// version is <code>1.0.0</code>.
  final String runtimeVersion;

  AppSyncRuntime({
    required this.name,
    required this.runtimeVersion,
  });

  factory AppSyncRuntime.fromJson(Map<String, dynamic> json) {
    return AppSyncRuntime(
      name: RuntimeName.fromString((json['name'] as String)),
      runtimeVersion: json['runtimeVersion'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final runtimeVersion = this.runtimeVersion;
    return {
      'name': name.value,
      'runtimeVersion': runtimeVersion,
    };
  }
}

class AssociateApiResponse {
  /// The <code>ApiAssociation</code> object.
  final ApiAssociation? apiAssociation;

  AssociateApiResponse({
    this.apiAssociation,
  });

  factory AssociateApiResponse.fromJson(Map<String, dynamic> json) {
    return AssociateApiResponse(
      apiAssociation: json['apiAssociation'] != null
          ? ApiAssociation.fromJson(
              json['apiAssociation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiAssociation = this.apiAssociation;
    return {
      if (apiAssociation != null) 'apiAssociation': apiAssociation,
    };
  }
}

class AssociateMergedGraphqlApiResponse {
  /// The <code>SourceApiAssociation</code> object data.
  final SourceApiAssociation? sourceApiAssociation;

  AssociateMergedGraphqlApiResponse({
    this.sourceApiAssociation,
  });

  factory AssociateMergedGraphqlApiResponse.fromJson(
      Map<String, dynamic> json) {
    return AssociateMergedGraphqlApiResponse(
      sourceApiAssociation: json['sourceApiAssociation'] != null
          ? SourceApiAssociation.fromJson(
              json['sourceApiAssociation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociation = this.sourceApiAssociation;
    return {
      if (sourceApiAssociation != null)
        'sourceApiAssociation': sourceApiAssociation,
    };
  }
}

class AssociateSourceGraphqlApiResponse {
  /// The <code>SourceApiAssociation</code> object data.
  final SourceApiAssociation? sourceApiAssociation;

  AssociateSourceGraphqlApiResponse({
    this.sourceApiAssociation,
  });

  factory AssociateSourceGraphqlApiResponse.fromJson(
      Map<String, dynamic> json) {
    return AssociateSourceGraphqlApiResponse(
      sourceApiAssociation: json['sourceApiAssociation'] != null
          ? SourceApiAssociation.fromJson(
              json['sourceApiAssociation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociation = this.sourceApiAssociation;
    return {
      if (sourceApiAssociation != null)
        'sourceApiAssociation': sourceApiAssociation,
    };
  }
}

enum AssociationStatus {
  processing('PROCESSING'),
  failed('FAILED'),
  success('SUCCESS'),
  ;

  final String value;

  const AssociationStatus(this.value);

  static AssociationStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum AssociationStatus'));
}

enum AuthenticationType {
  apiKey('API_KEY'),
  awsIam('AWS_IAM'),
  amazonCognitoUserPools('AMAZON_COGNITO_USER_POOLS'),
  openidConnect('OPENID_CONNECT'),
  awsLambda('AWS_LAMBDA'),
  ;

  final String value;

  const AuthenticationType(this.value);

  static AuthenticationType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum AuthenticationType'));
}

/// The authorization configuration in case the HTTP endpoint requires
/// authorization.
class AuthorizationConfig {
  /// The authorization type that the HTTP endpoint requires.
  ///
  /// <ul>
  /// <li>
  /// <b>AWS_IAM</b>: The authorization type is Signature Version 4 (SigV4).
  /// </li>
  /// </ul>
  final AuthorizationType authorizationType;

  /// The Identity and Access Management (IAM) settings.
  final AwsIamConfig? awsIamConfig;

  AuthorizationConfig({
    required this.authorizationType,
    this.awsIamConfig,
  });

  factory AuthorizationConfig.fromJson(Map<String, dynamic> json) {
    return AuthorizationConfig(
      authorizationType:
          AuthorizationType.fromString((json['authorizationType'] as String)),
      awsIamConfig: json['awsIamConfig'] != null
          ? AwsIamConfig.fromJson(json['awsIamConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final authorizationType = this.authorizationType;
    final awsIamConfig = this.awsIamConfig;
    return {
      'authorizationType': authorizationType.value,
      if (awsIamConfig != null) 'awsIamConfig': awsIamConfig,
    };
  }
}

enum AuthorizationType {
  awsIam('AWS_IAM'),
  ;

  final String value;

  const AuthorizationType(this.value);

  static AuthorizationType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum AuthorizationType'));
}

/// The Identity and Access Management (IAM) configuration.
class AwsIamConfig {
  /// The signing Amazon Web Services Region for IAM authorization.
  final String? signingRegion;

  /// The signing service name for IAM authorization.
  final String? signingServiceName;

  AwsIamConfig({
    this.signingRegion,
    this.signingServiceName,
  });

  factory AwsIamConfig.fromJson(Map<String, dynamic> json) {
    return AwsIamConfig(
      signingRegion: json['signingRegion'] as String?,
      signingServiceName: json['signingServiceName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final signingRegion = this.signingRegion;
    final signingServiceName = this.signingServiceName;
    return {
      if (signingRegion != null) 'signingRegion': signingRegion,
      if (signingServiceName != null) 'signingServiceName': signingServiceName,
    };
  }
}

enum CacheHealthMetricsConfig {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const CacheHealthMetricsConfig(this.value);

  static CacheHealthMetricsConfig fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum CacheHealthMetricsConfig'));
}

/// The caching configuration for a resolver that has caching activated.
class CachingConfig {
  /// The TTL in seconds for a resolver that has caching activated.
  ///
  /// Valid values are 1â€“3,600 seconds.
  final int ttl;

  /// The caching keys for a resolver that has caching activated.
  ///
  /// Valid values are entries from the <code>$context.arguments</code>,
  /// <code>$context.source</code>, and <code>$context.identity</code> maps.
  final List<String>? cachingKeys;

  CachingConfig({
    required this.ttl,
    this.cachingKeys,
  });

  factory CachingConfig.fromJson(Map<String, dynamic> json) {
    return CachingConfig(
      ttl: json['ttl'] as int,
      cachingKeys: (json['cachingKeys'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final ttl = this.ttl;
    final cachingKeys = this.cachingKeys;
    return {
      'ttl': ttl,
      if (cachingKeys != null) 'cachingKeys': cachingKeys,
    };
  }
}

/// Describes an AppSync error.
class CodeError {
  /// The type of code error.
  ///
  /// Examples include, but aren't limited to: <code>LINT_ERROR</code>,
  /// <code>PARSER_ERROR</code>.
  final String? errorType;

  /// The line, column, and span location of the error in the code.
  final CodeErrorLocation? location;

  /// A user presentable error.
  ///
  /// Examples include, but aren't limited to: <code>Parsing error: Unterminated
  /// string literal</code>.
  final String? value;

  CodeError({
    this.errorType,
    this.location,
    this.value,
  });

  factory CodeError.fromJson(Map<String, dynamic> json) {
    return CodeError(
      errorType: json['errorType'] as String?,
      location: json['location'] != null
          ? CodeErrorLocation.fromJson(json['location'] as Map<String, dynamic>)
          : null,
      value: json['value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorType = this.errorType;
    final location = this.location;
    final value = this.value;
    return {
      if (errorType != null) 'errorType': errorType,
      if (location != null) 'location': location,
      if (value != null) 'value': value,
    };
  }
}

/// Describes the location of the error in a code sample.
class CodeErrorLocation {
  /// The column number in the code. Defaults to <code>0</code> if unknown.
  final int? column;

  /// The line number in the code. Defaults to <code>0</code> if unknown.
  final int? line;

  /// The span/length of the error. Defaults to <code>-1</code> if unknown.
  final int? span;

  CodeErrorLocation({
    this.column,
    this.line,
    this.span,
  });

  factory CodeErrorLocation.fromJson(Map<String, dynamic> json) {
    return CodeErrorLocation(
      column: json['column'] as int?,
      line: json['line'] as int?,
      span: json['span'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final line = this.line;
    final span = this.span;
    return {
      if (column != null) 'column': column,
      if (line != null) 'line': line,
      if (span != null) 'span': span,
    };
  }
}

/// Describes an Amazon Cognito user pool configuration.
class CognitoUserPoolConfig {
  /// The Amazon Web Services Region in which the user pool was created.
  final String awsRegion;

  /// The user pool ID.
  final String userPoolId;

  /// A regular expression for validating the incoming Amazon Cognito user pool
  /// app client ID. If this value isn't set, no filtering is applied.
  final String? appIdClientRegex;

  CognitoUserPoolConfig({
    required this.awsRegion,
    required this.userPoolId,
    this.appIdClientRegex,
  });

  factory CognitoUserPoolConfig.fromJson(Map<String, dynamic> json) {
    return CognitoUserPoolConfig(
      awsRegion: json['awsRegion'] as String,
      userPoolId: json['userPoolId'] as String,
      appIdClientRegex: json['appIdClientRegex'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsRegion = this.awsRegion;
    final userPoolId = this.userPoolId;
    final appIdClientRegex = this.appIdClientRegex;
    return {
      'awsRegion': awsRegion,
      'userPoolId': userPoolId,
      if (appIdClientRegex != null) 'appIdClientRegex': appIdClientRegex,
    };
  }
}

enum ConflictDetectionType {
  version('VERSION'),
  none('NONE'),
  ;

  final String value;

  const ConflictDetectionType(this.value);

  static ConflictDetectionType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum ConflictDetectionType'));
}

enum ConflictHandlerType {
  optimisticConcurrency('OPTIMISTIC_CONCURRENCY'),
  lambda('LAMBDA'),
  automerge('AUTOMERGE'),
  none('NONE'),
  ;

  final String value;

  const ConflictHandlerType(this.value);

  static ConflictHandlerType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum ConflictHandlerType'));
}

/// Represents the output of a <code>CreateApiCache</code> operation.
class CreateApiCacheResponse {
  /// The <code>ApiCache</code> object.
  final ApiCache? apiCache;

  CreateApiCacheResponse({
    this.apiCache,
  });

  factory CreateApiCacheResponse.fromJson(Map<String, dynamic> json) {
    return CreateApiCacheResponse(
      apiCache: json['apiCache'] != null
          ? ApiCache.fromJson(json['apiCache'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiCache = this.apiCache;
    return {
      if (apiCache != null) 'apiCache': apiCache,
    };
  }
}

class CreateApiKeyResponse {
  /// The API key.
  final ApiKey? apiKey;

  CreateApiKeyResponse({
    this.apiKey,
  });

  factory CreateApiKeyResponse.fromJson(Map<String, dynamic> json) {
    return CreateApiKeyResponse(
      apiKey: json['apiKey'] != null
          ? ApiKey.fromJson(json['apiKey'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiKey = this.apiKey;
    return {
      if (apiKey != null) 'apiKey': apiKey,
    };
  }
}

class CreateDataSourceResponse {
  /// The <code>DataSource</code> object.
  final DataSource? dataSource;

  CreateDataSourceResponse({
    this.dataSource,
  });

  factory CreateDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return CreateDataSourceResponse(
      dataSource: json['dataSource'] != null
          ? DataSource.fromJson(json['dataSource'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSource = this.dataSource;
    return {
      if (dataSource != null) 'dataSource': dataSource,
    };
  }
}

class CreateDomainNameResponse {
  /// The configuration for the <code>DomainName</code>.
  final DomainNameConfig? domainNameConfig;

  CreateDomainNameResponse({
    this.domainNameConfig,
  });

  factory CreateDomainNameResponse.fromJson(Map<String, dynamic> json) {
    return CreateDomainNameResponse(
      domainNameConfig: json['domainNameConfig'] != null
          ? DomainNameConfig.fromJson(
              json['domainNameConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final domainNameConfig = this.domainNameConfig;
    return {
      if (domainNameConfig != null) 'domainNameConfig': domainNameConfig,
    };
  }
}

class CreateFunctionResponse {
  /// The <code>Function</code> object.
  final FunctionConfiguration? functionConfiguration;

  CreateFunctionResponse({
    this.functionConfiguration,
  });

  factory CreateFunctionResponse.fromJson(Map<String, dynamic> json) {
    return CreateFunctionResponse(
      functionConfiguration: json['functionConfiguration'] != null
          ? FunctionConfiguration.fromJson(
              json['functionConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final functionConfiguration = this.functionConfiguration;
    return {
      if (functionConfiguration != null)
        'functionConfiguration': functionConfiguration,
    };
  }
}

class CreateGraphqlApiResponse {
  /// The <code>GraphqlApi</code>.
  final GraphqlApi? graphqlApi;

  CreateGraphqlApiResponse({
    this.graphqlApi,
  });

  factory CreateGraphqlApiResponse.fromJson(Map<String, dynamic> json) {
    return CreateGraphqlApiResponse(
      graphqlApi: json['graphqlApi'] != null
          ? GraphqlApi.fromJson(json['graphqlApi'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final graphqlApi = this.graphqlApi;
    return {
      if (graphqlApi != null) 'graphqlApi': graphqlApi,
    };
  }
}

class CreateResolverResponse {
  /// The <code>Resolver</code> object.
  final Resolver? resolver;

  CreateResolverResponse({
    this.resolver,
  });

  factory CreateResolverResponse.fromJson(Map<String, dynamic> json) {
    return CreateResolverResponse(
      resolver: json['resolver'] != null
          ? Resolver.fromJson(json['resolver'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final resolver = this.resolver;
    return {
      if (resolver != null) 'resolver': resolver,
    };
  }
}

class CreateTypeResponse {
  /// The <code>Type</code> object.
  final Type? type;

  CreateTypeResponse({
    this.type,
  });

  factory CreateTypeResponse.fromJson(Map<String, dynamic> json) {
    return CreateTypeResponse(
      type: json['type'] != null
          ? Type.fromJson(json['type'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'type': type,
    };
  }
}

/// Describes a data source.
class DataSource {
  /// The data source Amazon Resource Name (ARN).
  final String? dataSourceArn;

  /// The description of the data source.
  final String? description;

  /// DynamoDB settings.
  final DynamodbDataSourceConfig? dynamodbConfig;

  /// Amazon OpenSearch Service settings.
  final ElasticsearchDataSourceConfig? elasticsearchConfig;

  /// Amazon EventBridge settings.
  final EventBridgeDataSourceConfig? eventBridgeConfig;

  /// HTTP endpoint settings.
  final HttpDataSourceConfig? httpConfig;

  /// Lambda settings.
  final LambdaDataSourceConfig? lambdaConfig;

  /// Enables or disables enhanced data source metrics for specified data sources.
  /// Note that <code>metricsConfig</code> won't be used unless the
  /// <code>dataSourceLevelMetricsBehavior</code> value is set to
  /// <code>PER_DATA_SOURCE_METRICS</code>. If the
  /// <code>dataSourceLevelMetricsBehavior</code> is set to
  /// <code>FULL_REQUEST_DATA_SOURCE_METRICS</code> instead,
  /// <code>metricsConfig</code> will be ignored. However, you can still set its
  /// value.
  ///
  /// <code>metricsConfig</code> can be <code>ENABLED</code> or
  /// <code>DISABLED</code>.
  final DataSourceLevelMetricsConfig? metricsConfig;

  /// The name of the data source.
  final String? name;

  /// Amazon OpenSearch Service settings.
  final OpenSearchServiceDataSourceConfig? openSearchServiceConfig;

  /// Relational database settings.
  final RelationalDatabaseDataSourceConfig? relationalDatabaseConfig;

  /// The Identity and Access Management (IAM) service role Amazon Resource Name
  /// (ARN) for the data source. The system assumes this role when accessing the
  /// data source.
  final String? serviceRoleArn;

  /// The type of the data source.
  ///
  /// <ul>
  /// <li>
  /// <b>AWS_LAMBDA</b>: The data source is an Lambda function.
  /// </li>
  /// <li>
  /// <b>AMAZON_DYNAMODB</b>: The data source is an Amazon DynamoDB table.
  /// </li>
  /// <li>
  /// <b>AMAZON_ELASTICSEARCH</b>: The data source is an Amazon OpenSearch Service
  /// domain.
  /// </li>
  /// <li>
  /// <b>AMAZON_OPENSEARCH_SERVICE</b>: The data source is an Amazon OpenSearch
  /// Service domain.
  /// </li>
  /// <li>
  /// <b>AMAZON_EVENTBRIDGE</b>: The data source is an Amazon EventBridge
  /// configuration.
  /// </li>
  /// <li>
  /// <b>NONE</b>: There is no data source. Use this type when you want to invoke
  /// a GraphQL operation without connecting to a data source, such as when you're
  /// performing data transformation with resolvers or invoking a subscription
  /// from a mutation.
  /// </li>
  /// <li>
  /// <b>HTTP</b>: The data source is an HTTP endpoint.
  /// </li>
  /// <li>
  /// <b>RELATIONAL_DATABASE</b>: The data source is a relational database.
  /// </li>
  /// </ul>
  final DataSourceType? type;

  DataSource({
    this.dataSourceArn,
    this.description,
    this.dynamodbConfig,
    this.elasticsearchConfig,
    this.eventBridgeConfig,
    this.httpConfig,
    this.lambdaConfig,
    this.metricsConfig,
    this.name,
    this.openSearchServiceConfig,
    this.relationalDatabaseConfig,
    this.serviceRoleArn,
    this.type,
  });

  factory DataSource.fromJson(Map<String, dynamic> json) {
    return DataSource(
      dataSourceArn: json['dataSourceArn'] as String?,
      description: json['description'] as String?,
      dynamodbConfig: json['dynamodbConfig'] != null
          ? DynamodbDataSourceConfig.fromJson(
              json['dynamodbConfig'] as Map<String, dynamic>)
          : null,
      elasticsearchConfig: json['elasticsearchConfig'] != null
          ? ElasticsearchDataSourceConfig.fromJson(
              json['elasticsearchConfig'] as Map<String, dynamic>)
          : null,
      eventBridgeConfig: json['eventBridgeConfig'] != null
          ? EventBridgeDataSourceConfig.fromJson(
              json['eventBridgeConfig'] as Map<String, dynamic>)
          : null,
      httpConfig: json['httpConfig'] != null
          ? HttpDataSourceConfig.fromJson(
              json['httpConfig'] as Map<String, dynamic>)
          : null,
      lambdaConfig: json['lambdaConfig'] != null
          ? LambdaDataSourceConfig.fromJson(
              json['lambdaConfig'] as Map<String, dynamic>)
          : null,
      metricsConfig: (json['metricsConfig'] as String?)
          ?.let(DataSourceLevelMetricsConfig.fromString),
      name: json['name'] as String?,
      openSearchServiceConfig: json['openSearchServiceConfig'] != null
          ? OpenSearchServiceDataSourceConfig.fromJson(
              json['openSearchServiceConfig'] as Map<String, dynamic>)
          : null,
      relationalDatabaseConfig: json['relationalDatabaseConfig'] != null
          ? RelationalDatabaseDataSourceConfig.fromJson(
              json['relationalDatabaseConfig'] as Map<String, dynamic>)
          : null,
      serviceRoleArn: json['serviceRoleArn'] as String?,
      type: (json['type'] as String?)?.let(DataSourceType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceArn = this.dataSourceArn;
    final description = this.description;
    final dynamodbConfig = this.dynamodbConfig;
    final elasticsearchConfig = this.elasticsearchConfig;
    final eventBridgeConfig = this.eventBridgeConfig;
    final httpConfig = this.httpConfig;
    final lambdaConfig = this.lambdaConfig;
    final metricsConfig = this.metricsConfig;
    final name = this.name;
    final openSearchServiceConfig = this.openSearchServiceConfig;
    final relationalDatabaseConfig = this.relationalDatabaseConfig;
    final serviceRoleArn = this.serviceRoleArn;
    final type = this.type;
    return {
      if (dataSourceArn != null) 'dataSourceArn': dataSourceArn,
      if (description != null) 'description': description,
      if (dynamodbConfig != null) 'dynamodbConfig': dynamodbConfig,
      if (elasticsearchConfig != null)
        'elasticsearchConfig': elasticsearchConfig,
      if (eventBridgeConfig != null) 'eventBridgeConfig': eventBridgeConfig,
      if (httpConfig != null) 'httpConfig': httpConfig,
      if (lambdaConfig != null) 'lambdaConfig': lambdaConfig,
      if (metricsConfig != null) 'metricsConfig': metricsConfig.value,
      if (name != null) 'name': name,
      if (openSearchServiceConfig != null)
        'openSearchServiceConfig': openSearchServiceConfig,
      if (relationalDatabaseConfig != null)
        'relationalDatabaseConfig': relationalDatabaseConfig,
      if (serviceRoleArn != null) 'serviceRoleArn': serviceRoleArn,
      if (type != null) 'type': type.value,
    };
  }
}

/// Contains the introspected data that was retrieved from the data source.
class DataSourceIntrospectionModel {
  /// The <code>DataSourceIntrospectionModelField</code> object data.
  final List<DataSourceIntrospectionModelField>? fields;

  /// The array of <code>DataSourceIntrospectionModelIndex</code> objects.
  final List<DataSourceIntrospectionModelIndex>? indexes;

  /// The name of the model. For example, this could be the name of a single table
  /// in a database.
  final String? name;

  /// The primary key stored as a <code>DataSourceIntrospectionModelIndex</code>
  /// object.
  final DataSourceIntrospectionModelIndex? primaryKey;

  /// Contains the output of the SDL that was generated from the introspected
  /// types. This is controlled by the <code>includeModelsSDL</code> parameter of
  /// the <code>GetDataSourceIntrospection</code> operation.
  final String? sdl;

  DataSourceIntrospectionModel({
    this.fields,
    this.indexes,
    this.name,
    this.primaryKey,
    this.sdl,
  });

  factory DataSourceIntrospectionModel.fromJson(Map<String, dynamic> json) {
    return DataSourceIntrospectionModel(
      fields: (json['fields'] as List?)
          ?.nonNulls
          .map((e) => DataSourceIntrospectionModelField.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      indexes: (json['indexes'] as List?)
          ?.nonNulls
          .map((e) => DataSourceIntrospectionModelIndex.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      name: json['name'] as String?,
      primaryKey: json['primaryKey'] != null
          ? DataSourceIntrospectionModelIndex.fromJson(
              json['primaryKey'] as Map<String, dynamic>)
          : null,
      sdl: json['sdl'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fields = this.fields;
    final indexes = this.indexes;
    final name = this.name;
    final primaryKey = this.primaryKey;
    final sdl = this.sdl;
    return {
      if (fields != null) 'fields': fields,
      if (indexes != null) 'indexes': indexes,
      if (name != null) 'name': name,
      if (primaryKey != null) 'primaryKey': primaryKey,
      if (sdl != null) 'sdl': sdl,
    };
  }
}

/// Represents the fields that were retrieved from the introspected data.
class DataSourceIntrospectionModelField {
  /// The length value of the introspected field.
  final int? length;

  /// The name of the field that was retrieved from the introspected data.
  final String? name;

  /// The <code>DataSourceIntrospectionModelFieldType</code> object data.
  final DataSourceIntrospectionModelFieldType? type;

  DataSourceIntrospectionModelField({
    this.length,
    this.name,
    this.type,
  });

  factory DataSourceIntrospectionModelField.fromJson(
      Map<String, dynamic> json) {
    return DataSourceIntrospectionModelField(
      length: json['length'] as int?,
      name: json['name'] as String?,
      type: json['type'] != null
          ? DataSourceIntrospectionModelFieldType.fromJson(
              json['type'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final length = this.length;
    final name = this.name;
    final type = this.type;
    return {
      if (length != null) 'length': length,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
    };
  }
}

/// Represents the type data for each field retrieved from the introspection.
class DataSourceIntrospectionModelFieldType {
  /// Specifies the classification of data. For example, this could be set to
  /// values like <code>Scalar</code> or <code>NonNull</code> to indicate a
  /// fundamental property of the field.
  ///
  /// Valid values include:
  ///
  /// <ul>
  /// <li>
  /// <code>Scalar</code>: Indicates the value is a primitive type (scalar).
  /// </li>
  /// <li>
  /// <code>NonNull</code>: Indicates the field cannot be <code>null</code>.
  /// </li>
  /// <li>
  /// <code>List</code>: Indicates the field contains a list.
  /// </li>
  /// </ul>
  final String? kind;

  /// The name of the data type that represents the field. For example,
  /// <code>String</code> is a valid <code>name</code> value.
  final String? name;

  /// The <code>DataSourceIntrospectionModelFieldType</code> object data. The
  /// <code>type</code> is only present if
  /// <code>DataSourceIntrospectionModelFieldType.kind</code> is set to
  /// <code>NonNull</code> or <code>List</code>.
  ///
  /// The <code>type</code> typically contains its own <code>kind</code> and
  /// <code>name</code> fields to represent the actual type data. For instance,
  /// <code>type</code> could contain a <code>kind</code> value of
  /// <code>Scalar</code> with a <code>name</code> value of <code>String</code>.
  /// The values <code>Scalar</code> and <code>String</code> will be collectively
  /// stored in the <code>values</code> field.
  final DataSourceIntrospectionModelFieldType? type;

  /// The values of the <code>type</code> field. This field represents the AppSync
  /// data type equivalent of the introspected field.
  final List<String>? values;

  DataSourceIntrospectionModelFieldType({
    this.kind,
    this.name,
    this.type,
    this.values,
  });

  factory DataSourceIntrospectionModelFieldType.fromJson(
      Map<String, dynamic> json) {
    return DataSourceIntrospectionModelFieldType(
      kind: json['kind'] as String?,
      name: json['name'] as String?,
      type: json['type'] != null
          ? DataSourceIntrospectionModelFieldType.fromJson(
              json['type'] as Map<String, dynamic>)
          : null,
      values:
          (json['values'] as List?)?.nonNulls.map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final kind = this.kind;
    final name = this.name;
    final type = this.type;
    final values = this.values;
    return {
      if (kind != null) 'kind': kind,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (values != null) 'values': values,
    };
  }
}

/// The index that was retrieved from the introspected data.
class DataSourceIntrospectionModelIndex {
  /// The fields of the index.
  final List<String>? fields;

  /// The name of the index.
  final String? name;

  DataSourceIntrospectionModelIndex({
    this.fields,
    this.name,
  });

  factory DataSourceIntrospectionModelIndex.fromJson(
      Map<String, dynamic> json) {
    return DataSourceIntrospectionModelIndex(
      fields:
          (json['fields'] as List?)?.nonNulls.map((e) => e as String).toList(),
      name: json['name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fields = this.fields;
    final name = this.name;
    return {
      if (fields != null) 'fields': fields,
      if (name != null) 'name': name,
    };
  }
}

/// Represents the output of a <code>DataSourceIntrospectionResult</code>. This
/// is the populated result of a <code>GetDataSourceIntrospection</code>
/// operation.
class DataSourceIntrospectionResult {
  /// The array of <code>DataSourceIntrospectionModel</code> objects.
  final List<DataSourceIntrospectionModel>? models;

  /// Determines the number of types to be returned in a single response before
  /// paginating. This value is typically taken from <code>nextToken</code> value
  /// from the previous response.
  final String? nextToken;

  DataSourceIntrospectionResult({
    this.models,
    this.nextToken,
  });

  factory DataSourceIntrospectionResult.fromJson(Map<String, dynamic> json) {
    return DataSourceIntrospectionResult(
      models: (json['models'] as List?)
          ?.nonNulls
          .map((e) =>
              DataSourceIntrospectionModel.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final models = this.models;
    final nextToken = this.nextToken;
    return {
      if (models != null) 'models': models,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

enum DataSourceIntrospectionStatus {
  processing('PROCESSING'),
  failed('FAILED'),
  success('SUCCESS'),
  ;

  final String value;

  const DataSourceIntrospectionStatus(this.value);

  static DataSourceIntrospectionStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum DataSourceIntrospectionStatus'));
}

enum DataSourceLevelMetricsBehavior {
  fullRequestDataSourceMetrics('FULL_REQUEST_DATA_SOURCE_METRICS'),
  perDataSourceMetrics('PER_DATA_SOURCE_METRICS'),
  ;

  final String value;

  const DataSourceLevelMetricsBehavior(this.value);

  static DataSourceLevelMetricsBehavior fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum DataSourceLevelMetricsBehavior'));
}

enum DataSourceLevelMetricsConfig {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const DataSourceLevelMetricsConfig(this.value);

  static DataSourceLevelMetricsConfig fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum DataSourceLevelMetricsConfig'));
}

enum DataSourceType {
  awsLambda('AWS_LAMBDA'),
  amazonDynamodb('AMAZON_DYNAMODB'),
  amazonElasticsearch('AMAZON_ELASTICSEARCH'),
  none('NONE'),
  http('HTTP'),
  relationalDatabase('RELATIONAL_DATABASE'),
  amazonOpensearchService('AMAZON_OPENSEARCH_SERVICE'),
  amazonEventbridge('AMAZON_EVENTBRIDGE'),
  ;

  final String value;

  const DataSourceType(this.value);

  static DataSourceType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum DataSourceType'));
}

enum DefaultAction {
  allow('ALLOW'),
  deny('DENY'),
  ;

  final String value;

  const DefaultAction(this.value);

  static DefaultAction fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum DefaultAction'));
}

/// Represents the output of a <code>DeleteApiCache</code> operation.
class DeleteApiCacheResponse {
  DeleteApiCacheResponse();

  factory DeleteApiCacheResponse.fromJson(Map<String, dynamic> _) {
    return DeleteApiCacheResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteApiKeyResponse {
  DeleteApiKeyResponse();

  factory DeleteApiKeyResponse.fromJson(Map<String, dynamic> _) {
    return DeleteApiKeyResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteDataSourceResponse {
  DeleteDataSourceResponse();

  factory DeleteDataSourceResponse.fromJson(Map<String, dynamic> _) {
    return DeleteDataSourceResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteDomainNameResponse {
  DeleteDomainNameResponse();

  factory DeleteDomainNameResponse.fromJson(Map<String, dynamic> _) {
    return DeleteDomainNameResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteFunctionResponse {
  DeleteFunctionResponse();

  factory DeleteFunctionResponse.fromJson(Map<String, dynamic> _) {
    return DeleteFunctionResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteGraphqlApiResponse {
  DeleteGraphqlApiResponse();

  factory DeleteGraphqlApiResponse.fromJson(Map<String, dynamic> _) {
    return DeleteGraphqlApiResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteResolverResponse {
  DeleteResolverResponse();

  factory DeleteResolverResponse.fromJson(Map<String, dynamic> _) {
    return DeleteResolverResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DeleteTypeResponse {
  DeleteTypeResponse();

  factory DeleteTypeResponse.fromJson(Map<String, dynamic> _) {
    return DeleteTypeResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Describes a Delta Sync configuration.
class DeltaSyncConfig {
  /// The number of minutes that an Item is stored in the data source.
  final int? baseTableTTL;

  /// The Delta Sync table name.
  final String? deltaSyncTableName;

  /// The number of minutes that a Delta Sync log entry is stored in the Delta
  /// Sync table.
  final int? deltaSyncTableTTL;

  DeltaSyncConfig({
    this.baseTableTTL,
    this.deltaSyncTableName,
    this.deltaSyncTableTTL,
  });

  factory DeltaSyncConfig.fromJson(Map<String, dynamic> json) {
    return DeltaSyncConfig(
      baseTableTTL: json['baseTableTTL'] as int?,
      deltaSyncTableName: json['deltaSyncTableName'] as String?,
      deltaSyncTableTTL: json['deltaSyncTableTTL'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final baseTableTTL = this.baseTableTTL;
    final deltaSyncTableName = this.deltaSyncTableName;
    final deltaSyncTableTTL = this.deltaSyncTableTTL;
    return {
      if (baseTableTTL != null) 'baseTableTTL': baseTableTTL,
      if (deltaSyncTableName != null) 'deltaSyncTableName': deltaSyncTableName,
      if (deltaSyncTableTTL != null) 'deltaSyncTableTTL': deltaSyncTableTTL,
    };
  }
}

class DisassociateApiResponse {
  DisassociateApiResponse();

  factory DisassociateApiResponse.fromJson(Map<String, dynamic> _) {
    return DisassociateApiResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

class DisassociateMergedGraphqlApiResponse {
  /// The state of the source API association.
  final SourceApiAssociationStatus? sourceApiAssociationStatus;

  DisassociateMergedGraphqlApiResponse({
    this.sourceApiAssociationStatus,
  });

  factory DisassociateMergedGraphqlApiResponse.fromJson(
      Map<String, dynamic> json) {
    return DisassociateMergedGraphqlApiResponse(
      sourceApiAssociationStatus:
          (json['sourceApiAssociationStatus'] as String?)
              ?.let(SourceApiAssociationStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociationStatus = this.sourceApiAssociationStatus;
    return {
      if (sourceApiAssociationStatus != null)
        'sourceApiAssociationStatus': sourceApiAssociationStatus.value,
    };
  }
}

class DisassociateSourceGraphqlApiResponse {
  /// The state of the source API association.
  final SourceApiAssociationStatus? sourceApiAssociationStatus;

  DisassociateSourceGraphqlApiResponse({
    this.sourceApiAssociationStatus,
  });

  factory DisassociateSourceGraphqlApiResponse.fromJson(
      Map<String, dynamic> json) {
    return DisassociateSourceGraphqlApiResponse(
      sourceApiAssociationStatus:
          (json['sourceApiAssociationStatus'] as String?)
              ?.let(SourceApiAssociationStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociationStatus = this.sourceApiAssociationStatus;
    return {
      if (sourceApiAssociationStatus != null)
        'sourceApiAssociationStatus': sourceApiAssociationStatus.value,
    };
  }
}

/// Describes a configuration for a custom domain.
class DomainNameConfig {
  /// The domain name that AppSync provides.
  final String? appsyncDomainName;

  /// The Amazon Resource Name (ARN) of the certificate. This can be an
  /// Certificate Manager (ACM) certificate or an Identity and Access Management
  /// (IAM) server certificate.
  final String? certificateArn;

  /// A description of the <code>DomainName</code> configuration.
  final String? description;

  /// The domain name.
  final String? domainName;

  /// The ID of your Amazon RouteÂ 53 hosted zone.
  final String? hostedZoneId;

  DomainNameConfig({
    this.appsyncDomainName,
    this.certificateArn,
    this.description,
    this.domainName,
    this.hostedZoneId,
  });

  factory DomainNameConfig.fromJson(Map<String, dynamic> json) {
    return DomainNameConfig(
      appsyncDomainName: json['appsyncDomainName'] as String?,
      certificateArn: json['certificateArn'] as String?,
      description: json['description'] as String?,
      domainName: json['domainName'] as String?,
      hostedZoneId: json['hostedZoneId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final appsyncDomainName = this.appsyncDomainName;
    final certificateArn = this.certificateArn;
    final description = this.description;
    final domainName = this.domainName;
    final hostedZoneId = this.hostedZoneId;
    return {
      if (appsyncDomainName != null) 'appsyncDomainName': appsyncDomainName,
      if (certificateArn != null) 'certificateArn': certificateArn,
      if (description != null) 'description': description,
      if (domainName != null) 'domainName': domainName,
      if (hostedZoneId != null) 'hostedZoneId': hostedZoneId,
    };
  }
}

/// Describes an Amazon DynamoDB data source configuration.
class DynamodbDataSourceConfig {
  /// The Amazon Web Services Region.
  final String awsRegion;

  /// The table name.
  final String tableName;

  /// The <code>DeltaSyncConfig</code> for a versioned data source.
  final DeltaSyncConfig? deltaSyncConfig;

  /// Set to TRUE to use Amazon Cognito credentials with this data source.
  final bool? useCallerCredentials;

  /// Set to TRUE to use Conflict Detection and Resolution with this data source.
  final bool? versioned;

  DynamodbDataSourceConfig({
    required this.awsRegion,
    required this.tableName,
    this.deltaSyncConfig,
    this.useCallerCredentials,
    this.versioned,
  });

  factory DynamodbDataSourceConfig.fromJson(Map<String, dynamic> json) {
    return DynamodbDataSourceConfig(
      awsRegion: json['awsRegion'] as String,
      tableName: json['tableName'] as String,
      deltaSyncConfig: json['deltaSyncConfig'] != null
          ? DeltaSyncConfig.fromJson(
              json['deltaSyncConfig'] as Map<String, dynamic>)
          : null,
      useCallerCredentials: json['useCallerCredentials'] as bool?,
      versioned: json['versioned'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsRegion = this.awsRegion;
    final tableName = this.tableName;
    final deltaSyncConfig = this.deltaSyncConfig;
    final useCallerCredentials = this.useCallerCredentials;
    final versioned = this.versioned;
    return {
      'awsRegion': awsRegion,
      'tableName': tableName,
      if (deltaSyncConfig != null) 'deltaSyncConfig': deltaSyncConfig,
      if (useCallerCredentials != null)
        'useCallerCredentials': useCallerCredentials,
      if (versioned != null) 'versioned': versioned,
    };
  }
}

/// Describes an OpenSearch data source configuration.
///
/// As of September 2021, Amazon Elasticsearch service is Amazon OpenSearch
/// Service. This configuration is deprecated. For new data sources, use
/// <a>OpenSearchServiceDataSourceConfig</a> to specify an OpenSearch data
/// source.
class ElasticsearchDataSourceConfig {
  /// The Amazon Web Services Region.
  final String awsRegion;

  /// The endpoint.
  final String endpoint;

  ElasticsearchDataSourceConfig({
    required this.awsRegion,
    required this.endpoint,
  });

  factory ElasticsearchDataSourceConfig.fromJson(Map<String, dynamic> json) {
    return ElasticsearchDataSourceConfig(
      awsRegion: json['awsRegion'] as String,
      endpoint: json['endpoint'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final awsRegion = this.awsRegion;
    final endpoint = this.endpoint;
    return {
      'awsRegion': awsRegion,
      'endpoint': endpoint,
    };
  }
}

/// Enables and controls the enhanced metrics feature. Enhanced metrics emit
/// granular data on API usage and performance such as AppSync request and error
/// counts, latency, and cache hits/misses. All enhanced metric data is sent to
/// your CloudWatch account, and you can configure the types of data that will
/// be sent.
///
/// Enhanced metrics can be configured at the resolver, data source, and
/// operation levels. <code>EnhancedMetricsConfig</code> contains three required
/// parameters, each controlling one of these categories:
/// <ol>
/// <li>
/// <code>resolverLevelMetricsBehavior</code>: Controls how resolver metrics
/// will be emitted to CloudWatch. Resolver metrics include:
///
/// <ul>
/// <li>
/// GraphQL errors: The number of GraphQL errors that occurred.
/// </li>
/// <li>
/// Requests: The number of invocations that occurred during a request.
/// </li>
/// <li>
/// Latency: The time to complete a resolver invocation.
/// </li>
/// <li>
/// Cache hits: The number of cache hits during a request.
/// </li>
/// <li>
/// Cache misses: The number of cache misses during a request.
/// </li>
/// </ul>
/// These metrics can be emitted to CloudWatch per resolver or for all resolvers
/// in the request. Metrics will be recorded by API ID and resolver name.
/// <code>resolverLevelMetricsBehavior</code> accepts one of these values at a
/// time:
///
/// <ul>
/// <li>
/// <code>FULL_REQUEST_RESOLVER_METRICS</code>: Records and emits metric data
/// for all resolvers in the request.
/// </li>
/// <li>
/// <code>PER_RESOLVER_METRICS</code>: Records and emits metric data for
/// resolvers that have the <code>metricsConfig</code> value set to
/// <code>ENABLED</code>.
/// </li>
/// </ul> </li>
/// <li>
/// <code>dataSourceLevelMetricsBehavior</code>: Controls how data source
/// metrics will be emitted to CloudWatch. Data source metrics include:
///
/// <ul>
/// <li>
/// Requests: The number of invocations that occured during a request.
/// </li>
/// <li>
/// Latency: The time to complete a data source invocation.
/// </li>
/// <li>
/// Errors: The number of errors that occurred during a data source invocation.
/// </li>
/// </ul>
/// These metrics can be emitted to CloudWatch per data source or for all data
/// sources in the request. Metrics will be recorded by API ID and data source
/// name. <code>dataSourceLevelMetricsBehavior</code> accepts one of these
/// values at a time:
///
/// <ul>
/// <li>
/// <code>FULL_REQUEST_DATA_SOURCE_METRICS</code>: Records and emits metric data
/// for all data sources in the request.
/// </li>
/// <li>
/// <code>PER_DATA_SOURCE_METRICS</code>: Records and emits metric data for data
/// sources that have the <code>metricsConfig</code> value set to
/// <code>ENABLED</code>.
/// </li>
/// </ul> </li>
/// <li>
/// <code>operationLevelMetricsConfig</code>: Controls how operation metrics
/// will be emitted to CloudWatch. Operation metrics include:
///
/// <ul>
/// <li>
/// Requests: The number of times a specified GraphQL operation was called.
/// </li>
/// <li>
/// GraphQL errors: The number of GraphQL errors that occurred during a
/// specified GraphQL operation.
/// </li>
/// </ul>
/// Metrics will be recorded by API ID and operation name. You can set the value
/// to <code>ENABLED</code> or <code>DISABLED</code>.
/// </li> </ol>
class EnhancedMetricsConfig {
  /// Controls how data source metrics will be emitted to CloudWatch. Data source
  /// metrics include:
  ///
  /// <ul>
  /// <li>
  /// Requests: The number of invocations that occured during a request.
  /// </li>
  /// <li>
  /// Latency: The time to complete a data source invocation.
  /// </li>
  /// <li>
  /// Errors: The number of errors that occurred during a data source invocation.
  /// </li>
  /// </ul>
  /// These metrics can be emitted to CloudWatch per data source or for all data
  /// sources in the request. Metrics will be recorded by API ID and data source
  /// name. <code>dataSourceLevelMetricsBehavior</code> accepts one of these
  /// values at a time:
  ///
  /// <ul>
  /// <li>
  /// <code>FULL_REQUEST_DATA_SOURCE_METRICS</code>: Records and emits metric data
  /// for all data sources in the request.
  /// </li>
  /// <li>
  /// <code>PER_DATA_SOURCE_METRICS</code>: Records and emits metric data for data
  /// sources that have the <code>metricsConfig</code> value set to
  /// <code>ENABLED</code>.
  /// </li>
  /// </ul>
  final DataSourceLevelMetricsBehavior dataSourceLevelMetricsBehavior;

  /// Controls how operation metrics will be emitted to CloudWatch. Operation
  /// metrics include:
  ///
  /// <ul>
  /// <li>
  /// Requests: The number of times a specified GraphQL operation was called.
  /// </li>
  /// <li>
  /// GraphQL errors: The number of GraphQL errors that occurred during a
  /// specified GraphQL operation.
  /// </li>
  /// </ul>
  /// Metrics will be recorded by API ID and operation name. You can set the value
  /// to <code>ENABLED</code> or <code>DISABLED</code>.
  final OperationLevelMetricsConfig operationLevelMetricsConfig;

  /// Controls how resolver metrics will be emitted to CloudWatch. Resolver
  /// metrics include:
  ///
  /// <ul>
  /// <li>
  /// GraphQL errors: The number of GraphQL errors that occurred.
  /// </li>
  /// <li>
  /// Requests: The number of invocations that occurred during a request.
  /// </li>
  /// <li>
  /// Latency: The time to complete a resolver invocation.
  /// </li>
  /// <li>
  /// Cache hits: The number of cache hits during a request.
  /// </li>
  /// <li>
  /// Cache misses: The number of cache misses during a request.
  /// </li>
  /// </ul>
  /// These metrics can be emitted to CloudWatch per resolver or for all resolvers
  /// in the request. Metrics will be recorded by API ID and resolver name.
  /// <code>resolverLevelMetricsBehavior</code> accepts one of these values at a
  /// time:
  ///
  /// <ul>
  /// <li>
  /// <code>FULL_REQUEST_RESOLVER_METRICS</code>: Records and emits metric data
  /// for all resolvers in the request.
  /// </li>
  /// <li>
  /// <code>PER_RESOLVER_METRICS</code>: Records and emits metric data for
  /// resolvers that have the <code>metricsConfig</code> value set to
  /// <code>ENABLED</code>.
  /// </li>
  /// </ul>
  final ResolverLevelMetricsBehavior resolverLevelMetricsBehavior;

  EnhancedMetricsConfig({
    required this.dataSourceLevelMetricsBehavior,
    required this.operationLevelMetricsConfig,
    required this.resolverLevelMetricsBehavior,
  });

  factory EnhancedMetricsConfig.fromJson(Map<String, dynamic> json) {
    return EnhancedMetricsConfig(
      dataSourceLevelMetricsBehavior: DataSourceLevelMetricsBehavior.fromString(
          (json['dataSourceLevelMetricsBehavior'] as String)),
      operationLevelMetricsConfig: OperationLevelMetricsConfig.fromString(
          (json['operationLevelMetricsConfig'] as String)),
      resolverLevelMetricsBehavior: ResolverLevelMetricsBehavior.fromString(
          (json['resolverLevelMetricsBehavior'] as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceLevelMetricsBehavior = this.dataSourceLevelMetricsBehavior;
    final operationLevelMetricsConfig = this.operationLevelMetricsConfig;
    final resolverLevelMetricsBehavior = this.resolverLevelMetricsBehavior;
    return {
      'dataSourceLevelMetricsBehavior': dataSourceLevelMetricsBehavior.value,
      'operationLevelMetricsConfig': operationLevelMetricsConfig.value,
      'resolverLevelMetricsBehavior': resolverLevelMetricsBehavior.value,
    };
  }
}

/// Contains the list of errors generated. When using JavaScript, this will
/// apply to the request or response function evaluation.
class ErrorDetail {
  /// The error payload.
  final String? message;

  ErrorDetail({
    this.message,
  });

  factory ErrorDetail.fromJson(Map<String, dynamic> json) {
    return ErrorDetail(
      message: json['message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    return {
      if (message != null) 'message': message,
    };
  }
}

/// Contains the list of errors from a code evaluation response.
class EvaluateCodeErrorDetail {
  /// Contains the list of <code>CodeError</code> objects.
  final List<CodeError>? codeErrors;

  /// The error payload.
  final String? message;

  EvaluateCodeErrorDetail({
    this.codeErrors,
    this.message,
  });

  factory EvaluateCodeErrorDetail.fromJson(Map<String, dynamic> json) {
    return EvaluateCodeErrorDetail(
      codeErrors: (json['codeErrors'] as List?)
          ?.nonNulls
          .map((e) => CodeError.fromJson(e as Map<String, dynamic>))
          .toList(),
      message: json['message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final codeErrors = this.codeErrors;
    final message = this.message;
    return {
      if (codeErrors != null) 'codeErrors': codeErrors,
      if (message != null) 'message': message,
    };
  }
}

class EvaluateCodeResponse {
  /// Contains the payload of the response error.
  final EvaluateCodeErrorDetail? error;

  /// The result of the evaluation operation.
  final String? evaluationResult;

  /// A list of logs that were generated by calls to <code>util.log.info</code>
  /// and <code>util.log.error</code> in the evaluated code.
  final List<String>? logs;

  EvaluateCodeResponse({
    this.error,
    this.evaluationResult,
    this.logs,
  });

  factory EvaluateCodeResponse.fromJson(Map<String, dynamic> json) {
    return EvaluateCodeResponse(
      error: json['error'] != null
          ? EvaluateCodeErrorDetail.fromJson(
              json['error'] as Map<String, dynamic>)
          : null,
      evaluationResult: json['evaluationResult'] as String?,
      logs: (json['logs'] as List?)?.nonNulls.map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final error = this.error;
    final evaluationResult = this.evaluationResult;
    final logs = this.logs;
    return {
      if (error != null) 'error': error,
      if (evaluationResult != null) 'evaluationResult': evaluationResult,
      if (logs != null) 'logs': logs,
    };
  }
}

class EvaluateMappingTemplateResponse {
  /// The <code>ErrorDetail</code> object.
  final ErrorDetail? error;

  /// The mapping template; this can be a request or response template.
  final String? evaluationResult;

  /// A list of logs that were generated by calls to <code>util.log.info</code>
  /// and <code>util.log.error</code> in the evaluated code.
  final List<String>? logs;

  EvaluateMappingTemplateResponse({
    this.error,
    this.evaluationResult,
    this.logs,
  });

  factory EvaluateMappingTemplateResponse.fromJson(Map<String, dynamic> json) {
    return EvaluateMappingTemplateResponse(
      error: json['error'] != null
          ? ErrorDetail.fromJson(json['error'] as Map<String, dynamic>)
          : null,
      evaluationResult: json['evaluationResult'] as String?,
      logs: (json['logs'] as List?)?.nonNulls.map((e) => e as String).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final error = this.error;
    final evaluationResult = this.evaluationResult;
    final logs = this.logs;
    return {
      if (error != null) 'error': error,
      if (evaluationResult != null) 'evaluationResult': evaluationResult,
      if (logs != null) 'logs': logs,
    };
  }
}

/// Describes an Amazon EventBridge bus data source configuration.
class EventBridgeDataSourceConfig {
  /// The ARN of the event bus. For more information about event buses, see <a
  /// href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-event-bus.html">Amazon
  /// EventBridge event buses</a>.
  final String eventBusArn;

  EventBridgeDataSourceConfig({
    required this.eventBusArn,
  });

  factory EventBridgeDataSourceConfig.fromJson(Map<String, dynamic> json) {
    return EventBridgeDataSourceConfig(
      eventBusArn: json['eventBusArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final eventBusArn = this.eventBusArn;
    return {
      'eventBusArn': eventBusArn,
    };
  }
}

enum FieldLogLevel {
  none('NONE'),
  error('ERROR'),
  all('ALL'),
  ;

  final String value;

  const FieldLogLevel(this.value);

  static FieldLogLevel fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum FieldLogLevel'));
}

/// Represents the output of a <code>FlushApiCache</code> operation.
class FlushApiCacheResponse {
  FlushApiCacheResponse();

  factory FlushApiCacheResponse.fromJson(Map<String, dynamic> _) {
    return FlushApiCacheResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// A function is a reusable entity. You can use multiple functions to compose
/// the resolver logic.
class FunctionConfiguration {
  /// The <code>function</code> code that contains the request and response
  /// functions. When code is used, the <code>runtime</code> is required. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  final String? code;

  /// The name of the <code>DataSource</code>.
  final String? dataSourceName;

  /// The <code>Function</code> description.
  final String? description;

  /// The Amazon Resource Name (ARN) of the <code>Function</code> object.
  final String? functionArn;

  /// A unique ID representing the <code>Function</code> object.
  final String? functionId;

  /// The version of the request mapping template. Currently, only the 2018-05-29
  /// version of the template is supported.
  final String? functionVersion;

  /// The maximum batching size for a resolver.
  final int? maxBatchSize;

  /// The name of the <code>Function</code> object.
  final String? name;

  /// The <code>Function</code> request mapping template. Functions support only
  /// the 2018-05-29 version of the request mapping template.
  final String? requestMappingTemplate;

  /// The <code>Function</code> response mapping template.
  final String? responseMappingTemplate;
  final AppSyncRuntime? runtime;
  final SyncConfig? syncConfig;

  FunctionConfiguration({
    this.code,
    this.dataSourceName,
    this.description,
    this.functionArn,
    this.functionId,
    this.functionVersion,
    this.maxBatchSize,
    this.name,
    this.requestMappingTemplate,
    this.responseMappingTemplate,
    this.runtime,
    this.syncConfig,
  });

  factory FunctionConfiguration.fromJson(Map<String, dynamic> json) {
    return FunctionConfiguration(
      code: json['code'] as String?,
      dataSourceName: json['dataSourceName'] as String?,
      description: json['description'] as String?,
      functionArn: json['functionArn'] as String?,
      functionId: json['functionId'] as String?,
      functionVersion: json['functionVersion'] as String?,
      maxBatchSize: json['maxBatchSize'] as int?,
      name: json['name'] as String?,
      requestMappingTemplate: json['requestMappingTemplate'] as String?,
      responseMappingTemplate: json['responseMappingTemplate'] as String?,
      runtime: json['runtime'] != null
          ? AppSyncRuntime.fromJson(json['runtime'] as Map<String, dynamic>)
          : null,
      syncConfig: json['syncConfig'] != null
          ? SyncConfig.fromJson(json['syncConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final code = this.code;
    final dataSourceName = this.dataSourceName;
    final description = this.description;
    final functionArn = this.functionArn;
    final functionId = this.functionId;
    final functionVersion = this.functionVersion;
    final maxBatchSize = this.maxBatchSize;
    final name = this.name;
    final requestMappingTemplate = this.requestMappingTemplate;
    final responseMappingTemplate = this.responseMappingTemplate;
    final runtime = this.runtime;
    final syncConfig = this.syncConfig;
    return {
      if (code != null) 'code': code,
      if (dataSourceName != null) 'dataSourceName': dataSourceName,
      if (description != null) 'description': description,
      if (functionArn != null) 'functionArn': functionArn,
      if (functionId != null) 'functionId': functionId,
      if (functionVersion != null) 'functionVersion': functionVersion,
      if (maxBatchSize != null) 'maxBatchSize': maxBatchSize,
      if (name != null) 'name': name,
      if (requestMappingTemplate != null)
        'requestMappingTemplate': requestMappingTemplate,
      if (responseMappingTemplate != null)
        'responseMappingTemplate': responseMappingTemplate,
      if (runtime != null) 'runtime': runtime,
      if (syncConfig != null) 'syncConfig': syncConfig,
    };
  }
}

class GetApiAssociationResponse {
  /// The <code>ApiAssociation</code> object.
  final ApiAssociation? apiAssociation;

  GetApiAssociationResponse({
    this.apiAssociation,
  });

  factory GetApiAssociationResponse.fromJson(Map<String, dynamic> json) {
    return GetApiAssociationResponse(
      apiAssociation: json['apiAssociation'] != null
          ? ApiAssociation.fromJson(
              json['apiAssociation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiAssociation = this.apiAssociation;
    return {
      if (apiAssociation != null) 'apiAssociation': apiAssociation,
    };
  }
}

/// Represents the output of a <code>GetApiCache</code> operation.
class GetApiCacheResponse {
  /// The <code>ApiCache</code> object.
  final ApiCache? apiCache;

  GetApiCacheResponse({
    this.apiCache,
  });

  factory GetApiCacheResponse.fromJson(Map<String, dynamic> json) {
    return GetApiCacheResponse(
      apiCache: json['apiCache'] != null
          ? ApiCache.fromJson(json['apiCache'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiCache = this.apiCache;
    return {
      if (apiCache != null) 'apiCache': apiCache,
    };
  }
}

class GetDataSourceIntrospectionResponse {
  /// The introspection ID. Each introspection contains a unique ID that can be
  /// used to reference the instrospection record.
  final String? introspectionId;

  /// The <code>DataSourceIntrospectionResult</code> object data.
  final DataSourceIntrospectionResult? introspectionResult;

  /// The status of the introspection during retrieval. By default, when a new
  /// instrospection is being retrieved, the status will be set to
  /// <code>PROCESSING</code>. Once the operation has been completed, the status
  /// will change to <code>SUCCESS</code> or <code>FAILED</code> depending on how
  /// the data was parsed. A <code>FAILED</code> operation will return an error
  /// and its details as an <code>introspectionStatusDetail</code>.
  final DataSourceIntrospectionStatus? introspectionStatus;

  /// The error detail field. When a <code>FAILED</code>
  /// <code>introspectionStatus</code> is returned, the
  /// <code>introspectionStatusDetail</code> will also return the exact error that
  /// was generated during the operation.
  final String? introspectionStatusDetail;

  GetDataSourceIntrospectionResponse({
    this.introspectionId,
    this.introspectionResult,
    this.introspectionStatus,
    this.introspectionStatusDetail,
  });

  factory GetDataSourceIntrospectionResponse.fromJson(
      Map<String, dynamic> json) {
    return GetDataSourceIntrospectionResponse(
      introspectionId: json['introspectionId'] as String?,
      introspectionResult: json['introspectionResult'] != null
          ? DataSourceIntrospectionResult.fromJson(
              json['introspectionResult'] as Map<String, dynamic>)
          : null,
      introspectionStatus: (json['introspectionStatus'] as String?)
          ?.let(DataSourceIntrospectionStatus.fromString),
      introspectionStatusDetail: json['introspectionStatusDetail'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final introspectionId = this.introspectionId;
    final introspectionResult = this.introspectionResult;
    final introspectionStatus = this.introspectionStatus;
    final introspectionStatusDetail = this.introspectionStatusDetail;
    return {
      if (introspectionId != null) 'introspectionId': introspectionId,
      if (introspectionResult != null)
        'introspectionResult': introspectionResult,
      if (introspectionStatus != null)
        'introspectionStatus': introspectionStatus.value,
      if (introspectionStatusDetail != null)
        'introspectionStatusDetail': introspectionStatusDetail,
    };
  }
}

class GetDataSourceResponse {
  /// The <code>DataSource</code> object.
  final DataSource? dataSource;

  GetDataSourceResponse({
    this.dataSource,
  });

  factory GetDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return GetDataSourceResponse(
      dataSource: json['dataSource'] != null
          ? DataSource.fromJson(json['dataSource'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSource = this.dataSource;
    return {
      if (dataSource != null) 'dataSource': dataSource,
    };
  }
}

class GetDomainNameResponse {
  /// The configuration for the <code>DomainName</code>.
  final DomainNameConfig? domainNameConfig;

  GetDomainNameResponse({
    this.domainNameConfig,
  });

  factory GetDomainNameResponse.fromJson(Map<String, dynamic> json) {
    return GetDomainNameResponse(
      domainNameConfig: json['domainNameConfig'] != null
          ? DomainNameConfig.fromJson(
              json['domainNameConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final domainNameConfig = this.domainNameConfig;
    return {
      if (domainNameConfig != null) 'domainNameConfig': domainNameConfig,
    };
  }
}

class GetFunctionResponse {
  /// The <code>Function</code> object.
  final FunctionConfiguration? functionConfiguration;

  GetFunctionResponse({
    this.functionConfiguration,
  });

  factory GetFunctionResponse.fromJson(Map<String, dynamic> json) {
    return GetFunctionResponse(
      functionConfiguration: json['functionConfiguration'] != null
          ? FunctionConfiguration.fromJson(
              json['functionConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final functionConfiguration = this.functionConfiguration;
    return {
      if (functionConfiguration != null)
        'functionConfiguration': functionConfiguration,
    };
  }
}

class GetGraphqlApiEnvironmentVariablesResponse {
  /// The payload containing each environmental variable in the <code>"key" :
  /// "value"</code> format.
  final Map<String, String>? environmentVariables;

  GetGraphqlApiEnvironmentVariablesResponse({
    this.environmentVariables,
  });

  factory GetGraphqlApiEnvironmentVariablesResponse.fromJson(
      Map<String, dynamic> json) {
    return GetGraphqlApiEnvironmentVariablesResponse(
      environmentVariables:
          (json['environmentVariables'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final environmentVariables = this.environmentVariables;
    return {
      if (environmentVariables != null)
        'environmentVariables': environmentVariables,
    };
  }
}

class GetGraphqlApiResponse {
  /// The <code>GraphqlApi</code> object.
  final GraphqlApi? graphqlApi;

  GetGraphqlApiResponse({
    this.graphqlApi,
  });

  factory GetGraphqlApiResponse.fromJson(Map<String, dynamic> json) {
    return GetGraphqlApiResponse(
      graphqlApi: json['graphqlApi'] != null
          ? GraphqlApi.fromJson(json['graphqlApi'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final graphqlApi = this.graphqlApi;
    return {
      if (graphqlApi != null) 'graphqlApi': graphqlApi,
    };
  }
}

class GetIntrospectionSchemaResponse {
  /// The schema, in GraphQL Schema Definition Language (SDL) format.
  ///
  /// For more information, see the <a
  /// href="http://graphql.org/learn/schema/">GraphQL SDL documentation</a>.
  final Uint8List? schema;

  GetIntrospectionSchemaResponse({
    this.schema,
  });

  Map<String, dynamic> toJson() {
    final schema = this.schema;
    return {
      if (schema != null) 'schema': base64Encode(schema),
    };
  }
}

class GetResolverResponse {
  /// The <code>Resolver</code> object.
  final Resolver? resolver;

  GetResolverResponse({
    this.resolver,
  });

  factory GetResolverResponse.fromJson(Map<String, dynamic> json) {
    return GetResolverResponse(
      resolver: json['resolver'] != null
          ? Resolver.fromJson(json['resolver'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final resolver = this.resolver;
    return {
      if (resolver != null) 'resolver': resolver,
    };
  }
}

class GetSchemaCreationStatusResponse {
  /// Detailed information about the status of the schema creation operation.
  final String? details;

  /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or
  /// NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
  final SchemaStatus? status;

  GetSchemaCreationStatusResponse({
    this.details,
    this.status,
  });

  factory GetSchemaCreationStatusResponse.fromJson(Map<String, dynamic> json) {
    return GetSchemaCreationStatusResponse(
      details: json['details'] as String?,
      status: (json['status'] as String?)?.let(SchemaStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final details = this.details;
    final status = this.status;
    return {
      if (details != null) 'details': details,
      if (status != null) 'status': status.value,
    };
  }
}

class GetSourceApiAssociationResponse {
  /// The <code>SourceApiAssociation</code> object data.
  final SourceApiAssociation? sourceApiAssociation;

  GetSourceApiAssociationResponse({
    this.sourceApiAssociation,
  });

  factory GetSourceApiAssociationResponse.fromJson(Map<String, dynamic> json) {
    return GetSourceApiAssociationResponse(
      sourceApiAssociation: json['sourceApiAssociation'] != null
          ? SourceApiAssociation.fromJson(
              json['sourceApiAssociation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociation = this.sourceApiAssociation;
    return {
      if (sourceApiAssociation != null)
        'sourceApiAssociation': sourceApiAssociation,
    };
  }
}

class GetTypeResponse {
  /// The <code>Type</code> object.
  final Type? type;

  GetTypeResponse({
    this.type,
  });

  factory GetTypeResponse.fromJson(Map<String, dynamic> json) {
    return GetTypeResponse(
      type: json['type'] != null
          ? Type.fromJson(json['type'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'type': type,
    };
  }
}

enum GraphQLApiIntrospectionConfig {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const GraphQLApiIntrospectionConfig(this.value);

  static GraphQLApiIntrospectionConfig fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum GraphQLApiIntrospectionConfig'));
}

enum GraphQLApiType {
  graphql('GRAPHQL'),
  merged('MERGED'),
  ;

  final String value;

  const GraphQLApiType(this.value);

  static GraphQLApiType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum GraphQLApiType'));
}

enum GraphQLApiVisibility {
  global('GLOBAL'),
  private('PRIVATE'),
  ;

  final String value;

  const GraphQLApiVisibility(this.value);

  static GraphQLApiVisibility fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum GraphQLApiVisibility'));
}

/// Describes a GraphQL API.
class GraphqlApi {
  /// A list of additional authentication providers for the
  /// <code>GraphqlApi</code> API.
  final List<AdditionalAuthenticationProvider>?
      additionalAuthenticationProviders;

  /// The API ID.
  final String? apiId;

  /// The value that indicates whether the GraphQL API is a standard API
  /// (<code>GRAPHQL</code>) or merged API (<code>MERGED</code>).
  final GraphQLApiType? apiType;

  /// The Amazon Resource Name (ARN).
  final String? arn;

  /// The authentication type.
  final AuthenticationType? authenticationType;

  /// The DNS records for the API.
  final Map<String, String>? dns;

  /// The <code>enhancedMetricsConfig</code> object.
  final EnhancedMetricsConfig? enhancedMetricsConfig;

  /// Sets the value of the GraphQL API to enable (<code>ENABLED</code>) or
  /// disable (<code>DISABLED</code>) introspection. If no value is provided, the
  /// introspection configuration will be set to <code>ENABLED</code> by default.
  /// This field will produce an error if the operation attempts to use the
  /// introspection feature while this field is disabled.
  ///
  /// For more information about introspection, see <a
  /// href="https://graphql.org/learn/introspection/">GraphQL introspection</a>.
  final GraphQLApiIntrospectionConfig? introspectionConfig;

  /// Configuration for Lambda function authorization.
  final LambdaAuthorizerConfig? lambdaAuthorizerConfig;

  /// The Amazon CloudWatch Logs configuration.
  final LogConfig? logConfig;

  /// The Identity and Access Management service role ARN for a merged API. The
  /// AppSync service assumes this role on behalf of the Merged API to validate
  /// access to source APIs at runtime and to prompt the <code>AUTO_MERGE</code>
  /// to update the merged API endpoint with the source API changes automatically.
  final String? mergedApiExecutionRoleArn;

  /// The API name.
  final String? name;

  /// The OpenID Connect configuration.
  final OpenIDConnectConfig? openIDConnectConfig;

  /// The account owner of the GraphQL API.
  final String? owner;

  /// The owner contact information for an API resource.
  ///
  /// This field accepts any string input with a length of 0 - 256 characters.
  final String? ownerContact;

  /// The maximum depth a query can have in a single request. Depth refers to the
  /// amount of nested levels allowed in the body of query. The default value is
  /// <code>0</code> (or unspecified), which indicates there's no depth limit. If
  /// you set a limit, it can be between <code>1</code> and <code>75</code> nested
  /// levels. This field will produce a limit error if the operation falls out of
  /// bounds.
  ///
  /// Note that fields can still be set to nullable or non-nullable. If a
  /// non-nullable field produces an error, the error will be thrown upwards to
  /// the first nullable field available.
  final int? queryDepthLimit;

  /// The maximum number of resolvers that can be invoked in a single request. The
  /// default value is <code>0</code> (or unspecified), which will set the limit
  /// to <code>10000</code>. When specified, the limit value can be between
  /// <code>1</code> and <code>10000</code>. This field will produce a limit error
  /// if the operation falls out of bounds.
  final int? resolverCountLimit;

  /// The tags.
  final Map<String, String>? tags;

  /// The URIs.
  final Map<String, String>? uris;

  /// The Amazon Cognito user pool configuration.
  final UserPoolConfig? userPoolConfig;

  /// Sets the value of the GraphQL API to public (<code>GLOBAL</code>) or private
  /// (<code>PRIVATE</code>). If no value is provided, the visibility will be set
  /// to <code>GLOBAL</code> by default. This value cannot be changed once the API
  /// has been created.
  final GraphQLApiVisibility? visibility;

  /// The ARN of the WAF access control list (ACL) associated with this
  /// <code>GraphqlApi</code>, if one exists.
  final String? wafWebAclArn;

  /// A flag indicating whether to use X-Ray tracing for this
  /// <code>GraphqlApi</code>.
  final bool? xrayEnabled;

  GraphqlApi({
    this.additionalAuthenticationProviders,
    this.apiId,
    this.apiType,
    this.arn,
    this.authenticationType,
    this.dns,
    this.enhancedMetricsConfig,
    this.introspectionConfig,
    this.lambdaAuthorizerConfig,
    this.logConfig,
    this.mergedApiExecutionRoleArn,
    this.name,
    this.openIDConnectConfig,
    this.owner,
    this.ownerContact,
    this.queryDepthLimit,
    this.resolverCountLimit,
    this.tags,
    this.uris,
    this.userPoolConfig,
    this.visibility,
    this.wafWebAclArn,
    this.xrayEnabled,
  });

  factory GraphqlApi.fromJson(Map<String, dynamic> json) {
    return GraphqlApi(
      additionalAuthenticationProviders:
          (json['additionalAuthenticationProviders'] as List?)
              ?.nonNulls
              .map((e) => AdditionalAuthenticationProvider.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
      apiId: json['apiId'] as String?,
      apiType: (json['apiType'] as String?)?.let(GraphQLApiType.fromString),
      arn: json['arn'] as String?,
      authenticationType: (json['authenticationType'] as String?)
          ?.let(AuthenticationType.fromString),
      dns: (json['dns'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      enhancedMetricsConfig: json['enhancedMetricsConfig'] != null
          ? EnhancedMetricsConfig.fromJson(
              json['enhancedMetricsConfig'] as Map<String, dynamic>)
          : null,
      introspectionConfig: (json['introspectionConfig'] as String?)
          ?.let(GraphQLApiIntrospectionConfig.fromString),
      lambdaAuthorizerConfig: json['lambdaAuthorizerConfig'] != null
          ? LambdaAuthorizerConfig.fromJson(
              json['lambdaAuthorizerConfig'] as Map<String, dynamic>)
          : null,
      logConfig: json['logConfig'] != null
          ? LogConfig.fromJson(json['logConfig'] as Map<String, dynamic>)
          : null,
      mergedApiExecutionRoleArn: json['mergedApiExecutionRoleArn'] as String?,
      name: json['name'] as String?,
      openIDConnectConfig: json['openIDConnectConfig'] != null
          ? OpenIDConnectConfig.fromJson(
              json['openIDConnectConfig'] as Map<String, dynamic>)
          : null,
      owner: json['owner'] as String?,
      ownerContact: json['ownerContact'] as String?,
      queryDepthLimit: json['queryDepthLimit'] as int?,
      resolverCountLimit: json['resolverCountLimit'] as int?,
      tags: (json['tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      uris: (json['uris'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
      userPoolConfig: json['userPoolConfig'] != null
          ? UserPoolConfig.fromJson(
              json['userPoolConfig'] as Map<String, dynamic>)
          : null,
      visibility:
          (json['visibility'] as String?)?.let(GraphQLApiVisibility.fromString),
      wafWebAclArn: json['wafWebAclArn'] as String?,
      xrayEnabled: json['xrayEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final additionalAuthenticationProviders =
        this.additionalAuthenticationProviders;
    final apiId = this.apiId;
    final apiType = this.apiType;
    final arn = this.arn;
    final authenticationType = this.authenticationType;
    final dns = this.dns;
    final enhancedMetricsConfig = this.enhancedMetricsConfig;
    final introspectionConfig = this.introspectionConfig;
    final lambdaAuthorizerConfig = this.lambdaAuthorizerConfig;
    final logConfig = this.logConfig;
    final mergedApiExecutionRoleArn = this.mergedApiExecutionRoleArn;
    final name = this.name;
    final openIDConnectConfig = this.openIDConnectConfig;
    final owner = this.owner;
    final ownerContact = this.ownerContact;
    final queryDepthLimit = this.queryDepthLimit;
    final resolverCountLimit = this.resolverCountLimit;
    final tags = this.tags;
    final uris = this.uris;
    final userPoolConfig = this.userPoolConfig;
    final visibility = this.visibility;
    final wafWebAclArn = this.wafWebAclArn;
    final xrayEnabled = this.xrayEnabled;
    return {
      if (additionalAuthenticationProviders != null)
        'additionalAuthenticationProviders': additionalAuthenticationProviders,
      if (apiId != null) 'apiId': apiId,
      if (apiType != null) 'apiType': apiType.value,
      if (arn != null) 'arn': arn,
      if (authenticationType != null)
        'authenticationType': authenticationType.value,
      if (dns != null) 'dns': dns,
      if (enhancedMetricsConfig != null)
        'enhancedMetricsConfig': enhancedMetricsConfig,
      if (introspectionConfig != null)
        'introspectionConfig': introspectionConfig.value,
      if (lambdaAuthorizerConfig != null)
        'lambdaAuthorizerConfig': lambdaAuthorizerConfig,
      if (logConfig != null) 'logConfig': logConfig,
      if (mergedApiExecutionRoleArn != null)
        'mergedApiExecutionRoleArn': mergedApiExecutionRoleArn,
      if (name != null) 'name': name,
      if (openIDConnectConfig != null)
        'openIDConnectConfig': openIDConnectConfig,
      if (owner != null) 'owner': owner,
      if (ownerContact != null) 'ownerContact': ownerContact,
      if (queryDepthLimit != null) 'queryDepthLimit': queryDepthLimit,
      if (resolverCountLimit != null) 'resolverCountLimit': resolverCountLimit,
      if (tags != null) 'tags': tags,
      if (uris != null) 'uris': uris,
      if (userPoolConfig != null) 'userPoolConfig': userPoolConfig,
      if (visibility != null) 'visibility': visibility.value,
      if (wafWebAclArn != null) 'wafWebAclArn': wafWebAclArn,
      if (xrayEnabled != null) 'xrayEnabled': xrayEnabled,
    };
  }
}

/// Describes an HTTP data source configuration.
class HttpDataSourceConfig {
  /// The authorization configuration in case the HTTP endpoint requires
  /// authorization.
  final AuthorizationConfig? authorizationConfig;

  /// The HTTP URL endpoint. You can specify either the domain name or IP, and
  /// port combination, and the URL scheme must be HTTP or HTTPS. If you don't
  /// specify the port, AppSync uses the default port 80 for the HTTP endpoint and
  /// port 443 for HTTPS endpoints.
  final String? endpoint;

  HttpDataSourceConfig({
    this.authorizationConfig,
    this.endpoint,
  });

  factory HttpDataSourceConfig.fromJson(Map<String, dynamic> json) {
    return HttpDataSourceConfig(
      authorizationConfig: json['authorizationConfig'] != null
          ? AuthorizationConfig.fromJson(
              json['authorizationConfig'] as Map<String, dynamic>)
          : null,
      endpoint: json['endpoint'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final authorizationConfig = this.authorizationConfig;
    final endpoint = this.endpoint;
    return {
      if (authorizationConfig != null)
        'authorizationConfig': authorizationConfig,
      if (endpoint != null) 'endpoint': endpoint,
    };
  }
}

/// A <code>LambdaAuthorizerConfig</code> specifies how to authorize AppSync API
/// access when using the <code>AWS_LAMBDA</code> authorizer mode. Be aware that
/// an AppSync API can have only one Lambda authorizer configured at a time.
class LambdaAuthorizerConfig {
  /// The Amazon Resource Name (ARN) of the Lambda function to be called for
  /// authorization. This can be a standard Lambda ARN, a version ARN
  /// (<code>.../v3</code>), or an alias ARN.
  ///
  /// <b>Note</b>: This Lambda function must have the following resource-based
  /// policy assigned to it. When configuring Lambda authorizers in the console,
  /// this is done for you. To use the Command Line Interface (CLI), run the
  /// following:
  ///
  /// <code>aws lambda add-permission --function-name
  /// "arn:aws:lambda:us-east-2:111122223333:function:my-function" --statement-id
  /// "appsync" --principal appsync.amazonaws.com --action
  /// lambda:InvokeFunction</code>
  final String authorizerUri;

  /// The number of seconds a response should be cached for. The default is 0
  /// seconds, which disables caching. If you don't specify a value for
  /// <code>authorizerResultTtlInSeconds</code>, the default value is used. The
  /// maximum value is one hour (3600 seconds). The Lambda function can override
  /// this by returning a <code>ttlOverride</code> key in its response.
  final int? authorizerResultTtlInSeconds;

  /// A regular expression for validation of tokens before the Lambda function is
  /// called.
  final String? identityValidationExpression;

  LambdaAuthorizerConfig({
    required this.authorizerUri,
    this.authorizerResultTtlInSeconds,
    this.identityValidationExpression,
  });

  factory LambdaAuthorizerConfig.fromJson(Map<String, dynamic> json) {
    return LambdaAuthorizerConfig(
      authorizerUri: json['authorizerUri'] as String,
      authorizerResultTtlInSeconds:
          json['authorizerResultTtlInSeconds'] as int?,
      identityValidationExpression:
          json['identityValidationExpression'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final authorizerUri = this.authorizerUri;
    final authorizerResultTtlInSeconds = this.authorizerResultTtlInSeconds;
    final identityValidationExpression = this.identityValidationExpression;
    return {
      'authorizerUri': authorizerUri,
      if (authorizerResultTtlInSeconds != null)
        'authorizerResultTtlInSeconds': authorizerResultTtlInSeconds,
      if (identityValidationExpression != null)
        'identityValidationExpression': identityValidationExpression,
    };
  }
}

/// The <code>LambdaConflictHandlerConfig</code> object when configuring
/// <code>LAMBDA</code> as the Conflict Handler.
class LambdaConflictHandlerConfig {
  /// The Amazon Resource Name (ARN) for the Lambda function to use as the
  /// Conflict Handler.
  final String? lambdaConflictHandlerArn;

  LambdaConflictHandlerConfig({
    this.lambdaConflictHandlerArn,
  });

  factory LambdaConflictHandlerConfig.fromJson(Map<String, dynamic> json) {
    return LambdaConflictHandlerConfig(
      lambdaConflictHandlerArn: json['lambdaConflictHandlerArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lambdaConflictHandlerArn = this.lambdaConflictHandlerArn;
    return {
      if (lambdaConflictHandlerArn != null)
        'lambdaConflictHandlerArn': lambdaConflictHandlerArn,
    };
  }
}

/// Describes an Lambda data source configuration.
class LambdaDataSourceConfig {
  /// The Amazon Resource Name (ARN) for the Lambda function.
  final String lambdaFunctionArn;

  LambdaDataSourceConfig({
    required this.lambdaFunctionArn,
  });

  factory LambdaDataSourceConfig.fromJson(Map<String, dynamic> json) {
    return LambdaDataSourceConfig(
      lambdaFunctionArn: json['lambdaFunctionArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final lambdaFunctionArn = this.lambdaFunctionArn;
    return {
      'lambdaFunctionArn': lambdaFunctionArn,
    };
  }
}

class ListApiKeysResponse {
  /// The <code>ApiKey</code> objects.
  final List<ApiKey>? apiKeys;

  /// An identifier to pass in the next request to this operation to return the
  /// next set of items in the list.
  final String? nextToken;

  ListApiKeysResponse({
    this.apiKeys,
    this.nextToken,
  });

  factory ListApiKeysResponse.fromJson(Map<String, dynamic> json) {
    return ListApiKeysResponse(
      apiKeys: (json['apiKeys'] as List?)
          ?.nonNulls
          .map((e) => ApiKey.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final apiKeys = this.apiKeys;
    final nextToken = this.nextToken;
    return {
      if (apiKeys != null) 'apiKeys': apiKeys,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListDataSourcesResponse {
  /// The <code>DataSource</code> objects.
  final List<DataSource>? dataSources;

  /// An identifier to pass in the next request to this operation to return the
  /// next set of items in the list.
  final String? nextToken;

  ListDataSourcesResponse({
    this.dataSources,
    this.nextToken,
  });

  factory ListDataSourcesResponse.fromJson(Map<String, dynamic> json) {
    return ListDataSourcesResponse(
      dataSources: (json['dataSources'] as List?)
          ?.nonNulls
          .map((e) => DataSource.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSources = this.dataSources;
    final nextToken = this.nextToken;
    return {
      if (dataSources != null) 'dataSources': dataSources,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListDomainNamesResponse {
  /// Lists configurations for multiple domain names.
  final List<DomainNameConfig>? domainNameConfigs;

  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  final String? nextToken;

  ListDomainNamesResponse({
    this.domainNameConfigs,
    this.nextToken,
  });

  factory ListDomainNamesResponse.fromJson(Map<String, dynamic> json) {
    return ListDomainNamesResponse(
      domainNameConfigs: (json['domainNameConfigs'] as List?)
          ?.nonNulls
          .map((e) => DomainNameConfig.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final domainNameConfigs = this.domainNameConfigs;
    final nextToken = this.nextToken;
    return {
      if (domainNameConfigs != null) 'domainNameConfigs': domainNameConfigs,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListFunctionsResponse {
  /// A list of <code>Function</code> objects.
  final List<FunctionConfiguration>? functions;

  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  final String? nextToken;

  ListFunctionsResponse({
    this.functions,
    this.nextToken,
  });

  factory ListFunctionsResponse.fromJson(Map<String, dynamic> json) {
    return ListFunctionsResponse(
      functions: (json['functions'] as List?)
          ?.nonNulls
          .map((e) => FunctionConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final functions = this.functions;
    final nextToken = this.nextToken;
    return {
      if (functions != null) 'functions': functions,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListGraphqlApisResponse {
  /// The <code>GraphqlApi</code> objects.
  final List<GraphqlApi>? graphqlApis;

  /// An identifier to pass in the next request to this operation to return the
  /// next set of items in the list.
  final String? nextToken;

  ListGraphqlApisResponse({
    this.graphqlApis,
    this.nextToken,
  });

  factory ListGraphqlApisResponse.fromJson(Map<String, dynamic> json) {
    return ListGraphqlApisResponse(
      graphqlApis: (json['graphqlApis'] as List?)
          ?.nonNulls
          .map((e) => GraphqlApi.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['nextToken'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final graphqlApis = this.graphqlApis;
    final nextToken = this.nextToken;
    return {
      if (graphqlApis != null) 'graphqlApis': graphqlApis,
      if (nextToken != null) 'nextToken': nextToken,
    };
  }
}

class ListResolversByFunctionResponse {
  /// An identifier that you can use to return the next set of items in the list.
  final String? nextToken;

  /// The list of resolvers.
  final List<Resolver>? resolvers;

  ListResolversByFunctionResponse({
    this.nextToken,
    this.resolvers,
  });

  factory ListResolversByFunctionResponse.fromJson(Map<String, dynamic> json) {
    return ListResolversByFunctionResponse(
      nextToken: json['nextToken'] as String?,
      resolvers: (json['resolvers'] as List?)
          ?.nonNulls
          .map((e) => Resolver.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final resolvers = this.resolvers;
    return {
      if (nextToken != null) 'nextToken': nextToken,
      if (resolvers != null) 'resolvers': resolvers,
    };
  }
}

class ListResolversResponse {
  /// An identifier to pass in the next request to this operation to return the
  /// next set of items in the list.
  final String? nextToken;

  /// The <code>Resolver</code> objects.
  final List<Resolver>? resolvers;

  ListResolversResponse({
    this.nextToken,
    this.resolvers,
  });

  factory ListResolversResponse.fromJson(Map<String, dynamic> json) {
    return ListResolversResponse(
      nextToken: json['nextToken'] as String?,
      resolvers: (json['resolvers'] as List?)
          ?.nonNulls
          .map((e) => Resolver.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final resolvers = this.resolvers;
    return {
      if (nextToken != null) 'nextToken': nextToken,
      if (resolvers != null) 'resolvers': resolvers,
    };
  }
}

class ListSourceApiAssociationsResponse {
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  final String? nextToken;

  /// The <code>SourceApiAssociationSummary</code> object data.
  final List<SourceApiAssociationSummary>? sourceApiAssociationSummaries;

  ListSourceApiAssociationsResponse({
    this.nextToken,
    this.sourceApiAssociationSummaries,
  });

  factory ListSourceApiAssociationsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListSourceApiAssociationsResponse(
      nextToken: json['nextToken'] as String?,
      sourceApiAssociationSummaries: (json['sourceApiAssociationSummaries']
              as List?)
          ?.nonNulls
          .map((e) =>
              SourceApiAssociationSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final sourceApiAssociationSummaries = this.sourceApiAssociationSummaries;
    return {
      if (nextToken != null) 'nextToken': nextToken,
      if (sourceApiAssociationSummaries != null)
        'sourceApiAssociationSummaries': sourceApiAssociationSummaries,
    };
  }
}

class ListTagsForResourceResponse {
  /// A <code>TagMap</code> object.
  final Map<String, String>? tags;

  ListTagsForResourceResponse({
    this.tags,
  });

  factory ListTagsForResourceResponse.fromJson(Map<String, dynamic> json) {
    return ListTagsForResourceResponse(
      tags: (json['tags'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final tags = this.tags;
    return {
      if (tags != null) 'tags': tags,
    };
  }
}

class ListTypesByAssociationResponse {
  /// An identifier that was returned from the previous call to this operation,
  /// which you can use to return the next set of items in the list.
  final String? nextToken;

  /// The <code>Type</code> objects.
  final List<Type>? types;

  ListTypesByAssociationResponse({
    this.nextToken,
    this.types,
  });

  factory ListTypesByAssociationResponse.fromJson(Map<String, dynamic> json) {
    return ListTypesByAssociationResponse(
      nextToken: json['nextToken'] as String?,
      types: (json['types'] as List?)
          ?.nonNulls
          .map((e) => Type.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final types = this.types;
    return {
      if (nextToken != null) 'nextToken': nextToken,
      if (types != null) 'types': types,
    };
  }
}

class ListTypesResponse {
  /// An identifier to pass in the next request to this operation to return the
  /// next set of items in the list.
  final String? nextToken;

  /// The <code>Type</code> objects.
  final List<Type>? types;

  ListTypesResponse({
    this.nextToken,
    this.types,
  });

  factory ListTypesResponse.fromJson(Map<String, dynamic> json) {
    return ListTypesResponse(
      nextToken: json['nextToken'] as String?,
      types: (json['types'] as List?)
          ?.nonNulls
          .map((e) => Type.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final types = this.types;
    return {
      if (nextToken != null) 'nextToken': nextToken,
      if (types != null) 'types': types,
    };
  }
}

/// The Amazon CloudWatch Logs configuration.
class LogConfig {
  /// The service role that AppSync assumes to publish to CloudWatch logs in your
  /// account.
  final String cloudWatchLogsRoleArn;

  /// The field logging level. Values can be NONE, ERROR, or ALL.
  ///
  /// <ul>
  /// <li>
  /// <b>NONE</b>: No field-level logs are captured.
  /// </li>
  /// <li>
  /// <b>ERROR</b>: Logs the following information only for the fields that are in
  /// error:
  ///
  /// <ul>
  /// <li>
  /// The error section in the server response.
  /// </li>
  /// <li>
  /// Field-level errors.
  /// </li>
  /// <li>
  /// The generated request/response functions that got resolved for error fields.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <b>ALL</b>: The following information is logged for all fields in the query:
  ///
  /// <ul>
  /// <li>
  /// Field-level tracing information.
  /// </li>
  /// <li>
  /// The generated request/response functions that got resolved for each field.
  /// </li>
  /// </ul> </li>
  /// </ul>
  final FieldLogLevel fieldLogLevel;

  /// Set to TRUE to exclude sections that contain information such as headers,
  /// context, and evaluated mapping templates, regardless of logging level.
  final bool? excludeVerboseContent;

  LogConfig({
    required this.cloudWatchLogsRoleArn,
    required this.fieldLogLevel,
    this.excludeVerboseContent,
  });

  factory LogConfig.fromJson(Map<String, dynamic> json) {
    return LogConfig(
      cloudWatchLogsRoleArn: json['cloudWatchLogsRoleArn'] as String,
      fieldLogLevel:
          FieldLogLevel.fromString((json['fieldLogLevel'] as String)),
      excludeVerboseContent: json['excludeVerboseContent'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final cloudWatchLogsRoleArn = this.cloudWatchLogsRoleArn;
    final fieldLogLevel = this.fieldLogLevel;
    final excludeVerboseContent = this.excludeVerboseContent;
    return {
      'cloudWatchLogsRoleArn': cloudWatchLogsRoleArn,
      'fieldLogLevel': fieldLogLevel.value,
      if (excludeVerboseContent != null)
        'excludeVerboseContent': excludeVerboseContent,
    };
  }
}

enum MergeType {
  manualMerge('MANUAL_MERGE'),
  autoMerge('AUTO_MERGE'),
  ;

  final String value;

  const MergeType(this.value);

  static MergeType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum MergeType'));
}

/// Describes an OpenID Connect (OIDC) configuration.
class OpenIDConnectConfig {
  /// The issuer for the OIDC configuration. The issuer returned by discovery must
  /// exactly match the value of <code>iss</code> in the ID token.
  final String issuer;

  /// The number of milliseconds that a token is valid after being authenticated.
  final int? authTTL;

  /// The client identifier of the relying party at the OpenID identity provider.
  /// This identifier is typically obtained when the relying party is registered
  /// with the OpenID identity provider. You can specify a regular expression so
  /// that AppSync can validate against multiple client identifiers at a time.
  final String? clientId;

  /// The number of milliseconds that a token is valid after it's issued to a
  /// user.
  final int? iatTTL;

  OpenIDConnectConfig({
    required this.issuer,
    this.authTTL,
    this.clientId,
    this.iatTTL,
  });

  factory OpenIDConnectConfig.fromJson(Map<String, dynamic> json) {
    return OpenIDConnectConfig(
      issuer: json['issuer'] as String,
      authTTL: json['authTTL'] as int?,
      clientId: json['clientId'] as String?,
      iatTTL: json['iatTTL'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final issuer = this.issuer;
    final authTTL = this.authTTL;
    final clientId = this.clientId;
    final iatTTL = this.iatTTL;
    return {
      'issuer': issuer,
      if (authTTL != null) 'authTTL': authTTL,
      if (clientId != null) 'clientId': clientId,
      if (iatTTL != null) 'iatTTL': iatTTL,
    };
  }
}

/// Describes an OpenSearch data source configuration.
class OpenSearchServiceDataSourceConfig {
  /// The Amazon Web Services Region.
  final String awsRegion;

  /// The endpoint.
  final String endpoint;

  OpenSearchServiceDataSourceConfig({
    required this.awsRegion,
    required this.endpoint,
  });

  factory OpenSearchServiceDataSourceConfig.fromJson(
      Map<String, dynamic> json) {
    return OpenSearchServiceDataSourceConfig(
      awsRegion: json['awsRegion'] as String,
      endpoint: json['endpoint'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final awsRegion = this.awsRegion;
    final endpoint = this.endpoint;
    return {
      'awsRegion': awsRegion,
      'endpoint': endpoint,
    };
  }
}

enum OperationLevelMetricsConfig {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const OperationLevelMetricsConfig(this.value);

  static OperationLevelMetricsConfig fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum OperationLevelMetricsConfig'));
}

enum OutputType {
  sdl('SDL'),
  json('JSON'),
  ;

  final String value;

  const OutputType(this.value);

  static OutputType fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum OutputType'));
}

enum Ownership {
  currentAccount('CURRENT_ACCOUNT'),
  otherAccounts('OTHER_ACCOUNTS'),
  ;

  final String value;

  const Ownership(this.value);

  static Ownership fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum Ownership'));
}

/// The pipeline configuration for a resolver of kind <code>PIPELINE</code>.
class PipelineConfig {
  /// A list of <code>Function</code> objects.
  final List<String>? functions;

  PipelineConfig({
    this.functions,
  });

  factory PipelineConfig.fromJson(Map<String, dynamic> json) {
    return PipelineConfig(
      functions: (json['functions'] as List?)
          ?.nonNulls
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final functions = this.functions;
    return {
      if (functions != null) 'functions': functions,
    };
  }
}

class PutGraphqlApiEnvironmentVariablesResponse {
  /// The payload containing each environmental variable in the <code>"key" :
  /// "value"</code> format.
  final Map<String, String>? environmentVariables;

  PutGraphqlApiEnvironmentVariablesResponse({
    this.environmentVariables,
  });

  factory PutGraphqlApiEnvironmentVariablesResponse.fromJson(
      Map<String, dynamic> json) {
    return PutGraphqlApiEnvironmentVariablesResponse(
      environmentVariables:
          (json['environmentVariables'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final environmentVariables = this.environmentVariables;
    return {
      if (environmentVariables != null)
        'environmentVariables': environmentVariables,
    };
  }
}

/// Contains the metadata required to introspect the RDS cluster.
class RdsDataApiConfig {
  /// The name of the database in the cluster.
  final String databaseName;

  /// The resource ARN of the RDS cluster.
  final String resourceArn;

  /// The secret's ARN that was obtained from Secrets Manager. A secret consists
  /// of secret information, the secret value, plus metadata about the secret. A
  /// secret value can be a string or binary. It typically includes the ARN,
  /// secret name and description, policies, tags, encryption key from the Key
  /// Management Service, and key rotation data.
  final String secretArn;

  RdsDataApiConfig({
    required this.databaseName,
    required this.resourceArn,
    required this.secretArn,
  });

  Map<String, dynamic> toJson() {
    final databaseName = this.databaseName;
    final resourceArn = this.resourceArn;
    final secretArn = this.secretArn;
    return {
      'databaseName': databaseName,
      'resourceArn': resourceArn,
      'secretArn': secretArn,
    };
  }
}

/// The Amazon Relational Database Service (Amazon RDS) HTTP endpoint
/// configuration.
class RdsHttpEndpointConfig {
  /// Amazon Web Services Region for Amazon RDS HTTP endpoint.
  final String? awsRegion;

  /// Amazon Web Services secret store Amazon Resource Name (ARN) for database
  /// credentials.
  final String? awsSecretStoreArn;

  /// Logical database name.
  final String? databaseName;

  /// Amazon RDS cluster Amazon Resource Name (ARN).
  final String? dbClusterIdentifier;

  /// Logical schema name.
  final String? schema;

  RdsHttpEndpointConfig({
    this.awsRegion,
    this.awsSecretStoreArn,
    this.databaseName,
    this.dbClusterIdentifier,
    this.schema,
  });

  factory RdsHttpEndpointConfig.fromJson(Map<String, dynamic> json) {
    return RdsHttpEndpointConfig(
      awsRegion: json['awsRegion'] as String?,
      awsSecretStoreArn: json['awsSecretStoreArn'] as String?,
      databaseName: json['databaseName'] as String?,
      dbClusterIdentifier: json['dbClusterIdentifier'] as String?,
      schema: json['schema'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsRegion = this.awsRegion;
    final awsSecretStoreArn = this.awsSecretStoreArn;
    final databaseName = this.databaseName;
    final dbClusterIdentifier = this.dbClusterIdentifier;
    final schema = this.schema;
    return {
      if (awsRegion != null) 'awsRegion': awsRegion,
      if (awsSecretStoreArn != null) 'awsSecretStoreArn': awsSecretStoreArn,
      if (databaseName != null) 'databaseName': databaseName,
      if (dbClusterIdentifier != null)
        'dbClusterIdentifier': dbClusterIdentifier,
      if (schema != null) 'schema': schema,
    };
  }
}

/// Describes a relational database data source configuration.
class RelationalDatabaseDataSourceConfig {
  /// Amazon RDS HTTP endpoint settings.
  final RdsHttpEndpointConfig? rdsHttpEndpointConfig;

  /// Source type for the relational database.
  ///
  /// <ul>
  /// <li>
  /// <b>RDS_HTTP_ENDPOINT</b>: The relational database source type is an Amazon
  /// Relational Database Service (Amazon RDS) HTTP endpoint.
  /// </li>
  /// </ul>
  final RelationalDatabaseSourceType? relationalDatabaseSourceType;

  RelationalDatabaseDataSourceConfig({
    this.rdsHttpEndpointConfig,
    this.relationalDatabaseSourceType,
  });

  factory RelationalDatabaseDataSourceConfig.fromJson(
      Map<String, dynamic> json) {
    return RelationalDatabaseDataSourceConfig(
      rdsHttpEndpointConfig: json['rdsHttpEndpointConfig'] != null
          ? RdsHttpEndpointConfig.fromJson(
              json['rdsHttpEndpointConfig'] as Map<String, dynamic>)
          : null,
      relationalDatabaseSourceType:
          (json['relationalDatabaseSourceType'] as String?)
              ?.let(RelationalDatabaseSourceType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final rdsHttpEndpointConfig = this.rdsHttpEndpointConfig;
    final relationalDatabaseSourceType = this.relationalDatabaseSourceType;
    return {
      if (rdsHttpEndpointConfig != null)
        'rdsHttpEndpointConfig': rdsHttpEndpointConfig,
      if (relationalDatabaseSourceType != null)
        'relationalDatabaseSourceType': relationalDatabaseSourceType.value,
    };
  }
}

enum RelationalDatabaseSourceType {
  rdsHttpEndpoint('RDS_HTTP_ENDPOINT'),
  ;

  final String value;

  const RelationalDatabaseSourceType(this.value);

  static RelationalDatabaseSourceType fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum RelationalDatabaseSourceType'));
}

/// Describes a resolver.
class Resolver {
  /// The caching configuration for the resolver.
  final CachingConfig? cachingConfig;

  /// The <code>resolver</code> code that contains the request and response
  /// functions. When code is used, the <code>runtime</code> is required. The
  /// <code>runtime</code> value must be <code>APPSYNC_JS</code>.
  final String? code;

  /// The resolver data source name.
  final String? dataSourceName;

  /// The resolver field name.
  final String? fieldName;

  /// The resolver type.
  ///
  /// <ul>
  /// <li>
  /// <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is the default resolver
  /// type. You can use a UNIT resolver to run a GraphQL query against a single
  /// data source.
  /// </li>
  /// <li>
  /// <b>PIPELINE</b>: A PIPELINE resolver type. You can use a PIPELINE resolver
  /// to invoke a series of <code>Function</code> objects in a serial manner. You
  /// can use a pipeline resolver to run a GraphQL query against multiple data
  /// sources.
  /// </li>
  /// </ul>
  final ResolverKind? kind;

  /// The maximum batching size for a resolver.
  final int? maxBatchSize;

  /// Enables or disables enhanced resolver metrics for specified resolvers. Note
  /// that <code>metricsConfig</code> won't be used unless the
  /// <code>resolverLevelMetricsBehavior</code> value is set to
  /// <code>PER_RESOLVER_METRICS</code>. If the
  /// <code>resolverLevelMetricsBehavior</code> is set to
  /// <code>FULL_REQUEST_RESOLVER_METRICS</code> instead,
  /// <code>metricsConfig</code> will be ignored. However, you can still set its
  /// value.
  ///
  /// <code>metricsConfig</code> can be <code>ENABLED</code> or
  /// <code>DISABLED</code>.
  final ResolverLevelMetricsConfig? metricsConfig;

  /// The <code>PipelineConfig</code>.
  final PipelineConfig? pipelineConfig;

  /// The request mapping template.
  final String? requestMappingTemplate;

  /// The resolver Amazon Resource Name (ARN).
  final String? resolverArn;

  /// The response mapping template.
  final String? responseMappingTemplate;
  final AppSyncRuntime? runtime;

  /// The <code>SyncConfig</code> for a resolver attached to a versioned data
  /// source.
  final SyncConfig? syncConfig;

  /// The resolver type name.
  final String? typeName;

  Resolver({
    this.cachingConfig,
    this.code,
    this.dataSourceName,
    this.fieldName,
    this.kind,
    this.maxBatchSize,
    this.metricsConfig,
    this.pipelineConfig,
    this.requestMappingTemplate,
    this.resolverArn,
    this.responseMappingTemplate,
    this.runtime,
    this.syncConfig,
    this.typeName,
  });

  factory Resolver.fromJson(Map<String, dynamic> json) {
    return Resolver(
      cachingConfig: json['cachingConfig'] != null
          ? CachingConfig.fromJson(
              json['cachingConfig'] as Map<String, dynamic>)
          : null,
      code: json['code'] as String?,
      dataSourceName: json['dataSourceName'] as String?,
      fieldName: json['fieldName'] as String?,
      kind: (json['kind'] as String?)?.let(ResolverKind.fromString),
      maxBatchSize: json['maxBatchSize'] as int?,
      metricsConfig: (json['metricsConfig'] as String?)
          ?.let(ResolverLevelMetricsConfig.fromString),
      pipelineConfig: json['pipelineConfig'] != null
          ? PipelineConfig.fromJson(
              json['pipelineConfig'] as Map<String, dynamic>)
          : null,
      requestMappingTemplate: json['requestMappingTemplate'] as String?,
      resolverArn: json['resolverArn'] as String?,
      responseMappingTemplate: json['responseMappingTemplate'] as String?,
      runtime: json['runtime'] != null
          ? AppSyncRuntime.fromJson(json['runtime'] as Map<String, dynamic>)
          : null,
      syncConfig: json['syncConfig'] != null
          ? SyncConfig.fromJson(json['syncConfig'] as Map<String, dynamic>)
          : null,
      typeName: json['typeName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final cachingConfig = this.cachingConfig;
    final code = this.code;
    final dataSourceName = this.dataSourceName;
    final fieldName = this.fieldName;
    final kind = this.kind;
    final maxBatchSize = this.maxBatchSize;
    final metricsConfig = this.metricsConfig;
    final pipelineConfig = this.pipelineConfig;
    final requestMappingTemplate = this.requestMappingTemplate;
    final resolverArn = this.resolverArn;
    final responseMappingTemplate = this.responseMappingTemplate;
    final runtime = this.runtime;
    final syncConfig = this.syncConfig;
    final typeName = this.typeName;
    return {
      if (cachingConfig != null) 'cachingConfig': cachingConfig,
      if (code != null) 'code': code,
      if (dataSourceName != null) 'dataSourceName': dataSourceName,
      if (fieldName != null) 'fieldName': fieldName,
      if (kind != null) 'kind': kind.value,
      if (maxBatchSize != null) 'maxBatchSize': maxBatchSize,
      if (metricsConfig != null) 'metricsConfig': metricsConfig.value,
      if (pipelineConfig != null) 'pipelineConfig': pipelineConfig,
      if (requestMappingTemplate != null)
        'requestMappingTemplate': requestMappingTemplate,
      if (resolverArn != null) 'resolverArn': resolverArn,
      if (responseMappingTemplate != null)
        'responseMappingTemplate': responseMappingTemplate,
      if (runtime != null) 'runtime': runtime,
      if (syncConfig != null) 'syncConfig': syncConfig,
      if (typeName != null) 'typeName': typeName,
    };
  }
}

enum ResolverKind {
  unit('UNIT'),
  pipeline('PIPELINE'),
  ;

  final String value;

  const ResolverKind(this.value);

  static ResolverKind fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum ResolverKind'));
}

enum ResolverLevelMetricsBehavior {
  fullRequestResolverMetrics('FULL_REQUEST_RESOLVER_METRICS'),
  perResolverMetrics('PER_RESOLVER_METRICS'),
  ;

  final String value;

  const ResolverLevelMetricsBehavior(this.value);

  static ResolverLevelMetricsBehavior fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ResolverLevelMetricsBehavior'));
}

enum ResolverLevelMetricsConfig {
  enabled('ENABLED'),
  disabled('DISABLED'),
  ;

  final String value;

  const ResolverLevelMetricsConfig(this.value);

  static ResolverLevelMetricsConfig fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum ResolverLevelMetricsConfig'));
}

enum RuntimeName {
  appsyncJs('APPSYNC_JS'),
  ;

  final String value;

  const RuntimeName(this.value);

  static RuntimeName fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () => throw Exception('$value is not known in enum RuntimeName'));
}

enum SchemaStatus {
  processing('PROCESSING'),
  active('ACTIVE'),
  deleting('DELETING'),
  failed('FAILED'),
  success('SUCCESS'),
  notApplicable('NOT_APPLICABLE'),
  ;

  final String value;

  const SchemaStatus(this.value);

  static SchemaStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () =>
              throw Exception('$value is not known in enum SchemaStatus'));
}

/// Describes the configuration of a source API. A source API is a GraphQL API
/// that is linked to a merged API. There can be multiple source APIs attached
/// to each merged API. When linked to a merged API, the source API's schema,
/// data sources, and resolvers will be combined with other linked source API
/// data to form a new, singular API.
///
/// Source APIs can originate from your account or from other accounts via
/// Amazon Web Services Resource Access Manager. For more information about
/// sharing resources from other accounts, see <a
/// href="https://docs.aws.amazon.com/ram/latest/userguide/what-is.html">What is
/// Amazon Web Services Resource Access Manager?</a> in the <i>Amazon Web
/// Services Resource Access Manager</i> guide.
class SourceApiAssociation {
  /// The Amazon Resource Name (ARN) of the source API association.
  final String? associationArn;

  /// The ID generated by the AppSync service for the source API association.
  final String? associationId;

  /// The description field.
  final String? description;

  /// The datetime value of the last successful merge of the source API
  /// association. The result will be in UTC format and your local time zone.
  final DateTime? lastSuccessfulMergeDate;

  /// The Amazon Resource Name (ARN) of the AppSync Merged API.
  final String? mergedApiArn;

  /// The ID of the AppSync Merged API.
  final String? mergedApiId;

  /// The Amazon Resource Name (ARN) of the AppSync source API.
  final String? sourceApiArn;

  /// The <code>SourceApiAssociationConfig</code> object data.
  final SourceApiAssociationConfig? sourceApiAssociationConfig;

  /// The state of the source API association.
  final SourceApiAssociationStatus? sourceApiAssociationStatus;

  /// The detailed message related to the current state of the source API
  /// association.
  final String? sourceApiAssociationStatusDetail;

  /// The ID of the AppSync source API.
  final String? sourceApiId;

  SourceApiAssociation({
    this.associationArn,
    this.associationId,
    this.description,
    this.lastSuccessfulMergeDate,
    this.mergedApiArn,
    this.mergedApiId,
    this.sourceApiArn,
    this.sourceApiAssociationConfig,
    this.sourceApiAssociationStatus,
    this.sourceApiAssociationStatusDetail,
    this.sourceApiId,
  });

  factory SourceApiAssociation.fromJson(Map<String, dynamic> json) {
    return SourceApiAssociation(
      associationArn: json['associationArn'] as String?,
      associationId: json['associationId'] as String?,
      description: json['description'] as String?,
      lastSuccessfulMergeDate:
          timeStampFromJson(json['lastSuccessfulMergeDate']),
      mergedApiArn: json['mergedApiArn'] as String?,
      mergedApiId: json['mergedApiId'] as String?,
      sourceApiArn: json['sourceApiArn'] as String?,
      sourceApiAssociationConfig: json['sourceApiAssociationConfig'] != null
          ? SourceApiAssociationConfig.fromJson(
              json['sourceApiAssociationConfig'] as Map<String, dynamic>)
          : null,
      sourceApiAssociationStatus:
          (json['sourceApiAssociationStatus'] as String?)
              ?.let(SourceApiAssociationStatus.fromString),
      sourceApiAssociationStatusDetail:
          json['sourceApiAssociationStatusDetail'] as String?,
      sourceApiId: json['sourceApiId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationArn = this.associationArn;
    final associationId = this.associationId;
    final description = this.description;
    final lastSuccessfulMergeDate = this.lastSuccessfulMergeDate;
    final mergedApiArn = this.mergedApiArn;
    final mergedApiId = this.mergedApiId;
    final sourceApiArn = this.sourceApiArn;
    final sourceApiAssociationConfig = this.sourceApiAssociationConfig;
    final sourceApiAssociationStatus = this.sourceApiAssociationStatus;
    final sourceApiAssociationStatusDetail =
        this.sourceApiAssociationStatusDetail;
    final sourceApiId = this.sourceApiId;
    return {
      if (associationArn != null) 'associationArn': associationArn,
      if (associationId != null) 'associationId': associationId,
      if (description != null) 'description': description,
      if (lastSuccessfulMergeDate != null)
        'lastSuccessfulMergeDate': unixTimestampToJson(lastSuccessfulMergeDate),
      if (mergedApiArn != null) 'mergedApiArn': mergedApiArn,
      if (mergedApiId != null) 'mergedApiId': mergedApiId,
      if (sourceApiArn != null) 'sourceApiArn': sourceApiArn,
      if (sourceApiAssociationConfig != null)
        'sourceApiAssociationConfig': sourceApiAssociationConfig,
      if (sourceApiAssociationStatus != null)
        'sourceApiAssociationStatus': sourceApiAssociationStatus.value,
      if (sourceApiAssociationStatusDetail != null)
        'sourceApiAssociationStatusDetail': sourceApiAssociationStatusDetail,
      if (sourceApiId != null) 'sourceApiId': sourceApiId,
    };
  }
}

/// Describes properties used to specify configurations related to a source API.
class SourceApiAssociationConfig {
  /// The property that indicates which merging option is enabled in the source
  /// API association.
  ///
  /// Valid merge types are <code>MANUAL_MERGE</code> (default) and
  /// <code>AUTO_MERGE</code>. Manual merges are the default behavior and require
  /// the user to trigger any changes from the source APIs to the merged API
  /// manually. Auto merges subscribe the merged API to the changes performed on
  /// the source APIs so that any change in the source APIs are also made to the
  /// merged API. Auto merges use <code>MergedApiExecutionRoleArn</code> to
  /// perform merge operations.
  final MergeType? mergeType;

  SourceApiAssociationConfig({
    this.mergeType,
  });

  factory SourceApiAssociationConfig.fromJson(Map<String, dynamic> json) {
    return SourceApiAssociationConfig(
      mergeType: (json['mergeType'] as String?)?.let(MergeType.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final mergeType = this.mergeType;
    return {
      if (mergeType != null) 'mergeType': mergeType.value,
    };
  }
}

enum SourceApiAssociationStatus {
  mergeScheduled('MERGE_SCHEDULED'),
  mergeFailed('MERGE_FAILED'),
  mergeSuccess('MERGE_SUCCESS'),
  mergeInProgress('MERGE_IN_PROGRESS'),
  autoMergeScheduleFailed('AUTO_MERGE_SCHEDULE_FAILED'),
  deletionScheduled('DELETION_SCHEDULED'),
  deletionInProgress('DELETION_IN_PROGRESS'),
  deletionFailed('DELETION_FAILED'),
  ;

  final String value;

  const SourceApiAssociationStatus(this.value);

  static SourceApiAssociationStatus fromString(String value) =>
      values.firstWhere((e) => e.value == value,
          orElse: () => throw Exception(
              '$value is not known in enum SourceApiAssociationStatus'));
}

/// Describes the ARNs and IDs of associations, Merged APIs, and source APIs.
class SourceApiAssociationSummary {
  /// The Amazon Resource Name (ARN) of the source API association.
  final String? associationArn;

  /// The ID generated by the AppSync service for the source API association.
  final String? associationId;

  /// The description field.
  final String? description;

  /// The Amazon Resource Name (ARN) of the AppSync Merged API.
  final String? mergedApiArn;

  /// The ID of the AppSync Merged API.
  final String? mergedApiId;

  /// The Amazon Resource Name (ARN) of the AppSync Source API.
  final String? sourceApiArn;

  /// The ID of the AppSync source API.
  final String? sourceApiId;

  SourceApiAssociationSummary({
    this.associationArn,
    this.associationId,
    this.description,
    this.mergedApiArn,
    this.mergedApiId,
    this.sourceApiArn,
    this.sourceApiId,
  });

  factory SourceApiAssociationSummary.fromJson(Map<String, dynamic> json) {
    return SourceApiAssociationSummary(
      associationArn: json['associationArn'] as String?,
      associationId: json['associationId'] as String?,
      description: json['description'] as String?,
      mergedApiArn: json['mergedApiArn'] as String?,
      mergedApiId: json['mergedApiId'] as String?,
      sourceApiArn: json['sourceApiArn'] as String?,
      sourceApiId: json['sourceApiId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final associationArn = this.associationArn;
    final associationId = this.associationId;
    final description = this.description;
    final mergedApiArn = this.mergedApiArn;
    final mergedApiId = this.mergedApiId;
    final sourceApiArn = this.sourceApiArn;
    final sourceApiId = this.sourceApiId;
    return {
      if (associationArn != null) 'associationArn': associationArn,
      if (associationId != null) 'associationId': associationId,
      if (description != null) 'description': description,
      if (mergedApiArn != null) 'mergedApiArn': mergedApiArn,
      if (mergedApiId != null) 'mergedApiId': mergedApiId,
      if (sourceApiArn != null) 'sourceApiArn': sourceApiArn,
      if (sourceApiId != null) 'sourceApiId': sourceApiId,
    };
  }
}

class StartDataSourceIntrospectionResponse {
  /// The introspection ID. Each introspection contains a unique ID that can be
  /// used to reference the instrospection record.
  final String? introspectionId;

  /// The status of the introspection during creation. By default, when a new
  /// instrospection has been created, the status will be set to
  /// <code>PROCESSING</code>. Once the operation has been completed, the status
  /// will change to <code>SUCCESS</code> or <code>FAILED</code> depending on how
  /// the data was parsed. A <code>FAILED</code> operation will return an error
  /// and its details as an <code>introspectionStatusDetail</code>.
  final DataSourceIntrospectionStatus? introspectionStatus;

  /// The error detail field. When a <code>FAILED</code>
  /// <code>introspectionStatus</code> is returned, the
  /// <code>introspectionStatusDetail</code> will also return the exact error that
  /// was generated during the operation.
  final String? introspectionStatusDetail;

  StartDataSourceIntrospectionResponse({
    this.introspectionId,
    this.introspectionStatus,
    this.introspectionStatusDetail,
  });

  factory StartDataSourceIntrospectionResponse.fromJson(
      Map<String, dynamic> json) {
    return StartDataSourceIntrospectionResponse(
      introspectionId: json['introspectionId'] as String?,
      introspectionStatus: (json['introspectionStatus'] as String?)
          ?.let(DataSourceIntrospectionStatus.fromString),
      introspectionStatusDetail: json['introspectionStatusDetail'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final introspectionId = this.introspectionId;
    final introspectionStatus = this.introspectionStatus;
    final introspectionStatusDetail = this.introspectionStatusDetail;
    return {
      if (introspectionId != null) 'introspectionId': introspectionId,
      if (introspectionStatus != null)
        'introspectionStatus': introspectionStatus.value,
      if (introspectionStatusDetail != null)
        'introspectionStatusDetail': introspectionStatusDetail,
    };
  }
}

class StartSchemaCreationResponse {
  /// The current state of the schema (PROCESSING, FAILED, SUCCESS, or
  /// NOT_APPLICABLE). When the schema is in the ACTIVE state, you can add data.
  final SchemaStatus? status;

  StartSchemaCreationResponse({
    this.status,
  });

  factory StartSchemaCreationResponse.fromJson(Map<String, dynamic> json) {
    return StartSchemaCreationResponse(
      status: (json['status'] as String?)?.let(SchemaStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'status': status.value,
    };
  }
}

class StartSchemaMergeResponse {
  /// The state of the source API association.
  final SourceApiAssociationStatus? sourceApiAssociationStatus;

  StartSchemaMergeResponse({
    this.sourceApiAssociationStatus,
  });

  factory StartSchemaMergeResponse.fromJson(Map<String, dynamic> json) {
    return StartSchemaMergeResponse(
      sourceApiAssociationStatus:
          (json['sourceApiAssociationStatus'] as String?)
              ?.let(SourceApiAssociationStatus.fromString),
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociationStatus = this.sourceApiAssociationStatus;
    return {
      if (sourceApiAssociationStatus != null)
        'sourceApiAssociationStatus': sourceApiAssociationStatus.value,
    };
  }
}

/// Describes a Sync configuration for a resolver.
///
/// Specifies which Conflict Detection strategy and Resolution strategy to use
/// when the resolver is invoked.
class SyncConfig {
  /// The Conflict Detection strategy to use.
  ///
  /// <ul>
  /// <li>
  /// <b>VERSION</b>: Detect conflicts based on object versions for this resolver.
  /// </li>
  /// <li>
  /// <b>NONE</b>: Do not detect conflicts when invoking this resolver.
  /// </li>
  /// </ul>
  final ConflictDetectionType? conflictDetection;

  /// The Conflict Resolution strategy to perform in the event of a conflict.
  ///
  /// <ul>
  /// <li>
  /// <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by rejecting mutations when
  /// versions don't match the latest version at the server.
  /// </li>
  /// <li>
  /// <b>AUTOMERGE</b>: Resolve conflicts with the Automerge conflict resolution
  /// strategy.
  /// </li>
  /// <li>
  /// <b>LAMBDA</b>: Resolve conflicts with an Lambda function supplied in the
  /// <code>LambdaConflictHandlerConfig</code>.
  /// </li>
  /// </ul>
  final ConflictHandlerType? conflictHandler;

  /// The <code>LambdaConflictHandlerConfig</code> when configuring
  /// <code>LAMBDA</code> as the Conflict Handler.
  final LambdaConflictHandlerConfig? lambdaConflictHandlerConfig;

  SyncConfig({
    this.conflictDetection,
    this.conflictHandler,
    this.lambdaConflictHandlerConfig,
  });

  factory SyncConfig.fromJson(Map<String, dynamic> json) {
    return SyncConfig(
      conflictDetection: (json['conflictDetection'] as String?)
          ?.let(ConflictDetectionType.fromString),
      conflictHandler: (json['conflictHandler'] as String?)
          ?.let(ConflictHandlerType.fromString),
      lambdaConflictHandlerConfig: json['lambdaConflictHandlerConfig'] != null
          ? LambdaConflictHandlerConfig.fromJson(
              json['lambdaConflictHandlerConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final conflictDetection = this.conflictDetection;
    final conflictHandler = this.conflictHandler;
    final lambdaConflictHandlerConfig = this.lambdaConflictHandlerConfig;
    return {
      if (conflictDetection != null)
        'conflictDetection': conflictDetection.value,
      if (conflictHandler != null) 'conflictHandler': conflictHandler.value,
      if (lambdaConflictHandlerConfig != null)
        'lambdaConflictHandlerConfig': lambdaConflictHandlerConfig,
    };
  }
}

class TagResourceResponse {
  TagResourceResponse();

  factory TagResourceResponse.fromJson(Map<String, dynamic> _) {
    return TagResourceResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Describes a type.
class Type {
  /// The type Amazon Resource Name (ARN).
  final String? arn;

  /// The type definition.
  final String? definition;

  /// The type description.
  final String? description;

  /// The type format: SDL or JSON.
  final TypeDefinitionFormat? format;

  /// The type name.
  final String? name;

  Type({
    this.arn,
    this.definition,
    this.description,
    this.format,
    this.name,
  });

  factory Type.fromJson(Map<String, dynamic> json) {
    return Type(
      arn: json['arn'] as String?,
      definition: json['definition'] as String?,
      description: json['description'] as String?,
      format: (json['format'] as String?)?.let(TypeDefinitionFormat.fromString),
      name: json['name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final definition = this.definition;
    final description = this.description;
    final format = this.format;
    final name = this.name;
    return {
      if (arn != null) 'arn': arn,
      if (definition != null) 'definition': definition,
      if (description != null) 'description': description,
      if (format != null) 'format': format.value,
      if (name != null) 'name': name,
    };
  }
}

enum TypeDefinitionFormat {
  sdl('SDL'),
  json('JSON'),
  ;

  final String value;

  const TypeDefinitionFormat(this.value);

  static TypeDefinitionFormat fromString(String value) => values.firstWhere(
      (e) => e.value == value,
      orElse: () =>
          throw Exception('$value is not known in enum TypeDefinitionFormat'));
}

class UntagResourceResponse {
  UntagResourceResponse();

  factory UntagResourceResponse.fromJson(Map<String, dynamic> _) {
    return UntagResourceResponse();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// Represents the output of a <code>UpdateApiCache</code> operation.
class UpdateApiCacheResponse {
  /// The <code>ApiCache</code> object.
  final ApiCache? apiCache;

  UpdateApiCacheResponse({
    this.apiCache,
  });

  factory UpdateApiCacheResponse.fromJson(Map<String, dynamic> json) {
    return UpdateApiCacheResponse(
      apiCache: json['apiCache'] != null
          ? ApiCache.fromJson(json['apiCache'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiCache = this.apiCache;
    return {
      if (apiCache != null) 'apiCache': apiCache,
    };
  }
}

class UpdateApiKeyResponse {
  /// The API key.
  final ApiKey? apiKey;

  UpdateApiKeyResponse({
    this.apiKey,
  });

  factory UpdateApiKeyResponse.fromJson(Map<String, dynamic> json) {
    return UpdateApiKeyResponse(
      apiKey: json['apiKey'] != null
          ? ApiKey.fromJson(json['apiKey'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final apiKey = this.apiKey;
    return {
      if (apiKey != null) 'apiKey': apiKey,
    };
  }
}

class UpdateDataSourceResponse {
  /// The updated <code>DataSource</code> object.
  final DataSource? dataSource;

  UpdateDataSourceResponse({
    this.dataSource,
  });

  factory UpdateDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDataSourceResponse(
      dataSource: json['dataSource'] != null
          ? DataSource.fromJson(json['dataSource'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSource = this.dataSource;
    return {
      if (dataSource != null) 'dataSource': dataSource,
    };
  }
}

class UpdateDomainNameResponse {
  /// The configuration for the <code>DomainName</code>.
  final DomainNameConfig? domainNameConfig;

  UpdateDomainNameResponse({
    this.domainNameConfig,
  });

  factory UpdateDomainNameResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDomainNameResponse(
      domainNameConfig: json['domainNameConfig'] != null
          ? DomainNameConfig.fromJson(
              json['domainNameConfig'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final domainNameConfig = this.domainNameConfig;
    return {
      if (domainNameConfig != null) 'domainNameConfig': domainNameConfig,
    };
  }
}

class UpdateFunctionResponse {
  /// The <code>Function</code> object.
  final FunctionConfiguration? functionConfiguration;

  UpdateFunctionResponse({
    this.functionConfiguration,
  });

  factory UpdateFunctionResponse.fromJson(Map<String, dynamic> json) {
    return UpdateFunctionResponse(
      functionConfiguration: json['functionConfiguration'] != null
          ? FunctionConfiguration.fromJson(
              json['functionConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final functionConfiguration = this.functionConfiguration;
    return {
      if (functionConfiguration != null)
        'functionConfiguration': functionConfiguration,
    };
  }
}

class UpdateGraphqlApiResponse {
  /// The updated <code>GraphqlApi</code> object.
  final GraphqlApi? graphqlApi;

  UpdateGraphqlApiResponse({
    this.graphqlApi,
  });

  factory UpdateGraphqlApiResponse.fromJson(Map<String, dynamic> json) {
    return UpdateGraphqlApiResponse(
      graphqlApi: json['graphqlApi'] != null
          ? GraphqlApi.fromJson(json['graphqlApi'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final graphqlApi = this.graphqlApi;
    return {
      if (graphqlApi != null) 'graphqlApi': graphqlApi,
    };
  }
}

class UpdateResolverResponse {
  /// The updated <code>Resolver</code> object.
  final Resolver? resolver;

  UpdateResolverResponse({
    this.resolver,
  });

  factory UpdateResolverResponse.fromJson(Map<String, dynamic> json) {
    return UpdateResolverResponse(
      resolver: json['resolver'] != null
          ? Resolver.fromJson(json['resolver'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final resolver = this.resolver;
    return {
      if (resolver != null) 'resolver': resolver,
    };
  }
}

class UpdateSourceApiAssociationResponse {
  /// The <code>SourceApiAssociation</code> object data.
  final SourceApiAssociation? sourceApiAssociation;

  UpdateSourceApiAssociationResponse({
    this.sourceApiAssociation,
  });

  factory UpdateSourceApiAssociationResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateSourceApiAssociationResponse(
      sourceApiAssociation: json['sourceApiAssociation'] != null
          ? SourceApiAssociation.fromJson(
              json['sourceApiAssociation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sourceApiAssociation = this.sourceApiAssociation;
    return {
      if (sourceApiAssociation != null)
        'sourceApiAssociation': sourceApiAssociation,
    };
  }
}

class UpdateTypeResponse {
  /// The updated <code>Type</code> object.
  final Type? type;

  UpdateTypeResponse({
    this.type,
  });

  factory UpdateTypeResponse.fromJson(Map<String, dynamic> json) {
    return UpdateTypeResponse(
      type: json['type'] != null
          ? Type.fromJson(json['type'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      if (type != null) 'type': type,
    };
  }
}

/// Describes an Amazon Cognito user pool configuration.
class UserPoolConfig {
  /// The Amazon Web Services Region in which the user pool was created.
  final String awsRegion;

  /// The action that you want your GraphQL API to take when a request that uses
  /// Amazon Cognito user pool authentication doesn't match the Amazon Cognito
  /// user pool configuration.
  final DefaultAction defaultAction;

  /// The user pool ID.
  final String userPoolId;

  /// A regular expression for validating the incoming Amazon Cognito user pool
  /// app client ID. If this value isn't set, no filtering is applied.
  final String? appIdClientRegex;

  UserPoolConfig({
    required this.awsRegion,
    required this.defaultAction,
    required this.userPoolId,
    this.appIdClientRegex,
  });

  factory UserPoolConfig.fromJson(Map<String, dynamic> json) {
    return UserPoolConfig(
      awsRegion: json['awsRegion'] as String,
      defaultAction:
          DefaultAction.fromString((json['defaultAction'] as String)),
      userPoolId: json['userPoolId'] as String,
      appIdClientRegex: json['appIdClientRegex'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsRegion = this.awsRegion;
    final defaultAction = this.defaultAction;
    final userPoolId = this.userPoolId;
    final appIdClientRegex = this.appIdClientRegex;
    return {
      'awsRegion': awsRegion,
      'defaultAction': defaultAction.value,
      'userPoolId': userPoolId,
      if (appIdClientRegex != null) 'appIdClientRegex': appIdClientRegex,
    };
  }
}

class AccessDeniedException extends _s.GenericAwsException {
  AccessDeniedException({String? type, String? message})
      : super(type: type, code: 'AccessDeniedException', message: message);
}

class ApiKeyLimitExceededException extends _s.GenericAwsException {
  ApiKeyLimitExceededException({String? type, String? message})
      : super(
            type: type, code: 'ApiKeyLimitExceededException', message: message);
}

class ApiKeyValidityOutOfBoundsException extends _s.GenericAwsException {
  ApiKeyValidityOutOfBoundsException({String? type, String? message})
      : super(
            type: type,
            code: 'ApiKeyValidityOutOfBoundsException',
            message: message);
}

class ApiLimitExceededException extends _s.GenericAwsException {
  ApiLimitExceededException({String? type, String? message})
      : super(type: type, code: 'ApiLimitExceededException', message: message);
}

class BadRequestException extends _s.GenericAwsException {
  BadRequestException({String? type, String? message})
      : super(type: type, code: 'BadRequestException', message: message);
}

class ConcurrentModificationException extends _s.GenericAwsException {
  ConcurrentModificationException({String? type, String? message})
      : super(
            type: type,
            code: 'ConcurrentModificationException',
            message: message);
}

class GraphQLSchemaException extends _s.GenericAwsException {
  GraphQLSchemaException({String? type, String? message})
      : super(type: type, code: 'GraphQLSchemaException', message: message);
}

class InternalFailureException extends _s.GenericAwsException {
  InternalFailureException({String? type, String? message})
      : super(type: type, code: 'InternalFailureException', message: message);
}

class LimitExceededException extends _s.GenericAwsException {
  LimitExceededException({String? type, String? message})
      : super(type: type, code: 'LimitExceededException', message: message);
}

class NotFoundException extends _s.GenericAwsException {
  NotFoundException({String? type, String? message})
      : super(type: type, code: 'NotFoundException', message: message);
}

class UnauthorizedException extends _s.GenericAwsException {
  UnauthorizedException({String? type, String? message})
      : super(type: type, code: 'UnauthorizedException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'AccessDeniedException': (type, message) =>
      AccessDeniedException(type: type, message: message),
  'ApiKeyLimitExceededException': (type, message) =>
      ApiKeyLimitExceededException(type: type, message: message),
  'ApiKeyValidityOutOfBoundsException': (type, message) =>
      ApiKeyValidityOutOfBoundsException(type: type, message: message),
  'ApiLimitExceededException': (type, message) =>
      ApiLimitExceededException(type: type, message: message),
  'BadRequestException': (type, message) =>
      BadRequestException(type: type, message: message),
  'ConcurrentModificationException': (type, message) =>
      ConcurrentModificationException(type: type, message: message),
  'GraphQLSchemaException': (type, message) =>
      GraphQLSchemaException(type: type, message: message),
  'InternalFailureException': (type, message) =>
      InternalFailureException(type: type, message: message),
  'LimitExceededException': (type, message) =>
      LimitExceededException(type: type, message: message),
  'NotFoundException': (type, message) =>
      NotFoundException(type: type, message: message),
  'UnauthorizedException': (type, message) =>
      UnauthorizedException(type: type, message: message),
};
