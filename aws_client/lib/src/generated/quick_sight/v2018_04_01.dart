// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        nonNullableTimeStampFromJson,
        timeStampFromJson;

export '../../shared/shared.dart' show AwsClientCredentials;

/// Amazon QuickSight is a fully managed, serverless business intelligence
/// service for the Amazon Web Services Cloud that makes it easy to extend data
/// and insights to every user in your organization. This API reference contains
/// documentation for a programming interface that you can use to manage Amazon
/// QuickSight.
class QuickSight {
  final _s.RestJsonProtocol _protocol;
  QuickSight({
    required String region,
    _s.AwsClientCredentials? credentials,
    _s.AwsClientCredentialsProvider? credentialsProvider,
    _s.Client? client,
    String? endpointUrl,
  }) : _protocol = _s.RestJsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'quicksight',
          ),
          region: region,
          credentials: credentials,
          credentialsProvider: credentialsProvider,
          endpointUrl: endpointUrl,
        );

  /// Closes the internal HTTP client if none was provided at creation.
  /// If a client was passed as a constructor argument, this becomes a noop.
  ///
  /// It's important to close all clients when it's done being used; failing to
  /// do so can cause the Dart process to hang.
  void close() {
    _protocol.close();
  }

  /// Cancels an ongoing ingestion of data into SPICE.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset used in the ingestion.
  ///
  /// Parameter [ingestionId] :
  /// An ID for the ingestion.
  Future<CancelIngestionResponse> cancelIngestion({
    required String awsAccountId,
    required String dataSetId,
    required String ingestionId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/ingestions/${Uri.encodeComponent(ingestionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CancelIngestionResponse.fromJson(response);
  }

  /// Creates Amazon QuickSight customizations for the current Amazon Web
  /// Services Region. Currently, you can add a custom default theme by using
  /// the <code>CreateAccountCustomization</code> or
  /// <code>UpdateAccountCustomization</code> API operation. To further
  /// customize Amazon QuickSight by removing Amazon QuickSight sample assets
  /// and videos for all new users, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-quicksight.html">Customizing
  /// Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide.</i>
  ///
  /// You can create customizations for your Amazon Web Services account or, if
  /// you specify a namespace, for a QuickSight namespace instead.
  /// Customizations that apply to a namespace always override customizations
  /// that apply to an Amazon Web Services account. To find out which
  /// customizations apply, use the <code>DescribeAccountCustomization</code>
  /// API operation.
  ///
  /// Before you use the <code>CreateAccountCustomization</code> API operation
  /// to add a theme as the namespace default, make sure that you first share
  /// the theme with the namespace. If you don't share it with the namespace,
  /// the theme isn't visible to your users even if you make it the default
  /// theme. To check if the theme is shared, view the current permissions by
  /// using the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeThemePermissions.html">DescribeThemePermissions</a>
  /// </code> API operation. To share the theme, grant permissions by using the
  /// <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateThemePermissions.html">UpdateThemePermissions</a>
  /// </code> API operation.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [accountCustomization] :
  /// The Amazon QuickSight customizations you're adding in the current Amazon
  /// Web Services Region. You can add these to an Amazon Web Services account
  /// and a QuickSight namespace.
  ///
  /// For example, you can add a default theme by setting
  /// <code>AccountCustomization</code> to the midnight theme:
  /// <code>"AccountCustomization": { "DefaultTheme":
  /// "arn:aws:quicksight::aws:theme/MIDNIGHT" }</code>. Or, you can add a
  /// custom theme by specifying <code>"AccountCustomization": { "DefaultTheme":
  /// "arn:aws:quicksight:us-west-2:111122223333:theme/bdb844d0-0fe9-4d9d-b520-0fe602d93639"
  /// }</code>.
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to customize
  /// Amazon QuickSight for.
  ///
  /// Parameter [namespace] :
  /// The Amazon QuickSight namespace that you want to add customizations to.
  ///
  /// Parameter [tags] :
  /// A list of the tags that you want to attach to this resource.
  Future<CreateAccountCustomizationResponse> createAccountCustomization({
    required AccountCustomization accountCustomization,
    required String awsAccountId,
    String? namespace,
    List<Tag>? tags,
  }) async {
    final $query = <String, List<String>>{
      if (namespace != null) 'namespace': [namespace],
    };
    final $payload = <String, dynamic>{
      'AccountCustomization': accountCustomization,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/customizations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return CreateAccountCustomizationResponse.fromJson(response);
  }

  /// Creates an Amazon QuickSight account, or subscribes to Amazon QuickSight
  /// Q.
  ///
  /// The Amazon Web Services Region for the account is derived from what is
  /// configured in the CLI or SDK.
  ///
  /// Before you use this operation, make sure that you can connect to an
  /// existing Amazon Web Services account. If you don't have an Amazon Web
  /// Services account, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/setting-up-aws-sign-up.html">Sign
  /// up for Amazon Web Services</a> in the <i>Amazon QuickSight User Guide</i>.
  /// The person who signs up for Amazon QuickSight needs to have the correct
  /// Identity and Access Management (IAM) permissions. For more information,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/iam-policy-examples.html">IAM
  /// Policy Examples for Amazon QuickSight</a> in the <i>Amazon QuickSight User
  /// Guide</i>.
  ///
  /// If your IAM policy includes both the <code>Subscribe</code> and
  /// <code>CreateAccountSubscription</code> actions, make sure that both
  /// actions are set to <code>Allow</code>. If either action is set to
  /// <code>Deny</code>, the <code>Deny</code> action prevails and your API call
  /// fails.
  ///
  /// You can't pass an existing IAM role to access other Amazon Web Services
  /// services using this API operation. To pass your existing IAM role to
  /// Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/security_iam_service-with-iam.html#security-create-iam-role">Passing
  /// IAM roles to Amazon QuickSight</a> in the <i>Amazon QuickSight User
  /// Guide</i>.
  ///
  /// You can't set default resource access on the new account from the Amazon
  /// QuickSight API. Instead, add default resource access from the Amazon
  /// QuickSight console. For more information about setting default resource
  /// access to Amazon Web Services services, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/scoping-policies-defaults.html">Setting
  /// default resource access to Amazon Web Services services</a> in the
  /// <i>Amazon QuickSight User Guide</i>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [PreconditionNotMetException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [accountName] :
  /// The name of your Amazon QuickSight account. This name is unique over all
  /// of Amazon Web Services, and it appears only when users sign in. You can't
  /// change <code>AccountName</code> value after the Amazon QuickSight account
  /// is created.
  ///
  /// Parameter [authenticationMethod] :
  /// The method that you want to use to authenticate your Amazon QuickSight
  /// account.
  ///
  /// If you choose <code>ACTIVE_DIRECTORY</code>, provide an
  /// <code>ActiveDirectoryName</code> and an <code>AdminGroup</code> associated
  /// with your Active Directory.
  ///
  /// If you choose <code>IAM_IDENTITY_CENTER</code>, provide an
  /// <code>AdminGroup</code> associated with your IAM Identity Center account.
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account that you're using to
  /// create your Amazon QuickSight account.
  ///
  /// Parameter [notificationEmail] :
  /// The email address that you want Amazon QuickSight to send notifications to
  /// regarding your Amazon QuickSight account or Amazon QuickSight
  /// subscription.
  ///
  /// Parameter [activeDirectoryName] :
  /// The name of your Active Directory. This field is required if
  /// <code>ACTIVE_DIRECTORY</code> is the selected authentication method of the
  /// new Amazon QuickSight account.
  ///
  /// Parameter [adminGroup] :
  /// The admin group associated with your Active Directory or IAM Identity
  /// Center account. Either this field or the <code>AdminProGroup</code> field
  /// is required if <code>ACTIVE_DIRECTORY</code> or
  /// <code>IAM_IDENTITY_CENTER</code> is the selected authentication method of
  /// the new Amazon QuickSight account.
  ///
  /// For more information about using IAM Identity Center in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html">Using
  /// IAM Identity Center with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide. For more information about using Active
  /// Directory in Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html">Using
  /// Active Directory with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide.
  ///
  /// Parameter [adminProGroup] :
  /// The admin pro group associated with your Active Directory or IAM Identity
  /// Center account. Either this field or the <code>AdminGroup</code> field is
  /// required if <code>ACTIVE_DIRECTORY</code> or
  /// <code>IAM_IDENTITY_CENTER</code> is the selected authentication method of
  /// the new Amazon QuickSight account.
  ///
  /// For more information about using IAM Identity Center in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html">Using
  /// IAM Identity Center with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide. For more information about using Active
  /// Directory in Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html">Using
  /// Active Directory with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide.
  ///
  /// Parameter [authorGroup] :
  /// The author group associated with your Active Directory or IAM Identity
  /// Center account.
  ///
  /// For more information about using IAM Identity Center in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html">Using
  /// IAM Identity Center with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide. For more information about using Active
  /// Directory in Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html">Using
  /// Active Directory with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide.
  ///
  /// Parameter [authorProGroup] :
  /// The author pro group associated with your Active Directory or IAM Identity
  /// Center account.
  ///
  /// For more information about using IAM Identity Center in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html">Using
  /// IAM Identity Center with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide. For more information about using Active
  /// Directory in Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html">Using
  /// Active Directory with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide.
  ///
  /// Parameter [contactNumber] :
  /// A 10-digit phone number for the author of the Amazon QuickSight account to
  /// use for future communications. This field is required if
  /// <code>ENTERPPRISE_AND_Q</code> is the selected edition of the new Amazon
  /// QuickSight account.
  ///
  /// Parameter [directoryId] :
  /// The ID of the Active Directory that is associated with your Amazon
  /// QuickSight account.
  ///
  /// Parameter [edition] :
  /// The edition of Amazon QuickSight that you want your account to have.
  /// Currently, you can choose from <code>ENTERPRISE</code> or
  /// <code>ENTERPRISE_AND_Q</code>.
  ///
  /// If you choose <code>ENTERPRISE_AND_Q</code>, the following parameters are
  /// required:
  ///
  /// <ul>
  /// <li>
  /// <code>FirstName</code>
  /// </li>
  /// <li>
  /// <code>LastName</code>
  /// </li>
  /// <li>
  /// <code>EmailAddress</code>
  /// </li>
  /// <li>
  /// <code>ContactNumber</code>
  /// </li>
  /// </ul>
  ///
  /// Parameter [emailAddress] :
  /// The email address of the author of the Amazon QuickSight account to use
  /// for future communications. This field is required if
  /// <code>ENTERPPRISE_AND_Q</code> is the selected edition of the new Amazon
  /// QuickSight account.
  ///
  /// Parameter [firstName] :
  /// The first name of the author of the Amazon QuickSight account to use for
  /// future communications. This field is required if
  /// <code>ENTERPPRISE_AND_Q</code> is the selected edition of the new Amazon
  /// QuickSight account.
  ///
  /// Parameter [iAMIdentityCenterInstanceArn] :
  /// The Amazon Resource Name (ARN) for the IAM Identity Center instance.
  ///
  /// Parameter [lastName] :
  /// The last name of the author of the Amazon QuickSight account to use for
  /// future communications. This field is required if
  /// <code>ENTERPPRISE_AND_Q</code> is the selected edition of the new Amazon
  /// QuickSight account.
  ///
  /// Parameter [readerGroup] :
  /// The reader group associated with your Active Directory or IAM Identity
  /// Center account.
  ///
  /// For more information about using IAM Identity Center in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html">Using
  /// IAM Identity Center with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide. For more information about using Active
  /// Directory in Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html">Using
  /// Active Directory with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide.
  ///
  /// Parameter [readerProGroup] :
  /// The reader pro group associated with your Active Directory or IAM Identity
  /// Center account.
  ///
  /// For more information about using IAM Identity Center in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sec-identity-management-identity-center.html">Using
  /// IAM Identity Center with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide. For more information about using Active
  /// Directory in Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/aws-directory-service.html">Using
  /// Active Directory with Amazon QuickSight Enterprise Edition</a> in the
  /// Amazon QuickSight User Guide.
  ///
  /// Parameter [realm] :
  /// The realm of the Active Directory that is associated with your Amazon
  /// QuickSight account. This field is required if
  /// <code>ACTIVE_DIRECTORY</code> is the selected authentication method of the
  /// new Amazon QuickSight account.
  Future<CreateAccountSubscriptionResponse> createAccountSubscription({
    required String accountName,
    required AuthenticationMethodOption authenticationMethod,
    required String awsAccountId,
    required String notificationEmail,
    String? activeDirectoryName,
    List<String>? adminGroup,
    List<String>? adminProGroup,
    List<String>? authorGroup,
    List<String>? authorProGroup,
    String? contactNumber,
    String? directoryId,
    Edition? edition,
    String? emailAddress,
    String? firstName,
    String? iAMIdentityCenterInstanceArn,
    String? lastName,
    List<String>? readerGroup,
    List<String>? readerProGroup,
    String? realm,
  }) async {
    final $payload = <String, dynamic>{
      'AccountName': accountName,
      'AuthenticationMethod': authenticationMethod.toValue(),
      'NotificationEmail': notificationEmail,
      if (activeDirectoryName != null)
        'ActiveDirectoryName': activeDirectoryName,
      if (adminGroup != null) 'AdminGroup': adminGroup,
      if (adminProGroup != null) 'AdminProGroup': adminProGroup,
      if (authorGroup != null) 'AuthorGroup': authorGroup,
      if (authorProGroup != null) 'AuthorProGroup': authorProGroup,
      if (contactNumber != null) 'ContactNumber': contactNumber,
      if (directoryId != null) 'DirectoryId': directoryId,
      if (edition != null) 'Edition': edition.toValue(),
      if (emailAddress != null) 'EmailAddress': emailAddress,
      if (firstName != null) 'FirstName': firstName,
      if (iAMIdentityCenterInstanceArn != null)
        'IAMIdentityCenterInstanceArn': iAMIdentityCenterInstanceArn,
      if (lastName != null) 'LastName': lastName,
      if (readerGroup != null) 'ReaderGroup': readerGroup,
      if (readerProGroup != null) 'ReaderProGroup': readerProGroup,
      if (realm != null) 'Realm': realm,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/account/${Uri.encodeComponent(awsAccountId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateAccountSubscriptionResponse.fromJson(response);
  }

  /// Creates an analysis in Amazon QuickSight. Analyses can be created either
  /// from a template or from an <code>AnalysisDefinition</code>.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID for the analysis that you're creating. This ID displays in the URL
  /// of the analysis.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account where you are creating an
  /// analysis.
  ///
  /// Parameter [name] :
  /// A descriptive name for the analysis that you're creating. This name
  /// displays for the analysis in the Amazon QuickSight console.
  ///
  /// Parameter [definition] :
  /// The definition of an analysis.
  ///
  /// A definition is the data model of all features in a Dashboard, Template,
  /// or Analysis.
  ///
  /// Either a <code>SourceEntity</code> or a <code>Definition</code> must be
  /// provided in order for the request to be valid.
  ///
  /// Parameter [folderArns] :
  /// When you create the analysis, Amazon QuickSight adds the analysis to these
  /// folders.
  ///
  /// Parameter [parameters] :
  /// The parameter names and override values that you want to use. An analysis
  /// can have any parameter type, and some parameters might accept multiple
  /// values.
  ///
  /// Parameter [permissions] :
  /// A structure that describes the principals and the resource-level
  /// permissions on an analysis. You can use the <code>Permissions</code>
  /// structure to grant permissions by providing a list of Identity and Access
  /// Management (IAM) action information for each principal listed by Amazon
  /// Resource Name (ARN).
  ///
  /// To specify no permissions, omit <code>Permissions</code>.
  ///
  /// Parameter [sourceEntity] :
  /// A source entity to use for the analysis that you're creating. This
  /// metadata structure contains details that describe a source template and
  /// one or more datasets.
  ///
  /// Either a <code>SourceEntity</code> or a <code>Definition</code> must be
  /// provided in order for the request to be valid.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags
  /// assigned to the analysis.
  ///
  /// Parameter [themeArn] :
  /// The ARN for the theme to apply to the analysis that you're creating. To
  /// see the theme in the Amazon QuickSight console, make sure that you have
  /// access to it.
  ///
  /// Parameter [validationStrategy] :
  /// The option to relax the validation needed to create an analysis with
  /// definition objects. This skips the validation step for specific errors.
  Future<CreateAnalysisResponse> createAnalysis({
    required String analysisId,
    required String awsAccountId,
    required String name,
    AnalysisDefinition? definition,
    List<String>? folderArns,
    Parameters? parameters,
    List<ResourcePermission>? permissions,
    AnalysisSourceEntity? sourceEntity,
    List<Tag>? tags,
    String? themeArn,
    ValidationStrategy? validationStrategy,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      if (definition != null) 'Definition': definition,
      if (folderArns != null) 'FolderArns': folderArns,
      if (parameters != null) 'Parameters': parameters,
      if (permissions != null) 'Permissions': permissions,
      if (sourceEntity != null) 'SourceEntity': sourceEntity,
      if (tags != null) 'Tags': tags,
      if (themeArn != null) 'ThemeArn': themeArn,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateAnalysisResponse.fromJson(response);
  }

  /// Creates a dashboard from either a template or directly with a
  /// <code>DashboardDefinition</code>. To first create a template, see the
  /// <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html">CreateTemplate</a>
  /// </code> API operation.
  ///
  /// A dashboard is an entity in Amazon QuickSight that identifies Amazon
  /// QuickSight reports, created from analyses. You can share Amazon QuickSight
  /// dashboards. With the right permissions, you can create scheduled email
  /// reports from them. If you have the correct permissions, you can create a
  /// dashboard from a template that exists in a different Amazon Web Services
  /// account.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account where you want to create the
  /// dashboard.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard, also added to the IAM policy.
  ///
  /// Parameter [name] :
  /// The display name of the dashboard.
  ///
  /// Parameter [dashboardPublishOptions] :
  /// Options for publishing the dashboard when you create it:
  ///
  /// <ul>
  /// <li>
  /// <code>AvailabilityStatus</code> for <code>AdHocFilteringOption</code> -
  /// This status can be either <code>ENABLED</code> or <code>DISABLED</code>.
  /// When this is set to <code>DISABLED</code>, Amazon QuickSight disables the
  /// left filter pane on the published dashboard, which can be used for ad hoc
  /// (one-time) filtering. This option is <code>ENABLED</code> by default.
  /// </li>
  /// <li>
  /// <code>AvailabilityStatus</code> for <code>ExportToCSVOption</code> - This
  /// status can be either <code>ENABLED</code> or <code>DISABLED</code>. The
  /// visual option to export data to .CSV format isn't enabled when this is set
  /// to <code>DISABLED</code>. This option is <code>ENABLED</code> by default.
  /// </li>
  /// <li>
  /// <code>VisibilityState</code> for <code>SheetControlsOption</code> - This
  /// visibility state can be either <code>COLLAPSED</code> or
  /// <code>EXPANDED</code>. This option is <code>COLLAPSED</code> by default.
  /// </li>
  /// </ul>
  ///
  /// Parameter [definition] :
  /// The definition of a dashboard.
  ///
  /// A definition is the data model of all features in a Dashboard, Template,
  /// or Analysis.
  ///
  /// Either a <code>SourceEntity</code> or a <code>Definition</code> must be
  /// provided in order for the request to be valid.
  ///
  /// Parameter [folderArns] :
  /// When you create the dashboard, Amazon QuickSight adds the dashboard to
  /// these folders.
  ///
  /// Parameter [linkEntities] :
  /// A list of analysis Amazon Resource Names (ARNs) to be linked to the
  /// dashboard.
  ///
  /// Parameter [linkSharingConfiguration] :
  /// A structure that contains the permissions of a shareable link to the
  /// dashboard.
  ///
  /// Parameter [parameters] :
  /// The parameters for the creation of the dashboard, which you want to use to
  /// override the default settings. A dashboard can have any type of
  /// parameters, and some parameters might accept multiple values.
  ///
  /// Parameter [permissions] :
  /// A structure that contains the permissions of the dashboard. You can use
  /// this structure for granting permissions by providing a list of IAM action
  /// information for each principal ARN.
  ///
  /// To specify no permissions, omit the permissions list.
  ///
  /// Parameter [sourceEntity] :
  /// The entity that you are using as a source when you create the dashboard.
  /// In <code>SourceEntity</code>, you specify the type of object you're using
  /// as source. You can only create a dashboard from a template, so you use a
  /// <code>SourceTemplate</code> entity. If you need to create a dashboard from
  /// an analysis, first convert the analysis to a template by using the <code>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html">CreateTemplate</a>
  /// </code> API operation. For <code>SourceTemplate</code>, specify the Amazon
  /// Resource Name (ARN) of the source template. The
  /// <code>SourceTemplate</code>ARN can contain any Amazon Web Services account
  /// and any Amazon QuickSight-supported Amazon Web Services Region.
  ///
  /// Use the <code>DataSetReferences</code> entity within
  /// <code>SourceTemplate</code> to list the replacement datasets for the
  /// placeholders listed in the original. The schema in each dataset must match
  /// its placeholder.
  ///
  /// Either a <code>SourceEntity</code> or a <code>Definition</code> must be
  /// provided in order for the request to be valid.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags
  /// assigned to the dashboard.
  ///
  /// Parameter [themeArn] :
  /// The Amazon Resource Name (ARN) of the theme that is being used for this
  /// dashboard. If you add a value for this field, it overrides the value that
  /// is used in the source entity. The theme ARN must exist in the same Amazon
  /// Web Services account where you create the dashboard.
  ///
  /// Parameter [validationStrategy] :
  /// The option to relax the validation needed to create a dashboard with
  /// definition objects. This option skips the validation step for specific
  /// errors.
  ///
  /// Parameter [versionDescription] :
  /// A description for the first version of the dashboard being created.
  Future<CreateDashboardResponse> createDashboard({
    required String awsAccountId,
    required String dashboardId,
    required String name,
    DashboardPublishOptions? dashboardPublishOptions,
    DashboardVersionDefinition? definition,
    List<String>? folderArns,
    List<String>? linkEntities,
    LinkSharingConfiguration? linkSharingConfiguration,
    Parameters? parameters,
    List<ResourcePermission>? permissions,
    DashboardSourceEntity? sourceEntity,
    List<Tag>? tags,
    String? themeArn,
    ValidationStrategy? validationStrategy,
    String? versionDescription,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      if (dashboardPublishOptions != null)
        'DashboardPublishOptions': dashboardPublishOptions,
      if (definition != null) 'Definition': definition,
      if (folderArns != null) 'FolderArns': folderArns,
      if (linkEntities != null) 'LinkEntities': linkEntities,
      if (linkSharingConfiguration != null)
        'LinkSharingConfiguration': linkSharingConfiguration,
      if (parameters != null) 'Parameters': parameters,
      if (permissions != null) 'Permissions': permissions,
      if (sourceEntity != null) 'SourceEntity': sourceEntity,
      if (tags != null) 'Tags': tags,
      if (themeArn != null) 'ThemeArn': themeArn,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateDashboardResponse.fromJson(response);
  }

  /// Creates a dataset. This operation doesn't support datasets that include
  /// uploaded files as a source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// An ID for the dataset that you want to create. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  ///
  /// Parameter [importMode] :
  /// Indicates whether you want to import the data into SPICE.
  ///
  /// Parameter [name] :
  /// The display name for the dataset.
  ///
  /// Parameter [physicalTableMap] :
  /// Declares the physical tables that are available in the underlying data
  /// sources.
  ///
  /// Parameter [columnGroups] :
  /// Groupings of columns that work together in certain Amazon QuickSight
  /// features. Currently, only geospatial hierarchy is supported.
  ///
  /// Parameter [columnLevelPermissionRules] :
  /// A set of one or more definitions of a <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a>
  /// </code>.
  ///
  /// Parameter [datasetParameters] :
  /// The parameter declarations of the dataset.
  ///
  /// Parameter [fieldFolders] :
  /// The folder that contains fields and nested subfolders for your dataset.
  ///
  /// Parameter [folderArns] :
  /// When you create the dataset, Amazon QuickSight adds the dataset to these
  /// folders.
  ///
  /// Parameter [logicalTableMap] :
  /// Configures the combination and transformation of the data from the
  /// physical tables.
  ///
  /// Parameter [permissions] :
  /// A list of resource permissions on the dataset.
  ///
  /// Parameter [rowLevelPermissionDataSet] :
  /// The row-level security configuration for the data that you want to create.
  ///
  /// Parameter [rowLevelPermissionTagConfiguration] :
  /// The configuration of tags on a dataset to set row-level security.
  /// Row-level security tags are currently supported for anonymous embedding
  /// only.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags
  /// assigned to the dataset.
  Future<CreateDataSetResponse> createDataSet({
    required String awsAccountId,
    required String dataSetId,
    required DataSetImportMode importMode,
    required String name,
    required Map<String, PhysicalTable> physicalTableMap,
    List<ColumnGroup>? columnGroups,
    List<ColumnLevelPermissionRule>? columnLevelPermissionRules,
    DataSetUsageConfiguration? dataSetUsageConfiguration,
    List<DatasetParameter>? datasetParameters,
    Map<String, FieldFolder>? fieldFolders,
    List<String>? folderArns,
    Map<String, LogicalTable>? logicalTableMap,
    List<ResourcePermission>? permissions,
    RowLevelPermissionDataSet? rowLevelPermissionDataSet,
    RowLevelPermissionTagConfiguration? rowLevelPermissionTagConfiguration,
    List<Tag>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'DataSetId': dataSetId,
      'ImportMode': importMode.toValue(),
      'Name': name,
      'PhysicalTableMap': physicalTableMap,
      if (columnGroups != null) 'ColumnGroups': columnGroups,
      if (columnLevelPermissionRules != null)
        'ColumnLevelPermissionRules': columnLevelPermissionRules,
      if (dataSetUsageConfiguration != null)
        'DataSetUsageConfiguration': dataSetUsageConfiguration,
      if (datasetParameters != null) 'DatasetParameters': datasetParameters,
      if (fieldFolders != null) 'FieldFolders': fieldFolders,
      if (folderArns != null) 'FolderArns': folderArns,
      if (logicalTableMap != null) 'LogicalTableMap': logicalTableMap,
      if (permissions != null) 'Permissions': permissions,
      if (rowLevelPermissionDataSet != null)
        'RowLevelPermissionDataSet': rowLevelPermissionDataSet,
      if (rowLevelPermissionTagConfiguration != null)
        'RowLevelPermissionTagConfiguration':
            rowLevelPermissionTagConfiguration,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets',
      exceptionFnMap: _exceptionFns,
    );
    return CreateDataSetResponse.fromJson(response);
  }

  /// Creates a data source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSourceId] :
  /// An ID for the data source. This ID is unique per Amazon Web Services
  /// Region for each Amazon Web Services account.
  ///
  /// Parameter [name] :
  /// A display name for the data source.
  ///
  /// Parameter [type] :
  /// The type of the data source. To return a list of all data sources, use
  /// <code>ListDataSources</code>.
  ///
  /// Use <code>AMAZON_ELASTICSEARCH</code> for Amazon OpenSearch Service.
  ///
  /// Parameter [credentials] :
  /// The credentials Amazon QuickSight that uses to connect to your underlying
  /// source. Currently, only credentials based on user name and password are
  /// supported.
  ///
  /// Parameter [dataSourceParameters] :
  /// The parameters that Amazon QuickSight uses to connect to your underlying
  /// source.
  ///
  /// Parameter [folderArns] :
  /// When you create the data source, Amazon QuickSight adds the data source to
  /// these folders.
  ///
  /// Parameter [permissions] :
  /// A list of resource permissions on the data source.
  ///
  /// Parameter [sslProperties] :
  /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight
  /// connects to your underlying source.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags
  /// assigned to the data source.
  ///
  /// Parameter [vpcConnectionProperties] :
  /// Use this parameter only when you want Amazon QuickSight to use a VPC
  /// connection when connecting to your underlying source.
  Future<CreateDataSourceResponse> createDataSource({
    required String awsAccountId,
    required String dataSourceId,
    required String name,
    required DataSourceType type,
    DataSourceCredentials? credentials,
    DataSourceParameters? dataSourceParameters,
    List<String>? folderArns,
    List<ResourcePermission>? permissions,
    SslProperties? sslProperties,
    List<Tag>? tags,
    VpcConnectionProperties? vpcConnectionProperties,
  }) async {
    final $payload = <String, dynamic>{
      'DataSourceId': dataSourceId,
      'Name': name,
      'Type': type.toValue(),
      if (credentials != null) 'Credentials': credentials,
      if (dataSourceParameters != null)
        'DataSourceParameters': dataSourceParameters,
      if (folderArns != null) 'FolderArns': folderArns,
      if (permissions != null) 'Permissions': permissions,
      if (sslProperties != null) 'SslProperties': sslProperties,
      if (tags != null) 'Tags': tags,
      if (vpcConnectionProperties != null)
        'VpcConnectionProperties': vpcConnectionProperties,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources',
      exceptionFnMap: _exceptionFns,
    );
    return CreateDataSourceResponse.fromJson(response);
  }

  /// Creates an empty shared folder.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [AccessDeniedException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account where you want to create the
  /// folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [folderType] :
  /// The type of folder. By default, <code>folderType</code> is
  /// <code>SHARED</code>.
  ///
  /// Parameter [name] :
  /// The name of the folder.
  ///
  /// Parameter [parentFolderArn] :
  /// The Amazon Resource Name (ARN) for the parent folder.
  ///
  /// <code>ParentFolderArn</code> can be null. An empty
  /// <code>parentFolderArn</code> creates a root-level folder.
  ///
  /// Parameter [permissions] :
  /// A structure that describes the principals and the resource-level
  /// permissions of a folder.
  ///
  /// To specify no permissions, omit <code>Permissions</code>.
  ///
  /// Parameter [sharingModel] :
  /// An optional parameter that determines the sharing scope of the folder. The
  /// default value for this parameter is <code>ACCOUNT</code>.
  ///
  /// Parameter [tags] :
  /// Tags for the folder.
  Future<CreateFolderResponse> createFolder({
    required String awsAccountId,
    required String folderId,
    FolderType? folderType,
    String? name,
    String? parentFolderArn,
    List<ResourcePermission>? permissions,
    SharingModel? sharingModel,
    List<Tag>? tags,
  }) async {
    final $payload = <String, dynamic>{
      if (folderType != null) 'FolderType': folderType.toValue(),
      if (name != null) 'Name': name,
      if (parentFolderArn != null) 'ParentFolderArn': parentFolderArn,
      if (permissions != null) 'Permissions': permissions,
      if (sharingModel != null) 'SharingModel': sharingModel.toValue(),
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateFolderResponse.fromJson(response);
  }

  /// Adds an asset, such as a dashboard, analysis, or dataset into a folder.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [memberId] :
  /// The ID of the asset that you want to add to the folder.
  ///
  /// Parameter [memberType] :
  /// The member type of the asset that you want to add to a folder.
  Future<CreateFolderMembershipResponse> createFolderMembership({
    required String awsAccountId,
    required String folderId,
    required String memberId,
    required MemberType memberType,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}/members/${Uri.encodeComponent(memberType.toValue())}/${Uri.encodeComponent(memberId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateFolderMembershipResponse.fromJson(response);
  }

  /// Use the <code>CreateGroup</code> operation to create a group in Amazon
  /// QuickSight. You can create up to 10,000 groups in a namespace. If you want
  /// to create more than 10,000 groups in a namespace, contact Amazon Web
  /// Services Support.
  ///
  /// The permissions resource is
  /// <code>arn:aws:quicksight:&lt;your-region&gt;:<i>&lt;relevant-aws-account-id&gt;</i>:group/default/<i>&lt;group-name&gt;</i>
  /// </code>.
  ///
  /// The response is a group object.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// A name for the group that you want to create.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want the group to be a part of.
  ///
  /// Parameter [description] :
  /// A description for the group that you want to create.
  Future<CreateGroupResponse> createGroup({
    required String awsAccountId,
    required String groupName,
    required String namespace,
    String? description,
  }) async {
    final $payload = <String, dynamic>{
      'GroupName': groupName,
      if (description != null) 'Description': description,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups',
      exceptionFnMap: _exceptionFns,
    );
    return CreateGroupResponse.fromJson(response);
  }

  /// Adds an Amazon QuickSight user to an Amazon QuickSight group.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to add the user to.
  ///
  /// Parameter [memberName] :
  /// The name of the user that you want to add to the group membership.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want the user to be a part of.
  Future<CreateGroupMembershipResponse> createGroupMembership({
    required String awsAccountId,
    required String groupName,
    required String memberName,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}/members/${Uri.encodeComponent(memberName)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateGroupMembershipResponse.fromJson(response);
  }

  /// Creates an assignment with one specified IAM policy, identified by its
  /// Amazon Resource Name (ARN). This policy assignment is attached to the
  /// specified groups or users of Amazon QuickSight. Assignment names are
  /// unique per Amazon Web Services account. To avoid overwriting rules in
  /// other namespaces, use assignment names that are unique.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConcurrentUpdatingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [assignmentName] :
  /// The name of the assignment, also called a rule. The name must be unique
  /// within the Amazon Web Services account.
  ///
  /// Parameter [assignmentStatus] :
  /// The status of the assignment. Possible values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ENABLED</code> - Anything specified in this assignment is used when
  /// creating the data source.
  /// </li>
  /// <li>
  /// <code>DISABLED</code> - This assignment isn't used when creating the data
  /// source.
  /// </li>
  /// <li>
  /// <code>DRAFT</code> - This assignment is an unfinished draft and isn't used
  /// when creating the data source.
  /// </li>
  /// </ul>
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account where you want to assign an IAM
  /// policy to Amazon QuickSight users or groups.
  ///
  /// Parameter [namespace] :
  /// The namespace that contains the assignment.
  ///
  /// Parameter [identities] :
  /// The Amazon QuickSight users, groups, or both that you want to assign the
  /// policy to.
  ///
  /// Parameter [policyArn] :
  /// The ARN for the IAM policy to apply to the Amazon QuickSight users and
  /// groups specified in this assignment.
  Future<CreateIAMPolicyAssignmentResponse> createIAMPolicyAssignment({
    required String assignmentName,
    required AssignmentStatus assignmentStatus,
    required String awsAccountId,
    required String namespace,
    Map<String, List<String>>? identities,
    String? policyArn,
  }) async {
    final $payload = <String, dynamic>{
      'AssignmentName': assignmentName,
      'AssignmentStatus': assignmentStatus.toValue(),
      if (identities != null) 'Identities': identities,
      if (policyArn != null) 'PolicyArn': policyArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/iam-policy-assignments/',
      exceptionFnMap: _exceptionFns,
    );
    return CreateIAMPolicyAssignmentResponse.fromJson(response);
  }

  /// Creates and starts a new SPICE ingestion for a dataset. You can manually
  /// refresh datasets in an Enterprise edition account 32 times in a 24-hour
  /// period. You can manually refresh datasets in a Standard edition account 8
  /// times in a 24-hour period. Each 24-hour period is measured starting 24
  /// hours before the current date and time.
  ///
  /// Any ingestions operating on tagged datasets inherit the same tags
  /// automatically for use in access control. For an example, see <a
  /// href="http://aws.amazon.com/premiumsupport/knowledge-center/iam-ec2-resource-tags/">How
  /// do I create an IAM policy to control access to Amazon EC2 resources using
  /// tags?</a> in the Amazon Web Services Knowledge Center. Tags are visible on
  /// the tagged dataset, but not on the ingestion resource.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset used in the ingestion.
  ///
  /// Parameter [ingestionId] :
  /// An ID for the ingestion.
  ///
  /// Parameter [ingestionType] :
  /// The type of ingestion that you want to create.
  Future<CreateIngestionResponse> createIngestion({
    required String awsAccountId,
    required String dataSetId,
    required String ingestionId,
    IngestionType? ingestionType,
  }) async {
    final $payload = <String, dynamic>{
      if (ingestionType != null) 'IngestionType': ingestionType.toValue(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/ingestions/${Uri.encodeComponent(ingestionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateIngestionResponse.fromJson(response);
  }

  /// (Enterprise edition only) Creates a new namespace for you to use with
  /// Amazon QuickSight.
  ///
  /// A namespace allows you to isolate the Amazon QuickSight users and groups
  /// that are registered for that namespace. Users that access the namespace
  /// can share assets only with other users or groups in the same namespace.
  /// They can't see users and groups in other namespaces. You can create a
  /// namespace after your Amazon Web Services account is subscribed to Amazon
  /// QuickSight. The namespace must be unique within the Amazon Web Services
  /// account. By default, there is a limit of 100 namespaces per Amazon Web
  /// Services account. To increase your limit, create a ticket with Amazon Web
  /// Services Support.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [PreconditionNotMetException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to create the
  /// Amazon QuickSight namespace in.
  ///
  /// Parameter [identityStore] :
  /// Specifies the type of your user identity directory. Currently, this
  /// supports users with an identity type of <code>QUICKSIGHT</code>.
  ///
  /// Parameter [namespace] :
  /// The name that you want to use to describe the new namespace.
  ///
  /// Parameter [tags] :
  /// The tags that you want to associate with the namespace that you're
  /// creating.
  Future<CreateNamespaceResponse> createNamespace({
    required String awsAccountId,
    required IdentityStore identityStore,
    required String namespace,
    List<Tag>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'IdentityStore': identityStore.toValue(),
      'Namespace': namespace,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateNamespaceResponse.fromJson(response);
  }

  /// Creates a refresh schedule for a dataset. You can create up to 5 different
  /// schedules for a single dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [schedule] :
  /// The refresh schedule.
  Future<CreateRefreshScheduleResponse> createRefreshSchedule({
    required String awsAccountId,
    required String dataSetId,
    required RefreshSchedule schedule,
  }) async {
    final $payload = <String, dynamic>{
      'Schedule': schedule,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-schedules',
      exceptionFnMap: _exceptionFns,
    );
    return CreateRefreshScheduleResponse.fromJson(response);
  }

  /// Use <code>CreateRoleMembership</code> to add an existing Amazon QuickSight
  /// group to an existing role.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to create a group
  /// in. The Amazon Web Services account ID that you provide must be the same
  /// Amazon Web Services account that contains your Amazon QuickSight account.
  ///
  /// Parameter [memberName] :
  /// The name of the group that you want to add to the role.
  ///
  /// Parameter [namespace] :
  /// The namespace that the role belongs to.
  ///
  /// Parameter [role] :
  /// The role that you want to add a group to.
  Future<CreateRoleMembershipResponse> createRoleMembership({
    required String awsAccountId,
    required String memberName,
    required String namespace,
    required Role role,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/roles/${Uri.encodeComponent(role.toValue())}/members/${Uri.encodeComponent(memberName)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateRoleMembershipResponse.fromJson(response);
  }

  /// Creates a template either from a <code>TemplateDefinition</code> or from
  /// an existing Amazon QuickSight analysis or template. You can use the
  /// resulting template to create additional dashboards, templates, or
  /// analyses.
  ///
  /// A <i>template</i> is an entity in Amazon QuickSight that encapsulates the
  /// metadata required to create an analysis and that you can use to create s
  /// dashboard. A template adds a layer of abstraction by using placeholders to
  /// replace the dataset associated with the analysis. You can use templates to
  /// create dashboards by replacing dataset placeholders with datasets that
  /// follow the same schema that was used to create the source analysis and
  /// template.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in. You use
  /// the ID for the Amazon Web Services account that contains your Amazon
  /// QuickSight account.
  ///
  /// Parameter [templateId] :
  /// An ID for the template that you want to create. This template is unique
  /// per Amazon Web Services Region; in each Amazon Web Services account.
  ///
  /// Parameter [definition] :
  /// The definition of a template.
  ///
  /// A definition is the data model of all features in a Dashboard, Template,
  /// or Analysis.
  ///
  /// Either a <code>SourceEntity</code> or a <code>Definition</code> must be
  /// provided in order for the request to be valid.
  ///
  /// Parameter [name] :
  /// A display name for the template.
  ///
  /// Parameter [permissions] :
  /// A list of resource permissions to be set on the template.
  ///
  /// Parameter [sourceEntity] :
  /// The entity that you are using as a source when you create the template. In
  /// <code>SourceEntity</code>, you specify the type of object you're using as
  /// source: <code>SourceTemplate</code> for a template or
  /// <code>SourceAnalysis</code> for an analysis. Both of these require an
  /// Amazon Resource Name (ARN). For <code>SourceTemplate</code>, specify the
  /// ARN of the source template. For <code>SourceAnalysis</code>, specify the
  /// ARN of the source analysis. The <code>SourceTemplate</code> ARN can
  /// contain any Amazon Web Services account and any Amazon
  /// QuickSight-supported Amazon Web Services Region.
  ///
  /// Use the <code>DataSetReferences</code> entity within
  /// <code>SourceTemplate</code> or <code>SourceAnalysis</code> to list the
  /// replacement datasets for the placeholders listed in the original. The
  /// schema in each dataset must match its placeholder.
  ///
  /// Either a <code>SourceEntity</code> or a <code>Definition</code> must be
  /// provided in order for the request to be valid.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags
  /// assigned to the resource.
  ///
  /// Parameter [validationStrategy] :
  /// TThe option to relax the validation needed to create a template with
  /// definition objects. This skips the validation step for specific errors.
  ///
  /// Parameter [versionDescription] :
  /// A description of the current template version being created. This API
  /// operation creates the first version of the template. Every time
  /// <code>UpdateTemplate</code> is called, a new version is created. Each
  /// version of the template maintains a description of the version in the
  /// <code>VersionDescription</code> field.
  Future<CreateTemplateResponse> createTemplate({
    required String awsAccountId,
    required String templateId,
    TemplateVersionDefinition? definition,
    String? name,
    List<ResourcePermission>? permissions,
    TemplateSourceEntity? sourceEntity,
    List<Tag>? tags,
    ValidationStrategy? validationStrategy,
    String? versionDescription,
  }) async {
    final $payload = <String, dynamic>{
      if (definition != null) 'Definition': definition,
      if (name != null) 'Name': name,
      if (permissions != null) 'Permissions': permissions,
      if (sourceEntity != null) 'SourceEntity': sourceEntity,
      if (tags != null) 'Tags': tags,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTemplateResponse.fromJson(response);
  }

  /// Creates a template alias for a template.
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [ResourceExistsException].
  /// May throw [LimitExceededException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The name that you want to give to the template alias that you're creating.
  /// Don't start the alias name with the <code>$</code> character. Alias names
  /// that start with <code>$</code> are reserved by Amazon QuickSight.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template that
  /// you creating an alias for.
  ///
  /// Parameter [templateId] :
  /// An ID for the template.
  ///
  /// Parameter [templateVersionNumber] :
  /// The version number of the template.
  Future<CreateTemplateAliasResponse> createTemplateAlias({
    required String aliasName,
    required String awsAccountId,
    required String templateId,
    required int templateVersionNumber,
  }) async {
    _s.validateNumRange(
      'templateVersionNumber',
      templateVersionNumber,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'TemplateVersionNumber': templateVersionNumber,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTemplateAliasResponse.fromJson(response);
  }

  /// Creates a theme.
  ///
  /// A <i>theme</i> is set of configuration options for color and layout.
  /// Themes apply to analyses and dashboards. For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using
  /// Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User
  /// Guide</i>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account where you want to store the new
  /// theme.
  ///
  /// Parameter [baseThemeId] :
  /// The ID of the theme that a custom theme will inherit from. All themes
  /// inherit from one of the starting themes defined by Amazon QuickSight. For
  /// a list of the starting themes, use <code>ListThemes</code> or choose
  /// <b>Themes</b> from within an analysis.
  ///
  /// Parameter [configuration] :
  /// The theme configuration, which contains the theme display properties.
  ///
  /// Parameter [name] :
  /// A display name for the theme.
  ///
  /// Parameter [themeId] :
  /// An ID for the theme that you want to create. The theme ID is unique per
  /// Amazon Web Services Region in each Amazon Web Services account.
  ///
  /// Parameter [permissions] :
  /// A valid grouping of resource permissions to apply to the new theme.
  ///
  /// Parameter [tags] :
  /// A map of the key-value pairs for the resource tag or tags that you want to
  /// add to the resource.
  ///
  /// Parameter [versionDescription] :
  /// A description of the first version of the theme that you're creating.
  /// Every time <code>UpdateTheme</code> is called, a new version is created.
  /// Each version of the theme has a description of the version in the
  /// <code>VersionDescription</code> field.
  Future<CreateThemeResponse> createTheme({
    required String awsAccountId,
    required String baseThemeId,
    required ThemeConfiguration configuration,
    required String name,
    required String themeId,
    List<ResourcePermission>? permissions,
    List<Tag>? tags,
    String? versionDescription,
  }) async {
    final $payload = <String, dynamic>{
      'BaseThemeId': baseThemeId,
      'Configuration': configuration,
      'Name': name,
      if (permissions != null) 'Permissions': permissions,
      if (tags != null) 'Tags': tags,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateThemeResponse.fromJson(response);
  }

  /// Creates a theme alias for a theme.
  ///
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The name that you want to give to the theme alias that you are creating.
  /// The alias name can't begin with a <code>$</code>. Alias names that start
  /// with <code>$</code> are reserved by Amazon QuickSight.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme for the
  /// new theme alias.
  ///
  /// Parameter [themeId] :
  /// An ID for the theme alias.
  ///
  /// Parameter [themeVersionNumber] :
  /// The version number of the theme.
  Future<CreateThemeAliasResponse> createThemeAlias({
    required String aliasName,
    required String awsAccountId,
    required String themeId,
    required int themeVersionNumber,
  }) async {
    _s.validateNumRange(
      'themeVersionNumber',
      themeVersionNumber,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'ThemeVersionNumber': themeVersionNumber,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return CreateThemeAliasResponse.fromJson(response);
  }

  /// Creates a new Q topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that you want to create a topic
  /// in.
  ///
  /// Parameter [topic] :
  /// The definition of a topic to create.
  ///
  /// Parameter [topicId] :
  /// The ID for the topic that you want to create. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags that
  /// are assigned to the dataset.
  Future<CreateTopicResponse> createTopic({
    required String awsAccountId,
    required TopicDetails topic,
    required String topicId,
    List<Tag>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Topic': topic,
      'TopicId': topicId,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/topics',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTopicResponse.fromJson(response);
  }

  /// Creates a topic refresh schedule.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic you're
  /// creating a refresh schedule for.
  ///
  /// Parameter [datasetArn] :
  /// The Amazon Resource Name (ARN) of the dataset.
  ///
  /// Parameter [refreshSchedule] :
  /// The definition of a refresh schedule.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  ///
  /// Parameter [datasetName] :
  /// The name of the dataset.
  Future<CreateTopicRefreshScheduleResponse> createTopicRefreshSchedule({
    required String awsAccountId,
    required String datasetArn,
    required TopicRefreshSchedule refreshSchedule,
    required String topicId,
    String? datasetName,
  }) async {
    final $payload = <String, dynamic>{
      'DatasetArn': datasetArn,
      'RefreshSchedule': refreshSchedule,
      if (datasetName != null) 'DatasetName': datasetName,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/schedules',
      exceptionFnMap: _exceptionFns,
    );
    return CreateTopicRefreshScheduleResponse.fromJson(response);
  }

  /// Creates a new VPC connection.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account where you want to create
  /// a new VPC connection.
  ///
  /// Parameter [name] :
  /// The display name for the VPC connection.
  ///
  /// Parameter [roleArn] :
  /// The IAM role to associate with the VPC connection.
  ///
  /// Parameter [securityGroupIds] :
  /// A list of security group IDs for the VPC connection.
  ///
  /// Parameter [subnetIds] :
  /// A list of subnet IDs for the VPC connection.
  ///
  /// Parameter [vPCConnectionId] :
  /// The ID of the VPC connection that you're creating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  ///
  /// Parameter [dnsResolvers] :
  /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
  ///
  /// Parameter [tags] :
  /// A map of the key-value pairs for the resource tag or tags assigned to the
  /// VPC connection.
  Future<CreateVPCConnectionResponse> createVPCConnection({
    required String awsAccountId,
    required String name,
    required String roleArn,
    required List<String> securityGroupIds,
    required List<String> subnetIds,
    required String vPCConnectionId,
    List<String>? dnsResolvers,
    List<Tag>? tags,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      'RoleArn': roleArn,
      'SecurityGroupIds': securityGroupIds,
      'SubnetIds': subnetIds,
      'VPCConnectionId': vPCConnectionId,
      if (dnsResolvers != null) 'DnsResolvers': dnsResolvers,
      if (tags != null) 'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/vpc-connections',
      exceptionFnMap: _exceptionFns,
    );
    return CreateVPCConnectionResponse.fromJson(response);
  }

  /// Deletes all Amazon QuickSight customizations in this Amazon Web Services
  /// Region for the specified Amazon Web Services account and Amazon QuickSight
  /// namespace.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to delete Amazon
  /// QuickSight customizations from in this Amazon Web Services Region.
  ///
  /// Parameter [namespace] :
  /// The Amazon QuickSight namespace that you're deleting the customizations
  /// from.
  Future<DeleteAccountCustomizationResponse> deleteAccountCustomization({
    required String awsAccountId,
    String? namespace,
  }) async {
    final $query = <String, List<String>>{
      if (namespace != null) 'namespace': [namespace],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/customizations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DeleteAccountCustomizationResponse.fromJson(response);
  }

  /// Use the <code>DeleteAccountSubscription</code> operation to delete an
  /// Amazon QuickSight account. This operation will result in an error message
  /// if you have configured your account termination protection settings to
  /// <code>True</code>. To change this setting and delete your account, call
  /// the <code>UpdateAccountSettings</code> API and set the value of the
  /// <code>TerminationProtectionEnabled</code> parameter to <code>False</code>,
  /// then make another call to the <code>DeleteAccountSubscription</code> API.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account that you want to delete.
  Future<DeleteAccountSubscriptionResponse> deleteAccountSubscription({
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/account/${Uri.encodeComponent(awsAccountId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteAccountSubscriptionResponse.fromJson(response);
  }

  /// Deletes an analysis from Amazon QuickSight. You can optionally include a
  /// recovery window during which you can restore the analysis. If you don't
  /// specify a recovery window value, the operation defaults to 30 days. Amazon
  /// QuickSight attaches a <code>DeletionTime</code> stamp to the response that
  /// specifies the end of the recovery window. At the end of the recovery
  /// window, Amazon QuickSight deletes the analysis permanently.
  ///
  /// At any time before recovery window ends, you can use the
  /// <code>RestoreAnalysis</code> API operation to remove the
  /// <code>DeletionTime</code> stamp and cancel the deletion of the analysis.
  /// The analysis remains visible in the API until it's deleted, so you can
  /// describe it but you can't make a template from it.
  ///
  /// An analysis that's scheduled for deletion isn't accessible in the Amazon
  /// QuickSight console. To access it in the console, restore it. Deleting an
  /// analysis doesn't delete the dashboards that you publish from it.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID of the analysis that you're deleting.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account where you want to delete an
  /// analysis.
  ///
  /// Parameter [forceDeleteWithoutRecovery] :
  /// This option defaults to the value
  /// <code>NoForceDeleteWithoutRecovery</code>. To immediately delete the
  /// analysis, add the <code>ForceDeleteWithoutRecovery</code> option. You
  /// can't restore an analysis after it's deleted.
  ///
  /// Parameter [recoveryWindowInDays] :
  /// A value that specifies the number of days that Amazon QuickSight waits
  /// before it deletes the analysis. You can't use this parameter with the
  /// <code>ForceDeleteWithoutRecovery</code> option in the same API call. The
  /// default value is 30.
  Future<DeleteAnalysisResponse> deleteAnalysis({
    required String analysisId,
    required String awsAccountId,
    bool? forceDeleteWithoutRecovery,
    int? recoveryWindowInDays,
  }) async {
    _s.validateNumRange(
      'recoveryWindowInDays',
      recoveryWindowInDays,
      7,
      30,
    );
    final $query = <String, List<String>>{
      if (forceDeleteWithoutRecovery != null)
        'force-delete-without-recovery': [
          forceDeleteWithoutRecovery.toString()
        ],
      if (recoveryWindowInDays != null)
        'recovery-window-in-days': [recoveryWindowInDays.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DeleteAnalysisResponse.fromJson(response);
  }

  /// Deletes a dashboard.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're deleting.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [versionNumber] :
  /// The version number of the dashboard. If the version number property is
  /// provided, only the specified version of the dashboard is deleted.
  Future<DeleteDashboardResponse> deleteDashboard({
    required String awsAccountId,
    required String dashboardId,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DeleteDashboardResponse.fromJson(response);
  }

  /// Deletes a dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID for the dataset that you want to create. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<DeleteDataSetResponse> deleteDataSet({
    required String awsAccountId,
    required String dataSetId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteDataSetResponse.fromJson(response);
  }

  /// Deletes the dataset refresh properties of the dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  Future<DeleteDataSetRefreshPropertiesResponse>
      deleteDataSetRefreshProperties({
    required String awsAccountId,
    required String dataSetId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-properties',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteDataSetRefreshPropertiesResponse.fromJson(response);
  }

  /// Deletes the data source permanently. This operation breaks all the
  /// datasets that reference the deleted data source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSourceId] :
  /// The ID of the data source. This ID is unique per Amazon Web Services
  /// Region for each Amazon Web Services account.
  Future<DeleteDataSourceResponse> deleteDataSource({
    required String awsAccountId,
    required String dataSourceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources/${Uri.encodeComponent(dataSourceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteDataSourceResponse.fromJson(response);
  }

  /// Deletes an empty folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [PreconditionNotMetException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  Future<DeleteFolderResponse> deleteFolder({
    required String awsAccountId,
    required String folderId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteFolderResponse.fromJson(response);
  }

  /// Removes an asset, such as a dashboard, analysis, or dataset, from a
  /// folder.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The Folder ID.
  ///
  /// Parameter [memberId] :
  /// The ID of the asset that you want to delete.
  ///
  /// Parameter [memberType] :
  /// The member type of the asset that you want to delete from a folder.
  Future<DeleteFolderMembershipResponse> deleteFolderMembership({
    required String awsAccountId,
    required String folderId,
    required String memberId,
    required MemberType memberType,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}/members/${Uri.encodeComponent(memberType.toValue())}/${Uri.encodeComponent(memberId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteFolderMembershipResponse.fromJson(response);
  }

  /// Removes a user group from Amazon QuickSight.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to delete.
  ///
  /// Parameter [namespace] :
  /// The namespace of the group that you want to delete.
  Future<DeleteGroupResponse> deleteGroup({
    required String awsAccountId,
    required String groupName,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteGroupResponse.fromJson(response);
  }

  /// Removes a user from a group so that the user is no longer a member of the
  /// group.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to delete the user from.
  ///
  /// Parameter [memberName] :
  /// The name of the user that you want to delete from the group membership.
  ///
  /// Parameter [namespace] :
  /// The namespace of the group that you want to remove a user from.
  Future<DeleteGroupMembershipResponse> deleteGroupMembership({
    required String awsAccountId,
    required String groupName,
    required String memberName,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}/members/${Uri.encodeComponent(memberName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteGroupMembershipResponse.fromJson(response);
  }

  /// Deletes an existing IAM policy assignment.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConcurrentUpdatingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [assignmentName] :
  /// The name of the assignment.
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID where you want to delete the IAM policy
  /// assignment.
  ///
  /// Parameter [namespace] :
  /// The namespace that contains the assignment.
  Future<DeleteIAMPolicyAssignmentResponse> deleteIAMPolicyAssignment({
    required String assignmentName,
    required String awsAccountId,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespace/${Uri.encodeComponent(namespace)}/iam-policy-assignments/${Uri.encodeComponent(assignmentName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteIAMPolicyAssignmentResponse.fromJson(response);
  }

  /// Deletes all access scopes and authorized targets that are associated with
  /// a service from the Amazon QuickSight IAM Identity Center application.
  ///
  /// This operation is only supported for Amazon QuickSight accounts that use
  /// IAM Identity Center.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that you want to delete an
  /// identity propagation configuration from.
  ///
  /// Parameter [service] :
  /// The name of the Amazon Web Services service that you want to delete the
  /// associated access scopes and authorized targets from.
  Future<DeleteIdentityPropagationConfigResponse>
      deleteIdentityPropagationConfig({
    required String awsAccountId,
    required ServiceType service,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/identity-propagation-config/${Uri.encodeComponent(service.toValue())}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteIdentityPropagationConfigResponse.fromJson(response);
  }

  /// Deletes a namespace and the users and groups that are associated with the
  /// namespace. This is an asynchronous process. Assets including dashboards,
  /// analyses, datasets and data sources are not deleted. To delete these
  /// assets, you use the API operations for the relevant asset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to delete the
  /// Amazon QuickSight namespace from.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want to delete.
  Future<DeleteNamespaceResponse> deleteNamespace({
    required String awsAccountId,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteNamespaceResponse.fromJson(response);
  }

  /// Deletes a refresh schedule from a dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [scheduleId] :
  /// The ID of the refresh schedule.
  Future<DeleteRefreshScheduleResponse> deleteRefreshSchedule({
    required String awsAccountId,
    required String dataSetId,
    required String scheduleId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-schedules/${Uri.encodeComponent(scheduleId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteRefreshScheduleResponse.fromJson(response);
  }

  /// Removes custom permissions from the role.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace that includes the role.
  ///
  /// Parameter [role] :
  /// The role that you want to remove permissions from.
  Future<DeleteRoleCustomPermissionResponse> deleteRoleCustomPermission({
    required String awsAccountId,
    required String namespace,
    required Role role,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/roles/${Uri.encodeComponent(role.toValue())}/custom-permission',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteRoleCustomPermissionResponse.fromJson(response);
  }

  /// Removes a group from a role.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to create a group
  /// in. The Amazon Web Services account ID that you provide must be the same
  /// Amazon Web Services account that contains your Amazon QuickSight account.
  ///
  /// Parameter [memberName] :
  /// The name of the group.
  ///
  /// Parameter [namespace] :
  /// The namespace that contains the role.
  ///
  /// Parameter [role] :
  /// The role that you want to remove permissions from.
  Future<DeleteRoleMembershipResponse> deleteRoleMembership({
    required String awsAccountId,
    required String memberName,
    required String namespace,
    required Role role,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/roles/${Uri.encodeComponent(role.toValue())}/members/${Uri.encodeComponent(memberName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteRoleMembershipResponse.fromJson(response);
  }

  /// Deletes a template.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [LimitExceededException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template that
  /// you're deleting.
  ///
  /// Parameter [templateId] :
  /// An ID for the template you want to delete.
  ///
  /// Parameter [versionNumber] :
  /// Specifies the version of the template that you want to delete. If you
  /// don't provide a version number, <code>DeleteTemplate</code> deletes all
  /// versions of the template.
  Future<DeleteTemplateResponse> deleteTemplate({
    required String awsAccountId,
    required String templateId,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DeleteTemplateResponse.fromJson(response);
  }

  /// Deletes the item that the specified template alias points to. If you
  /// provide a specific alias, you delete the version of the template that the
  /// alias points to.
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The name for the template alias. To delete a specific alias, you delete
  /// the version that the alias points to. You can specify the alias name, or
  /// specify the latest version of the template by providing the keyword
  /// <code>$LATEST</code> in the <code>AliasName</code> parameter.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the item to
  /// delete.
  ///
  /// Parameter [templateId] :
  /// The ID for the template that the specified alias is for.
  Future<DeleteTemplateAliasResponse> deleteTemplateAlias({
    required String aliasName,
    required String awsAccountId,
    required String templateId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteTemplateAliasResponse.fromJson(response);
  }

  /// Deletes a theme.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme that
  /// you're deleting.
  ///
  /// Parameter [themeId] :
  /// An ID for the theme that you want to delete.
  ///
  /// Parameter [versionNumber] :
  /// The version of the theme that you want to delete.
  ///
  /// <b>Note:</b> If you don't provide a version number, you're using this call
  /// to <code>DeleteTheme</code> to delete all versions of the theme.
  Future<DeleteThemeResponse> deleteTheme({
    required String awsAccountId,
    required String themeId,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DeleteThemeResponse.fromJson(response);
  }

  /// Deletes the version of the theme that the specified theme alias points to.
  /// If you provide a specific alias, you delete the version of the theme that
  /// the alias points to.
  ///
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The unique name for the theme alias to delete.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme alias to
  /// delete.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme that the specified alias is for.
  Future<DeleteThemeAliasResponse> deleteThemeAlias({
    required String aliasName,
    required String awsAccountId,
    required String themeId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteThemeAliasResponse.fromJson(response);
  }

  /// Deletes a topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic that you
  /// want to delete.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to delete. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  Future<DeleteTopicResponse> deleteTopic({
    required String awsAccountId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteTopicResponse.fromJson(response);
  }

  /// Deletes a topic refresh schedule.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [datasetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  Future<DeleteTopicRefreshScheduleResponse> deleteTopicRefreshSchedule({
    required String awsAccountId,
    required String datasetId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/schedules/${Uri.encodeComponent(datasetId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteTopicRefreshScheduleResponse.fromJson(response);
  }

  /// Deletes the Amazon QuickSight user that is associated with the identity of
  /// the IAM user or role that's making the call. The IAM user isn't deleted as
  /// a result of this call.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the user is in. Currently,
  /// you use the ID for the Amazon Web Services account that contains your
  /// Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [userName] :
  /// The name of the user that you want to delete.
  Future<DeleteUserResponse> deleteUser({
    required String awsAccountId,
    required String namespace,
    required String userName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users/${Uri.encodeComponent(userName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteUserResponse.fromJson(response);
  }

  /// Deletes a user identified by its principal ID.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the user is in. Currently,
  /// you use the ID for the Amazon Web Services account that contains your
  /// Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [principalId] :
  /// The principal ID of the user.
  Future<DeleteUserByPrincipalIdResponse> deleteUserByPrincipalId({
    required String awsAccountId,
    required String namespace,
    required String principalId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/user-principals/${Uri.encodeComponent(principalId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteUserByPrincipalIdResponse.fromJson(response);
  }

  /// Deletes a VPC connection.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account where you want to delete
  /// a VPC connection.
  ///
  /// Parameter [vPCConnectionId] :
  /// The ID of the VPC connection that you're creating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  Future<DeleteVPCConnectionResponse> deleteVPCConnection({
    required String awsAccountId,
    required String vPCConnectionId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/vpc-connections/${Uri.encodeComponent(vPCConnectionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DeleteVPCConnectionResponse.fromJson(response);
  }

  /// Describes the customizations associated with the provided Amazon Web
  /// Services account and Amazon Amazon QuickSight namespace in an Amazon Web
  /// Services Region. The Amazon QuickSight console evaluates which
  /// customizations to apply by running this API operation with the
  /// <code>Resolved</code> flag included.
  ///
  /// To determine what customizations display when you run this command, it can
  /// help to visualize the relationship of the entities involved.
  ///
  /// <ul>
  /// <li>
  /// <code>Amazon Web Services account</code> - The Amazon Web Services account
  /// exists at the top of the hierarchy. It has the potential to use all of the
  /// Amazon Web Services Regions and Amazon Web Services Services. When you
  /// subscribe to Amazon QuickSight, you choose one Amazon Web Services Region
  /// to use as your home Region. That's where your free SPICE capacity is
  /// located. You can use Amazon QuickSight in any supported Amazon Web
  /// Services Region.
  /// </li>
  /// <li>
  /// <code>Amazon Web Services Region</code> - In each Amazon Web Services
  /// Region where you sign in to Amazon QuickSight at least once, Amazon
  /// QuickSight acts as a separate instance of the same service. If you have a
  /// user directory, it resides in us-east-1, which is the US East (N.
  /// Virginia). Generally speaking, these users have access to Amazon
  /// QuickSight in any Amazon Web Services Region, unless they are constrained
  /// to a namespace.
  ///
  /// To run the command in a different Amazon Web Services Region, you change
  /// your Region settings. If you're using the CLI, you can use one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// Use <a
  /// href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-options.html">command
  /// line options</a>.
  /// </li>
  /// <li>
  /// Use <a
  /// href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html">named
  /// profiles</a>.
  /// </li>
  /// <li>
  /// Run <code>aws configure</code> to change your default Amazon Web Services
  /// Region. Use Enter to key the same settings for your keys. For more
  /// information, see <a
  /// href="https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html">Configuring
  /// the CLI</a>.
  /// </li>
  /// </ul> </li>
  /// <li>
  /// <code>Namespace</code> - A QuickSight namespace is a partition that
  /// contains users and assets (data sources, datasets, dashboards, and so on).
  /// To access assets that are in a specific namespace, users and groups must
  /// also be part of the same namespace. People who share a namespace are
  /// completely isolated from users and assets in other namespaces, even if
  /// they are in the same Amazon Web Services account and Amazon Web Services
  /// Region.
  /// </li>
  /// <li>
  /// <code>Applied customizations</code> - Within an Amazon Web Services
  /// Region, a set of Amazon QuickSight customizations can apply to an Amazon
  /// Web Services account or to a namespace. Settings that you apply to a
  /// namespace override settings that you apply to an Amazon Web Services
  /// account. All settings are isolated to a single Amazon Web Services Region.
  /// To apply them in other Amazon Web Services Regions, run the
  /// <code>CreateAccountCustomization</code> command in each Amazon Web
  /// Services Region where you want to apply the same customizations.
  /// </li>
  /// </ul>
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to describe
  /// Amazon QuickSight customizations for.
  ///
  /// Parameter [namespace] :
  /// The Amazon QuickSight namespace that you want to describe Amazon
  /// QuickSight customizations for.
  ///
  /// Parameter [resolved] :
  /// The <code>Resolved</code> flag works with the other parameters to
  /// determine which view of Amazon QuickSight customizations is returned. You
  /// can add this flag to your command to use the same view that Amazon
  /// QuickSight uses to identify which customizations to apply to the console.
  /// Omit this flag, or set it to <code>no-resolved</code>, to reveal
  /// customizations that are configured at different levels.
  Future<DescribeAccountCustomizationResponse> describeAccountCustomization({
    required String awsAccountId,
    String? namespace,
    bool? resolved,
  }) async {
    final $query = <String, List<String>>{
      if (namespace != null) 'namespace': [namespace],
      if (resolved != null) 'resolved': [resolved.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/customizations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAccountCustomizationResponse.fromJson(response);
  }

  /// Describes the settings that were used when your Amazon QuickSight
  /// subscription was first created in this Amazon Web Services account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the settings that
  /// you want to list.
  Future<DescribeAccountSettingsResponse> describeAccountSettings({
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/settings',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAccountSettingsResponse.fromJson(response);
  }

  /// Use the DescribeAccountSubscription operation to receive a description of
  /// an Amazon QuickSight account's subscription. A successful API call returns
  /// an <code>AccountInfo</code> object that includes an account's name,
  /// subscription status, authentication type, edition, and notification email
  /// address.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID associated with your Amazon QuickSight
  /// account.
  Future<DescribeAccountSubscriptionResponse> describeAccountSubscription({
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/account/${Uri.encodeComponent(awsAccountId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAccountSubscriptionResponse.fromJson(response);
  }

  /// Provides a summary of the metadata for an analysis.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID of the analysis that you're describing. The ID is part of the URL
  /// of the analysis.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analysis. You
  /// must be using the Amazon Web Services account that the analysis is in.
  Future<DescribeAnalysisResponse> describeAnalysis({
    required String analysisId,
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAnalysisResponse.fromJson(response);
  }

  /// Provides a detailed description of the definition of an analysis.
  /// <note>
  /// If you do not need to know details about the content of an Analysis, for
  /// instance if you are trying to check the status of a recently created or
  /// updated Analysis, use the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeAnalysis.html">
  /// <code>DescribeAnalysis</code> </a> instead.
  /// </note>
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID of the analysis that you're describing. The ID is part of the URL
  /// of the analysis.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analysis. You
  /// must be using the Amazon Web Services account that the analysis is in.
  Future<DescribeAnalysisDefinitionResponse> describeAnalysisDefinition({
    required String analysisId,
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}/definition',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAnalysisDefinitionResponse.fromJson(response);
  }

  /// Provides the read and write permissions for an analysis.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID of the analysis whose permissions you're describing. The ID is part
  /// of the analysis URL.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analysis whose
  /// permissions you're describing. You must be using the Amazon Web Services
  /// account that the analysis is in.
  Future<DescribeAnalysisPermissionsResponse> describeAnalysisPermissions({
    required String analysisId,
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAnalysisPermissionsResponse.fromJson(response);
  }

  /// Describes an existing export job.
  ///
  /// Poll job descriptions after a job starts to know the status of the job.
  /// When a job succeeds, a URL is provided to download the exported assets'
  /// data from. Download URLs are valid for five minutes after they are
  /// generated. You can call the <code>DescribeAssetBundleExportJob</code> API
  /// for a new download URL as needed.
  ///
  /// Job descriptions are available for 14 days after the job starts.
  ///
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [assetBundleExportJobId] :
  /// The ID of the job that you want described. The job ID is set when you
  /// start a new job with a <code>StartAssetBundleExportJob</code> API call.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account the export job is executed in.
  Future<DescribeAssetBundleExportJobResponse> describeAssetBundleExportJob({
    required String assetBundleExportJobId,
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/asset-bundle-export-jobs/${Uri.encodeComponent(assetBundleExportJobId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAssetBundleExportJobResponse.fromJson(response);
  }

  /// Describes an existing import job.
  ///
  /// Poll job descriptions after starting a job to know when it has succeeded
  /// or failed. Job descriptions are available for 14 days after job starts.
  ///
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [assetBundleImportJobId] :
  /// The ID of the job. The job ID is set when you start a new job with a
  /// <code>StartAssetBundleImportJob</code> API call.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account the import job was executed in.
  Future<DescribeAssetBundleImportJobResponse> describeAssetBundleImportJob({
    required String assetBundleImportJobId,
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/asset-bundle-import-jobs/${Uri.encodeComponent(assetBundleImportJobId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeAssetBundleImportJobResponse.fromJson(response);
  }

  /// Provides a summary for a dashboard.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're describing.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [aliasName] :
  /// The alias name.
  ///
  /// Parameter [versionNumber] :
  /// The version number for the dashboard. If a version number isn't passed,
  /// the latest published dashboard version is described.
  Future<DescribeDashboardResponse> describeDashboard({
    required String awsAccountId,
    required String dashboardId,
    String? aliasName,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (aliasName != null) 'alias-name': [aliasName],
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDashboardResponse.fromJson(response);
  }

  /// Provides a detailed description of the definition of a dashboard.
  /// <note>
  /// If you do not need to know details about the content of a dashboard, for
  /// instance if you are trying to check the status of a recently created or
  /// updated dashboard, use the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeDashboard.html">
  /// <code>DescribeDashboard</code> </a> instead.
  /// </note>
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're describing.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [aliasName] :
  /// The alias name.
  ///
  /// Parameter [versionNumber] :
  /// The version number for the dashboard. If a version number isn't passed,
  /// the latest published dashboard version is described.
  Future<DescribeDashboardDefinitionResponse> describeDashboardDefinition({
    required String awsAccountId,
    required String dashboardId,
    String? aliasName,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (aliasName != null) 'alias-name': [aliasName],
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/definition',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDashboardDefinitionResponse.fromJson(response);
  }

  /// Describes read and write permissions for a dashboard.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're describing permissions for.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard, also added to the IAM policy.
  Future<DescribeDashboardPermissionsResponse> describeDashboardPermissions({
    required String awsAccountId,
    required String dashboardId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDashboardPermissionsResponse.fromJson(response);
  }

  /// Describes an existing snapshot job.
  ///
  /// Poll job descriptions after a job starts to know the status of the job.
  /// For information on available status codes, see <code>JobStatus</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that the dashboard snapshot job
  /// is executed in.
  ///
  /// Parameter [dashboardId] :
  /// The ID of the dashboard that you have started a snapshot job for.
  ///
  /// Parameter [snapshotJobId] :
  /// The ID of the job to be described. The job ID is set when you start a new
  /// job with a <code>StartDashboardSnapshotJob</code> API call.
  Future<DescribeDashboardSnapshotJobResponse> describeDashboardSnapshotJob({
    required String awsAccountId,
    required String dashboardId,
    required String snapshotJobId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/snapshot-jobs/${Uri.encodeComponent(snapshotJobId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDashboardSnapshotJobResponse.fromJson(response);
  }

  /// Describes the result of an existing snapshot job that has finished
  /// running.
  ///
  /// A finished snapshot job will return a <code>COMPLETED</code> or
  /// <code>FAILED</code> status when you poll the job with a
  /// <code>DescribeDashboardSnapshotJob</code> API call.
  ///
  /// If the job has not finished running, this operation returns a message that
  /// says <code>Dashboard Snapshot Job with id &lt;SnapshotjobId&gt; has not
  /// reached a terminal state.</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that the dashboard snapshot job
  /// is executed in.
  ///
  /// Parameter [dashboardId] :
  /// The ID of the dashboard that you have started a snapshot job for.
  ///
  /// Parameter [snapshotJobId] :
  /// The ID of the job to be described. The job ID is set when you start a new
  /// job with a <code>StartDashboardSnapshotJob</code> API call.
  Future<DescribeDashboardSnapshotJobResultResponse>
      describeDashboardSnapshotJobResult({
    required String awsAccountId,
    required String dashboardId,
    required String snapshotJobId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/snapshot-jobs/${Uri.encodeComponent(snapshotJobId)}/result',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDashboardSnapshotJobResultResponse.fromJson(response);
  }

  /// Describes a dataset. This operation doesn't support datasets that include
  /// uploaded files as a source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID for the dataset that you want to create. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<DescribeDataSetResponse> describeDataSet({
    required String awsAccountId,
    required String dataSetId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDataSetResponse.fromJson(response);
  }

  /// Describes the permissions on a dataset.
  ///
  /// The permissions resource is
  /// <code>arn:aws:quicksight:region:aws-account-id:dataset/data-set-id</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID for the dataset that you want to create. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<DescribeDataSetPermissionsResponse> describeDataSetPermissions({
    required String awsAccountId,
    required String dataSetId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDataSetPermissionsResponse.fromJson(response);
  }

  /// Describes the refresh properties of a dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  Future<DescribeDataSetRefreshPropertiesResponse>
      describeDataSetRefreshProperties({
    required String awsAccountId,
    required String dataSetId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-properties',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDataSetRefreshPropertiesResponse.fromJson(response);
  }

  /// Describes a data source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSourceId] :
  /// The ID of the data source. This ID is unique per Amazon Web Services
  /// Region for each Amazon Web Services account.
  Future<DescribeDataSourceResponse> describeDataSource({
    required String awsAccountId,
    required String dataSourceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources/${Uri.encodeComponent(dataSourceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDataSourceResponse.fromJson(response);
  }

  /// Describes the resource permissions for a data source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSourceId] :
  /// The ID of the data source. This ID is unique per Amazon Web Services
  /// Region for each Amazon Web Services account.
  Future<DescribeDataSourcePermissionsResponse> describeDataSourcePermissions({
    required String awsAccountId,
    required String dataSourceId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources/${Uri.encodeComponent(dataSourceId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeDataSourcePermissionsResponse.fromJson(response);
  }

  /// Describes a folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  Future<DescribeFolderResponse> describeFolder({
    required String awsAccountId,
    required String folderId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeFolderResponse.fromJson(response);
  }

  /// Describes permissions for a folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [namespace] :
  /// The namespace of the folder whose permissions you want described.
  ///
  /// Parameter [nextToken] :
  /// A pagination token for the next set of results.
  Future<DescribeFolderPermissionsResponse> describeFolderPermissions({
    required String awsAccountId,
    required String folderId,
    int? maxResults,
    String? namespace,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (namespace != null) 'namespace': [namespace],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}/permissions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeFolderPermissionsResponse.fromJson(response);
  }

  /// Describes the folder resolved permissions. Permissions consists of both
  /// folder direct permissions and the inherited permissions from the ancestor
  /// folders.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [namespace] :
  /// The namespace of the folder whose permissions you want described.
  ///
  /// Parameter [nextToken] :
  /// A pagination token for the next set of results.
  Future<DescribeFolderResolvedPermissionsResponse>
      describeFolderResolvedPermissions({
    required String awsAccountId,
    required String folderId,
    int? maxResults,
    String? namespace,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (namespace != null) 'namespace': [namespace],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}/resolved-permissions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeFolderResolvedPermissionsResponse.fromJson(response);
  }

  /// Returns an Amazon QuickSight group's description and Amazon Resource Name
  /// (ARN).
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to describe.
  ///
  /// Parameter [namespace] :
  /// The namespace of the group that you want described.
  Future<DescribeGroupResponse> describeGroup({
    required String awsAccountId,
    required String groupName,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeGroupResponse.fromJson(response);
  }

  /// Use the <code>DescribeGroupMembership</code> operation to determine if a
  /// user is a member of the specified group. If the user exists and is a
  /// member of the specified group, an associated <code>GroupMember</code>
  /// object is returned.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to search.
  ///
  /// Parameter [memberName] :
  /// The user name of the user that you want to search for.
  ///
  /// Parameter [namespace] :
  /// The namespace that includes the group you are searching within.
  Future<DescribeGroupMembershipResponse> describeGroupMembership({
    required String awsAccountId,
    required String groupName,
    required String memberName,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}/members/${Uri.encodeComponent(memberName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeGroupMembershipResponse.fromJson(response);
  }

  /// Describes an existing IAM policy assignment, as specified by the
  /// assignment name.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [assignmentName] :
  /// The name of the assignment, also called a rule.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the assignment
  /// that you want to describe.
  ///
  /// Parameter [namespace] :
  /// The namespace that contains the assignment.
  Future<DescribeIAMPolicyAssignmentResponse> describeIAMPolicyAssignment({
    required String assignmentName,
    required String awsAccountId,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/iam-policy-assignments/${Uri.encodeComponent(assignmentName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeIAMPolicyAssignmentResponse.fromJson(response);
  }

  /// Describes a SPICE ingestion.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset used in the ingestion.
  ///
  /// Parameter [ingestionId] :
  /// An ID for the ingestion.
  Future<DescribeIngestionResponse> describeIngestion({
    required String awsAccountId,
    required String dataSetId,
    required String ingestionId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/ingestions/${Uri.encodeComponent(ingestionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeIngestionResponse.fromJson(response);
  }

  /// Provides a summary and status of IP rules.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the IP rules.
  Future<DescribeIpRestrictionResponse> describeIpRestriction({
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/ip-restriction',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeIpRestrictionResponse.fromJson(response);
  }

  /// Describes all customer managed key registrations in a Amazon QuickSight
  /// account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the customer
  /// managed key registration that you want to describe.
  ///
  /// Parameter [defaultKeyOnly] :
  /// Determines whether the request returns the default key only.
  Future<DescribeKeyRegistrationResponse> describeKeyRegistration({
    required String awsAccountId,
    bool? defaultKeyOnly,
  }) async {
    final $query = <String, List<String>>{
      if (defaultKeyOnly != null)
        'default-key-only': [defaultKeyOnly.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/key-registration',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeKeyRegistrationResponse.fromJson(response);
  }

  /// Describes the current namespace.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the Amazon
  /// QuickSight namespace that you want to describe.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want to describe.
  Future<DescribeNamespaceResponse> describeNamespace({
    required String awsAccountId,
    required String namespace,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeNamespaceResponse.fromJson(response);
  }

  /// Provides a summary of a refresh schedule.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [scheduleId] :
  /// The ID of the refresh schedule.
  Future<DescribeRefreshScheduleResponse> describeRefreshSchedule({
    required String awsAccountId,
    required String dataSetId,
    required String scheduleId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-schedules/${Uri.encodeComponent(scheduleId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeRefreshScheduleResponse.fromJson(response);
  }

  /// Describes all custom permissions that are mapped to a role.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to create a group
  /// in. The Amazon Web Services account ID that you provide must be the same
  /// Amazon Web Services account that contains your Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace that contains the role.
  ///
  /// Parameter [role] :
  /// The name of the role whose permissions you want described.
  Future<DescribeRoleCustomPermissionResponse> describeRoleCustomPermission({
    required String awsAccountId,
    required String namespace,
    required Role role,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/roles/${Uri.encodeComponent(role.toValue())}/custom-permission',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeRoleCustomPermissionResponse.fromJson(response);
  }

  /// Describes a template's metadata.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template that
  /// you're describing.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  ///
  /// Parameter [aliasName] :
  /// The alias of the template that you want to describe. If you name a
  /// specific alias, you describe the version that the alias points to. You can
  /// specify the latest version of the template by providing the keyword
  /// <code>$LATEST</code> in the <code>AliasName</code> parameter. The keyword
  /// <code>$PUBLISHED</code> doesn't apply to templates.
  ///
  /// Parameter [versionNumber] :
  /// (Optional) The number for the version to describe. If a
  /// <code>VersionNumber</code> parameter value isn't provided, the latest
  /// version of the template is described.
  Future<DescribeTemplateResponse> describeTemplate({
    required String awsAccountId,
    required String templateId,
    String? aliasName,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (aliasName != null) 'alias-name': [aliasName],
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTemplateResponse.fromJson(response);
  }

  /// Describes the template alias for a template.
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The name of the template alias that you want to describe. If you name a
  /// specific alias, you describe the version that the alias points to. You can
  /// specify the latest version of the template by providing the keyword
  /// <code>$LATEST</code> in the <code>AliasName</code> parameter. The keyword
  /// <code>$PUBLISHED</code> doesn't apply to templates.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template alias
  /// that you're describing.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  Future<DescribeTemplateAliasResponse> describeTemplateAlias({
    required String aliasName,
    required String awsAccountId,
    required String templateId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTemplateAliasResponse.fromJson(response);
  }

  /// Provides a detailed description of the definition of a template.
  /// <note>
  /// If you do not need to know details about the content of a template, for
  /// instance if you are trying to check the status of a recently created or
  /// updated template, use the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeTemplate.html">
  /// <code>DescribeTemplate</code> </a> instead.
  /// </note>
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template. You
  /// must be using the Amazon Web Services account that the template is in.
  ///
  /// Parameter [templateId] :
  /// The ID of the template that you're describing.
  ///
  /// Parameter [aliasName] :
  /// The alias of the template that you want to describe. If you name a
  /// specific alias, you describe the version that the alias points to. You can
  /// specify the latest version of the template by providing the keyword
  /// <code>$LATEST</code> in the <code>AliasName</code> parameter. The keyword
  /// <code>$PUBLISHED</code> doesn't apply to templates.
  ///
  /// Parameter [versionNumber] :
  /// The version number of the template.
  Future<DescribeTemplateDefinitionResponse> describeTemplateDefinition({
    required String awsAccountId,
    required String templateId,
    String? aliasName,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (aliasName != null) 'alias-name': [aliasName],
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/definition',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTemplateDefinitionResponse.fromJson(response);
  }

  /// Describes read and write permissions on a template.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template that
  /// you're describing.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  Future<DescribeTemplatePermissionsResponse> describeTemplatePermissions({
    required String awsAccountId,
    required String templateId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTemplatePermissionsResponse.fromJson(response);
  }

  /// Describes a theme.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme that
  /// you're describing.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  ///
  /// Parameter [aliasName] :
  /// The alias of the theme that you want to describe. If you name a specific
  /// alias, you describe the version that the alias points to. You can specify
  /// the latest version of the theme by providing the keyword
  /// <code>$LATEST</code> in the <code>AliasName</code> parameter. The keyword
  /// <code>$PUBLISHED</code> doesn't apply to themes.
  ///
  /// Parameter [versionNumber] :
  /// The version number for the version to describe. If a
  /// <code>VersionNumber</code> parameter value isn't provided, the latest
  /// version of the theme is described.
  Future<DescribeThemeResponse> describeTheme({
    required String awsAccountId,
    required String themeId,
    String? aliasName,
    int? versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
    );
    final $query = <String, List<String>>{
      if (aliasName != null) 'alias-name': [aliasName],
      if (versionNumber != null) 'version-number': [versionNumber.toString()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return DescribeThemeResponse.fromJson(response);
  }

  /// Describes the alias for a theme.
  ///
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The name of the theme alias that you want to describe.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme alias
  /// that you're describing.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  Future<DescribeThemeAliasResponse> describeThemeAlias({
    required String aliasName,
    required String awsAccountId,
    required String themeId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeThemeAliasResponse.fromJson(response);
  }

  /// Describes the read and write permissions for a theme.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme that
  /// you're describing.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme that you want to describe permissions for.
  Future<DescribeThemePermissionsResponse> describeThemePermissions({
    required String awsAccountId,
    required String themeId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeThemePermissionsResponse.fromJson(response);
  }

  /// Describes a topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to describe. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<DescribeTopicResponse> describeTopic({
    required String awsAccountId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTopicResponse.fromJson(response);
  }

  /// Describes the permissions of a topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic that you
  /// want described.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to describe. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<DescribeTopicPermissionsResponse> describeTopicPermissions({
    required String awsAccountId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTopicPermissionsResponse.fromJson(response);
  }

  /// Describes the status of a topic refresh.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic whose
  /// refresh you want to describe.
  ///
  /// Parameter [refreshId] :
  /// The ID of the refresh, which is performed when the topic is created or
  /// updated.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to describe. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<DescribeTopicRefreshResponse> describeTopicRefresh({
    required String awsAccountId,
    required String refreshId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/refresh/${Uri.encodeComponent(refreshId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTopicRefreshResponse.fromJson(response);
  }

  /// Deletes a topic refresh schedule.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [datasetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that contains the refresh schedule that you want to
  /// describe. This ID is unique per Amazon Web Services Region for each Amazon
  /// Web Services account.
  Future<DescribeTopicRefreshScheduleResponse> describeTopicRefreshSchedule({
    required String awsAccountId,
    required String datasetId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/schedules/${Uri.encodeComponent(datasetId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeTopicRefreshScheduleResponse.fromJson(response);
  }

  /// Returns information about a user, given the user name.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the user is in. Currently,
  /// you use the ID for the Amazon Web Services account that contains your
  /// Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [userName] :
  /// The name of the user that you want to describe.
  Future<DescribeUserResponse> describeUser({
    required String awsAccountId,
    required String namespace,
    required String userName,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users/${Uri.encodeComponent(userName)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeUserResponse.fromJson(response);
  }

  /// Describes a VPC connection.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account that contains the VPC
  /// connection that you want described.
  ///
  /// Parameter [vPCConnectionId] :
  /// The ID of the VPC connection that you're creating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  Future<DescribeVPCConnectionResponse> describeVPCConnection({
    required String awsAccountId,
    required String vPCConnectionId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/vpc-connections/${Uri.encodeComponent(vPCConnectionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return DescribeVPCConnectionResponse.fromJson(response);
  }

  /// Generates an embed URL that you can use to embed an Amazon QuickSight
  /// dashboard or visual in your website, without having to register any reader
  /// users. Before you use this action, make sure that you have configured the
  /// dashboards and permissions.
  ///
  /// The following rules apply to the generated URL:
  ///
  /// <ul>
  /// <li>
  /// It contains a temporary bearer token. It is valid for 5 minutes after it
  /// is generated. Once redeemed within this period, it cannot be re-used
  /// again.
  /// </li>
  /// <li>
  /// The URL validity period should not be confused with the actual session
  /// lifetime that can be customized using the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForAnonymousUser.html#QS-GenerateEmbedUrlForAnonymousUser-request-SessionLifetimeInMinutes">SessionLifetimeInMinutes</a>
  /// </code> parameter. The resulting user session is valid for 15 minutes
  /// (minimum) to 10 hours (maximum). The default session duration is 10 hours.
  /// </li>
  /// <li>
  /// You are charged only when the URL is used or there is interaction with
  /// Amazon QuickSight.
  /// </li>
  /// </ul>
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics.html">Embedded
  /// Analytics</a> in the <i>Amazon QuickSight User Guide</i>.
  ///
  /// For more information about the high-level steps for embedding and for an
  /// interactive demo of the ways you can customize embedding, visit the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon
  /// QuickSight Developer Portal</a>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [SessionLifetimeInMinutesInvalidException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [UnsupportedPricingPlanException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [authorizedResourceArns] :
  /// The Amazon Resource Names (ARNs) for the Amazon QuickSight resources that
  /// the user is authorized to access during the lifetime of the session.
  ///
  /// If you choose <code>Dashboard</code> embedding experience, pass the list
  /// of dashboard ARNs in the account that you want the user to be able to
  /// view.
  ///
  /// If you want to make changes to the theme of your embedded content, pass a
  /// list of theme ARNs that the anonymous users need access to.
  ///
  /// Currently, you can pass up to 25 theme ARNs in each API call.
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the dashboard
  /// that you're embedding.
  ///
  /// Parameter [experienceConfiguration] :
  /// The configuration of the experience that you are embedding.
  ///
  /// Parameter [namespace] :
  /// The Amazon QuickSight namespace that the anonymous user virtually belongs
  /// to. If you are not using an Amazon QuickSight custom namespace, set this
  /// to <code>default</code>.
  ///
  /// Parameter [allowedDomains] :
  /// The domains that you want to add to the allow list for access to the
  /// generated URL that is then embedded. This optional parameter overrides the
  /// static domains that are configured in the Manage QuickSight menu in the
  /// Amazon QuickSight console. Instead, it allows only the domains that you
  /// include in this parameter. You can list up to three domains or subdomains
  /// in each API call.
  ///
  /// To include all subdomains under a specific domain to the allow list, use
  /// <code>*</code>. For example, <code>https://*.sapp.amazon.com</code>
  /// includes all subdomains under <code>https://sapp.amazon.com</code>.
  ///
  /// Parameter [sessionLifetimeInMinutes] :
  /// How many minutes the session is valid. The session lifetime must be in
  /// [15-600] minutes range.
  ///
  /// Parameter [sessionTags] :
  /// The session tags used for row-level security. Before you use this
  /// parameter, make sure that you have configured the relevant datasets using
  /// the <code>DataSet$RowLevelPermissionTagConfiguration</code> parameter so
  /// that session tags can be used to provide row-level security.
  ///
  /// These are not the tags used for the Amazon Web Services resource tagging
  /// feature. For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-rls-tags.html">Using
  /// Row-Level Security (RLS) with Tags</a>in the <i>Amazon QuickSight User
  /// Guide</i>.
  Future<GenerateEmbedUrlForAnonymousUserResponse>
      generateEmbedUrlForAnonymousUser({
    required List<String> authorizedResourceArns,
    required String awsAccountId,
    required AnonymousUserEmbeddingExperienceConfiguration
        experienceConfiguration,
    required String namespace,
    List<String>? allowedDomains,
    int? sessionLifetimeInMinutes,
    List<SessionTag>? sessionTags,
  }) async {
    _s.validateNumRange(
      'sessionLifetimeInMinutes',
      sessionLifetimeInMinutes,
      15,
      600,
    );
    final $payload = <String, dynamic>{
      'AuthorizedResourceArns': authorizedResourceArns,
      'ExperienceConfiguration': experienceConfiguration,
      'Namespace': namespace,
      if (allowedDomains != null) 'AllowedDomains': allowedDomains,
      if (sessionLifetimeInMinutes != null)
        'SessionLifetimeInMinutes': sessionLifetimeInMinutes,
      if (sessionTags != null) 'SessionTags': sessionTags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/embed-url/anonymous-user',
      exceptionFnMap: _exceptionFns,
    );
    return GenerateEmbedUrlForAnonymousUserResponse.fromJson(response);
  }

  /// Generates an embed URL that you can use to embed an Amazon QuickSight
  /// experience in your website. This action can be used for any type of user
  /// registered in an Amazon QuickSight account. Before you use this action,
  /// make sure that you have configured the relevant Amazon QuickSight resource
  /// and permissions.
  ///
  /// The following rules apply to the generated URL:
  ///
  /// <ul>
  /// <li>
  /// It contains a temporary bearer token. It is valid for 5 minutes after it
  /// is generated. Once redeemed within this period, it cannot be re-used
  /// again.
  /// </li>
  /// <li>
  /// The URL validity period should not be confused with the actual session
  /// lifetime that can be customized using the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html#QS-GenerateEmbedUrlForRegisteredUser-request-SessionLifetimeInMinutes">SessionLifetimeInMinutes</a>
  /// </code> parameter.
  ///
  /// The resulting user session is valid for 15 minutes (minimum) to 10 hours
  /// (maximum). The default session duration is 10 hours.
  /// </li>
  /// <li>
  /// You are charged only when the URL is used or there is interaction with
  /// Amazon QuickSight.
  /// </li>
  /// </ul>
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics.html">Embedded
  /// Analytics</a> in the <i>Amazon QuickSight User Guide</i>.
  ///
  /// For more information about the high-level steps for embedding and for an
  /// interactive demo of the ways you can customize embedding, visit the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon
  /// QuickSight Developer Portal</a>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [QuickSightUserNotFoundException].
  /// May throw [ResourceNotFoundException].
  /// May throw [SessionLifetimeInMinutesInvalidException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [UnsupportedPricingPlanException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the dashboard
  /// that you're embedding.
  ///
  /// Parameter [experienceConfiguration] :
  /// The experience that you want to embed. For registered users, you can embed
  /// Amazon QuickSight dashboards, Amazon QuickSight visuals, the Amazon
  /// QuickSight Q search bar, the Amazon QuickSight Generative Q&amp;A
  /// experience, or the entire Amazon QuickSight console.
  ///
  /// Parameter [userArn] :
  /// The Amazon Resource Name for the registered user.
  ///
  /// Parameter [allowedDomains] :
  /// The domains that you want to add to the allow list for access to the
  /// generated URL that is then embedded. This optional parameter overrides the
  /// static domains that are configured in the Manage QuickSight menu in the
  /// Amazon QuickSight console. Instead, it allows only the domains that you
  /// include in this parameter. You can list up to three domains or subdomains
  /// in each API call.
  ///
  /// To include all subdomains under a specific domain to the allow list, use
  /// <code>*</code>. For example, <code>https://*.sapp.amazon.com</code>
  /// includes all subdomains under <code>https://sapp.amazon.com</code>.
  ///
  /// Parameter [sessionLifetimeInMinutes] :
  /// How many minutes the session is valid. The session lifetime must be in
  /// [15-600] minutes range.
  Future<GenerateEmbedUrlForRegisteredUserResponse>
      generateEmbedUrlForRegisteredUser({
    required String awsAccountId,
    required RegisteredUserEmbeddingExperienceConfiguration
        experienceConfiguration,
    required String userArn,
    List<String>? allowedDomains,
    int? sessionLifetimeInMinutes,
  }) async {
    _s.validateNumRange(
      'sessionLifetimeInMinutes',
      sessionLifetimeInMinutes,
      15,
      600,
    );
    final $payload = <String, dynamic>{
      'ExperienceConfiguration': experienceConfiguration,
      'UserArn': userArn,
      if (allowedDomains != null) 'AllowedDomains': allowedDomains,
      if (sessionLifetimeInMinutes != null)
        'SessionLifetimeInMinutes': sessionLifetimeInMinutes,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/embed-url/registered-user',
      exceptionFnMap: _exceptionFns,
    );
    return GenerateEmbedUrlForRegisteredUserResponse.fromJson(response);
  }

  /// Generates a temporary session URL and authorization code(bearer token)
  /// that you can use to embed an Amazon QuickSight read-only dashboard in your
  /// website or application. Before you use this command, make sure that you
  /// have configured the dashboards and permissions.
  ///
  /// Currently, you can use <code>GetDashboardEmbedURL</code> only from the
  /// server, not from the user's browser. The following rules apply to the
  /// generated URL:
  ///
  /// <ul>
  /// <li>
  /// They must be used together.
  /// </li>
  /// <li>
  /// They can be used one time only.
  /// </li>
  /// <li>
  /// They are valid for 5 minutes after you run this command.
  /// </li>
  /// <li>
  /// You are charged only when the URL is used or there is interaction with
  /// Amazon QuickSight.
  /// </li>
  /// <li>
  /// The resulting user session is valid for 15 minutes (default) up to 10
  /// hours (maximum). You can use the optional
  /// <code>SessionLifetimeInMinutes</code> parameter to customize session
  /// duration.
  /// </li>
  /// </ul>
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-deprecated.html">Embedding
  /// Analytics Using GetDashboardEmbedUrl</a> in the <i>Amazon QuickSight User
  /// Guide</i>.
  ///
  /// For more information about the high-level steps for embedding and for an
  /// interactive demo of the ways you can customize embedding, visit the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon
  /// QuickSight Developer Portal</a>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [DomainNotWhitelistedException].
  /// May throw [QuickSightUserNotFoundException].
  /// May throw [IdentityTypeNotSupportedException].
  /// May throw [SessionLifetimeInMinutesInvalidException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [UnsupportedPricingPlanException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the dashboard
  /// that you're embedding.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard, also added to the Identity and Access Management
  /// (IAM) policy.
  ///
  /// Parameter [identityType] :
  /// The authentication method that the user uses to sign in.
  ///
  /// Parameter [additionalDashboardIds] :
  /// A list of one or more dashboard IDs that you want anonymous users to have
  /// tempporary access to. Currently, the <code>IdentityType</code> parameter
  /// must be set to <code>ANONYMOUS</code> because other identity types
  /// authenticate as Amazon QuickSight or IAM users. For example, if you set
  /// "<code>--dashboard-id dash_id1 --dashboard-id dash_id2 dash_id3
  /// identity-type ANONYMOUS</code>", the session can access all three
  /// dashboards.
  ///
  /// Parameter [namespace] :
  /// The Amazon QuickSight namespace that contains the dashboard IDs in this
  /// request. If you're not using a custom namespace, set <code>Namespace =
  /// default</code>.
  ///
  /// Parameter [resetDisabled] :
  /// Remove the reset button on the embedded dashboard. The default is FALSE,
  /// which enables the reset button.
  ///
  /// Parameter [sessionLifetimeInMinutes] :
  /// How many minutes the session is valid. The session lifetime must be 15-600
  /// minutes.
  ///
  /// Parameter [statePersistenceEnabled] :
  /// Adds persistence of state for the user session in an embedded dashboard.
  /// Persistence applies to the sheet and the parameter settings. These are
  /// control settings that the dashboard subscriber (Amazon QuickSight reader)
  /// chooses while viewing the dashboard. If this is set to <code>TRUE</code>,
  /// the settings are the same when the subscriber reopens the same dashboard
  /// URL. The state is stored in Amazon QuickSight, not in a browser cookie. If
  /// this is set to FALSE, the state of the user session is not persisted. The
  /// default is <code>FALSE</code>.
  ///
  /// Parameter [undoRedoDisabled] :
  /// Remove the undo/redo button on the embedded dashboard. The default is
  /// FALSE, which enables the undo/redo button.
  ///
  /// Parameter [userArn] :
  /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with
  /// <code>QUICKSIGHT</code> identity type. You can use this for any Amazon
  /// QuickSight users in your account (readers, authors, or admins)
  /// authenticated as one of the following:
  ///
  /// <ul>
  /// <li>
  /// Active Directory (AD) users or group members
  /// </li>
  /// <li>
  /// Invited nonfederated users
  /// </li>
  /// <li>
  /// IAM users and IAM role-based sessions authenticated through Federated
  /// Single Sign-On using SAML, OpenID Connect, or IAM federation.
  /// </li>
  /// </ul>
  /// Omit this parameter for users in the third group  IAM users and IAM
  /// role-based sessions.
  Future<GetDashboardEmbedUrlResponse> getDashboardEmbedUrl({
    required String awsAccountId,
    required String dashboardId,
    required EmbeddingIdentityType identityType,
    List<String>? additionalDashboardIds,
    String? namespace,
    bool? resetDisabled,
    int? sessionLifetimeInMinutes,
    bool? statePersistenceEnabled,
    bool? undoRedoDisabled,
    String? userArn,
  }) async {
    _s.validateNumRange(
      'sessionLifetimeInMinutes',
      sessionLifetimeInMinutes,
      15,
      600,
    );
    final $query = <String, List<String>>{
      'creds-type': [identityType.toValue()],
      if (additionalDashboardIds != null)
        'additional-dashboard-ids': additionalDashboardIds,
      if (namespace != null) 'namespace': [namespace],
      if (resetDisabled != null) 'reset-disabled': [resetDisabled.toString()],
      if (sessionLifetimeInMinutes != null)
        'session-lifetime': [sessionLifetimeInMinutes.toString()],
      if (statePersistenceEnabled != null)
        'state-persistence-enabled': [statePersistenceEnabled.toString()],
      if (undoRedoDisabled != null)
        'undo-redo-disabled': [undoRedoDisabled.toString()],
      if (userArn != null) 'user-arn': [userArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/embed-url',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetDashboardEmbedUrlResponse.fromJson(response);
  }

  /// Generates a session URL and authorization code that you can use to embed
  /// the Amazon Amazon QuickSight console in your web server code. Use
  /// <code>GetSessionEmbedUrl</code> where you want to provide an authoring
  /// portal that allows users to create data sources, datasets, analyses, and
  /// dashboards. The users who access an embedded Amazon QuickSight console
  /// need belong to the author or admin security cohort. If you want to
  /// restrict permissions to some of these features, add a custom permissions
  /// profile to the user with the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a>
  /// </code> API operation. Use <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html">RegisterUser</a>
  /// </code> API operation to add a new user with a custom permission profile
  /// attached. For more information, see the following sections in the
  /// <i>Amazon QuickSight User Guide</i>:
  ///
  /// <ul>
  /// <li>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics.html">Embedding
  /// Analytics</a>
  /// </li>
  /// <li>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing
  /// Access to the Amazon QuickSight Console</a>
  /// </li>
  /// </ul>
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [QuickSightUserNotFoundException].
  /// May throw [SessionLifetimeInMinutesInvalidException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account associated with your Amazon
  /// QuickSight subscription.
  ///
  /// Parameter [entryPoint] :
  /// The URL you use to access the embedded session. The entry point URL is
  /// constrained to the following paths:
  ///
  /// <ul>
  /// <li>
  /// <code>/start</code>
  /// </li>
  /// <li>
  /// <code>/start/analyses</code>
  /// </li>
  /// <li>
  /// <code>/start/dashboards</code>
  /// </li>
  /// <li>
  /// <code>/start/favorites</code>
  /// </li>
  /// <li>
  /// <code>/dashboards/<i>DashboardId</i> </code> - where
  /// <code>DashboardId</code> is the actual ID key from the Amazon QuickSight
  /// console URL of the dashboard
  /// </li>
  /// <li>
  /// <code>/analyses/<i>AnalysisId</i> </code> - where <code>AnalysisId</code>
  /// is the actual ID key from the Amazon QuickSight console URL of the
  /// analysis
  /// </li>
  /// </ul>
  ///
  /// Parameter [sessionLifetimeInMinutes] :
  /// How many minutes the session is valid. The session lifetime must be 15-600
  /// minutes.
  ///
  /// Parameter [userArn] :
  /// The Amazon QuickSight user's Amazon Resource Name (ARN), for use with
  /// <code>QUICKSIGHT</code> identity type. You can use this for any type of
  /// Amazon QuickSight users in your account (readers, authors, or admins).
  /// They need to be authenticated as one of the following:
  /// <ol>
  /// <li>
  /// Active Directory (AD) users or group members
  /// </li>
  /// <li>
  /// Invited nonfederated users
  /// </li>
  /// <li>
  /// IAM users and IAM role-based sessions authenticated through Federated
  /// Single Sign-On using SAML, OpenID Connect, or IAM federation
  /// </li> </ol>
  /// Omit this parameter for users in the third group, IAM users and IAM
  /// role-based sessions.
  Future<GetSessionEmbedUrlResponse> getSessionEmbedUrl({
    required String awsAccountId,
    String? entryPoint,
    int? sessionLifetimeInMinutes,
    String? userArn,
  }) async {
    _s.validateNumRange(
      'sessionLifetimeInMinutes',
      sessionLifetimeInMinutes,
      15,
      600,
    );
    final $query = <String, List<String>>{
      if (entryPoint != null) 'entry-point': [entryPoint],
      if (sessionLifetimeInMinutes != null)
        'session-lifetime': [sessionLifetimeInMinutes.toString()],
      if (userArn != null) 'user-arn': [userArn],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/session-embed-url',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return GetSessionEmbedUrlResponse.fromJson(response);
  }

  /// Lists Amazon QuickSight analyses that exist in the specified Amazon Web
  /// Services account.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analyses.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<ListAnalysesResponse> listAnalyses({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListAnalysesResponse.fromJson(response);
  }

  /// Lists all asset bundle export jobs that have been taken place in the last
  /// 14 days. Jobs created more than 14 days ago are deleted forever and are
  /// not returned. If you are using the same job ID for multiple jobs,
  /// <code>ListAssetBundleExportJobs</code> only returns the most recent job
  /// that uses the repeated job ID.
  ///
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidNextTokenException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that the export jobs were
  /// executed in.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListAssetBundleExportJobsResponse> listAssetBundleExportJobs({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/asset-bundle-export-jobs',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListAssetBundleExportJobsResponse.fromJson(response);
  }

  /// Lists all asset bundle import jobs that have taken place in the last 14
  /// days. Jobs created more than 14 days ago are deleted forever and are not
  /// returned. If you are using the same job ID for multiple jobs,
  /// <code>ListAssetBundleImportJobs</code> only returns the most recent job
  /// that uses the repeated job ID.
  ///
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ThrottlingException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidNextTokenException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that the import jobs were
  /// executed in.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListAssetBundleImportJobsResponse> listAssetBundleImportJobs({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/asset-bundle-import-jobs',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListAssetBundleImportJobsResponse.fromJson(response);
  }

  /// Lists all the versions of the dashboards in the Amazon QuickSight
  /// subscription.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're listing versions for.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListDashboardVersionsResponse> listDashboardVersions({
    required String awsAccountId,
    required String dashboardId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/versions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListDashboardVersionsResponse.fromJson(response);
  }

  /// Lists dashboards in an Amazon Web Services account.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboards
  /// that you're listing.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListDashboardsResponse> listDashboards({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListDashboardsResponse.fromJson(response);
  }

  /// Lists all of the datasets belonging to the current Amazon Web Services
  /// account in an Amazon Web Services Region.
  ///
  /// The permissions resource is
  /// <code>arn:aws:quicksight:region:aws-account-id:dataset/*</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListDataSetsResponse> listDataSets({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListDataSetsResponse.fromJson(response);
  }

  /// Lists data sources in current Amazon Web Services Region that belong to
  /// this Amazon Web Services account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListDataSourcesResponse> listDataSources({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListDataSourcesResponse.fromJson(response);
  }

  /// List all assets (<code>DASHBOARD</code>, <code>ANALYSIS</code>, and
  /// <code>DATASET</code>) in a folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListFolderMembersResponse> listFolderMembers({
    required String awsAccountId,
    required String folderId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}/members',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListFolderMembersResponse.fromJson(response);
  }

  /// Lists all folders in an account.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListFoldersResponse> listFolders({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/folders',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListFoldersResponse.fromJson(response);
  }

  /// Lists member users in a group.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to see a membership list of.
  ///
  /// Parameter [namespace] :
  /// The namespace of the group that you want a list of users from.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return from this request.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<ListGroupMembershipsResponse> listGroupMemberships({
    required String awsAccountId,
    required String groupName,
    required String namespace,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}/members',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListGroupMembershipsResponse.fromJson(response);
  }

  /// Lists all user groups in Amazon QuickSight.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want a list of groups from.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<ListGroupsResponse> listGroups({
    required String awsAccountId,
    required String namespace,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListGroupsResponse.fromJson(response);
  }

  /// Lists the IAM policy assignments in the current Amazon QuickSight account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains these IAM policy
  /// assignments.
  ///
  /// Parameter [namespace] :
  /// The namespace for the assignments.
  ///
  /// Parameter [assignmentStatus] :
  /// The status of the assignments.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListIAMPolicyAssignmentsResponse> listIAMPolicyAssignments({
    required String awsAccountId,
    required String namespace,
    AssignmentStatus? assignmentStatus,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (assignmentStatus != null)
        'assignment-status': [assignmentStatus.toValue()],
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/v2/iam-policy-assignments',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListIAMPolicyAssignmentsResponse.fromJson(response);
  }

  /// Lists all of the IAM policy assignments, including the Amazon Resource
  /// Names (ARNs), for the IAM policies assigned to the specified user and
  /// group, or groups that the user belongs to.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConcurrentUpdatingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the assignments.
  ///
  /// Parameter [namespace] :
  /// The namespace of the assignment.
  ///
  /// Parameter [userName] :
  /// The name of the user.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListIAMPolicyAssignmentsForUserResponse>
      listIAMPolicyAssignmentsForUser({
    required String awsAccountId,
    required String namespace,
    required String userName,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users/${Uri.encodeComponent(userName)}/iam-policy-assignments',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListIAMPolicyAssignmentsForUserResponse.fromJson(response);
  }

  /// Lists all services and authorized targets that the Amazon QuickSight IAM
  /// Identity Center application can access.
  ///
  /// This operation is only supported for Amazon QuickSight accounts that use
  /// IAM Identity Center.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contain the identity
  /// propagation configurations of.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListIdentityPropagationConfigsResponse>
      listIdentityPropagationConfigs({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      10,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/identity-propagation-config',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListIdentityPropagationConfigsResponse.fromJson(response);
  }

  /// Lists the history of SPICE ingestions for a dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset used in the ingestion.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListIngestionsResponse> listIngestions({
    required String awsAccountId,
    required String dataSetId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/ingestions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListIngestionsResponse.fromJson(response);
  }

  /// Lists the namespaces for the specified Amazon Web Services account. This
  /// operation doesn't list deleted namespaces.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the Amazon
  /// QuickSight namespaces that you want to list.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// A unique pagination token that can be used in a subsequent request. You
  /// will receive a pagination token in the response body of a previous
  /// <code>ListNameSpaces</code> API call if there is more data that can be
  /// returned. To receive the data, make another <code>ListNamespaces</code>
  /// API call with the returned token to retrieve the next page of data. Each
  /// token is valid for 24 hours. If you try to make a
  /// <code>ListNamespaces</code> API call with an expired token, you will
  /// receive a <code>HTTP 400 InvalidNextTokenException</code> error.
  Future<ListNamespacesResponse> listNamespaces({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListNamespacesResponse.fromJson(response);
  }

  /// Lists the refresh schedules of a dataset. Each dataset can have up to 5
  /// schedules.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  Future<ListRefreshSchedulesResponse> listRefreshSchedules({
    required String awsAccountId,
    required String dataSetId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-schedules',
      exceptionFnMap: _exceptionFns,
    );
    return ListRefreshSchedulesResponse.fromJson(response);
  }

  /// Lists all groups that are associated with a role.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [PreconditionNotMetException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to create a group
  /// in. The Amazon Web Services account ID that you provide must be the same
  /// Amazon Web Services account that contains your Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace that includes the role.
  ///
  /// Parameter [role] :
  /// The name of the role.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<ListRoleMembershipsResponse> listRoleMemberships({
    required String awsAccountId,
    required String namespace,
    required Role role,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/roles/${Uri.encodeComponent(role.toValue())}/members',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListRoleMembershipsResponse.fromJson(response);
  }

  /// Lists the tags assigned to a resource.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource that you want a list of
  /// tags for.
  Future<ListTagsForResourceResponse> listTagsForResource({
    required String resourceArn,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/resources/${Uri.encodeComponent(resourceArn)}/tags',
      exceptionFnMap: _exceptionFns,
    );
    return ListTagsForResourceResponse.fromJson(response);
  }

  /// Lists all the aliases of a template.
  ///
  /// May throw [InvalidNextTokenException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template
  /// aliases that you're listing.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListTemplateAliasesResponse> listTemplateAliases({
    required String awsAccountId,
    required String templateId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-result': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/aliases',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTemplateAliasesResponse.fromJson(response);
  }

  /// Lists all the versions of the templates in the current Amazon QuickSight
  /// account.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the templates that
  /// you're listing.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListTemplateVersionsResponse> listTemplateVersions({
    required String awsAccountId,
    required String templateId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/versions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTemplateVersionsResponse.fromJson(response);
  }

  /// Lists all the templates in the current Amazon QuickSight account.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the templates that
  /// you're listing.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListTemplatesResponse> listTemplates({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-result': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/templates',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTemplatesResponse.fromJson(response);
  }

  /// Lists all the aliases of a theme.
  ///
  /// May throw [ConflictException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme aliases
  /// that you're listing.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListThemeAliasesResponse> listThemeAliases({
    required String awsAccountId,
    required String themeId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-result': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/aliases',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListThemeAliasesResponse.fromJson(response);
  }

  /// Lists all the versions of the themes in the current Amazon Web Services
  /// account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the themes that
  /// you're listing.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListThemeVersionsResponse> listThemeVersions({
    required String awsAccountId,
    required String themeId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/versions',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListThemeVersionsResponse.fromJson(response);
  }

  /// Lists all the themes in the current Amazon Web Services account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [InvalidNextTokenException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the themes that
  /// you're listing.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  ///
  /// Parameter [type] :
  /// The type of themes that you want to list. Valid options include the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL (default)</code>- Display all existing themes.
  /// </li>
  /// <li>
  /// <code>CUSTOM</code> - Display only the themes created by people using
  /// Amazon QuickSight.
  /// </li>
  /// <li>
  /// <code>QUICKSIGHT</code> - Display only the starting themes defined by
  /// Amazon QuickSight.
  /// </li>
  /// </ul>
  Future<ListThemesResponse> listThemes({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
    ThemeType? type,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
      if (type != null) 'type': [type.toValue()],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/themes',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListThemesResponse.fromJson(response);
  }

  /// Lists all of the refresh schedules for a topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic whose
  /// refresh schedule you want described.
  ///
  /// Parameter [topicId] :
  /// The ID for the topic that you want to describe. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  Future<ListTopicRefreshSchedulesResponse> listTopicRefreshSchedules({
    required String awsAccountId,
    required String topicId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/schedules',
      exceptionFnMap: _exceptionFns,
    );
    return ListTopicRefreshSchedulesResponse.fromJson(response);
  }

  /// Lists all of the topics within an account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topics that
  /// you want to list.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListTopicsResponse> listTopics({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/topics',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListTopicsResponse.fromJson(response);
  }

  /// Lists the Amazon QuickSight groups that an Amazon QuickSight user is a
  /// member of.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID that the user is in. Currently, you use
  /// the ID for the Amazon Web Services account that contains your Amazon
  /// QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [userName] :
  /// The Amazon QuickSight user name that you want to list group memberships
  /// for.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return from this request.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<ListUserGroupsResponse> listUserGroups({
    required String awsAccountId,
    required String namespace,
    required String userName,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users/${Uri.encodeComponent(userName)}/groups',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListUserGroupsResponse.fromJson(response);
  }

  /// Returns a list of all of the Amazon QuickSight users belonging to this
  /// account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the user is in. Currently,
  /// you use the ID for the Amazon Web Services account that contains your
  /// Amazon QuickSight account.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return from this request.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<ListUsersResponse> listUsers({
    required String awsAccountId,
    required String namespace,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListUsersResponse.fromJson(response);
  }

  /// Lists all of the VPC connections in the current set Amazon Web Services
  /// Region of an Amazon Web Services account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account that contains the VPC
  /// connections that you want to list.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<ListVPCConnectionsResponse> listVPCConnections({
    required String awsAccountId,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final response = await _protocol.send(
      payload: null,
      method: 'GET',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/vpc-connections',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return ListVPCConnectionsResponse.fromJson(response);
  }

  /// Creates or updates the dataset refresh properties for the dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [PreconditionNotMetException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [dataSetRefreshProperties] :
  /// The dataset refresh properties.
  Future<PutDataSetRefreshPropertiesResponse> putDataSetRefreshProperties({
    required String awsAccountId,
    required String dataSetId,
    required DataSetRefreshProperties dataSetRefreshProperties,
  }) async {
    final $payload = <String, dynamic>{
      'DataSetRefreshProperties': dataSetRefreshProperties,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-properties',
      exceptionFnMap: _exceptionFns,
    );
    return PutDataSetRefreshPropertiesResponse.fromJson(response);
  }

  /// Creates an Amazon QuickSight user whose identity is associated with the
  /// Identity and Access Management (IAM) identity or role specified in the
  /// request. When you register a new user from the Amazon QuickSight API,
  /// Amazon QuickSight generates a registration URL. The user accesses this
  /// registration URL to create their account. Amazon QuickSight doesn't send a
  /// registration email to users who are registered from the Amazon QuickSight
  /// API. If you want new users to receive a registration email, then add those
  /// users in the Amazon QuickSight console. For more information on
  /// registering a new user in the Amazon QuickSight console, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/managing-users.html#inviting-users">
  /// Inviting users to access Amazon QuickSight</a>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the user is in. Currently,
  /// you use the ID for the Amazon Web Services account that contains your
  /// Amazon QuickSight account.
  ///
  /// Parameter [email] :
  /// The email address of the user that you want to register.
  ///
  /// Parameter [identityType] :
  /// The identity type that your Amazon QuickSight account uses to manage the
  /// identity of users.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [userRole] :
  /// The Amazon QuickSight role for the user. The user role can be one of the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>READER</code>: A user who has read-only access to dashboards.
  /// </li>
  /// <li>
  /// <code>AUTHOR</code>: A user who can create data sources, datasets,
  /// analyses, and dashboards.
  /// </li>
  /// <li>
  /// <code>ADMIN</code>: A user who is an author, who can also manage Amazon
  /// QuickSight settings.
  /// </li>
  /// <li>
  /// <code>READER_PRO</code>: Reader Pro adds Generative BI capabilities to the
  /// Reader role. Reader Pros have access to Amazon Q in Amazon QuickSight, can
  /// build stories with Amazon Q, and can generate executive summaries from
  /// dashboards.
  /// </li>
  /// <li>
  /// <code>AUTHOR_PRO</code>: Author Pro adds Generative BI capabilities to the
  /// Author role. Author Pros can author dashboards with natural language with
  /// Amazon Q, build stories with Amazon Q, create Topics for Q&amp;A, and
  /// generate executive summaries from dashboards.
  /// </li>
  /// <li>
  /// <code>ADMIN_PRO</code>: Admin Pros are Author Pros who can also manage
  /// Amazon QuickSight administrative settings. Admin Pro users are billed at
  /// Author Pro pricing.
  /// </li>
  /// <li>
  /// <code>RESTRICTED_READER</code>: This role isn't currently available for
  /// use.
  /// </li>
  /// <li>
  /// <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for
  /// use.
  /// </li>
  /// </ul>
  ///
  /// Parameter [customFederationProviderUrl] :
  /// The URL of the custom OpenID Connect (OIDC) provider that provides
  /// identity to let a user federate into Amazon QuickSight with an associated
  /// Identity and Access Management(IAM) role. This parameter should only be
  /// used when <code>ExternalLoginFederationProviderType</code> parameter is
  /// set to <code>CUSTOM_OIDC</code>.
  ///
  /// Parameter [customPermissionsName] :
  /// (Enterprise edition only) The name of the custom permissions profile that
  /// you want to assign to this user. Customized permissions allows you to
  /// control a user's access by restricting access the following operations:
  ///
  /// <ul>
  /// <li>
  /// Create and update data sources
  /// </li>
  /// <li>
  /// Create and update datasets
  /// </li>
  /// <li>
  /// Create and update email reports
  /// </li>
  /// <li>
  /// Subscribe to email reports
  /// </li>
  /// </ul>
  /// To add custom permissions to an existing user, use <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a>
  /// </code> instead.
  ///
  /// A set of custom permissions includes any combination of these
  /// restrictions. Currently, you need to create the profile names for custom
  /// permission sets by using the Amazon QuickSight console. Then, you use the
  /// <code>RegisterUser</code> API operation to assign the named set of
  /// permissions to a Amazon QuickSight user.
  ///
  /// Amazon QuickSight custom permissions are applied through IAM policies.
  /// Therefore, they override the permissions typically granted by assigning
  /// Amazon QuickSight users to one of the default security cohorts in Amazon
  /// QuickSight (admin, author, reader, admin pro, author pro, reader pro).
  ///
  /// This feature is available only to Amazon QuickSight Enterprise edition
  /// subscriptions.
  ///
  /// Parameter [externalLoginFederationProviderType] :
  /// The type of supported external login provider that provides identity to
  /// let a user federate into Amazon QuickSight with an associated Identity and
  /// Access Management(IAM) role. The type of supported external login provider
  /// can be one of the following.
  ///
  /// <ul>
  /// <li>
  /// <code>COGNITO</code>: Amazon Cognito. The provider URL is
  /// cognito-identity.amazonaws.com. When choosing the <code>COGNITO</code>
  /// provider type, dont use the "CustomFederationProviderUrl" parameter which
  /// is only needed when the external provider is custom.
  /// </li>
  /// <li>
  /// <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider. When
  /// choosing <code>CUSTOM_OIDC</code> type, use the
  /// <code>CustomFederationProviderUrl</code> parameter to provide the custom
  /// OIDC provider URL.
  /// </li>
  /// </ul>
  ///
  /// Parameter [externalLoginId] :
  /// The identity ID for a user in the external login provider.
  ///
  /// Parameter [iamArn] :
  /// The ARN of the IAM user or role that you are registering with Amazon
  /// QuickSight.
  ///
  /// Parameter [sessionName] :
  /// You need to use this parameter only when you register one or more users
  /// using an assumed IAM role. You don't need to provide the session name for
  /// other scenarios, for example when you are registering an IAM user or an
  /// Amazon QuickSight user. You can register multiple users using the same IAM
  /// role if each user has a different session name. For more information on
  /// assuming IAM roles, see <a
  /// href="https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role.html">
  /// <code>assume-role</code> </a> in the <i>CLI Reference.</i>
  ///
  /// Parameter [tags] :
  /// The tags to associate with the user.
  ///
  /// Parameter [userName] :
  /// The Amazon QuickSight user name that you want to create for the user you
  /// are registering.
  Future<RegisterUserResponse> registerUser({
    required String awsAccountId,
    required String email,
    required IdentityType identityType,
    required String namespace,
    required UserRole userRole,
    String? customFederationProviderUrl,
    String? customPermissionsName,
    String? externalLoginFederationProviderType,
    String? externalLoginId,
    String? iamArn,
    String? sessionName,
    List<Tag>? tags,
    String? userName,
  }) async {
    final $payload = <String, dynamic>{
      'Email': email,
      'IdentityType': identityType.toValue(),
      'UserRole': userRole.toValue(),
      if (customFederationProviderUrl != null)
        'CustomFederationProviderUrl': customFederationProviderUrl,
      if (customPermissionsName != null)
        'CustomPermissionsName': customPermissionsName,
      if (externalLoginFederationProviderType != null)
        'ExternalLoginFederationProviderType':
            externalLoginFederationProviderType,
      if (externalLoginId != null) 'ExternalLoginId': externalLoginId,
      if (iamArn != null) 'IamArn': iamArn,
      if (sessionName != null) 'SessionName': sessionName,
      if (tags != null) 'Tags': tags,
      if (userName != null) 'UserName': userName,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users',
      exceptionFnMap: _exceptionFns,
    );
    return RegisterUserResponse.fromJson(response);
  }

  /// Restores an analysis.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID of the analysis that you're restoring.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analysis.
  Future<RestoreAnalysisResponse> restoreAnalysis({
    required String analysisId,
    required String awsAccountId,
  }) async {
    final response = await _protocol.send(
      payload: null,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/restore/analyses/${Uri.encodeComponent(analysisId)}',
      exceptionFnMap: _exceptionFns,
    );
    return RestoreAnalysisResponse.fromJson(response);
  }

  /// Searches for analyses that belong to the user specified in the filter.
  /// <note>
  /// This operation is eventually consistent. The results are best effort and
  /// may not reflect very recent updates and changes.
  /// </note>
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analyses that
  /// you're searching for.
  ///
  /// Parameter [filters] :
  /// The structure for the search filters that you want to apply to your
  /// search.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<SearchAnalysesResponse> searchAnalyses({
    required String awsAccountId,
    required List<AnalysisSearchFilter> filters,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/search/analyses',
      exceptionFnMap: _exceptionFns,
    );
    return SearchAnalysesResponse.fromJson(response);
  }

  /// Searches for dashboards that belong to a user.
  /// <note>
  /// This operation is eventually consistent. The results are best effort and
  /// may not reflect very recent updates and changes.
  /// </note>
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the user whose
  /// dashboards you're searching for.
  ///
  /// Parameter [filters] :
  /// The filters to apply to the search. Currently, you can search only by user
  /// name, for example, <code>"Filters": [ { "Name": "QUICKSIGHT_USER",
  /// "Operator": "StringEquals", "Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1" } ]</code>
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<SearchDashboardsResponse> searchDashboards({
    required String awsAccountId,
    required List<DashboardSearchFilter> filters,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/search/dashboards',
      exceptionFnMap: _exceptionFns,
    );
    return SearchDashboardsResponse.fromJson(response);
  }

  /// Use the <code>SearchDataSets</code> operation to search for datasets that
  /// belong to an account.
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [filters] :
  /// The filters to apply to the search.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<SearchDataSetsResponse> searchDataSets({
    required String awsAccountId,
    required List<DataSetSearchFilter> filters,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/search/data-sets',
      exceptionFnMap: _exceptionFns,
    );
    return SearchDataSetsResponse.fromJson(response);
  }

  /// Use the <code>SearchDataSources</code> operation to search for data
  /// sources that belong to an account.
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidNextTokenException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [filters] :
  /// The filters to apply to the search.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<SearchDataSourcesResponse> searchDataSources({
    required String awsAccountId,
    required List<DataSourceSearchFilter> filters,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/search/data-sources',
      exceptionFnMap: _exceptionFns,
    );
    return SearchDataSourcesResponse.fromJson(response);
  }

  /// Searches the subfolders in a folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InvalidRequestException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder.
  ///
  /// Parameter [filters] :
  /// The filters to apply to the search. Currently, you can search only by the
  /// parent folder ARN. For example, <code>"Filters": [ { "Name":
  /// "PARENT_FOLDER_ARN", "Operator": "StringEquals", "Value":
  /// "arn:aws:quicksight:us-east-1:1:folder/folderId" } ]</code>.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to be returned per request.
  ///
  /// Parameter [nextToken] :
  /// The token for the next set of results, or null if there are no more
  /// results.
  Future<SearchFoldersResponse> searchFolders({
    required String awsAccountId,
    required List<FolderSearchFilter> filters,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $payload = <String, dynamic>{
      'Filters': filters,
      if (maxResults != null) 'MaxResults': maxResults,
      if (nextToken != null) 'NextToken': nextToken,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/search/folders',
      exceptionFnMap: _exceptionFns,
    );
    return SearchFoldersResponse.fromJson(response);
  }

  /// Use the <code>SearchGroups</code> operation to search groups in a
  /// specified Amazon QuickSight namespace using the supplied filters.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidNextTokenException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [filters] :
  /// The structure for the search filters that you want to apply to your
  /// search.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want to search.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of results to return from this request.
  ///
  /// Parameter [nextToken] :
  /// A pagination token that can be used in a subsequent request.
  Future<SearchGroupsResponse> searchGroups({
    required String awsAccountId,
    required List<GroupSearchFilter> filters,
    required String namespace,
    int? maxResults,
    String? nextToken,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      1,
      100,
    );
    final $query = <String, List<String>>{
      if (maxResults != null) 'max-results': [maxResults.toString()],
      if (nextToken != null) 'next-token': [nextToken],
    };
    final $payload = <String, dynamic>{
      'Filters': filters,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups-search',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return SearchGroupsResponse.fromJson(response);
  }

  /// Starts an Asset Bundle export job.
  ///
  /// An Asset Bundle export job exports specified Amazon QuickSight assets. You
  /// can also choose to export any asset dependencies in the same job. Export
  /// jobs run asynchronously and can be polled with a
  /// <code>DescribeAssetBundleExportJob</code> API call. When a job is
  /// successfully completed, a download URL that contains the exported assets
  /// is returned. The URL is valid for 5 minutes and can be refreshed with a
  /// <code>DescribeAssetBundleExportJob</code> API call. Each Amazon QuickSight
  /// account can run up to 5 export jobs concurrently.
  ///
  /// The API caller must have the necessary permissions in their IAM role to
  /// access each resource before the resources can be exported.
  ///
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [LimitExceededException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [assetBundleExportJobId] :
  /// The ID of the job. This ID is unique while the job is running. After the
  /// job is completed, you can reuse this ID for another job.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account to export assets from.
  ///
  /// Parameter [exportFormat] :
  /// The export data format.
  ///
  /// Parameter [resourceArns] :
  /// An array of resource ARNs to export. The following resources are
  /// supported.
  ///
  /// <ul>
  /// <li>
  /// <code>Analysis</code>
  /// </li>
  /// <li>
  /// <code>Dashboard</code>
  /// </li>
  /// <li>
  /// <code>DataSet</code>
  /// </li>
  /// <li>
  /// <code>DataSource</code>
  /// </li>
  /// <li>
  /// <code>RefreshSchedule</code>
  /// </li>
  /// <li>
  /// <code>Theme</code>
  /// </li>
  /// <li>
  /// <code>VPCConnection</code>
  /// </li>
  /// </ul>
  /// The API caller must have the necessary permissions in their IAM role to
  /// access each resource before the resources can be exported.
  ///
  /// Parameter [cloudFormationOverridePropertyConfiguration] :
  /// An optional collection of structures that generate CloudFormation
  /// parameters to override the existing resource property values when the
  /// resource is exported to a new CloudFormation template.
  ///
  /// Use this field if the <code>ExportFormat</code> field of a
  /// <code>StartAssetBundleExportJobRequest</code> API call is set to
  /// <code>CLOUDFORMATION_JSON</code>.
  ///
  /// Parameter [includeAllDependencies] :
  /// A Boolean that determines whether all dependencies of each resource ARN
  /// are recursively exported with the job. For example, say you provided a
  /// Dashboard ARN to the <code>ResourceArns</code> parameter. If you set
  /// <code>IncludeAllDependencies</code> to <code>TRUE</code>, any theme,
  /// dataset, and data source resource that is a dependency of the dashboard is
  /// also exported.
  ///
  /// Parameter [includePermissions] :
  /// A Boolean that determines whether all permissions for each resource ARN
  /// are exported with the job. If you set <code>IncludePermissions</code> to
  /// <code>TRUE</code>, any permissions associated with each resource are
  /// exported.
  ///
  /// Parameter [includeTags] :
  /// A Boolean that determines whether all tags for each resource ARN are
  /// exported with the job. If you set <code>IncludeTags</code> to
  /// <code>TRUE</code>, any tags associated with each resource are exported.
  ///
  /// Parameter [validationStrategy] :
  /// An optional parameter that determines which validation strategy to use for
  /// the export job. If <code>StrictModeForAllResources</code> is set to
  /// <code>TRUE</code>, strict validation for every error is enforced. If it is
  /// set to <code>FALSE</code>, validation is skipped for specific UI errors
  /// that are shown as warnings. The default value for
  /// <code>StrictModeForAllResources</code> is <code>FALSE</code>.
  Future<StartAssetBundleExportJobResponse> startAssetBundleExportJob({
    required String assetBundleExportJobId,
    required String awsAccountId,
    required AssetBundleExportFormat exportFormat,
    required List<String> resourceArns,
    AssetBundleCloudFormationOverridePropertyConfiguration?
        cloudFormationOverridePropertyConfiguration,
    bool? includeAllDependencies,
    bool? includePermissions,
    bool? includeTags,
    AssetBundleExportJobValidationStrategy? validationStrategy,
  }) async {
    final $payload = <String, dynamic>{
      'AssetBundleExportJobId': assetBundleExportJobId,
      'ExportFormat': exportFormat.toValue(),
      'ResourceArns': resourceArns,
      if (cloudFormationOverridePropertyConfiguration != null)
        'CloudFormationOverridePropertyConfiguration':
            cloudFormationOverridePropertyConfiguration,
      if (includeAllDependencies != null)
        'IncludeAllDependencies': includeAllDependencies,
      if (includePermissions != null) 'IncludePermissions': includePermissions,
      if (includeTags != null) 'IncludeTags': includeTags,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/asset-bundle-export-jobs/export',
      exceptionFnMap: _exceptionFns,
    );
    return StartAssetBundleExportJobResponse.fromJson(response);
  }

  /// Starts an Asset Bundle import job.
  ///
  /// An Asset Bundle import job imports specified Amazon QuickSight assets into
  /// an Amazon QuickSight account. You can also choose to import a naming
  /// prefix and specified configuration overrides. The assets that are
  /// contained in the bundle file that you provide are used to create or update
  /// a new or existing asset in your Amazon QuickSight account. Each Amazon
  /// QuickSight account can run up to 5 import jobs concurrently.
  ///
  /// The API caller must have the necessary <code>"create"</code>,
  /// <code>"describe"</code>, and <code>"update"</code> permissions in their
  /// IAM role to access each resource type that is contained in the bundle file
  /// before the resources can be imported.
  ///
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [LimitExceededException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  ///
  /// Parameter [assetBundleImportJobId] :
  /// The ID of the job. This ID is unique while the job is running. After the
  /// job is completed, you can reuse this ID for another job.
  ///
  /// Parameter [assetBundleImportSource] :
  /// The source of the asset bundle zip file that contains the data that you
  /// want to import. The file must be in <code>QUICKSIGHT_JSON</code> format.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account to import assets into.
  ///
  /// Parameter [failureAction] :
  /// The failure action for the import job.
  ///
  /// If you choose <code>ROLLBACK</code>, failed import jobs will attempt to
  /// undo any asset changes caused by the failed job.
  ///
  /// If you choose <code>DO_NOTHING</code>, failed import jobs will not attempt
  /// to roll back any asset changes caused by the failed job, possibly keeping
  /// the Amazon QuickSight account in an inconsistent state.
  ///
  /// Parameter [overrideParameters] :
  /// Optional overrides that are applied to the resource configuration before
  /// import.
  ///
  /// Parameter [overridePermissions] :
  /// Optional permission overrides that are applied to the resource
  /// configuration before import.
  ///
  /// Parameter [overrideTags] :
  /// Optional tag overrides that are applied to the resource configuration
  /// before import.
  ///
  /// Parameter [overrideValidationStrategy] :
  /// An optional validation strategy override for all analyses and dashboards
  /// that is applied to the resource configuration before import.
  Future<StartAssetBundleImportJobResponse> startAssetBundleImportJob({
    required String assetBundleImportJobId,
    required AssetBundleImportSource assetBundleImportSource,
    required String awsAccountId,
    AssetBundleImportFailureAction? failureAction,
    AssetBundleImportJobOverrideParameters? overrideParameters,
    AssetBundleImportJobOverridePermissions? overridePermissions,
    AssetBundleImportJobOverrideTags? overrideTags,
    AssetBundleImportJobOverrideValidationStrategy? overrideValidationStrategy,
  }) async {
    final $payload = <String, dynamic>{
      'AssetBundleImportJobId': assetBundleImportJobId,
      'AssetBundleImportSource': assetBundleImportSource,
      if (failureAction != null) 'FailureAction': failureAction.toValue(),
      if (overrideParameters != null) 'OverrideParameters': overrideParameters,
      if (overridePermissions != null)
        'OverridePermissions': overridePermissions,
      if (overrideTags != null) 'OverrideTags': overrideTags,
      if (overrideValidationStrategy != null)
        'OverrideValidationStrategy': overrideValidationStrategy,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/asset-bundle-import-jobs/import',
      exceptionFnMap: _exceptionFns,
    );
    return StartAssetBundleImportJobResponse.fromJson(response);
  }

  /// Starts an asynchronous job that generates a snapshot of a dashboard's
  /// output. You can request one or several of the following format
  /// configurations in each API call.
  ///
  /// <ul>
  /// <li>
  /// 1 Paginated PDF
  /// </li>
  /// <li>
  /// 1 Excel workbook that includes up to 5 table or pivot table visuals
  /// </li>
  /// <li>
  /// 5 CSVs from table or pivot table visuals
  /// </li>
  /// </ul>
  /// The status of a submitted job can be polled with the
  /// <code>DescribeDashboardSnapshotJob</code> API. When you call the
  /// <code>DescribeDashboardSnapshotJob</code> API, check the
  /// <code>JobStatus</code> field in the response. Once the job reaches a
  /// <code>COMPLETED</code> or <code>FAILED</code> status, use the
  /// <code>DescribeDashboardSnapshotJobResult</code> API to obtain the URLs for
  /// the generated files. If the job fails, the
  /// <code>DescribeDashboardSnapshotJobResult</code> API returns detailed
  /// information about the error that occurred.
  ///
  /// <b>StartDashboardSnapshotJob API throttling</b>
  ///
  /// Amazon QuickSight utilizes API throttling to create a more consistent user
  /// experience within a time span for customers when they call the
  /// <code>StartDashboardSnapshotJob</code>. By default, 12 jobs can run
  /// simlutaneously in one Amazon Web Services account and users can submit up
  /// 10 API requests per second before an account is throttled. If an
  /// overwhelming number of API requests are made by the same user in a short
  /// period of time, Amazon QuickSight throttles the API calls to maintin an
  /// optimal experience and reliability for all Amazon QuickSight users.
  ///
  /// <b>Common throttling scenarios</b>
  ///
  /// The following list provides information about the most commin throttling
  /// scenarios that can occur.
  ///
  /// <ul>
  /// <li>
  /// <b>A large number of <code>SnapshotExport</code> API jobs are running
  /// simultaneously on an Amazon Web Services account.</b> When a new
  /// <code>StartDashboardSnapshotJob</code> is created and there are already 12
  /// jobs with the <code>RUNNING</code> status, the new job request fails and
  /// returns a <code>LimitExceededException</code> error. Wait for a current
  /// job to comlpete before you resubmit the new job.
  /// </li>
  /// <li>
  /// <b>A large number of API requests are submitted on an Amazon Web Services
  /// account.</b> When a user makes more than 10 API calls to the Amazon
  /// QuickSight API in one second, a <code>ThrottlingException</code> is
  /// returned.
  /// </li>
  /// </ul>
  /// If your use case requires a higher throttling limit, contact your account
  /// admin or <a href="http://aws.amazon.com/contact-us/">Amazon Web
  /// ServicesSupport</a> to explore options to tailor a more optimal expereince
  /// for your account.
  ///
  /// <b>Best practices to handle throttling</b>
  ///
  /// If your use case projects high levels of API traffic, try to reduce the
  /// degree of frequency and parallelism of API calls as much as you can to
  /// avoid throttling. You can also perform a timing test to calculate an
  /// estimate for the total processing time of your projected load that stays
  /// within the throttling limits of the Amazon QuickSight APIs. For example,
  /// if your projected traffic is 100 snapshot jobs before 12:00 PM per day,
  /// start 12 jobs in parallel and measure the amount of time it takes to
  /// proccess all 12 jobs. Once you obtain the result, multiply the duration by
  /// 9, for example <code>(12 minutes * 9 = 108 minutes)</code>. Use the new
  /// result to determine the latest time at which the jobs need to be started
  /// to meet your target deadline.
  ///
  /// The time that it takes to process a job can be impacted by the following
  /// factors:
  ///
  /// <ul>
  /// <li>
  /// The dataset type (Direct Query or SPICE).
  /// </li>
  /// <li>
  /// The size of the dataset.
  /// </li>
  /// <li>
  /// The complexity of the calculated fields that are used in the dashboard.
  /// </li>
  /// <li>
  /// The number of visuals that are on a sheet.
  /// </li>
  /// <li>
  /// The types of visuals that are on the sheet.
  /// </li>
  /// <li>
  /// The number of formats and snapshots that are requested in the job
  /// configuration.
  /// </li>
  /// <li>
  /// The size of the generated snapshots.
  /// </li>
  /// </ul>
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [UnsupportedPricingPlanException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that the dashboard snapshot job
  /// is executed in.
  ///
  /// Parameter [dashboardId] :
  /// The ID of the dashboard that you want to start a snapshot job for.
  ///
  /// Parameter [snapshotConfiguration] :
  /// A structure that describes the configuration of the dashboard snapshot.
  ///
  /// Parameter [snapshotJobId] :
  /// An ID for the dashboard snapshot job. This ID is unique to the dashboard
  /// while the job is running. This ID can be used to poll the status of a job
  /// with a <code>DescribeDashboardSnapshotJob</code> while the job runs. You
  /// can reuse this ID for another job 24 hours after the current job is
  /// completed.
  ///
  /// Parameter [userConfiguration] :
  /// A structure that contains information about the anonymous users that the
  /// generated snapshot is for. This API will not return information about
  /// registered Amazon QuickSight.
  Future<StartDashboardSnapshotJobResponse> startDashboardSnapshotJob({
    required String awsAccountId,
    required String dashboardId,
    required SnapshotConfiguration snapshotConfiguration,
    required String snapshotJobId,
    required SnapshotUserConfiguration userConfiguration,
  }) async {
    final $payload = <String, dynamic>{
      'SnapshotConfiguration': snapshotConfiguration,
      'SnapshotJobId': snapshotJobId,
      'UserConfiguration': userConfiguration,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/snapshot-jobs',
      exceptionFnMap: _exceptionFns,
    );
    return StartDashboardSnapshotJobResponse.fromJson(response);
  }

  /// Assigns one or more tags (key-value pairs) to the specified Amazon
  /// QuickSight resource.
  ///
  /// Tags can help you organize and categorize your resources. You can also use
  /// them to scope user permissions, by granting a user permission to access or
  /// change only resources with certain tag values. You can use the
  /// <code>TagResource</code> operation with a resource that already has tags.
  /// If you specify a new tag key for the resource, this tag is appended to the
  /// list of tags associated with the resource. If you specify a tag key that
  /// is already associated with the resource, the new tag value that you
  /// specify replaces the previous value for that tag.
  ///
  /// You can associate as many as 50 tags with a resource. Amazon QuickSight
  /// supports tagging on data set, data source, dashboard, template, topic, and
  /// user.
  ///
  /// Tagging for Amazon QuickSight works in a similar way to tagging for other
  /// Amazon Web Services services, except for the following:
  ///
  /// <ul>
  /// <li>
  /// Tags are used to track costs for users in Amazon QuickSight. You can't tag
  /// other resources that Amazon QuickSight costs are based on, such as storage
  /// capacoty (SPICE), session usage, alert consumption, or reporting units.
  /// </li>
  /// <li>
  /// Amazon QuickSight doesn't currently support the tag editor for Resource
  /// Groups.
  /// </li>
  /// </ul>
  ///
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource that you want to tag.
  ///
  /// Parameter [tags] :
  /// Contains a map of the key-value pairs for the resource tag or tags
  /// assigned to the resource.
  Future<TagResourceResponse> tagResource({
    required String resourceArn,
    required List<Tag> tags,
  }) async {
    final $payload = <String, dynamic>{
      'Tags': tags,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri: '/resources/${Uri.encodeComponent(resourceArn)}/tags',
      exceptionFnMap: _exceptionFns,
    );
    return TagResourceResponse.fromJson(response);
  }

  /// Removes a tag or tags from a resource.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [resourceArn] :
  /// The Amazon Resource Name (ARN) of the resource that you want to untag.
  ///
  /// Parameter [tagKeys] :
  /// The keys of the key-value pairs for the resource tag or tags assigned to
  /// the resource.
  Future<UntagResourceResponse> untagResource({
    required String resourceArn,
    required List<String> tagKeys,
  }) async {
    final $query = <String, List<String>>{
      'keys': tagKeys,
    };
    final response = await _protocol.send(
      payload: null,
      method: 'DELETE',
      requestUri: '/resources/${Uri.encodeComponent(resourceArn)}/tags',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return UntagResourceResponse.fromJson(response);
  }

  /// Updates Amazon QuickSight customizations for the current Amazon Web
  /// Services Region. Currently, the only customization that you can use is a
  /// theme.
  ///
  /// You can use customizations for your Amazon Web Services account or, if you
  /// specify a namespace, for a Amazon QuickSight namespace instead.
  /// Customizations that apply to a namespace override customizations that
  /// apply to an Amazon Web Services account. To find out which customizations
  /// apply, use the <code>DescribeAccountCustomization</code> API operation.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [accountCustomization] :
  /// The Amazon QuickSight customizations you're updating in the current Amazon
  /// Web Services Region.
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to update Amazon
  /// QuickSight customizations for.
  ///
  /// Parameter [namespace] :
  /// The namespace that you want to update Amazon QuickSight customizations
  /// for.
  Future<UpdateAccountCustomizationResponse> updateAccountCustomization({
    required AccountCustomization accountCustomization,
    required String awsAccountId,
    String? namespace,
  }) async {
    final $query = <String, List<String>>{
      if (namespace != null) 'namespace': [namespace],
    };
    final $payload = <String, dynamic>{
      'AccountCustomization': accountCustomization,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/customizations',
      queryParams: $query,
      exceptionFnMap: _exceptionFns,
    );
    return UpdateAccountCustomizationResponse.fromJson(response);
  }

  /// Updates the Amazon QuickSight settings in your Amazon Web Services
  /// account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the Amazon
  /// QuickSight settings that you want to list.
  ///
  /// Parameter [defaultNamespace] :
  /// The default namespace for this Amazon Web Services account. Currently, the
  /// default is <code>default</code>. IAM users that register for the first
  /// time with Amazon QuickSight provide an email address that becomes
  /// associated with the default namespace.
  ///
  /// Parameter [notificationEmail] :
  /// The email address that you want Amazon QuickSight to send notifications to
  /// regarding your Amazon Web Services account or Amazon QuickSight
  /// subscription.
  ///
  /// Parameter [terminationProtectionEnabled] :
  /// A boolean value that determines whether or not an Amazon QuickSight
  /// account can be deleted. A <code>True</code> value doesn't allow the
  /// account to be deleted and results in an error message if a user tries to
  /// make a <code>DeleteAccountSubscription</code> request. A
  /// <code>False</code> value will allow the account to be deleted.
  Future<UpdateAccountSettingsResponse> updateAccountSettings({
    required String awsAccountId,
    required String defaultNamespace,
    String? notificationEmail,
    bool? terminationProtectionEnabled,
  }) async {
    final $payload = <String, dynamic>{
      'DefaultNamespace': defaultNamespace,
      if (notificationEmail != null) 'NotificationEmail': notificationEmail,
      if (terminationProtectionEnabled != null)
        'TerminationProtectionEnabled': terminationProtectionEnabled,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri: '/accounts/${Uri.encodeComponent(awsAccountId)}/settings',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateAccountSettingsResponse.fromJson(response);
  }

  /// Updates an analysis in Amazon QuickSight
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceExistsException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID for the analysis that you're updating. This ID displays in the URL
  /// of the analysis.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analysis that
  /// you're updating.
  ///
  /// Parameter [name] :
  /// A descriptive name for the analysis that you're updating. This name
  /// displays for the analysis in the Amazon QuickSight console.
  ///
  /// Parameter [definition] :
  /// The definition of an analysis.
  ///
  /// A definition is the data model of all features in a Dashboard, Template,
  /// or Analysis.
  ///
  /// Parameter [parameters] :
  /// The parameter names and override values that you want to use. An analysis
  /// can have any parameter type, and some parameters might accept multiple
  /// values.
  ///
  /// Parameter [sourceEntity] :
  /// A source entity to use for the analysis that you're updating. This
  /// metadata structure contains details that describe a source template and
  /// one or more datasets.
  ///
  /// Parameter [themeArn] :
  /// The Amazon Resource Name (ARN) for the theme to apply to the analysis that
  /// you're creating. To see the theme in the Amazon QuickSight console, make
  /// sure that you have access to it.
  ///
  /// Parameter [validationStrategy] :
  /// The option to relax the validation needed to update an analysis with
  /// definition objects. This skips the validation step for specific errors.
  Future<UpdateAnalysisResponse> updateAnalysis({
    required String analysisId,
    required String awsAccountId,
    required String name,
    AnalysisDefinition? definition,
    Parameters? parameters,
    AnalysisSourceEntity? sourceEntity,
    String? themeArn,
    ValidationStrategy? validationStrategy,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      if (definition != null) 'Definition': definition,
      if (parameters != null) 'Parameters': parameters,
      if (sourceEntity != null) 'SourceEntity': sourceEntity,
      if (themeArn != null) 'ThemeArn': themeArn,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateAnalysisResponse.fromJson(response);
  }

  /// Updates the read and write permissions for an analysis.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [analysisId] :
  /// The ID of the analysis whose permissions you're updating. The ID is part
  /// of the analysis URL.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the analysis whose
  /// permissions you're updating. You must be using the Amazon Web Services
  /// account that the analysis is in.
  ///
  /// Parameter [grantPermissions] :
  /// A structure that describes the permissions to add and the principal to add
  /// them to.
  ///
  /// Parameter [revokePermissions] :
  /// A structure that describes the permissions to remove and the principal to
  /// remove them from.
  Future<UpdateAnalysisPermissionsResponse> updateAnalysisPermissions({
    required String analysisId,
    required String awsAccountId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/analyses/${Uri.encodeComponent(analysisId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateAnalysisPermissionsResponse.fromJson(response);
  }

  /// Updates a dashboard in an Amazon Web Services account.
  /// <note>
  /// Updating a Dashboard creates a new dashboard version but does not
  /// immediately publish the new version. You can update the published version
  /// of a dashboard by using the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateDashboardPublishedVersion.html">UpdateDashboardPublishedVersion</a>
  /// </code> API operation.
  /// </note>
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [LimitExceededException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're updating.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [name] :
  /// The display name of the dashboard.
  ///
  /// Parameter [dashboardPublishOptions] :
  /// Options for publishing the dashboard when you create it:
  ///
  /// <ul>
  /// <li>
  /// <code>AvailabilityStatus</code> for <code>AdHocFilteringOption</code> -
  /// This status can be either <code>ENABLED</code> or <code>DISABLED</code>.
  /// When this is set to <code>DISABLED</code>, Amazon QuickSight disables the
  /// left filter pane on the published dashboard, which can be used for ad hoc
  /// (one-time) filtering. This option is <code>ENABLED</code> by default.
  /// </li>
  /// <li>
  /// <code>AvailabilityStatus</code> for <code>ExportToCSVOption</code> - This
  /// status can be either <code>ENABLED</code> or <code>DISABLED</code>. The
  /// visual option to export data to .CSV format isn't enabled when this is set
  /// to <code>DISABLED</code>. This option is <code>ENABLED</code> by default.
  /// </li>
  /// <li>
  /// <code>VisibilityState</code> for <code>SheetControlsOption</code> - This
  /// visibility state can be either <code>COLLAPSED</code> or
  /// <code>EXPANDED</code>. This option is <code>COLLAPSED</code> by default.
  /// </li>
  /// </ul>
  ///
  /// Parameter [definition] :
  /// The definition of a dashboard.
  ///
  /// A definition is the data model of all features in a Dashboard, Template,
  /// or Analysis.
  ///
  /// Parameter [parameters] :
  /// A structure that contains the parameters of the dashboard. These are
  /// parameter overrides for a dashboard. A dashboard can have any type of
  /// parameters, and some parameters might accept multiple values.
  ///
  /// Parameter [sourceEntity] :
  /// The entity that you are using as a source when you update the dashboard.
  /// In <code>SourceEntity</code>, you specify the type of object you're using
  /// as source. You can only update a dashboard from a template, so you use a
  /// <code>SourceTemplate</code> entity. If you need to update a dashboard from
  /// an analysis, first convert the analysis to a template by using the <code>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CreateTemplate.html">CreateTemplate</a>
  /// </code> API operation. For <code>SourceTemplate</code>, specify the Amazon
  /// Resource Name (ARN) of the source template. The
  /// <code>SourceTemplate</code> ARN can contain any Amazon Web Services
  /// account and any Amazon QuickSight-supported Amazon Web Services Region.
  ///
  /// Use the <code>DataSetReferences</code> entity within
  /// <code>SourceTemplate</code> to list the replacement datasets for the
  /// placeholders listed in the original. The schema in each dataset must match
  /// its placeholder.
  ///
  /// Parameter [themeArn] :
  /// The Amazon Resource Name (ARN) of the theme that is being used for this
  /// dashboard. If you add a value for this field, it overrides the value that
  /// was originally associated with the entity. The theme ARN must exist in the
  /// same Amazon Web Services account where you create the dashboard.
  ///
  /// Parameter [validationStrategy] :
  /// The option to relax the validation needed to update a dashboard with
  /// definition objects. This skips the validation step for specific errors.
  ///
  /// Parameter [versionDescription] :
  /// A description for the first version of the dashboard being created.
  Future<UpdateDashboardResponse> updateDashboard({
    required String awsAccountId,
    required String dashboardId,
    required String name,
    DashboardPublishOptions? dashboardPublishOptions,
    DashboardVersionDefinition? definition,
    Parameters? parameters,
    DashboardSourceEntity? sourceEntity,
    String? themeArn,
    ValidationStrategy? validationStrategy,
    String? versionDescription,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      if (dashboardPublishOptions != null)
        'DashboardPublishOptions': dashboardPublishOptions,
      if (definition != null) 'Definition': definition,
      if (parameters != null) 'Parameters': parameters,
      if (sourceEntity != null) 'SourceEntity': sourceEntity,
      if (themeArn != null) 'ThemeArn': themeArn,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDashboardResponse.fromJson(response);
  }

  /// Updates the linked analyses on a dashboard.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [AccessDeniedException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard
  /// whose links you want to update.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [linkEntities] :
  /// list of analysis Amazon Resource Names (ARNs) to be linked to the
  /// dashboard.
  Future<UpdateDashboardLinksResponse> updateDashboardLinks({
    required String awsAccountId,
    required String dashboardId,
    required List<String> linkEntities,
  }) async {
    final $payload = <String, dynamic>{
      'LinkEntities': linkEntities,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/linked-entities',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDashboardLinksResponse.fromJson(response);
  }

  /// Updates read and write permissions on a dashboard.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard
  /// whose permissions you're updating.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [grantLinkPermissions] :
  /// Grants link permissions to all users in a defined namespace.
  ///
  /// Parameter [grantPermissions] :
  /// The permissions that you want to grant on this resource.
  ///
  /// Parameter [revokeLinkPermissions] :
  /// Revokes link permissions from all users in a defined namespace.
  ///
  /// Parameter [revokePermissions] :
  /// The permissions that you want to revoke from this resource.
  Future<UpdateDashboardPermissionsResponse> updateDashboardPermissions({
    required String awsAccountId,
    required String dashboardId,
    List<ResourcePermission>? grantLinkPermissions,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokeLinkPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantLinkPermissions != null)
        'GrantLinkPermissions': grantLinkPermissions,
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokeLinkPermissions != null)
        'RevokeLinkPermissions': revokeLinkPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDashboardPermissionsResponse.fromJson(response);
  }

  /// Updates the published version of a dashboard.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the dashboard that
  /// you're updating.
  ///
  /// Parameter [dashboardId] :
  /// The ID for the dashboard.
  ///
  /// Parameter [versionNumber] :
  /// The version number of the dashboard.
  Future<UpdateDashboardPublishedVersionResponse>
      updateDashboardPublishedVersion({
    required String awsAccountId,
    required String dashboardId,
    required int versionNumber,
  }) async {
    _s.validateNumRange(
      'versionNumber',
      versionNumber,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final response = await _protocol.send(
      payload: null,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/dashboards/${Uri.encodeComponent(dashboardId)}/versions/${Uri.encodeComponent(versionNumber.toString())}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDashboardPublishedVersionResponse.fromJson(response);
  }

  /// Updates a dataset. This operation doesn't support datasets that include
  /// uploaded files as a source. Partial updates are not supported by this
  /// operation.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID for the dataset that you want to update. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  ///
  /// Parameter [importMode] :
  /// Indicates whether you want to import the data into SPICE.
  ///
  /// Parameter [name] :
  /// The display name for the dataset.
  ///
  /// Parameter [physicalTableMap] :
  /// Declares the physical tables that are available in the underlying data
  /// sources.
  ///
  /// Parameter [columnGroups] :
  /// Groupings of columns that work together in certain Amazon QuickSight
  /// features. Currently, only geospatial hierarchy is supported.
  ///
  /// Parameter [columnLevelPermissionRules] :
  /// A set of one or more definitions of a <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a>
  /// </code>.
  ///
  /// Parameter [datasetParameters] :
  /// The parameter declarations of the dataset.
  ///
  /// Parameter [fieldFolders] :
  /// The folder that contains fields and nested subfolders for your dataset.
  ///
  /// Parameter [logicalTableMap] :
  /// Configures the combination and transformation of the data from the
  /// physical tables.
  ///
  /// Parameter [rowLevelPermissionDataSet] :
  /// The row-level security configuration for the data you want to create.
  ///
  /// Parameter [rowLevelPermissionTagConfiguration] :
  /// The configuration of tags on a dataset to set row-level security.
  /// Row-level security tags are currently supported for anonymous embedding
  /// only.
  Future<UpdateDataSetResponse> updateDataSet({
    required String awsAccountId,
    required String dataSetId,
    required DataSetImportMode importMode,
    required String name,
    required Map<String, PhysicalTable> physicalTableMap,
    List<ColumnGroup>? columnGroups,
    List<ColumnLevelPermissionRule>? columnLevelPermissionRules,
    DataSetUsageConfiguration? dataSetUsageConfiguration,
    List<DatasetParameter>? datasetParameters,
    Map<String, FieldFolder>? fieldFolders,
    Map<String, LogicalTable>? logicalTableMap,
    RowLevelPermissionDataSet? rowLevelPermissionDataSet,
    RowLevelPermissionTagConfiguration? rowLevelPermissionTagConfiguration,
  }) async {
    final $payload = <String, dynamic>{
      'ImportMode': importMode.toValue(),
      'Name': name,
      'PhysicalTableMap': physicalTableMap,
      if (columnGroups != null) 'ColumnGroups': columnGroups,
      if (columnLevelPermissionRules != null)
        'ColumnLevelPermissionRules': columnLevelPermissionRules,
      if (dataSetUsageConfiguration != null)
        'DataSetUsageConfiguration': dataSetUsageConfiguration,
      if (datasetParameters != null) 'DatasetParameters': datasetParameters,
      if (fieldFolders != null) 'FieldFolders': fieldFolders,
      if (logicalTableMap != null) 'LogicalTableMap': logicalTableMap,
      if (rowLevelPermissionDataSet != null)
        'RowLevelPermissionDataSet': rowLevelPermissionDataSet,
      if (rowLevelPermissionTagConfiguration != null)
        'RowLevelPermissionTagConfiguration':
            rowLevelPermissionTagConfiguration,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDataSetResponse.fromJson(response);
  }

  /// Updates the permissions on a dataset.
  ///
  /// The permissions resource is
  /// <code>arn:aws:quicksight:region:aws-account-id:dataset/data-set-id</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID for the dataset whose permissions you want to update. This ID is
  /// unique per Amazon Web Services Region for each Amazon Web Services
  /// account.
  ///
  /// Parameter [grantPermissions] :
  /// The resource permissions that you want to grant to the dataset.
  ///
  /// Parameter [revokePermissions] :
  /// The resource permissions that you want to revoke from the dataset.
  Future<UpdateDataSetPermissionsResponse> updateDataSetPermissions({
    required String awsAccountId,
    required String dataSetId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDataSetPermissionsResponse.fromJson(response);
  }

  /// Updates a data source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSourceId] :
  /// The ID of the data source. This ID is unique per Amazon Web Services
  /// Region for each Amazon Web Services account.
  ///
  /// Parameter [name] :
  /// A display name for the data source.
  ///
  /// Parameter [credentials] :
  /// The credentials that Amazon QuickSight that uses to connect to your
  /// underlying source. Currently, only credentials based on user name and
  /// password are supported.
  ///
  /// Parameter [dataSourceParameters] :
  /// The parameters that Amazon QuickSight uses to connect to your underlying
  /// source.
  ///
  /// Parameter [sslProperties] :
  /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight
  /// connects to your underlying source.
  ///
  /// Parameter [vpcConnectionProperties] :
  /// Use this parameter only when you want Amazon QuickSight to use a VPC
  /// connection when connecting to your underlying source.
  Future<UpdateDataSourceResponse> updateDataSource({
    required String awsAccountId,
    required String dataSourceId,
    required String name,
    DataSourceCredentials? credentials,
    DataSourceParameters? dataSourceParameters,
    SslProperties? sslProperties,
    VpcConnectionProperties? vpcConnectionProperties,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      if (credentials != null) 'Credentials': credentials,
      if (dataSourceParameters != null)
        'DataSourceParameters': dataSourceParameters,
      if (sslProperties != null) 'SslProperties': sslProperties,
      if (vpcConnectionProperties != null)
        'VpcConnectionProperties': vpcConnectionProperties,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources/${Uri.encodeComponent(dataSourceId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDataSourceResponse.fromJson(response);
  }

  /// Updates the permissions to a data source.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSourceId] :
  /// The ID of the data source. This ID is unique per Amazon Web Services
  /// Region for each Amazon Web Services account.
  ///
  /// Parameter [grantPermissions] :
  /// A list of resource permissions that you want to grant on the data source.
  ///
  /// Parameter [revokePermissions] :
  /// A list of resource permissions that you want to revoke on the data source.
  Future<UpdateDataSourcePermissionsResponse> updateDataSourcePermissions({
    required String awsAccountId,
    required String dataSourceId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sources/${Uri.encodeComponent(dataSourceId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateDataSourcePermissionsResponse.fromJson(response);
  }

  /// Updates the name of a folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder to
  /// update.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [name] :
  /// The name of the folder.
  Future<UpdateFolderResponse> updateFolder({
    required String awsAccountId,
    required String folderId,
    required String name,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateFolderResponse.fromJson(response);
  }

  /// Updates permissions of a folder.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [AccessDeniedException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that contains the folder to
  /// update.
  ///
  /// Parameter [folderId] :
  /// The ID of the folder.
  ///
  /// Parameter [grantPermissions] :
  /// The permissions that you want to grant on a resource. Namespace ARNs are
  /// not supported <code>Principal</code> values for folder permissions.
  ///
  /// Parameter [revokePermissions] :
  /// The permissions that you want to revoke from a resource. Namespace ARNs
  /// are not supported <code>Principal</code> values for folder permissions.
  Future<UpdateFolderPermissionsResponse> updateFolderPermissions({
    required String awsAccountId,
    required String folderId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/folders/${Uri.encodeComponent(folderId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateFolderPermissionsResponse.fromJson(response);
  }

  /// Changes a group description.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the group is in.
  /// Currently, you use the ID for the Amazon Web Services account that
  /// contains your Amazon QuickSight account.
  ///
  /// Parameter [groupName] :
  /// The name of the group that you want to update.
  ///
  /// Parameter [namespace] :
  /// The namespace of the group that you want to update.
  ///
  /// Parameter [description] :
  /// The description for the group that you want to update.
  Future<UpdateGroupResponse> updateGroup({
    required String awsAccountId,
    required String groupName,
    required String namespace,
    String? description,
  }) async {
    final $payload = <String, dynamic>{
      if (description != null) 'Description': description,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/groups/${Uri.encodeComponent(groupName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateGroupResponse.fromJson(response);
  }

  /// Updates an existing IAM policy assignment. This operation updates only the
  /// optional parameter or parameters that are specified in the request. This
  /// overwrites all of the users included in <code>Identities</code>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConcurrentUpdatingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [assignmentName] :
  /// The name of the assignment, also called a rule. The name must be unique
  /// within the Amazon Web Services account.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the IAM policy
  /// assignment.
  ///
  /// Parameter [namespace] :
  /// The namespace of the assignment.
  ///
  /// Parameter [assignmentStatus] :
  /// The status of the assignment. Possible values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ENABLED</code> - Anything specified in this assignment is used when
  /// creating the data source.
  /// </li>
  /// <li>
  /// <code>DISABLED</code> - This assignment isn't used when creating the data
  /// source.
  /// </li>
  /// <li>
  /// <code>DRAFT</code> - This assignment is an unfinished draft and isn't used
  /// when creating the data source.
  /// </li>
  /// </ul>
  ///
  /// Parameter [identities] :
  /// The Amazon QuickSight users, groups, or both that you want to assign the
  /// policy to.
  ///
  /// Parameter [policyArn] :
  /// The ARN for the IAM policy to apply to the Amazon QuickSight users and
  /// groups specified in this assignment.
  Future<UpdateIAMPolicyAssignmentResponse> updateIAMPolicyAssignment({
    required String assignmentName,
    required String awsAccountId,
    required String namespace,
    AssignmentStatus? assignmentStatus,
    Map<String, List<String>>? identities,
    String? policyArn,
  }) async {
    final $payload = <String, dynamic>{
      if (assignmentStatus != null)
        'AssignmentStatus': assignmentStatus.toValue(),
      if (identities != null) 'Identities': identities,
      if (policyArn != null) 'PolicyArn': policyArn,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/iam-policy-assignments/${Uri.encodeComponent(assignmentName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateIAMPolicyAssignmentResponse.fromJson(response);
  }

  /// Adds or updates services and authorized targets to configure what the
  /// Amazon QuickSight IAM Identity Center application can access.
  ///
  /// This operation is only supported for Amazon QuickSight accounts using IAM
  /// Identity Center
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the identity
  /// propagation configuration that you want to update.
  ///
  /// Parameter [service] :
  /// The name of the Amazon Web Services service that contains the authorized
  /// targets that you want to add or update.
  ///
  /// Parameter [authorizedTargets] :
  /// Specifies a list of application ARNs that represent the authorized targets
  /// for a service.
  Future<UpdateIdentityPropagationConfigResponse>
      updateIdentityPropagationConfig({
    required String awsAccountId,
    required ServiceType service,
    List<String>? authorizedTargets,
  }) async {
    final $payload = <String, dynamic>{
      if (authorizedTargets != null) 'AuthorizedTargets': authorizedTargets,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/identity-propagation-config/${Uri.encodeComponent(service.toValue())}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateIdentityPropagationConfigResponse.fromJson(response);
  }

  /// Updates the content and status of IP rules. Traffic from a source is
  /// allowed when the source satisfies either the
  /// <code>IpRestrictionRule</code>, <code>VpcIdRestrictionRule</code>, or
  /// <code>VpcEndpointIdRestrictionRule</code>. To use this operation, you must
  /// provide the entire map of rules. You can use the
  /// <code>DescribeIpRestriction</code> operation to get the current rule map.
  ///
  /// May throw [LimitExceededException].
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the IP rules.
  ///
  /// Parameter [enabled] :
  /// A value that specifies whether IP rules are turned on.
  ///
  /// Parameter [ipRestrictionRuleMap] :
  /// A map that describes the updated IP rules with CIDR ranges and
  /// descriptions.
  ///
  /// Parameter [vpcEndpointIdRestrictionRuleMap] :
  /// A map of allowed VPC endpoint IDs and their corresponding rule
  /// descriptions.
  ///
  /// Parameter [vpcIdRestrictionRuleMap] :
  /// A map of VPC IDs and their corresponding rules. When you configure this
  /// parameter, traffic from all VPC endpoints that are present in the
  /// specified VPC is allowed.
  Future<UpdateIpRestrictionResponse> updateIpRestriction({
    required String awsAccountId,
    bool? enabled,
    Map<String, String>? ipRestrictionRuleMap,
    Map<String, String>? vpcEndpointIdRestrictionRuleMap,
    Map<String, String>? vpcIdRestrictionRuleMap,
  }) async {
    final $payload = <String, dynamic>{
      if (enabled != null) 'Enabled': enabled,
      if (ipRestrictionRuleMap != null)
        'IpRestrictionRuleMap': ipRestrictionRuleMap,
      if (vpcEndpointIdRestrictionRuleMap != null)
        'VpcEndpointIdRestrictionRuleMap': vpcEndpointIdRestrictionRuleMap,
      if (vpcIdRestrictionRuleMap != null)
        'VpcIdRestrictionRuleMap': vpcIdRestrictionRuleMap,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/ip-restriction',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateIpRestrictionResponse.fromJson(response);
  }

  /// Updates a customer managed key in a Amazon QuickSight account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the customer
  /// managed key registration that you want to update.
  ///
  /// Parameter [keyRegistration] :
  /// A list of <code>RegisteredCustomerManagedKey</code> objects to be updated
  /// to the Amazon QuickSight account.
  Future<UpdateKeyRegistrationResponse> updateKeyRegistration({
    required String awsAccountId,
    required List<RegisteredCustomerManagedKey> keyRegistration,
  }) async {
    final $payload = <String, dynamic>{
      'KeyRegistration': keyRegistration,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/key-registration',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateKeyRegistrationResponse.fromJson(response);
  }

  /// Use the <code>UpdatePublicSharingSettings</code> operation to turn on or
  /// turn off the public sharing settings of an Amazon QuickSight dashboard.
  ///
  /// To use this operation, turn on session capacity pricing for your Amazon
  /// QuickSight account.
  ///
  /// Before you can turn on public sharing on your account, make sure to give
  /// public sharing permissions to an administrative user in the Identity and
  /// Access Management (IAM) console. For more information on using IAM with
  /// Amazon QuickSight, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/security_iam_service-with-iam.html">Using
  /// Amazon QuickSight with IAM</a> in the <i>Amazon QuickSight User Guide</i>.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedPricingPlanException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID associated with your Amazon QuickSight
  /// subscription.
  ///
  /// Parameter [publicSharingEnabled] :
  /// A Boolean value that indicates whether public sharing is turned on for an
  /// Amazon QuickSight account.
  Future<UpdatePublicSharingSettingsResponse> updatePublicSharingSettings({
    required String awsAccountId,
    bool? publicSharingEnabled,
  }) async {
    final $payload = <String, dynamic>{
      if (publicSharingEnabled != null)
        'PublicSharingEnabled': publicSharingEnabled,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/public-sharing-settings',
      exceptionFnMap: _exceptionFns,
    );
    return UpdatePublicSharingSettingsResponse.fromJson(response);
  }

  /// Updates a refresh schedule for a dataset.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [LimitExceededException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID.
  ///
  /// Parameter [dataSetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [schedule] :
  /// The refresh schedule.
  Future<UpdateRefreshScheduleResponse> updateRefreshSchedule({
    required String awsAccountId,
    required String dataSetId,
    required RefreshSchedule schedule,
  }) async {
    final $payload = <String, dynamic>{
      'Schedule': schedule,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/data-sets/${Uri.encodeComponent(dataSetId)}/refresh-schedules',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateRefreshScheduleResponse.fromJson(response);
  }

  /// Updates the custom permissions that are associated with a role.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that you want to create a group
  /// in. The Amazon Web Services account ID that you provide must be the same
  /// Amazon Web Services account that contains your Amazon QuickSight account.
  ///
  /// Parameter [customPermissionsName] :
  /// The name of the custom permission that you want to update the role with.
  ///
  /// Parameter [namespace] :
  /// The namespace that contains the role that you want to update.
  ///
  /// Parameter [role] :
  /// The name of role tht you want to update.
  Future<UpdateRoleCustomPermissionResponse> updateRoleCustomPermission({
    required String awsAccountId,
    required String customPermissionsName,
    required String namespace,
    required Role role,
  }) async {
    final $payload = <String, dynamic>{
      'CustomPermissionsName': customPermissionsName,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/roles/${Uri.encodeComponent(role.toValue())}/custom-permission',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateRoleCustomPermissionResponse.fromJson(response);
  }

  /// Updates the SPICE capacity configuration for a Amazon QuickSight account.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the SPICE
  /// configuration that you want to update.
  ///
  /// Parameter [purchaseMode] :
  /// Determines how SPICE capacity can be purchased. The following options are
  /// available.
  ///
  /// <ul>
  /// <li>
  /// <code>MANUAL</code>: SPICE capacity can only be purchased manually.
  /// </li>
  /// <li>
  /// <code>AUTO_PURCHASE</code>: Extra SPICE capacity is automatically
  /// purchased on your behalf as needed. SPICE capacity can also be purchased
  /// manually with this option.
  /// </li>
  /// </ul>
  Future<UpdateSPICECapacityConfigurationResponse>
      updateSPICECapacityConfiguration({
    required String awsAccountId,
    required PurchaseMode purchaseMode,
  }) async {
    final $payload = <String, dynamic>{
      'PurchaseMode': purchaseMode.toValue(),
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'POST',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/spice-capacity-configuration',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateSPICECapacityConfigurationResponse.fromJson(response);
  }

  /// Updates a template from an existing Amazon QuickSight analysis or another
  /// template.
  ///
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [ConflictException].
  /// May throw [LimitExceededException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template that
  /// you're updating.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  ///
  /// Parameter [definition] :
  /// The definition of a template.
  ///
  /// A definition is the data model of all features in a Dashboard, Template,
  /// or Analysis.
  ///
  /// Parameter [name] :
  /// The name for the template.
  ///
  /// Parameter [sourceEntity] :
  /// The entity that you are using as a source when you update the template. In
  /// <code>SourceEntity</code>, you specify the type of object you're using as
  /// source: <code>SourceTemplate</code> for a template or
  /// <code>SourceAnalysis</code> for an analysis. Both of these require an
  /// Amazon Resource Name (ARN). For <code>SourceTemplate</code>, specify the
  /// ARN of the source template. For <code>SourceAnalysis</code>, specify the
  /// ARN of the source analysis. The <code>SourceTemplate</code> ARN can
  /// contain any Amazon Web Services account and any Amazon
  /// QuickSight-supported Amazon Web Services Region;.
  ///
  /// Use the <code>DataSetReferences</code> entity within
  /// <code>SourceTemplate</code> or <code>SourceAnalysis</code> to list the
  /// replacement datasets for the placeholders listed in the original. The
  /// schema in each dataset must match its placeholder.
  ///
  /// Parameter [validationStrategy] :
  /// The option to relax the validation needed to update a template with
  /// definition objects. This skips the validation step for specific errors.
  ///
  /// Parameter [versionDescription] :
  /// A description of the current template version that is being updated. Every
  /// time you call <code>UpdateTemplate</code>, you create a new version of the
  /// template. Each version of the template maintains a description of the
  /// version in the <code>VersionDescription</code> field.
  Future<UpdateTemplateResponse> updateTemplate({
    required String awsAccountId,
    required String templateId,
    TemplateVersionDefinition? definition,
    String? name,
    TemplateSourceEntity? sourceEntity,
    ValidationStrategy? validationStrategy,
    String? versionDescription,
  }) async {
    final $payload = <String, dynamic>{
      if (definition != null) 'Definition': definition,
      if (name != null) 'Name': name,
      if (sourceEntity != null) 'SourceEntity': sourceEntity,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTemplateResponse.fromJson(response);
  }

  /// Updates the template alias of a template.
  ///
  /// May throw [ThrottlingException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ConflictException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The alias of the template that you want to update. If you name a specific
  /// alias, you update the version that the alias points to. You can specify
  /// the latest version of the template by providing the keyword
  /// <code>$LATEST</code> in the <code>AliasName</code> parameter. The keyword
  /// <code>$PUBLISHED</code> doesn't apply to templates.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template alias
  /// that you're updating.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  ///
  /// Parameter [templateVersionNumber] :
  /// The version number of the template.
  Future<UpdateTemplateAliasResponse> updateTemplateAlias({
    required String aliasName,
    required String awsAccountId,
    required String templateId,
    required int templateVersionNumber,
  }) async {
    _s.validateNumRange(
      'templateVersionNumber',
      templateVersionNumber,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'TemplateVersionNumber': templateVersionNumber,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTemplateAliasResponse.fromJson(response);
  }

  /// Updates the resource permissions for a template.
  ///
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ConflictException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the template.
  ///
  /// Parameter [templateId] :
  /// The ID for the template.
  ///
  /// Parameter [grantPermissions] :
  /// A list of resource permissions to be granted on the template.
  ///
  /// Parameter [revokePermissions] :
  /// A list of resource permissions to be revoked from the template.
  Future<UpdateTemplatePermissionsResponse> updateTemplatePermissions({
    required String awsAccountId,
    required String templateId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/templates/${Uri.encodeComponent(templateId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTemplatePermissionsResponse.fromJson(response);
  }

  /// Updates a theme.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme that
  /// you're updating.
  ///
  /// Parameter [baseThemeId] :
  /// The theme ID, defined by Amazon QuickSight, that a custom theme inherits
  /// from. All themes initially inherit from a default Amazon QuickSight theme.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  ///
  /// Parameter [configuration] :
  /// The theme configuration, which contains the theme display properties.
  ///
  /// Parameter [name] :
  /// The name for the theme.
  ///
  /// Parameter [versionDescription] :
  /// A description of the theme version that you're updating Every time that
  /// you call <code>UpdateTheme</code>, you create a new version of the theme.
  /// Each version of the theme maintains a description of the version in
  /// <code>VersionDescription</code>.
  Future<UpdateThemeResponse> updateTheme({
    required String awsAccountId,
    required String baseThemeId,
    required String themeId,
    ThemeConfiguration? configuration,
    String? name,
    String? versionDescription,
  }) async {
    final $payload = <String, dynamic>{
      'BaseThemeId': baseThemeId,
      if (configuration != null) 'Configuration': configuration,
      if (name != null) 'Name': name,
      if (versionDescription != null) 'VersionDescription': versionDescription,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateThemeResponse.fromJson(response);
  }

  /// Updates an alias of a theme.
  ///
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceExistsException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [aliasName] :
  /// The name of the theme alias that you want to update.
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme alias
  /// that you're updating.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  ///
  /// Parameter [themeVersionNumber] :
  /// The version number of the theme that the alias should reference.
  Future<UpdateThemeAliasResponse> updateThemeAlias({
    required String aliasName,
    required String awsAccountId,
    required String themeId,
    required int themeVersionNumber,
  }) async {
    _s.validateNumRange(
      'themeVersionNumber',
      themeVersionNumber,
      1,
      1152921504606846976,
      isRequired: true,
    );
    final $payload = <String, dynamic>{
      'ThemeVersionNumber': themeVersionNumber,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/aliases/${Uri.encodeComponent(aliasName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateThemeAliasResponse.fromJson(response);
  }

  /// Updates the resource permissions for a theme. Permissions apply to the
  /// action to grant or revoke permissions on, for example
  /// <code>"quicksight:DescribeTheme"</code>.
  ///
  /// Theme permissions apply in groupings. Valid groupings include the
  /// following for the three levels of permissions, which are user, owner, or
  /// no permissions:
  ///
  /// <ul>
  /// <li>
  /// User
  ///
  /// <ul>
  /// <li>
  /// <code>"quicksight:DescribeTheme"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:DescribeThemeAlias"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:ListThemeAliases"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:ListThemeVersions"</code>
  /// </li>
  /// </ul> </li>
  /// <li>
  /// Owner
  ///
  /// <ul>
  /// <li>
  /// <code>"quicksight:DescribeTheme"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:DescribeThemeAlias"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:ListThemeAliases"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:ListThemeVersions"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:DeleteTheme"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:UpdateTheme"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:CreateThemeAlias"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:DeleteThemeAlias"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:UpdateThemeAlias"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:UpdateThemePermissions"</code>
  /// </li>
  /// <li>
  /// <code>"quicksight:DescribeThemePermissions"</code>
  /// </li>
  /// </ul> </li>
  /// <li>
  /// To specify no permissions, omit the permissions list.
  /// </li>
  /// </ul>
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the theme.
  ///
  /// Parameter [themeId] :
  /// The ID for the theme.
  ///
  /// Parameter [grantPermissions] :
  /// A list of resource permissions to be granted for the theme.
  ///
  /// Parameter [revokePermissions] :
  /// A list of resource permissions to be revoked from the theme.
  Future<UpdateThemePermissionsResponse> updateThemePermissions({
    required String awsAccountId,
    required String themeId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/themes/${Uri.encodeComponent(themeId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateThemePermissionsResponse.fromJson(response);
  }

  /// Updates a topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic that you
  /// want to update.
  ///
  /// Parameter [topic] :
  /// The definition of the topic that you want to update.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  Future<UpdateTopicResponse> updateTopic({
    required String awsAccountId,
    required TopicDetails topic,
    required String topicId,
  }) async {
    final $payload = <String, dynamic>{
      'Topic': topic,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTopicResponse.fromJson(response);
  }

  /// Updates the permissions of a topic.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ThrottlingException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [ConflictException].
  /// May throw [LimitExceededException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic that you
  /// want to update the permissions for.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  ///
  /// Parameter [grantPermissions] :
  /// The resource permissions that you want to grant to the topic.
  ///
  /// Parameter [revokePermissions] :
  /// The resource permissions that you want to revoke from the topic.
  Future<UpdateTopicPermissionsResponse> updateTopicPermissions({
    required String awsAccountId,
    required String topicId,
    List<ResourcePermission>? grantPermissions,
    List<ResourcePermission>? revokePermissions,
  }) async {
    final $payload = <String, dynamic>{
      if (grantPermissions != null) 'GrantPermissions': grantPermissions,
      if (revokePermissions != null) 'RevokePermissions': revokePermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/permissions',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTopicPermissionsResponse.fromJson(response);
  }

  /// Updates a topic refresh schedule.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ResourceExistsException].
  /// May throw [ThrottlingException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID of the Amazon Web Services account that contains the topic whose
  /// refresh schedule you want to update.
  ///
  /// Parameter [datasetId] :
  /// The ID of the dataset.
  ///
  /// Parameter [refreshSchedule] :
  /// The definition of a refresh schedule.
  ///
  /// Parameter [topicId] :
  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  Future<UpdateTopicRefreshScheduleResponse> updateTopicRefreshSchedule({
    required String awsAccountId,
    required String datasetId,
    required TopicRefreshSchedule refreshSchedule,
    required String topicId,
  }) async {
    final $payload = <String, dynamic>{
      'RefreshSchedule': refreshSchedule,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/topics/${Uri.encodeComponent(topicId)}/schedules/${Uri.encodeComponent(datasetId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateTopicRefreshScheduleResponse.fromJson(response);
  }

  /// Updates an Amazon QuickSight user.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [InvalidParameterValueException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [PreconditionNotMetException].
  /// May throw [InternalFailureException].
  /// May throw [ResourceUnavailableException].
  ///
  /// Parameter [awsAccountId] :
  /// The ID for the Amazon Web Services account that the user is in. Currently,
  /// you use the ID for the Amazon Web Services account that contains your
  /// Amazon QuickSight account.
  ///
  /// Parameter [email] :
  /// The email address of the user that you want to update.
  ///
  /// Parameter [namespace] :
  /// The namespace. Currently, you should set this to <code>default</code>.
  ///
  /// Parameter [role] :
  /// The Amazon QuickSight role of the user. The role can be one of the
  /// following default security cohorts:
  ///
  /// <ul>
  /// <li>
  /// <code>READER</code>: A user who has read-only access to dashboards.
  /// </li>
  /// <li>
  /// <code>AUTHOR</code>: A user who can create data sources, datasets,
  /// analyses, and dashboards.
  /// </li>
  /// <li>
  /// <code>ADMIN</code>: A user who is an author, who can also manage Amazon
  /// QuickSight settings.
  /// </li>
  /// <li>
  /// <code>READER_PRO</code>: Reader Pro adds Generative BI capabilities to the
  /// Reader role. Reader Pros have access to Amazon Q in Amazon QuickSight, can
  /// build stories with Amazon Q, and can generate executive summaries from
  /// dashboards.
  /// </li>
  /// <li>
  /// <code>AUTHOR_PRO</code>: Author Pro adds Generative BI capabilities to the
  /// Author role. Author Pros can author dashboards with natural language with
  /// Amazon Q, build stories with Amazon Q, create Topics for Q&amp;A, and
  /// generate executive summaries from dashboards.
  /// </li>
  /// <li>
  /// <code>ADMIN_PRO</code>: Admin Pros are Author Pros who can also manage
  /// Amazon QuickSight administrative settings. Admin Pro users are billed at
  /// Author Pro pricing.
  /// </li>
  /// </ul>
  /// The name of the Amazon QuickSight role is invisible to the user except for
  /// the console screens dealing with permissions.
  ///
  /// Parameter [userName] :
  /// The Amazon QuickSight user name that you want to update.
  ///
  /// Parameter [customFederationProviderUrl] :
  /// The URL of the custom OpenID Connect (OIDC) provider that provides
  /// identity to let a user federate into Amazon QuickSight with an associated
  /// Identity and Access Management(IAM) role. This parameter should only be
  /// used when <code>ExternalLoginFederationProviderType</code> parameter is
  /// set to <code>CUSTOM_OIDC</code>.
  ///
  /// Parameter [customPermissionsName] :
  /// (Enterprise edition only) The name of the custom permissions profile that
  /// you want to assign to this user. Customized permissions allows you to
  /// control a user's access by restricting access the following operations:
  ///
  /// <ul>
  /// <li>
  /// Create and update data sources
  /// </li>
  /// <li>
  /// Create and update datasets
  /// </li>
  /// <li>
  /// Create and update email reports
  /// </li>
  /// <li>
  /// Subscribe to email reports
  /// </li>
  /// </ul>
  /// A set of custom permissions includes any combination of these
  /// restrictions. Currently, you need to create the profile names for custom
  /// permission sets by using the Amazon QuickSight console. Then, you use the
  /// <code>RegisterUser</code> API operation to assign the named set of
  /// permissions to a Amazon QuickSight user.
  ///
  /// Amazon QuickSight custom permissions are applied through IAM policies.
  /// Therefore, they override the permissions typically granted by assigning
  /// Amazon QuickSight users to one of the default security cohorts in Amazon
  /// QuickSight (admin, author, reader).
  ///
  /// This feature is available only to Amazon QuickSight Enterprise edition
  /// subscriptions.
  ///
  /// Parameter [externalLoginFederationProviderType] :
  /// The type of supported external login provider that provides identity to
  /// let a user federate into Amazon QuickSight with an associated Identity and
  /// Access Management(IAM) role. The type of supported external login provider
  /// can be one of the following.
  ///
  /// <ul>
  /// <li>
  /// <code>COGNITO</code>: Amazon Cognito. The provider URL is
  /// cognito-identity.amazonaws.com. When choosing the <code>COGNITO</code>
  /// provider type, dont use the "CustomFederationProviderUrl" parameter which
  /// is only needed when the external provider is custom.
  /// </li>
  /// <li>
  /// <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider. When
  /// choosing <code>CUSTOM_OIDC</code> type, use the
  /// <code>CustomFederationProviderUrl</code> parameter to provide the custom
  /// OIDC provider URL.
  /// </li>
  /// <li>
  /// <code>NONE</code>: This clears all the previously saved external login
  /// information for a user. Use the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DescribeUser.html">DescribeUser</a>
  /// </code> API operation to check the external login information.
  /// </li>
  /// </ul>
  ///
  /// Parameter [externalLoginId] :
  /// The identity ID for a user in the external login provider.
  ///
  /// Parameter [unapplyCustomPermissions] :
  /// A flag that you use to indicate that you want to remove all custom
  /// permissions from this user. Using this parameter resets the user to the
  /// state it was in before a custom permissions profile was applied. This
  /// parameter defaults to NULL and it doesn't accept any other value.
  Future<UpdateUserResponse> updateUser({
    required String awsAccountId,
    required String email,
    required String namespace,
    required UserRole role,
    required String userName,
    String? customFederationProviderUrl,
    String? customPermissionsName,
    String? externalLoginFederationProviderType,
    String? externalLoginId,
    bool? unapplyCustomPermissions,
  }) async {
    final $payload = <String, dynamic>{
      'Email': email,
      'Role': role.toValue(),
      if (customFederationProviderUrl != null)
        'CustomFederationProviderUrl': customFederationProviderUrl,
      if (customPermissionsName != null)
        'CustomPermissionsName': customPermissionsName,
      if (externalLoginFederationProviderType != null)
        'ExternalLoginFederationProviderType':
            externalLoginFederationProviderType,
      if (externalLoginId != null) 'ExternalLoginId': externalLoginId,
      if (unapplyCustomPermissions != null)
        'UnapplyCustomPermissions': unapplyCustomPermissions,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/namespaces/${Uri.encodeComponent(namespace)}/users/${Uri.encodeComponent(userName)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateUserResponse.fromJson(response);
  }

  /// Updates a VPC connection.
  ///
  /// May throw [AccessDeniedException].
  /// May throw [ConflictException].
  /// May throw [InvalidParameterValueException].
  /// May throw [LimitExceededException].
  /// May throw [ResourceNotFoundException].
  /// May throw [ThrottlingException].
  /// May throw [UnsupportedUserEditionException].
  /// May throw [InternalFailureException].
  ///
  /// Parameter [awsAccountId] :
  /// The Amazon Web Services account ID of the account that contains the VPC
  /// connection that you want to update.
  ///
  /// Parameter [name] :
  /// The display name for the VPC connection.
  ///
  /// Parameter [roleArn] :
  /// An IAM role associated with the VPC connection.
  ///
  /// Parameter [securityGroupIds] :
  /// A list of security group IDs for the VPC connection.
  ///
  /// Parameter [subnetIds] :
  /// A list of subnet IDs for the VPC connection.
  ///
  /// Parameter [vPCConnectionId] :
  /// The ID of the VPC connection that you're updating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  ///
  /// Parameter [dnsResolvers] :
  /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
  Future<UpdateVPCConnectionResponse> updateVPCConnection({
    required String awsAccountId,
    required String name,
    required String roleArn,
    required List<String> securityGroupIds,
    required List<String> subnetIds,
    required String vPCConnectionId,
    List<String>? dnsResolvers,
  }) async {
    final $payload = <String, dynamic>{
      'Name': name,
      'RoleArn': roleArn,
      'SecurityGroupIds': securityGroupIds,
      'SubnetIds': subnetIds,
      if (dnsResolvers != null) 'DnsResolvers': dnsResolvers,
    };
    final response = await _protocol.send(
      payload: $payload,
      method: 'PUT',
      requestUri:
          '/accounts/${Uri.encodeComponent(awsAccountId)}/vpc-connections/${Uri.encodeComponent(vPCConnectionId)}',
      exceptionFnMap: _exceptionFns,
    );
    return UpdateVPCConnectionResponse.fromJson(response);
  }
}

/// The Amazon QuickSight customizations associated with your Amazon Web
/// Services account or a QuickSight namespace in a specific Amazon Web Services
/// Region.
class AccountCustomization {
  /// The default email customization template.
  final String? defaultEmailCustomizationTemplate;

  /// The default theme for this Amazon QuickSight subscription.
  final String? defaultTheme;

  AccountCustomization({
    this.defaultEmailCustomizationTemplate,
    this.defaultTheme,
  });

  factory AccountCustomization.fromJson(Map<String, dynamic> json) {
    return AccountCustomization(
      defaultEmailCustomizationTemplate:
          json['DefaultEmailCustomizationTemplate'] as String?,
      defaultTheme: json['DefaultTheme'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultEmailCustomizationTemplate =
        this.defaultEmailCustomizationTemplate;
    final defaultTheme = this.defaultTheme;
    return {
      if (defaultEmailCustomizationTemplate != null)
        'DefaultEmailCustomizationTemplate': defaultEmailCustomizationTemplate,
      if (defaultTheme != null) 'DefaultTheme': defaultTheme,
    };
  }
}

/// A structure that contains the following account information elements:
///
/// <ul>
/// <li>
/// Your Amazon QuickSight account name.
/// </li>
/// <li>
/// The edition of Amazon QuickSight that your account is using.
/// </li>
/// <li>
/// The notification email address that is associated with the Amazon QuickSight
/// account.
/// </li>
/// <li>
/// The authentication type of the Amazon QuickSight account.
/// </li>
/// <li>
/// The status of the Amazon QuickSight account's subscription.
/// </li>
/// </ul>
class AccountInfo {
  /// The account name that you provided for the Amazon QuickSight subscription in
  /// your Amazon Web Services account. You create this name when you sign up for
  /// Amazon QuickSight. It's unique over all of Amazon Web Services, and it
  /// appears only when users sign in.
  final String? accountName;

  /// The status of your account subscription.
  final String? accountSubscriptionStatus;

  /// The way that your Amazon QuickSight account is authenticated.
  final String? authenticationType;

  /// The edition of your Amazon QuickSight account.
  final Edition? edition;

  /// The Amazon Resource Name (ARN) for the IAM Identity Center instance.
  final String? iAMIdentityCenterInstanceArn;

  /// The email address that will be used for Amazon QuickSight to send
  /// notifications regarding your Amazon Web Services account or Amazon
  /// QuickSight subscription.
  final String? notificationEmail;

  AccountInfo({
    this.accountName,
    this.accountSubscriptionStatus,
    this.authenticationType,
    this.edition,
    this.iAMIdentityCenterInstanceArn,
    this.notificationEmail,
  });

  factory AccountInfo.fromJson(Map<String, dynamic> json) {
    return AccountInfo(
      accountName: json['AccountName'] as String?,
      accountSubscriptionStatus: json['AccountSubscriptionStatus'] as String?,
      authenticationType: json['AuthenticationType'] as String?,
      edition: (json['Edition'] as String?)?.toEdition(),
      iAMIdentityCenterInstanceArn:
          json['IAMIdentityCenterInstanceArn'] as String?,
      notificationEmail: json['NotificationEmail'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountName = this.accountName;
    final accountSubscriptionStatus = this.accountSubscriptionStatus;
    final authenticationType = this.authenticationType;
    final edition = this.edition;
    final iAMIdentityCenterInstanceArn = this.iAMIdentityCenterInstanceArn;
    final notificationEmail = this.notificationEmail;
    return {
      if (accountName != null) 'AccountName': accountName,
      if (accountSubscriptionStatus != null)
        'AccountSubscriptionStatus': accountSubscriptionStatus,
      if (authenticationType != null) 'AuthenticationType': authenticationType,
      if (edition != null) 'Edition': edition.toValue(),
      if (iAMIdentityCenterInstanceArn != null)
        'IAMIdentityCenterInstanceArn': iAMIdentityCenterInstanceArn,
      if (notificationEmail != null) 'NotificationEmail': notificationEmail,
    };
  }
}

/// The Amazon QuickSight settings associated with your Amazon Web Services
/// account.
class AccountSettings {
  /// The "account name" you provided for the Amazon QuickSight subscription in
  /// your Amazon Web Services account. You create this name when you sign up for
  /// Amazon QuickSight. It is unique in all of Amazon Web Services and it appears
  /// only when users sign in.
  final String? accountName;

  /// The default Amazon QuickSight namespace for your Amazon Web Services
  /// account.
  final String? defaultNamespace;

  /// The edition of Amazon QuickSight that you're currently subscribed to:
  /// Enterprise edition or Standard edition.
  final Edition? edition;

  /// The main notification email for your Amazon QuickSight subscription.
  final String? notificationEmail;

  /// A Boolean value that indicates whether public sharing is turned on for an
  /// Amazon QuickSight account. For more information about turning on public
  /// sharing, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdatePublicSharingSettings.html">UpdatePublicSharingSettings</a>.
  final bool? publicSharingEnabled;

  /// A boolean value that determines whether or not an Amazon QuickSight account
  /// can be deleted. A <code>True</code> value doesn't allow the account to be
  /// deleted and results in an error message if a user tries to make a
  /// <code>DeleteAccountSubsctiption</code> request. A <code>False</code> value
  /// will allow the ccount to be deleted.
  final bool? terminationProtectionEnabled;

  AccountSettings({
    this.accountName,
    this.defaultNamespace,
    this.edition,
    this.notificationEmail,
    this.publicSharingEnabled,
    this.terminationProtectionEnabled,
  });

  factory AccountSettings.fromJson(Map<String, dynamic> json) {
    return AccountSettings(
      accountName: json['AccountName'] as String?,
      defaultNamespace: json['DefaultNamespace'] as String?,
      edition: (json['Edition'] as String?)?.toEdition(),
      notificationEmail: json['NotificationEmail'] as String?,
      publicSharingEnabled: json['PublicSharingEnabled'] as bool?,
      terminationProtectionEnabled:
          json['TerminationProtectionEnabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountName = this.accountName;
    final defaultNamespace = this.defaultNamespace;
    final edition = this.edition;
    final notificationEmail = this.notificationEmail;
    final publicSharingEnabled = this.publicSharingEnabled;
    final terminationProtectionEnabled = this.terminationProtectionEnabled;
    return {
      if (accountName != null) 'AccountName': accountName,
      if (defaultNamespace != null) 'DefaultNamespace': defaultNamespace,
      if (edition != null) 'Edition': edition.toValue(),
      if (notificationEmail != null) 'NotificationEmail': notificationEmail,
      if (publicSharingEnabled != null)
        'PublicSharingEnabled': publicSharingEnabled,
      if (terminationProtectionEnabled != null)
        'TerminationProtectionEnabled': terminationProtectionEnabled,
    };
  }
}

/// The active Identity and Access Management (IAM) policy assignment.
class ActiveIAMPolicyAssignment {
  /// A name for the IAM policy assignment.
  final String? assignmentName;

  /// The Amazon Resource Name (ARN) of the resource.
  final String? policyArn;

  ActiveIAMPolicyAssignment({
    this.assignmentName,
    this.policyArn,
  });

  factory ActiveIAMPolicyAssignment.fromJson(Map<String, dynamic> json) {
    return ActiveIAMPolicyAssignment(
      assignmentName: json['AssignmentName'] as String?,
      policyArn: json['PolicyArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assignmentName = this.assignmentName;
    final policyArn = this.policyArn;
    return {
      if (assignmentName != null) 'AssignmentName': assignmentName,
      if (policyArn != null) 'PolicyArn': policyArn,
    };
  }
}

/// An ad hoc (one-time) filtering option.
class AdHocFilteringOption {
  /// Availability status.
  final DashboardBehavior? availabilityStatus;

  AdHocFilteringOption({
    this.availabilityStatus,
  });

  factory AdHocFilteringOption.fromJson(Map<String, dynamic> json) {
    return AdHocFilteringOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// An aggregation function aggregates values from a dimension or measure.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class AggregationFunction {
  /// Aggregation for attributes.
  final AttributeAggregationFunction? attributeAggregationFunction;

  /// Aggregation for categorical values.
  ///
  /// <ul>
  /// <li>
  /// <code>COUNT</code>: Aggregate by the total number of values, including
  /// duplicates.
  /// </li>
  /// <li>
  /// <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct
  /// values.
  /// </li>
  /// </ul>
  final CategoricalAggregationFunction? categoricalAggregationFunction;

  /// Aggregation for date values.
  ///
  /// <ul>
  /// <li>
  /// <code>COUNT</code>: Aggregate by the total number of values, including
  /// duplicates.
  /// </li>
  /// <li>
  /// <code>DISTINCT_COUNT</code>: Aggregate by the total number of distinct
  /// values.
  /// </li>
  /// <li>
  /// <code>MIN</code>: Select the smallest date value.
  /// </li>
  /// <li>
  /// <code>MAX</code>: Select the largest date value.
  /// </li>
  /// </ul>
  final DateAggregationFunction? dateAggregationFunction;

  /// Aggregation for numerical values.
  final NumericalAggregationFunction? numericalAggregationFunction;

  AggregationFunction({
    this.attributeAggregationFunction,
    this.categoricalAggregationFunction,
    this.dateAggregationFunction,
    this.numericalAggregationFunction,
  });

  factory AggregationFunction.fromJson(Map<String, dynamic> json) {
    return AggregationFunction(
      attributeAggregationFunction: json['AttributeAggregationFunction'] != null
          ? AttributeAggregationFunction.fromJson(
              json['AttributeAggregationFunction'] as Map<String, dynamic>)
          : null,
      categoricalAggregationFunction:
          (json['CategoricalAggregationFunction'] as String?)
              ?.toCategoricalAggregationFunction(),
      dateAggregationFunction: (json['DateAggregationFunction'] as String?)
          ?.toDateAggregationFunction(),
      numericalAggregationFunction: json['NumericalAggregationFunction'] != null
          ? NumericalAggregationFunction.fromJson(
              json['NumericalAggregationFunction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final attributeAggregationFunction = this.attributeAggregationFunction;
    final categoricalAggregationFunction = this.categoricalAggregationFunction;
    final dateAggregationFunction = this.dateAggregationFunction;
    final numericalAggregationFunction = this.numericalAggregationFunction;
    return {
      if (attributeAggregationFunction != null)
        'AttributeAggregationFunction': attributeAggregationFunction,
      if (categoricalAggregationFunction != null)
        'CategoricalAggregationFunction':
            categoricalAggregationFunction.toValue(),
      if (dateAggregationFunction != null)
        'DateAggregationFunction': dateAggregationFunction.toValue(),
      if (numericalAggregationFunction != null)
        'NumericalAggregationFunction': numericalAggregationFunction,
    };
  }
}

/// The configuration options to sort aggregated values.
class AggregationSortConfiguration {
  /// The column that determines the sort order of aggregated values.
  final ColumnIdentifier column;

  /// The sort direction of values.
  ///
  /// <ul>
  /// <li>
  /// <code>ASC</code>: Sort in ascending order.
  /// </li>
  /// <li>
  /// <code>DESC</code>: Sort in descending order.
  /// </li>
  /// </ul>
  final SortDirection sortDirection;

  /// The function that aggregates the values in <code>Column</code>.
  final AggregationFunction? aggregationFunction;

  AggregationSortConfiguration({
    required this.column,
    required this.sortDirection,
    this.aggregationFunction,
  });

  factory AggregationSortConfiguration.fromJson(Map<String, dynamic> json) {
    return AggregationSortConfiguration(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      sortDirection: (json['SortDirection'] as String).toSortDirection(),
      aggregationFunction: json['AggregationFunction'] != null
          ? AggregationFunction.fromJson(
              json['AggregationFunction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final sortDirection = this.sortDirection;
    final aggregationFunction = this.aggregationFunction;
    return {
      'Column': column,
      'SortDirection': sortDirection.toValue(),
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction,
    };
  }
}

/// An empty object that represents that the <code>AllSheets</code> option is
/// the chosen value for the <code>FilterScopeConfiguration</code> parameter.
/// This structure applies the filter to all visuals on all sheets of an
/// Analysis, Dashboard, or Template.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class AllSheetsFilterScopeConfiguration {
  AllSheetsFilterScopeConfiguration();

  factory AllSheetsFilterScopeConfiguration.fromJson(Map<String, dynamic> _) {
    return AllSheetsFilterScopeConfiguration();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The parameters for OpenSearch.
class AmazonElasticsearchParameters {
  /// The OpenSearch domain.
  final String domain;

  AmazonElasticsearchParameters({
    required this.domain,
  });

  factory AmazonElasticsearchParameters.fromJson(Map<String, dynamic> json) {
    return AmazonElasticsearchParameters(
      domain: json['Domain'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final domain = this.domain;
    return {
      'Domain': domain,
    };
  }
}

/// The parameters for OpenSearch.
class AmazonOpenSearchParameters {
  /// The OpenSearch domain.
  final String domain;

  AmazonOpenSearchParameters({
    required this.domain,
  });

  factory AmazonOpenSearchParameters.fromJson(Map<String, dynamic> json) {
    return AmazonOpenSearchParameters(
      domain: json['Domain'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final domain = this.domain;
    return {
      'Domain': domain,
    };
  }
}

/// Metadata structure for an analysis in Amazon QuickSight
class Analysis {
  /// The ID of the analysis.
  final String? analysisId;

  /// The Amazon Resource Name (ARN) of the analysis.
  final String? arn;

  /// The time that the analysis was created.
  final DateTime? createdTime;

  /// The ARNs of the datasets of the analysis.
  final List<String>? dataSetArns;

  /// Errors associated with the analysis.
  final List<AnalysisError>? errors;

  /// The time that the analysis was last updated.
  final DateTime? lastUpdatedTime;

  /// The descriptive name of the analysis.
  final String? name;

  /// A list of the associated sheets with the unique identifier and name of each
  /// sheet.
  final List<Sheet>? sheets;

  /// Status associated with the analysis.
  final ResourceStatus? status;

  /// The ARN of the theme of the analysis.
  final String? themeArn;

  Analysis({
    this.analysisId,
    this.arn,
    this.createdTime,
    this.dataSetArns,
    this.errors,
    this.lastUpdatedTime,
    this.name,
    this.sheets,
    this.status,
    this.themeArn,
  });

  factory Analysis.fromJson(Map<String, dynamic> json) {
    return Analysis(
      analysisId: json['AnalysisId'] as String?,
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSetArns: (json['DataSetArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => AnalysisError.fromJson(e as Map<String, dynamic>))
          .toList(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      sheets: (json['Sheets'] as List?)
          ?.whereNotNull()
          .map((e) => Sheet.fromJson(e as Map<String, dynamic>))
          .toList(),
      status: (json['Status'] as String?)?.toResourceStatus(),
      themeArn: json['ThemeArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final arn = this.arn;
    final createdTime = this.createdTime;
    final dataSetArns = this.dataSetArns;
    final errors = this.errors;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final sheets = this.sheets;
    final status = this.status;
    final themeArn = this.themeArn;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSetArns != null) 'DataSetArns': dataSetArns,
      if (errors != null) 'Errors': errors,
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (sheets != null) 'Sheets': sheets,
      if (status != null) 'Status': status.toValue(),
      if (themeArn != null) 'ThemeArn': themeArn,
    };
  }
}

/// The configuration for default analysis settings.
class AnalysisDefaults {
  /// The configuration for default new sheet settings.
  final DefaultNewSheetConfiguration defaultNewSheetConfiguration;

  AnalysisDefaults({
    required this.defaultNewSheetConfiguration,
  });

  factory AnalysisDefaults.fromJson(Map<String, dynamic> json) {
    return AnalysisDefaults(
      defaultNewSheetConfiguration: DefaultNewSheetConfiguration.fromJson(
          json['DefaultNewSheetConfiguration'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final defaultNewSheetConfiguration = this.defaultNewSheetConfiguration;
    return {
      'DefaultNewSheetConfiguration': defaultNewSheetConfiguration,
    };
  }
}

/// The definition of an analysis.
class AnalysisDefinition {
  /// An array of dataset identifier declarations. This mapping allows the usage
  /// of dataset identifiers instead of dataset ARNs throughout analysis
  /// sub-structures.
  final List<DataSetIdentifierDeclaration> dataSetIdentifierDeclarations;
  final AnalysisDefaults? analysisDefaults;

  /// An array of calculated field definitions for the analysis.
  final List<CalculatedField>? calculatedFields;

  /// An array of analysis-level column configurations. Column configurations can
  /// be used to set default formatting for a column to be used throughout an
  /// analysis.
  final List<ColumnConfiguration>? columnConfigurations;

  /// Filter definitions for an analysis.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering
  /// Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<FilterGroup>? filterGroups;

  /// An array of option definitions for an analysis.
  final AssetOptions? options;

  /// An array of parameter declarations for an analysis.
  ///
  /// Parameters are named variables that can transfer a value for use by an
  /// action or an object.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters
  /// in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<ParameterDeclaration>? parameterDeclarations;

  /// An array of sheet definitions for an analysis. Each
  /// <code>SheetDefinition</code> provides detailed information about a sheet
  /// within this analysis.
  final List<SheetDefinition>? sheets;

  AnalysisDefinition({
    required this.dataSetIdentifierDeclarations,
    this.analysisDefaults,
    this.calculatedFields,
    this.columnConfigurations,
    this.filterGroups,
    this.options,
    this.parameterDeclarations,
    this.sheets,
  });

  factory AnalysisDefinition.fromJson(Map<String, dynamic> json) {
    return AnalysisDefinition(
      dataSetIdentifierDeclarations: (json['DataSetIdentifierDeclarations']
              as List)
          .whereNotNull()
          .map((e) =>
              DataSetIdentifierDeclaration.fromJson(e as Map<String, dynamic>))
          .toList(),
      analysisDefaults: json['AnalysisDefaults'] != null
          ? AnalysisDefaults.fromJson(
              json['AnalysisDefaults'] as Map<String, dynamic>)
          : null,
      calculatedFields: (json['CalculatedFields'] as List?)
          ?.whereNotNull()
          .map((e) => CalculatedField.fromJson(e as Map<String, dynamic>))
          .toList(),
      columnConfigurations: (json['ColumnConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      filterGroups: (json['FilterGroups'] as List?)
          ?.whereNotNull()
          .map((e) => FilterGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      options: json['Options'] != null
          ? AssetOptions.fromJson(json['Options'] as Map<String, dynamic>)
          : null,
      parameterDeclarations: (json['ParameterDeclarations'] as List?)
          ?.whereNotNull()
          .map((e) => ParameterDeclaration.fromJson(e as Map<String, dynamic>))
          .toList(),
      sheets: (json['Sheets'] as List?)
          ?.whereNotNull()
          .map((e) => SheetDefinition.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifierDeclarations = this.dataSetIdentifierDeclarations;
    final analysisDefaults = this.analysisDefaults;
    final calculatedFields = this.calculatedFields;
    final columnConfigurations = this.columnConfigurations;
    final filterGroups = this.filterGroups;
    final options = this.options;
    final parameterDeclarations = this.parameterDeclarations;
    final sheets = this.sheets;
    return {
      'DataSetIdentifierDeclarations': dataSetIdentifierDeclarations,
      if (analysisDefaults != null) 'AnalysisDefaults': analysisDefaults,
      if (calculatedFields != null) 'CalculatedFields': calculatedFields,
      if (columnConfigurations != null)
        'ColumnConfigurations': columnConfigurations,
      if (filterGroups != null) 'FilterGroups': filterGroups,
      if (options != null) 'Options': options,
      if (parameterDeclarations != null)
        'ParameterDeclarations': parameterDeclarations,
      if (sheets != null) 'Sheets': sheets,
    };
  }
}

/// Analysis error.
class AnalysisError {
  /// The message associated with the analysis error.
  final String? message;

  /// The type of the analysis error.
  final AnalysisErrorType? type;

  /// Lists the violated entities that caused the analysis error
  final List<Entity>? violatedEntities;

  AnalysisError({
    this.message,
    this.type,
    this.violatedEntities,
  });

  factory AnalysisError.fromJson(Map<String, dynamic> json) {
    return AnalysisError(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toAnalysisErrorType(),
      violatedEntities: (json['ViolatedEntities'] as List?)
          ?.whereNotNull()
          .map((e) => Entity.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    final violatedEntities = this.violatedEntities;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
      if (violatedEntities != null) 'ViolatedEntities': violatedEntities,
    };
  }
}

enum AnalysisErrorType {
  accessDenied,
  sourceNotFound,
  dataSetNotFound,
  internalFailure,
  parameterValueIncompatible,
  parameterTypeInvalid,
  parameterNotFound,
  columnTypeMismatch,
  columnGeographicRoleMismatch,
  columnReplacementMissing,
}

extension AnalysisErrorTypeValueExtension on AnalysisErrorType {
  String toValue() {
    switch (this) {
      case AnalysisErrorType.accessDenied:
        return 'ACCESS_DENIED';
      case AnalysisErrorType.sourceNotFound:
        return 'SOURCE_NOT_FOUND';
      case AnalysisErrorType.dataSetNotFound:
        return 'DATA_SET_NOT_FOUND';
      case AnalysisErrorType.internalFailure:
        return 'INTERNAL_FAILURE';
      case AnalysisErrorType.parameterValueIncompatible:
        return 'PARAMETER_VALUE_INCOMPATIBLE';
      case AnalysisErrorType.parameterTypeInvalid:
        return 'PARAMETER_TYPE_INVALID';
      case AnalysisErrorType.parameterNotFound:
        return 'PARAMETER_NOT_FOUND';
      case AnalysisErrorType.columnTypeMismatch:
        return 'COLUMN_TYPE_MISMATCH';
      case AnalysisErrorType.columnGeographicRoleMismatch:
        return 'COLUMN_GEOGRAPHIC_ROLE_MISMATCH';
      case AnalysisErrorType.columnReplacementMissing:
        return 'COLUMN_REPLACEMENT_MISSING';
    }
  }
}

extension AnalysisErrorTypeFromString on String {
  AnalysisErrorType toAnalysisErrorType() {
    switch (this) {
      case 'ACCESS_DENIED':
        return AnalysisErrorType.accessDenied;
      case 'SOURCE_NOT_FOUND':
        return AnalysisErrorType.sourceNotFound;
      case 'DATA_SET_NOT_FOUND':
        return AnalysisErrorType.dataSetNotFound;
      case 'INTERNAL_FAILURE':
        return AnalysisErrorType.internalFailure;
      case 'PARAMETER_VALUE_INCOMPATIBLE':
        return AnalysisErrorType.parameterValueIncompatible;
      case 'PARAMETER_TYPE_INVALID':
        return AnalysisErrorType.parameterTypeInvalid;
      case 'PARAMETER_NOT_FOUND':
        return AnalysisErrorType.parameterNotFound;
      case 'COLUMN_TYPE_MISMATCH':
        return AnalysisErrorType.columnTypeMismatch;
      case 'COLUMN_GEOGRAPHIC_ROLE_MISMATCH':
        return AnalysisErrorType.columnGeographicRoleMismatch;
      case 'COLUMN_REPLACEMENT_MISSING':
        return AnalysisErrorType.columnReplacementMissing;
    }
    throw Exception('$this is not known in enum AnalysisErrorType');
  }
}

enum AnalysisFilterAttribute {
  quicksightUser,
  quicksightViewerOrOwner,
  directQuicksightViewerOrOwner,
  quicksightOwner,
  directQuicksightOwner,
  directQuicksightSoleOwner,
  analysisName,
}

extension AnalysisFilterAttributeValueExtension on AnalysisFilterAttribute {
  String toValue() {
    switch (this) {
      case AnalysisFilterAttribute.quicksightUser:
        return 'QUICKSIGHT_USER';
      case AnalysisFilterAttribute.quicksightViewerOrOwner:
        return 'QUICKSIGHT_VIEWER_OR_OWNER';
      case AnalysisFilterAttribute.directQuicksightViewerOrOwner:
        return 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER';
      case AnalysisFilterAttribute.quicksightOwner:
        return 'QUICKSIGHT_OWNER';
      case AnalysisFilterAttribute.directQuicksightOwner:
        return 'DIRECT_QUICKSIGHT_OWNER';
      case AnalysisFilterAttribute.directQuicksightSoleOwner:
        return 'DIRECT_QUICKSIGHT_SOLE_OWNER';
      case AnalysisFilterAttribute.analysisName:
        return 'ANALYSIS_NAME';
    }
  }
}

extension AnalysisFilterAttributeFromString on String {
  AnalysisFilterAttribute toAnalysisFilterAttribute() {
    switch (this) {
      case 'QUICKSIGHT_USER':
        return AnalysisFilterAttribute.quicksightUser;
      case 'QUICKSIGHT_VIEWER_OR_OWNER':
        return AnalysisFilterAttribute.quicksightViewerOrOwner;
      case 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER':
        return AnalysisFilterAttribute.directQuicksightViewerOrOwner;
      case 'QUICKSIGHT_OWNER':
        return AnalysisFilterAttribute.quicksightOwner;
      case 'DIRECT_QUICKSIGHT_OWNER':
        return AnalysisFilterAttribute.directQuicksightOwner;
      case 'DIRECT_QUICKSIGHT_SOLE_OWNER':
        return AnalysisFilterAttribute.directQuicksightSoleOwner;
      case 'ANALYSIS_NAME':
        return AnalysisFilterAttribute.analysisName;
    }
    throw Exception('$this is not known in enum AnalysisFilterAttribute');
  }
}

/// A filter that you apply when searching for one or more analyses.
class AnalysisSearchFilter {
  /// The name of the value that you want to use as a filter, for example
  /// <code>"Name": "QUICKSIGHT_OWNER"</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group,
  /// and any analyses with that ARN listed as one of the analysis' owners or
  /// viewers are returned. Implicit permissions from folders or groups are
  /// considered.
  /// </li>
  /// <li>
  /// <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any
  /// analyses with that ARN listed as one of the owners of the analyses are
  /// returned. Implicit permissions from folders or groups are considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or
  /// group, and any analyses with that ARN listed as the only owner of the
  /// analysis are returned. Implicit permissions from folders or groups are not
  /// considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and
  /// any analyses with that ARN listed as one of the owners of the analyses are
  /// returned. Implicit permissions from folders or groups are not considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or
  /// group, and any analyses with that ARN listed as one of the owners or viewers
  /// of the analyses are returned. Implicit permissions from folders or groups
  /// are not considered.
  /// </li>
  /// <li>
  /// <code>ANALYSIS_NAME</code>: Any analyses whose names have a substring match
  /// to this value will be returned.
  /// </li>
  /// </ul>
  final AnalysisFilterAttribute? name;

  /// The comparison operator that you want to use as a filter, for example
  /// <code>"Operator": "StringEquals"</code>. Valid values are
  /// <code>"StringEquals"</code> and <code>"StringLike"</code>.
  ///
  /// If you set the operator value to <code>"StringEquals"</code>, you need to
  /// provide an ownership related filter in the <code>"NAME"</code> field and the
  /// arn of the user or group whose folders you want to search in the
  /// <code>"Value"</code> field. For example,
  /// <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  ///
  /// If you set the value to <code>"StringLike"</code>, you need to provide the
  /// name of the folders you are searching for. For example,
  /// <code>"Name":"ANALYSIS_NAME", "Operator": "StringLike", "Value":
  /// "Test"</code>. The <code>"StringLike"</code> operator only supports the
  /// <code>NAME</code> value <code>ANALYSIS_NAME</code>.
  final FilterOperator? operator;

  /// The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that
  /// you want to use as a filter, for example <code>"Value"</code>. An example is
  /// <code>"arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  final String? value;

  AnalysisSearchFilter({
    this.name,
    this.operator,
    this.value,
  });

  Map<String, dynamic> toJson() {
    final name = this.name;
    final operator = this.operator;
    final value = this.value;
    return {
      if (name != null) 'Name': name.toValue(),
      if (operator != null) 'Operator': operator.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

/// The source entity of an analysis.
class AnalysisSourceEntity {
  /// The source template for the source entity of the analysis.
  final AnalysisSourceTemplate? sourceTemplate;

  AnalysisSourceEntity({
    this.sourceTemplate,
  });

  Map<String, dynamic> toJson() {
    final sourceTemplate = this.sourceTemplate;
    return {
      if (sourceTemplate != null) 'SourceTemplate': sourceTemplate,
    };
  }
}

/// The source template of an analysis.
class AnalysisSourceTemplate {
  /// The Amazon Resource Name (ARN) of the source template of an analysis.
  final String arn;

  /// The dataset references of the source template of an analysis.
  final List<DataSetReference> dataSetReferences;

  AnalysisSourceTemplate({
    required this.arn,
    required this.dataSetReferences,
  });

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSetReferences = this.dataSetReferences;
    return {
      'Arn': arn,
      'DataSetReferences': dataSetReferences,
    };
  }
}

/// The summary metadata that describes an analysis.
class AnalysisSummary {
  /// The ID of the analysis. This ID displays in the URL.
  final String? analysisId;

  /// The Amazon Resource Name (ARN) for the analysis.
  final String? arn;

  /// The time that the analysis was created.
  final DateTime? createdTime;

  /// The time that the analysis was last updated.
  final DateTime? lastUpdatedTime;

  /// The name of the analysis. This name is displayed in the Amazon QuickSight
  /// console.
  final String? name;

  /// The last known status for the analysis.
  final ResourceStatus? status;

  AnalysisSummary({
    this.analysisId,
    this.arn,
    this.createdTime,
    this.lastUpdatedTime,
    this.name,
    this.status,
  });

  factory AnalysisSummary.fromJson(Map<String, dynamic> json) {
    return AnalysisSummary(
      analysisId: json['AnalysisId'] as String?,
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      status: (json['Status'] as String?)?.toResourceStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final arn = this.arn;
    final createdTime = this.createdTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final status = this.status;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (status != null) 'Status': status.toValue(),
    };
  }
}

/// The date configuration of the filter.
class AnchorDateConfiguration {
  /// The options for the date configuration. Choose one of the options below:
  ///
  /// <ul>
  /// <li>
  /// <code>NOW</code>
  /// </li>
  /// </ul>
  final AnchorOption? anchorOption;

  /// The name of the parameter that is used for the anchor date configuration.
  final String? parameterName;

  AnchorDateConfiguration({
    this.anchorOption,
    this.parameterName,
  });

  factory AnchorDateConfiguration.fromJson(Map<String, dynamic> json) {
    return AnchorDateConfiguration(
      anchorOption: (json['AnchorOption'] as String?)?.toAnchorOption(),
      parameterName: json['ParameterName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final anchorOption = this.anchorOption;
    final parameterName = this.parameterName;
    return {
      if (anchorOption != null) 'AnchorOption': anchorOption.toValue(),
      if (parameterName != null) 'ParameterName': parameterName,
    };
  }
}

enum AnchorOption {
  now,
}

extension AnchorOptionValueExtension on AnchorOption {
  String toValue() {
    switch (this) {
      case AnchorOption.now:
        return 'NOW';
    }
  }
}

extension AnchorOptionFromString on String {
  AnchorOption toAnchorOption() {
    switch (this) {
      case 'NOW':
        return AnchorOption.now;
    }
    throw Exception('$this is not known in enum AnchorOption');
  }
}

/// Information about the dashboard that you want to embed.
class AnonymousUserDashboardEmbeddingConfiguration {
  /// The dashboard ID for the dashboard that you want the user to see first. This
  /// ID is included in the output URL. When the URL in response is accessed,
  /// Amazon QuickSight renders this dashboard.
  ///
  /// The Amazon Resource Name (ARN) of this dashboard must be included in the
  /// <code>AuthorizedResourceArns</code> parameter. Otherwise, the request will
  /// fail with <code>InvalidParameterValueException</code>.
  final String initialDashboardId;

  AnonymousUserDashboardEmbeddingConfiguration({
    required this.initialDashboardId,
  });

  Map<String, dynamic> toJson() {
    final initialDashboardId = this.initialDashboardId;
    return {
      'InitialDashboardId': initialDashboardId,
    };
  }
}

/// The experience that you are embedding. You can use this object to generate a
/// url that embeds a visual into your application.
class AnonymousUserDashboardVisualEmbeddingConfiguration {
  /// The visual ID for the visual that you want the user to see. This ID is
  /// included in the output URL. When the URL in response is accessed, Amazon
  /// QuickSight renders this visual.
  ///
  /// The Amazon Resource Name (ARN) of the dashboard that the visual belongs to
  /// must be included in the <code>AuthorizedResourceArns</code> parameter.
  /// Otherwise, the request will fail with
  /// <code>InvalidParameterValueException</code>.
  final DashboardVisualId initialDashboardVisualId;

  AnonymousUserDashboardVisualEmbeddingConfiguration({
    required this.initialDashboardVisualId,
  });

  Map<String, dynamic> toJson() {
    final initialDashboardVisualId = this.initialDashboardVisualId;
    return {
      'InitialDashboardVisualId': initialDashboardVisualId,
    };
  }
}

/// The type of experience you want to embed. For anonymous users, you can embed
/// Amazon QuickSight dashboards.
class AnonymousUserEmbeddingExperienceConfiguration {
  /// The type of embedding experience. In this case, Amazon QuickSight
  /// dashboards.
  final AnonymousUserDashboardEmbeddingConfiguration? dashboard;

  /// The type of embedding experience. In this case, Amazon QuickSight visuals.
  final AnonymousUserDashboardVisualEmbeddingConfiguration? dashboardVisual;

  /// The Generative Q&amp;A experience that you want to use for anonymous user
  /// embedding.
  final AnonymousUserGenerativeQnAEmbeddingConfiguration? generativeQnA;

  /// The Q search bar that you want to use for anonymous user embedding.
  final AnonymousUserQSearchBarEmbeddingConfiguration? qSearchBar;

  AnonymousUserEmbeddingExperienceConfiguration({
    this.dashboard,
    this.dashboardVisual,
    this.generativeQnA,
    this.qSearchBar,
  });

  Map<String, dynamic> toJson() {
    final dashboard = this.dashboard;
    final dashboardVisual = this.dashboardVisual;
    final generativeQnA = this.generativeQnA;
    final qSearchBar = this.qSearchBar;
    return {
      if (dashboard != null) 'Dashboard': dashboard,
      if (dashboardVisual != null) 'DashboardVisual': dashboardVisual,
      if (generativeQnA != null) 'GenerativeQnA': generativeQnA,
      if (qSearchBar != null) 'QSearchBar': qSearchBar,
    };
  }
}

/// The settings that you want to use for the Generative Q&amp;A experience.
class AnonymousUserGenerativeQnAEmbeddingConfiguration {
  /// The Amazon QuickSight Q topic ID of the new reader experience topic that you
  /// want the anonymous user to see first. This ID is included in the output URL.
  /// When the URL in response is accessed, Amazon QuickSight renders the
  /// Generative Q&amp;A experience with this new reader experience topic pre
  /// selected.
  ///
  /// The Amazon Resource Name (ARN) of this Q new reader experience topic must be
  /// included in the <code>AuthorizedResourceArns</code> parameter. Otherwise,
  /// the request fails with an <code>InvalidParameterValueException</code> error.
  final String initialTopicId;

  AnonymousUserGenerativeQnAEmbeddingConfiguration({
    required this.initialTopicId,
  });

  Map<String, dynamic> toJson() {
    final initialTopicId = this.initialTopicId;
    return {
      'InitialTopicId': initialTopicId,
    };
  }
}

/// The settings that you want to use with the Q search bar.
class AnonymousUserQSearchBarEmbeddingConfiguration {
  /// The Amazon QuickSight Q topic ID of the legacy topic that you want the
  /// anonymous user to see first. This ID is included in the output URL. When the
  /// URL in response is accessed, Amazon QuickSight renders the Q search bar with
  /// this legacy topic pre-selected.
  ///
  /// The Amazon Resource Name (ARN) of this Q legacy topic must be included in
  /// the <code>AuthorizedResourceArns</code> parameter. Otherwise, the request
  /// fails with an <code>InvalidParameterValueException</code> error.
  final String initialTopicId;

  AnonymousUserQSearchBarEmbeddingConfiguration({
    required this.initialTopicId,
  });

  Map<String, dynamic> toJson() {
    final initialTopicId = this.initialTopicId;
    return {
      'InitialTopicId': initialTopicId,
    };
  }
}

/// A structure that contains the file groups that are requested for the
/// artifact generation in a <code>StartDashboardSnapshotJob</code> API call.
class AnonymousUserSnapshotJobResult {
  /// A list of <code>SnapshotJobResultFileGroup</code> objects that contain
  /// information on the files that are requested during a
  /// <code>StartDashboardSnapshotJob</code> API call. If the job succeeds, these
  /// objects contain the location where the snapshot artifacts are stored. If the
  /// job fails, the objects contain information about the error that caused the
  /// job to fail.
  final List<SnapshotJobResultFileGroup>? fileGroups;

  AnonymousUserSnapshotJobResult({
    this.fileGroups,
  });

  factory AnonymousUserSnapshotJobResult.fromJson(Map<String, dynamic> json) {
    return AnonymousUserSnapshotJobResult(
      fileGroups: (json['FileGroups'] as List?)
          ?.whereNotNull()
          .map((e) =>
              SnapshotJobResultFileGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final fileGroups = this.fileGroups;
    return {
      if (fileGroups != null) 'FileGroups': fileGroups,
    };
  }
}

/// The arc axis configuration of a <code>GaugeChartVisual</code>.
class ArcAxisConfiguration {
  /// The arc axis range of a <code>GaugeChartVisual</code>.
  final ArcAxisDisplayRange? range;

  /// The reserved range of the arc axis.
  final int? reserveRange;

  ArcAxisConfiguration({
    this.range,
    this.reserveRange,
  });

  factory ArcAxisConfiguration.fromJson(Map<String, dynamic> json) {
    return ArcAxisConfiguration(
      range: json['Range'] != null
          ? ArcAxisDisplayRange.fromJson(json['Range'] as Map<String, dynamic>)
          : null,
      reserveRange: json['ReserveRange'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final range = this.range;
    final reserveRange = this.reserveRange;
    return {
      if (range != null) 'Range': range,
      if (reserveRange != null) 'ReserveRange': reserveRange,
    };
  }
}

/// The arc axis range of a <code>GaugeChartVisual</code>.
class ArcAxisDisplayRange {
  /// The maximum value of the arc axis range.
  final double? max;

  /// The minimum value of the arc axis range.
  final double? min;

  ArcAxisDisplayRange({
    this.max,
    this.min,
  });

  factory ArcAxisDisplayRange.fromJson(Map<String, dynamic> json) {
    return ArcAxisDisplayRange(
      max: json['Max'] as double?,
      min: json['Min'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final max = this.max;
    final min = this.min;
    return {
      if (max != null) 'Max': max,
      if (min != null) 'Min': min,
    };
  }
}

/// The arc configuration of a <code>GaugeChartVisual</code>.
class ArcConfiguration {
  /// The option that determines the arc angle of a <code>GaugeChartVisual</code>.
  final double? arcAngle;

  /// The options that determine the arc thickness of a
  /// <code>GaugeChartVisual</code>.
  final ArcThicknessOptions? arcThickness;

  ArcConfiguration({
    this.arcAngle,
    this.arcThickness,
  });

  factory ArcConfiguration.fromJson(Map<String, dynamic> json) {
    return ArcConfiguration(
      arcAngle: json['ArcAngle'] as double?,
      arcThickness: (json['ArcThickness'] as String?)?.toArcThicknessOptions(),
    );
  }

  Map<String, dynamic> toJson() {
    final arcAngle = this.arcAngle;
    final arcThickness = this.arcThickness;
    return {
      if (arcAngle != null) 'ArcAngle': arcAngle,
      if (arcThickness != null) 'ArcThickness': arcThickness.toValue(),
    };
  }
}

/// The options that determine the arc thickness of a
/// <code>GaugeChartVisual</code>.
class ArcOptions {
  /// The arc thickness of a <code>GaugeChartVisual</code>.
  final ArcThickness? arcThickness;

  ArcOptions({
    this.arcThickness,
  });

  factory ArcOptions.fromJson(Map<String, dynamic> json) {
    return ArcOptions(
      arcThickness: (json['ArcThickness'] as String?)?.toArcThickness(),
    );
  }

  Map<String, dynamic> toJson() {
    final arcThickness = this.arcThickness;
    return {
      if (arcThickness != null) 'ArcThickness': arcThickness.toValue(),
    };
  }
}

enum ArcThickness {
  small,
  medium,
  large,
  whole,
}

extension ArcThicknessValueExtension on ArcThickness {
  String toValue() {
    switch (this) {
      case ArcThickness.small:
        return 'SMALL';
      case ArcThickness.medium:
        return 'MEDIUM';
      case ArcThickness.large:
        return 'LARGE';
      case ArcThickness.whole:
        return 'WHOLE';
    }
  }
}

extension ArcThicknessFromString on String {
  ArcThickness toArcThickness() {
    switch (this) {
      case 'SMALL':
        return ArcThickness.small;
      case 'MEDIUM':
        return ArcThickness.medium;
      case 'LARGE':
        return ArcThickness.large;
      case 'WHOLE':
        return ArcThickness.whole;
    }
    throw Exception('$this is not known in enum ArcThickness');
  }
}

enum ArcThicknessOptions {
  small,
  medium,
  large,
}

extension ArcThicknessOptionsValueExtension on ArcThicknessOptions {
  String toValue() {
    switch (this) {
      case ArcThicknessOptions.small:
        return 'SMALL';
      case ArcThicknessOptions.medium:
        return 'MEDIUM';
      case ArcThicknessOptions.large:
        return 'LARGE';
    }
  }
}

extension ArcThicknessOptionsFromString on String {
  ArcThicknessOptions toArcThicknessOptions() {
    switch (this) {
      case 'SMALL':
        return ArcThicknessOptions.small;
      case 'MEDIUM':
        return ArcThicknessOptions.medium;
      case 'LARGE':
        return ArcThicknessOptions.large;
    }
    throw Exception('$this is not known in enum ArcThicknessOptions');
  }
}

/// An optional collection of CloudFormation property configurations that
/// control how the export job is generated.
class AssetBundleCloudFormationOverridePropertyConfiguration {
  /// An optional list of structures that control how <code>Analysis</code>
  /// resources are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobAnalysisOverrideProperties>? analyses;

  /// An optional list of structures that control how <code>Dashboard</code>
  /// resources are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobDashboardOverrideProperties>? dashboards;

  /// An optional list of structures that control how <code>DataSet</code>
  /// resources are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobDataSetOverrideProperties>? dataSets;

  /// An optional list of structures that control how <code>DataSource</code>
  /// resources are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobDataSourceOverrideProperties>? dataSources;

  /// An optional list of structures that control how <code>RefreshSchedule</code>
  /// resources are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobRefreshScheduleOverrideProperties>?
      refreshSchedules;

  /// An optional list of structures that control how resource IDs are
  /// parameterized in the returned CloudFormation template.
  final AssetBundleExportJobResourceIdOverrideConfiguration?
      resourceIdOverrideConfiguration;

  /// An optional list of structures that control how <code>Theme</code> resources
  /// are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobThemeOverrideProperties>? themes;

  /// An optional list of structures that control how <code>VPCConnection</code>
  /// resources are parameterized in the returned CloudFormation template.
  final List<AssetBundleExportJobVPCConnectionOverrideProperties>?
      vPCConnections;

  AssetBundleCloudFormationOverridePropertyConfiguration({
    this.analyses,
    this.dashboards,
    this.dataSets,
    this.dataSources,
    this.refreshSchedules,
    this.resourceIdOverrideConfiguration,
    this.themes,
    this.vPCConnections,
  });

  factory AssetBundleCloudFormationOverridePropertyConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleCloudFormationOverridePropertyConfiguration(
      analyses: (json['Analyses'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleExportJobAnalysisOverrideProperties.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dashboards: (json['Dashboards'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleExportJobDashboardOverrideProperties.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSets: (json['DataSets'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleExportJobDataSetOverrideProperties.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSources: (json['DataSources'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleExportJobDataSourceOverrideProperties.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      refreshSchedules: (json['RefreshSchedules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleExportJobRefreshScheduleOverrideProperties.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      resourceIdOverrideConfiguration:
          json['ResourceIdOverrideConfiguration'] != null
              ? AssetBundleExportJobResourceIdOverrideConfiguration.fromJson(
                  json['ResourceIdOverrideConfiguration']
                      as Map<String, dynamic>)
              : null,
      themes: (json['Themes'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleExportJobThemeOverrideProperties.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      vPCConnections: (json['VPCConnections'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleExportJobVPCConnectionOverrideProperties.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final analyses = this.analyses;
    final dashboards = this.dashboards;
    final dataSets = this.dataSets;
    final dataSources = this.dataSources;
    final refreshSchedules = this.refreshSchedules;
    final resourceIdOverrideConfiguration =
        this.resourceIdOverrideConfiguration;
    final themes = this.themes;
    final vPCConnections = this.vPCConnections;
    return {
      if (analyses != null) 'Analyses': analyses,
      if (dashboards != null) 'Dashboards': dashboards,
      if (dataSets != null) 'DataSets': dataSets,
      if (dataSources != null) 'DataSources': dataSources,
      if (refreshSchedules != null) 'RefreshSchedules': refreshSchedules,
      if (resourceIdOverrideConfiguration != null)
        'ResourceIdOverrideConfiguration': resourceIdOverrideConfiguration,
      if (themes != null) 'Themes': themes,
      if (vPCConnections != null) 'VPCConnections': vPCConnections,
    };
  }
}

enum AssetBundleExportFormat {
  cloudformationJson,
  quicksightJson,
}

extension AssetBundleExportFormatValueExtension on AssetBundleExportFormat {
  String toValue() {
    switch (this) {
      case AssetBundleExportFormat.cloudformationJson:
        return 'CLOUDFORMATION_JSON';
      case AssetBundleExportFormat.quicksightJson:
        return 'QUICKSIGHT_JSON';
    }
  }
}

extension AssetBundleExportFormatFromString on String {
  AssetBundleExportFormat toAssetBundleExportFormat() {
    switch (this) {
      case 'CLOUDFORMATION_JSON':
        return AssetBundleExportFormat.cloudformationJson;
      case 'QUICKSIGHT_JSON':
        return AssetBundleExportFormat.quicksightJson;
    }
    throw Exception('$this is not known in enum AssetBundleExportFormat');
  }
}

/// Controls how a specific <code>Analysis</code> resource is parameterized in
/// the returned CloudFormation template.
class AssetBundleExportJobAnalysisOverrideProperties {
  /// The ARN of the specific <code>Analysis</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>Analysis</code> resource properties to generate variables
  /// for in the returned CloudFormation template.
  final List<AssetBundleExportJobAnalysisPropertyToOverride> properties;

  AssetBundleExportJobAnalysisOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobAnalysisOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobAnalysisOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) =>
              (e as String).toAssetBundleExportJobAnalysisPropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobAnalysisPropertyToOverride {
  name,
}

extension AssetBundleExportJobAnalysisPropertyToOverrideValueExtension
    on AssetBundleExportJobAnalysisPropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobAnalysisPropertyToOverride.name:
        return 'Name';
    }
  }
}

extension AssetBundleExportJobAnalysisPropertyToOverrideFromString on String {
  AssetBundleExportJobAnalysisPropertyToOverride
      toAssetBundleExportJobAnalysisPropertyToOverride() {
    switch (this) {
      case 'Name':
        return AssetBundleExportJobAnalysisPropertyToOverride.name;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobAnalysisPropertyToOverride');
  }
}

/// Controls how a specific <code>Dashboard</code> resource is parameterized in
/// the returned CloudFormation template.
class AssetBundleExportJobDashboardOverrideProperties {
  /// The ARN of the specific <code>Dashboard</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>Dashboard</code> resource properties to generate variables
  /// for in the returned CloudFormation template.
  final List<AssetBundleExportJobDashboardPropertyToOverride> properties;

  AssetBundleExportJobDashboardOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobDashboardOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobDashboardOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) =>
              (e as String).toAssetBundleExportJobDashboardPropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobDashboardPropertyToOverride {
  name,
}

extension AssetBundleExportJobDashboardPropertyToOverrideValueExtension
    on AssetBundleExportJobDashboardPropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobDashboardPropertyToOverride.name:
        return 'Name';
    }
  }
}

extension AssetBundleExportJobDashboardPropertyToOverrideFromString on String {
  AssetBundleExportJobDashboardPropertyToOverride
      toAssetBundleExportJobDashboardPropertyToOverride() {
    switch (this) {
      case 'Name':
        return AssetBundleExportJobDashboardPropertyToOverride.name;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobDashboardPropertyToOverride');
  }
}

/// Controls how a specific <code>DataSet</code> resource is parameterized in
/// the returned CloudFormation template.
class AssetBundleExportJobDataSetOverrideProperties {
  /// The ARN of the specific <code>DataSet</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>DataSet</code> resource properties to generate variables for
  /// in the returned CloudFormation template.
  final List<AssetBundleExportJobDataSetPropertyToOverride> properties;

  AssetBundleExportJobDataSetOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobDataSetOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobDataSetOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) =>
              (e as String).toAssetBundleExportJobDataSetPropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobDataSetPropertyToOverride {
  name,
}

extension AssetBundleExportJobDataSetPropertyToOverrideValueExtension
    on AssetBundleExportJobDataSetPropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobDataSetPropertyToOverride.name:
        return 'Name';
    }
  }
}

extension AssetBundleExportJobDataSetPropertyToOverrideFromString on String {
  AssetBundleExportJobDataSetPropertyToOverride
      toAssetBundleExportJobDataSetPropertyToOverride() {
    switch (this) {
      case 'Name':
        return AssetBundleExportJobDataSetPropertyToOverride.name;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobDataSetPropertyToOverride');
  }
}

/// Controls how a specific <code>DataSource</code> resource is parameterized in
/// the returned CloudFormation template.
class AssetBundleExportJobDataSourceOverrideProperties {
  /// The ARN of the specific <code>DataSource</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>DataSource</code> resource properties to generate variables
  /// for in the returned CloudFormation template.
  final List<AssetBundleExportJobDataSourcePropertyToOverride> properties;

  AssetBundleExportJobDataSourceOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobDataSourceOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobDataSourceOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) => (e as String)
              .toAssetBundleExportJobDataSourcePropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobDataSourcePropertyToOverride {
  name,
  disableSsl,
  secretArn,
  username,
  password,
  domain,
  workGroup,
  host,
  port,
  database,
  dataSetName,
  catalog,
  instanceId,
  clusterId,
  manifestFileLocation,
  warehouse,
  roleArn,
  productType,
}

extension AssetBundleExportJobDataSourcePropertyToOverrideValueExtension
    on AssetBundleExportJobDataSourcePropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobDataSourcePropertyToOverride.name:
        return 'Name';
      case AssetBundleExportJobDataSourcePropertyToOverride.disableSsl:
        return 'DisableSsl';
      case AssetBundleExportJobDataSourcePropertyToOverride.secretArn:
        return 'SecretArn';
      case AssetBundleExportJobDataSourcePropertyToOverride.username:
        return 'Username';
      case AssetBundleExportJobDataSourcePropertyToOverride.password:
        return 'Password';
      case AssetBundleExportJobDataSourcePropertyToOverride.domain:
        return 'Domain';
      case AssetBundleExportJobDataSourcePropertyToOverride.workGroup:
        return 'WorkGroup';
      case AssetBundleExportJobDataSourcePropertyToOverride.host:
        return 'Host';
      case AssetBundleExportJobDataSourcePropertyToOverride.port:
        return 'Port';
      case AssetBundleExportJobDataSourcePropertyToOverride.database:
        return 'Database';
      case AssetBundleExportJobDataSourcePropertyToOverride.dataSetName:
        return 'DataSetName';
      case AssetBundleExportJobDataSourcePropertyToOverride.catalog:
        return 'Catalog';
      case AssetBundleExportJobDataSourcePropertyToOverride.instanceId:
        return 'InstanceId';
      case AssetBundleExportJobDataSourcePropertyToOverride.clusterId:
        return 'ClusterId';
      case AssetBundleExportJobDataSourcePropertyToOverride
            .manifestFileLocation:
        return 'ManifestFileLocation';
      case AssetBundleExportJobDataSourcePropertyToOverride.warehouse:
        return 'Warehouse';
      case AssetBundleExportJobDataSourcePropertyToOverride.roleArn:
        return 'RoleArn';
      case AssetBundleExportJobDataSourcePropertyToOverride.productType:
        return 'ProductType';
    }
  }
}

extension AssetBundleExportJobDataSourcePropertyToOverrideFromString on String {
  AssetBundleExportJobDataSourcePropertyToOverride
      toAssetBundleExportJobDataSourcePropertyToOverride() {
    switch (this) {
      case 'Name':
        return AssetBundleExportJobDataSourcePropertyToOverride.name;
      case 'DisableSsl':
        return AssetBundleExportJobDataSourcePropertyToOverride.disableSsl;
      case 'SecretArn':
        return AssetBundleExportJobDataSourcePropertyToOverride.secretArn;
      case 'Username':
        return AssetBundleExportJobDataSourcePropertyToOverride.username;
      case 'Password':
        return AssetBundleExportJobDataSourcePropertyToOverride.password;
      case 'Domain':
        return AssetBundleExportJobDataSourcePropertyToOverride.domain;
      case 'WorkGroup':
        return AssetBundleExportJobDataSourcePropertyToOverride.workGroup;
      case 'Host':
        return AssetBundleExportJobDataSourcePropertyToOverride.host;
      case 'Port':
        return AssetBundleExportJobDataSourcePropertyToOverride.port;
      case 'Database':
        return AssetBundleExportJobDataSourcePropertyToOverride.database;
      case 'DataSetName':
        return AssetBundleExportJobDataSourcePropertyToOverride.dataSetName;
      case 'Catalog':
        return AssetBundleExportJobDataSourcePropertyToOverride.catalog;
      case 'InstanceId':
        return AssetBundleExportJobDataSourcePropertyToOverride.instanceId;
      case 'ClusterId':
        return AssetBundleExportJobDataSourcePropertyToOverride.clusterId;
      case 'ManifestFileLocation':
        return AssetBundleExportJobDataSourcePropertyToOverride
            .manifestFileLocation;
      case 'Warehouse':
        return AssetBundleExportJobDataSourcePropertyToOverride.warehouse;
      case 'RoleArn':
        return AssetBundleExportJobDataSourcePropertyToOverride.roleArn;
      case 'ProductType':
        return AssetBundleExportJobDataSourcePropertyToOverride.productType;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobDataSourcePropertyToOverride');
  }
}

/// Describes an error that occurred during an Asset Bundle export job.
class AssetBundleExportJobError {
  /// The ARN of the resource whose processing caused an error.
  final String? arn;

  /// A description of the error.
  final String? message;

  /// The specific error type of the error that occurred.
  final String? type;

  AssetBundleExportJobError({
    this.arn,
    this.message,
    this.type,
  });

  factory AssetBundleExportJobError.fromJson(Map<String, dynamic> json) {
    return AssetBundleExportJobError(
      arn: json['Arn'] as String?,
      message: json['Message'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final message = this.message;
    final type = this.type;
    return {
      if (arn != null) 'Arn': arn,
      if (message != null) 'Message': message,
      if (type != null) 'Type': type,
    };
  }
}

/// Controls how a specific <code>RefreshSchedule</code> resource is
/// parameterized in the returned CloudFormation template.
class AssetBundleExportJobRefreshScheduleOverrideProperties {
  /// The ARN of the specific <code>RefreshSchedule</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>RefreshSchedule</code> resource properties to generate
  /// variables for in the returned CloudFormation template.
  final List<AssetBundleExportJobRefreshSchedulePropertyToOverride> properties;

  AssetBundleExportJobRefreshScheduleOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobRefreshScheduleOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobRefreshScheduleOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) => (e as String)
              .toAssetBundleExportJobRefreshSchedulePropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobRefreshSchedulePropertyToOverride {
  startAfterDateTime,
}

extension AssetBundleExportJobRefreshSchedulePropertyToOverrideValueExtension
    on AssetBundleExportJobRefreshSchedulePropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobRefreshSchedulePropertyToOverride
            .startAfterDateTime:
        return 'StartAfterDateTime';
    }
  }
}

extension AssetBundleExportJobRefreshSchedulePropertyToOverrideFromString
    on String {
  AssetBundleExportJobRefreshSchedulePropertyToOverride
      toAssetBundleExportJobRefreshSchedulePropertyToOverride() {
    switch (this) {
      case 'StartAfterDateTime':
        return AssetBundleExportJobRefreshSchedulePropertyToOverride
            .startAfterDateTime;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobRefreshSchedulePropertyToOverride');
  }
}

/// An optional structure that configures resource ID overrides for the export
/// job.
class AssetBundleExportJobResourceIdOverrideConfiguration {
  /// An option to request a CloudFormation variable for a prefix to be prepended
  /// to each resource's ID before import. The prefix is only added to the asset
  /// IDs and does not change the name of the asset.
  final bool? prefixForAllResources;

  AssetBundleExportJobResourceIdOverrideConfiguration({
    this.prefixForAllResources,
  });

  factory AssetBundleExportJobResourceIdOverrideConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobResourceIdOverrideConfiguration(
      prefixForAllResources: json['PrefixForAllResources'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final prefixForAllResources = this.prefixForAllResources;
    return {
      if (prefixForAllResources != null)
        'PrefixForAllResources': prefixForAllResources,
    };
  }
}

enum AssetBundleExportJobStatus {
  queuedForImmediateExecution,
  inProgress,
  successful,
  failed,
}

extension AssetBundleExportJobStatusValueExtension
    on AssetBundleExportJobStatus {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobStatus.queuedForImmediateExecution:
        return 'QUEUED_FOR_IMMEDIATE_EXECUTION';
      case AssetBundleExportJobStatus.inProgress:
        return 'IN_PROGRESS';
      case AssetBundleExportJobStatus.successful:
        return 'SUCCESSFUL';
      case AssetBundleExportJobStatus.failed:
        return 'FAILED';
    }
  }
}

extension AssetBundleExportJobStatusFromString on String {
  AssetBundleExportJobStatus toAssetBundleExportJobStatus() {
    switch (this) {
      case 'QUEUED_FOR_IMMEDIATE_EXECUTION':
        return AssetBundleExportJobStatus.queuedForImmediateExecution;
      case 'IN_PROGRESS':
        return AssetBundleExportJobStatus.inProgress;
      case 'SUCCESSFUL':
        return AssetBundleExportJobStatus.successful;
      case 'FAILED':
        return AssetBundleExportJobStatus.failed;
    }
    throw Exception('$this is not known in enum AssetBundleExportJobStatus');
  }
}

/// A summary of the export job that includes details of the job's configuration
/// and its current status.
class AssetBundleExportJobSummary {
  /// The ARN of the export job.
  final String? arn;

  /// The ID of the export job.
  final String? assetBundleExportJobId;

  /// The time that the export job was created.
  final DateTime? createdTime;

  /// The format for the export job.
  final AssetBundleExportFormat? exportFormat;

  /// The flag that determines the inclusion of resource dependencies in the
  /// returned asset bundle.
  final bool? includeAllDependencies;

  /// The flag that determines the inclusion of permissions associated with each
  /// resource ARN.
  final bool? includePermissions;

  /// The flag that determines the inclusion of tags associated with each resource
  /// ARN.
  final bool? includeTags;

  /// The current status of the export job.
  final AssetBundleExportJobStatus? jobStatus;

  AssetBundleExportJobSummary({
    this.arn,
    this.assetBundleExportJobId,
    this.createdTime,
    this.exportFormat,
    this.includeAllDependencies,
    this.includePermissions,
    this.includeTags,
    this.jobStatus,
  });

  factory AssetBundleExportJobSummary.fromJson(Map<String, dynamic> json) {
    return AssetBundleExportJobSummary(
      arn: json['Arn'] as String?,
      assetBundleExportJobId: json['AssetBundleExportJobId'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      exportFormat:
          (json['ExportFormat'] as String?)?.toAssetBundleExportFormat(),
      includeAllDependencies: json['IncludeAllDependencies'] as bool?,
      includePermissions: json['IncludePermissions'] as bool?,
      includeTags: json['IncludeTags'] as bool?,
      jobStatus: (json['JobStatus'] as String?)?.toAssetBundleExportJobStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assetBundleExportJobId = this.assetBundleExportJobId;
    final createdTime = this.createdTime;
    final exportFormat = this.exportFormat;
    final includeAllDependencies = this.includeAllDependencies;
    final includePermissions = this.includePermissions;
    final includeTags = this.includeTags;
    final jobStatus = this.jobStatus;
    return {
      if (arn != null) 'Arn': arn,
      if (assetBundleExportJobId != null)
        'AssetBundleExportJobId': assetBundleExportJobId,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (exportFormat != null) 'ExportFormat': exportFormat.toValue(),
      if (includeAllDependencies != null)
        'IncludeAllDependencies': includeAllDependencies,
      if (includePermissions != null) 'IncludePermissions': includePermissions,
      if (includeTags != null) 'IncludeTags': includeTags,
      if (jobStatus != null) 'JobStatus': jobStatus.toValue(),
    };
  }
}

/// Controls how a specific <code>Theme</code> resource is parameterized in the
/// returned CloudFormation template.
class AssetBundleExportJobThemeOverrideProperties {
  /// The ARN of the specific <code>Theme</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>Theme</code> resource properties to generate variables for
  /// in the returned CloudFormation template.
  final List<AssetBundleExportJobThemePropertyToOverride> properties;

  AssetBundleExportJobThemeOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobThemeOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobThemeOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) =>
              (e as String).toAssetBundleExportJobThemePropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobThemePropertyToOverride {
  name,
}

extension AssetBundleExportJobThemePropertyToOverrideValueExtension
    on AssetBundleExportJobThemePropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobThemePropertyToOverride.name:
        return 'Name';
    }
  }
}

extension AssetBundleExportJobThemePropertyToOverrideFromString on String {
  AssetBundleExportJobThemePropertyToOverride
      toAssetBundleExportJobThemePropertyToOverride() {
    switch (this) {
      case 'Name':
        return AssetBundleExportJobThemePropertyToOverride.name;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobThemePropertyToOverride');
  }
}

/// Controls how a specific <code>VPCConnection</code> resource is parameterized
/// in the outputted CloudFormation template.
class AssetBundleExportJobVPCConnectionOverrideProperties {
  /// The ARN of the specific <code>VPCConnection</code> resource whose override
  /// properties are configured in this structure.
  final String arn;

  /// A list of <code>VPCConnection</code> resource properties to generate
  /// variables for in the returned CloudFormation template.
  final List<AssetBundleExportJobVPCConnectionPropertyToOverride> properties;

  AssetBundleExportJobVPCConnectionOverrideProperties({
    required this.arn,
    required this.properties,
  });

  factory AssetBundleExportJobVPCConnectionOverrideProperties.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobVPCConnectionOverrideProperties(
      arn: json['Arn'] as String,
      properties: (json['Properties'] as List)
          .whereNotNull()
          .map((e) => (e as String)
              .toAssetBundleExportJobVPCConnectionPropertyToOverride())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final properties = this.properties;
    return {
      'Arn': arn,
      'Properties': properties.map((e) => e.toValue()).toList(),
    };
  }
}

enum AssetBundleExportJobVPCConnectionPropertyToOverride {
  name,
  dnsResolvers,
  roleArn,
}

extension AssetBundleExportJobVPCConnectionPropertyToOverrideValueExtension
    on AssetBundleExportJobVPCConnectionPropertyToOverride {
  String toValue() {
    switch (this) {
      case AssetBundleExportJobVPCConnectionPropertyToOverride.name:
        return 'Name';
      case AssetBundleExportJobVPCConnectionPropertyToOverride.dnsResolvers:
        return 'DnsResolvers';
      case AssetBundleExportJobVPCConnectionPropertyToOverride.roleArn:
        return 'RoleArn';
    }
  }
}

extension AssetBundleExportJobVPCConnectionPropertyToOverrideFromString
    on String {
  AssetBundleExportJobVPCConnectionPropertyToOverride
      toAssetBundleExportJobVPCConnectionPropertyToOverride() {
    switch (this) {
      case 'Name':
        return AssetBundleExportJobVPCConnectionPropertyToOverride.name;
      case 'DnsResolvers':
        return AssetBundleExportJobVPCConnectionPropertyToOverride.dnsResolvers;
      case 'RoleArn':
        return AssetBundleExportJobVPCConnectionPropertyToOverride.roleArn;
    }
    throw Exception(
        '$this is not known in enum AssetBundleExportJobVPCConnectionPropertyToOverride');
  }
}

/// The option to relax the validation that is required to export each asset.
/// When <code>StrictModeForAllResource</code> is set to <code>false</code>,
/// validation is skipped for specific UI errors.
class AssetBundleExportJobValidationStrategy {
  /// A Boolean value that indicates whether to export resources under strict or
  /// lenient mode.
  final bool? strictModeForAllResources;

  AssetBundleExportJobValidationStrategy({
    this.strictModeForAllResources,
  });

  factory AssetBundleExportJobValidationStrategy.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleExportJobValidationStrategy(
      strictModeForAllResources: json['StrictModeForAllResources'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final strictModeForAllResources = this.strictModeForAllResources;
    return {
      if (strictModeForAllResources != null)
        'StrictModeForAllResources': strictModeForAllResources,
    };
  }
}

/// Describes a warning that occurred during an Asset Bundle export job.
class AssetBundleExportJobWarning {
  /// The ARN of the resource whose processing caused a warning.
  final String? arn;

  /// A description of the warning.
  final String? message;

  AssetBundleExportJobWarning({
    this.arn,
    this.message,
  });

  factory AssetBundleExportJobWarning.fromJson(Map<String, dynamic> json) {
    return AssetBundleExportJobWarning(
      arn: json['Arn'] as String?,
      message: json['Message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final message = this.message;
    return {
      if (arn != null) 'Arn': arn,
      if (message != null) 'Message': message,
    };
  }
}

enum AssetBundleImportFailureAction {
  doNothing,
  rollback,
}

extension AssetBundleImportFailureActionValueExtension
    on AssetBundleImportFailureAction {
  String toValue() {
    switch (this) {
      case AssetBundleImportFailureAction.doNothing:
        return 'DO_NOTHING';
      case AssetBundleImportFailureAction.rollback:
        return 'ROLLBACK';
    }
  }
}

extension AssetBundleImportFailureActionFromString on String {
  AssetBundleImportFailureAction toAssetBundleImportFailureAction() {
    switch (this) {
      case 'DO_NOTHING':
        return AssetBundleImportFailureAction.doNothing;
      case 'ROLLBACK':
        return AssetBundleImportFailureAction.rollback;
    }
    throw Exception(
        '$this is not known in enum AssetBundleImportFailureAction');
  }
}

/// The override parameters for a single analysis that is being imported.
class AssetBundleImportJobAnalysisOverrideParameters {
  /// The ID of the analysis that you ant to apply overrides to.
  final String analysisId;

  /// A new name for the analysis.
  final String? name;

  AssetBundleImportJobAnalysisOverrideParameters({
    required this.analysisId,
    this.name,
  });

  factory AssetBundleImportJobAnalysisOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobAnalysisOverrideParameters(
      analysisId: json['AnalysisId'] as String,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final name = this.name;
    return {
      'AnalysisId': analysisId,
      if (name != null) 'Name': name,
    };
  }
}

/// An object that contains a list of permissions to be applied to a list of
/// analysis IDs.
class AssetBundleImportJobAnalysisOverridePermissions {
  /// A list of analysis IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all analyses in this asset bundle.
  final List<String> analysisIds;

  /// A list of permissions for the analyses that you want to apply overrides to.
  final AssetBundleResourcePermissions permissions;

  AssetBundleImportJobAnalysisOverridePermissions({
    required this.analysisIds,
    required this.permissions,
  });

  factory AssetBundleImportJobAnalysisOverridePermissions.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobAnalysisOverridePermissions(
      analysisIds: (json['AnalysisIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      permissions: AssetBundleResourcePermissions.fromJson(
          json['Permissions'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final analysisIds = this.analysisIds;
    final permissions = this.permissions;
    return {
      'AnalysisIds': analysisIds,
      'Permissions': permissions,
    };
  }
}

/// An object that contains a list of tags to be assigned to a list of analysis
/// IDs.
class AssetBundleImportJobAnalysisOverrideTags {
  /// A list of analysis IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all analyses in this asset bundle.
  final List<String> analysisIds;

  /// A list of tags for the analyses that you want to apply overrides to.
  final List<Tag> tags;

  AssetBundleImportJobAnalysisOverrideTags({
    required this.analysisIds,
    required this.tags,
  });

  factory AssetBundleImportJobAnalysisOverrideTags.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobAnalysisOverrideTags(
      analysisIds: (json['AnalysisIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final analysisIds = this.analysisIds;
    final tags = this.tags;
    return {
      'AnalysisIds': analysisIds,
      'Tags': tags,
    };
  }
}

/// The override parameters for a single dashboard that is being imported.
class AssetBundleImportJobDashboardOverrideParameters {
  /// The ID of the dashboard that you want to apply overrides to.
  final String dashboardId;

  /// A new name for the dashboard.
  final String? name;

  AssetBundleImportJobDashboardOverrideParameters({
    required this.dashboardId,
    this.name,
  });

  factory AssetBundleImportJobDashboardOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDashboardOverrideParameters(
      dashboardId: json['DashboardId'] as String,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardId = this.dashboardId;
    final name = this.name;
    return {
      'DashboardId': dashboardId,
      if (name != null) 'Name': name,
    };
  }
}

/// An object that contains a list of permissions to be applied to a list of
/// dashboard IDs.
class AssetBundleImportJobDashboardOverridePermissions {
  /// A list of dashboard IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all dashboards in this asset bundle.
  final List<String> dashboardIds;

  /// A structure that contains the link sharing configurations that you want to
  /// apply overrides to.
  final AssetBundleResourceLinkSharingConfiguration? linkSharingConfiguration;

  /// A list of permissions for the dashboards that you want to apply overrides
  /// to.
  final AssetBundleResourcePermissions? permissions;

  AssetBundleImportJobDashboardOverridePermissions({
    required this.dashboardIds,
    this.linkSharingConfiguration,
    this.permissions,
  });

  factory AssetBundleImportJobDashboardOverridePermissions.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDashboardOverridePermissions(
      dashboardIds: (json['DashboardIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      linkSharingConfiguration: json['LinkSharingConfiguration'] != null
          ? AssetBundleResourceLinkSharingConfiguration.fromJson(
              json['LinkSharingConfiguration'] as Map<String, dynamic>)
          : null,
      permissions: json['Permissions'] != null
          ? AssetBundleResourcePermissions.fromJson(
              json['Permissions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardIds = this.dashboardIds;
    final linkSharingConfiguration = this.linkSharingConfiguration;
    final permissions = this.permissions;
    return {
      'DashboardIds': dashboardIds,
      if (linkSharingConfiguration != null)
        'LinkSharingConfiguration': linkSharingConfiguration,
      if (permissions != null) 'Permissions': permissions,
    };
  }
}

/// An object that contains a list of tags to be assigned to a list of dashboard
/// IDs.
class AssetBundleImportJobDashboardOverrideTags {
  /// A list of dashboard IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all dashboards in this asset bundle.
  final List<String> dashboardIds;

  /// A list of tags for the dashboards that you want to apply overrides to.
  final List<Tag> tags;

  AssetBundleImportJobDashboardOverrideTags({
    required this.dashboardIds,
    required this.tags,
  });

  factory AssetBundleImportJobDashboardOverrideTags.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDashboardOverrideTags(
      dashboardIds: (json['DashboardIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardIds = this.dashboardIds;
    final tags = this.tags;
    return {
      'DashboardIds': dashboardIds,
      'Tags': tags,
    };
  }
}

/// The override parameters for a single dataset that is being imported.
class AssetBundleImportJobDataSetOverrideParameters {
  /// The ID of the dataset to apply overrides to.
  final String dataSetId;

  /// A new name for the dataset.
  final String? name;

  AssetBundleImportJobDataSetOverrideParameters({
    required this.dataSetId,
    this.name,
  });

  factory AssetBundleImportJobDataSetOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSetOverrideParameters(
      dataSetId: json['DataSetId'] as String,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetId = this.dataSetId;
    final name = this.name;
    return {
      'DataSetId': dataSetId,
      if (name != null) 'Name': name,
    };
  }
}

/// An object that contains a list of permissions to be applied to a list of
/// dataset IDs.
class AssetBundleImportJobDataSetOverridePermissions {
  /// A list of dataset IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all datasets in this asset bundle.
  final List<String> dataSetIds;

  /// A list of permissions for the datasets that you want to apply overrides to.
  final AssetBundleResourcePermissions permissions;

  AssetBundleImportJobDataSetOverridePermissions({
    required this.dataSetIds,
    required this.permissions,
  });

  factory AssetBundleImportJobDataSetOverridePermissions.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSetOverridePermissions(
      dataSetIds: (json['DataSetIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      permissions: AssetBundleResourcePermissions.fromJson(
          json['Permissions'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIds = this.dataSetIds;
    final permissions = this.permissions;
    return {
      'DataSetIds': dataSetIds,
      'Permissions': permissions,
    };
  }
}

/// An object that contains a list of tags to be assigned to a list of dataset
/// IDs.
class AssetBundleImportJobDataSetOverrideTags {
  /// A list of dataset IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all datasets in this asset bundle.
  final List<String> dataSetIds;

  /// A list of tags for the datasets that you want to apply overrides to.
  final List<Tag> tags;

  AssetBundleImportJobDataSetOverrideTags({
    required this.dataSetIds,
    required this.tags,
  });

  factory AssetBundleImportJobDataSetOverrideTags.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSetOverrideTags(
      dataSetIds: (json['DataSetIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIds = this.dataSetIds;
    final tags = this.tags;
    return {
      'DataSetIds': dataSetIds,
      'Tags': tags,
    };
  }
}

/// A username and password credential pair to use to import a data source
/// resource.
class AssetBundleImportJobDataSourceCredentialPair {
  /// The password for the data source connection.
  final String password;

  /// The username for the data source connection.
  final String username;

  AssetBundleImportJobDataSourceCredentialPair({
    required this.password,
    required this.username,
  });

  factory AssetBundleImportJobDataSourceCredentialPair.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSourceCredentialPair(
      password: json['Password'] as String,
      username: json['Username'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final password = this.password;
    final username = this.username;
    return {
      'Password': password,
      'Username': username,
    };
  }
}

/// The login credentials to use to import a data source resource.
class AssetBundleImportJobDataSourceCredentials {
  /// A username and password credential pair to be used to create the imported
  /// data source. Keep this field blank if you are using a Secrets Manager secret
  /// to provide credentials.
  final AssetBundleImportJobDataSourceCredentialPair? credentialPair;

  /// The ARN of the Secrets Manager secret that's used to create the imported
  /// data source. Keep this field blank, unless you are using a secret in place
  /// of a credential pair.
  final String? secretArn;

  AssetBundleImportJobDataSourceCredentials({
    this.credentialPair,
    this.secretArn,
  });

  factory AssetBundleImportJobDataSourceCredentials.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSourceCredentials(
      credentialPair: json['CredentialPair'] != null
          ? AssetBundleImportJobDataSourceCredentialPair.fromJson(
              json['CredentialPair'] as Map<String, dynamic>)
          : null,
      secretArn: json['SecretArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final credentialPair = this.credentialPair;
    final secretArn = this.secretArn;
    return {
      if (credentialPair != null) 'CredentialPair': credentialPair,
      if (secretArn != null) 'SecretArn': secretArn,
    };
  }
}

/// The override parameters for a single data source that is being imported.
class AssetBundleImportJobDataSourceOverrideParameters {
  /// The ID of the data source to apply overrides to.
  final String dataSourceId;

  /// An optional structure that provides the credentials to be used to create the
  /// imported data source.
  final AssetBundleImportJobDataSourceCredentials? credentials;
  final DataSourceParameters? dataSourceParameters;

  /// A new name for the data source.
  final String? name;
  final SslProperties? sslProperties;
  final VpcConnectionProperties? vpcConnectionProperties;

  AssetBundleImportJobDataSourceOverrideParameters({
    required this.dataSourceId,
    this.credentials,
    this.dataSourceParameters,
    this.name,
    this.sslProperties,
    this.vpcConnectionProperties,
  });

  factory AssetBundleImportJobDataSourceOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSourceOverrideParameters(
      dataSourceId: json['DataSourceId'] as String,
      credentials: json['Credentials'] != null
          ? AssetBundleImportJobDataSourceCredentials.fromJson(
              json['Credentials'] as Map<String, dynamic>)
          : null,
      dataSourceParameters: json['DataSourceParameters'] != null
          ? DataSourceParameters.fromJson(
              json['DataSourceParameters'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      sslProperties: json['SslProperties'] != null
          ? SslProperties.fromJson(
              json['SslProperties'] as Map<String, dynamic>)
          : null,
      vpcConnectionProperties: json['VpcConnectionProperties'] != null
          ? VpcConnectionProperties.fromJson(
              json['VpcConnectionProperties'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceId = this.dataSourceId;
    final credentials = this.credentials;
    final dataSourceParameters = this.dataSourceParameters;
    final name = this.name;
    final sslProperties = this.sslProperties;
    final vpcConnectionProperties = this.vpcConnectionProperties;
    return {
      'DataSourceId': dataSourceId,
      if (credentials != null) 'Credentials': credentials,
      if (dataSourceParameters != null)
        'DataSourceParameters': dataSourceParameters,
      if (name != null) 'Name': name,
      if (sslProperties != null) 'SslProperties': sslProperties,
      if (vpcConnectionProperties != null)
        'VpcConnectionProperties': vpcConnectionProperties,
    };
  }
}

/// An object that contains a list of permissions to be applied to a list of
/// data source IDs.
class AssetBundleImportJobDataSourceOverridePermissions {
  /// A list of data source IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all data sources in this asset bundle.
  final List<String> dataSourceIds;

  /// A list of permissions for the data source that you want to apply overrides
  /// to.
  final AssetBundleResourcePermissions permissions;

  AssetBundleImportJobDataSourceOverridePermissions({
    required this.dataSourceIds,
    required this.permissions,
  });

  factory AssetBundleImportJobDataSourceOverridePermissions.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSourceOverridePermissions(
      dataSourceIds: (json['DataSourceIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      permissions: AssetBundleResourcePermissions.fromJson(
          json['Permissions'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceIds = this.dataSourceIds;
    final permissions = this.permissions;
    return {
      'DataSourceIds': dataSourceIds,
      'Permissions': permissions,
    };
  }
}

/// An object that contains a list of tags to be assigned to a list of data
/// source IDs.
class AssetBundleImportJobDataSourceOverrideTags {
  /// A list of data source IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all data sources in this asset bundle.
  final List<String> dataSourceIds;

  /// A list of tags for the data source that you want to apply overrides to.
  final List<Tag> tags;

  AssetBundleImportJobDataSourceOverrideTags({
    required this.dataSourceIds,
    required this.tags,
  });

  factory AssetBundleImportJobDataSourceOverrideTags.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobDataSourceOverrideTags(
      dataSourceIds: (json['DataSourceIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceIds = this.dataSourceIds;
    final tags = this.tags;
    return {
      'DataSourceIds': dataSourceIds,
      'Tags': tags,
    };
  }
}

/// Describes an error that occurred within an Asset Bundle import execution.
class AssetBundleImportJobError {
  /// The ARN of the resource whose processing caused an error.
  final String? arn;

  /// A description of the error.
  final String? message;

  /// The specific error type or the error that occurred.
  final String? type;

  AssetBundleImportJobError({
    this.arn,
    this.message,
    this.type,
  });

  factory AssetBundleImportJobError.fromJson(Map<String, dynamic> json) {
    return AssetBundleImportJobError(
      arn: json['Arn'] as String?,
      message: json['Message'] as String?,
      type: json['Type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final message = this.message;
    final type = this.type;
    return {
      if (arn != null) 'Arn': arn,
      if (message != null) 'Message': message,
      if (type != null) 'Type': type,
    };
  }
}

/// A list of overrides that modify the asset bundle resource configuration
/// before the resource is imported.
class AssetBundleImportJobOverrideParameters {
  /// A list of overrides for any <code>Analysis</code> resources that are present
  /// in the asset bundle that is imported.
  final List<AssetBundleImportJobAnalysisOverrideParameters>? analyses;

  /// A list of overrides for any <code>Dashboard</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobDashboardOverrideParameters>? dashboards;

  /// A list of overrides for any <code>DataSet</code> resources that are present
  /// in the asset bundle that is imported.
  final List<AssetBundleImportJobDataSetOverrideParameters>? dataSets;

  /// A list of overrides for any <code>DataSource</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobDataSourceOverrideParameters>? dataSources;

  /// A list of overrides for any <code>RefreshSchedule</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobRefreshScheduleOverrideParameters>?
      refreshSchedules;

  /// An optional structure that configures resource ID overrides to be applied
  /// within the import job.
  final AssetBundleImportJobResourceIdOverrideConfiguration?
      resourceIdOverrideConfiguration;

  /// A list of overrides for any <code>Theme</code> resources that are present in
  /// the asset bundle that is imported.
  final List<AssetBundleImportJobThemeOverrideParameters>? themes;

  /// A list of overrides for any <code>VPCConnection</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobVPCConnectionOverrideParameters>?
      vPCConnections;

  AssetBundleImportJobOverrideParameters({
    this.analyses,
    this.dashboards,
    this.dataSets,
    this.dataSources,
    this.refreshSchedules,
    this.resourceIdOverrideConfiguration,
    this.themes,
    this.vPCConnections,
  });

  factory AssetBundleImportJobOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobOverrideParameters(
      analyses: (json['Analyses'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobAnalysisOverrideParameters.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dashboards: (json['Dashboards'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDashboardOverrideParameters.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSets: (json['DataSets'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDataSetOverrideParameters.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSources: (json['DataSources'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDataSourceOverrideParameters.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      refreshSchedules: (json['RefreshSchedules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobRefreshScheduleOverrideParameters.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      resourceIdOverrideConfiguration:
          json['ResourceIdOverrideConfiguration'] != null
              ? AssetBundleImportJobResourceIdOverrideConfiguration.fromJson(
                  json['ResourceIdOverrideConfiguration']
                      as Map<String, dynamic>)
              : null,
      themes: (json['Themes'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobThemeOverrideParameters.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      vPCConnections: (json['VPCConnections'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobVPCConnectionOverrideParameters.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final analyses = this.analyses;
    final dashboards = this.dashboards;
    final dataSets = this.dataSets;
    final dataSources = this.dataSources;
    final refreshSchedules = this.refreshSchedules;
    final resourceIdOverrideConfiguration =
        this.resourceIdOverrideConfiguration;
    final themes = this.themes;
    final vPCConnections = this.vPCConnections;
    return {
      if (analyses != null) 'Analyses': analyses,
      if (dashboards != null) 'Dashboards': dashboards,
      if (dataSets != null) 'DataSets': dataSets,
      if (dataSources != null) 'DataSources': dataSources,
      if (refreshSchedules != null) 'RefreshSchedules': refreshSchedules,
      if (resourceIdOverrideConfiguration != null)
        'ResourceIdOverrideConfiguration': resourceIdOverrideConfiguration,
      if (themes != null) 'Themes': themes,
      if (vPCConnections != null) 'VPCConnections': vPCConnections,
    };
  }
}

/// A structure that contains the override permission configurations that modify
/// the permissions for specified resources before the resource is imported.
class AssetBundleImportJobOverridePermissions {
  /// A list of permissions overrides for any <code>Analysis</code> resources that
  /// are present in the asset bundle that is imported.
  final List<AssetBundleImportJobAnalysisOverridePermissions>? analyses;

  /// A list of permissions overrides for any <code>Dashboard</code> resources
  /// that are present in the asset bundle that is imported.
  final List<AssetBundleImportJobDashboardOverridePermissions>? dashboards;

  /// A list of permissions overrides for any <code>DataSet</code> resources that
  /// are present in the asset bundle that is imported.
  final List<AssetBundleImportJobDataSetOverridePermissions>? dataSets;

  /// A list of permissions overrides for any <code>DataSource</code> resources
  /// that are present in the asset bundle that is imported.
  final List<AssetBundleImportJobDataSourceOverridePermissions>? dataSources;

  /// A list of permissions overrides for any <code>Theme</code> resources that
  /// are present in the asset bundle that is imported.
  final List<AssetBundleImportJobThemeOverridePermissions>? themes;

  AssetBundleImportJobOverridePermissions({
    this.analyses,
    this.dashboards,
    this.dataSets,
    this.dataSources,
    this.themes,
  });

  factory AssetBundleImportJobOverridePermissions.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobOverridePermissions(
      analyses: (json['Analyses'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobAnalysisOverridePermissions.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dashboards: (json['Dashboards'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDashboardOverridePermissions.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSets: (json['DataSets'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDataSetOverridePermissions.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSources: (json['DataSources'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobDataSourceOverridePermissions.fromJson(
                  e as Map<String, dynamic>))
          .toList(),
      themes: (json['Themes'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobThemeOverridePermissions.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final analyses = this.analyses;
    final dashboards = this.dashboards;
    final dataSets = this.dataSets;
    final dataSources = this.dataSources;
    final themes = this.themes;
    return {
      if (analyses != null) 'Analyses': analyses,
      if (dashboards != null) 'Dashboards': dashboards,
      if (dataSets != null) 'DataSets': dataSets,
      if (dataSources != null) 'DataSources': dataSources,
      if (themes != null) 'Themes': themes,
    };
  }
}

/// A structure that contains the override tag configuration that modify the
/// tags that are assigned to specified resources before the resource is
/// imported.
class AssetBundleImportJobOverrideTags {
  /// A list of tag overrides for any <code>Analysis</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobAnalysisOverrideTags>? analyses;

  /// A list of tag overrides for any <code>Dashboard</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobDashboardOverrideTags>? dashboards;

  /// A list of tag overrides for any <code>DataSet</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobDataSetOverrideTags>? dataSets;

  /// A list of tag overrides for any <code>DataSource</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobDataSourceOverrideTags>? dataSources;

  /// A list of tag overrides for any <code>Theme</code> resources that are
  /// present in the asset bundle that is imported.
  final List<AssetBundleImportJobThemeOverrideTags>? themes;

  /// A list of tag overrides for any <code>VPCConnection</code> resources that
  /// are present in the asset bundle that is imported.
  final List<AssetBundleImportJobVPCConnectionOverrideTags>? vPCConnections;

  AssetBundleImportJobOverrideTags({
    this.analyses,
    this.dashboards,
    this.dataSets,
    this.dataSources,
    this.themes,
    this.vPCConnections,
  });

  factory AssetBundleImportJobOverrideTags.fromJson(Map<String, dynamic> json) {
    return AssetBundleImportJobOverrideTags(
      analyses: (json['Analyses'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobAnalysisOverrideTags.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dashboards: (json['Dashboards'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDashboardOverrideTags.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSets: (json['DataSets'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDataSetOverrideTags.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataSources: (json['DataSources'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobDataSourceOverrideTags.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      themes: (json['Themes'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobThemeOverrideTags.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      vPCConnections: (json['VPCConnections'] as List?)
          ?.whereNotNull()
          .map((e) => AssetBundleImportJobVPCConnectionOverrideTags.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final analyses = this.analyses;
    final dashboards = this.dashboards;
    final dataSets = this.dataSets;
    final dataSources = this.dataSources;
    final themes = this.themes;
    final vPCConnections = this.vPCConnections;
    return {
      if (analyses != null) 'Analyses': analyses,
      if (dashboards != null) 'Dashboards': dashboards,
      if (dataSets != null) 'DataSets': dataSets,
      if (dataSources != null) 'DataSources': dataSources,
      if (themes != null) 'Themes': themes,
      if (vPCConnections != null) 'VPCConnections': vPCConnections,
    };
  }
}

/// An optional parameter that overrides the validation strategy for all
/// analyses and dashboards before the resource is imported.
class AssetBundleImportJobOverrideValidationStrategy {
  /// A Boolean value that indicates whether to import all analyses and dashboards
  /// under strict or lenient mode.
  final bool? strictModeForAllResources;

  AssetBundleImportJobOverrideValidationStrategy({
    this.strictModeForAllResources,
  });

  factory AssetBundleImportJobOverrideValidationStrategy.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobOverrideValidationStrategy(
      strictModeForAllResources: json['StrictModeForAllResources'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final strictModeForAllResources = this.strictModeForAllResources;
    return {
      if (strictModeForAllResources != null)
        'StrictModeForAllResources': strictModeForAllResources,
    };
  }
}

/// A list of overrides for a specific <code>RefreshsSchedule</code> resource
/// that is present in the asset bundle that is imported.
class AssetBundleImportJobRefreshScheduleOverrideParameters {
  /// A partial identifier for the specific <code>RefreshSchedule</code> resource
  /// that is being overridden. This structure is used together with the
  /// <code>ScheduleID</code> structure.
  final String dataSetId;

  /// A partial identifier for the specific <code>RefreshSchedule</code> resource
  /// being overridden. This structure is used together with the
  /// <code>DataSetId</code> structure.
  final String scheduleId;

  /// An override for the <code>StartAfterDateTime</code> of a
  /// <code>RefreshSchedule</code>. Make sure that the
  /// <code>StartAfterDateTime</code> is set to a time that takes place in the
  /// future.
  final DateTime? startAfterDateTime;

  AssetBundleImportJobRefreshScheduleOverrideParameters({
    required this.dataSetId,
    required this.scheduleId,
    this.startAfterDateTime,
  });

  factory AssetBundleImportJobRefreshScheduleOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobRefreshScheduleOverrideParameters(
      dataSetId: json['DataSetId'] as String,
      scheduleId: json['ScheduleId'] as String,
      startAfterDateTime: timeStampFromJson(json['StartAfterDateTime']),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetId = this.dataSetId;
    final scheduleId = this.scheduleId;
    final startAfterDateTime = this.startAfterDateTime;
    return {
      'DataSetId': dataSetId,
      'ScheduleId': scheduleId,
      if (startAfterDateTime != null)
        'StartAfterDateTime': unixTimestampToJson(startAfterDateTime),
    };
  }
}

/// An optional structure that configures resource ID overrides for the import
/// job.
class AssetBundleImportJobResourceIdOverrideConfiguration {
  /// An option to request a CloudFormation variable for a prefix to be prepended
  /// to each resource's ID before import. The prefix is only added to the asset
  /// IDs and does not change the name of the asset.
  final String? prefixForAllResources;

  AssetBundleImportJobResourceIdOverrideConfiguration({
    this.prefixForAllResources,
  });

  factory AssetBundleImportJobResourceIdOverrideConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobResourceIdOverrideConfiguration(
      prefixForAllResources: json['PrefixForAllResources'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final prefixForAllResources = this.prefixForAllResources;
    return {
      if (prefixForAllResources != null)
        'PrefixForAllResources': prefixForAllResources,
    };
  }
}

enum AssetBundleImportJobStatus {
  queuedForImmediateExecution,
  inProgress,
  successful,
  failed,
  failedRollbackInProgress,
  failedRollbackCompleted,
  failedRollbackError,
}

extension AssetBundleImportJobStatusValueExtension
    on AssetBundleImportJobStatus {
  String toValue() {
    switch (this) {
      case AssetBundleImportJobStatus.queuedForImmediateExecution:
        return 'QUEUED_FOR_IMMEDIATE_EXECUTION';
      case AssetBundleImportJobStatus.inProgress:
        return 'IN_PROGRESS';
      case AssetBundleImportJobStatus.successful:
        return 'SUCCESSFUL';
      case AssetBundleImportJobStatus.failed:
        return 'FAILED';
      case AssetBundleImportJobStatus.failedRollbackInProgress:
        return 'FAILED_ROLLBACK_IN_PROGRESS';
      case AssetBundleImportJobStatus.failedRollbackCompleted:
        return 'FAILED_ROLLBACK_COMPLETED';
      case AssetBundleImportJobStatus.failedRollbackError:
        return 'FAILED_ROLLBACK_ERROR';
    }
  }
}

extension AssetBundleImportJobStatusFromString on String {
  AssetBundleImportJobStatus toAssetBundleImportJobStatus() {
    switch (this) {
      case 'QUEUED_FOR_IMMEDIATE_EXECUTION':
        return AssetBundleImportJobStatus.queuedForImmediateExecution;
      case 'IN_PROGRESS':
        return AssetBundleImportJobStatus.inProgress;
      case 'SUCCESSFUL':
        return AssetBundleImportJobStatus.successful;
      case 'FAILED':
        return AssetBundleImportJobStatus.failed;
      case 'FAILED_ROLLBACK_IN_PROGRESS':
        return AssetBundleImportJobStatus.failedRollbackInProgress;
      case 'FAILED_ROLLBACK_COMPLETED':
        return AssetBundleImportJobStatus.failedRollbackCompleted;
      case 'FAILED_ROLLBACK_ERROR':
        return AssetBundleImportJobStatus.failedRollbackError;
    }
    throw Exception('$this is not known in enum AssetBundleImportJobStatus');
  }
}

/// A summary of the import job that includes details of the requested job's
/// configuration and its current status.
class AssetBundleImportJobSummary {
  /// The ARN of the import job.
  final String? arn;

  /// The ID of the job. This ID is unique while the job is running. After the job
  /// is completed, you can reuse this ID for another job.
  final String? assetBundleImportJobId;

  /// The time that the import job was created.
  final DateTime? createdTime;

  /// The failure action for the import job.
  final AssetBundleImportFailureAction? failureAction;

  /// The current status of the import job.
  final AssetBundleImportJobStatus? jobStatus;

  AssetBundleImportJobSummary({
    this.arn,
    this.assetBundleImportJobId,
    this.createdTime,
    this.failureAction,
    this.jobStatus,
  });

  factory AssetBundleImportJobSummary.fromJson(Map<String, dynamic> json) {
    return AssetBundleImportJobSummary(
      arn: json['Arn'] as String?,
      assetBundleImportJobId: json['AssetBundleImportJobId'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      failureAction: (json['FailureAction'] as String?)
          ?.toAssetBundleImportFailureAction(),
      jobStatus: (json['JobStatus'] as String?)?.toAssetBundleImportJobStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assetBundleImportJobId = this.assetBundleImportJobId;
    final createdTime = this.createdTime;
    final failureAction = this.failureAction;
    final jobStatus = this.jobStatus;
    return {
      if (arn != null) 'Arn': arn,
      if (assetBundleImportJobId != null)
        'AssetBundleImportJobId': assetBundleImportJobId,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (failureAction != null) 'FailureAction': failureAction.toValue(),
      if (jobStatus != null) 'JobStatus': jobStatus.toValue(),
    };
  }
}

/// The override parameters for a single theme that is imported.
class AssetBundleImportJobThemeOverrideParameters {
  /// The ID of the theme to apply overrides to.
  final String themeId;

  /// A new name for the theme.
  final String? name;

  AssetBundleImportJobThemeOverrideParameters({
    required this.themeId,
    this.name,
  });

  factory AssetBundleImportJobThemeOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobThemeOverrideParameters(
      themeId: json['ThemeId'] as String,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final themeId = this.themeId;
    final name = this.name;
    return {
      'ThemeId': themeId,
      if (name != null) 'Name': name,
    };
  }
}

/// An object that contains a list of permissions to be applied to a list of
/// theme IDs.
class AssetBundleImportJobThemeOverridePermissions {
  /// A list of permissions for the themes that you want to apply overrides to.
  final AssetBundleResourcePermissions permissions;

  /// A list of theme IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all themes in this asset bundle.
  final List<String> themeIds;

  AssetBundleImportJobThemeOverridePermissions({
    required this.permissions,
    required this.themeIds,
  });

  factory AssetBundleImportJobThemeOverridePermissions.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobThemeOverridePermissions(
      permissions: AssetBundleResourcePermissions.fromJson(
          json['Permissions'] as Map<String, dynamic>),
      themeIds: (json['ThemeIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final themeIds = this.themeIds;
    return {
      'Permissions': permissions,
      'ThemeIds': themeIds,
    };
  }
}

/// An object that contains a list of tags to be assigned to a list of theme
/// IDs.
class AssetBundleImportJobThemeOverrideTags {
  /// A list of tags for the themes that you want to apply overrides to.
  final List<Tag> tags;

  /// A list of theme IDs that you want to apply overrides to. You can use
  /// <code>*</code> to override all themes in this asset bundle.
  final List<String> themeIds;

  AssetBundleImportJobThemeOverrideTags({
    required this.tags,
    required this.themeIds,
  });

  factory AssetBundleImportJobThemeOverrideTags.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobThemeOverrideTags(
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
      themeIds: (json['ThemeIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final tags = this.tags;
    final themeIds = this.themeIds;
    return {
      'Tags': tags,
      'ThemeIds': themeIds,
    };
  }
}

/// The override parameters for a single VPC connection that is imported.
class AssetBundleImportJobVPCConnectionOverrideParameters {
  /// The ID of the VPC Connection to apply overrides to.
  final String vPCConnectionId;

  /// An optional override of DNS resolvers to be used by the VPC connection.
  final List<String>? dnsResolvers;

  /// A new name for the VPC connection.
  final String? name;

  /// An optional override of the role ARN to be used by the VPC connection.
  final String? roleArn;

  /// A new security group ID for the VPC connection you are importing. This field
  /// is required if you are importing the VPC connection from another Amazon Web
  /// Services account or Region.
  final List<String>? securityGroupIds;

  /// A list of new subnet IDs for the VPC connection you are importing. This
  /// field is required if you are importing the VPC connection from another
  /// Amazon Web Services account or Region.
  final List<String>? subnetIds;

  AssetBundleImportJobVPCConnectionOverrideParameters({
    required this.vPCConnectionId,
    this.dnsResolvers,
    this.name,
    this.roleArn,
    this.securityGroupIds,
    this.subnetIds,
  });

  factory AssetBundleImportJobVPCConnectionOverrideParameters.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobVPCConnectionOverrideParameters(
      vPCConnectionId: json['VPCConnectionId'] as String,
      dnsResolvers: (json['DnsResolvers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      name: json['Name'] as String?,
      roleArn: json['RoleArn'] as String?,
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subnetIds: (json['SubnetIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final vPCConnectionId = this.vPCConnectionId;
    final dnsResolvers = this.dnsResolvers;
    final name = this.name;
    final roleArn = this.roleArn;
    final securityGroupIds = this.securityGroupIds;
    final subnetIds = this.subnetIds;
    return {
      'VPCConnectionId': vPCConnectionId,
      if (dnsResolvers != null) 'DnsResolvers': dnsResolvers,
      if (name != null) 'Name': name,
      if (roleArn != null) 'RoleArn': roleArn,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (subnetIds != null) 'SubnetIds': subnetIds,
    };
  }
}

/// An object that contains a list of tags to be assigned to a list of VPC
/// connection IDs.
class AssetBundleImportJobVPCConnectionOverrideTags {
  /// A list of tags for the VPC connections that you want to apply overrides to.
  final List<Tag> tags;

  /// A list of VPC connection IDs that you want to apply overrides to. You can
  /// use <code>*</code> to override all VPC connections in this asset bundle.
  final List<String> vPCConnectionIds;

  AssetBundleImportJobVPCConnectionOverrideTags({
    required this.tags,
    required this.vPCConnectionIds,
  });

  factory AssetBundleImportJobVPCConnectionOverrideTags.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportJobVPCConnectionOverrideTags(
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
      vPCConnectionIds: (json['VPCConnectionIds'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final tags = this.tags;
    final vPCConnectionIds = this.vPCConnectionIds;
    return {
      'Tags': tags,
      'VPCConnectionIds': vPCConnectionIds,
    };
  }
}

/// Describes a warning that occurred during an Asset Bundle import job.
class AssetBundleImportJobWarning {
  /// The ARN of the resource that the warning occurred for.
  final String? arn;

  /// A description of the warning that occurred during an Asset Bundle import
  /// job.
  final String? message;

  AssetBundleImportJobWarning({
    this.arn,
    this.message,
  });

  factory AssetBundleImportJobWarning.fromJson(Map<String, dynamic> json) {
    return AssetBundleImportJobWarning(
      arn: json['Arn'] as String?,
      message: json['Message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final message = this.message;
    return {
      if (arn != null) 'Arn': arn,
      if (message != null) 'Message': message,
    };
  }
}

/// The source of the asset bundle zip file that contains the data that you want
/// to import. The file must be in <code>QUICKSIGHT_JSON</code> format.
class AssetBundleImportSource {
  /// The bytes of the base64 encoded asset bundle import zip file. This file
  /// can't exceed 20 MB.
  ///
  /// If you are calling the API operations from the Amazon Web Services SDK for
  /// Java, JavaScript, Python, or PHP, the SDK encodes base64 automatically to
  /// allow the direct setting of the zip file's bytes. If you are using an SDK
  /// for a different language or receiving related errors, try to base64 encode
  /// your data.
  final Uint8List? body;

  /// The Amazon S3 URI for an asset bundle import file that exists in an Amazon
  /// S3 bucket that the caller has read access to. The file must be a zip format
  /// file and can't exceed 20 MB.
  final String? s3Uri;

  AssetBundleImportSource({
    this.body,
    this.s3Uri,
  });

  Map<String, dynamic> toJson() {
    final body = this.body;
    final s3Uri = this.s3Uri;
    return {
      if (body != null) 'Body': base64Encode(body),
      if (s3Uri != null) 'S3Uri': s3Uri,
    };
  }
}

/// A description of the import source that you provide at the start of an
/// import job. This value is set to either <code>Body</code> or
/// <code>S3Uri</code>, depending on how the
/// <code>StartAssetBundleImportJobRequest</code> is configured.
class AssetBundleImportSourceDescription {
  /// An HTTPS download URL for the provided asset bundle that you optionally
  /// provided at the start of the import job. This URL is valid for five minutes
  /// after issuance. Call <code>DescribeAssetBundleExportJob</code> again for a
  /// fresh URL if needed. The downloaded asset bundle is a <code>.qs</code> zip
  /// file.
  final String? body;

  /// The Amazon S3 URI that you provided at the start of the import job.
  final String? s3Uri;

  AssetBundleImportSourceDescription({
    this.body,
    this.s3Uri,
  });

  factory AssetBundleImportSourceDescription.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleImportSourceDescription(
      body: json['Body'] as String?,
      s3Uri: json['S3Uri'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final body = this.body;
    final s3Uri = this.s3Uri;
    return {
      if (body != null) 'Body': body,
      if (s3Uri != null) 'S3Uri': s3Uri,
    };
  }
}

/// A structure that contains the configuration of a shared link to an Amazon
/// QuickSight dashboard.
class AssetBundleResourceLinkSharingConfiguration {
  /// A list of link sharing permissions for the dashboards that you want to apply
  /// overrides to.
  final AssetBundleResourcePermissions? permissions;

  AssetBundleResourceLinkSharingConfiguration({
    this.permissions,
  });

  factory AssetBundleResourceLinkSharingConfiguration.fromJson(
      Map<String, dynamic> json) {
    return AssetBundleResourceLinkSharingConfiguration(
      permissions: json['Permissions'] != null
          ? AssetBundleResourcePermissions.fromJson(
              json['Permissions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    return {
      if (permissions != null) 'Permissions': permissions,
    };
  }
}

/// A structure that contains the permissions for the resource that you want to
/// override in an asset bundle import job.
class AssetBundleResourcePermissions {
  /// A list of IAM actions to grant permissions on.
  final List<String> actions;

  /// A list of principals to grant permissions on.
  final List<String> principals;

  AssetBundleResourcePermissions({
    required this.actions,
    required this.principals,
  });

  factory AssetBundleResourcePermissions.fromJson(Map<String, dynamic> json) {
    return AssetBundleResourcePermissions(
      actions: (json['Actions'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      principals: (json['Principals'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final principals = this.principals;
    return {
      'Actions': actions,
      'Principals': principals,
    };
  }
}

/// An array of analysis level configurations.
class AssetOptions {
  /// Determines the timezone for the analysis.
  final String? timezone;

  /// Determines the week start day for an analysis.
  final DayOfTheWeek? weekStart;

  AssetOptions({
    this.timezone,
    this.weekStart,
  });

  factory AssetOptions.fromJson(Map<String, dynamic> json) {
    return AssetOptions(
      timezone: json['Timezone'] as String?,
      weekStart: (json['WeekStart'] as String?)?.toDayOfTheWeek(),
    );
  }

  Map<String, dynamic> toJson() {
    final timezone = this.timezone;
    final weekStart = this.weekStart;
    return {
      if (timezone != null) 'Timezone': timezone,
      if (weekStart != null) 'WeekStart': weekStart.toValue(),
    };
  }
}

enum AssignmentStatus {
  enabled,
  draft,
  disabled,
}

extension AssignmentStatusValueExtension on AssignmentStatus {
  String toValue() {
    switch (this) {
      case AssignmentStatus.enabled:
        return 'ENABLED';
      case AssignmentStatus.draft:
        return 'DRAFT';
      case AssignmentStatus.disabled:
        return 'DISABLED';
    }
  }
}

extension AssignmentStatusFromString on String {
  AssignmentStatus toAssignmentStatus() {
    switch (this) {
      case 'ENABLED':
        return AssignmentStatus.enabled;
      case 'DRAFT':
        return AssignmentStatus.draft;
      case 'DISABLED':
        return AssignmentStatus.disabled;
    }
    throw Exception('$this is not known in enum AssignmentStatus');
  }
}

/// Parameters for Amazon Athena.
class AthenaParameters {
  /// Use the <code>RoleArn</code> structure to override an account-wide role for
  /// a specific Athena data source. For example, say an account administrator has
  /// turned off all Athena access with an account-wide role. The administrator
  /// can then use <code>RoleArn</code> to bypass the account-wide role and allow
  /// Athena access for the single Athena data source that is specified in the
  /// structure, even if the account-wide role forbidding Athena access is still
  /// active.
  final String? roleArn;

  /// The workgroup that Amazon Athena uses.
  final String? workGroup;

  AthenaParameters({
    this.roleArn,
    this.workGroup,
  });

  factory AthenaParameters.fromJson(Map<String, dynamic> json) {
    return AthenaParameters(
      roleArn: json['RoleArn'] as String?,
      workGroup: json['WorkGroup'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final roleArn = this.roleArn;
    final workGroup = this.workGroup;
    return {
      if (roleArn != null) 'RoleArn': roleArn,
      if (workGroup != null) 'WorkGroup': workGroup,
    };
  }
}

/// Aggregation for attributes.
class AttributeAggregationFunction {
  /// The built-in aggregation functions for attributes.
  ///
  /// <ul>
  /// <li>
  /// <code>UNIQUE_VALUE</code>: Returns the unique value for a field, aggregated
  /// by the dimension fields.
  /// </li>
  /// </ul>
  final SimpleAttributeAggregationFunction? simpleAttributeAggregation;

  /// Used by the <code>UNIQUE_VALUE</code> aggregation function. If there are
  /// multiple values for the field used by the aggregation, the value for this
  /// property will be returned instead. Defaults to '*'.
  final String? valueForMultipleValues;

  AttributeAggregationFunction({
    this.simpleAttributeAggregation,
    this.valueForMultipleValues,
  });

  factory AttributeAggregationFunction.fromJson(Map<String, dynamic> json) {
    return AttributeAggregationFunction(
      simpleAttributeAggregation:
          (json['SimpleAttributeAggregation'] as String?)
              ?.toSimpleAttributeAggregationFunction(),
      valueForMultipleValues: json['ValueForMultipleValues'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final simpleAttributeAggregation = this.simpleAttributeAggregation;
    final valueForMultipleValues = this.valueForMultipleValues;
    return {
      if (simpleAttributeAggregation != null)
        'SimpleAttributeAggregation': simpleAttributeAggregation.toValue(),
      if (valueForMultipleValues != null)
        'ValueForMultipleValues': valueForMultipleValues,
    };
  }
}

/// Parameters for Amazon Aurora.
class AuroraParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Port.
  final int port;

  AuroraParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory AuroraParameters.fromJson(Map<String, dynamic> json) {
    return AuroraParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

/// Parameters for Amazon Aurora PostgreSQL-Compatible Edition.
class AuroraPostgreSqlParameters {
  /// The Amazon Aurora PostgreSQL database to connect to.
  final String database;

  /// The Amazon Aurora PostgreSQL-Compatible host to connect to.
  final String host;

  /// The port that Amazon Aurora PostgreSQL is listening on.
  final int port;

  AuroraPostgreSqlParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory AuroraPostgreSqlParameters.fromJson(Map<String, dynamic> json) {
    return AuroraPostgreSqlParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

enum AuthenticationMethodOption {
  iamAndQuicksight,
  iamOnly,
  activeDirectory,
  iamIdentityCenter,
}

extension AuthenticationMethodOptionValueExtension
    on AuthenticationMethodOption {
  String toValue() {
    switch (this) {
      case AuthenticationMethodOption.iamAndQuicksight:
        return 'IAM_AND_QUICKSIGHT';
      case AuthenticationMethodOption.iamOnly:
        return 'IAM_ONLY';
      case AuthenticationMethodOption.activeDirectory:
        return 'ACTIVE_DIRECTORY';
      case AuthenticationMethodOption.iamIdentityCenter:
        return 'IAM_IDENTITY_CENTER';
    }
  }
}

extension AuthenticationMethodOptionFromString on String {
  AuthenticationMethodOption toAuthenticationMethodOption() {
    switch (this) {
      case 'IAM_AND_QUICKSIGHT':
        return AuthenticationMethodOption.iamAndQuicksight;
      case 'IAM_ONLY':
        return AuthenticationMethodOption.iamOnly;
      case 'ACTIVE_DIRECTORY':
        return AuthenticationMethodOption.activeDirectory;
      case 'IAM_IDENTITY_CENTER':
        return AuthenticationMethodOption.iamIdentityCenter;
    }
    throw Exception('$this is not known in enum AuthenticationMethodOption');
  }
}

enum AuthorSpecifiedAggregation {
  count,
  distinctCount,
  min,
  max,
  median,
  sum,
  average,
  stdev,
  stdevp,
  $var,
  varp,
  percentile,
}

extension AuthorSpecifiedAggregationValueExtension
    on AuthorSpecifiedAggregation {
  String toValue() {
    switch (this) {
      case AuthorSpecifiedAggregation.count:
        return 'COUNT';
      case AuthorSpecifiedAggregation.distinctCount:
        return 'DISTINCT_COUNT';
      case AuthorSpecifiedAggregation.min:
        return 'MIN';
      case AuthorSpecifiedAggregation.max:
        return 'MAX';
      case AuthorSpecifiedAggregation.median:
        return 'MEDIAN';
      case AuthorSpecifiedAggregation.sum:
        return 'SUM';
      case AuthorSpecifiedAggregation.average:
        return 'AVERAGE';
      case AuthorSpecifiedAggregation.stdev:
        return 'STDEV';
      case AuthorSpecifiedAggregation.stdevp:
        return 'STDEVP';
      case AuthorSpecifiedAggregation.$var:
        return 'VAR';
      case AuthorSpecifiedAggregation.varp:
        return 'VARP';
      case AuthorSpecifiedAggregation.percentile:
        return 'PERCENTILE';
    }
  }
}

extension AuthorSpecifiedAggregationFromString on String {
  AuthorSpecifiedAggregation toAuthorSpecifiedAggregation() {
    switch (this) {
      case 'COUNT':
        return AuthorSpecifiedAggregation.count;
      case 'DISTINCT_COUNT':
        return AuthorSpecifiedAggregation.distinctCount;
      case 'MIN':
        return AuthorSpecifiedAggregation.min;
      case 'MAX':
        return AuthorSpecifiedAggregation.max;
      case 'MEDIAN':
        return AuthorSpecifiedAggregation.median;
      case 'SUM':
        return AuthorSpecifiedAggregation.sum;
      case 'AVERAGE':
        return AuthorSpecifiedAggregation.average;
      case 'STDEV':
        return AuthorSpecifiedAggregation.stdev;
      case 'STDEVP':
        return AuthorSpecifiedAggregation.stdevp;
      case 'VAR':
        return AuthorSpecifiedAggregation.$var;
      case 'VARP':
        return AuthorSpecifiedAggregation.varp;
      case 'PERCENTILE':
        return AuthorSpecifiedAggregation.percentile;
    }
    throw Exception('$this is not known in enum AuthorSpecifiedAggregation');
  }
}

/// The authorized targets that are associated with a service.
class AuthorizedTargetsByService {
  /// Aist of authorized targets that are represented by IAM Identity Center
  /// application ARNs.
  final List<String>? authorizedTargets;

  /// The name of the Amazon Web Services service.
  final ServiceType? service;

  AuthorizedTargetsByService({
    this.authorizedTargets,
    this.service,
  });

  factory AuthorizedTargetsByService.fromJson(Map<String, dynamic> json) {
    return AuthorizedTargetsByService(
      authorizedTargets: (json['AuthorizedTargets'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      service: (json['Service'] as String?)?.toServiceType(),
    );
  }

  Map<String, dynamic> toJson() {
    final authorizedTargets = this.authorizedTargets;
    final service = this.service;
    return {
      if (authorizedTargets != null) 'AuthorizedTargets': authorizedTargets,
      if (service != null) 'Service': service.toValue(),
    };
  }
}

/// The parameters for IoT Analytics.
class AwsIotAnalyticsParameters {
  /// Dataset name.
  final String dataSetName;

  AwsIotAnalyticsParameters({
    required this.dataSetName,
  });

  factory AwsIotAnalyticsParameters.fromJson(Map<String, dynamic> json) {
    return AwsIotAnalyticsParameters(
      dataSetName: json['DataSetName'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetName = this.dataSetName;
    return {
      'DataSetName': dataSetName,
    };
  }
}

enum AxisBinding {
  primaryYaxis,
  secondaryYaxis,
}

extension AxisBindingValueExtension on AxisBinding {
  String toValue() {
    switch (this) {
      case AxisBinding.primaryYaxis:
        return 'PRIMARY_YAXIS';
      case AxisBinding.secondaryYaxis:
        return 'SECONDARY_YAXIS';
    }
  }
}

extension AxisBindingFromString on String {
  AxisBinding toAxisBinding() {
    switch (this) {
      case 'PRIMARY_YAXIS':
        return AxisBinding.primaryYaxis;
      case 'SECONDARY_YAXIS':
        return AxisBinding.secondaryYaxis;
    }
    throw Exception('$this is not known in enum AxisBinding');
  }
}

/// The data options for an axis.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class AxisDataOptions {
  /// The options for an axis with a date field.
  final DateAxisOptions? dateAxisOptions;

  /// The options for an axis with a numeric field.
  final NumericAxisOptions? numericAxisOptions;

  AxisDataOptions({
    this.dateAxisOptions,
    this.numericAxisOptions,
  });

  factory AxisDataOptions.fromJson(Map<String, dynamic> json) {
    return AxisDataOptions(
      dateAxisOptions: json['DateAxisOptions'] != null
          ? DateAxisOptions.fromJson(
              json['DateAxisOptions'] as Map<String, dynamic>)
          : null,
      numericAxisOptions: json['NumericAxisOptions'] != null
          ? NumericAxisOptions.fromJson(
              json['NumericAxisOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateAxisOptions = this.dateAxisOptions;
    final numericAxisOptions = this.numericAxisOptions;
    return {
      if (dateAxisOptions != null) 'DateAxisOptions': dateAxisOptions,
      if (numericAxisOptions != null) 'NumericAxisOptions': numericAxisOptions,
    };
  }
}

/// The options that are saved for future extension.
class AxisDisplayDataDrivenRange {
  AxisDisplayDataDrivenRange();

  factory AxisDisplayDataDrivenRange.fromJson(Map<String, dynamic> _) {
    return AxisDisplayDataDrivenRange();
  }

  Map<String, dynamic> toJson() {
    return {};
  }
}

/// The minimum and maximum setup for an axis display range.
class AxisDisplayMinMaxRange {
  /// The maximum setup for an axis display range.
  final double? maximum;

  /// The minimum setup for an axis display range.
  final double? minimum;

  AxisDisplayMinMaxRange({
    this.maximum,
    this.minimum,
  });

  factory AxisDisplayMinMaxRange.fromJson(Map<String, dynamic> json) {
    return AxisDisplayMinMaxRange(
      maximum: json['Maximum'] as double?,
      minimum: json['Minimum'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final maximum = this.maximum;
    final minimum = this.minimum;
    return {
      if (maximum != null) 'Maximum': maximum,
      if (minimum != null) 'Minimum': minimum,
    };
  }
}

/// The display options for the axis label.
class AxisDisplayOptions {
  /// Determines whether or not the axis line is visible.
  final Visibility? axisLineVisibility;

  /// The offset value that determines the starting placement of the axis within a
  /// visual's bounds.
  final String? axisOffset;

  /// The data options for an axis.
  final AxisDataOptions? dataOptions;

  /// Determines whether or not the grid line is visible.
  final Visibility? gridLineVisibility;

  /// The scroll bar options for an axis.
  final ScrollBarOptions? scrollbarOptions;

  /// The tick label options of an axis.
  final AxisTickLabelOptions? tickLabelOptions;

  AxisDisplayOptions({
    this.axisLineVisibility,
    this.axisOffset,
    this.dataOptions,
    this.gridLineVisibility,
    this.scrollbarOptions,
    this.tickLabelOptions,
  });

  factory AxisDisplayOptions.fromJson(Map<String, dynamic> json) {
    return AxisDisplayOptions(
      axisLineVisibility:
          (json['AxisLineVisibility'] as String?)?.toVisibility(),
      axisOffset: json['AxisOffset'] as String?,
      dataOptions: json['DataOptions'] != null
          ? AxisDataOptions.fromJson(
              json['DataOptions'] as Map<String, dynamic>)
          : null,
      gridLineVisibility:
          (json['GridLineVisibility'] as String?)?.toVisibility(),
      scrollbarOptions: json['ScrollbarOptions'] != null
          ? ScrollBarOptions.fromJson(
              json['ScrollbarOptions'] as Map<String, dynamic>)
          : null,
      tickLabelOptions: json['TickLabelOptions'] != null
          ? AxisTickLabelOptions.fromJson(
              json['TickLabelOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final axisLineVisibility = this.axisLineVisibility;
    final axisOffset = this.axisOffset;
    final dataOptions = this.dataOptions;
    final gridLineVisibility = this.gridLineVisibility;
    final scrollbarOptions = this.scrollbarOptions;
    final tickLabelOptions = this.tickLabelOptions;
    return {
      if (axisLineVisibility != null)
        'AxisLineVisibility': axisLineVisibility.toValue(),
      if (axisOffset != null) 'AxisOffset': axisOffset,
      if (dataOptions != null) 'DataOptions': dataOptions,
      if (gridLineVisibility != null)
        'GridLineVisibility': gridLineVisibility.toValue(),
      if (scrollbarOptions != null) 'ScrollbarOptions': scrollbarOptions,
      if (tickLabelOptions != null) 'TickLabelOptions': tickLabelOptions,
    };
  }
}

/// The range setup of a numeric axis display range.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class AxisDisplayRange {
  /// The data-driven setup of an axis display range.
  final AxisDisplayDataDrivenRange? dataDriven;

  /// The minimum and maximum setup of an axis display range.
  final AxisDisplayMinMaxRange? minMax;

  AxisDisplayRange({
    this.dataDriven,
    this.minMax,
  });

  factory AxisDisplayRange.fromJson(Map<String, dynamic> json) {
    return AxisDisplayRange(
      dataDriven: json['DataDriven'] != null
          ? AxisDisplayDataDrivenRange.fromJson(
              json['DataDriven'] as Map<String, dynamic>)
          : null,
      minMax: json['MinMax'] != null
          ? AxisDisplayMinMaxRange.fromJson(
              json['MinMax'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataDriven = this.dataDriven;
    final minMax = this.minMax;
    return {
      if (dataDriven != null) 'DataDriven': dataDriven,
      if (minMax != null) 'MinMax': minMax,
    };
  }
}

/// The label options for a chart axis. You must specify the field that the
/// label is targeted to.
class AxisLabelOptions {
  /// The options that indicate which field the label belongs to.
  final AxisLabelReferenceOptions? applyTo;

  /// The text for the axis label.
  final String? customLabel;

  /// The font configuration of the axis label.
  final FontConfiguration? fontConfiguration;

  AxisLabelOptions({
    this.applyTo,
    this.customLabel,
    this.fontConfiguration,
  });

  factory AxisLabelOptions.fromJson(Map<String, dynamic> json) {
    return AxisLabelOptions(
      applyTo: json['ApplyTo'] != null
          ? AxisLabelReferenceOptions.fromJson(
              json['ApplyTo'] as Map<String, dynamic>)
          : null,
      customLabel: json['CustomLabel'] as String?,
      fontConfiguration: json['FontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['FontConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final applyTo = this.applyTo;
    final customLabel = this.customLabel;
    final fontConfiguration = this.fontConfiguration;
    return {
      if (applyTo != null) 'ApplyTo': applyTo,
      if (customLabel != null) 'CustomLabel': customLabel,
      if (fontConfiguration != null) 'FontConfiguration': fontConfiguration,
    };
  }
}

/// The reference that specifies where the axis label is applied to.
class AxisLabelReferenceOptions {
  /// The column that the axis label is targeted to.
  final ColumnIdentifier column;

  /// The field that the axis label is targeted to.
  final String fieldId;

  AxisLabelReferenceOptions({
    required this.column,
    required this.fieldId,
  });

  factory AxisLabelReferenceOptions.fromJson(Map<String, dynamic> json) {
    return AxisLabelReferenceOptions(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    return {
      'Column': column,
      'FieldId': fieldId,
    };
  }
}

/// The liner axis scale setup.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class AxisLinearScale {
  /// The step count setup of a linear axis.
  final int? stepCount;

  /// The step size setup of a linear axis.
  final double? stepSize;

  AxisLinearScale({
    this.stepCount,
    this.stepSize,
  });

  factory AxisLinearScale.fromJson(Map<String, dynamic> json) {
    return AxisLinearScale(
      stepCount: json['StepCount'] as int?,
      stepSize: json['StepSize'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final stepCount = this.stepCount;
    final stepSize = this.stepSize;
    return {
      if (stepCount != null) 'StepCount': stepCount,
      if (stepSize != null) 'StepSize': stepSize,
    };
  }
}

/// The logarithmic axis scale setup.
class AxisLogarithmicScale {
  /// The base setup of a logarithmic axis scale.
  final double? base;

  AxisLogarithmicScale({
    this.base,
  });

  factory AxisLogarithmicScale.fromJson(Map<String, dynamic> json) {
    return AxisLogarithmicScale(
      base: json['Base'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final base = this.base;
    return {
      if (base != null) 'Base': base,
    };
  }
}

/// The scale setup options for a numeric axis display.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class AxisScale {
  /// The linear axis scale setup.
  final AxisLinearScale? linear;

  /// The logarithmic axis scale setup.
  final AxisLogarithmicScale? logarithmic;

  AxisScale({
    this.linear,
    this.logarithmic,
  });

  factory AxisScale.fromJson(Map<String, dynamic> json) {
    return AxisScale(
      linear: json['Linear'] != null
          ? AxisLinearScale.fromJson(json['Linear'] as Map<String, dynamic>)
          : null,
      logarithmic: json['Logarithmic'] != null
          ? AxisLogarithmicScale.fromJson(
              json['Logarithmic'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final linear = this.linear;
    final logarithmic = this.logarithmic;
    return {
      if (linear != null) 'Linear': linear,
      if (logarithmic != null) 'Logarithmic': logarithmic,
    };
  }
}

/// The tick label options of an axis.
class AxisTickLabelOptions {
  /// Determines whether or not the axis ticks are visible.
  final LabelOptions? labelOptions;

  /// The rotation angle of the axis tick labels.
  final double? rotationAngle;

  AxisTickLabelOptions({
    this.labelOptions,
    this.rotationAngle,
  });

  factory AxisTickLabelOptions.fromJson(Map<String, dynamic> json) {
    return AxisTickLabelOptions(
      labelOptions: json['LabelOptions'] != null
          ? LabelOptions.fromJson(json['LabelOptions'] as Map<String, dynamic>)
          : null,
      rotationAngle: json['RotationAngle'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final labelOptions = this.labelOptions;
    final rotationAngle = this.rotationAngle;
    return {
      if (labelOptions != null) 'LabelOptions': labelOptions,
      if (rotationAngle != null) 'RotationAngle': rotationAngle,
    };
  }
}

/// The aggregated field wells of a bar chart.
class BarChartAggregatedFieldWells {
  /// The category (y-axis) field well of a bar chart.
  final List<DimensionField>? category;

  /// The color (group/color) field well of a bar chart.
  final List<DimensionField>? colors;

  /// The small multiples field well of a bar chart.
  final List<DimensionField>? smallMultiples;

  /// The value field wells of a bar chart. Values are aggregated by category.
  final List<MeasureField>? values;

  BarChartAggregatedFieldWells({
    this.category,
    this.colors,
    this.smallMultiples,
    this.values,
  });

  factory BarChartAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return BarChartAggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      smallMultiples: (json['SmallMultiples'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final colors = this.colors;
    final smallMultiples = this.smallMultiples;
    final values = this.values;
    return {
      if (category != null) 'Category': category,
      if (colors != null) 'Colors': colors,
      if (smallMultiples != null) 'SmallMultiples': smallMultiples,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a <code>BarChartVisual</code>.
class BarChartConfiguration {
  /// Determines the arrangement of the bars. The orientation and arrangement of
  /// bars determine the type of bar that is used in the visual.
  final BarsArrangement? barsArrangement;

  /// The label display options (grid line, range, scale, axis step) for bar chart
  /// category.
  final AxisDisplayOptions? categoryAxis;

  /// The label options (label text, label visibility and sort icon visibility)
  /// for a bar chart.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The label options (label text, label visibility and sort icon visibility)
  /// for a color that is used in a bar chart.
  final ChartAxisLabelOptions? colorLabelOptions;

  /// The contribution analysis (anomaly configuration) setup of the visual.
  final List<ContributionAnalysisDefault>? contributionAnalysisDefaults;

  /// The options that determine if visual data labels are displayed.
  final DataLabelOptions? dataLabels;

  /// The field wells of the visual.
  final BarChartFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The orientation of the bars in a bar chart visual. There are two valid
  /// values in this structure:
  ///
  /// <ul>
  /// <li>
  /// <code>HORIZONTAL</code>: Used for charts that have horizontal bars. Visuals
  /// that use this value are horizontal bar charts, horizontal stacked bar
  /// charts, and horizontal stacked 100% bar charts.
  /// </li>
  /// <li>
  /// <code>VERTICAL</code>: Used for charts that have vertical bars. Visuals that
  /// use this value are vertical bar charts, vertical stacked bar charts, and
  /// vertical stacked 100% bar charts.
  /// </li>
  /// </ul>
  final BarChartOrientation? orientation;

  /// The reference line setup of the visual.
  final List<ReferenceLine>? referenceLines;

  /// The small multiples setup for the visual.
  final SmallMultiplesOptions? smallMultiplesOptions;

  /// The sort configuration of a <code>BarChartVisual</code>.
  final BarChartSortConfiguration? sortConfiguration;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;

  /// The label display options (grid line, range, scale, axis step) for a bar
  /// chart value.
  final AxisDisplayOptions? valueAxis;

  /// The label options (label text, label visibility and sort icon visibility)
  /// for a bar chart value.
  final ChartAxisLabelOptions? valueLabelOptions;

  /// The palette (chart color) display setup of the visual.
  final VisualPalette? visualPalette;

  BarChartConfiguration({
    this.barsArrangement,
    this.categoryAxis,
    this.categoryLabelOptions,
    this.colorLabelOptions,
    this.contributionAnalysisDefaults,
    this.dataLabels,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.orientation,
    this.referenceLines,
    this.smallMultiplesOptions,
    this.sortConfiguration,
    this.tooltip,
    this.valueAxis,
    this.valueLabelOptions,
    this.visualPalette,
  });

  factory BarChartConfiguration.fromJson(Map<String, dynamic> json) {
    return BarChartConfiguration(
      barsArrangement:
          (json['BarsArrangement'] as String?)?.toBarsArrangement(),
      categoryAxis: json['CategoryAxis'] != null
          ? AxisDisplayOptions.fromJson(
              json['CategoryAxis'] as Map<String, dynamic>)
          : null,
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      colorLabelOptions: json['ColorLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ColorLabelOptions'] as Map<String, dynamic>)
          : null,
      contributionAnalysisDefaults: (json['ContributionAnalysisDefaults']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              ContributionAnalysisDefault.fromJson(e as Map<String, dynamic>))
          .toList(),
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? BarChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      orientation: (json['Orientation'] as String?)?.toBarChartOrientation(),
      referenceLines: (json['ReferenceLines'] as List?)
          ?.whereNotNull()
          .map((e) => ReferenceLine.fromJson(e as Map<String, dynamic>))
          .toList(),
      smallMultiplesOptions: json['SmallMultiplesOptions'] != null
          ? SmallMultiplesOptions.fromJson(
              json['SmallMultiplesOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? BarChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      valueAxis: json['ValueAxis'] != null
          ? AxisDisplayOptions.fromJson(
              json['ValueAxis'] as Map<String, dynamic>)
          : null,
      valueLabelOptions: json['ValueLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ValueLabelOptions'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final barsArrangement = this.barsArrangement;
    final categoryAxis = this.categoryAxis;
    final categoryLabelOptions = this.categoryLabelOptions;
    final colorLabelOptions = this.colorLabelOptions;
    final contributionAnalysisDefaults = this.contributionAnalysisDefaults;
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final orientation = this.orientation;
    final referenceLines = this.referenceLines;
    final smallMultiplesOptions = this.smallMultiplesOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final valueAxis = this.valueAxis;
    final valueLabelOptions = this.valueLabelOptions;
    final visualPalette = this.visualPalette;
    return {
      if (barsArrangement != null) 'BarsArrangement': barsArrangement.toValue(),
      if (categoryAxis != null) 'CategoryAxis': categoryAxis,
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (colorLabelOptions != null) 'ColorLabelOptions': colorLabelOptions,
      if (contributionAnalysisDefaults != null)
        'ContributionAnalysisDefaults': contributionAnalysisDefaults,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (orientation != null) 'Orientation': orientation.toValue(),
      if (referenceLines != null) 'ReferenceLines': referenceLines,
      if (smallMultiplesOptions != null)
        'SmallMultiplesOptions': smallMultiplesOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (valueAxis != null) 'ValueAxis': valueAxis,
      if (valueLabelOptions != null) 'ValueLabelOptions': valueLabelOptions,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The field wells of a <code>BarChartVisual</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class BarChartFieldWells {
  /// The aggregated field wells of a bar chart.
  final BarChartAggregatedFieldWells? barChartAggregatedFieldWells;

  BarChartFieldWells({
    this.barChartAggregatedFieldWells,
  });

  factory BarChartFieldWells.fromJson(Map<String, dynamic> json) {
    return BarChartFieldWells(
      barChartAggregatedFieldWells: json['BarChartAggregatedFieldWells'] != null
          ? BarChartAggregatedFieldWells.fromJson(
              json['BarChartAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final barChartAggregatedFieldWells = this.barChartAggregatedFieldWells;
    return {
      if (barChartAggregatedFieldWells != null)
        'BarChartAggregatedFieldWells': barChartAggregatedFieldWells,
    };
  }
}

enum BarChartOrientation {
  horizontal,
  vertical,
}

extension BarChartOrientationValueExtension on BarChartOrientation {
  String toValue() {
    switch (this) {
      case BarChartOrientation.horizontal:
        return 'HORIZONTAL';
      case BarChartOrientation.vertical:
        return 'VERTICAL';
    }
  }
}

extension BarChartOrientationFromString on String {
  BarChartOrientation toBarChartOrientation() {
    switch (this) {
      case 'HORIZONTAL':
        return BarChartOrientation.horizontal;
      case 'VERTICAL':
        return BarChartOrientation.vertical;
    }
    throw Exception('$this is not known in enum BarChartOrientation');
  }
}

/// sort-configuration-description
class BarChartSortConfiguration {
  /// The limit on the number of categories displayed in a bar chart.
  final ItemsLimitConfiguration? categoryItemsLimit;

  /// The sort configuration of category fields.
  final List<FieldSortOptions>? categorySort;

  /// The limit on the number of values displayed in a bar chart.
  final ItemsLimitConfiguration? colorItemsLimit;

  /// The sort configuration of color fields in a bar chart.
  final List<FieldSortOptions>? colorSort;

  /// The limit on the number of small multiples panels that are displayed.
  final ItemsLimitConfiguration? smallMultiplesLimitConfiguration;

  /// The sort configuration of the small multiples field.
  final List<FieldSortOptions>? smallMultiplesSort;

  BarChartSortConfiguration({
    this.categoryItemsLimit,
    this.categorySort,
    this.colorItemsLimit,
    this.colorSort,
    this.smallMultiplesLimitConfiguration,
    this.smallMultiplesSort,
  });

  factory BarChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return BarChartSortConfiguration(
      categoryItemsLimit: json['CategoryItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['CategoryItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      colorItemsLimit: json['ColorItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['ColorItemsLimit'] as Map<String, dynamic>)
          : null,
      colorSort: (json['ColorSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      smallMultiplesLimitConfiguration:
          json['SmallMultiplesLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['SmallMultiplesLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      smallMultiplesSort: (json['SmallMultiplesSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimit = this.categoryItemsLimit;
    final categorySort = this.categorySort;
    final colorItemsLimit = this.colorItemsLimit;
    final colorSort = this.colorSort;
    final smallMultiplesLimitConfiguration =
        this.smallMultiplesLimitConfiguration;
    final smallMultiplesSort = this.smallMultiplesSort;
    return {
      if (categoryItemsLimit != null) 'CategoryItemsLimit': categoryItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
      if (colorItemsLimit != null) 'ColorItemsLimit': colorItemsLimit,
      if (colorSort != null) 'ColorSort': colorSort,
      if (smallMultiplesLimitConfiguration != null)
        'SmallMultiplesLimitConfiguration': smallMultiplesLimitConfiguration,
      if (smallMultiplesSort != null) 'SmallMultiplesSort': smallMultiplesSort,
    };
  }
}

/// A bar chart.
///
/// The <code>BarChartVisual</code> structure describes a visual that is a
/// member of the bar chart family. The following charts can be described using
/// this structure:
///
/// <ul>
/// <li>
/// Horizontal bar chart
/// </li>
/// <li>
/// Vertical bar chart
/// </li>
/// <li>
/// Horizontal stacked bar chart
/// </li>
/// <li>
/// Vertical stacked bar chart
/// </li>
/// <li>
/// Horizontal stacked 100% bar chart
/// </li>
/// <li>
/// Vertical stacked 100% bar chart
/// </li>
/// </ul>
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using
/// bar charts</a> in the <i>Amazon QuickSight User Guide</i>.
class BarChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final BarChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  BarChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory BarChartVisual.fromJson(Map<String, dynamic> json) {
    return BarChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? BarChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

enum BarsArrangement {
  clustered,
  stacked,
  stackedPercent,
}

extension BarsArrangementValueExtension on BarsArrangement {
  String toValue() {
    switch (this) {
      case BarsArrangement.clustered:
        return 'CLUSTERED';
      case BarsArrangement.stacked:
        return 'STACKED';
      case BarsArrangement.stackedPercent:
        return 'STACKED_PERCENT';
    }
  }
}

extension BarsArrangementFromString on String {
  BarsArrangement toBarsArrangement() {
    switch (this) {
      case 'CLUSTERED':
        return BarsArrangement.clustered;
      case 'STACKED':
        return BarsArrangement.stacked;
      case 'STACKED_PERCENT':
        return BarsArrangement.stackedPercent;
    }
    throw Exception('$this is not known in enum BarsArrangement');
  }
}

enum BaseMapStyleType {
  lightGray,
  darkGray,
  street,
  imagery,
}

extension BaseMapStyleTypeValueExtension on BaseMapStyleType {
  String toValue() {
    switch (this) {
      case BaseMapStyleType.lightGray:
        return 'LIGHT_GRAY';
      case BaseMapStyleType.darkGray:
        return 'DARK_GRAY';
      case BaseMapStyleType.street:
        return 'STREET';
      case BaseMapStyleType.imagery:
        return 'IMAGERY';
    }
  }
}

extension BaseMapStyleTypeFromString on String {
  BaseMapStyleType toBaseMapStyleType() {
    switch (this) {
      case 'LIGHT_GRAY':
        return BaseMapStyleType.lightGray;
      case 'DARK_GRAY':
        return BaseMapStyleType.darkGray;
      case 'STREET':
        return BaseMapStyleType.street;
      case 'IMAGERY':
        return BaseMapStyleType.imagery;
    }
    throw Exception('$this is not known in enum BaseMapStyleType');
  }
}

/// The parameters that are required to connect to a Google BigQuery data
/// source.
class BigQueryParameters {
  /// The Google Cloud Platform project ID where your datasource was created.
  final String projectId;

  /// The storage location where you create a Google BigQuery data source.
  final String? dataSetRegion;

  BigQueryParameters({
    required this.projectId,
    this.dataSetRegion,
  });

  factory BigQueryParameters.fromJson(Map<String, dynamic> json) {
    return BigQueryParameters(
      projectId: json['ProjectId'] as String,
      dataSetRegion: json['DataSetRegion'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final projectId = this.projectId;
    final dataSetRegion = this.dataSetRegion;
    return {
      'ProjectId': projectId,
      if (dataSetRegion != null) 'DataSetRegion': dataSetRegion,
    };
  }
}

/// The options that determine the bin count of a histogram.
class BinCountOptions {
  /// The options that determine the bin count value.
  final int? value;

  BinCountOptions({
    this.value,
  });

  factory BinCountOptions.fromJson(Map<String, dynamic> json) {
    return BinCountOptions(
      value: json['Value'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      if (value != null) 'Value': value,
    };
  }
}

/// The options that determine the bin width of a histogram.
class BinWidthOptions {
  /// The options that determine the bin count limit.
  final int? binCountLimit;

  /// The options that determine the bin width value.
  final double? value;

  BinWidthOptions({
    this.binCountLimit,
    this.value,
  });

  factory BinWidthOptions.fromJson(Map<String, dynamic> json) {
    return BinWidthOptions(
      binCountLimit: json['BinCountLimit'] as int?,
      value: json['Value'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final binCountLimit = this.binCountLimit;
    final value = this.value;
    return {
      if (binCountLimit != null) 'BinCountLimit': binCountLimit,
      if (value != null) 'Value': value,
    };
  }
}

/// The configuration of a body section.
class BodySectionConfiguration {
  /// The configuration of content in a body section.
  final BodySectionContent content;

  /// The unique identifier of a body section.
  final String sectionId;

  /// The configuration of a page break for a section.
  final SectionPageBreakConfiguration? pageBreakConfiguration;

  /// The style options of a body section.
  final SectionStyle? style;

  BodySectionConfiguration({
    required this.content,
    required this.sectionId,
    this.pageBreakConfiguration,
    this.style,
  });

  factory BodySectionConfiguration.fromJson(Map<String, dynamic> json) {
    return BodySectionConfiguration(
      content:
          BodySectionContent.fromJson(json['Content'] as Map<String, dynamic>),
      sectionId: json['SectionId'] as String,
      pageBreakConfiguration: json['PageBreakConfiguration'] != null
          ? SectionPageBreakConfiguration.fromJson(
              json['PageBreakConfiguration'] as Map<String, dynamic>)
          : null,
      style: json['Style'] != null
          ? SectionStyle.fromJson(json['Style'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final content = this.content;
    final sectionId = this.sectionId;
    final pageBreakConfiguration = this.pageBreakConfiguration;
    final style = this.style;
    return {
      'Content': content,
      'SectionId': sectionId,
      if (pageBreakConfiguration != null)
        'PageBreakConfiguration': pageBreakConfiguration,
      if (style != null) 'Style': style,
    };
  }
}

/// The configuration of content in a body section.
class BodySectionContent {
  /// The layout configuration of a body section.
  final SectionLayoutConfiguration? layout;

  BodySectionContent({
    this.layout,
  });

  factory BodySectionContent.fromJson(Map<String, dynamic> json) {
    return BodySectionContent(
      layout: json['Layout'] != null
          ? SectionLayoutConfiguration.fromJson(
              json['Layout'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final layout = this.layout;
    return {
      if (layout != null) 'Layout': layout,
    };
  }
}

/// The bookmarks configuration of an embedded dashboard.
class BookmarksConfigurations {
  /// A Boolean value that determines whether a user can bookmark an embedded
  /// dashboard.
  final bool enabled;

  BookmarksConfigurations({
    required this.enabled,
  });

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      'Enabled': enabled,
    };
  }
}

/// The display options for tile borders for visuals.
class BorderStyle {
  /// The option to enable display of borders for visuals.
  final bool? show;

  BorderStyle({
    this.show,
  });

  factory BorderStyle.fromJson(Map<String, dynamic> json) {
    return BorderStyle(
      show: json['Show'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final show = this.show;
    return {
      if (show != null) 'Show': show,
    };
  }
}

/// The aggregated field well for a box plot.
class BoxPlotAggregatedFieldWells {
  /// The group by field well of a box plot chart. Values are grouped based on
  /// group by fields.
  final List<DimensionField>? groupBy;

  /// The value field well of a box plot chart. Values are aggregated based on
  /// group by fields.
  final List<MeasureField>? values;

  BoxPlotAggregatedFieldWells({
    this.groupBy,
    this.values,
  });

  factory BoxPlotAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return BoxPlotAggregatedFieldWells(
      groupBy: (json['GroupBy'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final groupBy = this.groupBy;
    final values = this.values;
    return {
      if (groupBy != null) 'GroupBy': groupBy,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a <code>BoxPlotVisual</code>.
class BoxPlotChartConfiguration {
  /// The box plot chart options for a box plot visual
  final BoxPlotOptions? boxPlotOptions;

  /// The label display options (grid line, range, scale, axis step) of a box plot
  /// category.
  final AxisDisplayOptions? categoryAxis;

  /// The label options (label text, label visibility and sort Icon visibility) of
  /// a box plot category.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The field wells of the visual.
  final BoxPlotFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;
  final LegendOptions? legend;

  /// The label display options (grid line, range, scale, axis step) of a box plot
  /// category.
  final AxisDisplayOptions? primaryYAxisDisplayOptions;

  /// The label options (label text, label visibility and sort icon visibility) of
  /// a box plot value.
  final ChartAxisLabelOptions? primaryYAxisLabelOptions;

  /// The reference line setup of the visual.
  final List<ReferenceLine>? referenceLines;

  /// The sort configuration of a <code>BoxPlotVisual</code>.
  final BoxPlotSortConfiguration? sortConfiguration;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;

  /// The palette (chart color) display setup of the visual.
  final VisualPalette? visualPalette;

  BoxPlotChartConfiguration({
    this.boxPlotOptions,
    this.categoryAxis,
    this.categoryLabelOptions,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.primaryYAxisDisplayOptions,
    this.primaryYAxisLabelOptions,
    this.referenceLines,
    this.sortConfiguration,
    this.tooltip,
    this.visualPalette,
  });

  factory BoxPlotChartConfiguration.fromJson(Map<String, dynamic> json) {
    return BoxPlotChartConfiguration(
      boxPlotOptions: json['BoxPlotOptions'] != null
          ? BoxPlotOptions.fromJson(
              json['BoxPlotOptions'] as Map<String, dynamic>)
          : null,
      categoryAxis: json['CategoryAxis'] != null
          ? AxisDisplayOptions.fromJson(
              json['CategoryAxis'] as Map<String, dynamic>)
          : null,
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? BoxPlotFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      primaryYAxisDisplayOptions: json['PrimaryYAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['PrimaryYAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      primaryYAxisLabelOptions: json['PrimaryYAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['PrimaryYAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      referenceLines: (json['ReferenceLines'] as List?)
          ?.whereNotNull()
          .map((e) => ReferenceLine.fromJson(e as Map<String, dynamic>))
          .toList(),
      sortConfiguration: json['SortConfiguration'] != null
          ? BoxPlotSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final boxPlotOptions = this.boxPlotOptions;
    final categoryAxis = this.categoryAxis;
    final categoryLabelOptions = this.categoryLabelOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final primaryYAxisDisplayOptions = this.primaryYAxisDisplayOptions;
    final primaryYAxisLabelOptions = this.primaryYAxisLabelOptions;
    final referenceLines = this.referenceLines;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final visualPalette = this.visualPalette;
    return {
      if (boxPlotOptions != null) 'BoxPlotOptions': boxPlotOptions,
      if (categoryAxis != null) 'CategoryAxis': categoryAxis,
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (primaryYAxisDisplayOptions != null)
        'PrimaryYAxisDisplayOptions': primaryYAxisDisplayOptions,
      if (primaryYAxisLabelOptions != null)
        'PrimaryYAxisLabelOptions': primaryYAxisLabelOptions,
      if (referenceLines != null) 'ReferenceLines': referenceLines,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The field wells of a <code>BoxPlotVisual</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class BoxPlotFieldWells {
  /// The aggregated field wells of a box plot.
  final BoxPlotAggregatedFieldWells? boxPlotAggregatedFieldWells;

  BoxPlotFieldWells({
    this.boxPlotAggregatedFieldWells,
  });

  factory BoxPlotFieldWells.fromJson(Map<String, dynamic> json) {
    return BoxPlotFieldWells(
      boxPlotAggregatedFieldWells: json['BoxPlotAggregatedFieldWells'] != null
          ? BoxPlotAggregatedFieldWells.fromJson(
              json['BoxPlotAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final boxPlotAggregatedFieldWells = this.boxPlotAggregatedFieldWells;
    return {
      if (boxPlotAggregatedFieldWells != null)
        'BoxPlotAggregatedFieldWells': boxPlotAggregatedFieldWells,
    };
  }
}

enum BoxPlotFillStyle {
  solid,
  transparent,
}

extension BoxPlotFillStyleValueExtension on BoxPlotFillStyle {
  String toValue() {
    switch (this) {
      case BoxPlotFillStyle.solid:
        return 'SOLID';
      case BoxPlotFillStyle.transparent:
        return 'TRANSPARENT';
    }
  }
}

extension BoxPlotFillStyleFromString on String {
  BoxPlotFillStyle toBoxPlotFillStyle() {
    switch (this) {
      case 'SOLID':
        return BoxPlotFillStyle.solid;
      case 'TRANSPARENT':
        return BoxPlotFillStyle.transparent;
    }
    throw Exception('$this is not known in enum BoxPlotFillStyle');
  }
}

/// The options of a box plot visual.
class BoxPlotOptions {
  /// Determines the visibility of all data points of the box plot.
  final Visibility? allDataPointsVisibility;

  /// Determines the visibility of the outlier in a box plot.
  final Visibility? outlierVisibility;

  /// The style options of the box plot.
  final BoxPlotStyleOptions? styleOptions;

  BoxPlotOptions({
    this.allDataPointsVisibility,
    this.outlierVisibility,
    this.styleOptions,
  });

  factory BoxPlotOptions.fromJson(Map<String, dynamic> json) {
    return BoxPlotOptions(
      allDataPointsVisibility:
          (json['AllDataPointsVisibility'] as String?)?.toVisibility(),
      outlierVisibility: (json['OutlierVisibility'] as String?)?.toVisibility(),
      styleOptions: json['StyleOptions'] != null
          ? BoxPlotStyleOptions.fromJson(
              json['StyleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final allDataPointsVisibility = this.allDataPointsVisibility;
    final outlierVisibility = this.outlierVisibility;
    final styleOptions = this.styleOptions;
    return {
      if (allDataPointsVisibility != null)
        'AllDataPointsVisibility': allDataPointsVisibility.toValue(),
      if (outlierVisibility != null)
        'OutlierVisibility': outlierVisibility.toValue(),
      if (styleOptions != null) 'StyleOptions': styleOptions,
    };
  }
}

/// The sort configuration of a <code>BoxPlotVisual</code>.
class BoxPlotSortConfiguration {
  /// The sort configuration of a group by fields.
  final List<FieldSortOptions>? categorySort;

  /// The pagination configuration of a table visual or box plot.
  final PaginationConfiguration? paginationConfiguration;

  BoxPlotSortConfiguration({
    this.categorySort,
    this.paginationConfiguration,
  });

  factory BoxPlotSortConfiguration.fromJson(Map<String, dynamic> json) {
    return BoxPlotSortConfiguration(
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      paginationConfiguration: json['PaginationConfiguration'] != null
          ? PaginationConfiguration.fromJson(
              json['PaginationConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categorySort = this.categorySort;
    final paginationConfiguration = this.paginationConfiguration;
    return {
      if (categorySort != null) 'CategorySort': categorySort,
      if (paginationConfiguration != null)
        'PaginationConfiguration': paginationConfiguration,
    };
  }
}

/// The style options of the box plot.
class BoxPlotStyleOptions {
  /// The fill styles (solid, transparent) of the box plot.
  final BoxPlotFillStyle? fillStyle;

  BoxPlotStyleOptions({
    this.fillStyle,
  });

  factory BoxPlotStyleOptions.fromJson(Map<String, dynamic> json) {
    return BoxPlotStyleOptions(
      fillStyle: (json['FillStyle'] as String?)?.toBoxPlotFillStyle(),
    );
  }

  Map<String, dynamic> toJson() {
    final fillStyle = this.fillStyle;
    return {
      if (fillStyle != null) 'FillStyle': fillStyle.toValue(),
    };
  }
}

/// A box plot.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using
/// box plots</a> in the <i>Amazon QuickSight User Guide</i>.
class BoxPlotVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final BoxPlotChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  BoxPlotVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory BoxPlotVisual.fromJson(Map<String, dynamic> json) {
    return BoxPlotVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? BoxPlotChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// A calculated column for a dataset.
class CalculatedColumn {
  /// A unique ID to identify a calculated column. During a dataset update, if the
  /// column ID of a calculated column matches that of an existing calculated
  /// column, Amazon QuickSight preserves the existing calculated column.
  final String columnId;

  /// Column name.
  final String columnName;

  /// An expression that defines the calculated column.
  final String expression;

  CalculatedColumn({
    required this.columnId,
    required this.columnName,
    required this.expression,
  });

  factory CalculatedColumn.fromJson(Map<String, dynamic> json) {
    return CalculatedColumn(
      columnId: json['ColumnId'] as String,
      columnName: json['ColumnName'] as String,
      expression: json['Expression'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final columnId = this.columnId;
    final columnName = this.columnName;
    final expression = this.expression;
    return {
      'ColumnId': columnId,
      'ColumnName': columnName,
      'Expression': expression,
    };
  }
}

/// The calculated field of an analysis.
class CalculatedField {
  /// The data set that is used in this calculated field.
  final String dataSetIdentifier;

  /// The expression of the calculated field.
  final String expression;

  /// The name of the calculated field.
  final String name;

  CalculatedField({
    required this.dataSetIdentifier,
    required this.expression,
    required this.name,
  });

  factory CalculatedField.fromJson(Map<String, dynamic> json) {
    return CalculatedField(
      dataSetIdentifier: json['DataSetIdentifier'] as String,
      expression: json['Expression'] as String,
      name: json['Name'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifier = this.dataSetIdentifier;
    final expression = this.expression;
    final name = this.name;
    return {
      'DataSetIdentifier': dataSetIdentifier,
      'Expression': expression,
      'Name': name,
    };
  }
}

/// The table calculation measure field for pivot tables.
class CalculatedMeasureField {
  /// The expression in the table calculation.
  final String expression;

  /// The custom field ID.
  final String fieldId;

  CalculatedMeasureField({
    required this.expression,
    required this.fieldId,
  });

  factory CalculatedMeasureField.fromJson(Map<String, dynamic> json) {
    return CalculatedMeasureField(
      expression: json['Expression'] as String,
      fieldId: json['FieldId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final fieldId = this.fieldId;
    return {
      'Expression': expression,
      'FieldId': fieldId,
    };
  }
}

class CancelIngestionResponse {
  /// The Amazon Resource Name (ARN) for the data ingestion.
  final String? arn;

  /// An ID for the ingestion.
  final String? ingestionId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CancelIngestionResponse({
    this.arn,
    this.ingestionId,
    this.requestId,
    this.status,
  });

  factory CancelIngestionResponse.fromJson(Map<String, dynamic> json) {
    return CancelIngestionResponse(
      arn: json['Arn'] as String?,
      ingestionId: json['IngestionId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final ingestionId = this.ingestionId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (ingestionId != null) 'IngestionId': ingestionId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// The values that are displayed in a control can be configured to only show
/// values that are valid based on what's selected in other controls.
class CascadingControlConfiguration {
  /// A list of source controls that determine the values that are used in the
  /// current control.
  final List<CascadingControlSource>? sourceControls;

  CascadingControlConfiguration({
    this.sourceControls,
  });

  factory CascadingControlConfiguration.fromJson(Map<String, dynamic> json) {
    return CascadingControlConfiguration(
      sourceControls: (json['SourceControls'] as List?)
          ?.whereNotNull()
          .map(
              (e) => CascadingControlSource.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final sourceControls = this.sourceControls;
    return {
      if (sourceControls != null) 'SourceControls': sourceControls,
    };
  }
}

/// The source controls that are used in a
/// <code>CascadingControlConfiguration</code>.
class CascadingControlSource {
  /// The column identifier that determines which column to look up for the source
  /// sheet control.
  final ColumnIdentifier? columnToMatch;

  /// The source sheet control ID of a <code>CascadingControlSource</code>.
  final String? sourceSheetControlId;

  CascadingControlSource({
    this.columnToMatch,
    this.sourceSheetControlId,
  });

  factory CascadingControlSource.fromJson(Map<String, dynamic> json) {
    return CascadingControlSource(
      columnToMatch: json['ColumnToMatch'] != null
          ? ColumnIdentifier.fromJson(
              json['ColumnToMatch'] as Map<String, dynamic>)
          : null,
      sourceSheetControlId: json['SourceSheetControlId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final columnToMatch = this.columnToMatch;
    final sourceSheetControlId = this.sourceSheetControlId;
    return {
      if (columnToMatch != null) 'ColumnToMatch': columnToMatch,
      if (sourceSheetControlId != null)
        'SourceSheetControlId': sourceSheetControlId,
    };
  }
}

/// A transform operation that casts a column to a different type.
class CastColumnTypeOperation {
  /// Column name.
  final String columnName;

  /// New column data type.
  final ColumnDataType newColumnType;

  /// When casting a column from string to datetime type, you can supply a string
  /// in a format supported by Amazon QuickSight to denote the source data format.
  final String? format;

  /// The sub data type of the new column. Sub types are only available for
  /// decimal columns that are part of a SPICE dataset.
  final ColumnDataSubType? subType;

  CastColumnTypeOperation({
    required this.columnName,
    required this.newColumnType,
    this.format,
    this.subType,
  });

  factory CastColumnTypeOperation.fromJson(Map<String, dynamic> json) {
    return CastColumnTypeOperation(
      columnName: json['ColumnName'] as String,
      newColumnType: (json['NewColumnType'] as String).toColumnDataType(),
      format: json['Format'] as String?,
      subType: (json['SubType'] as String?)?.toColumnDataSubType(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final newColumnType = this.newColumnType;
    final format = this.format;
    final subType = this.subType;
    return {
      'ColumnName': columnName,
      'NewColumnType': newColumnType.toValue(),
      if (format != null) 'Format': format,
      if (subType != null) 'SubType': subType.toValue(),
    };
  }
}

enum CategoricalAggregationFunction {
  count,
  distinctCount,
}

extension CategoricalAggregationFunctionValueExtension
    on CategoricalAggregationFunction {
  String toValue() {
    switch (this) {
      case CategoricalAggregationFunction.count:
        return 'COUNT';
      case CategoricalAggregationFunction.distinctCount:
        return 'DISTINCT_COUNT';
    }
  }
}

extension CategoricalAggregationFunctionFromString on String {
  CategoricalAggregationFunction toCategoricalAggregationFunction() {
    switch (this) {
      case 'COUNT':
        return CategoricalAggregationFunction.count;
      case 'DISTINCT_COUNT':
        return CategoricalAggregationFunction.distinctCount;
    }
    throw Exception(
        '$this is not known in enum CategoricalAggregationFunction');
  }
}

/// The dimension type field with categorical type columns..
class CategoricalDimensionField {
  /// The column that is used in the <code>CategoricalDimensionField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The format configuration of the field.
  final StringFormatConfiguration? formatConfiguration;

  /// The custom hierarchy ID.
  final String? hierarchyId;

  CategoricalDimensionField({
    required this.column,
    required this.fieldId,
    this.formatConfiguration,
    this.hierarchyId,
  });

  factory CategoricalDimensionField.fromJson(Map<String, dynamic> json) {
    return CategoricalDimensionField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      formatConfiguration: json['FormatConfiguration'] != null
          ? StringFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
      hierarchyId: json['HierarchyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final formatConfiguration = this.formatConfiguration;
    final hierarchyId = this.hierarchyId;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
      if (hierarchyId != null) 'HierarchyId': hierarchyId,
    };
  }
}

/// The measure type field with categorical type columns.
class CategoricalMeasureField {
  /// The column that is used in the <code>CategoricalMeasureField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The aggregation function of the measure field.
  final CategoricalAggregationFunction? aggregationFunction;

  /// The format configuration of the field.
  final StringFormatConfiguration? formatConfiguration;

  CategoricalMeasureField({
    required this.column,
    required this.fieldId,
    this.aggregationFunction,
    this.formatConfiguration,
  });

  factory CategoricalMeasureField.fromJson(Map<String, dynamic> json) {
    return CategoricalMeasureField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      aggregationFunction: (json['AggregationFunction'] as String?)
          ?.toCategoricalAggregationFunction(),
      formatConfiguration: json['FormatConfiguration'] != null
          ? StringFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final aggregationFunction = this.aggregationFunction;
    final formatConfiguration = this.formatConfiguration;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction.toValue(),
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
    };
  }
}

/// The category drill down filter.
class CategoryDrillDownFilter {
  /// A list of the string inputs that are the values of the category drill down
  /// filter.
  final List<String> categoryValues;

  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  CategoryDrillDownFilter({
    required this.categoryValues,
    required this.column,
  });

  factory CategoryDrillDownFilter.fromJson(Map<String, dynamic> json) {
    return CategoryDrillDownFilter(
      categoryValues: (json['CategoryValues'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryValues = this.categoryValues;
    final column = this.column;
    return {
      'CategoryValues': categoryValues,
      'Column': column,
    };
  }
}

/// A <code>CategoryFilter</code> filters text values.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding
/// text filters</a> in the <i>Amazon QuickSight User Guide</i>.
class CategoryFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// The configuration for a <code>CategoryFilter</code>.
  final CategoryFilterConfiguration configuration;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  CategoryFilter({
    required this.column,
    required this.configuration,
    required this.filterId,
    this.defaultFilterControlConfiguration,
  });

  factory CategoryFilter.fromJson(Map<String, dynamic> json) {
    return CategoryFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      configuration: CategoryFilterConfiguration.fromJson(
          json['Configuration'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final configuration = this.configuration;
    final filterId = this.filterId;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    return {
      'Column': column,
      'Configuration': configuration,
      'FilterId': filterId,
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
    };
  }
}

/// The configuration for a <code>CategoryFilter</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class CategoryFilterConfiguration {
  /// A custom filter that filters based on a single value. This filter can be
  /// partially matched.
  final CustomFilterConfiguration? customFilterConfiguration;

  /// A list of custom filter values. In the Amazon QuickSight console, this
  /// filter type is called a custom filter list.
  final CustomFilterListConfiguration? customFilterListConfiguration;

  /// A list of filter configurations. In the Amazon QuickSight console, this
  /// filter type is called a filter list.
  final FilterListConfiguration? filterListConfiguration;

  CategoryFilterConfiguration({
    this.customFilterConfiguration,
    this.customFilterListConfiguration,
    this.filterListConfiguration,
  });

  factory CategoryFilterConfiguration.fromJson(Map<String, dynamic> json) {
    return CategoryFilterConfiguration(
      customFilterConfiguration: json['CustomFilterConfiguration'] != null
          ? CustomFilterConfiguration.fromJson(
              json['CustomFilterConfiguration'] as Map<String, dynamic>)
          : null,
      customFilterListConfiguration:
          json['CustomFilterListConfiguration'] != null
              ? CustomFilterListConfiguration.fromJson(
                  json['CustomFilterListConfiguration'] as Map<String, dynamic>)
              : null,
      filterListConfiguration: json['FilterListConfiguration'] != null
          ? FilterListConfiguration.fromJson(
              json['FilterListConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customFilterConfiguration = this.customFilterConfiguration;
    final customFilterListConfiguration = this.customFilterListConfiguration;
    final filterListConfiguration = this.filterListConfiguration;
    return {
      if (customFilterConfiguration != null)
        'CustomFilterConfiguration': customFilterConfiguration,
      if (customFilterListConfiguration != null)
        'CustomFilterListConfiguration': customFilterListConfiguration,
      if (filterListConfiguration != null)
        'FilterListConfiguration': filterListConfiguration,
    };
  }
}

enum CategoryFilterFunction {
  exact,
  contains,
}

extension CategoryFilterFunctionValueExtension on CategoryFilterFunction {
  String toValue() {
    switch (this) {
      case CategoryFilterFunction.exact:
        return 'EXACT';
      case CategoryFilterFunction.contains:
        return 'CONTAINS';
    }
  }
}

extension CategoryFilterFunctionFromString on String {
  CategoryFilterFunction toCategoryFilterFunction() {
    switch (this) {
      case 'EXACT':
        return CategoryFilterFunction.exact;
      case 'CONTAINS':
        return CategoryFilterFunction.contains;
    }
    throw Exception('$this is not known in enum CategoryFilterFunction');
  }
}

enum CategoryFilterMatchOperator {
  equals,
  doesNotEqual,
  contains,
  doesNotContain,
  startsWith,
  endsWith,
}

extension CategoryFilterMatchOperatorValueExtension
    on CategoryFilterMatchOperator {
  String toValue() {
    switch (this) {
      case CategoryFilterMatchOperator.equals:
        return 'EQUALS';
      case CategoryFilterMatchOperator.doesNotEqual:
        return 'DOES_NOT_EQUAL';
      case CategoryFilterMatchOperator.contains:
        return 'CONTAINS';
      case CategoryFilterMatchOperator.doesNotContain:
        return 'DOES_NOT_CONTAIN';
      case CategoryFilterMatchOperator.startsWith:
        return 'STARTS_WITH';
      case CategoryFilterMatchOperator.endsWith:
        return 'ENDS_WITH';
    }
  }
}

extension CategoryFilterMatchOperatorFromString on String {
  CategoryFilterMatchOperator toCategoryFilterMatchOperator() {
    switch (this) {
      case 'EQUALS':
        return CategoryFilterMatchOperator.equals;
      case 'DOES_NOT_EQUAL':
        return CategoryFilterMatchOperator.doesNotEqual;
      case 'CONTAINS':
        return CategoryFilterMatchOperator.contains;
      case 'DOES_NOT_CONTAIN':
        return CategoryFilterMatchOperator.doesNotContain;
      case 'STARTS_WITH':
        return CategoryFilterMatchOperator.startsWith;
      case 'ENDS_WITH':
        return CategoryFilterMatchOperator.endsWith;
    }
    throw Exception('$this is not known in enum CategoryFilterMatchOperator');
  }
}

enum CategoryFilterSelectAllOptions {
  filterAllValues,
}

extension CategoryFilterSelectAllOptionsValueExtension
    on CategoryFilterSelectAllOptions {
  String toValue() {
    switch (this) {
      case CategoryFilterSelectAllOptions.filterAllValues:
        return 'FILTER_ALL_VALUES';
    }
  }
}

extension CategoryFilterSelectAllOptionsFromString on String {
  CategoryFilterSelectAllOptions toCategoryFilterSelectAllOptions() {
    switch (this) {
      case 'FILTER_ALL_VALUES':
        return CategoryFilterSelectAllOptions.filterAllValues;
    }
    throw Exception(
        '$this is not known in enum CategoryFilterSelectAllOptions');
  }
}

enum CategoryFilterType {
  customFilter,
  customFilterList,
  filterList,
}

extension CategoryFilterTypeValueExtension on CategoryFilterType {
  String toValue() {
    switch (this) {
      case CategoryFilterType.customFilter:
        return 'CUSTOM_FILTER';
      case CategoryFilterType.customFilterList:
        return 'CUSTOM_FILTER_LIST';
      case CategoryFilterType.filterList:
        return 'FILTER_LIST';
    }
  }
}

extension CategoryFilterTypeFromString on String {
  CategoryFilterType toCategoryFilterType() {
    switch (this) {
      case 'CUSTOM_FILTER':
        return CategoryFilterType.customFilter;
      case 'CUSTOM_FILTER_LIST':
        return CategoryFilterType.customFilterList;
      case 'FILTER_LIST':
        return CategoryFilterType.filterList;
    }
    throw Exception('$this is not known in enum CategoryFilterType');
  }
}

/// A structure that represents the cell value synonym.
class CellValueSynonym {
  /// The cell value.
  final String? cellValue;

  /// Other names or aliases for the cell value.
  final List<String>? synonyms;

  CellValueSynonym({
    this.cellValue,
    this.synonyms,
  });

  factory CellValueSynonym.fromJson(Map<String, dynamic> json) {
    return CellValueSynonym(
      cellValue: json['CellValue'] as String?,
      synonyms: (json['Synonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final cellValue = this.cellValue;
    final synonyms = this.synonyms;
    return {
      if (cellValue != null) 'CellValue': cellValue,
      if (synonyms != null) 'Synonyms': synonyms,
    };
  }
}

/// The label options for an axis on a chart.
class ChartAxisLabelOptions {
  /// The label options for a chart axis.
  final List<AxisLabelOptions>? axisLabelOptions;

  /// The visibility configuration of the sort icon on a chart's axis label.
  final Visibility? sortIconVisibility;

  /// The visibility of an axis label on a chart. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>VISIBLE</code>: Shows the axis.
  /// </li>
  /// <li>
  /// <code>HIDDEN</code>: Hides the axis.
  /// </li>
  /// </ul>
  final Visibility? visibility;

  ChartAxisLabelOptions({
    this.axisLabelOptions,
    this.sortIconVisibility,
    this.visibility,
  });

  factory ChartAxisLabelOptions.fromJson(Map<String, dynamic> json) {
    return ChartAxisLabelOptions(
      axisLabelOptions: (json['AxisLabelOptions'] as List?)
          ?.whereNotNull()
          .map((e) => AxisLabelOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      sortIconVisibility:
          (json['SortIconVisibility'] as String?)?.toVisibility(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final axisLabelOptions = this.axisLabelOptions;
    final sortIconVisibility = this.sortIconVisibility;
    final visibility = this.visibility;
    return {
      if (axisLabelOptions != null) 'AxisLabelOptions': axisLabelOptions,
      if (sortIconVisibility != null)
        'SortIconVisibility': sortIconVisibility.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The cluster marker that is a part of the cluster marker configuration.
class ClusterMarker {
  /// The simple cluster marker of the cluster marker.
  final SimpleClusterMarker? simpleClusterMarker;

  ClusterMarker({
    this.simpleClusterMarker,
  });

  factory ClusterMarker.fromJson(Map<String, dynamic> json) {
    return ClusterMarker(
      simpleClusterMarker: json['SimpleClusterMarker'] != null
          ? SimpleClusterMarker.fromJson(
              json['SimpleClusterMarker'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final simpleClusterMarker = this.simpleClusterMarker;
    return {
      if (simpleClusterMarker != null)
        'SimpleClusterMarker': simpleClusterMarker,
    };
  }
}

/// The cluster marker configuration of the geospatial map selected point style.
class ClusterMarkerConfiguration {
  /// The cluster marker that is a part of the cluster marker configuration.
  final ClusterMarker? clusterMarker;

  ClusterMarkerConfiguration({
    this.clusterMarker,
  });

  factory ClusterMarkerConfiguration.fromJson(Map<String, dynamic> json) {
    return ClusterMarkerConfiguration(
      clusterMarker: json['ClusterMarker'] != null
          ? ClusterMarker.fromJson(
              json['ClusterMarker'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final clusterMarker = this.clusterMarker;
    return {
      if (clusterMarker != null) 'ClusterMarker': clusterMarker,
    };
  }
}

/// A structure that represents a collective constant.
class CollectiveConstant {
  /// A list of values for the collective constant.
  final List<String>? valueList;

  CollectiveConstant({
    this.valueList,
  });

  factory CollectiveConstant.fromJson(Map<String, dynamic> json) {
    return CollectiveConstant(
      valueList: (json['ValueList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final valueList = this.valueList;
    return {
      if (valueList != null) 'ValueList': valueList,
    };
  }
}

enum ColorFillType {
  discrete,
  gradient,
}

extension ColorFillTypeValueExtension on ColorFillType {
  String toValue() {
    switch (this) {
      case ColorFillType.discrete:
        return 'DISCRETE';
      case ColorFillType.gradient:
        return 'GRADIENT';
    }
  }
}

extension ColorFillTypeFromString on String {
  ColorFillType toColorFillType() {
    switch (this) {
      case 'DISCRETE':
        return ColorFillType.discrete;
      case 'GRADIENT':
        return ColorFillType.gradient;
    }
    throw Exception('$this is not known in enum ColorFillType');
  }
}

/// Determines the color scale that is applied to the visual.
class ColorScale {
  /// Determines the color fill type.
  final ColorFillType colorFillType;

  /// Determines the list of colors that are applied to the visual.
  final List<DataColor> colors;

  /// Determines the color that is applied to null values.
  final DataColor? nullValueColor;

  ColorScale({
    required this.colorFillType,
    required this.colors,
    this.nullValueColor,
  });

  factory ColorScale.fromJson(Map<String, dynamic> json) {
    return ColorScale(
      colorFillType: (json['ColorFillType'] as String).toColorFillType(),
      colors: (json['Colors'] as List)
          .whereNotNull()
          .map((e) => DataColor.fromJson(e as Map<String, dynamic>))
          .toList(),
      nullValueColor: json['NullValueColor'] != null
          ? DataColor.fromJson(json['NullValueColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final colorFillType = this.colorFillType;
    final colors = this.colors;
    final nullValueColor = this.nullValueColor;
    return {
      'ColorFillType': colorFillType.toValue(),
      'Colors': colors,
      if (nullValueColor != null) 'NullValueColor': nullValueColor,
    };
  }
}

/// The color configurations for a column.
class ColorsConfiguration {
  /// A list of up to 50 custom colors.
  final List<CustomColor>? customColors;

  ColorsConfiguration({
    this.customColors,
  });

  factory ColorsConfiguration.fromJson(Map<String, dynamic> json) {
    return ColorsConfiguration(
      customColors: (json['CustomColors'] as List?)
          ?.whereNotNull()
          .map((e) => CustomColor.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final customColors = this.customColors;
    return {
      if (customColors != null) 'CustomColors': customColors,
    };
  }
}

/// The general configuration of a column.
class ColumnConfiguration {
  /// The column.
  final ColumnIdentifier column;

  /// The color configurations of the column.
  final ColorsConfiguration? colorsConfiguration;

  /// The format configuration of a column.
  final FormatConfiguration? formatConfiguration;

  /// The role of the column.
  final ColumnRole? role;

  ColumnConfiguration({
    required this.column,
    this.colorsConfiguration,
    this.formatConfiguration,
    this.role,
  });

  factory ColumnConfiguration.fromJson(Map<String, dynamic> json) {
    return ColumnConfiguration(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      colorsConfiguration: json['ColorsConfiguration'] != null
          ? ColorsConfiguration.fromJson(
              json['ColorsConfiguration'] as Map<String, dynamic>)
          : null,
      formatConfiguration: json['FormatConfiguration'] != null
          ? FormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
      role: (json['Role'] as String?)?.toColumnRole(),
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final colorsConfiguration = this.colorsConfiguration;
    final formatConfiguration = this.formatConfiguration;
    final role = this.role;
    return {
      'Column': column,
      if (colorsConfiguration != null)
        'ColorsConfiguration': colorsConfiguration,
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
      if (role != null) 'Role': role.toValue(),
    };
  }
}

enum ColumnDataRole {
  dimension,
  measure,
}

extension ColumnDataRoleValueExtension on ColumnDataRole {
  String toValue() {
    switch (this) {
      case ColumnDataRole.dimension:
        return 'DIMENSION';
      case ColumnDataRole.measure:
        return 'MEASURE';
    }
  }
}

extension ColumnDataRoleFromString on String {
  ColumnDataRole toColumnDataRole() {
    switch (this) {
      case 'DIMENSION':
        return ColumnDataRole.dimension;
      case 'MEASURE':
        return ColumnDataRole.measure;
    }
    throw Exception('$this is not known in enum ColumnDataRole');
  }
}

enum ColumnDataSubType {
  float,
  fixed,
}

extension ColumnDataSubTypeValueExtension on ColumnDataSubType {
  String toValue() {
    switch (this) {
      case ColumnDataSubType.float:
        return 'FLOAT';
      case ColumnDataSubType.fixed:
        return 'FIXED';
    }
  }
}

extension ColumnDataSubTypeFromString on String {
  ColumnDataSubType toColumnDataSubType() {
    switch (this) {
      case 'FLOAT':
        return ColumnDataSubType.float;
      case 'FIXED':
        return ColumnDataSubType.fixed;
    }
    throw Exception('$this is not known in enum ColumnDataSubType');
  }
}

enum ColumnDataType {
  string,
  integer,
  decimal,
  datetime,
}

extension ColumnDataTypeValueExtension on ColumnDataType {
  String toValue() {
    switch (this) {
      case ColumnDataType.string:
        return 'STRING';
      case ColumnDataType.integer:
        return 'INTEGER';
      case ColumnDataType.decimal:
        return 'DECIMAL';
      case ColumnDataType.datetime:
        return 'DATETIME';
    }
  }
}

extension ColumnDataTypeFromString on String {
  ColumnDataType toColumnDataType() {
    switch (this) {
      case 'STRING':
        return ColumnDataType.string;
      case 'INTEGER':
        return ColumnDataType.integer;
      case 'DECIMAL':
        return ColumnDataType.decimal;
      case 'DATETIME':
        return ColumnDataType.datetime;
    }
    throw Exception('$this is not known in enum ColumnDataType');
  }
}

/// Metadata that contains a description for a column.
class ColumnDescription {
  /// The text of a description for a column.
  final String? text;

  ColumnDescription({
    this.text,
  });

  factory ColumnDescription.fromJson(Map<String, dynamic> json) {
    return ColumnDescription(
      text: json['Text'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final text = this.text;
    return {
      if (text != null) 'Text': text,
    };
  }
}

/// Groupings of columns that work together in certain Amazon QuickSight
/// features. This is a variant type structure. For this structure to be valid,
/// only one of the attributes can be non-null.
class ColumnGroup {
  /// Geospatial column group that denotes a hierarchy.
  final GeoSpatialColumnGroup? geoSpatialColumnGroup;

  ColumnGroup({
    this.geoSpatialColumnGroup,
  });

  factory ColumnGroup.fromJson(Map<String, dynamic> json) {
    return ColumnGroup(
      geoSpatialColumnGroup: json['GeoSpatialColumnGroup'] != null
          ? GeoSpatialColumnGroup.fromJson(
              json['GeoSpatialColumnGroup'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final geoSpatialColumnGroup = this.geoSpatialColumnGroup;
    return {
      if (geoSpatialColumnGroup != null)
        'GeoSpatialColumnGroup': geoSpatialColumnGroup,
    };
  }
}

/// A structure describing the name, data type, and geographic role of the
/// columns.
class ColumnGroupColumnSchema {
  /// The name of the column group's column schema.
  final String? name;

  ColumnGroupColumnSchema({
    this.name,
  });

  factory ColumnGroupColumnSchema.fromJson(Map<String, dynamic> json) {
    return ColumnGroupColumnSchema(
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      if (name != null) 'Name': name,
    };
  }
}

/// The column group schema.
class ColumnGroupSchema {
  /// A structure containing the list of schemas for column group columns.
  final List<ColumnGroupColumnSchema>? columnGroupColumnSchemaList;

  /// The name of the column group schema.
  final String? name;

  ColumnGroupSchema({
    this.columnGroupColumnSchemaList,
    this.name,
  });

  factory ColumnGroupSchema.fromJson(Map<String, dynamic> json) {
    return ColumnGroupSchema(
      columnGroupColumnSchemaList:
          (json['ColumnGroupColumnSchemaList'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  ColumnGroupColumnSchema.fromJson(e as Map<String, dynamic>))
              .toList(),
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final columnGroupColumnSchemaList = this.columnGroupColumnSchemaList;
    final name = this.name;
    return {
      if (columnGroupColumnSchemaList != null)
        'ColumnGroupColumnSchemaList': columnGroupColumnSchemaList,
      if (name != null) 'Name': name,
    };
  }
}

/// The option that determines the hierarchy of the fields for a visual element.
class ColumnHierarchy {
  /// The option that determines the hierarchy of any <code>DateTime</code>
  /// fields.
  final DateTimeHierarchy? dateTimeHierarchy;

  /// The option that determines the hierarchy of the fields that are built within
  /// a visual's field wells. These fields can't be duplicated to other visuals.
  final ExplicitHierarchy? explicitHierarchy;

  /// The option that determines the hierarchy of the fields that are defined
  /// during data preparation. These fields are available to use in any analysis
  /// that uses the data source.
  final PredefinedHierarchy? predefinedHierarchy;

  ColumnHierarchy({
    this.dateTimeHierarchy,
    this.explicitHierarchy,
    this.predefinedHierarchy,
  });

  factory ColumnHierarchy.fromJson(Map<String, dynamic> json) {
    return ColumnHierarchy(
      dateTimeHierarchy: json['DateTimeHierarchy'] != null
          ? DateTimeHierarchy.fromJson(
              json['DateTimeHierarchy'] as Map<String, dynamic>)
          : null,
      explicitHierarchy: json['ExplicitHierarchy'] != null
          ? ExplicitHierarchy.fromJson(
              json['ExplicitHierarchy'] as Map<String, dynamic>)
          : null,
      predefinedHierarchy: json['PredefinedHierarchy'] != null
          ? PredefinedHierarchy.fromJson(
              json['PredefinedHierarchy'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeHierarchy = this.dateTimeHierarchy;
    final explicitHierarchy = this.explicitHierarchy;
    final predefinedHierarchy = this.predefinedHierarchy;
    return {
      if (dateTimeHierarchy != null) 'DateTimeHierarchy': dateTimeHierarchy,
      if (explicitHierarchy != null) 'ExplicitHierarchy': explicitHierarchy,
      if (predefinedHierarchy != null)
        'PredefinedHierarchy': predefinedHierarchy,
    };
  }
}

/// A column of a data set.
class ColumnIdentifier {
  /// The name of the column.
  final String columnName;

  /// The data set that the column belongs to.
  final String dataSetIdentifier;

  ColumnIdentifier({
    required this.columnName,
    required this.dataSetIdentifier,
  });

  factory ColumnIdentifier.fromJson(Map<String, dynamic> json) {
    return ColumnIdentifier(
      columnName: json['ColumnName'] as String,
      dataSetIdentifier: json['DataSetIdentifier'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final dataSetIdentifier = this.dataSetIdentifier;
    return {
      'ColumnName': columnName,
      'DataSetIdentifier': dataSetIdentifier,
    };
  }
}

/// A rule defined to grant access on one or more restricted columns. Each
/// dataset can have multiple rules. To create a restricted column, you add it
/// to one or more rules. Each rule must contain at least one column and at
/// least one user or group. To be able to see a restricted column, a user or
/// group needs to be added to a rule for that column.
class ColumnLevelPermissionRule {
  /// An array of column names.
  final List<String>? columnNames;

  /// An array of Amazon Resource Names (ARNs) for Amazon QuickSight users or
  /// groups.
  final List<String>? principals;

  ColumnLevelPermissionRule({
    this.columnNames,
    this.principals,
  });

  factory ColumnLevelPermissionRule.fromJson(Map<String, dynamic> json) {
    return ColumnLevelPermissionRule(
      columnNames: (json['ColumnNames'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      principals: (json['Principals'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnNames = this.columnNames;
    final principals = this.principals;
    return {
      if (columnNames != null) 'ColumnNames': columnNames,
      if (principals != null) 'Principals': principals,
    };
  }
}

enum ColumnOrderingType {
  greaterIsBetter,
  lesserIsBetter,
  specified,
}

extension ColumnOrderingTypeValueExtension on ColumnOrderingType {
  String toValue() {
    switch (this) {
      case ColumnOrderingType.greaterIsBetter:
        return 'GREATER_IS_BETTER';
      case ColumnOrderingType.lesserIsBetter:
        return 'LESSER_IS_BETTER';
      case ColumnOrderingType.specified:
        return 'SPECIFIED';
    }
  }
}

extension ColumnOrderingTypeFromString on String {
  ColumnOrderingType toColumnOrderingType() {
    switch (this) {
      case 'GREATER_IS_BETTER':
        return ColumnOrderingType.greaterIsBetter;
      case 'LESSER_IS_BETTER':
        return ColumnOrderingType.lesserIsBetter;
      case 'SPECIFIED':
        return ColumnOrderingType.specified;
    }
    throw Exception('$this is not known in enum ColumnOrderingType');
  }
}

enum ColumnRole {
  dimension,
  measure,
}

extension ColumnRoleValueExtension on ColumnRole {
  String toValue() {
    switch (this) {
      case ColumnRole.dimension:
        return 'DIMENSION';
      case ColumnRole.measure:
        return 'MEASURE';
    }
  }
}

extension ColumnRoleFromString on String {
  ColumnRole toColumnRole() {
    switch (this) {
      case 'DIMENSION':
        return ColumnRole.dimension;
      case 'MEASURE':
        return ColumnRole.measure;
    }
    throw Exception('$this is not known in enum ColumnRole');
  }
}

/// The column schema.
class ColumnSchema {
  /// The data type of the column schema.
  final String? dataType;

  /// The geographic role of the column schema.
  final String? geographicRole;

  /// The name of the column schema.
  final String? name;

  ColumnSchema({
    this.dataType,
    this.geographicRole,
    this.name,
  });

  factory ColumnSchema.fromJson(Map<String, dynamic> json) {
    return ColumnSchema(
      dataType: json['DataType'] as String?,
      geographicRole: json['GeographicRole'] as String?,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataType = this.dataType;
    final geographicRole = this.geographicRole;
    final name = this.name;
    return {
      if (dataType != null) 'DataType': dataType,
      if (geographicRole != null) 'GeographicRole': geographicRole,
      if (name != null) 'Name': name,
    };
  }
}

/// The sort configuration for a column that is not used in a field well.
class ColumnSort {
  /// The sort direction.
  final SortDirection direction;
  final ColumnIdentifier sortBy;

  /// The aggregation function that is defined in the column sort.
  final AggregationFunction? aggregationFunction;

  ColumnSort({
    required this.direction,
    required this.sortBy,
    this.aggregationFunction,
  });

  factory ColumnSort.fromJson(Map<String, dynamic> json) {
    return ColumnSort(
      direction: (json['Direction'] as String).toSortDirection(),
      sortBy: ColumnIdentifier.fromJson(json['SortBy'] as Map<String, dynamic>),
      aggregationFunction: json['AggregationFunction'] != null
          ? AggregationFunction.fromJson(
              json['AggregationFunction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final direction = this.direction;
    final sortBy = this.sortBy;
    final aggregationFunction = this.aggregationFunction;
    return {
      'Direction': direction.toValue(),
      'SortBy': sortBy,
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction,
    };
  }
}

/// A tag for a column in a <code> <a
/// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_TagColumnOperation.html">TagColumnOperation</a>
/// </code> structure. This is a variant type structure. For this structure to
/// be valid, only one of the attributes can be non-null.
class ColumnTag {
  /// A description for a column.
  final ColumnDescription? columnDescription;

  /// A geospatial role for a column.
  final GeoSpatialDataRole? columnGeographicRole;

  ColumnTag({
    this.columnDescription,
    this.columnGeographicRole,
  });

  factory ColumnTag.fromJson(Map<String, dynamic> json) {
    return ColumnTag(
      columnDescription: json['ColumnDescription'] != null
          ? ColumnDescription.fromJson(
              json['ColumnDescription'] as Map<String, dynamic>)
          : null,
      columnGeographicRole:
          (json['ColumnGeographicRole'] as String?)?.toGeoSpatialDataRole(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnDescription = this.columnDescription;
    final columnGeographicRole = this.columnGeographicRole;
    return {
      if (columnDescription != null) 'ColumnDescription': columnDescription,
      if (columnGeographicRole != null)
        'ColumnGeographicRole': columnGeographicRole.toValue(),
    };
  }
}

enum ColumnTagName {
  columnGeographicRole,
  columnDescription,
}

extension ColumnTagNameValueExtension on ColumnTagName {
  String toValue() {
    switch (this) {
      case ColumnTagName.columnGeographicRole:
        return 'COLUMN_GEOGRAPHIC_ROLE';
      case ColumnTagName.columnDescription:
        return 'COLUMN_DESCRIPTION';
    }
  }
}

extension ColumnTagNameFromString on String {
  ColumnTagName toColumnTagName() {
    switch (this) {
      case 'COLUMN_GEOGRAPHIC_ROLE':
        return ColumnTagName.columnGeographicRole;
      case 'COLUMN_DESCRIPTION':
        return ColumnTagName.columnDescription;
    }
    throw Exception('$this is not known in enum ColumnTagName');
  }
}

/// The tooltip item for the columns that are not part of a field well.
class ColumnTooltipItem {
  /// The target column of the tooltip item.
  final ColumnIdentifier column;

  /// The aggregation function of the column tooltip item.
  final AggregationFunction? aggregation;

  /// The label of the tooltip item.
  final String? label;

  /// Determines the target of the column tooltip item in a combo chart visual.
  final TooltipTarget? tooltipTarget;

  /// The visibility of the tooltip item.
  final Visibility? visibility;

  ColumnTooltipItem({
    required this.column,
    this.aggregation,
    this.label,
    this.tooltipTarget,
    this.visibility,
  });

  factory ColumnTooltipItem.fromJson(Map<String, dynamic> json) {
    return ColumnTooltipItem(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      aggregation: json['Aggregation'] != null
          ? AggregationFunction.fromJson(
              json['Aggregation'] as Map<String, dynamic>)
          : null,
      label: json['Label'] as String?,
      tooltipTarget: (json['TooltipTarget'] as String?)?.toTooltipTarget(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final aggregation = this.aggregation;
    final label = this.label;
    final tooltipTarget = this.tooltipTarget;
    final visibility = this.visibility;
    return {
      'Column': column,
      if (aggregation != null) 'Aggregation': aggregation,
      if (label != null) 'Label': label,
      if (tooltipTarget != null) 'TooltipTarget': tooltipTarget.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The aggregated field wells of a combo chart.
class ComboChartAggregatedFieldWells {
  /// The aggregated <code>BarValues</code> field well of a combo chart.
  final List<MeasureField>? barValues;

  /// The aggregated category field wells of a combo chart.
  final List<DimensionField>? category;

  /// The aggregated colors field well of a combo chart.
  final List<DimensionField>? colors;

  /// The aggregated <code>LineValues</code> field well of a combo chart.
  final List<MeasureField>? lineValues;

  ComboChartAggregatedFieldWells({
    this.barValues,
    this.category,
    this.colors,
    this.lineValues,
  });

  factory ComboChartAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return ComboChartAggregatedFieldWells(
      barValues: (json['BarValues'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      lineValues: (json['LineValues'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final barValues = this.barValues;
    final category = this.category;
    final colors = this.colors;
    final lineValues = this.lineValues;
    return {
      if (barValues != null) 'BarValues': barValues,
      if (category != null) 'Category': category,
      if (colors != null) 'Colors': colors,
      if (lineValues != null) 'LineValues': lineValues,
    };
  }
}

/// The configuration of a <code>ComboChartVisual</code>.
class ComboChartConfiguration {
  /// The options that determine if visual data labels are displayed.
  ///
  /// The data label options for a bar in a combo chart.
  final DataLabelOptions? barDataLabels;

  /// Determines the bar arrangement in a combo chart. The following are valid
  /// values in this structure:
  ///
  /// <ul>
  /// <li>
  /// <code>CLUSTERED</code>: For clustered bar combo charts.
  /// </li>
  /// <li>
  /// <code>STACKED</code>: For stacked bar combo charts.
  /// </li>
  /// <li>
  /// <code>STACKED_PERCENT</code>: Do not use. If you use this value, the
  /// operation returns a validation error.
  /// </li>
  /// </ul>
  final BarsArrangement? barsArrangement;

  /// The category axis of a combo chart.
  final AxisDisplayOptions? categoryAxis;

  /// The label options (label text, label visibility, and sort icon visibility)
  /// of a combo chart category (group/color) field well.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The label options (label text, label visibility, and sort icon visibility)
  /// of a combo chart's color field well.
  final ChartAxisLabelOptions? colorLabelOptions;

  /// The field wells of the visual.
  final ComboChartFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The options that determine if visual data labels are displayed.
  ///
  /// The data label options for a line in a combo chart.
  final DataLabelOptions? lineDataLabels;

  /// The label display options (grid line, range, scale, and axis step) of a
  /// combo chart's primary y-axis (bar) field well.
  final AxisDisplayOptions? primaryYAxisDisplayOptions;

  /// The label options (label text, label visibility, and sort icon visibility)
  /// of a combo chart's primary y-axis (bar) field well.
  final ChartAxisLabelOptions? primaryYAxisLabelOptions;

  /// The reference line setup of the visual.
  final List<ReferenceLine>? referenceLines;

  /// The label display options (grid line, range, scale, axis step) of a combo
  /// chart's secondary y-axis (line) field well.
  final AxisDisplayOptions? secondaryYAxisDisplayOptions;

  /// The label options (label text, label visibility, and sort icon visibility)
  /// of a combo chart's secondary y-axis(line) field well.
  final ChartAxisLabelOptions? secondaryYAxisLabelOptions;
  final SingleAxisOptions? singleAxisOptions;

  /// The sort configuration of a <code>ComboChartVisual</code>.
  final ComboChartSortConfiguration? sortConfiguration;

  /// The legend display setup of the visual.
  final TooltipOptions? tooltip;

  /// The palette (chart color) display setup of the visual.
  final VisualPalette? visualPalette;

  ComboChartConfiguration({
    this.barDataLabels,
    this.barsArrangement,
    this.categoryAxis,
    this.categoryLabelOptions,
    this.colorLabelOptions,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.lineDataLabels,
    this.primaryYAxisDisplayOptions,
    this.primaryYAxisLabelOptions,
    this.referenceLines,
    this.secondaryYAxisDisplayOptions,
    this.secondaryYAxisLabelOptions,
    this.singleAxisOptions,
    this.sortConfiguration,
    this.tooltip,
    this.visualPalette,
  });

  factory ComboChartConfiguration.fromJson(Map<String, dynamic> json) {
    return ComboChartConfiguration(
      barDataLabels: json['BarDataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['BarDataLabels'] as Map<String, dynamic>)
          : null,
      barsArrangement:
          (json['BarsArrangement'] as String?)?.toBarsArrangement(),
      categoryAxis: json['CategoryAxis'] != null
          ? AxisDisplayOptions.fromJson(
              json['CategoryAxis'] as Map<String, dynamic>)
          : null,
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      colorLabelOptions: json['ColorLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ColorLabelOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? ComboChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      lineDataLabels: json['LineDataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['LineDataLabels'] as Map<String, dynamic>)
          : null,
      primaryYAxisDisplayOptions: json['PrimaryYAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['PrimaryYAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      primaryYAxisLabelOptions: json['PrimaryYAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['PrimaryYAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      referenceLines: (json['ReferenceLines'] as List?)
          ?.whereNotNull()
          .map((e) => ReferenceLine.fromJson(e as Map<String, dynamic>))
          .toList(),
      secondaryYAxisDisplayOptions: json['SecondaryYAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['SecondaryYAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      secondaryYAxisLabelOptions: json['SecondaryYAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['SecondaryYAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      singleAxisOptions: json['SingleAxisOptions'] != null
          ? SingleAxisOptions.fromJson(
              json['SingleAxisOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? ComboChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final barDataLabels = this.barDataLabels;
    final barsArrangement = this.barsArrangement;
    final categoryAxis = this.categoryAxis;
    final categoryLabelOptions = this.categoryLabelOptions;
    final colorLabelOptions = this.colorLabelOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final lineDataLabels = this.lineDataLabels;
    final primaryYAxisDisplayOptions = this.primaryYAxisDisplayOptions;
    final primaryYAxisLabelOptions = this.primaryYAxisLabelOptions;
    final referenceLines = this.referenceLines;
    final secondaryYAxisDisplayOptions = this.secondaryYAxisDisplayOptions;
    final secondaryYAxisLabelOptions = this.secondaryYAxisLabelOptions;
    final singleAxisOptions = this.singleAxisOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final visualPalette = this.visualPalette;
    return {
      if (barDataLabels != null) 'BarDataLabels': barDataLabels,
      if (barsArrangement != null) 'BarsArrangement': barsArrangement.toValue(),
      if (categoryAxis != null) 'CategoryAxis': categoryAxis,
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (colorLabelOptions != null) 'ColorLabelOptions': colorLabelOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (lineDataLabels != null) 'LineDataLabels': lineDataLabels,
      if (primaryYAxisDisplayOptions != null)
        'PrimaryYAxisDisplayOptions': primaryYAxisDisplayOptions,
      if (primaryYAxisLabelOptions != null)
        'PrimaryYAxisLabelOptions': primaryYAxisLabelOptions,
      if (referenceLines != null) 'ReferenceLines': referenceLines,
      if (secondaryYAxisDisplayOptions != null)
        'SecondaryYAxisDisplayOptions': secondaryYAxisDisplayOptions,
      if (secondaryYAxisLabelOptions != null)
        'SecondaryYAxisLabelOptions': secondaryYAxisLabelOptions,
      if (singleAxisOptions != null) 'SingleAxisOptions': singleAxisOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The field wells of the visual.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class ComboChartFieldWells {
  /// The aggregated field wells of a combo chart. Combo charts only have
  /// aggregated field wells. Columns in a combo chart are aggregated by category.
  final ComboChartAggregatedFieldWells? comboChartAggregatedFieldWells;

  ComboChartFieldWells({
    this.comboChartAggregatedFieldWells,
  });

  factory ComboChartFieldWells.fromJson(Map<String, dynamic> json) {
    return ComboChartFieldWells(
      comboChartAggregatedFieldWells: json['ComboChartAggregatedFieldWells'] !=
              null
          ? ComboChartAggregatedFieldWells.fromJson(
              json['ComboChartAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final comboChartAggregatedFieldWells = this.comboChartAggregatedFieldWells;
    return {
      if (comboChartAggregatedFieldWells != null)
        'ComboChartAggregatedFieldWells': comboChartAggregatedFieldWells,
    };
  }
}

/// The sort configuration of a <code>ComboChartVisual</code>.
class ComboChartSortConfiguration {
  /// The item limit configuration for the category field well of a combo chart.
  final ItemsLimitConfiguration? categoryItemsLimit;

  /// The sort configuration of the category field well in a combo chart.
  final List<FieldSortOptions>? categorySort;

  /// The item limit configuration of the color field well in a combo chart.
  final ItemsLimitConfiguration? colorItemsLimit;

  /// The sort configuration of the color field well in a combo chart.
  final List<FieldSortOptions>? colorSort;

  ComboChartSortConfiguration({
    this.categoryItemsLimit,
    this.categorySort,
    this.colorItemsLimit,
    this.colorSort,
  });

  factory ComboChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return ComboChartSortConfiguration(
      categoryItemsLimit: json['CategoryItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['CategoryItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      colorItemsLimit: json['ColorItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['ColorItemsLimit'] as Map<String, dynamic>)
          : null,
      colorSort: (json['ColorSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimit = this.categoryItemsLimit;
    final categorySort = this.categorySort;
    final colorItemsLimit = this.colorItemsLimit;
    final colorSort = this.colorSort;
    return {
      if (categoryItemsLimit != null) 'CategoryItemsLimit': categoryItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
      if (colorItemsLimit != null) 'ColorItemsLimit': colorItemsLimit,
      if (colorSort != null) 'ColorSort': colorSort,
    };
  }
}

/// A combo chart.
///
/// The <code>ComboChartVisual</code> includes stacked bar combo charts and
/// clustered bar combo charts
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using
/// combo charts</a> in the <i>Amazon QuickSight User Guide</i>.
class ComboChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final ComboChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  ComboChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory ComboChartVisual.fromJson(Map<String, dynamic> json) {
    return ComboChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? ComboChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// A structure that represents a comparative order.
class ComparativeOrder {
  /// The list of columns to be used in the ordering.
  final List<String>? specifedOrder;

  /// The treat of undefined specified values. Valid values for this structure are
  /// <code>LEAST</code> and <code>MOST</code>.
  final UndefinedSpecifiedValueType? treatUndefinedSpecifiedValues;

  /// The ordering type for a column. Valid values for this structure are
  /// <code>GREATER_IS_BETTER</code>, <code>LESSER_IS_BETTER</code> and
  /// <code>SPECIFIED</code>.
  final ColumnOrderingType? useOrdering;

  ComparativeOrder({
    this.specifedOrder,
    this.treatUndefinedSpecifiedValues,
    this.useOrdering,
  });

  factory ComparativeOrder.fromJson(Map<String, dynamic> json) {
    return ComparativeOrder(
      specifedOrder: (json['SpecifedOrder'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      treatUndefinedSpecifiedValues:
          (json['TreatUndefinedSpecifiedValues'] as String?)
              ?.toUndefinedSpecifiedValueType(),
      useOrdering: (json['UseOrdering'] as String?)?.toColumnOrderingType(),
    );
  }

  Map<String, dynamic> toJson() {
    final specifedOrder = this.specifedOrder;
    final treatUndefinedSpecifiedValues = this.treatUndefinedSpecifiedValues;
    final useOrdering = this.useOrdering;
    return {
      if (specifedOrder != null) 'SpecifedOrder': specifedOrder,
      if (treatUndefinedSpecifiedValues != null)
        'TreatUndefinedSpecifiedValues':
            treatUndefinedSpecifiedValues.toValue(),
      if (useOrdering != null) 'UseOrdering': useOrdering.toValue(),
    };
  }
}

/// The comparison display configuration of a KPI or gauge chart.
class ComparisonConfiguration {
  /// The format of the comparison.
  final ComparisonFormatConfiguration? comparisonFormat;

  /// The method of the comparison. Choose from the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>DIFFERENCE</code>
  /// </li>
  /// <li>
  /// <code>PERCENT_DIFFERENCE</code>
  /// </li>
  /// <li>
  /// <code>PERCENT</code>
  /// </li>
  /// </ul>
  final ComparisonMethod? comparisonMethod;

  ComparisonConfiguration({
    this.comparisonFormat,
    this.comparisonMethod,
  });

  factory ComparisonConfiguration.fromJson(Map<String, dynamic> json) {
    return ComparisonConfiguration(
      comparisonFormat: json['ComparisonFormat'] != null
          ? ComparisonFormatConfiguration.fromJson(
              json['ComparisonFormat'] as Map<String, dynamic>)
          : null,
      comparisonMethod:
          (json['ComparisonMethod'] as String?)?.toComparisonMethod(),
    );
  }

  Map<String, dynamic> toJson() {
    final comparisonFormat = this.comparisonFormat;
    final comparisonMethod = this.comparisonMethod;
    return {
      if (comparisonFormat != null) 'ComparisonFormat': comparisonFormat,
      if (comparisonMethod != null)
        'ComparisonMethod': comparisonMethod.toValue(),
    };
  }
}

/// The format of the comparison.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class ComparisonFormatConfiguration {
  /// The number display format.
  final NumberDisplayFormatConfiguration? numberDisplayFormatConfiguration;

  /// The percentage display format.
  final PercentageDisplayFormatConfiguration?
      percentageDisplayFormatConfiguration;

  ComparisonFormatConfiguration({
    this.numberDisplayFormatConfiguration,
    this.percentageDisplayFormatConfiguration,
  });

  factory ComparisonFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return ComparisonFormatConfiguration(
      numberDisplayFormatConfiguration:
          json['NumberDisplayFormatConfiguration'] != null
              ? NumberDisplayFormatConfiguration.fromJson(
                  json['NumberDisplayFormatConfiguration']
                      as Map<String, dynamic>)
              : null,
      percentageDisplayFormatConfiguration:
          json['PercentageDisplayFormatConfiguration'] != null
              ? PercentageDisplayFormatConfiguration.fromJson(
                  json['PercentageDisplayFormatConfiguration']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final numberDisplayFormatConfiguration =
        this.numberDisplayFormatConfiguration;
    final percentageDisplayFormatConfiguration =
        this.percentageDisplayFormatConfiguration;
    return {
      if (numberDisplayFormatConfiguration != null)
        'NumberDisplayFormatConfiguration': numberDisplayFormatConfiguration,
      if (percentageDisplayFormatConfiguration != null)
        'PercentageDisplayFormatConfiguration':
            percentageDisplayFormatConfiguration,
    };
  }
}

enum ComparisonMethod {
  difference,
  percentDifference,
  percent,
}

extension ComparisonMethodValueExtension on ComparisonMethod {
  String toValue() {
    switch (this) {
      case ComparisonMethod.difference:
        return 'DIFFERENCE';
      case ComparisonMethod.percentDifference:
        return 'PERCENT_DIFFERENCE';
      case ComparisonMethod.percent:
        return 'PERCENT';
    }
  }
}

extension ComparisonMethodFromString on String {
  ComparisonMethod toComparisonMethod() {
    switch (this) {
      case 'DIFFERENCE':
        return ComparisonMethod.difference;
      case 'PERCENT_DIFFERENCE':
        return ComparisonMethod.percentDifference;
      case 'PERCENT':
        return ComparisonMethod.percent;
    }
    throw Exception('$this is not known in enum ComparisonMethod');
  }
}

/// The computation union that is used in an insight visual.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class Computation {
  /// The forecast computation configuration.
  final ForecastComputation? forecast;

  /// The growth rate computation configuration.
  final GrowthRateComputation? growthRate;

  /// The maximum and minimum computation configuration.
  final MaximumMinimumComputation? maximumMinimum;

  /// The metric comparison computation configuration.
  final MetricComparisonComputation? metricComparison;

  /// The period over period computation configuration.
  final PeriodOverPeriodComputation? periodOverPeriod;

  /// The period to <code>DataSetIdentifier</code> computation configuration.
  final PeriodToDateComputation? periodToDate;

  /// The top movers and bottom movers computation configuration.
  final TopBottomMoversComputation? topBottomMovers;

  /// The top ranked and bottom ranked computation configuration.
  final TopBottomRankedComputation? topBottomRanked;

  /// The total aggregation computation configuration.
  final TotalAggregationComputation? totalAggregation;

  /// The unique values computation configuration.
  final UniqueValuesComputation? uniqueValues;

  Computation({
    this.forecast,
    this.growthRate,
    this.maximumMinimum,
    this.metricComparison,
    this.periodOverPeriod,
    this.periodToDate,
    this.topBottomMovers,
    this.topBottomRanked,
    this.totalAggregation,
    this.uniqueValues,
  });

  factory Computation.fromJson(Map<String, dynamic> json) {
    return Computation(
      forecast: json['Forecast'] != null
          ? ForecastComputation.fromJson(
              json['Forecast'] as Map<String, dynamic>)
          : null,
      growthRate: json['GrowthRate'] != null
          ? GrowthRateComputation.fromJson(
              json['GrowthRate'] as Map<String, dynamic>)
          : null,
      maximumMinimum: json['MaximumMinimum'] != null
          ? MaximumMinimumComputation.fromJson(
              json['MaximumMinimum'] as Map<String, dynamic>)
          : null,
      metricComparison: json['MetricComparison'] != null
          ? MetricComparisonComputation.fromJson(
              json['MetricComparison'] as Map<String, dynamic>)
          : null,
      periodOverPeriod: json['PeriodOverPeriod'] != null
          ? PeriodOverPeriodComputation.fromJson(
              json['PeriodOverPeriod'] as Map<String, dynamic>)
          : null,
      periodToDate: json['PeriodToDate'] != null
          ? PeriodToDateComputation.fromJson(
              json['PeriodToDate'] as Map<String, dynamic>)
          : null,
      topBottomMovers: json['TopBottomMovers'] != null
          ? TopBottomMoversComputation.fromJson(
              json['TopBottomMovers'] as Map<String, dynamic>)
          : null,
      topBottomRanked: json['TopBottomRanked'] != null
          ? TopBottomRankedComputation.fromJson(
              json['TopBottomRanked'] as Map<String, dynamic>)
          : null,
      totalAggregation: json['TotalAggregation'] != null
          ? TotalAggregationComputation.fromJson(
              json['TotalAggregation'] as Map<String, dynamic>)
          : null,
      uniqueValues: json['UniqueValues'] != null
          ? UniqueValuesComputation.fromJson(
              json['UniqueValues'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final forecast = this.forecast;
    final growthRate = this.growthRate;
    final maximumMinimum = this.maximumMinimum;
    final metricComparison = this.metricComparison;
    final periodOverPeriod = this.periodOverPeriod;
    final periodToDate = this.periodToDate;
    final topBottomMovers = this.topBottomMovers;
    final topBottomRanked = this.topBottomRanked;
    final totalAggregation = this.totalAggregation;
    final uniqueValues = this.uniqueValues;
    return {
      if (forecast != null) 'Forecast': forecast,
      if (growthRate != null) 'GrowthRate': growthRate,
      if (maximumMinimum != null) 'MaximumMinimum': maximumMinimum,
      if (metricComparison != null) 'MetricComparison': metricComparison,
      if (periodOverPeriod != null) 'PeriodOverPeriod': periodOverPeriod,
      if (periodToDate != null) 'PeriodToDate': periodToDate,
      if (topBottomMovers != null) 'TopBottomMovers': topBottomMovers,
      if (topBottomRanked != null) 'TopBottomRanked': topBottomRanked,
      if (totalAggregation != null) 'TotalAggregation': totalAggregation,
      if (uniqueValues != null) 'UniqueValues': uniqueValues,
    };
  }
}

/// The formatting configuration for the color.
class ConditionalFormattingColor {
  /// Formatting configuration for gradient color.
  final ConditionalFormattingGradientColor? gradient;

  /// Formatting configuration for solid color.
  final ConditionalFormattingSolidColor? solid;

  ConditionalFormattingColor({
    this.gradient,
    this.solid,
  });

  factory ConditionalFormattingColor.fromJson(Map<String, dynamic> json) {
    return ConditionalFormattingColor(
      gradient: json['Gradient'] != null
          ? ConditionalFormattingGradientColor.fromJson(
              json['Gradient'] as Map<String, dynamic>)
          : null,
      solid: json['Solid'] != null
          ? ConditionalFormattingSolidColor.fromJson(
              json['Solid'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final gradient = this.gradient;
    final solid = this.solid;
    return {
      if (gradient != null) 'Gradient': gradient,
      if (solid != null) 'Solid': solid,
    };
  }
}

/// Determines the custom condition for an icon set.
class ConditionalFormattingCustomIconCondition {
  /// The expression that determines the condition of the icon set.
  final String expression;

  /// Custom icon options for an icon set.
  final ConditionalFormattingCustomIconOptions iconOptions;

  /// Determines the color of the icon.
  final String? color;

  /// Determines the icon display configuration.
  final ConditionalFormattingIconDisplayConfiguration? displayConfiguration;

  ConditionalFormattingCustomIconCondition({
    required this.expression,
    required this.iconOptions,
    this.color,
    this.displayConfiguration,
  });

  factory ConditionalFormattingCustomIconCondition.fromJson(
      Map<String, dynamic> json) {
    return ConditionalFormattingCustomIconCondition(
      expression: json['Expression'] as String,
      iconOptions: ConditionalFormattingCustomIconOptions.fromJson(
          json['IconOptions'] as Map<String, dynamic>),
      color: json['Color'] as String?,
      displayConfiguration: json['DisplayConfiguration'] != null
          ? ConditionalFormattingIconDisplayConfiguration.fromJson(
              json['DisplayConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final iconOptions = this.iconOptions;
    final color = this.color;
    final displayConfiguration = this.displayConfiguration;
    return {
      'Expression': expression,
      'IconOptions': iconOptions,
      if (color != null) 'Color': color,
      if (displayConfiguration != null)
        'DisplayConfiguration': displayConfiguration,
    };
  }
}

/// Custom icon options for an icon set.
class ConditionalFormattingCustomIconOptions {
  /// Determines the type of icon.
  final Icon? icon;

  /// Determines the Unicode icon type.
  final String? unicodeIcon;

  ConditionalFormattingCustomIconOptions({
    this.icon,
    this.unicodeIcon,
  });

  factory ConditionalFormattingCustomIconOptions.fromJson(
      Map<String, dynamic> json) {
    return ConditionalFormattingCustomIconOptions(
      icon: (json['Icon'] as String?)?.toIcon(),
      unicodeIcon: json['UnicodeIcon'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final icon = this.icon;
    final unicodeIcon = this.unicodeIcon;
    return {
      if (icon != null) 'Icon': icon.toValue(),
      if (unicodeIcon != null) 'UnicodeIcon': unicodeIcon,
    };
  }
}

/// Formatting configuration for gradient color.
class ConditionalFormattingGradientColor {
  /// Determines the color.
  final GradientColor color;

  /// The expression that determines the formatting configuration for gradient
  /// color.
  final String expression;

  ConditionalFormattingGradientColor({
    required this.color,
    required this.expression,
  });

  factory ConditionalFormattingGradientColor.fromJson(
      Map<String, dynamic> json) {
    return ConditionalFormattingGradientColor(
      color: GradientColor.fromJson(json['Color'] as Map<String, dynamic>),
      expression: json['Expression'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final expression = this.expression;
    return {
      'Color': color,
      'Expression': expression,
    };
  }
}

/// The formatting configuration for the icon.
class ConditionalFormattingIcon {
  /// Determines the custom condition for an icon set.
  final ConditionalFormattingCustomIconCondition? customCondition;

  /// Formatting configuration for icon set.
  final ConditionalFormattingIconSet? iconSet;

  ConditionalFormattingIcon({
    this.customCondition,
    this.iconSet,
  });

  factory ConditionalFormattingIcon.fromJson(Map<String, dynamic> json) {
    return ConditionalFormattingIcon(
      customCondition: json['CustomCondition'] != null
          ? ConditionalFormattingCustomIconCondition.fromJson(
              json['CustomCondition'] as Map<String, dynamic>)
          : null,
      iconSet: json['IconSet'] != null
          ? ConditionalFormattingIconSet.fromJson(
              json['IconSet'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customCondition = this.customCondition;
    final iconSet = this.iconSet;
    return {
      if (customCondition != null) 'CustomCondition': customCondition,
      if (iconSet != null) 'IconSet': iconSet,
    };
  }
}

/// Determines the icon display configuration.
class ConditionalFormattingIconDisplayConfiguration {
  /// Determines the icon display configuration.
  final ConditionalFormattingIconDisplayOption? iconDisplayOption;

  ConditionalFormattingIconDisplayConfiguration({
    this.iconDisplayOption,
  });

  factory ConditionalFormattingIconDisplayConfiguration.fromJson(
      Map<String, dynamic> json) {
    return ConditionalFormattingIconDisplayConfiguration(
      iconDisplayOption: (json['IconDisplayOption'] as String?)
          ?.toConditionalFormattingIconDisplayOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final iconDisplayOption = this.iconDisplayOption;
    return {
      if (iconDisplayOption != null)
        'IconDisplayOption': iconDisplayOption.toValue(),
    };
  }
}

enum ConditionalFormattingIconDisplayOption {
  iconOnly,
}

extension ConditionalFormattingIconDisplayOptionValueExtension
    on ConditionalFormattingIconDisplayOption {
  String toValue() {
    switch (this) {
      case ConditionalFormattingIconDisplayOption.iconOnly:
        return 'ICON_ONLY';
    }
  }
}

extension ConditionalFormattingIconDisplayOptionFromString on String {
  ConditionalFormattingIconDisplayOption
      toConditionalFormattingIconDisplayOption() {
    switch (this) {
      case 'ICON_ONLY':
        return ConditionalFormattingIconDisplayOption.iconOnly;
    }
    throw Exception(
        '$this is not known in enum ConditionalFormattingIconDisplayOption');
  }
}

/// Formatting configuration for icon set.
class ConditionalFormattingIconSet {
  /// The expression that determines the formatting configuration for the icon
  /// set.
  final String expression;

  /// Determines the icon set type.
  final ConditionalFormattingIconSetType? iconSetType;

  ConditionalFormattingIconSet({
    required this.expression,
    this.iconSetType,
  });

  factory ConditionalFormattingIconSet.fromJson(Map<String, dynamic> json) {
    return ConditionalFormattingIconSet(
      expression: json['Expression'] as String,
      iconSetType: (json['IconSetType'] as String?)
          ?.toConditionalFormattingIconSetType(),
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final iconSetType = this.iconSetType;
    return {
      'Expression': expression,
      if (iconSetType != null) 'IconSetType': iconSetType.toValue(),
    };
  }
}

enum ConditionalFormattingIconSetType {
  plusMinus,
  checkX,
  threeColorArrow,
  threeGrayArrow,
  caretUpMinusDown,
  threeShape,
  threeCircle,
  flags,
  bars,
  fourColorArrow,
  fourGrayArrow,
}

extension ConditionalFormattingIconSetTypeValueExtension
    on ConditionalFormattingIconSetType {
  String toValue() {
    switch (this) {
      case ConditionalFormattingIconSetType.plusMinus:
        return 'PLUS_MINUS';
      case ConditionalFormattingIconSetType.checkX:
        return 'CHECK_X';
      case ConditionalFormattingIconSetType.threeColorArrow:
        return 'THREE_COLOR_ARROW';
      case ConditionalFormattingIconSetType.threeGrayArrow:
        return 'THREE_GRAY_ARROW';
      case ConditionalFormattingIconSetType.caretUpMinusDown:
        return 'CARET_UP_MINUS_DOWN';
      case ConditionalFormattingIconSetType.threeShape:
        return 'THREE_SHAPE';
      case ConditionalFormattingIconSetType.threeCircle:
        return 'THREE_CIRCLE';
      case ConditionalFormattingIconSetType.flags:
        return 'FLAGS';
      case ConditionalFormattingIconSetType.bars:
        return 'BARS';
      case ConditionalFormattingIconSetType.fourColorArrow:
        return 'FOUR_COLOR_ARROW';
      case ConditionalFormattingIconSetType.fourGrayArrow:
        return 'FOUR_GRAY_ARROW';
    }
  }
}

extension ConditionalFormattingIconSetTypeFromString on String {
  ConditionalFormattingIconSetType toConditionalFormattingIconSetType() {
    switch (this) {
      case 'PLUS_MINUS':
        return ConditionalFormattingIconSetType.plusMinus;
      case 'CHECK_X':
        return ConditionalFormattingIconSetType.checkX;
      case 'THREE_COLOR_ARROW':
        return ConditionalFormattingIconSetType.threeColorArrow;
      case 'THREE_GRAY_ARROW':
        return ConditionalFormattingIconSetType.threeGrayArrow;
      case 'CARET_UP_MINUS_DOWN':
        return ConditionalFormattingIconSetType.caretUpMinusDown;
      case 'THREE_SHAPE':
        return ConditionalFormattingIconSetType.threeShape;
      case 'THREE_CIRCLE':
        return ConditionalFormattingIconSetType.threeCircle;
      case 'FLAGS':
        return ConditionalFormattingIconSetType.flags;
      case 'BARS':
        return ConditionalFormattingIconSetType.bars;
      case 'FOUR_COLOR_ARROW':
        return ConditionalFormattingIconSetType.fourColorArrow;
      case 'FOUR_GRAY_ARROW':
        return ConditionalFormattingIconSetType.fourGrayArrow;
    }
    throw Exception(
        '$this is not known in enum ConditionalFormattingIconSetType');
  }
}

/// Formatting configuration for solid color.
class ConditionalFormattingSolidColor {
  /// The expression that determines the formatting configuration for solid color.
  final String expression;

  /// Determines the color.
  final String? color;

  ConditionalFormattingSolidColor({
    required this.expression,
    this.color,
  });

  factory ConditionalFormattingSolidColor.fromJson(Map<String, dynamic> json) {
    return ConditionalFormattingSolidColor(
      expression: json['Expression'] as String,
      color: json['Color'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final color = this.color;
    return {
      'Expression': expression,
      if (color != null) 'Color': color,
    };
  }
}

enum ConstantType {
  singular,
  range,
  collective,
}

extension ConstantTypeValueExtension on ConstantType {
  String toValue() {
    switch (this) {
      case ConstantType.singular:
        return 'SINGULAR';
      case ConstantType.range:
        return 'RANGE';
      case ConstantType.collective:
        return 'COLLECTIVE';
    }
  }
}

extension ConstantTypeFromString on String {
  ConstantType toConstantType() {
    switch (this) {
      case 'SINGULAR':
        return ConstantType.singular;
      case 'RANGE':
        return ConstantType.range;
      case 'COLLECTIVE':
        return ConstantType.collective;
    }
    throw Exception('$this is not known in enum ConstantType');
  }
}

/// The context menu options for a visual's interactions.
class ContextMenuOption {
  /// The availability status of the context menu options. If the value of this
  /// property is set to <code>ENABLED</code>, dashboard readers can interact with
  /// the context menu.
  final DashboardBehavior? availabilityStatus;

  ContextMenuOption({
    this.availabilityStatus,
  });

  factory ContextMenuOption.fromJson(Map<String, dynamic> json) {
    return ContextMenuOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// The contribution analysis visual display for a line, pie, or bar chart.
class ContributionAnalysisDefault {
  /// The dimensions columns that are used in the contribution analysis, usually a
  /// list of <code>ColumnIdentifiers</code>.
  final List<ColumnIdentifier> contributorDimensions;

  /// The measure field that is used in the contribution analysis.
  final String measureFieldId;

  ContributionAnalysisDefault({
    required this.contributorDimensions,
    required this.measureFieldId,
  });

  factory ContributionAnalysisDefault.fromJson(Map<String, dynamic> json) {
    return ContributionAnalysisDefault(
      contributorDimensions: (json['ContributorDimensions'] as List)
          .whereNotNull()
          .map((e) => ColumnIdentifier.fromJson(e as Map<String, dynamic>))
          .toList(),
      measureFieldId: json['MeasureFieldId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final contributorDimensions = this.contributorDimensions;
    final measureFieldId = this.measureFieldId;
    return {
      'ContributorDimensions': contributorDimensions,
      'MeasureFieldId': measureFieldId,
    };
  }
}

class CreateAccountCustomizationResponse {
  /// The Amazon QuickSight customizations you're adding in the current Amazon Web
  /// Services Region.
  final AccountCustomization? accountCustomization;

  /// The Amazon Resource Name (ARN) for the customization that you created for
  /// this Amazon Web Services account.
  final String? arn;

  /// The ID for the Amazon Web Services account that you want to customize Amazon
  /// QuickSight for.
  final String? awsAccountId;

  /// The namespace associated with the customization you're creating.
  final String? namespace;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateAccountCustomizationResponse({
    this.accountCustomization,
    this.arn,
    this.awsAccountId,
    this.namespace,
    this.requestId,
    this.status,
  });

  factory CreateAccountCustomizationResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateAccountCustomizationResponse(
      accountCustomization: json['AccountCustomization'] != null
          ? AccountCustomization.fromJson(
              json['AccountCustomization'] as Map<String, dynamic>)
          : null,
      arn: json['Arn'] as String?,
      awsAccountId: json['AwsAccountId'] as String?,
      namespace: json['Namespace'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountCustomization = this.accountCustomization;
    final arn = this.arn;
    final awsAccountId = this.awsAccountId;
    final namespace = this.namespace;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (accountCustomization != null)
        'AccountCustomization': accountCustomization,
      if (arn != null) 'Arn': arn,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (namespace != null) 'Namespace': namespace,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateAccountSubscriptionResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// A <code>SignupResponse</code> object that returns information about a newly
  /// created Amazon QuickSight account.
  final SignupResponse? signupResponse;

  /// The HTTP status of the request.
  final int? status;

  CreateAccountSubscriptionResponse({
    this.requestId,
    this.signupResponse,
    this.status,
  });

  factory CreateAccountSubscriptionResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateAccountSubscriptionResponse(
      requestId: json['RequestId'] as String?,
      signupResponse: json['SignupResponse'] != null
          ? SignupResponse.fromJson(
              json['SignupResponse'] as Map<String, dynamic>)
          : null,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final signupResponse = this.signupResponse;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (signupResponse != null) 'SignupResponse': signupResponse,
    };
  }
}

class CreateAnalysisResponse {
  /// The ID of the analysis.
  final String? analysisId;

  /// The ARN for the analysis.
  final String? arn;

  /// The status of the creation of the analysis.
  final ResourceStatus? creationStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateAnalysisResponse({
    this.analysisId,
    this.arn,
    this.creationStatus,
    this.requestId,
    this.status,
  });

  factory CreateAnalysisResponse.fromJson(Map<String, dynamic> json) {
    return CreateAnalysisResponse(
      analysisId: json['AnalysisId'] as String?,
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// A transform operation that creates calculated columns. Columns created in
/// one such operation form a lexical closure.
class CreateColumnsOperation {
  /// Calculated columns to create.
  final List<CalculatedColumn> columns;

  CreateColumnsOperation({
    required this.columns,
  });

  factory CreateColumnsOperation.fromJson(Map<String, dynamic> json) {
    return CreateColumnsOperation(
      columns: (json['Columns'] as List)
          .whereNotNull()
          .map((e) => CalculatedColumn.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    return {
      'Columns': columns,
    };
  }
}

class CreateDashboardResponse {
  /// The ARN of the dashboard.
  final String? arn;

  /// The status of the dashboard creation request.
  final ResourceStatus? creationStatus;

  /// The ID for the dashboard.
  final String? dashboardId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ARN of the dashboard, including the version number of the first version
  /// that is created.
  final String? versionArn;

  CreateDashboardResponse({
    this.arn,
    this.creationStatus,
    this.dashboardId,
    this.requestId,
    this.status,
    this.versionArn,
  });

  factory CreateDashboardResponse.fromJson(Map<String, dynamic> json) {
    return CreateDashboardResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      dashboardId: json['DashboardId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      versionArn: json['VersionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final dashboardId = this.dashboardId;
    final requestId = this.requestId;
    final status = this.status;
    final versionArn = this.versionArn;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (requestId != null) 'RequestId': requestId,
      if (versionArn != null) 'VersionArn': versionArn,
    };
  }
}

class CreateDataSetResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? arn;

  /// The ID for the dataset that you want to create. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? dataSetId;

  /// The ARN for the ingestion, which is triggered as a result of dataset
  /// creation if the import mode is SPICE.
  final String? ingestionArn;

  /// The ID of the ingestion, which is triggered as a result of dataset creation
  /// if the import mode is SPICE.
  final String? ingestionId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateDataSetResponse({
    this.arn,
    this.dataSetId,
    this.ingestionArn,
    this.ingestionId,
    this.requestId,
    this.status,
  });

  factory CreateDataSetResponse.fromJson(Map<String, dynamic> json) {
    return CreateDataSetResponse(
      arn: json['Arn'] as String?,
      dataSetId: json['DataSetId'] as String?,
      ingestionArn: json['IngestionArn'] as String?,
      ingestionId: json['IngestionId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSetId = this.dataSetId;
    final ingestionArn = this.ingestionArn;
    final ingestionId = this.ingestionId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (ingestionArn != null) 'IngestionArn': ingestionArn,
      if (ingestionId != null) 'IngestionId': ingestionId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateDataSourceResponse {
  /// The Amazon Resource Name (ARN) of the data source.
  final String? arn;

  /// The status of creating the data source.
  final ResourceStatus? creationStatus;

  /// The ID of the data source. This ID is unique per Amazon Web Services Region
  /// for each Amazon Web Services account.
  final String? dataSourceId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateDataSourceResponse({
    this.arn,
    this.creationStatus,
    this.dataSourceId,
    this.requestId,
    this.status,
  });

  factory CreateDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return CreateDataSourceResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      dataSourceId: json['DataSourceId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final dataSourceId = this.dataSourceId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateFolderMembershipResponse {
  /// Information about the member in the folder.
  final FolderMember? folderMember;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateFolderMembershipResponse({
    this.folderMember,
    this.requestId,
    this.status,
  });

  factory CreateFolderMembershipResponse.fromJson(Map<String, dynamic> json) {
    return CreateFolderMembershipResponse(
      folderMember: json['FolderMember'] != null
          ? FolderMember.fromJson(json['FolderMember'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final folderMember = this.folderMember;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (folderMember != null) 'FolderMember': folderMember,
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class CreateFolderResponse {
  /// The Amazon Resource Name (ARN) for the newly created folder.
  final String? arn;

  /// The folder ID for the newly created folder.
  final String? folderId;

  /// The request ID for the newly created folder.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateFolderResponse({
    this.arn,
    this.folderId,
    this.requestId,
    this.status,
  });

  factory CreateFolderResponse.fromJson(Map<String, dynamic> json) {
    return CreateFolderResponse(
      arn: json['Arn'] as String?,
      folderId: json['FolderId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final folderId = this.folderId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (folderId != null) 'FolderId': folderId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateGroupMembershipResponse {
  /// The group member.
  final GroupMember? groupMember;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateGroupMembershipResponse({
    this.groupMember,
    this.requestId,
    this.status,
  });

  factory CreateGroupMembershipResponse.fromJson(Map<String, dynamic> json) {
    return CreateGroupMembershipResponse(
      groupMember: json['GroupMember'] != null
          ? GroupMember.fromJson(json['GroupMember'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupMember = this.groupMember;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (groupMember != null) 'GroupMember': groupMember,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// The response object for this operation.
class CreateGroupResponse {
  /// The name of the group.
  final Group? group;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateGroupResponse({
    this.group,
    this.requestId,
    this.status,
  });

  factory CreateGroupResponse.fromJson(Map<String, dynamic> json) {
    return CreateGroupResponse(
      group: json['Group'] != null
          ? Group.fromJson(json['Group'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final group = this.group;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (group != null) 'Group': group,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateIAMPolicyAssignmentResponse {
  /// The ID for the assignment.
  final String? assignmentId;

  /// The name of the assignment. The name must be unique within the Amazon Web
  /// Services account.
  final String? assignmentName;

  /// The status of the assignment. Possible values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ENABLED</code> - Anything specified in this assignment is used when
  /// creating the data source.
  /// </li>
  /// <li>
  /// <code>DISABLED</code> - This assignment isn't used when creating the data
  /// source.
  /// </li>
  /// <li>
  /// <code>DRAFT</code> - This assignment is an unfinished draft and isn't used
  /// when creating the data source.
  /// </li>
  /// </ul>
  final AssignmentStatus? assignmentStatus;

  /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned
  /// to.
  final Map<String, List<String>>? identities;

  /// The ARN for the IAM policy that is applied to the Amazon QuickSight users
  /// and groups specified in this assignment.
  final String? policyArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateIAMPolicyAssignmentResponse({
    this.assignmentId,
    this.assignmentName,
    this.assignmentStatus,
    this.identities,
    this.policyArn,
    this.requestId,
    this.status,
  });

  factory CreateIAMPolicyAssignmentResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateIAMPolicyAssignmentResponse(
      assignmentId: json['AssignmentId'] as String?,
      assignmentName: json['AssignmentName'] as String?,
      assignmentStatus:
          (json['AssignmentStatus'] as String?)?.toAssignmentStatus(),
      identities: (json['Identities'] as Map<String, dynamic>?)?.map((k, e) =>
          MapEntry(
              k, (e as List).whereNotNull().map((e) => e as String).toList())),
      policyArn: json['PolicyArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final assignmentId = this.assignmentId;
    final assignmentName = this.assignmentName;
    final assignmentStatus = this.assignmentStatus;
    final identities = this.identities;
    final policyArn = this.policyArn;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (assignmentId != null) 'AssignmentId': assignmentId,
      if (assignmentName != null) 'AssignmentName': assignmentName,
      if (assignmentStatus != null)
        'AssignmentStatus': assignmentStatus.toValue(),
      if (identities != null) 'Identities': identities,
      if (policyArn != null) 'PolicyArn': policyArn,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateIngestionResponse {
  /// The Amazon Resource Name (ARN) for the data ingestion.
  final String? arn;

  /// An ID for the ingestion.
  final String? ingestionId;

  /// The ingestion status.
  final IngestionStatus? ingestionStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateIngestionResponse({
    this.arn,
    this.ingestionId,
    this.ingestionStatus,
    this.requestId,
    this.status,
  });

  factory CreateIngestionResponse.fromJson(Map<String, dynamic> json) {
    return CreateIngestionResponse(
      arn: json['Arn'] as String?,
      ingestionId: json['IngestionId'] as String?,
      ingestionStatus:
          (json['IngestionStatus'] as String?)?.toIngestionStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final ingestionId = this.ingestionId;
    final ingestionStatus = this.ingestionStatus;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (ingestionId != null) 'IngestionId': ingestionId,
      if (ingestionStatus != null) 'IngestionStatus': ingestionStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateNamespaceResponse {
  /// The ARN of the Amazon QuickSight namespace you created.
  final String? arn;

  /// The Amazon Web Services Region; that you want to use for the free SPICE
  /// capacity for the new namespace. This is set to the region that you run
  /// CreateNamespace in.
  final String? capacityRegion;

  /// The status of the creation of the namespace. This is an asynchronous
  /// process. A status of <code>CREATED</code> means that your namespace is ready
  /// to use. If an error occurs, it indicates if the process is
  /// <code>retryable</code> or <code>non-retryable</code>. In the case of a
  /// non-retryable error, refer to the error message for follow-up tasks.
  final NamespaceStatus? creationStatus;

  /// Specifies the type of your user identity directory. Currently, this supports
  /// users with an identity type of <code>QUICKSIGHT</code>.
  final IdentityStore? identityStore;

  /// The name of the new namespace that you created.
  final String? name;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateNamespaceResponse({
    this.arn,
    this.capacityRegion,
    this.creationStatus,
    this.identityStore,
    this.name,
    this.requestId,
    this.status,
  });

  factory CreateNamespaceResponse.fromJson(Map<String, dynamic> json) {
    return CreateNamespaceResponse(
      arn: json['Arn'] as String?,
      capacityRegion: json['CapacityRegion'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toNamespaceStatus(),
      identityStore: (json['IdentityStore'] as String?)?.toIdentityStore(),
      name: json['Name'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final capacityRegion = this.capacityRegion;
    final creationStatus = this.creationStatus;
    final identityStore = this.identityStore;
    final name = this.name;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (capacityRegion != null) 'CapacityRegion': capacityRegion,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (identityStore != null) 'IdentityStore': identityStore.toValue(),
      if (name != null) 'Name': name,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) for the refresh schedule.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The ID of the refresh schedule.
  final String? scheduleId;

  /// The HTTP status of the request.
  final int? status;

  CreateRefreshScheduleResponse({
    this.arn,
    this.requestId,
    this.scheduleId,
    this.status,
  });

  factory CreateRefreshScheduleResponse.fromJson(Map<String, dynamic> json) {
    return CreateRefreshScheduleResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      scheduleId: json['ScheduleId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final scheduleId = this.scheduleId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (scheduleId != null) 'ScheduleId': scheduleId,
    };
  }
}

class CreateRoleMembershipResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  CreateRoleMembershipResponse({
    this.requestId,
    this.status,
  });

  factory CreateRoleMembershipResponse.fromJson(Map<String, dynamic> json) {
    return CreateRoleMembershipResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class CreateTemplateAliasResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Information about the template alias.
  final TemplateAlias? templateAlias;

  CreateTemplateAliasResponse({
    this.requestId,
    this.status,
    this.templateAlias,
  });

  factory CreateTemplateAliasResponse.fromJson(Map<String, dynamic> json) {
    return CreateTemplateAliasResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateAlias: json['TemplateAlias'] != null
          ? TemplateAlias.fromJson(
              json['TemplateAlias'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final templateAlias = this.templateAlias;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (templateAlias != null) 'TemplateAlias': templateAlias,
    };
  }
}

class CreateTemplateResponse {
  /// The ARN for the template.
  final String? arn;

  /// The template creation status.
  final ResourceStatus? creationStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID of the template.
  final String? templateId;

  /// The ARN for the template, including the version information of the first
  /// version.
  final String? versionArn;

  CreateTemplateResponse({
    this.arn,
    this.creationStatus,
    this.requestId,
    this.status,
    this.templateId,
    this.versionArn,
  });

  factory CreateTemplateResponse.fromJson(Map<String, dynamic> json) {
    return CreateTemplateResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateId: json['TemplateId'] as String?,
      versionArn: json['VersionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final requestId = this.requestId;
    final status = this.status;
    final templateId = this.templateId;
    final versionArn = this.versionArn;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (templateId != null) 'TemplateId': templateId,
      if (versionArn != null) 'VersionArn': versionArn,
    };
  }
}

class CreateThemeAliasResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Information about the theme alias.
  final ThemeAlias? themeAlias;

  CreateThemeAliasResponse({
    this.requestId,
    this.status,
    this.themeAlias,
  });

  factory CreateThemeAliasResponse.fromJson(Map<String, dynamic> json) {
    return CreateThemeAliasResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeAlias: json['ThemeAlias'] != null
          ? ThemeAlias.fromJson(json['ThemeAlias'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final themeAlias = this.themeAlias;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (themeAlias != null) 'ThemeAlias': themeAlias,
    };
  }
}

class CreateThemeResponse {
  /// The Amazon Resource Name (ARN) for the theme.
  final String? arn;

  /// The theme creation status.
  final ResourceStatus? creationStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID of the theme.
  final String? themeId;

  /// The Amazon Resource Name (ARN) for the new theme.
  final String? versionArn;

  CreateThemeResponse({
    this.arn,
    this.creationStatus,
    this.requestId,
    this.status,
    this.themeId,
    this.versionArn,
  });

  factory CreateThemeResponse.fromJson(Map<String, dynamic> json) {
    return CreateThemeResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeId: json['ThemeId'] as String?,
      versionArn: json['VersionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final requestId = this.requestId;
    final status = this.status;
    final themeId = this.themeId;
    final versionArn = this.versionArn;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (themeId != null) 'ThemeId': themeId,
      if (versionArn != null) 'VersionArn': versionArn,
    };
  }
}

class CreateTopicRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? datasetArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  CreateTopicRefreshScheduleResponse({
    this.datasetArn,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory CreateTopicRefreshScheduleResponse.fromJson(
      Map<String, dynamic> json) {
    return CreateTopicRefreshScheduleResponse(
      datasetArn: json['DatasetArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final datasetArn = this.datasetArn;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (datasetArn != null) 'DatasetArn': datasetArn,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class CreateTopicResponse {
  /// The Amazon Resource Name (ARN) of the topic.
  final String? arn;

  /// The Amazon Resource Name (ARN) of the topic refresh.
  final String? refreshArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID for the topic that you want to create. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  CreateTopicResponse({
    this.arn,
    this.refreshArn,
    this.requestId,
    this.status,
    this.topicId,
  });

  factory CreateTopicResponse.fromJson(Map<String, dynamic> json) {
    return CreateTopicResponse(
      arn: json['Arn'] as String?,
      refreshArn: json['RefreshArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final refreshArn = this.refreshArn;
    final requestId = this.requestId;
    final status = this.status;
    final topicId = this.topicId;
    return {
      if (arn != null) 'Arn': arn,
      if (refreshArn != null) 'RefreshArn': refreshArn,
      if (requestId != null) 'RequestId': requestId,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class CreateVPCConnectionResponse {
  /// The Amazon Resource Name (ARN) of the VPC connection.
  final String? arn;

  /// The availability status of the VPC connection.
  final VPCConnectionAvailabilityStatus? availabilityStatus;

  /// The status of the creation of the VPC connection.
  final VPCConnectionResourceStatus? creationStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID for the VPC connection that you're creating. This ID is unique per
  /// Amazon Web Services Region for each Amazon Web Services account.
  final String? vPCConnectionId;

  CreateVPCConnectionResponse({
    this.arn,
    this.availabilityStatus,
    this.creationStatus,
    this.requestId,
    this.status,
    this.vPCConnectionId,
  });

  factory CreateVPCConnectionResponse.fromJson(Map<String, dynamic> json) {
    return CreateVPCConnectionResponse(
      arn: json['Arn'] as String?,
      availabilityStatus: (json['AvailabilityStatus'] as String?)
          ?.toVPCConnectionAvailabilityStatus(),
      creationStatus:
          (json['CreationStatus'] as String?)?.toVPCConnectionResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      vPCConnectionId: json['VPCConnectionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final availabilityStatus = this.availabilityStatus;
    final creationStatus = this.creationStatus;
    final requestId = this.requestId;
    final status = this.status;
    final vPCConnectionId = this.vPCConnectionId;
    return {
      if (arn != null) 'Arn': arn,
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (vPCConnectionId != null) 'VPCConnectionId': vPCConnectionId,
    };
  }
}

/// The combination of user name and password that are used as credentials.
class CredentialPair {
  /// Password.
  final String password;

  /// User name.
  final String username;

  /// A set of alternate data source parameters that you want to share for these
  /// credentials. The credentials are applied in tandem with the data source
  /// parameters when you copy a data source by using a create or update request.
  /// The API operation compares the <code>DataSourceParameters</code> structure
  /// that's in the request with the structures in the
  /// <code>AlternateDataSourceParameters</code> allow list. If the structures are
  /// an exact match, the request is allowed to use the new data source with the
  /// existing credentials. If the <code>AlternateDataSourceParameters</code> list
  /// is null, the <code>DataSourceParameters</code> originally used with these
  /// <code>Credentials</code> is automatically allowed.
  final List<DataSourceParameters>? alternateDataSourceParameters;

  CredentialPair({
    required this.password,
    required this.username,
    this.alternateDataSourceParameters,
  });

  Map<String, dynamic> toJson() {
    final password = this.password;
    final username = this.username;
    final alternateDataSourceParameters = this.alternateDataSourceParameters;
    return {
      'Password': password,
      'Username': username,
      if (alternateDataSourceParameters != null)
        'AlternateDataSourceParameters': alternateDataSourceParameters,
    };
  }
}

enum CrossDatasetTypes {
  allDatasets,
  singleDataset,
}

extension CrossDatasetTypesValueExtension on CrossDatasetTypes {
  String toValue() {
    switch (this) {
      case CrossDatasetTypes.allDatasets:
        return 'ALL_DATASETS';
      case CrossDatasetTypes.singleDataset:
        return 'SINGLE_DATASET';
    }
  }
}

extension CrossDatasetTypesFromString on String {
  CrossDatasetTypes toCrossDatasetTypes() {
    switch (this) {
      case 'ALL_DATASETS':
        return CrossDatasetTypes.allDatasets;
      case 'SINGLE_DATASET':
        return CrossDatasetTypes.singleDataset;
    }
    throw Exception('$this is not known in enum CrossDatasetTypes');
  }
}

/// The options that determine the currency display format configuration.
class CurrencyDisplayFormatConfiguration {
  /// The option that determines the decimal places configuration.
  final DecimalPlacesConfiguration? decimalPlacesConfiguration;

  /// The options that determine the negative value configuration.
  final NegativeValueConfiguration? negativeValueConfiguration;

  /// The options that determine the null value format configuration.
  final NullValueFormatConfiguration? nullValueFormatConfiguration;

  /// Determines the number scale value for the currency format.
  final NumberScale? numberScale;

  /// Determines the prefix value of the currency format.
  final String? prefix;

  /// The options that determine the numeric separator configuration.
  final NumericSeparatorConfiguration? separatorConfiguration;

  /// Determines the suffix value of the currency format.
  final String? suffix;

  /// Determines the symbol for the currency format.
  final String? symbol;

  CurrencyDisplayFormatConfiguration({
    this.decimalPlacesConfiguration,
    this.negativeValueConfiguration,
    this.nullValueFormatConfiguration,
    this.numberScale,
    this.prefix,
    this.separatorConfiguration,
    this.suffix,
    this.symbol,
  });

  factory CurrencyDisplayFormatConfiguration.fromJson(
      Map<String, dynamic> json) {
    return CurrencyDisplayFormatConfiguration(
      decimalPlacesConfiguration: json['DecimalPlacesConfiguration'] != null
          ? DecimalPlacesConfiguration.fromJson(
              json['DecimalPlacesConfiguration'] as Map<String, dynamic>)
          : null,
      negativeValueConfiguration: json['NegativeValueConfiguration'] != null
          ? NegativeValueConfiguration.fromJson(
              json['NegativeValueConfiguration'] as Map<String, dynamic>)
          : null,
      nullValueFormatConfiguration: json['NullValueFormatConfiguration'] != null
          ? NullValueFormatConfiguration.fromJson(
              json['NullValueFormatConfiguration'] as Map<String, dynamic>)
          : null,
      numberScale: (json['NumberScale'] as String?)?.toNumberScale(),
      prefix: json['Prefix'] as String?,
      separatorConfiguration: json['SeparatorConfiguration'] != null
          ? NumericSeparatorConfiguration.fromJson(
              json['SeparatorConfiguration'] as Map<String, dynamic>)
          : null,
      suffix: json['Suffix'] as String?,
      symbol: json['Symbol'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final decimalPlacesConfiguration = this.decimalPlacesConfiguration;
    final negativeValueConfiguration = this.negativeValueConfiguration;
    final nullValueFormatConfiguration = this.nullValueFormatConfiguration;
    final numberScale = this.numberScale;
    final prefix = this.prefix;
    final separatorConfiguration = this.separatorConfiguration;
    final suffix = this.suffix;
    final symbol = this.symbol;
    return {
      if (decimalPlacesConfiguration != null)
        'DecimalPlacesConfiguration': decimalPlacesConfiguration,
      if (negativeValueConfiguration != null)
        'NegativeValueConfiguration': negativeValueConfiguration,
      if (nullValueFormatConfiguration != null)
        'NullValueFormatConfiguration': nullValueFormatConfiguration,
      if (numberScale != null) 'NumberScale': numberScale.toValue(),
      if (prefix != null) 'Prefix': prefix,
      if (separatorConfiguration != null)
        'SeparatorConfiguration': separatorConfiguration,
      if (suffix != null) 'Suffix': suffix,
      if (symbol != null) 'Symbol': symbol,
    };
  }
}

/// The filter operation that filters data included in a visual or in an entire
/// sheet.
class CustomActionFilterOperation {
  /// The configuration that chooses the fields to be filtered.
  final FilterOperationSelectedFieldsConfiguration selectedFieldsConfiguration;

  /// The configuration that chooses the target visuals to be filtered.
  final FilterOperationTargetVisualsConfiguration targetVisualsConfiguration;

  CustomActionFilterOperation({
    required this.selectedFieldsConfiguration,
    required this.targetVisualsConfiguration,
  });

  factory CustomActionFilterOperation.fromJson(Map<String, dynamic> json) {
    return CustomActionFilterOperation(
      selectedFieldsConfiguration:
          FilterOperationSelectedFieldsConfiguration.fromJson(
              json['SelectedFieldsConfiguration'] as Map<String, dynamic>),
      targetVisualsConfiguration:
          FilterOperationTargetVisualsConfiguration.fromJson(
              json['TargetVisualsConfiguration'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final selectedFieldsConfiguration = this.selectedFieldsConfiguration;
    final targetVisualsConfiguration = this.targetVisualsConfiguration;
    return {
      'SelectedFieldsConfiguration': selectedFieldsConfiguration,
      'TargetVisualsConfiguration': targetVisualsConfiguration,
    };
  }
}

/// The navigation operation that navigates between different sheets in the same
/// analysis.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class CustomActionNavigationOperation {
  /// The configuration that chooses the navigation target.
  final LocalNavigationConfiguration? localNavigationConfiguration;

  CustomActionNavigationOperation({
    this.localNavigationConfiguration,
  });

  factory CustomActionNavigationOperation.fromJson(Map<String, dynamic> json) {
    return CustomActionNavigationOperation(
      localNavigationConfiguration: json['LocalNavigationConfiguration'] != null
          ? LocalNavigationConfiguration.fromJson(
              json['LocalNavigationConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final localNavigationConfiguration = this.localNavigationConfiguration;
    return {
      if (localNavigationConfiguration != null)
        'LocalNavigationConfiguration': localNavigationConfiguration,
    };
  }
}

/// The set parameter operation that sets parameters in custom action.
class CustomActionSetParametersOperation {
  /// The parameter that determines the value configuration.
  final List<SetParameterValueConfiguration> parameterValueConfigurations;

  CustomActionSetParametersOperation({
    required this.parameterValueConfigurations,
  });

  factory CustomActionSetParametersOperation.fromJson(
      Map<String, dynamic> json) {
    return CustomActionSetParametersOperation(
      parameterValueConfigurations:
          (json['ParameterValueConfigurations'] as List)
              .whereNotNull()
              .map((e) => SetParameterValueConfiguration.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final parameterValueConfigurations = this.parameterValueConfigurations;
    return {
      'ParameterValueConfigurations': parameterValueConfigurations,
    };
  }
}

/// The URL operation that opens a link to another webpage.
class CustomActionURLOperation {
  /// The target of the <code>CustomActionURLOperation</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>NEW_TAB</code>: Opens the target URL in a new browser tab.
  /// </li>
  /// <li>
  /// <code>NEW_WINDOW</code>: Opens the target URL in a new browser window.
  /// </li>
  /// <li>
  /// <code>SAME_TAB</code>: Opens the target URL in the same browser tab.
  /// </li>
  /// </ul>
  final URLTargetConfiguration uRLTarget;

  /// THe URL link of the <code>CustomActionURLOperation</code>.
  final String uRLTemplate;

  CustomActionURLOperation({
    required this.uRLTarget,
    required this.uRLTemplate,
  });

  factory CustomActionURLOperation.fromJson(Map<String, dynamic> json) {
    return CustomActionURLOperation(
      uRLTarget: (json['URLTarget'] as String).toURLTargetConfiguration(),
      uRLTemplate: json['URLTemplate'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final uRLTarget = this.uRLTarget;
    final uRLTemplate = this.uRLTemplate;
    return {
      'URLTarget': uRLTarget.toValue(),
      'URLTemplate': uRLTemplate,
    };
  }
}

/// Determines the color that's applied to a particular data value in a column.
class CustomColor {
  /// The color that is applied to the data value.
  final String color;

  /// The data value that the color is applied to.
  final String? fieldValue;

  /// The value of a special data value.
  final SpecialValue? specialValue;

  CustomColor({
    required this.color,
    this.fieldValue,
    this.specialValue,
  });

  factory CustomColor.fromJson(Map<String, dynamic> json) {
    return CustomColor(
      color: json['Color'] as String,
      fieldValue: json['FieldValue'] as String?,
      specialValue: (json['SpecialValue'] as String?)?.toSpecialValue(),
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final fieldValue = this.fieldValue;
    final specialValue = this.specialValue;
    return {
      'Color': color,
      if (fieldValue != null) 'FieldValue': fieldValue,
      if (specialValue != null) 'SpecialValue': specialValue.toValue(),
    };
  }
}

/// The configuration of a <code>CustomContentVisual</code>.
class CustomContentConfiguration {
  /// The content type of the custom content visual. You can use this to have the
  /// visual render as an image.
  final CustomContentType? contentType;

  /// The input URL that links to the custom content that you want in the custom
  /// visual.
  final String? contentUrl;

  /// The sizing options for the size of the custom content visual. This structure
  /// is required when the <code>ContentType</code> of the visual is
  /// <code>'IMAGE'</code>.
  final CustomContentImageScalingConfiguration? imageScaling;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  CustomContentConfiguration({
    this.contentType,
    this.contentUrl,
    this.imageScaling,
    this.interactions,
  });

  factory CustomContentConfiguration.fromJson(Map<String, dynamic> json) {
    return CustomContentConfiguration(
      contentType: (json['ContentType'] as String?)?.toCustomContentType(),
      contentUrl: json['ContentUrl'] as String?,
      imageScaling: (json['ImageScaling'] as String?)
          ?.toCustomContentImageScalingConfiguration(),
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contentType = this.contentType;
    final contentUrl = this.contentUrl;
    final imageScaling = this.imageScaling;
    final interactions = this.interactions;
    return {
      if (contentType != null) 'ContentType': contentType.toValue(),
      if (contentUrl != null) 'ContentUrl': contentUrl,
      if (imageScaling != null) 'ImageScaling': imageScaling.toValue(),
      if (interactions != null) 'Interactions': interactions,
    };
  }
}

enum CustomContentImageScalingConfiguration {
  fitToHeight,
  fitToWidth,
  doNotScale,
  scaleToVisual,
}

extension CustomContentImageScalingConfigurationValueExtension
    on CustomContentImageScalingConfiguration {
  String toValue() {
    switch (this) {
      case CustomContentImageScalingConfiguration.fitToHeight:
        return 'FIT_TO_HEIGHT';
      case CustomContentImageScalingConfiguration.fitToWidth:
        return 'FIT_TO_WIDTH';
      case CustomContentImageScalingConfiguration.doNotScale:
        return 'DO_NOT_SCALE';
      case CustomContentImageScalingConfiguration.scaleToVisual:
        return 'SCALE_TO_VISUAL';
    }
  }
}

extension CustomContentImageScalingConfigurationFromString on String {
  CustomContentImageScalingConfiguration
      toCustomContentImageScalingConfiguration() {
    switch (this) {
      case 'FIT_TO_HEIGHT':
        return CustomContentImageScalingConfiguration.fitToHeight;
      case 'FIT_TO_WIDTH':
        return CustomContentImageScalingConfiguration.fitToWidth;
      case 'DO_NOT_SCALE':
        return CustomContentImageScalingConfiguration.doNotScale;
      case 'SCALE_TO_VISUAL':
        return CustomContentImageScalingConfiguration.scaleToVisual;
    }
    throw Exception(
        '$this is not known in enum CustomContentImageScalingConfiguration');
  }
}

enum CustomContentType {
  image,
  otherEmbeddedContent,
}

extension CustomContentTypeValueExtension on CustomContentType {
  String toValue() {
    switch (this) {
      case CustomContentType.image:
        return 'IMAGE';
      case CustomContentType.otherEmbeddedContent:
        return 'OTHER_EMBEDDED_CONTENT';
    }
  }
}

extension CustomContentTypeFromString on String {
  CustomContentType toCustomContentType() {
    switch (this) {
      case 'IMAGE':
        return CustomContentType.image;
      case 'OTHER_EMBEDDED_CONTENT':
        return CustomContentType.otherEmbeddedContent;
    }
    throw Exception('$this is not known in enum CustomContentType');
  }
}

/// A visual that contains custom content.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using
/// custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.
class CustomContentVisual {
  /// The dataset that is used to create the custom content visual. You can't
  /// create a visual without a dataset.
  final String dataSetIdentifier;

  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a <code>CustomContentVisual</code>.
  final CustomContentConfiguration? chartConfiguration;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  CustomContentVisual({
    required this.dataSetIdentifier,
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.subtitle,
    this.title,
  });

  factory CustomContentVisual.fromJson(Map<String, dynamic> json) {
    return CustomContentVisual(
      dataSetIdentifier: json['DataSetIdentifier'] as String,
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? CustomContentConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifier = this.dataSetIdentifier;
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'DataSetIdentifier': dataSetIdentifier,
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// A custom filter that filters based on a single value. This filter can be
/// partially matched.
class CustomFilterConfiguration {
  /// The match operator that is used to determine if a filter should be applied.
  final CategoryFilterMatchOperator matchOperator;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption nullOption;

  /// The category value for the filter.
  ///
  /// This field is mutually exclusive to <code>ParameterName</code>.
  final String? categoryValue;

  /// The parameter whose value should be used for the filter value.
  ///
  /// This field is mutually exclusive to <code>CategoryValue</code>.
  final String? parameterName;

  /// Select all of the values. Null is not the assigned value of select all.
  ///
  /// <ul>
  /// <li>
  /// <code>FILTER_ALL_VALUES</code>
  /// </li>
  /// </ul>
  final CategoryFilterSelectAllOptions? selectAllOptions;

  CustomFilterConfiguration({
    required this.matchOperator,
    required this.nullOption,
    this.categoryValue,
    this.parameterName,
    this.selectAllOptions,
  });

  factory CustomFilterConfiguration.fromJson(Map<String, dynamic> json) {
    return CustomFilterConfiguration(
      matchOperator:
          (json['MatchOperator'] as String).toCategoryFilterMatchOperator(),
      nullOption: (json['NullOption'] as String).toFilterNullOption(),
      categoryValue: json['CategoryValue'] as String?,
      parameterName: json['ParameterName'] as String?,
      selectAllOptions: (json['SelectAllOptions'] as String?)
          ?.toCategoryFilterSelectAllOptions(),
    );
  }

  Map<String, dynamic> toJson() {
    final matchOperator = this.matchOperator;
    final nullOption = this.nullOption;
    final categoryValue = this.categoryValue;
    final parameterName = this.parameterName;
    final selectAllOptions = this.selectAllOptions;
    return {
      'MatchOperator': matchOperator.toValue(),
      'NullOption': nullOption.toValue(),
      if (categoryValue != null) 'CategoryValue': categoryValue,
      if (parameterName != null) 'ParameterName': parameterName,
      if (selectAllOptions != null)
        'SelectAllOptions': selectAllOptions.toValue(),
    };
  }
}

/// A list of custom filter values.
class CustomFilterListConfiguration {
  /// The match operator that is used to determine if a filter should be applied.
  final CategoryFilterMatchOperator matchOperator;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption nullOption;

  /// The list of category values for the filter.
  final List<String>? categoryValues;

  /// Select all of the values. Null is not the assigned value of select all.
  ///
  /// <ul>
  /// <li>
  /// <code>FILTER_ALL_VALUES</code>
  /// </li>
  /// </ul>
  final CategoryFilterSelectAllOptions? selectAllOptions;

  CustomFilterListConfiguration({
    required this.matchOperator,
    required this.nullOption,
    this.categoryValues,
    this.selectAllOptions,
  });

  factory CustomFilterListConfiguration.fromJson(Map<String, dynamic> json) {
    return CustomFilterListConfiguration(
      matchOperator:
          (json['MatchOperator'] as String).toCategoryFilterMatchOperator(),
      nullOption: (json['NullOption'] as String).toFilterNullOption(),
      categoryValues: (json['CategoryValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      selectAllOptions: (json['SelectAllOptions'] as String?)
          ?.toCategoryFilterSelectAllOptions(),
    );
  }

  Map<String, dynamic> toJson() {
    final matchOperator = this.matchOperator;
    final nullOption = this.nullOption;
    final categoryValues = this.categoryValues;
    final selectAllOptions = this.selectAllOptions;
    return {
      'MatchOperator': matchOperator.toValue(),
      'NullOption': nullOption.toValue(),
      if (categoryValues != null) 'CategoryValues': categoryValues,
      if (selectAllOptions != null)
        'SelectAllOptions': selectAllOptions.toValue(),
    };
  }
}

/// The custom narrative options.
class CustomNarrativeOptions {
  /// The string input of custom narrative.
  final String narrative;

  CustomNarrativeOptions({
    required this.narrative,
  });

  factory CustomNarrativeOptions.fromJson(Map<String, dynamic> json) {
    return CustomNarrativeOptions(
      narrative: json['Narrative'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final narrative = this.narrative;
    return {
      'Narrative': narrative,
    };
  }
}

/// The customized parameter values.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class CustomParameterValues {
  /// A list of datetime-type parameter values.
  final List<DateTime>? dateTimeValues;

  /// A list of decimal-type parameter values.
  final List<double>? decimalValues;

  /// A list of integer-type parameter values.
  final List<int>? integerValues;

  /// A list of string-type parameter values.
  final List<String>? stringValues;

  CustomParameterValues({
    this.dateTimeValues,
    this.decimalValues,
    this.integerValues,
    this.stringValues,
  });

  factory CustomParameterValues.fromJson(Map<String, dynamic> json) {
    return CustomParameterValues(
      dateTimeValues: (json['DateTimeValues'] as List?)
          ?.whereNotNull()
          .map(nonNullableTimeStampFromJson)
          .toList(),
      decimalValues: (json['DecimalValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as double)
          .toList(),
      integerValues: (json['IntegerValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      stringValues: (json['StringValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeValues = this.dateTimeValues;
    final decimalValues = this.decimalValues;
    final integerValues = this.integerValues;
    final stringValues = this.stringValues;
    return {
      if (dateTimeValues != null)
        'DateTimeValues': dateTimeValues.map(unixTimestampToJson).toList(),
      if (decimalValues != null) 'DecimalValues': decimalValues,
      if (integerValues != null) 'IntegerValues': integerValues,
      if (stringValues != null) 'StringValues': stringValues,
    };
  }
}

/// A physical table type built from the results of the custom SQL query.
class CustomSql {
  /// The Amazon Resource Name (ARN) of the data source.
  final String dataSourceArn;

  /// A display name for the SQL query result.
  final String name;

  /// The SQL query.
  final String sqlQuery;

  /// The column schema from the SQL query result set.
  final List<InputColumn>? columns;

  CustomSql({
    required this.dataSourceArn,
    required this.name,
    required this.sqlQuery,
    this.columns,
  });

  factory CustomSql.fromJson(Map<String, dynamic> json) {
    return CustomSql(
      dataSourceArn: json['DataSourceArn'] as String,
      name: json['Name'] as String,
      sqlQuery: json['SqlQuery'] as String,
      columns: (json['Columns'] as List?)
          ?.whereNotNull()
          .map((e) => InputColumn.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceArn = this.dataSourceArn;
    final name = this.name;
    final sqlQuery = this.sqlQuery;
    final columns = this.columns;
    return {
      'DataSourceArn': dataSourceArn,
      'Name': name,
      'SqlQuery': sqlQuery,
      if (columns != null) 'Columns': columns,
    };
  }
}

/// The configuration of custom values for the destination parameter in
/// <code>DestinationParameterValueConfiguration</code>.
class CustomValuesConfiguration {
  final CustomParameterValues customValues;

  /// Includes the null value in custom action parameter values.
  final bool? includeNullValue;

  CustomValuesConfiguration({
    required this.customValues,
    this.includeNullValue,
  });

  factory CustomValuesConfiguration.fromJson(Map<String, dynamic> json) {
    return CustomValuesConfiguration(
      customValues: CustomParameterValues.fromJson(
          json['CustomValues'] as Map<String, dynamic>),
      includeNullValue: json['IncludeNullValue'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final customValues = this.customValues;
    final includeNullValue = this.includeNullValue;
    return {
      'CustomValues': customValues,
      if (includeNullValue != null) 'IncludeNullValue': includeNullValue,
    };
  }
}

/// Dashboard.
class Dashboard {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The time that this dashboard was created.
  final DateTime? createdTime;

  /// Dashboard ID.
  final String? dashboardId;

  /// The last time that this dashboard was published.
  final DateTime? lastPublishedTime;

  /// The last time that this dashboard was updated.
  final DateTime? lastUpdatedTime;

  /// A list of analysis Amazon Resource Names (ARNs) to be linked to the
  /// dashboard.
  final List<String>? linkEntities;

  /// A display name for the dashboard.
  final String? name;

  /// Version.
  final DashboardVersion? version;

  Dashboard({
    this.arn,
    this.createdTime,
    this.dashboardId,
    this.lastPublishedTime,
    this.lastUpdatedTime,
    this.linkEntities,
    this.name,
    this.version,
  });

  factory Dashboard.fromJson(Map<String, dynamic> json) {
    return Dashboard(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dashboardId: json['DashboardId'] as String?,
      lastPublishedTime: timeStampFromJson(json['LastPublishedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      linkEntities: (json['LinkEntities'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      name: json['Name'] as String?,
      version: json['Version'] != null
          ? DashboardVersion.fromJson(json['Version'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final dashboardId = this.dashboardId;
    final lastPublishedTime = this.lastPublishedTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final linkEntities = this.linkEntities;
    final name = this.name;
    final version = this.version;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (lastPublishedTime != null)
        'LastPublishedTime': unixTimestampToJson(lastPublishedTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (linkEntities != null) 'LinkEntities': linkEntities,
      if (name != null) 'Name': name,
      if (version != null) 'Version': version,
    };
  }
}

enum DashboardBehavior {
  enabled,
  disabled,
}

extension DashboardBehaviorValueExtension on DashboardBehavior {
  String toValue() {
    switch (this) {
      case DashboardBehavior.enabled:
        return 'ENABLED';
      case DashboardBehavior.disabled:
        return 'DISABLED';
    }
  }
}

extension DashboardBehaviorFromString on String {
  DashboardBehavior toDashboardBehavior() {
    switch (this) {
      case 'ENABLED':
        return DashboardBehavior.enabled;
      case 'DISABLED':
        return DashboardBehavior.disabled;
    }
    throw Exception('$this is not known in enum DashboardBehavior');
  }
}

/// Dashboard error.
class DashboardError {
  /// Message.
  final String? message;

  /// Type.
  final DashboardErrorType? type;

  /// Lists the violated entities that caused the dashboard error.
  final List<Entity>? violatedEntities;

  DashboardError({
    this.message,
    this.type,
    this.violatedEntities,
  });

  factory DashboardError.fromJson(Map<String, dynamic> json) {
    return DashboardError(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toDashboardErrorType(),
      violatedEntities: (json['ViolatedEntities'] as List?)
          ?.whereNotNull()
          .map((e) => Entity.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    final violatedEntities = this.violatedEntities;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
      if (violatedEntities != null) 'ViolatedEntities': violatedEntities,
    };
  }
}

enum DashboardErrorType {
  accessDenied,
  sourceNotFound,
  dataSetNotFound,
  internalFailure,
  parameterValueIncompatible,
  parameterTypeInvalid,
  parameterNotFound,
  columnTypeMismatch,
  columnGeographicRoleMismatch,
  columnReplacementMissing,
}

extension DashboardErrorTypeValueExtension on DashboardErrorType {
  String toValue() {
    switch (this) {
      case DashboardErrorType.accessDenied:
        return 'ACCESS_DENIED';
      case DashboardErrorType.sourceNotFound:
        return 'SOURCE_NOT_FOUND';
      case DashboardErrorType.dataSetNotFound:
        return 'DATA_SET_NOT_FOUND';
      case DashboardErrorType.internalFailure:
        return 'INTERNAL_FAILURE';
      case DashboardErrorType.parameterValueIncompatible:
        return 'PARAMETER_VALUE_INCOMPATIBLE';
      case DashboardErrorType.parameterTypeInvalid:
        return 'PARAMETER_TYPE_INVALID';
      case DashboardErrorType.parameterNotFound:
        return 'PARAMETER_NOT_FOUND';
      case DashboardErrorType.columnTypeMismatch:
        return 'COLUMN_TYPE_MISMATCH';
      case DashboardErrorType.columnGeographicRoleMismatch:
        return 'COLUMN_GEOGRAPHIC_ROLE_MISMATCH';
      case DashboardErrorType.columnReplacementMissing:
        return 'COLUMN_REPLACEMENT_MISSING';
    }
  }
}

extension DashboardErrorTypeFromString on String {
  DashboardErrorType toDashboardErrorType() {
    switch (this) {
      case 'ACCESS_DENIED':
        return DashboardErrorType.accessDenied;
      case 'SOURCE_NOT_FOUND':
        return DashboardErrorType.sourceNotFound;
      case 'DATA_SET_NOT_FOUND':
        return DashboardErrorType.dataSetNotFound;
      case 'INTERNAL_FAILURE':
        return DashboardErrorType.internalFailure;
      case 'PARAMETER_VALUE_INCOMPATIBLE':
        return DashboardErrorType.parameterValueIncompatible;
      case 'PARAMETER_TYPE_INVALID':
        return DashboardErrorType.parameterTypeInvalid;
      case 'PARAMETER_NOT_FOUND':
        return DashboardErrorType.parameterNotFound;
      case 'COLUMN_TYPE_MISMATCH':
        return DashboardErrorType.columnTypeMismatch;
      case 'COLUMN_GEOGRAPHIC_ROLE_MISMATCH':
        return DashboardErrorType.columnGeographicRoleMismatch;
      case 'COLUMN_REPLACEMENT_MISSING':
        return DashboardErrorType.columnReplacementMissing;
    }
    throw Exception('$this is not known in enum DashboardErrorType');
  }
}

enum DashboardFilterAttribute {
  quicksightUser,
  quicksightViewerOrOwner,
  directQuicksightViewerOrOwner,
  quicksightOwner,
  directQuicksightOwner,
  directQuicksightSoleOwner,
  dashboardName,
}

extension DashboardFilterAttributeValueExtension on DashboardFilterAttribute {
  String toValue() {
    switch (this) {
      case DashboardFilterAttribute.quicksightUser:
        return 'QUICKSIGHT_USER';
      case DashboardFilterAttribute.quicksightViewerOrOwner:
        return 'QUICKSIGHT_VIEWER_OR_OWNER';
      case DashboardFilterAttribute.directQuicksightViewerOrOwner:
        return 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER';
      case DashboardFilterAttribute.quicksightOwner:
        return 'QUICKSIGHT_OWNER';
      case DashboardFilterAttribute.directQuicksightOwner:
        return 'DIRECT_QUICKSIGHT_OWNER';
      case DashboardFilterAttribute.directQuicksightSoleOwner:
        return 'DIRECT_QUICKSIGHT_SOLE_OWNER';
      case DashboardFilterAttribute.dashboardName:
        return 'DASHBOARD_NAME';
    }
  }
}

extension DashboardFilterAttributeFromString on String {
  DashboardFilterAttribute toDashboardFilterAttribute() {
    switch (this) {
      case 'QUICKSIGHT_USER':
        return DashboardFilterAttribute.quicksightUser;
      case 'QUICKSIGHT_VIEWER_OR_OWNER':
        return DashboardFilterAttribute.quicksightViewerOrOwner;
      case 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER':
        return DashboardFilterAttribute.directQuicksightViewerOrOwner;
      case 'QUICKSIGHT_OWNER':
        return DashboardFilterAttribute.quicksightOwner;
      case 'DIRECT_QUICKSIGHT_OWNER':
        return DashboardFilterAttribute.directQuicksightOwner;
      case 'DIRECT_QUICKSIGHT_SOLE_OWNER':
        return DashboardFilterAttribute.directQuicksightSoleOwner;
      case 'DASHBOARD_NAME':
        return DashboardFilterAttribute.dashboardName;
    }
    throw Exception('$this is not known in enum DashboardFilterAttribute');
  }
}

/// Dashboard publish options.
class DashboardPublishOptions {
  /// Ad hoc (one-time) filtering option.
  final AdHocFilteringOption? adHocFilteringOption;

  /// The drill-down options of data points in a dashboard.
  final DataPointDrillUpDownOption? dataPointDrillUpDownOption;

  /// The data point menu label options of a dashboard.
  final DataPointMenuLabelOption? dataPointMenuLabelOption;

  /// The data point tool tip options of a dashboard.
  final DataPointTooltipOption? dataPointTooltipOption;

  /// Export to .csv option.
  final ExportToCSVOption? exportToCSVOption;

  /// Determines if hidden fields are exported with a dashboard.
  final ExportWithHiddenFieldsOption? exportWithHiddenFieldsOption;

  /// Sheet controls option.
  final SheetControlsOption? sheetControlsOption;

  /// The sheet layout maximization options of a dashbaord.
  final SheetLayoutElementMaximizationOption?
      sheetLayoutElementMaximizationOption;

  /// The axis sort options of a dashboard.
  final VisualAxisSortOption? visualAxisSortOption;

  /// The menu options of a visual in a dashboard.
  final VisualMenuOption? visualMenuOption;

  /// The visual publish options of a visual in a dashboard.
  final DashboardVisualPublishOptions? visualPublishOptions;

  DashboardPublishOptions({
    this.adHocFilteringOption,
    this.dataPointDrillUpDownOption,
    this.dataPointMenuLabelOption,
    this.dataPointTooltipOption,
    this.exportToCSVOption,
    this.exportWithHiddenFieldsOption,
    this.sheetControlsOption,
    this.sheetLayoutElementMaximizationOption,
    this.visualAxisSortOption,
    this.visualMenuOption,
    this.visualPublishOptions,
  });

  factory DashboardPublishOptions.fromJson(Map<String, dynamic> json) {
    return DashboardPublishOptions(
      adHocFilteringOption: json['AdHocFilteringOption'] != null
          ? AdHocFilteringOption.fromJson(
              json['AdHocFilteringOption'] as Map<String, dynamic>)
          : null,
      dataPointDrillUpDownOption: json['DataPointDrillUpDownOption'] != null
          ? DataPointDrillUpDownOption.fromJson(
              json['DataPointDrillUpDownOption'] as Map<String, dynamic>)
          : null,
      dataPointMenuLabelOption: json['DataPointMenuLabelOption'] != null
          ? DataPointMenuLabelOption.fromJson(
              json['DataPointMenuLabelOption'] as Map<String, dynamic>)
          : null,
      dataPointTooltipOption: json['DataPointTooltipOption'] != null
          ? DataPointTooltipOption.fromJson(
              json['DataPointTooltipOption'] as Map<String, dynamic>)
          : null,
      exportToCSVOption: json['ExportToCSVOption'] != null
          ? ExportToCSVOption.fromJson(
              json['ExportToCSVOption'] as Map<String, dynamic>)
          : null,
      exportWithHiddenFieldsOption: json['ExportWithHiddenFieldsOption'] != null
          ? ExportWithHiddenFieldsOption.fromJson(
              json['ExportWithHiddenFieldsOption'] as Map<String, dynamic>)
          : null,
      sheetControlsOption: json['SheetControlsOption'] != null
          ? SheetControlsOption.fromJson(
              json['SheetControlsOption'] as Map<String, dynamic>)
          : null,
      sheetLayoutElementMaximizationOption:
          json['SheetLayoutElementMaximizationOption'] != null
              ? SheetLayoutElementMaximizationOption.fromJson(
                  json['SheetLayoutElementMaximizationOption']
                      as Map<String, dynamic>)
              : null,
      visualAxisSortOption: json['VisualAxisSortOption'] != null
          ? VisualAxisSortOption.fromJson(
              json['VisualAxisSortOption'] as Map<String, dynamic>)
          : null,
      visualMenuOption: json['VisualMenuOption'] != null
          ? VisualMenuOption.fromJson(
              json['VisualMenuOption'] as Map<String, dynamic>)
          : null,
      visualPublishOptions: json['VisualPublishOptions'] != null
          ? DashboardVisualPublishOptions.fromJson(
              json['VisualPublishOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final adHocFilteringOption = this.adHocFilteringOption;
    final dataPointDrillUpDownOption = this.dataPointDrillUpDownOption;
    final dataPointMenuLabelOption = this.dataPointMenuLabelOption;
    final dataPointTooltipOption = this.dataPointTooltipOption;
    final exportToCSVOption = this.exportToCSVOption;
    final exportWithHiddenFieldsOption = this.exportWithHiddenFieldsOption;
    final sheetControlsOption = this.sheetControlsOption;
    final sheetLayoutElementMaximizationOption =
        this.sheetLayoutElementMaximizationOption;
    final visualAxisSortOption = this.visualAxisSortOption;
    final visualMenuOption = this.visualMenuOption;
    final visualPublishOptions = this.visualPublishOptions;
    return {
      if (adHocFilteringOption != null)
        'AdHocFilteringOption': adHocFilteringOption,
      if (dataPointDrillUpDownOption != null)
        'DataPointDrillUpDownOption': dataPointDrillUpDownOption,
      if (dataPointMenuLabelOption != null)
        'DataPointMenuLabelOption': dataPointMenuLabelOption,
      if (dataPointTooltipOption != null)
        'DataPointTooltipOption': dataPointTooltipOption,
      if (exportToCSVOption != null) 'ExportToCSVOption': exportToCSVOption,
      if (exportWithHiddenFieldsOption != null)
        'ExportWithHiddenFieldsOption': exportWithHiddenFieldsOption,
      if (sheetControlsOption != null)
        'SheetControlsOption': sheetControlsOption,
      if (sheetLayoutElementMaximizationOption != null)
        'SheetLayoutElementMaximizationOption':
            sheetLayoutElementMaximizationOption,
      if (visualAxisSortOption != null)
        'VisualAxisSortOption': visualAxisSortOption,
      if (visualMenuOption != null) 'VisualMenuOption': visualMenuOption,
      if (visualPublishOptions != null)
        'VisualPublishOptions': visualPublishOptions,
    };
  }
}

/// A filter that you apply when searching for dashboards.
class DashboardSearchFilter {
  /// The comparison operator that you want to use as a filter, for example
  /// <code>"Operator": "StringEquals"</code>. Valid values are
  /// <code>"StringEquals"</code> and <code>"StringLike"</code>.
  ///
  /// If you set the operator value to <code>"StringEquals"</code>, you need to
  /// provide an ownership related filter in the <code>"NAME"</code> field and the
  /// arn of the user or group whose folders you want to search in the
  /// <code>"Value"</code> field. For example,
  /// <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  ///
  /// If you set the value to <code>"StringLike"</code>, you need to provide the
  /// name of the folders you are searching for. For example,
  /// <code>"Name":"DASHBOARD_NAME", "Operator": "StringLike", "Value":
  /// "Test"</code>. The <code>"StringLike"</code> operator only supports the
  /// <code>NAME</code> value <code>DASHBOARD_NAME</code>.
  final FilterOperator operator;

  /// The name of the value that you want to use as a filter, for example,
  /// <code>"Name": "QUICKSIGHT_OWNER"</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group,
  /// and any dashboards with that ARN listed as one of the dashboards's owners or
  /// viewers are returned. Implicit permissions from folders or groups are
  /// considered.
  /// </li>
  /// <li>
  /// <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any
  /// dashboards with that ARN listed as one of the owners of the dashboards are
  /// returned. Implicit permissions from folders or groups are considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or
  /// group, and any dashboards with that ARN listed as the only owner of the
  /// dashboard are returned. Implicit permissions from folders or groups are not
  /// considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and
  /// any dashboards with that ARN listed as one of the owners of the dashboards
  /// are returned. Implicit permissions from folders or groups are not
  /// considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or
  /// group, and any dashboards with that ARN listed as one of the owners or
  /// viewers of the dashboards are returned. Implicit permissions from folders or
  /// groups are not considered.
  /// </li>
  /// <li>
  /// <code>DASHBOARD_NAME</code>: Any dashboards whose names have a substring
  /// match to this value will be returned.
  /// </li>
  /// </ul>
  final DashboardFilterAttribute? name;

  /// The value of the named item, in this case <code>QUICKSIGHT_USER</code>, that
  /// you want to use as a filter, for example, <code>"Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  final String? value;

  DashboardSearchFilter({
    required this.operator,
    this.name,
    this.value,
  });

  Map<String, dynamic> toJson() {
    final operator = this.operator;
    final name = this.name;
    final value = this.value;
    return {
      'Operator': operator.toValue(),
      if (name != null) 'Name': name.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

/// Dashboard source entity.
class DashboardSourceEntity {
  /// Source template.
  final DashboardSourceTemplate? sourceTemplate;

  DashboardSourceEntity({
    this.sourceTemplate,
  });

  Map<String, dynamic> toJson() {
    final sourceTemplate = this.sourceTemplate;
    return {
      if (sourceTemplate != null) 'SourceTemplate': sourceTemplate,
    };
  }
}

/// Dashboard source template.
class DashboardSourceTemplate {
  /// The Amazon Resource Name (ARN) of the resource.
  final String arn;

  /// Dataset references.
  final List<DataSetReference> dataSetReferences;

  DashboardSourceTemplate({
    required this.arn,
    required this.dataSetReferences,
  });

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSetReferences = this.dataSetReferences;
    return {
      'Arn': arn,
      'DataSetReferences': dataSetReferences,
    };
  }
}

/// Dashboard summary.
class DashboardSummary {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The time that this dashboard was created.
  final DateTime? createdTime;

  /// Dashboard ID.
  final String? dashboardId;

  /// The last time that this dashboard was published.
  final DateTime? lastPublishedTime;

  /// The last time that this dashboard was updated.
  final DateTime? lastUpdatedTime;

  /// A display name for the dashboard.
  final String? name;

  /// Published version number.
  final int? publishedVersionNumber;

  DashboardSummary({
    this.arn,
    this.createdTime,
    this.dashboardId,
    this.lastPublishedTime,
    this.lastUpdatedTime,
    this.name,
    this.publishedVersionNumber,
  });

  factory DashboardSummary.fromJson(Map<String, dynamic> json) {
    return DashboardSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dashboardId: json['DashboardId'] as String?,
      lastPublishedTime: timeStampFromJson(json['LastPublishedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      publishedVersionNumber: json['PublishedVersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final dashboardId = this.dashboardId;
    final lastPublishedTime = this.lastPublishedTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final publishedVersionNumber = this.publishedVersionNumber;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (lastPublishedTime != null)
        'LastPublishedTime': unixTimestampToJson(lastPublishedTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (publishedVersionNumber != null)
        'PublishedVersionNumber': publishedVersionNumber,
    };
  }
}

enum DashboardUIState {
  expanded,
  collapsed,
}

extension DashboardUIStateValueExtension on DashboardUIState {
  String toValue() {
    switch (this) {
      case DashboardUIState.expanded:
        return 'EXPANDED';
      case DashboardUIState.collapsed:
        return 'COLLAPSED';
    }
  }
}

extension DashboardUIStateFromString on String {
  DashboardUIState toDashboardUIState() {
    switch (this) {
      case 'EXPANDED':
        return DashboardUIState.expanded;
      case 'COLLAPSED':
        return DashboardUIState.collapsed;
    }
    throw Exception('$this is not known in enum DashboardUIState');
  }
}

/// Dashboard version.
class DashboardVersion {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The time that this dashboard version was created.
  final DateTime? createdTime;

  /// The Amazon Resource Numbers (ARNs) for the datasets that are associated with
  /// this version of the dashboard.
  final List<String>? dataSetArns;

  /// Description.
  final String? description;

  /// Errors associated with this dashboard version.
  final List<DashboardError>? errors;

  /// A list of the associated sheets with the unique identifier and name of each
  /// sheet.
  final List<Sheet>? sheets;

  /// Source entity ARN.
  final String? sourceEntityArn;

  /// The HTTP status of the request.
  final ResourceStatus? status;

  /// The ARN of the theme associated with a version of the dashboard.
  final String? themeArn;

  /// Version number for this version of the dashboard.
  final int? versionNumber;

  DashboardVersion({
    this.arn,
    this.createdTime,
    this.dataSetArns,
    this.description,
    this.errors,
    this.sheets,
    this.sourceEntityArn,
    this.status,
    this.themeArn,
    this.versionNumber,
  });

  factory DashboardVersion.fromJson(Map<String, dynamic> json) {
    return DashboardVersion(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSetArns: (json['DataSetArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      description: json['Description'] as String?,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => DashboardError.fromJson(e as Map<String, dynamic>))
          .toList(),
      sheets: (json['Sheets'] as List?)
          ?.whereNotNull()
          .map((e) => Sheet.fromJson(e as Map<String, dynamic>))
          .toList(),
      sourceEntityArn: json['SourceEntityArn'] as String?,
      status: (json['Status'] as String?)?.toResourceStatus(),
      themeArn: json['ThemeArn'] as String?,
      versionNumber: json['VersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final dataSetArns = this.dataSetArns;
    final description = this.description;
    final errors = this.errors;
    final sheets = this.sheets;
    final sourceEntityArn = this.sourceEntityArn;
    final status = this.status;
    final themeArn = this.themeArn;
    final versionNumber = this.versionNumber;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSetArns != null) 'DataSetArns': dataSetArns,
      if (description != null) 'Description': description,
      if (errors != null) 'Errors': errors,
      if (sheets != null) 'Sheets': sheets,
      if (sourceEntityArn != null) 'SourceEntityArn': sourceEntityArn,
      if (status != null) 'Status': status.toValue(),
      if (themeArn != null) 'ThemeArn': themeArn,
      if (versionNumber != null) 'VersionNumber': versionNumber,
    };
  }
}

/// The contents of a dashboard.
class DashboardVersionDefinition {
  /// An array of dataset identifier declarations. With this mapping,you can use
  /// dataset identifiers instead of dataset Amazon Resource Names (ARNs)
  /// throughout the dashboard's sub-structures.
  final List<DataSetIdentifierDeclaration> dataSetIdentifierDeclarations;
  final AnalysisDefaults? analysisDefaults;

  /// An array of calculated field definitions for the dashboard.
  final List<CalculatedField>? calculatedFields;

  /// An array of dashboard-level column configurations. Column configurations are
  /// used to set the default formatting for a column that is used throughout a
  /// dashboard.
  final List<ColumnConfiguration>? columnConfigurations;

  /// The filter definitions for a dashboard.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/adding-a-filter.html">Filtering
  /// Data in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<FilterGroup>? filterGroups;

  /// An array of option definitions for a dashboard.
  final AssetOptions? options;

  /// The parameter declarations for a dashboard. Parameters are named variables
  /// that can transfer a value for use by an action or an object.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters
  /// in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<ParameterDeclaration>? parameterDeclarations;

  /// An array of sheet definitions for a dashboard.
  final List<SheetDefinition>? sheets;

  DashboardVersionDefinition({
    required this.dataSetIdentifierDeclarations,
    this.analysisDefaults,
    this.calculatedFields,
    this.columnConfigurations,
    this.filterGroups,
    this.options,
    this.parameterDeclarations,
    this.sheets,
  });

  factory DashboardVersionDefinition.fromJson(Map<String, dynamic> json) {
    return DashboardVersionDefinition(
      dataSetIdentifierDeclarations: (json['DataSetIdentifierDeclarations']
              as List)
          .whereNotNull()
          .map((e) =>
              DataSetIdentifierDeclaration.fromJson(e as Map<String, dynamic>))
          .toList(),
      analysisDefaults: json['AnalysisDefaults'] != null
          ? AnalysisDefaults.fromJson(
              json['AnalysisDefaults'] as Map<String, dynamic>)
          : null,
      calculatedFields: (json['CalculatedFields'] as List?)
          ?.whereNotNull()
          .map((e) => CalculatedField.fromJson(e as Map<String, dynamic>))
          .toList(),
      columnConfigurations: (json['ColumnConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      filterGroups: (json['FilterGroups'] as List?)
          ?.whereNotNull()
          .map((e) => FilterGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      options: json['Options'] != null
          ? AssetOptions.fromJson(json['Options'] as Map<String, dynamic>)
          : null,
      parameterDeclarations: (json['ParameterDeclarations'] as List?)
          ?.whereNotNull()
          .map((e) => ParameterDeclaration.fromJson(e as Map<String, dynamic>))
          .toList(),
      sheets: (json['Sheets'] as List?)
          ?.whereNotNull()
          .map((e) => SheetDefinition.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifierDeclarations = this.dataSetIdentifierDeclarations;
    final analysisDefaults = this.analysisDefaults;
    final calculatedFields = this.calculatedFields;
    final columnConfigurations = this.columnConfigurations;
    final filterGroups = this.filterGroups;
    final options = this.options;
    final parameterDeclarations = this.parameterDeclarations;
    final sheets = this.sheets;
    return {
      'DataSetIdentifierDeclarations': dataSetIdentifierDeclarations,
      if (analysisDefaults != null) 'AnalysisDefaults': analysisDefaults,
      if (calculatedFields != null) 'CalculatedFields': calculatedFields,
      if (columnConfigurations != null)
        'ColumnConfigurations': columnConfigurations,
      if (filterGroups != null) 'FilterGroups': filterGroups,
      if (options != null) 'Options': options,
      if (parameterDeclarations != null)
        'ParameterDeclarations': parameterDeclarations,
      if (sheets != null) 'Sheets': sheets,
    };
  }
}

/// Dashboard version summary.
class DashboardVersionSummary {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The time that this dashboard version was created.
  final DateTime? createdTime;

  /// Description.
  final String? description;

  /// Source entity ARN.
  final String? sourceEntityArn;

  /// The HTTP status of the request.
  final ResourceStatus? status;

  /// Version number.
  final int? versionNumber;

  DashboardVersionSummary({
    this.arn,
    this.createdTime,
    this.description,
    this.sourceEntityArn,
    this.status,
    this.versionNumber,
  });

  factory DashboardVersionSummary.fromJson(Map<String, dynamic> json) {
    return DashboardVersionSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      description: json['Description'] as String?,
      sourceEntityArn: json['SourceEntityArn'] as String?,
      status: (json['Status'] as String?)?.toResourceStatus(),
      versionNumber: json['VersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final description = this.description;
    final sourceEntityArn = this.sourceEntityArn;
    final status = this.status;
    final versionNumber = this.versionNumber;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (description != null) 'Description': description,
      if (sourceEntityArn != null) 'SourceEntityArn': sourceEntityArn,
      if (status != null) 'Status': status.toValue(),
      if (versionNumber != null) 'VersionNumber': versionNumber,
    };
  }
}

/// A structure that contains the following elements:
///
/// <ul>
/// <li>
/// The <code>DashboardId</code> of the dashboard that has the visual that you
/// want to embed.
/// </li>
/// <li>
/// The <code>SheetId</code> of the sheet that has the visual that you want to
/// embed.
/// </li>
/// <li>
/// The <code>VisualId</code> of the visual that you want to embed.
/// </li>
/// </ul>
/// The <code>DashboardId</code>, <code>SheetId</code>, and
/// <code>VisualId</code> can be found in the <code>IDs for developers</code>
/// section of the <code>Embed visual</code> pane of the visual's on-visual menu
/// of the Amazon QuickSight console. You can also get the
/// <code>DashboardId</code> with a <code>ListDashboards</code> API operation.
class DashboardVisualId {
  /// The ID of the dashboard that has the visual that you want to embed. The
  /// <code>DashboardId</code> can be found in the <code>IDs for developers</code>
  /// section of the <code>Embed visual</code> pane of the visual's on-visual menu
  /// of the Amazon QuickSight console. You can also get the
  /// <code>DashboardId</code> with a <code>ListDashboards</code> API operation.
  final String dashboardId;

  /// The ID of the sheet that the has visual that you want to embed. The
  /// <code>SheetId</code> can be found in the <code>IDs for developers</code>
  /// section of the <code>Embed visual</code> pane of the visual's on-visual menu
  /// of the Amazon QuickSight console.
  final String sheetId;

  /// The ID of the visual that you want to embed. The <code>VisualID</code> can
  /// be found in the <code>IDs for developers</code> section of the <code>Embed
  /// visual</code> pane of the visual's on-visual menu of the Amazon QuickSight
  /// console.
  final String visualId;

  DashboardVisualId({
    required this.dashboardId,
    required this.sheetId,
    required this.visualId,
  });

  Map<String, dynamic> toJson() {
    final dashboardId = this.dashboardId;
    final sheetId = this.sheetId;
    final visualId = this.visualId;
    return {
      'DashboardId': dashboardId,
      'SheetId': sheetId,
      'VisualId': visualId,
    };
  }
}

/// The visual publish options of a visual in a dashboard
class DashboardVisualPublishOptions {
  /// Determines if hidden fields are included in an exported dashboard.
  final ExportHiddenFieldsOption? exportHiddenFieldsOption;

  DashboardVisualPublishOptions({
    this.exportHiddenFieldsOption,
  });

  factory DashboardVisualPublishOptions.fromJson(Map<String, dynamic> json) {
    return DashboardVisualPublishOptions(
      exportHiddenFieldsOption: json['ExportHiddenFieldsOption'] != null
          ? ExportHiddenFieldsOption.fromJson(
              json['ExportHiddenFieldsOption'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final exportHiddenFieldsOption = this.exportHiddenFieldsOption;
    return {
      if (exportHiddenFieldsOption != null)
        'ExportHiddenFieldsOption': exportHiddenFieldsOption,
    };
  }
}

/// A structure that represents a data aggregation.
class DataAggregation {
  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TopicTimeGranularity? datasetRowDateGranularity;

  /// The column name for the default date.
  final String? defaultDateColumnName;

  DataAggregation({
    this.datasetRowDateGranularity,
    this.defaultDateColumnName,
  });

  factory DataAggregation.fromJson(Map<String, dynamic> json) {
    return DataAggregation(
      datasetRowDateGranularity: (json['DatasetRowDateGranularity'] as String?)
          ?.toTopicTimeGranularity(),
      defaultDateColumnName: json['DefaultDateColumnName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final datasetRowDateGranularity = this.datasetRowDateGranularity;
    final defaultDateColumnName = this.defaultDateColumnName;
    return {
      if (datasetRowDateGranularity != null)
        'DatasetRowDateGranularity': datasetRowDateGranularity.toValue(),
      if (defaultDateColumnName != null)
        'DefaultDateColumnName': defaultDateColumnName,
    };
  }
}

/// The options for data bars.
class DataBarsOptions {
  /// The field ID for the data bars options.
  final String fieldId;

  /// The color of the negative data bar.
  final String? negativeColor;

  /// The color of the positive data bar.
  final String? positiveColor;

  DataBarsOptions({
    required this.fieldId,
    this.negativeColor,
    this.positiveColor,
  });

  factory DataBarsOptions.fromJson(Map<String, dynamic> json) {
    return DataBarsOptions(
      fieldId: json['FieldId'] as String,
      negativeColor: json['NegativeColor'] as String?,
      positiveColor: json['PositiveColor'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final negativeColor = this.negativeColor;
    final positiveColor = this.positiveColor;
    return {
      'FieldId': fieldId,
      if (negativeColor != null) 'NegativeColor': negativeColor,
      if (positiveColor != null) 'PositiveColor': positiveColor,
    };
  }
}

/// Determines the color that is applied to a particular data value.
class DataColor {
  /// The color that is applied to the data value.
  final String? color;

  /// The data value that the color is applied to.
  final double? dataValue;

  DataColor({
    this.color,
    this.dataValue,
  });

  factory DataColor.fromJson(Map<String, dynamic> json) {
    return DataColor(
      color: json['Color'] as String?,
      dataValue: json['DataValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final dataValue = this.dataValue;
    return {
      if (color != null) 'Color': color,
      if (dataValue != null) 'DataValue': dataValue,
    };
  }
}

/// The theme colors that are used for data colors in charts. The colors
/// description is a hexadecimal color code that consists of six alphanumerical
/// characters, prefixed with <code>#</code>, for example #37BFF5.
class DataColorPalette {
  /// The hexadecimal codes for the colors.
  final List<String>? colors;

  /// The hexadecimal code of a color that applies to charts where a lack of data
  /// is highlighted.
  final String? emptyFillColor;

  /// The minimum and maximum hexadecimal codes that describe a color gradient.
  final List<String>? minMaxGradient;

  DataColorPalette({
    this.colors,
    this.emptyFillColor,
    this.minMaxGradient,
  });

  factory DataColorPalette.fromJson(Map<String, dynamic> json) {
    return DataColorPalette(
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      emptyFillColor: json['EmptyFillColor'] as String?,
      minMaxGradient: (json['MinMaxGradient'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final colors = this.colors;
    final emptyFillColor = this.emptyFillColor;
    final minMaxGradient = this.minMaxGradient;
    return {
      if (colors != null) 'Colors': colors,
      if (emptyFillColor != null) 'EmptyFillColor': emptyFillColor,
      if (minMaxGradient != null) 'MinMaxGradient': minMaxGradient,
    };
  }
}

/// The data field series item configuration of a line chart.
class DataFieldSeriesItem {
  /// The axis that you are binding the field to.
  final AxisBinding axisBinding;

  /// The field ID of the field that you are setting the axis binding to.
  final String fieldId;

  /// The field value of the field that you are setting the axis binding to.
  final String? fieldValue;

  /// The options that determine the presentation of line series associated to the
  /// field.
  final LineChartSeriesSettings? settings;

  DataFieldSeriesItem({
    required this.axisBinding,
    required this.fieldId,
    this.fieldValue,
    this.settings,
  });

  factory DataFieldSeriesItem.fromJson(Map<String, dynamic> json) {
    return DataFieldSeriesItem(
      axisBinding: (json['AxisBinding'] as String).toAxisBinding(),
      fieldId: json['FieldId'] as String,
      fieldValue: json['FieldValue'] as String?,
      settings: json['Settings'] != null
          ? LineChartSeriesSettings.fromJson(
              json['Settings'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final axisBinding = this.axisBinding;
    final fieldId = this.fieldId;
    final fieldValue = this.fieldValue;
    final settings = this.settings;
    return {
      'AxisBinding': axisBinding.toValue(),
      'FieldId': fieldId,
      if (fieldValue != null) 'FieldValue': fieldValue,
      if (settings != null) 'Settings': settings,
    };
  }
}

enum DataLabelContent {
  value,
  percent,
  valueAndPercent,
}

extension DataLabelContentValueExtension on DataLabelContent {
  String toValue() {
    switch (this) {
      case DataLabelContent.value:
        return 'VALUE';
      case DataLabelContent.percent:
        return 'PERCENT';
      case DataLabelContent.valueAndPercent:
        return 'VALUE_AND_PERCENT';
    }
  }
}

extension DataLabelContentFromString on String {
  DataLabelContent toDataLabelContent() {
    switch (this) {
      case 'VALUE':
        return DataLabelContent.value;
      case 'PERCENT':
        return DataLabelContent.percent;
      case 'VALUE_AND_PERCENT':
        return DataLabelContent.valueAndPercent;
    }
    throw Exception('$this is not known in enum DataLabelContent');
  }
}

/// The options that determine the presentation of the data labels.
class DataLabelOptions {
  /// Determines the visibility of the category field labels.
  final Visibility? categoryLabelVisibility;

  /// The option that determines the data label type.
  final List<DataLabelType>? dataLabelTypes;

  /// Determines the color of the data labels.
  final String? labelColor;

  /// Determines the content of the data labels.
  final DataLabelContent? labelContent;

  /// Determines the font configuration of the data labels.
  final FontConfiguration? labelFontConfiguration;

  /// Determines the visibility of the measure field labels.
  final Visibility? measureLabelVisibility;

  /// Determines whether overlap is enabled or disabled for the data labels.
  final DataLabelOverlap? overlap;

  /// Determines the position of the data labels.
  final DataLabelPosition? position;

  /// Determines the visibility of the total.
  final Visibility? totalsVisibility;

  /// Determines the visibility of the data labels.
  final Visibility? visibility;

  DataLabelOptions({
    this.categoryLabelVisibility,
    this.dataLabelTypes,
    this.labelColor,
    this.labelContent,
    this.labelFontConfiguration,
    this.measureLabelVisibility,
    this.overlap,
    this.position,
    this.totalsVisibility,
    this.visibility,
  });

  factory DataLabelOptions.fromJson(Map<String, dynamic> json) {
    return DataLabelOptions(
      categoryLabelVisibility:
          (json['CategoryLabelVisibility'] as String?)?.toVisibility(),
      dataLabelTypes: (json['DataLabelTypes'] as List?)
          ?.whereNotNull()
          .map((e) => DataLabelType.fromJson(e as Map<String, dynamic>))
          .toList(),
      labelColor: json['LabelColor'] as String?,
      labelContent: (json['LabelContent'] as String?)?.toDataLabelContent(),
      labelFontConfiguration: json['LabelFontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['LabelFontConfiguration'] as Map<String, dynamic>)
          : null,
      measureLabelVisibility:
          (json['MeasureLabelVisibility'] as String?)?.toVisibility(),
      overlap: (json['Overlap'] as String?)?.toDataLabelOverlap(),
      position: (json['Position'] as String?)?.toDataLabelPosition(),
      totalsVisibility: (json['TotalsVisibility'] as String?)?.toVisibility(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryLabelVisibility = this.categoryLabelVisibility;
    final dataLabelTypes = this.dataLabelTypes;
    final labelColor = this.labelColor;
    final labelContent = this.labelContent;
    final labelFontConfiguration = this.labelFontConfiguration;
    final measureLabelVisibility = this.measureLabelVisibility;
    final overlap = this.overlap;
    final position = this.position;
    final totalsVisibility = this.totalsVisibility;
    final visibility = this.visibility;
    return {
      if (categoryLabelVisibility != null)
        'CategoryLabelVisibility': categoryLabelVisibility.toValue(),
      if (dataLabelTypes != null) 'DataLabelTypes': dataLabelTypes,
      if (labelColor != null) 'LabelColor': labelColor,
      if (labelContent != null) 'LabelContent': labelContent.toValue(),
      if (labelFontConfiguration != null)
        'LabelFontConfiguration': labelFontConfiguration,
      if (measureLabelVisibility != null)
        'MeasureLabelVisibility': measureLabelVisibility.toValue(),
      if (overlap != null) 'Overlap': overlap.toValue(),
      if (position != null) 'Position': position.toValue(),
      if (totalsVisibility != null)
        'TotalsVisibility': totalsVisibility.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

enum DataLabelOverlap {
  disableOverlap,
  enableOverlap,
}

extension DataLabelOverlapValueExtension on DataLabelOverlap {
  String toValue() {
    switch (this) {
      case DataLabelOverlap.disableOverlap:
        return 'DISABLE_OVERLAP';
      case DataLabelOverlap.enableOverlap:
        return 'ENABLE_OVERLAP';
    }
  }
}

extension DataLabelOverlapFromString on String {
  DataLabelOverlap toDataLabelOverlap() {
    switch (this) {
      case 'DISABLE_OVERLAP':
        return DataLabelOverlap.disableOverlap;
      case 'ENABLE_OVERLAP':
        return DataLabelOverlap.enableOverlap;
    }
    throw Exception('$this is not known in enum DataLabelOverlap');
  }
}

enum DataLabelPosition {
  inside,
  outside,
  left,
  top,
  bottom,
  right,
}

extension DataLabelPositionValueExtension on DataLabelPosition {
  String toValue() {
    switch (this) {
      case DataLabelPosition.inside:
        return 'INSIDE';
      case DataLabelPosition.outside:
        return 'OUTSIDE';
      case DataLabelPosition.left:
        return 'LEFT';
      case DataLabelPosition.top:
        return 'TOP';
      case DataLabelPosition.bottom:
        return 'BOTTOM';
      case DataLabelPosition.right:
        return 'RIGHT';
    }
  }
}

extension DataLabelPositionFromString on String {
  DataLabelPosition toDataLabelPosition() {
    switch (this) {
      case 'INSIDE':
        return DataLabelPosition.inside;
      case 'OUTSIDE':
        return DataLabelPosition.outside;
      case 'LEFT':
        return DataLabelPosition.left;
      case 'TOP':
        return DataLabelPosition.top;
      case 'BOTTOM':
        return DataLabelPosition.bottom;
      case 'RIGHT':
        return DataLabelPosition.right;
    }
    throw Exception('$this is not known in enum DataLabelPosition');
  }
}

/// The option that determines the data label type.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class DataLabelType {
  /// The option that specifies individual data values for labels.
  final DataPathLabelType? dataPathLabelType;

  /// Determines the label configuration for the entire field.
  final FieldLabelType? fieldLabelType;

  /// Determines the label configuration for the maximum value in a visual.
  final MaximumLabelType? maximumLabelType;

  /// Determines the label configuration for the minimum value in a visual.
  final MinimumLabelType? minimumLabelType;

  /// Determines the label configuration for range end value in a visual.
  final RangeEndsLabelType? rangeEndsLabelType;

  DataLabelType({
    this.dataPathLabelType,
    this.fieldLabelType,
    this.maximumLabelType,
    this.minimumLabelType,
    this.rangeEndsLabelType,
  });

  factory DataLabelType.fromJson(Map<String, dynamic> json) {
    return DataLabelType(
      dataPathLabelType: json['DataPathLabelType'] != null
          ? DataPathLabelType.fromJson(
              json['DataPathLabelType'] as Map<String, dynamic>)
          : null,
      fieldLabelType: json['FieldLabelType'] != null
          ? FieldLabelType.fromJson(
              json['FieldLabelType'] as Map<String, dynamic>)
          : null,
      maximumLabelType: json['MaximumLabelType'] != null
          ? MaximumLabelType.fromJson(
              json['MaximumLabelType'] as Map<String, dynamic>)
          : null,
      minimumLabelType: json['MinimumLabelType'] != null
          ? MinimumLabelType.fromJson(
              json['MinimumLabelType'] as Map<String, dynamic>)
          : null,
      rangeEndsLabelType: json['RangeEndsLabelType'] != null
          ? RangeEndsLabelType.fromJson(
              json['RangeEndsLabelType'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataPathLabelType = this.dataPathLabelType;
    final fieldLabelType = this.fieldLabelType;
    final maximumLabelType = this.maximumLabelType;
    final minimumLabelType = this.minimumLabelType;
    final rangeEndsLabelType = this.rangeEndsLabelType;
    return {
      if (dataPathLabelType != null) 'DataPathLabelType': dataPathLabelType,
      if (fieldLabelType != null) 'FieldLabelType': fieldLabelType,
      if (maximumLabelType != null) 'MaximumLabelType': maximumLabelType,
      if (minimumLabelType != null) 'MinimumLabelType': minimumLabelType,
      if (rangeEndsLabelType != null) 'RangeEndsLabelType': rangeEndsLabelType,
    };
  }
}

/// The color map that determines the color options for a particular element.
class DataPathColor {
  /// The color that needs to be applied to the element.
  final String color;

  /// The element that the color needs to be applied to.
  final DataPathValue element;

  /// The time granularity of the field that the color needs to be applied to.
  final TimeGranularity? timeGranularity;

  DataPathColor({
    required this.color,
    required this.element,
    this.timeGranularity,
  });

  factory DataPathColor.fromJson(Map<String, dynamic> json) {
    return DataPathColor(
      color: json['Color'] as String,
      element: DataPathValue.fromJson(json['Element'] as Map<String, dynamic>),
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final element = this.element;
    final timeGranularity = this.timeGranularity;
    return {
      'Color': color,
      'Element': element,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// The option that specifies individual data values for labels.
class DataPathLabelType {
  /// The field ID of the field that the data label needs to be applied to.
  final String? fieldId;

  /// The actual value of the field that is labeled.
  final String? fieldValue;

  /// The visibility of the data label.
  final Visibility? visibility;

  DataPathLabelType({
    this.fieldId,
    this.fieldValue,
    this.visibility,
  });

  factory DataPathLabelType.fromJson(Map<String, dynamic> json) {
    return DataPathLabelType(
      fieldId: json['FieldId'] as String?,
      fieldValue: json['FieldValue'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final fieldValue = this.fieldValue;
    final visibility = this.visibility;
    return {
      if (fieldId != null) 'FieldId': fieldId,
      if (fieldValue != null) 'FieldValue': fieldValue,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// Allows data paths to be sorted by a specific data value.
class DataPathSort {
  /// Determines the sort direction.
  final SortDirection direction;

  /// The list of data paths that need to be sorted.
  final List<DataPathValue> sortPaths;

  DataPathSort({
    required this.direction,
    required this.sortPaths,
  });

  factory DataPathSort.fromJson(Map<String, dynamic> json) {
    return DataPathSort(
      direction: (json['Direction'] as String).toSortDirection(),
      sortPaths: (json['SortPaths'] as List)
          .whereNotNull()
          .map((e) => DataPathValue.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final direction = this.direction;
    final sortPaths = this.sortPaths;
    return {
      'Direction': direction.toValue(),
      'SortPaths': sortPaths,
    };
  }
}

/// The type of the data path value.
class DataPathType {
  /// The type of data path value utilized in a pivot table. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>HIERARCHY_ROWS_LAYOUT_COLUMN</code> - The type of data path for the
  /// rows layout column, when <code>RowsLayout</code> is set to
  /// <code>HIERARCHY</code>.
  /// </li>
  /// <li>
  /// <code>MULTIPLE_ROW_METRICS_COLUMN</code> - The type of data path for the
  /// metric column when the row is set to Metric Placement.
  /// </li>
  /// <li>
  /// <code>EMPTY_COLUMN_HEADER</code> - The type of data path for the column with
  /// empty column header, when there is no field in <code>ColumnsFieldWell</code>
  /// and the row is set to Metric Placement.
  /// </li>
  /// <li>
  /// <code>COUNT_METRIC_COLUMN</code> - The type of data path for the column with
  /// <code>COUNT</code> as the metric, when there is no field in the
  /// <code>ValuesFieldWell</code>.
  /// </li>
  /// </ul>
  final PivotTableDataPathType? pivotTableDataPathType;

  DataPathType({
    this.pivotTableDataPathType,
  });

  factory DataPathType.fromJson(Map<String, dynamic> json) {
    return DataPathType(
      pivotTableDataPathType: (json['PivotTableDataPathType'] as String?)
          ?.toPivotTableDataPathType(),
    );
  }

  Map<String, dynamic> toJson() {
    final pivotTableDataPathType = this.pivotTableDataPathType;
    return {
      if (pivotTableDataPathType != null)
        'PivotTableDataPathType': pivotTableDataPathType.toValue(),
    };
  }
}

/// The data path that needs to be sorted.
class DataPathValue {
  /// The type configuration of the field.
  final DataPathType? dataPathType;

  /// The field ID of the field that needs to be sorted.
  final String? fieldId;

  /// The actual value of the field that needs to be sorted.
  final String? fieldValue;

  DataPathValue({
    this.dataPathType,
    this.fieldId,
    this.fieldValue,
  });

  factory DataPathValue.fromJson(Map<String, dynamic> json) {
    return DataPathValue(
      dataPathType: json['DataPathType'] != null
          ? DataPathType.fromJson(json['DataPathType'] as Map<String, dynamic>)
          : null,
      fieldId: json['FieldId'] as String?,
      fieldValue: json['FieldValue'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataPathType = this.dataPathType;
    final fieldId = this.fieldId;
    final fieldValue = this.fieldValue;
    return {
      if (dataPathType != null) 'DataPathType': dataPathType,
      if (fieldId != null) 'FieldId': fieldId,
      if (fieldValue != null) 'FieldValue': fieldValue,
    };
  }
}

/// The drill down options for data points in a dashbaord.
class DataPointDrillUpDownOption {
  /// The status of the drill down options of data points.
  final DashboardBehavior? availabilityStatus;

  DataPointDrillUpDownOption({
    this.availabilityStatus,
  });

  factory DataPointDrillUpDownOption.fromJson(Map<String, dynamic> json) {
    return DataPointDrillUpDownOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// The data point menu options of a dashboard.
class DataPointMenuLabelOption {
  /// The status of the data point menu options.
  final DashboardBehavior? availabilityStatus;

  DataPointMenuLabelOption({
    this.availabilityStatus,
  });

  factory DataPointMenuLabelOption.fromJson(Map<String, dynamic> json) {
    return DataPointMenuLabelOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// The data point tooltip options.
class DataPointTooltipOption {
  /// The status of the data point tool tip options.
  final DashboardBehavior? availabilityStatus;

  DataPointTooltipOption({
    this.availabilityStatus,
  });

  factory DataPointTooltipOption.fromJson(Map<String, dynamic> json) {
    return DataPointTooltipOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// Dataset.
class DataSet {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// Groupings of columns that work together in certain Amazon QuickSight
  /// features. Currently, only geospatial hierarchy is supported.
  final List<ColumnGroup>? columnGroups;

  /// A set of one or more definitions of a <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_ColumnLevelPermissionRule.html">ColumnLevelPermissionRule</a>
  /// </code>.
  final List<ColumnLevelPermissionRule>? columnLevelPermissionRules;

  /// The amount of SPICE capacity used by this dataset. This is 0 if the dataset
  /// isn't imported into SPICE.
  final int? consumedSpiceCapacityInBytes;

  /// The time that this dataset was created.
  final DateTime? createdTime;

  /// The ID of the dataset.
  final String? dataSetId;

  /// The usage configuration to apply to child datasets that reference this
  /// dataset as a source.
  final DataSetUsageConfiguration? dataSetUsageConfiguration;

  /// The parameters that are declared in a dataset.
  final List<DatasetParameter>? datasetParameters;

  /// The folder that contains fields and nested subfolders for your dataset.
  final Map<String, FieldFolder>? fieldFolders;

  /// A value that indicates whether you want to import the data into SPICE.
  final DataSetImportMode? importMode;

  /// The last time that this dataset was updated.
  final DateTime? lastUpdatedTime;

  /// Configures the combination and transformation of the data from the physical
  /// tables.
  final Map<String, LogicalTable>? logicalTableMap;

  /// A display name for the dataset.
  final String? name;

  /// The list of columns after all transforms. These columns are available in
  /// templates, analyses, and dashboards.
  final List<OutputColumn>? outputColumns;

  /// Declares the physical tables that are available in the underlying data
  /// sources.
  final Map<String, PhysicalTable>? physicalTableMap;

  /// The row-level security configuration for the dataset.
  final RowLevelPermissionDataSet? rowLevelPermissionDataSet;

  /// The element you can use to define tags for row-level security.
  final RowLevelPermissionTagConfiguration? rowLevelPermissionTagConfiguration;

  DataSet({
    this.arn,
    this.columnGroups,
    this.columnLevelPermissionRules,
    this.consumedSpiceCapacityInBytes,
    this.createdTime,
    this.dataSetId,
    this.dataSetUsageConfiguration,
    this.datasetParameters,
    this.fieldFolders,
    this.importMode,
    this.lastUpdatedTime,
    this.logicalTableMap,
    this.name,
    this.outputColumns,
    this.physicalTableMap,
    this.rowLevelPermissionDataSet,
    this.rowLevelPermissionTagConfiguration,
  });

  factory DataSet.fromJson(Map<String, dynamic> json) {
    return DataSet(
      arn: json['Arn'] as String?,
      columnGroups: (json['ColumnGroups'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      columnLevelPermissionRules: (json['ColumnLevelPermissionRules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              ColumnLevelPermissionRule.fromJson(e as Map<String, dynamic>))
          .toList(),
      consumedSpiceCapacityInBytes:
          json['ConsumedSpiceCapacityInBytes'] as int?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSetId: json['DataSetId'] as String?,
      dataSetUsageConfiguration: json['DataSetUsageConfiguration'] != null
          ? DataSetUsageConfiguration.fromJson(
              json['DataSetUsageConfiguration'] as Map<String, dynamic>)
          : null,
      datasetParameters: (json['DatasetParameters'] as List?)
          ?.whereNotNull()
          .map((e) => DatasetParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      fieldFolders: (json['FieldFolders'] as Map<String, dynamic>?)?.map(
          (k, e) =>
              MapEntry(k, FieldFolder.fromJson(e as Map<String, dynamic>))),
      importMode: (json['ImportMode'] as String?)?.toDataSetImportMode(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      logicalTableMap: (json['LogicalTableMap'] as Map<String, dynamic>?)?.map(
          (k, e) =>
              MapEntry(k, LogicalTable.fromJson(e as Map<String, dynamic>))),
      name: json['Name'] as String?,
      outputColumns: (json['OutputColumns'] as List?)
          ?.whereNotNull()
          .map((e) => OutputColumn.fromJson(e as Map<String, dynamic>))
          .toList(),
      physicalTableMap: (json['PhysicalTableMap'] as Map<String, dynamic>?)
          ?.map((k, e) =>
              MapEntry(k, PhysicalTable.fromJson(e as Map<String, dynamic>))),
      rowLevelPermissionDataSet: json['RowLevelPermissionDataSet'] != null
          ? RowLevelPermissionDataSet.fromJson(
              json['RowLevelPermissionDataSet'] as Map<String, dynamic>)
          : null,
      rowLevelPermissionTagConfiguration:
          json['RowLevelPermissionTagConfiguration'] != null
              ? RowLevelPermissionTagConfiguration.fromJson(
                  json['RowLevelPermissionTagConfiguration']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final columnGroups = this.columnGroups;
    final columnLevelPermissionRules = this.columnLevelPermissionRules;
    final consumedSpiceCapacityInBytes = this.consumedSpiceCapacityInBytes;
    final createdTime = this.createdTime;
    final dataSetId = this.dataSetId;
    final dataSetUsageConfiguration = this.dataSetUsageConfiguration;
    final datasetParameters = this.datasetParameters;
    final fieldFolders = this.fieldFolders;
    final importMode = this.importMode;
    final lastUpdatedTime = this.lastUpdatedTime;
    final logicalTableMap = this.logicalTableMap;
    final name = this.name;
    final outputColumns = this.outputColumns;
    final physicalTableMap = this.physicalTableMap;
    final rowLevelPermissionDataSet = this.rowLevelPermissionDataSet;
    final rowLevelPermissionTagConfiguration =
        this.rowLevelPermissionTagConfiguration;
    return {
      if (arn != null) 'Arn': arn,
      if (columnGroups != null) 'ColumnGroups': columnGroups,
      if (columnLevelPermissionRules != null)
        'ColumnLevelPermissionRules': columnLevelPermissionRules,
      if (consumedSpiceCapacityInBytes != null)
        'ConsumedSpiceCapacityInBytes': consumedSpiceCapacityInBytes,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (dataSetUsageConfiguration != null)
        'DataSetUsageConfiguration': dataSetUsageConfiguration,
      if (datasetParameters != null) 'DatasetParameters': datasetParameters,
      if (fieldFolders != null) 'FieldFolders': fieldFolders,
      if (importMode != null) 'ImportMode': importMode.toValue(),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (logicalTableMap != null) 'LogicalTableMap': logicalTableMap,
      if (name != null) 'Name': name,
      if (outputColumns != null) 'OutputColumns': outputColumns,
      if (physicalTableMap != null) 'PhysicalTableMap': physicalTableMap,
      if (rowLevelPermissionDataSet != null)
        'RowLevelPermissionDataSet': rowLevelPermissionDataSet,
      if (rowLevelPermissionTagConfiguration != null)
        'RowLevelPermissionTagConfiguration':
            rowLevelPermissionTagConfiguration,
    };
  }
}

/// Dataset configuration.
class DataSetConfiguration {
  /// A structure containing the list of column group schemas.
  final List<ColumnGroupSchema>? columnGroupSchemaList;

  /// Dataset schema.
  final DataSetSchema? dataSetSchema;

  /// Placeholder.
  final String? placeholder;

  DataSetConfiguration({
    this.columnGroupSchemaList,
    this.dataSetSchema,
    this.placeholder,
  });

  factory DataSetConfiguration.fromJson(Map<String, dynamic> json) {
    return DataSetConfiguration(
      columnGroupSchemaList: (json['ColumnGroupSchemaList'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnGroupSchema.fromJson(e as Map<String, dynamic>))
          .toList(),
      dataSetSchema: json['DataSetSchema'] != null
          ? DataSetSchema.fromJson(
              json['DataSetSchema'] as Map<String, dynamic>)
          : null,
      placeholder: json['Placeholder'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final columnGroupSchemaList = this.columnGroupSchemaList;
    final dataSetSchema = this.dataSetSchema;
    final placeholder = this.placeholder;
    return {
      if (columnGroupSchemaList != null)
        'ColumnGroupSchemaList': columnGroupSchemaList,
      if (dataSetSchema != null) 'DataSetSchema': dataSetSchema,
      if (placeholder != null) 'Placeholder': placeholder,
    };
  }
}

enum DataSetFilterAttribute {
  quicksightViewerOrOwner,
  quicksightOwner,
  directQuicksightViewerOrOwner,
  directQuicksightOwner,
  directQuicksightSoleOwner,
  datasetName,
}

extension DataSetFilterAttributeValueExtension on DataSetFilterAttribute {
  String toValue() {
    switch (this) {
      case DataSetFilterAttribute.quicksightViewerOrOwner:
        return 'QUICKSIGHT_VIEWER_OR_OWNER';
      case DataSetFilterAttribute.quicksightOwner:
        return 'QUICKSIGHT_OWNER';
      case DataSetFilterAttribute.directQuicksightViewerOrOwner:
        return 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER';
      case DataSetFilterAttribute.directQuicksightOwner:
        return 'DIRECT_QUICKSIGHT_OWNER';
      case DataSetFilterAttribute.directQuicksightSoleOwner:
        return 'DIRECT_QUICKSIGHT_SOLE_OWNER';
      case DataSetFilterAttribute.datasetName:
        return 'DATASET_NAME';
    }
  }
}

extension DataSetFilterAttributeFromString on String {
  DataSetFilterAttribute toDataSetFilterAttribute() {
    switch (this) {
      case 'QUICKSIGHT_VIEWER_OR_OWNER':
        return DataSetFilterAttribute.quicksightViewerOrOwner;
      case 'QUICKSIGHT_OWNER':
        return DataSetFilterAttribute.quicksightOwner;
      case 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER':
        return DataSetFilterAttribute.directQuicksightViewerOrOwner;
      case 'DIRECT_QUICKSIGHT_OWNER':
        return DataSetFilterAttribute.directQuicksightOwner;
      case 'DIRECT_QUICKSIGHT_SOLE_OWNER':
        return DataSetFilterAttribute.directQuicksightSoleOwner;
      case 'DATASET_NAME':
        return DataSetFilterAttribute.datasetName;
    }
    throw Exception('$this is not known in enum DataSetFilterAttribute');
  }
}

/// A data set.
class DataSetIdentifierDeclaration {
  /// The Amazon Resource Name (ARN) of the data set.
  final String dataSetArn;

  /// The identifier of the data set, typically the data set's name.
  final String identifier;

  DataSetIdentifierDeclaration({
    required this.dataSetArn,
    required this.identifier,
  });

  factory DataSetIdentifierDeclaration.fromJson(Map<String, dynamic> json) {
    return DataSetIdentifierDeclaration(
      dataSetArn: json['DataSetArn'] as String,
      identifier: json['Identifier'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetArn = this.dataSetArn;
    final identifier = this.identifier;
    return {
      'DataSetArn': dataSetArn,
      'Identifier': identifier,
    };
  }
}

enum DataSetImportMode {
  spice,
  directQuery,
}

extension DataSetImportModeValueExtension on DataSetImportMode {
  String toValue() {
    switch (this) {
      case DataSetImportMode.spice:
        return 'SPICE';
      case DataSetImportMode.directQuery:
        return 'DIRECT_QUERY';
    }
  }
}

extension DataSetImportModeFromString on String {
  DataSetImportMode toDataSetImportMode() {
    switch (this) {
      case 'SPICE':
        return DataSetImportMode.spice;
      case 'DIRECT_QUERY':
        return DataSetImportMode.directQuery;
    }
    throw Exception('$this is not known in enum DataSetImportMode');
  }
}

/// Dataset reference.
class DataSetReference {
  /// Dataset Amazon Resource Name (ARN).
  final String dataSetArn;

  /// Dataset placeholder.
  final String dataSetPlaceholder;

  DataSetReference({
    required this.dataSetArn,
    required this.dataSetPlaceholder,
  });

  Map<String, dynamic> toJson() {
    final dataSetArn = this.dataSetArn;
    final dataSetPlaceholder = this.dataSetPlaceholder;
    return {
      'DataSetArn': dataSetArn,
      'DataSetPlaceholder': dataSetPlaceholder,
    };
  }
}

/// The refresh properties of a dataset.
class DataSetRefreshProperties {
  /// The refresh configuration for a dataset.
  final RefreshConfiguration refreshConfiguration;

  DataSetRefreshProperties({
    required this.refreshConfiguration,
  });

  factory DataSetRefreshProperties.fromJson(Map<String, dynamic> json) {
    return DataSetRefreshProperties(
      refreshConfiguration: RefreshConfiguration.fromJson(
          json['RefreshConfiguration'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final refreshConfiguration = this.refreshConfiguration;
    return {
      'RefreshConfiguration': refreshConfiguration,
    };
  }
}

/// Dataset schema.
class DataSetSchema {
  /// A structure containing the list of column schemas.
  final List<ColumnSchema>? columnSchemaList;

  DataSetSchema({
    this.columnSchemaList,
  });

  factory DataSetSchema.fromJson(Map<String, dynamic> json) {
    return DataSetSchema(
      columnSchemaList: (json['ColumnSchemaList'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnSchema.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnSchemaList = this.columnSchemaList;
    return {
      if (columnSchemaList != null) 'ColumnSchemaList': columnSchemaList,
    };
  }
}

/// A filter that you apply when searching for datasets.
class DataSetSearchFilter {
  /// The name of the value that you want to use as a filter, for example,
  /// <code>"Name": "QUICKSIGHT_OWNER"</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group,
  /// and any datasets with that ARN listed as one of the dataset owners or
  /// viewers are returned. Implicit permissions from folders or groups are
  /// considered.
  /// </li>
  /// <li>
  /// <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any
  /// datasets with that ARN listed as one of the owners of the dataset are
  /// returned. Implicit permissions from folders or groups are considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or
  /// group, and any datasets with that ARN listed as the only owner of the
  /// dataset are returned. Implicit permissions from folders or groups are not
  /// considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and
  /// any datasets with that ARN listed as one of the owners if the dataset are
  /// returned. Implicit permissions from folders or groups are not considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or
  /// group, and any datasets with that ARN listed as one of the owners or viewers
  /// of the dataset are returned. Implicit permissions from folders or groups are
  /// not considered.
  /// </li>
  /// <li>
  /// <code>DATASET_NAME</code>: Any datasets whose names have a substring match
  /// to this value will be returned.
  /// </li>
  /// </ul>
  final DataSetFilterAttribute name;

  /// The comparison operator that you want to use as a filter, for example
  /// <code>"Operator": "StringEquals"</code>. Valid values are
  /// <code>"StringEquals"</code> and <code>"StringLike"</code>.
  ///
  /// If you set the operator value to <code>"StringEquals"</code>, you need to
  /// provide an ownership related filter in the <code>"NAME"</code> field and the
  /// arn of the user or group whose datasets you want to search in the
  /// <code>"Value"</code> field. For example, <code>"Name":"QUICKSIGHT_OWNER",
  /// "Operator": "StringEquals", "Value": "arn:aws:quicksight:us-east-
  /// 1:1:user/default/UserName1"</code>.
  ///
  /// If you set the value to <code>"StringLike"</code>, you need to provide the
  /// name of the datasets you are searching for. For example,
  /// <code>"Name":"DATASET_NAME", "Operator": "StringLike", "Value":
  /// "Test"</code>. The <code>"StringLike"</code> operator only supports the
  /// <code>NAME</code> value <code>DATASET_NAME</code>.
  final FilterOperator operator;

  /// The value of the named item, in this case <code>QUICKSIGHT_OWNER</code>,
  /// that you want to use as a filter, for example, <code>"Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  final String value;

  DataSetSearchFilter({
    required this.name,
    required this.operator,
    required this.value,
  });

  Map<String, dynamic> toJson() {
    final name = this.name;
    final operator = this.operator;
    final value = this.value;
    return {
      'Name': name.toValue(),
      'Operator': operator.toValue(),
      'Value': value,
    };
  }
}

/// Dataset summary.
class DataSetSummary {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? arn;

  /// A value that indicates if the dataset has column level permission
  /// configured.
  final bool? columnLevelPermissionRulesApplied;

  /// The time that this dataset was created.
  final DateTime? createdTime;

  /// The ID of the dataset.
  final String? dataSetId;

  /// A value that indicates whether you want to import the data into SPICE.
  final DataSetImportMode? importMode;

  /// The last time that this dataset was updated.
  final DateTime? lastUpdatedTime;

  /// A display name for the dataset.
  final String? name;

  /// The row-level security configuration for the dataset.
  final RowLevelPermissionDataSet? rowLevelPermissionDataSet;

  /// Whether or not the row level permission tags are applied.
  final bool? rowLevelPermissionTagConfigurationApplied;

  DataSetSummary({
    this.arn,
    this.columnLevelPermissionRulesApplied,
    this.createdTime,
    this.dataSetId,
    this.importMode,
    this.lastUpdatedTime,
    this.name,
    this.rowLevelPermissionDataSet,
    this.rowLevelPermissionTagConfigurationApplied,
  });

  factory DataSetSummary.fromJson(Map<String, dynamic> json) {
    return DataSetSummary(
      arn: json['Arn'] as String?,
      columnLevelPermissionRulesApplied:
          json['ColumnLevelPermissionRulesApplied'] as bool?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSetId: json['DataSetId'] as String?,
      importMode: (json['ImportMode'] as String?)?.toDataSetImportMode(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      rowLevelPermissionDataSet: json['RowLevelPermissionDataSet'] != null
          ? RowLevelPermissionDataSet.fromJson(
              json['RowLevelPermissionDataSet'] as Map<String, dynamic>)
          : null,
      rowLevelPermissionTagConfigurationApplied:
          json['RowLevelPermissionTagConfigurationApplied'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final columnLevelPermissionRulesApplied =
        this.columnLevelPermissionRulesApplied;
    final createdTime = this.createdTime;
    final dataSetId = this.dataSetId;
    final importMode = this.importMode;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final rowLevelPermissionDataSet = this.rowLevelPermissionDataSet;
    final rowLevelPermissionTagConfigurationApplied =
        this.rowLevelPermissionTagConfigurationApplied;
    return {
      if (arn != null) 'Arn': arn,
      if (columnLevelPermissionRulesApplied != null)
        'ColumnLevelPermissionRulesApplied': columnLevelPermissionRulesApplied,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (importMode != null) 'ImportMode': importMode.toValue(),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (rowLevelPermissionDataSet != null)
        'RowLevelPermissionDataSet': rowLevelPermissionDataSet,
      if (rowLevelPermissionTagConfigurationApplied != null)
        'RowLevelPermissionTagConfigurationApplied':
            rowLevelPermissionTagConfigurationApplied,
    };
  }
}

/// The usage configuration to apply to child datasets that reference this
/// dataset as a source.
class DataSetUsageConfiguration {
  /// An option that controls whether a child dataset of a direct query can use
  /// this dataset as a source.
  final bool? disableUseAsDirectQuerySource;

  /// An option that controls whether a child dataset that's stored in QuickSight
  /// can use this dataset as a source.
  final bool? disableUseAsImportedSource;

  DataSetUsageConfiguration({
    this.disableUseAsDirectQuerySource,
    this.disableUseAsImportedSource,
  });

  factory DataSetUsageConfiguration.fromJson(Map<String, dynamic> json) {
    return DataSetUsageConfiguration(
      disableUseAsDirectQuerySource:
          json['DisableUseAsDirectQuerySource'] as bool?,
      disableUseAsImportedSource: json['DisableUseAsImportedSource'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final disableUseAsDirectQuerySource = this.disableUseAsDirectQuerySource;
    final disableUseAsImportedSource = this.disableUseAsImportedSource;
    return {
      if (disableUseAsDirectQuerySource != null)
        'DisableUseAsDirectQuerySource': disableUseAsDirectQuerySource,
      if (disableUseAsImportedSource != null)
        'DisableUseAsImportedSource': disableUseAsImportedSource,
    };
  }
}

/// The structure of a data source.
class DataSource {
  /// A set of alternate data source parameters that you want to share for the
  /// credentials stored with this data source. The credentials are applied in
  /// tandem with the data source parameters when you copy a data source by using
  /// a create or update request. The API operation compares the
  /// <code>DataSourceParameters</code> structure that's in the request with the
  /// structures in the <code>AlternateDataSourceParameters</code> allow list. If
  /// the structures are an exact match, the request is allowed to use the
  /// credentials from this existing data source. If the
  /// <code>AlternateDataSourceParameters</code> list is null, the
  /// <code>Credentials</code> originally used with this
  /// <code>DataSourceParameters</code> are automatically allowed.
  final List<DataSourceParameters>? alternateDataSourceParameters;

  /// The Amazon Resource Name (ARN) of the data source.
  final String? arn;

  /// The time that this data source was created.
  final DateTime? createdTime;

  /// The ID of the data source. This ID is unique per Amazon Web Services Region
  /// for each Amazon Web Services account.
  final String? dataSourceId;

  /// The parameters that Amazon QuickSight uses to connect to your underlying
  /// source. This is a variant type structure. For this structure to be valid,
  /// only one of the attributes can be non-null.
  final DataSourceParameters? dataSourceParameters;

  /// Error information from the last update or the creation of the data source.
  final DataSourceErrorInfo? errorInfo;

  /// The last time that this data source was updated.
  final DateTime? lastUpdatedTime;

  /// A display name for the data source.
  final String? name;

  /// The Amazon Resource Name (ARN) of the secret associated with the data source
  /// in Amazon Secrets Manager.
  final String? secretArn;

  /// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight
  /// connects to your underlying source.
  final SslProperties? sslProperties;

  /// The HTTP status of the request.
  final ResourceStatus? status;

  /// The type of the data source. This type indicates which database engine the
  /// data source connects to.
  final DataSourceType? type;

  /// The VPC connection information. You need to use this parameter only when you
  /// want Amazon QuickSight to use a VPC connection when connecting to your
  /// underlying source.
  final VpcConnectionProperties? vpcConnectionProperties;

  DataSource({
    this.alternateDataSourceParameters,
    this.arn,
    this.createdTime,
    this.dataSourceId,
    this.dataSourceParameters,
    this.errorInfo,
    this.lastUpdatedTime,
    this.name,
    this.secretArn,
    this.sslProperties,
    this.status,
    this.type,
    this.vpcConnectionProperties,
  });

  factory DataSource.fromJson(Map<String, dynamic> json) {
    return DataSource(
      alternateDataSourceParameters: (json['AlternateDataSourceParameters']
              as List?)
          ?.whereNotNull()
          .map((e) => DataSourceParameters.fromJson(e as Map<String, dynamic>))
          .toList(),
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSourceId: json['DataSourceId'] as String?,
      dataSourceParameters: json['DataSourceParameters'] != null
          ? DataSourceParameters.fromJson(
              json['DataSourceParameters'] as Map<String, dynamic>)
          : null,
      errorInfo: json['ErrorInfo'] != null
          ? DataSourceErrorInfo.fromJson(
              json['ErrorInfo'] as Map<String, dynamic>)
          : null,
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      secretArn: json['SecretArn'] as String?,
      sslProperties: json['SslProperties'] != null
          ? SslProperties.fromJson(
              json['SslProperties'] as Map<String, dynamic>)
          : null,
      status: (json['Status'] as String?)?.toResourceStatus(),
      type: (json['Type'] as String?)?.toDataSourceType(),
      vpcConnectionProperties: json['VpcConnectionProperties'] != null
          ? VpcConnectionProperties.fromJson(
              json['VpcConnectionProperties'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final alternateDataSourceParameters = this.alternateDataSourceParameters;
    final arn = this.arn;
    final createdTime = this.createdTime;
    final dataSourceId = this.dataSourceId;
    final dataSourceParameters = this.dataSourceParameters;
    final errorInfo = this.errorInfo;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final secretArn = this.secretArn;
    final sslProperties = this.sslProperties;
    final status = this.status;
    final type = this.type;
    final vpcConnectionProperties = this.vpcConnectionProperties;
    return {
      if (alternateDataSourceParameters != null)
        'AlternateDataSourceParameters': alternateDataSourceParameters,
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (dataSourceParameters != null)
        'DataSourceParameters': dataSourceParameters,
      if (errorInfo != null) 'ErrorInfo': errorInfo,
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (secretArn != null) 'SecretArn': secretArn,
      if (sslProperties != null) 'SslProperties': sslProperties,
      if (status != null) 'Status': status.toValue(),
      if (type != null) 'Type': type.toValue(),
      if (vpcConnectionProperties != null)
        'VpcConnectionProperties': vpcConnectionProperties,
    };
  }
}

/// Data source credentials. This is a variant type structure. For this
/// structure to be valid, only one of the attributes can be non-null.
class DataSourceCredentials {
  /// The Amazon Resource Name (ARN) of a data source that has the credential pair
  /// that you want to use. When <code>CopySourceArn</code> is not null, the
  /// credential pair from the data source in the ARN is used as the credentials
  /// for the <code>DataSourceCredentials</code> structure.
  final String? copySourceArn;

  /// Credential pair. For more information, see <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_CredentialPair.html">CredentialPair</a>
  /// </code>.
  final CredentialPair? credentialPair;

  /// The Amazon Resource Name (ARN) of the secret associated with the data source
  /// in Amazon Secrets Manager.
  final String? secretArn;

  DataSourceCredentials({
    this.copySourceArn,
    this.credentialPair,
    this.secretArn,
  });

  Map<String, dynamic> toJson() {
    final copySourceArn = this.copySourceArn;
    final credentialPair = this.credentialPair;
    final secretArn = this.secretArn;
    return {
      if (copySourceArn != null) 'CopySourceArn': copySourceArn,
      if (credentialPair != null) 'CredentialPair': credentialPair,
      if (secretArn != null) 'SecretArn': secretArn,
    };
  }
}

/// Error information for the data source creation or update.
class DataSourceErrorInfo {
  /// Error message.
  final String? message;

  /// Error type.
  final DataSourceErrorInfoType? type;

  DataSourceErrorInfo({
    this.message,
    this.type,
  });

  factory DataSourceErrorInfo.fromJson(Map<String, dynamic> json) {
    return DataSourceErrorInfo(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toDataSourceErrorInfoType(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum DataSourceErrorInfoType {
  accessDenied,
  copySourceNotFound,
  timeout,
  engineVersionNotSupported,
  unknownHost,
  genericSqlFailure,
  conflict,
  unknown,
}

extension DataSourceErrorInfoTypeValueExtension on DataSourceErrorInfoType {
  String toValue() {
    switch (this) {
      case DataSourceErrorInfoType.accessDenied:
        return 'ACCESS_DENIED';
      case DataSourceErrorInfoType.copySourceNotFound:
        return 'COPY_SOURCE_NOT_FOUND';
      case DataSourceErrorInfoType.timeout:
        return 'TIMEOUT';
      case DataSourceErrorInfoType.engineVersionNotSupported:
        return 'ENGINE_VERSION_NOT_SUPPORTED';
      case DataSourceErrorInfoType.unknownHost:
        return 'UNKNOWN_HOST';
      case DataSourceErrorInfoType.genericSqlFailure:
        return 'GENERIC_SQL_FAILURE';
      case DataSourceErrorInfoType.conflict:
        return 'CONFLICT';
      case DataSourceErrorInfoType.unknown:
        return 'UNKNOWN';
    }
  }
}

extension DataSourceErrorInfoTypeFromString on String {
  DataSourceErrorInfoType toDataSourceErrorInfoType() {
    switch (this) {
      case 'ACCESS_DENIED':
        return DataSourceErrorInfoType.accessDenied;
      case 'COPY_SOURCE_NOT_FOUND':
        return DataSourceErrorInfoType.copySourceNotFound;
      case 'TIMEOUT':
        return DataSourceErrorInfoType.timeout;
      case 'ENGINE_VERSION_NOT_SUPPORTED':
        return DataSourceErrorInfoType.engineVersionNotSupported;
      case 'UNKNOWN_HOST':
        return DataSourceErrorInfoType.unknownHost;
      case 'GENERIC_SQL_FAILURE':
        return DataSourceErrorInfoType.genericSqlFailure;
      case 'CONFLICT':
        return DataSourceErrorInfoType.conflict;
      case 'UNKNOWN':
        return DataSourceErrorInfoType.unknown;
    }
    throw Exception('$this is not known in enum DataSourceErrorInfoType');
  }
}

enum DataSourceFilterAttribute {
  directQuicksightViewerOrOwner,
  directQuicksightOwner,
  directQuicksightSoleOwner,
  datasourceName,
}

extension DataSourceFilterAttributeValueExtension on DataSourceFilterAttribute {
  String toValue() {
    switch (this) {
      case DataSourceFilterAttribute.directQuicksightViewerOrOwner:
        return 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER';
      case DataSourceFilterAttribute.directQuicksightOwner:
        return 'DIRECT_QUICKSIGHT_OWNER';
      case DataSourceFilterAttribute.directQuicksightSoleOwner:
        return 'DIRECT_QUICKSIGHT_SOLE_OWNER';
      case DataSourceFilterAttribute.datasourceName:
        return 'DATASOURCE_NAME';
    }
  }
}

extension DataSourceFilterAttributeFromString on String {
  DataSourceFilterAttribute toDataSourceFilterAttribute() {
    switch (this) {
      case 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER':
        return DataSourceFilterAttribute.directQuicksightViewerOrOwner;
      case 'DIRECT_QUICKSIGHT_OWNER':
        return DataSourceFilterAttribute.directQuicksightOwner;
      case 'DIRECT_QUICKSIGHT_SOLE_OWNER':
        return DataSourceFilterAttribute.directQuicksightSoleOwner;
      case 'DATASOURCE_NAME':
        return DataSourceFilterAttribute.datasourceName;
    }
    throw Exception('$this is not known in enum DataSourceFilterAttribute');
  }
}

/// The parameters that Amazon QuickSight uses to connect to your underlying
/// data source. This is a variant type structure. For this structure to be
/// valid, only one of the attributes can be non-null.
class DataSourceParameters {
  /// The parameters for OpenSearch.
  final AmazonElasticsearchParameters? amazonElasticsearchParameters;

  /// The parameters for OpenSearch.
  final AmazonOpenSearchParameters? amazonOpenSearchParameters;

  /// The parameters for Amazon Athena.
  final AthenaParameters? athenaParameters;

  /// The parameters for Amazon Aurora MySQL.
  final AuroraParameters? auroraParameters;

  /// The parameters for Amazon Aurora.
  final AuroraPostgreSqlParameters? auroraPostgreSqlParameters;

  /// The parameters for IoT Analytics.
  final AwsIotAnalyticsParameters? awsIotAnalyticsParameters;

  /// The parameters that are required to connect to a Google BigQuery data
  /// source.
  final BigQueryParameters? bigQueryParameters;

  /// The parameters that are required to connect to a Databricks data source.
  final DatabricksParameters? databricksParameters;

  /// The parameters for Exasol.
  final ExasolParameters? exasolParameters;

  /// The parameters for Jira.
  final JiraParameters? jiraParameters;

  /// The parameters for MariaDB.
  final MariaDbParameters? mariaDbParameters;

  /// The parameters for MySQL.
  final MySqlParameters? mySqlParameters;

  /// The parameters for Oracle.
  final OracleParameters? oracleParameters;

  /// The parameters for PostgreSQL.
  final PostgreSqlParameters? postgreSqlParameters;

  /// The parameters for Presto.
  final PrestoParameters? prestoParameters;

  /// The parameters for Amazon RDS.
  final RdsParameters? rdsParameters;

  /// The parameters for Amazon Redshift.
  final RedshiftParameters? redshiftParameters;

  /// The parameters for S3.
  final S3Parameters? s3Parameters;

  /// The parameters for ServiceNow.
  final ServiceNowParameters? serviceNowParameters;

  /// The parameters for Snowflake.
  final SnowflakeParameters? snowflakeParameters;

  /// The parameters for Spark.
  final SparkParameters? sparkParameters;

  /// The parameters for SQL Server.
  final SqlServerParameters? sqlServerParameters;

  /// The parameters that are required to connect to a Starburst data source.
  final StarburstParameters? starburstParameters;

  /// The parameters for Teradata.
  final TeradataParameters? teradataParameters;

  /// The parameters that are required to connect to a Trino data source.
  final TrinoParameters? trinoParameters;

  /// The parameters for Twitter.
  final TwitterParameters? twitterParameters;

  DataSourceParameters({
    this.amazonElasticsearchParameters,
    this.amazonOpenSearchParameters,
    this.athenaParameters,
    this.auroraParameters,
    this.auroraPostgreSqlParameters,
    this.awsIotAnalyticsParameters,
    this.bigQueryParameters,
    this.databricksParameters,
    this.exasolParameters,
    this.jiraParameters,
    this.mariaDbParameters,
    this.mySqlParameters,
    this.oracleParameters,
    this.postgreSqlParameters,
    this.prestoParameters,
    this.rdsParameters,
    this.redshiftParameters,
    this.s3Parameters,
    this.serviceNowParameters,
    this.snowflakeParameters,
    this.sparkParameters,
    this.sqlServerParameters,
    this.starburstParameters,
    this.teradataParameters,
    this.trinoParameters,
    this.twitterParameters,
  });

  factory DataSourceParameters.fromJson(Map<String, dynamic> json) {
    return DataSourceParameters(
      amazonElasticsearchParameters:
          json['AmazonElasticsearchParameters'] != null
              ? AmazonElasticsearchParameters.fromJson(
                  json['AmazonElasticsearchParameters'] as Map<String, dynamic>)
              : null,
      amazonOpenSearchParameters: json['AmazonOpenSearchParameters'] != null
          ? AmazonOpenSearchParameters.fromJson(
              json['AmazonOpenSearchParameters'] as Map<String, dynamic>)
          : null,
      athenaParameters: json['AthenaParameters'] != null
          ? AthenaParameters.fromJson(
              json['AthenaParameters'] as Map<String, dynamic>)
          : null,
      auroraParameters: json['AuroraParameters'] != null
          ? AuroraParameters.fromJson(
              json['AuroraParameters'] as Map<String, dynamic>)
          : null,
      auroraPostgreSqlParameters: json['AuroraPostgreSqlParameters'] != null
          ? AuroraPostgreSqlParameters.fromJson(
              json['AuroraPostgreSqlParameters'] as Map<String, dynamic>)
          : null,
      awsIotAnalyticsParameters: json['AwsIotAnalyticsParameters'] != null
          ? AwsIotAnalyticsParameters.fromJson(
              json['AwsIotAnalyticsParameters'] as Map<String, dynamic>)
          : null,
      bigQueryParameters: json['BigQueryParameters'] != null
          ? BigQueryParameters.fromJson(
              json['BigQueryParameters'] as Map<String, dynamic>)
          : null,
      databricksParameters: json['DatabricksParameters'] != null
          ? DatabricksParameters.fromJson(
              json['DatabricksParameters'] as Map<String, dynamic>)
          : null,
      exasolParameters: json['ExasolParameters'] != null
          ? ExasolParameters.fromJson(
              json['ExasolParameters'] as Map<String, dynamic>)
          : null,
      jiraParameters: json['JiraParameters'] != null
          ? JiraParameters.fromJson(
              json['JiraParameters'] as Map<String, dynamic>)
          : null,
      mariaDbParameters: json['MariaDbParameters'] != null
          ? MariaDbParameters.fromJson(
              json['MariaDbParameters'] as Map<String, dynamic>)
          : null,
      mySqlParameters: json['MySqlParameters'] != null
          ? MySqlParameters.fromJson(
              json['MySqlParameters'] as Map<String, dynamic>)
          : null,
      oracleParameters: json['OracleParameters'] != null
          ? OracleParameters.fromJson(
              json['OracleParameters'] as Map<String, dynamic>)
          : null,
      postgreSqlParameters: json['PostgreSqlParameters'] != null
          ? PostgreSqlParameters.fromJson(
              json['PostgreSqlParameters'] as Map<String, dynamic>)
          : null,
      prestoParameters: json['PrestoParameters'] != null
          ? PrestoParameters.fromJson(
              json['PrestoParameters'] as Map<String, dynamic>)
          : null,
      rdsParameters: json['RdsParameters'] != null
          ? RdsParameters.fromJson(
              json['RdsParameters'] as Map<String, dynamic>)
          : null,
      redshiftParameters: json['RedshiftParameters'] != null
          ? RedshiftParameters.fromJson(
              json['RedshiftParameters'] as Map<String, dynamic>)
          : null,
      s3Parameters: json['S3Parameters'] != null
          ? S3Parameters.fromJson(json['S3Parameters'] as Map<String, dynamic>)
          : null,
      serviceNowParameters: json['ServiceNowParameters'] != null
          ? ServiceNowParameters.fromJson(
              json['ServiceNowParameters'] as Map<String, dynamic>)
          : null,
      snowflakeParameters: json['SnowflakeParameters'] != null
          ? SnowflakeParameters.fromJson(
              json['SnowflakeParameters'] as Map<String, dynamic>)
          : null,
      sparkParameters: json['SparkParameters'] != null
          ? SparkParameters.fromJson(
              json['SparkParameters'] as Map<String, dynamic>)
          : null,
      sqlServerParameters: json['SqlServerParameters'] != null
          ? SqlServerParameters.fromJson(
              json['SqlServerParameters'] as Map<String, dynamic>)
          : null,
      starburstParameters: json['StarburstParameters'] != null
          ? StarburstParameters.fromJson(
              json['StarburstParameters'] as Map<String, dynamic>)
          : null,
      teradataParameters: json['TeradataParameters'] != null
          ? TeradataParameters.fromJson(
              json['TeradataParameters'] as Map<String, dynamic>)
          : null,
      trinoParameters: json['TrinoParameters'] != null
          ? TrinoParameters.fromJson(
              json['TrinoParameters'] as Map<String, dynamic>)
          : null,
      twitterParameters: json['TwitterParameters'] != null
          ? TwitterParameters.fromJson(
              json['TwitterParameters'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final amazonElasticsearchParameters = this.amazonElasticsearchParameters;
    final amazonOpenSearchParameters = this.amazonOpenSearchParameters;
    final athenaParameters = this.athenaParameters;
    final auroraParameters = this.auroraParameters;
    final auroraPostgreSqlParameters = this.auroraPostgreSqlParameters;
    final awsIotAnalyticsParameters = this.awsIotAnalyticsParameters;
    final bigQueryParameters = this.bigQueryParameters;
    final databricksParameters = this.databricksParameters;
    final exasolParameters = this.exasolParameters;
    final jiraParameters = this.jiraParameters;
    final mariaDbParameters = this.mariaDbParameters;
    final mySqlParameters = this.mySqlParameters;
    final oracleParameters = this.oracleParameters;
    final postgreSqlParameters = this.postgreSqlParameters;
    final prestoParameters = this.prestoParameters;
    final rdsParameters = this.rdsParameters;
    final redshiftParameters = this.redshiftParameters;
    final s3Parameters = this.s3Parameters;
    final serviceNowParameters = this.serviceNowParameters;
    final snowflakeParameters = this.snowflakeParameters;
    final sparkParameters = this.sparkParameters;
    final sqlServerParameters = this.sqlServerParameters;
    final starburstParameters = this.starburstParameters;
    final teradataParameters = this.teradataParameters;
    final trinoParameters = this.trinoParameters;
    final twitterParameters = this.twitterParameters;
    return {
      if (amazonElasticsearchParameters != null)
        'AmazonElasticsearchParameters': amazonElasticsearchParameters,
      if (amazonOpenSearchParameters != null)
        'AmazonOpenSearchParameters': amazonOpenSearchParameters,
      if (athenaParameters != null) 'AthenaParameters': athenaParameters,
      if (auroraParameters != null) 'AuroraParameters': auroraParameters,
      if (auroraPostgreSqlParameters != null)
        'AuroraPostgreSqlParameters': auroraPostgreSqlParameters,
      if (awsIotAnalyticsParameters != null)
        'AwsIotAnalyticsParameters': awsIotAnalyticsParameters,
      if (bigQueryParameters != null) 'BigQueryParameters': bigQueryParameters,
      if (databricksParameters != null)
        'DatabricksParameters': databricksParameters,
      if (exasolParameters != null) 'ExasolParameters': exasolParameters,
      if (jiraParameters != null) 'JiraParameters': jiraParameters,
      if (mariaDbParameters != null) 'MariaDbParameters': mariaDbParameters,
      if (mySqlParameters != null) 'MySqlParameters': mySqlParameters,
      if (oracleParameters != null) 'OracleParameters': oracleParameters,
      if (postgreSqlParameters != null)
        'PostgreSqlParameters': postgreSqlParameters,
      if (prestoParameters != null) 'PrestoParameters': prestoParameters,
      if (rdsParameters != null) 'RdsParameters': rdsParameters,
      if (redshiftParameters != null) 'RedshiftParameters': redshiftParameters,
      if (s3Parameters != null) 'S3Parameters': s3Parameters,
      if (serviceNowParameters != null)
        'ServiceNowParameters': serviceNowParameters,
      if (snowflakeParameters != null)
        'SnowflakeParameters': snowflakeParameters,
      if (sparkParameters != null) 'SparkParameters': sparkParameters,
      if (sqlServerParameters != null)
        'SqlServerParameters': sqlServerParameters,
      if (starburstParameters != null)
        'StarburstParameters': starburstParameters,
      if (teradataParameters != null) 'TeradataParameters': teradataParameters,
      if (trinoParameters != null) 'TrinoParameters': trinoParameters,
      if (twitterParameters != null) 'TwitterParameters': twitterParameters,
    };
  }
}

/// A filter that you apply when searching for data sources.
class DataSourceSearchFilter {
  /// The name of the value that you want to use as a filter, for example,
  /// <code>"Name": "DIRECT_QUICKSIGHT_OWNER"</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or
  /// group, and any data sources with that ARN listed as one of the owners or
  /// viewers of the data sources are returned. Implicit permissions from folders
  /// or groups are not considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and
  /// any data sources with that ARN listed as one of the owners if the data
  /// source are returned. Implicit permissions from folders or groups are not
  /// considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or
  /// group, and any data sources with that ARN listed as the only owner of the
  /// data source are returned. Implicit permissions from folders or groups are
  /// not considered.
  /// </li>
  /// <li>
  /// <code>DATASOURCE_NAME</code>: Any data sources whose names have a substring
  /// match to the provided value are returned.
  /// </li>
  /// </ul>
  final DataSourceFilterAttribute name;

  /// The comparison operator that you want to use as a filter, for example
  /// <code>"Operator": "StringEquals"</code>. Valid values are
  /// <code>"StringEquals"</code> and <code>"StringLike"</code>.
  ///
  /// If you set the operator value to <code>"StringEquals"</code>, you need to
  /// provide an ownership related filter in the <code>"NAME"</code> field and the
  /// arn of the user or group whose data sources you want to search in the
  /// <code>"Value"</code> field. For example,
  /// <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  ///
  /// If you set the value to <code>"StringLike"</code>, you need to provide the
  /// name of the data sources you are searching for. For example,
  /// <code>"Name":"DATASOURCE_NAME", "Operator": "StringLike", "Value":
  /// "Test"</code>. The <code>"StringLike"</code> operator only supports the
  /// <code>NAME</code> value <code>DATASOURCE_NAME</code>.
  final FilterOperator operator;

  /// The value of the named item, for example
  /// <code>DIRECT_QUICKSIGHT_OWNER</code>, that you want to use as a filter, for
  /// example, <code>"Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  final String value;

  DataSourceSearchFilter({
    required this.name,
    required this.operator,
    required this.value,
  });

  Map<String, dynamic> toJson() {
    final name = this.name;
    final operator = this.operator;
    final value = this.value;
    return {
      'Name': name.toValue(),
      'Operator': operator.toValue(),
      'Value': value,
    };
  }
}

/// A <code>DataSourceSummary</code> object that returns a summary of a data
/// source.
class DataSourceSummary {
  /// The arn of the datasource.
  final String? arn;

  /// The date and time that the data source was created. This value is expressed
  /// in MM-DD-YYYY HH:MM:SS format.
  final DateTime? createdTime;

  /// The unique ID of the data source.
  final String? dataSourceId;

  /// The date and time the data source was last updated. This value is expressed
  /// in MM-DD-YYYY HH:MM:SS format.
  final DateTime? lastUpdatedTime;

  /// The name of the data source.
  final String? name;

  /// The type of the data source.
  final DataSourceType? type;

  DataSourceSummary({
    this.arn,
    this.createdTime,
    this.dataSourceId,
    this.lastUpdatedTime,
    this.name,
    this.type,
  });

  factory DataSourceSummary.fromJson(Map<String, dynamic> json) {
    return DataSourceSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSourceId: json['DataSourceId'] as String?,
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      type: (json['Type'] as String?)?.toDataSourceType(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final dataSourceId = this.dataSourceId;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final type = this.type;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum DataSourceType {
  adobeAnalytics,
  amazonElasticsearch,
  athena,
  aurora,
  auroraPostgresql,
  awsIotAnalytics,
  github,
  jira,
  mariadb,
  mysql,
  oracle,
  postgresql,
  presto,
  redshift,
  s3,
  salesforce,
  servicenow,
  snowflake,
  spark,
  sqlserver,
  teradata,
  twitter,
  timestream,
  amazonOpensearch,
  exasol,
  databricks,
  starburst,
  trino,
  bigquery,
}

extension DataSourceTypeValueExtension on DataSourceType {
  String toValue() {
    switch (this) {
      case DataSourceType.adobeAnalytics:
        return 'ADOBE_ANALYTICS';
      case DataSourceType.amazonElasticsearch:
        return 'AMAZON_ELASTICSEARCH';
      case DataSourceType.athena:
        return 'ATHENA';
      case DataSourceType.aurora:
        return 'AURORA';
      case DataSourceType.auroraPostgresql:
        return 'AURORA_POSTGRESQL';
      case DataSourceType.awsIotAnalytics:
        return 'AWS_IOT_ANALYTICS';
      case DataSourceType.github:
        return 'GITHUB';
      case DataSourceType.jira:
        return 'JIRA';
      case DataSourceType.mariadb:
        return 'MARIADB';
      case DataSourceType.mysql:
        return 'MYSQL';
      case DataSourceType.oracle:
        return 'ORACLE';
      case DataSourceType.postgresql:
        return 'POSTGRESQL';
      case DataSourceType.presto:
        return 'PRESTO';
      case DataSourceType.redshift:
        return 'REDSHIFT';
      case DataSourceType.s3:
        return 'S3';
      case DataSourceType.salesforce:
        return 'SALESFORCE';
      case DataSourceType.servicenow:
        return 'SERVICENOW';
      case DataSourceType.snowflake:
        return 'SNOWFLAKE';
      case DataSourceType.spark:
        return 'SPARK';
      case DataSourceType.sqlserver:
        return 'SQLSERVER';
      case DataSourceType.teradata:
        return 'TERADATA';
      case DataSourceType.twitter:
        return 'TWITTER';
      case DataSourceType.timestream:
        return 'TIMESTREAM';
      case DataSourceType.amazonOpensearch:
        return 'AMAZON_OPENSEARCH';
      case DataSourceType.exasol:
        return 'EXASOL';
      case DataSourceType.databricks:
        return 'DATABRICKS';
      case DataSourceType.starburst:
        return 'STARBURST';
      case DataSourceType.trino:
        return 'TRINO';
      case DataSourceType.bigquery:
        return 'BIGQUERY';
    }
  }
}

extension DataSourceTypeFromString on String {
  DataSourceType toDataSourceType() {
    switch (this) {
      case 'ADOBE_ANALYTICS':
        return DataSourceType.adobeAnalytics;
      case 'AMAZON_ELASTICSEARCH':
        return DataSourceType.amazonElasticsearch;
      case 'ATHENA':
        return DataSourceType.athena;
      case 'AURORA':
        return DataSourceType.aurora;
      case 'AURORA_POSTGRESQL':
        return DataSourceType.auroraPostgresql;
      case 'AWS_IOT_ANALYTICS':
        return DataSourceType.awsIotAnalytics;
      case 'GITHUB':
        return DataSourceType.github;
      case 'JIRA':
        return DataSourceType.jira;
      case 'MARIADB':
        return DataSourceType.mariadb;
      case 'MYSQL':
        return DataSourceType.mysql;
      case 'ORACLE':
        return DataSourceType.oracle;
      case 'POSTGRESQL':
        return DataSourceType.postgresql;
      case 'PRESTO':
        return DataSourceType.presto;
      case 'REDSHIFT':
        return DataSourceType.redshift;
      case 'S3':
        return DataSourceType.s3;
      case 'SALESFORCE':
        return DataSourceType.salesforce;
      case 'SERVICENOW':
        return DataSourceType.servicenow;
      case 'SNOWFLAKE':
        return DataSourceType.snowflake;
      case 'SPARK':
        return DataSourceType.spark;
      case 'SQLSERVER':
        return DataSourceType.sqlserver;
      case 'TERADATA':
        return DataSourceType.teradata;
      case 'TWITTER':
        return DataSourceType.twitter;
      case 'TIMESTREAM':
        return DataSourceType.timestream;
      case 'AMAZON_OPENSEARCH':
        return DataSourceType.amazonOpensearch;
      case 'EXASOL':
        return DataSourceType.exasol;
      case 'DATABRICKS':
        return DataSourceType.databricks;
      case 'STARBURST':
        return DataSourceType.starburst;
      case 'TRINO':
        return DataSourceType.trino;
      case 'BIGQUERY':
        return DataSourceType.bigquery;
    }
    throw Exception('$this is not known in enum DataSourceType');
  }
}

/// The parameters that are required to connect to a Databricks data source.
class DatabricksParameters {
  /// The host name of the Databricks data source.
  final String host;

  /// The port for the Databricks data source.
  final int port;

  /// The HTTP path of the Databricks data source.
  final String sqlEndpointPath;

  DatabricksParameters({
    required this.host,
    required this.port,
    required this.sqlEndpointPath,
  });

  factory DatabricksParameters.fromJson(Map<String, dynamic> json) {
    return DatabricksParameters(
      host: json['Host'] as String,
      port: json['Port'] as int,
      sqlEndpointPath: json['SqlEndpointPath'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final host = this.host;
    final port = this.port;
    final sqlEndpointPath = this.sqlEndpointPath;
    return {
      'Host': host,
      'Port': port,
      'SqlEndpointPath': sqlEndpointPath,
    };
  }
}

/// A structure that represents a dataset.
class DatasetMetadata {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String datasetArn;

  /// The list of calculated field definitions.
  final List<TopicCalculatedField>? calculatedFields;

  /// The list of column definitions.
  final List<TopicColumn>? columns;

  /// The definition of a data aggregation.
  final DataAggregation? dataAggregation;

  /// The description of the dataset.
  final String? datasetDescription;

  /// The name of the dataset.
  final String? datasetName;

  /// The list of filter definitions.
  final List<TopicFilter>? filters;

  /// The list of named entities definitions.
  final List<TopicNamedEntity>? namedEntities;

  DatasetMetadata({
    required this.datasetArn,
    this.calculatedFields,
    this.columns,
    this.dataAggregation,
    this.datasetDescription,
    this.datasetName,
    this.filters,
    this.namedEntities,
  });

  factory DatasetMetadata.fromJson(Map<String, dynamic> json) {
    return DatasetMetadata(
      datasetArn: json['DatasetArn'] as String,
      calculatedFields: (json['CalculatedFields'] as List?)
          ?.whereNotNull()
          .map((e) => TopicCalculatedField.fromJson(e as Map<String, dynamic>))
          .toList(),
      columns: (json['Columns'] as List?)
          ?.whereNotNull()
          .map((e) => TopicColumn.fromJson(e as Map<String, dynamic>))
          .toList(),
      dataAggregation: json['DataAggregation'] != null
          ? DataAggregation.fromJson(
              json['DataAggregation'] as Map<String, dynamic>)
          : null,
      datasetDescription: json['DatasetDescription'] as String?,
      datasetName: json['DatasetName'] as String?,
      filters: (json['Filters'] as List?)
          ?.whereNotNull()
          .map((e) => TopicFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
      namedEntities: (json['NamedEntities'] as List?)
          ?.whereNotNull()
          .map((e) => TopicNamedEntity.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final datasetArn = this.datasetArn;
    final calculatedFields = this.calculatedFields;
    final columns = this.columns;
    final dataAggregation = this.dataAggregation;
    final datasetDescription = this.datasetDescription;
    final datasetName = this.datasetName;
    final filters = this.filters;
    final namedEntities = this.namedEntities;
    return {
      'DatasetArn': datasetArn,
      if (calculatedFields != null) 'CalculatedFields': calculatedFields,
      if (columns != null) 'Columns': columns,
      if (dataAggregation != null) 'DataAggregation': dataAggregation,
      if (datasetDescription != null) 'DatasetDescription': datasetDescription,
      if (datasetName != null) 'DatasetName': datasetName,
      if (filters != null) 'Filters': filters,
      if (namedEntities != null) 'NamedEntities': namedEntities,
    };
  }
}

/// A parameter that is created in a dataset. The parameter can be a string,
/// integer, decimal, or datetime data type.
class DatasetParameter {
  /// A date time parameter that is created in the dataset.
  final DateTimeDatasetParameter? dateTimeDatasetParameter;

  /// A decimal parameter that is created in the dataset.
  final DecimalDatasetParameter? decimalDatasetParameter;

  /// An integer parameter that is created in the dataset.
  final IntegerDatasetParameter? integerDatasetParameter;

  /// A string parameter that is created in the dataset.
  final StringDatasetParameter? stringDatasetParameter;

  DatasetParameter({
    this.dateTimeDatasetParameter,
    this.decimalDatasetParameter,
    this.integerDatasetParameter,
    this.stringDatasetParameter,
  });

  factory DatasetParameter.fromJson(Map<String, dynamic> json) {
    return DatasetParameter(
      dateTimeDatasetParameter: json['DateTimeDatasetParameter'] != null
          ? DateTimeDatasetParameter.fromJson(
              json['DateTimeDatasetParameter'] as Map<String, dynamic>)
          : null,
      decimalDatasetParameter: json['DecimalDatasetParameter'] != null
          ? DecimalDatasetParameter.fromJson(
              json['DecimalDatasetParameter'] as Map<String, dynamic>)
          : null,
      integerDatasetParameter: json['IntegerDatasetParameter'] != null
          ? IntegerDatasetParameter.fromJson(
              json['IntegerDatasetParameter'] as Map<String, dynamic>)
          : null,
      stringDatasetParameter: json['StringDatasetParameter'] != null
          ? StringDatasetParameter.fromJson(
              json['StringDatasetParameter'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeDatasetParameter = this.dateTimeDatasetParameter;
    final decimalDatasetParameter = this.decimalDatasetParameter;
    final integerDatasetParameter = this.integerDatasetParameter;
    final stringDatasetParameter = this.stringDatasetParameter;
    return {
      if (dateTimeDatasetParameter != null)
        'DateTimeDatasetParameter': dateTimeDatasetParameter,
      if (decimalDatasetParameter != null)
        'DecimalDatasetParameter': decimalDatasetParameter,
      if (integerDatasetParameter != null)
        'IntegerDatasetParameter': integerDatasetParameter,
      if (stringDatasetParameter != null)
        'StringDatasetParameter': stringDatasetParameter,
    };
  }
}

/// The value type of the parameter. The value type is used to validate the
/// parameter before it is evaluated.
enum DatasetParameterValueType {
  multiValued,
  singleValued,
}

extension DatasetParameterValueTypeValueExtension on DatasetParameterValueType {
  String toValue() {
    switch (this) {
      case DatasetParameterValueType.multiValued:
        return 'MULTI_VALUED';
      case DatasetParameterValueType.singleValued:
        return 'SINGLE_VALUED';
    }
  }
}

extension DatasetParameterValueTypeFromString on String {
  DatasetParameterValueType toDatasetParameterValueType() {
    switch (this) {
      case 'MULTI_VALUED':
        return DatasetParameterValueType.multiValued;
      case 'SINGLE_VALUED':
        return DatasetParameterValueType.singleValued;
    }
    throw Exception('$this is not known in enum DatasetParameterValueType');
  }
}

enum DateAggregationFunction {
  count,
  distinctCount,
  min,
  max,
}

extension DateAggregationFunctionValueExtension on DateAggregationFunction {
  String toValue() {
    switch (this) {
      case DateAggregationFunction.count:
        return 'COUNT';
      case DateAggregationFunction.distinctCount:
        return 'DISTINCT_COUNT';
      case DateAggregationFunction.min:
        return 'MIN';
      case DateAggregationFunction.max:
        return 'MAX';
    }
  }
}

extension DateAggregationFunctionFromString on String {
  DateAggregationFunction toDateAggregationFunction() {
    switch (this) {
      case 'COUNT':
        return DateAggregationFunction.count;
      case 'DISTINCT_COUNT':
        return DateAggregationFunction.distinctCount;
      case 'MIN':
        return DateAggregationFunction.min;
      case 'MAX':
        return DateAggregationFunction.max;
    }
    throw Exception('$this is not known in enum DateAggregationFunction');
  }
}

/// The options that determine how a date axis is displayed.
class DateAxisOptions {
  /// Determines whether or not missing dates are displayed.
  final Visibility? missingDateVisibility;

  DateAxisOptions({
    this.missingDateVisibility,
  });

  factory DateAxisOptions.fromJson(Map<String, dynamic> json) {
    return DateAxisOptions(
      missingDateVisibility:
          (json['MissingDateVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final missingDateVisibility = this.missingDateVisibility;
    return {
      if (missingDateVisibility != null)
        'MissingDateVisibility': missingDateVisibility.toValue(),
    };
  }
}

/// The dimension type field with date type columns.
class DateDimensionField {
  /// The column that is used in the <code>DateDimensionField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The date granularity of the <code>DateDimensionField</code>. Choose one of
  /// the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>YEAR</code>
  /// </li>
  /// <li>
  /// <code>QUARTER</code>
  /// </li>
  /// <li>
  /// <code>MONTH</code>
  /// </li>
  /// <li>
  /// <code>WEEK</code>
  /// </li>
  /// <li>
  /// <code>DAY</code>
  /// </li>
  /// <li>
  /// <code>HOUR</code>
  /// </li>
  /// <li>
  /// <code>MINUTE</code>
  /// </li>
  /// <li>
  /// <code>SECOND</code>
  /// </li>
  /// <li>
  /// <code>MILLISECOND</code>
  /// </li>
  /// </ul>
  final TimeGranularity? dateGranularity;

  /// The format configuration of the field.
  final DateTimeFormatConfiguration? formatConfiguration;

  /// The custom hierarchy ID.
  final String? hierarchyId;

  DateDimensionField({
    required this.column,
    required this.fieldId,
    this.dateGranularity,
    this.formatConfiguration,
    this.hierarchyId,
  });

  factory DateDimensionField.fromJson(Map<String, dynamic> json) {
    return DateDimensionField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      dateGranularity:
          (json['DateGranularity'] as String?)?.toTimeGranularity(),
      formatConfiguration: json['FormatConfiguration'] != null
          ? DateTimeFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
      hierarchyId: json['HierarchyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final dateGranularity = this.dateGranularity;
    final formatConfiguration = this.formatConfiguration;
    final hierarchyId = this.hierarchyId;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (dateGranularity != null) 'DateGranularity': dateGranularity.toValue(),
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
      if (hierarchyId != null) 'HierarchyId': hierarchyId,
    };
  }
}

/// The measure type field with date type columns.
class DateMeasureField {
  /// The column that is used in the <code>DateMeasureField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The aggregation function of the measure field.
  final DateAggregationFunction? aggregationFunction;

  /// The format configuration of the field.
  final DateTimeFormatConfiguration? formatConfiguration;

  DateMeasureField({
    required this.column,
    required this.fieldId,
    this.aggregationFunction,
    this.formatConfiguration,
  });

  factory DateMeasureField.fromJson(Map<String, dynamic> json) {
    return DateMeasureField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      aggregationFunction:
          (json['AggregationFunction'] as String?)?.toDateAggregationFunction(),
      formatConfiguration: json['FormatConfiguration'] != null
          ? DateTimeFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final aggregationFunction = this.aggregationFunction;
    final formatConfiguration = this.formatConfiguration;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction.toValue(),
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
    };
  }
}

/// A date time parameter for a dataset.
class DateTimeDatasetParameter {
  /// An identifier for the parameter that is created in the dataset.
  final String id;

  /// The name of the date time parameter that is created in the dataset.
  final String name;

  /// The value type of the dataset parameter. Valid values are <code>single
  /// value</code> or <code>multi value</code>.
  final DatasetParameterValueType valueType;

  /// A list of default values for a given date time parameter. This structure
  /// only accepts static values.
  final DateTimeDatasetParameterDefaultValues? defaultValues;

  /// The time granularity of the date time parameter.
  final TimeGranularity? timeGranularity;

  DateTimeDatasetParameter({
    required this.id,
    required this.name,
    required this.valueType,
    this.defaultValues,
    this.timeGranularity,
  });

  factory DateTimeDatasetParameter.fromJson(Map<String, dynamic> json) {
    return DateTimeDatasetParameter(
      id: json['Id'] as String,
      name: json['Name'] as String,
      valueType: (json['ValueType'] as String).toDatasetParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? DateTimeDatasetParameterDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final name = this.name;
    final valueType = this.valueType;
    final defaultValues = this.defaultValues;
    final timeGranularity = this.timeGranularity;
    return {
      'Id': id,
      'Name': name,
      'ValueType': valueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// The default values of a date time parameter.
class DateTimeDatasetParameterDefaultValues {
  /// A list of static default values for a given date time parameter.
  final List<DateTime>? staticValues;

  DateTimeDatasetParameterDefaultValues({
    this.staticValues,
  });

  factory DateTimeDatasetParameterDefaultValues.fromJson(
      Map<String, dynamic> json) {
    return DateTimeDatasetParameterDefaultValues(
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map(nonNullableTimeStampFromJson)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final staticValues = this.staticValues;
    return {
      if (staticValues != null)
        'StaticValues': staticValues.map(unixTimestampToJson).toList(),
    };
  }
}

/// The default values of the <code>DateTimeParameterDeclaration</code>.
class DateTimeDefaultValues {
  /// The dynamic value of the <code>DataTimeDefaultValues</code>. Different
  /// defaults are displayed according to users, groups, and values mapping.
  final DynamicDefaultValue? dynamicValue;

  /// The rolling date of the <code>DataTimeDefaultValues</code>. The date is
  /// determined from the dataset based on input expression.
  final RollingDateConfiguration? rollingDate;

  /// The static values of the <code>DataTimeDefaultValues</code>.
  final List<DateTime>? staticValues;

  DateTimeDefaultValues({
    this.dynamicValue,
    this.rollingDate,
    this.staticValues,
  });

  factory DateTimeDefaultValues.fromJson(Map<String, dynamic> json) {
    return DateTimeDefaultValues(
      dynamicValue: json['DynamicValue'] != null
          ? DynamicDefaultValue.fromJson(
              json['DynamicValue'] as Map<String, dynamic>)
          : null,
      rollingDate: json['RollingDate'] != null
          ? RollingDateConfiguration.fromJson(
              json['RollingDate'] as Map<String, dynamic>)
          : null,
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map(nonNullableTimeStampFromJson)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dynamicValue = this.dynamicValue;
    final rollingDate = this.rollingDate;
    final staticValues = this.staticValues;
    return {
      if (dynamicValue != null) 'DynamicValue': dynamicValue,
      if (rollingDate != null) 'RollingDate': rollingDate,
      if (staticValues != null)
        'StaticValues': staticValues.map(unixTimestampToJson).toList(),
    };
  }
}

/// Formatting configuration for <code>DateTime</code> fields.
class DateTimeFormatConfiguration {
  /// Determines the <code>DateTime</code> format.
  final String? dateTimeFormat;

  /// The options that determine the null value format configuration.
  final NullValueFormatConfiguration? nullValueFormatConfiguration;

  /// The formatting configuration for numeric <code>DateTime</code> fields.
  final NumericFormatConfiguration? numericFormatConfiguration;

  DateTimeFormatConfiguration({
    this.dateTimeFormat,
    this.nullValueFormatConfiguration,
    this.numericFormatConfiguration,
  });

  factory DateTimeFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return DateTimeFormatConfiguration(
      dateTimeFormat: json['DateTimeFormat'] as String?,
      nullValueFormatConfiguration: json['NullValueFormatConfiguration'] != null
          ? NullValueFormatConfiguration.fromJson(
              json['NullValueFormatConfiguration'] as Map<String, dynamic>)
          : null,
      numericFormatConfiguration: json['NumericFormatConfiguration'] != null
          ? NumericFormatConfiguration.fromJson(
              json['NumericFormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeFormat = this.dateTimeFormat;
    final nullValueFormatConfiguration = this.nullValueFormatConfiguration;
    final numericFormatConfiguration = this.numericFormatConfiguration;
    return {
      if (dateTimeFormat != null) 'DateTimeFormat': dateTimeFormat,
      if (nullValueFormatConfiguration != null)
        'NullValueFormatConfiguration': nullValueFormatConfiguration,
      if (numericFormatConfiguration != null)
        'NumericFormatConfiguration': numericFormatConfiguration,
    };
  }
}

/// The option that determines the hierarchy of any <code>DateTime</code>
/// fields.
class DateTimeHierarchy {
  /// The hierarchy ID of the <code>DateTime</code> hierarchy.
  final String hierarchyId;

  /// The option that determines the drill down filters for the
  /// <code>DateTime</code> hierarchy.
  final List<DrillDownFilter>? drillDownFilters;

  DateTimeHierarchy({
    required this.hierarchyId,
    this.drillDownFilters,
  });

  factory DateTimeHierarchy.fromJson(Map<String, dynamic> json) {
    return DateTimeHierarchy(
      hierarchyId: json['HierarchyId'] as String,
      drillDownFilters: (json['DrillDownFilters'] as List?)
          ?.whereNotNull()
          .map((e) => DrillDownFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final hierarchyId = this.hierarchyId;
    final drillDownFilters = this.drillDownFilters;
    return {
      'HierarchyId': hierarchyId,
      if (drillDownFilters != null) 'DrillDownFilters': drillDownFilters,
    };
  }
}

/// A date-time parameter.
class DateTimeParameter {
  /// A display name for the date-time parameter.
  final String name;

  /// The values for the date-time parameter.
  final List<DateTime> values;

  DateTimeParameter({
    required this.name,
    required this.values,
  });

  factory DateTimeParameter.fromJson(Map<String, dynamic> json) {
    return DateTimeParameter(
      name: json['Name'] as String,
      values: (json['Values'] as List)
          .whereNotNull()
          .map(nonNullableTimeStampFromJson)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final values = this.values;
    return {
      'Name': name,
      'Values': values.map(unixTimestampToJson).toList(),
    };
  }
}

/// A parameter declaration for the <code>DateTime</code> data type.
class DateTimeParameterDeclaration {
  /// The name of the parameter that is being declared.
  final String name;

  /// The default values of a parameter. If the parameter is a single-value
  /// parameter, a maximum of one default value can be provided.
  final DateTimeDefaultValues? defaultValues;
  final List<MappedDataSetParameter>? mappedDataSetParameters;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TimeGranularity? timeGranularity;

  /// The configuration that defines the default value of a <code>DateTime</code>
  /// parameter when a value has not been set.
  final DateTimeValueWhenUnsetConfiguration? valueWhenUnset;

  DateTimeParameterDeclaration({
    required this.name,
    this.defaultValues,
    this.mappedDataSetParameters,
    this.timeGranularity,
    this.valueWhenUnset,
  });

  factory DateTimeParameterDeclaration.fromJson(Map<String, dynamic> json) {
    return DateTimeParameterDeclaration(
      name: json['Name'] as String,
      defaultValues: json['DefaultValues'] != null
          ? DateTimeDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
      mappedDataSetParameters: (json['MappedDataSetParameters'] as List?)
          ?.whereNotNull()
          .map(
              (e) => MappedDataSetParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTimeGranularity(),
      valueWhenUnset: json['ValueWhenUnset'] != null
          ? DateTimeValueWhenUnsetConfiguration.fromJson(
              json['ValueWhenUnset'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final defaultValues = this.defaultValues;
    final mappedDataSetParameters = this.mappedDataSetParameters;
    final timeGranularity = this.timeGranularity;
    final valueWhenUnset = this.valueWhenUnset;
    return {
      'Name': name,
      if (defaultValues != null) 'DefaultValues': defaultValues,
      if (mappedDataSetParameters != null)
        'MappedDataSetParameters': mappedDataSetParameters,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
      if (valueWhenUnset != null) 'ValueWhenUnset': valueWhenUnset,
    };
  }
}

/// The display options of a control.
class DateTimePickerControlDisplayOptions {
  /// Customize how dates are formatted in controls.
  final String? dateTimeFormat;

  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  DateTimePickerControlDisplayOptions({
    this.dateTimeFormat,
    this.infoIconLabelOptions,
    this.titleOptions,
  });

  factory DateTimePickerControlDisplayOptions.fromJson(
      Map<String, dynamic> json) {
    return DateTimePickerControlDisplayOptions(
      dateTimeFormat: json['DateTimeFormat'] as String?,
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeFormat = this.dateTimeFormat;
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final titleOptions = this.titleOptions;
    return {
      if (dateTimeFormat != null) 'DateTimeFormat': dateTimeFormat,
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

/// The configuration that defines the default value of a <code>DateTime</code>
/// parameter when a value has not been set.
class DateTimeValueWhenUnsetConfiguration {
  /// A custom value that's used when the value of a parameter isn't set.
  final DateTime? customValue;

  /// The built-in options for default values. The value can be one of the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>RECOMMENDED</code>: The recommended value.
  /// </li>
  /// <li>
  /// <code>NULL</code>: The <code>NULL</code> value.
  /// </li>
  /// </ul>
  final ValueWhenUnsetOption? valueWhenUnsetOption;

  DateTimeValueWhenUnsetConfiguration({
    this.customValue,
    this.valueWhenUnsetOption,
  });

  factory DateTimeValueWhenUnsetConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DateTimeValueWhenUnsetConfiguration(
      customValue: timeStampFromJson(json['CustomValue']),
      valueWhenUnsetOption:
          (json['ValueWhenUnsetOption'] as String?)?.toValueWhenUnsetOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final customValue = this.customValue;
    final valueWhenUnsetOption = this.valueWhenUnsetOption;
    return {
      if (customValue != null) 'CustomValue': unixTimestampToJson(customValue),
      if (valueWhenUnsetOption != null)
        'ValueWhenUnsetOption': valueWhenUnsetOption.toValue(),
    };
  }
}

enum DayOfTheWeek {
  sunday,
  monday,
  tuesday,
  wednesday,
  thursday,
  friday,
  saturday,
}

extension DayOfTheWeekValueExtension on DayOfTheWeek {
  String toValue() {
    switch (this) {
      case DayOfTheWeek.sunday:
        return 'SUNDAY';
      case DayOfTheWeek.monday:
        return 'MONDAY';
      case DayOfTheWeek.tuesday:
        return 'TUESDAY';
      case DayOfTheWeek.wednesday:
        return 'WEDNESDAY';
      case DayOfTheWeek.thursday:
        return 'THURSDAY';
      case DayOfTheWeek.friday:
        return 'FRIDAY';
      case DayOfTheWeek.saturday:
        return 'SATURDAY';
    }
  }
}

extension DayOfTheWeekFromString on String {
  DayOfTheWeek toDayOfTheWeek() {
    switch (this) {
      case 'SUNDAY':
        return DayOfTheWeek.sunday;
      case 'MONDAY':
        return DayOfTheWeek.monday;
      case 'TUESDAY':
        return DayOfTheWeek.tuesday;
      case 'WEDNESDAY':
        return DayOfTheWeek.wednesday;
      case 'THURSDAY':
        return DayOfTheWeek.thursday;
      case 'FRIDAY':
        return DayOfTheWeek.friday;
      case 'SATURDAY':
        return DayOfTheWeek.saturday;
    }
    throw Exception('$this is not known in enum DayOfTheWeek');
  }
}

enum DayOfWeek {
  sunday,
  monday,
  tuesday,
  wednesday,
  thursday,
  friday,
  saturday,
}

extension DayOfWeekValueExtension on DayOfWeek {
  String toValue() {
    switch (this) {
      case DayOfWeek.sunday:
        return 'SUNDAY';
      case DayOfWeek.monday:
        return 'MONDAY';
      case DayOfWeek.tuesday:
        return 'TUESDAY';
      case DayOfWeek.wednesday:
        return 'WEDNESDAY';
      case DayOfWeek.thursday:
        return 'THURSDAY';
      case DayOfWeek.friday:
        return 'FRIDAY';
      case DayOfWeek.saturday:
        return 'SATURDAY';
    }
  }
}

extension DayOfWeekFromString on String {
  DayOfWeek toDayOfWeek() {
    switch (this) {
      case 'SUNDAY':
        return DayOfWeek.sunday;
      case 'MONDAY':
        return DayOfWeek.monday;
      case 'TUESDAY':
        return DayOfWeek.tuesday;
      case 'WEDNESDAY':
        return DayOfWeek.wednesday;
      case 'THURSDAY':
        return DayOfWeek.thursday;
      case 'FRIDAY':
        return DayOfWeek.friday;
      case 'SATURDAY':
        return DayOfWeek.saturday;
    }
    throw Exception('$this is not known in enum DayOfWeek');
  }
}

/// A decimal parameter for a dataset.
class DecimalDatasetParameter {
  /// An identifier for the decimal parameter created in the dataset.
  final String id;

  /// The name of the decimal parameter that is created in the dataset.
  final String name;

  /// The value type of the dataset parameter. Valid values are <code>single
  /// value</code> or <code>multi value</code>.
  final DatasetParameterValueType valueType;

  /// A list of default values for a given decimal parameter. This structure only
  /// accepts static values.
  final DecimalDatasetParameterDefaultValues? defaultValues;

  DecimalDatasetParameter({
    required this.id,
    required this.name,
    required this.valueType,
    this.defaultValues,
  });

  factory DecimalDatasetParameter.fromJson(Map<String, dynamic> json) {
    return DecimalDatasetParameter(
      id: json['Id'] as String,
      name: json['Name'] as String,
      valueType: (json['ValueType'] as String).toDatasetParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? DecimalDatasetParameterDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final name = this.name;
    final valueType = this.valueType;
    final defaultValues = this.defaultValues;
    return {
      'Id': id,
      'Name': name,
      'ValueType': valueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
    };
  }
}

/// The default values of a decimal parameter.
class DecimalDatasetParameterDefaultValues {
  /// A list of static default values for a given decimal parameter.
  final List<double>? staticValues;

  DecimalDatasetParameterDefaultValues({
    this.staticValues,
  });

  factory DecimalDatasetParameterDefaultValues.fromJson(
      Map<String, dynamic> json) {
    return DecimalDatasetParameterDefaultValues(
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as double)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final staticValues = this.staticValues;
    return {
      if (staticValues != null) 'StaticValues': staticValues,
    };
  }
}

/// The default values of the <code>DecimalParameterDeclaration</code>.
class DecimalDefaultValues {
  /// The dynamic value of the <code>DecimalDefaultValues</code>. Different
  /// defaults are displayed according to users, groups, and values mapping.
  final DynamicDefaultValue? dynamicValue;

  /// The static values of the <code>DecimalDefaultValues</code>.
  final List<double>? staticValues;

  DecimalDefaultValues({
    this.dynamicValue,
    this.staticValues,
  });

  factory DecimalDefaultValues.fromJson(Map<String, dynamic> json) {
    return DecimalDefaultValues(
      dynamicValue: json['DynamicValue'] != null
          ? DynamicDefaultValue.fromJson(
              json['DynamicValue'] as Map<String, dynamic>)
          : null,
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as double)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dynamicValue = this.dynamicValue;
    final staticValues = this.staticValues;
    return {
      if (dynamicValue != null) 'DynamicValue': dynamicValue,
      if (staticValues != null) 'StaticValues': staticValues,
    };
  }
}

/// A decimal parameter.
class DecimalParameter {
  /// A display name for the decimal parameter.
  final String name;

  /// The values for the decimal parameter.
  final List<double> values;

  DecimalParameter({
    required this.name,
    required this.values,
  });

  factory DecimalParameter.fromJson(Map<String, dynamic> json) {
    return DecimalParameter(
      name: json['Name'] as String,
      values: (json['Values'] as List)
          .whereNotNull()
          .map((e) => e as double)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final values = this.values;
    return {
      'Name': name,
      'Values': values,
    };
  }
}

/// A parameter declaration for the <code>Decimal</code> data type.
class DecimalParameterDeclaration {
  /// The name of the parameter that is being declared.
  final String name;

  /// The value type determines whether the parameter is a single-value or
  /// multi-value parameter.
  final ParameterValueType parameterValueType;

  /// The default values of a parameter. If the parameter is a single-value
  /// parameter, a maximum of one default value can be provided.
  final DecimalDefaultValues? defaultValues;
  final List<MappedDataSetParameter>? mappedDataSetParameters;

  /// The configuration that defines the default value of a <code>Decimal</code>
  /// parameter when a value has not been set.
  final DecimalValueWhenUnsetConfiguration? valueWhenUnset;

  DecimalParameterDeclaration({
    required this.name,
    required this.parameterValueType,
    this.defaultValues,
    this.mappedDataSetParameters,
    this.valueWhenUnset,
  });

  factory DecimalParameterDeclaration.fromJson(Map<String, dynamic> json) {
    return DecimalParameterDeclaration(
      name: json['Name'] as String,
      parameterValueType:
          (json['ParameterValueType'] as String).toParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? DecimalDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
      mappedDataSetParameters: (json['MappedDataSetParameters'] as List?)
          ?.whereNotNull()
          .map(
              (e) => MappedDataSetParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      valueWhenUnset: json['ValueWhenUnset'] != null
          ? DecimalValueWhenUnsetConfiguration.fromJson(
              json['ValueWhenUnset'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final parameterValueType = this.parameterValueType;
    final defaultValues = this.defaultValues;
    final mappedDataSetParameters = this.mappedDataSetParameters;
    final valueWhenUnset = this.valueWhenUnset;
    return {
      'Name': name,
      'ParameterValueType': parameterValueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
      if (mappedDataSetParameters != null)
        'MappedDataSetParameters': mappedDataSetParameters,
      if (valueWhenUnset != null) 'ValueWhenUnset': valueWhenUnset,
    };
  }
}

/// The option that determines the decimal places configuration.
class DecimalPlacesConfiguration {
  /// The values of the decimal places.
  final int decimalPlaces;

  DecimalPlacesConfiguration({
    required this.decimalPlaces,
  });

  factory DecimalPlacesConfiguration.fromJson(Map<String, dynamic> json) {
    return DecimalPlacesConfiguration(
      decimalPlaces: json['DecimalPlaces'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final decimalPlaces = this.decimalPlaces;
    return {
      'DecimalPlaces': decimalPlaces,
    };
  }
}

/// The configuration that defines the default value of a <code>Decimal</code>
/// parameter when a value has not been set.
class DecimalValueWhenUnsetConfiguration {
  /// A custom value that's used when the value of a parameter isn't set.
  final double? customValue;

  /// The built-in options for default values. The value can be one of the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>RECOMMENDED</code>: The recommended value.
  /// </li>
  /// <li>
  /// <code>NULL</code>: The <code>NULL</code> value.
  /// </li>
  /// </ul>
  final ValueWhenUnsetOption? valueWhenUnsetOption;

  DecimalValueWhenUnsetConfiguration({
    this.customValue,
    this.valueWhenUnsetOption,
  });

  factory DecimalValueWhenUnsetConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DecimalValueWhenUnsetConfiguration(
      customValue: json['CustomValue'] as double?,
      valueWhenUnsetOption:
          (json['ValueWhenUnsetOption'] as String?)?.toValueWhenUnsetOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final customValue = this.customValue;
    final valueWhenUnsetOption = this.valueWhenUnsetOption;
    return {
      if (customValue != null) 'CustomValue': customValue,
      if (valueWhenUnsetOption != null)
        'ValueWhenUnsetOption': valueWhenUnsetOption.toValue(),
    };
  }
}

enum DefaultAggregation {
  sum,
  max,
  min,
  count,
  distinctCount,
  average,
  median,
  stdev,
  stdevp,
  $var,
  varp,
}

extension DefaultAggregationValueExtension on DefaultAggregation {
  String toValue() {
    switch (this) {
      case DefaultAggregation.sum:
        return 'SUM';
      case DefaultAggregation.max:
        return 'MAX';
      case DefaultAggregation.min:
        return 'MIN';
      case DefaultAggregation.count:
        return 'COUNT';
      case DefaultAggregation.distinctCount:
        return 'DISTINCT_COUNT';
      case DefaultAggregation.average:
        return 'AVERAGE';
      case DefaultAggregation.median:
        return 'MEDIAN';
      case DefaultAggregation.stdev:
        return 'STDEV';
      case DefaultAggregation.stdevp:
        return 'STDEVP';
      case DefaultAggregation.$var:
        return 'VAR';
      case DefaultAggregation.varp:
        return 'VARP';
    }
  }
}

extension DefaultAggregationFromString on String {
  DefaultAggregation toDefaultAggregation() {
    switch (this) {
      case 'SUM':
        return DefaultAggregation.sum;
      case 'MAX':
        return DefaultAggregation.max;
      case 'MIN':
        return DefaultAggregation.min;
      case 'COUNT':
        return DefaultAggregation.count;
      case 'DISTINCT_COUNT':
        return DefaultAggregation.distinctCount;
      case 'AVERAGE':
        return DefaultAggregation.average;
      case 'MEDIAN':
        return DefaultAggregation.median;
      case 'STDEV':
        return DefaultAggregation.stdev;
      case 'STDEVP':
        return DefaultAggregation.stdevp;
      case 'VAR':
        return DefaultAggregation.$var;
      case 'VARP':
        return DefaultAggregation.varp;
    }
    throw Exception('$this is not known in enum DefaultAggregation');
  }
}

/// The default options that correspond to the filter control type of a
/// <code>DateTimePicker</code>.
class DefaultDateTimePickerControlOptions {
  /// The display options of a control.
  final DateTimePickerControlDisplayOptions? displayOptions;

  /// The date time picker type of the
  /// <code>DefaultDateTimePickerControlOptions</code>. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>SINGLE_VALUED</code>: The filter condition is a fixed date.
  /// </li>
  /// <li>
  /// <code>DATE_RANGE</code>: The filter condition is a date time range.
  /// </li>
  /// </ul>
  final SheetControlDateTimePickerType? type;

  DefaultDateTimePickerControlOptions({
    this.displayOptions,
    this.type,
  });

  factory DefaultDateTimePickerControlOptions.fromJson(
      Map<String, dynamic> json) {
    return DefaultDateTimePickerControlOptions(
      displayOptions: json['DisplayOptions'] != null
          ? DateTimePickerControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlDateTimePickerType(),
    );
  }

  Map<String, dynamic> toJson() {
    final displayOptions = this.displayOptions;
    final type = this.type;
    return {
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// The default configuration for all dependent controls of the filter.
class DefaultFilterControlConfiguration {
  /// The control option for the <code>DefaultFilterControlConfiguration</code>.
  final DefaultFilterControlOptions controlOptions;

  /// The title of the <code>DefaultFilterControlConfiguration</code>. This title
  /// is shared by all controls that are tied to this filter.
  final String title;

  DefaultFilterControlConfiguration({
    required this.controlOptions,
    required this.title,
  });

  factory DefaultFilterControlConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DefaultFilterControlConfiguration(
      controlOptions: DefaultFilterControlOptions.fromJson(
          json['ControlOptions'] as Map<String, dynamic>),
      title: json['Title'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final controlOptions = this.controlOptions;
    final title = this.title;
    return {
      'ControlOptions': controlOptions,
      'Title': title,
    };
  }
}

/// The option that corresponds to the control type of the filter.
class DefaultFilterControlOptions {
  /// The default options that correspond to the filter control type of a
  /// <code>DateTimePicker</code>.
  final DefaultDateTimePickerControlOptions? defaultDateTimePickerOptions;

  /// The default options that correspond to the <code>Dropdown</code> filter
  /// control type.
  final DefaultFilterDropDownControlOptions? defaultDropdownOptions;

  /// The default options that correspond to the <code>List</code> filter control
  /// type.
  final DefaultFilterListControlOptions? defaultListOptions;

  /// The default options that correspond to the <code>RelativeDateTime</code>
  /// filter control type.
  final DefaultRelativeDateTimeControlOptions? defaultRelativeDateTimeOptions;

  /// The default options that correspond to the <code>Slider</code> filter
  /// control type.
  final DefaultSliderControlOptions? defaultSliderOptions;

  /// The default options that correspond to the <code>TextArea</code> filter
  /// control type.
  final DefaultTextAreaControlOptions? defaultTextAreaOptions;

  /// The default options that correspond to the <code>TextField</code> filter
  /// control type.
  final DefaultTextFieldControlOptions? defaultTextFieldOptions;

  DefaultFilterControlOptions({
    this.defaultDateTimePickerOptions,
    this.defaultDropdownOptions,
    this.defaultListOptions,
    this.defaultRelativeDateTimeOptions,
    this.defaultSliderOptions,
    this.defaultTextAreaOptions,
    this.defaultTextFieldOptions,
  });

  factory DefaultFilterControlOptions.fromJson(Map<String, dynamic> json) {
    return DefaultFilterControlOptions(
      defaultDateTimePickerOptions: json['DefaultDateTimePickerOptions'] != null
          ? DefaultDateTimePickerControlOptions.fromJson(
              json['DefaultDateTimePickerOptions'] as Map<String, dynamic>)
          : null,
      defaultDropdownOptions: json['DefaultDropdownOptions'] != null
          ? DefaultFilterDropDownControlOptions.fromJson(
              json['DefaultDropdownOptions'] as Map<String, dynamic>)
          : null,
      defaultListOptions: json['DefaultListOptions'] != null
          ? DefaultFilterListControlOptions.fromJson(
              json['DefaultListOptions'] as Map<String, dynamic>)
          : null,
      defaultRelativeDateTimeOptions: json['DefaultRelativeDateTimeOptions'] !=
              null
          ? DefaultRelativeDateTimeControlOptions.fromJson(
              json['DefaultRelativeDateTimeOptions'] as Map<String, dynamic>)
          : null,
      defaultSliderOptions: json['DefaultSliderOptions'] != null
          ? DefaultSliderControlOptions.fromJson(
              json['DefaultSliderOptions'] as Map<String, dynamic>)
          : null,
      defaultTextAreaOptions: json['DefaultTextAreaOptions'] != null
          ? DefaultTextAreaControlOptions.fromJson(
              json['DefaultTextAreaOptions'] as Map<String, dynamic>)
          : null,
      defaultTextFieldOptions: json['DefaultTextFieldOptions'] != null
          ? DefaultTextFieldControlOptions.fromJson(
              json['DefaultTextFieldOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultDateTimePickerOptions = this.defaultDateTimePickerOptions;
    final defaultDropdownOptions = this.defaultDropdownOptions;
    final defaultListOptions = this.defaultListOptions;
    final defaultRelativeDateTimeOptions = this.defaultRelativeDateTimeOptions;
    final defaultSliderOptions = this.defaultSliderOptions;
    final defaultTextAreaOptions = this.defaultTextAreaOptions;
    final defaultTextFieldOptions = this.defaultTextFieldOptions;
    return {
      if (defaultDateTimePickerOptions != null)
        'DefaultDateTimePickerOptions': defaultDateTimePickerOptions,
      if (defaultDropdownOptions != null)
        'DefaultDropdownOptions': defaultDropdownOptions,
      if (defaultListOptions != null) 'DefaultListOptions': defaultListOptions,
      if (defaultRelativeDateTimeOptions != null)
        'DefaultRelativeDateTimeOptions': defaultRelativeDateTimeOptions,
      if (defaultSliderOptions != null)
        'DefaultSliderOptions': defaultSliderOptions,
      if (defaultTextAreaOptions != null)
        'DefaultTextAreaOptions': defaultTextAreaOptions,
      if (defaultTextFieldOptions != null)
        'DefaultTextFieldOptions': defaultTextFieldOptions,
    };
  }
}

/// The default options that correspond to the <code>Dropdown</code> filter
/// control type.
class DefaultFilterDropDownControlOptions {
  /// The display options of a control.
  final DropDownControlDisplayOptions? displayOptions;

  /// A list of selectable values that are used in a control.
  final FilterSelectableValues? selectableValues;

  /// The type of the <code>FilterDropDownControl</code>. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>MULTI_SELECT</code>: The user can select multiple entries from a
  /// dropdown menu.
  /// </li>
  /// <li>
  /// <code>SINGLE_SELECT</code>: The user can select a single entry from a
  /// dropdown menu.
  /// </li>
  /// </ul>
  final SheetControlListType? type;

  DefaultFilterDropDownControlOptions({
    this.displayOptions,
    this.selectableValues,
    this.type,
  });

  factory DefaultFilterDropDownControlOptions.fromJson(
      Map<String, dynamic> json) {
    return DefaultFilterDropDownControlOptions(
      displayOptions: json['DisplayOptions'] != null
          ? DropDownControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      selectableValues: json['SelectableValues'] != null
          ? FilterSelectableValues.fromJson(
              json['SelectableValues'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlListType(),
    );
  }

  Map<String, dynamic> toJson() {
    final displayOptions = this.displayOptions;
    final selectableValues = this.selectableValues;
    final type = this.type;
    return {
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (selectableValues != null) 'SelectableValues': selectableValues,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// The default options that correspond to the <code>List</code> filter control
/// type.
class DefaultFilterListControlOptions {
  /// The display options of a control.
  final ListControlDisplayOptions? displayOptions;

  /// A list of selectable values that are used in a control.
  final FilterSelectableValues? selectableValues;

  /// The type of the <code>DefaultFilterListControlOptions</code>. Choose one of
  /// the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>MULTI_SELECT</code>: The user can select multiple entries from the
  /// list.
  /// </li>
  /// <li>
  /// <code>SINGLE_SELECT</code>: The user can select a single entry from the
  /// list.
  /// </li>
  /// </ul>
  final SheetControlListType? type;

  DefaultFilterListControlOptions({
    this.displayOptions,
    this.selectableValues,
    this.type,
  });

  factory DefaultFilterListControlOptions.fromJson(Map<String, dynamic> json) {
    return DefaultFilterListControlOptions(
      displayOptions: json['DisplayOptions'] != null
          ? ListControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      selectableValues: json['SelectableValues'] != null
          ? FilterSelectableValues.fromJson(
              json['SelectableValues'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlListType(),
    );
  }

  Map<String, dynamic> toJson() {
    final displayOptions = this.displayOptions;
    final selectableValues = this.selectableValues;
    final type = this.type;
    return {
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (selectableValues != null) 'SelectableValues': selectableValues,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A structure that represents a default formatting definition.
class DefaultFormatting {
  /// The display format. Valid values for this structure are <code>AUTO</code>,
  /// <code>PERCENT</code>, <code>CURRENCY</code>, <code>NUMBER</code>,
  /// <code>DATE</code>, and <code>STRING</code>.
  final DisplayFormat? displayFormat;

  /// The additional options for display formatting.
  final DisplayFormatOptions? displayFormatOptions;

  DefaultFormatting({
    this.displayFormat,
    this.displayFormatOptions,
  });

  factory DefaultFormatting.fromJson(Map<String, dynamic> json) {
    return DefaultFormatting(
      displayFormat: (json['DisplayFormat'] as String?)?.toDisplayFormat(),
      displayFormatOptions: json['DisplayFormatOptions'] != null
          ? DisplayFormatOptions.fromJson(
              json['DisplayFormatOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final displayFormat = this.displayFormat;
    final displayFormatOptions = this.displayFormatOptions;
    return {
      if (displayFormat != null) 'DisplayFormat': displayFormat.toValue(),
      if (displayFormatOptions != null)
        'DisplayFormatOptions': displayFormatOptions,
    };
  }
}

/// The options that determine the default settings of a free-form layout
/// configuration.
class DefaultFreeFormLayoutConfiguration {
  /// Determines the screen canvas size options for a free-form layout.
  final FreeFormLayoutCanvasSizeOptions canvasSizeOptions;

  DefaultFreeFormLayoutConfiguration({
    required this.canvasSizeOptions,
  });

  factory DefaultFreeFormLayoutConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DefaultFreeFormLayoutConfiguration(
      canvasSizeOptions: FreeFormLayoutCanvasSizeOptions.fromJson(
          json['CanvasSizeOptions'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final canvasSizeOptions = this.canvasSizeOptions;
    return {
      'CanvasSizeOptions': canvasSizeOptions,
    };
  }
}

/// The options that determine the default settings for a grid layout
/// configuration.
class DefaultGridLayoutConfiguration {
  /// Determines the screen canvas size options for a grid layout.
  final GridLayoutCanvasSizeOptions canvasSizeOptions;

  DefaultGridLayoutConfiguration({
    required this.canvasSizeOptions,
  });

  factory DefaultGridLayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return DefaultGridLayoutConfiguration(
      canvasSizeOptions: GridLayoutCanvasSizeOptions.fromJson(
          json['CanvasSizeOptions'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final canvasSizeOptions = this.canvasSizeOptions;
    return {
      'CanvasSizeOptions': canvasSizeOptions,
    };
  }
}

/// The options that determine the default settings for interactive layout
/// configuration.
class DefaultInteractiveLayoutConfiguration {
  /// The options that determine the default settings of a free-form layout
  /// configuration.
  final DefaultFreeFormLayoutConfiguration? freeForm;

  /// The options that determine the default settings for a grid layout
  /// configuration.
  final DefaultGridLayoutConfiguration? grid;

  DefaultInteractiveLayoutConfiguration({
    this.freeForm,
    this.grid,
  });

  factory DefaultInteractiveLayoutConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DefaultInteractiveLayoutConfiguration(
      freeForm: json['FreeForm'] != null
          ? DefaultFreeFormLayoutConfiguration.fromJson(
              json['FreeForm'] as Map<String, dynamic>)
          : null,
      grid: json['Grid'] != null
          ? DefaultGridLayoutConfiguration.fromJson(
              json['Grid'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final freeForm = this.freeForm;
    final grid = this.grid;
    return {
      if (freeForm != null) 'FreeForm': freeForm,
      if (grid != null) 'Grid': grid,
    };
  }
}

/// The configuration for default new sheet settings.
class DefaultNewSheetConfiguration {
  /// The options that determine the default settings for interactive layout
  /// configuration.
  final DefaultInteractiveLayoutConfiguration? interactiveLayoutConfiguration;

  /// The options that determine the default settings for a paginated layout
  /// configuration.
  final DefaultPaginatedLayoutConfiguration? paginatedLayoutConfiguration;

  /// The option that determines the sheet content type.
  final SheetContentType? sheetContentType;

  DefaultNewSheetConfiguration({
    this.interactiveLayoutConfiguration,
    this.paginatedLayoutConfiguration,
    this.sheetContentType,
  });

  factory DefaultNewSheetConfiguration.fromJson(Map<String, dynamic> json) {
    return DefaultNewSheetConfiguration(
      interactiveLayoutConfiguration: json['InteractiveLayoutConfiguration'] !=
              null
          ? DefaultInteractiveLayoutConfiguration.fromJson(
              json['InteractiveLayoutConfiguration'] as Map<String, dynamic>)
          : null,
      paginatedLayoutConfiguration: json['PaginatedLayoutConfiguration'] != null
          ? DefaultPaginatedLayoutConfiguration.fromJson(
              json['PaginatedLayoutConfiguration'] as Map<String, dynamic>)
          : null,
      sheetContentType:
          (json['SheetContentType'] as String?)?.toSheetContentType(),
    );
  }

  Map<String, dynamic> toJson() {
    final interactiveLayoutConfiguration = this.interactiveLayoutConfiguration;
    final paginatedLayoutConfiguration = this.paginatedLayoutConfiguration;
    final sheetContentType = this.sheetContentType;
    return {
      if (interactiveLayoutConfiguration != null)
        'InteractiveLayoutConfiguration': interactiveLayoutConfiguration,
      if (paginatedLayoutConfiguration != null)
        'PaginatedLayoutConfiguration': paginatedLayoutConfiguration,
      if (sheetContentType != null)
        'SheetContentType': sheetContentType.toValue(),
    };
  }
}

/// The options that determine the default settings for a paginated layout
/// configuration.
class DefaultPaginatedLayoutConfiguration {
  /// The options that determine the default settings for a section-based layout
  /// configuration.
  final DefaultSectionBasedLayoutConfiguration? sectionBased;

  DefaultPaginatedLayoutConfiguration({
    this.sectionBased,
  });

  factory DefaultPaginatedLayoutConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DefaultPaginatedLayoutConfiguration(
      sectionBased: json['SectionBased'] != null
          ? DefaultSectionBasedLayoutConfiguration.fromJson(
              json['SectionBased'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sectionBased = this.sectionBased;
    return {
      if (sectionBased != null) 'SectionBased': sectionBased,
    };
  }
}

/// The default options that correspond to the <code>RelativeDateTime</code>
/// filter control type.
class DefaultRelativeDateTimeControlOptions {
  /// The display options of a control.
  final RelativeDateTimeControlDisplayOptions? displayOptions;

  DefaultRelativeDateTimeControlOptions({
    this.displayOptions,
  });

  factory DefaultRelativeDateTimeControlOptions.fromJson(
      Map<String, dynamic> json) {
    return DefaultRelativeDateTimeControlOptions(
      displayOptions: json['DisplayOptions'] != null
          ? RelativeDateTimeControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final displayOptions = this.displayOptions;
    return {
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// The options that determine the default settings for a section-based layout
/// configuration.
class DefaultSectionBasedLayoutConfiguration {
  /// Determines the screen canvas size options for a section-based layout.
  final SectionBasedLayoutCanvasSizeOptions canvasSizeOptions;

  DefaultSectionBasedLayoutConfiguration({
    required this.canvasSizeOptions,
  });

  factory DefaultSectionBasedLayoutConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DefaultSectionBasedLayoutConfiguration(
      canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions.fromJson(
          json['CanvasSizeOptions'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final canvasSizeOptions = this.canvasSizeOptions;
    return {
      'CanvasSizeOptions': canvasSizeOptions,
    };
  }
}

/// The default options that correspond to the <code>Slider</code> filter
/// control type.
class DefaultSliderControlOptions {
  /// The larger value that is displayed at the right of the slider.
  final double maximumValue;

  /// The smaller value that is displayed at the left of the slider.
  final double minimumValue;

  /// The number of increments that the slider bar is divided into.
  final double stepSize;

  /// The display options of a control.
  final SliderControlDisplayOptions? displayOptions;

  /// The type of the <code>DefaultSliderControlOptions</code>. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>SINGLE_POINT</code>: Filter against(equals) a single data point.
  /// </li>
  /// <li>
  /// <code>RANGE</code>: Filter data that is in a specified range.
  /// </li>
  /// </ul>
  final SheetControlSliderType? type;

  DefaultSliderControlOptions({
    required this.maximumValue,
    required this.minimumValue,
    required this.stepSize,
    this.displayOptions,
    this.type,
  });

  factory DefaultSliderControlOptions.fromJson(Map<String, dynamic> json) {
    return DefaultSliderControlOptions(
      maximumValue: json['MaximumValue'] as double,
      minimumValue: json['MinimumValue'] as double,
      stepSize: json['StepSize'] as double,
      displayOptions: json['DisplayOptions'] != null
          ? SliderControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlSliderType(),
    );
  }

  Map<String, dynamic> toJson() {
    final maximumValue = this.maximumValue;
    final minimumValue = this.minimumValue;
    final stepSize = this.stepSize;
    final displayOptions = this.displayOptions;
    final type = this.type;
    return {
      'MaximumValue': maximumValue,
      'MinimumValue': minimumValue,
      'StepSize': stepSize,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// The default options that correspond to the <code>TextArea</code> filter
/// control type.
class DefaultTextAreaControlOptions {
  /// The delimiter that is used to separate the lines in text.
  final String? delimiter;

  /// The display options of a control.
  final TextAreaControlDisplayOptions? displayOptions;

  DefaultTextAreaControlOptions({
    this.delimiter,
    this.displayOptions,
  });

  factory DefaultTextAreaControlOptions.fromJson(Map<String, dynamic> json) {
    return DefaultTextAreaControlOptions(
      delimiter: json['Delimiter'] as String?,
      displayOptions: json['DisplayOptions'] != null
          ? TextAreaControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final delimiter = this.delimiter;
    final displayOptions = this.displayOptions;
    return {
      if (delimiter != null) 'Delimiter': delimiter,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// The default options that correspond to the <code>TextField</code> filter
/// control type.
class DefaultTextFieldControlOptions {
  /// The display options of a control.
  final TextFieldControlDisplayOptions? displayOptions;

  DefaultTextFieldControlOptions({
    this.displayOptions,
  });

  factory DefaultTextFieldControlOptions.fromJson(Map<String, dynamic> json) {
    return DefaultTextFieldControlOptions(
      displayOptions: json['DisplayOptions'] != null
          ? TextFieldControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final displayOptions = this.displayOptions;
    return {
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

class DeleteAccountCustomizationResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteAccountCustomizationResponse({
    this.requestId,
    this.status,
  });

  factory DeleteAccountCustomizationResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteAccountCustomizationResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteAccountSubscriptionResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteAccountSubscriptionResponse({
    this.requestId,
    this.status,
  });

  factory DeleteAccountSubscriptionResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteAccountSubscriptionResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteAnalysisResponse {
  /// The ID of the deleted analysis.
  final String? analysisId;

  /// The Amazon Resource Name (ARN) of the deleted analysis.
  final String? arn;

  /// The date and time that the analysis is scheduled to be deleted.
  final DateTime? deletionTime;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteAnalysisResponse({
    this.analysisId,
    this.arn,
    this.deletionTime,
    this.requestId,
    this.status,
  });

  factory DeleteAnalysisResponse.fromJson(Map<String, dynamic> json) {
    return DeleteAnalysisResponse(
      analysisId: json['AnalysisId'] as String?,
      arn: json['Arn'] as String?,
      deletionTime: timeStampFromJson(json['DeletionTime']),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final arn = this.arn;
    final deletionTime = this.deletionTime;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (arn != null) 'Arn': arn,
      if (deletionTime != null)
        'DeletionTime': unixTimestampToJson(deletionTime),
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteDashboardResponse {
  /// The Secure Socket Layer (SSL) properties that apply for the resource.
  final String? arn;

  /// The ID of the dashboard.
  final String? dashboardId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteDashboardResponse({
    this.arn,
    this.dashboardId,
    this.requestId,
    this.status,
  });

  factory DeleteDashboardResponse.fromJson(Map<String, dynamic> json) {
    return DeleteDashboardResponse(
      arn: json['Arn'] as String?,
      dashboardId: json['DashboardId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dashboardId = this.dashboardId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteDataSetRefreshPropertiesResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteDataSetRefreshPropertiesResponse({
    this.requestId,
    this.status,
  });

  factory DeleteDataSetRefreshPropertiesResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteDataSetRefreshPropertiesResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteDataSetResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? arn;

  /// The ID for the dataset that you want to create. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? dataSetId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteDataSetResponse({
    this.arn,
    this.dataSetId,
    this.requestId,
    this.status,
  });

  factory DeleteDataSetResponse.fromJson(Map<String, dynamic> json) {
    return DeleteDataSetResponse(
      arn: json['Arn'] as String?,
      dataSetId: json['DataSetId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSetId = this.dataSetId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteDataSourceResponse {
  /// The Amazon Resource Name (ARN) of the data source that you deleted.
  final String? arn;

  /// The ID of the data source. This ID is unique per Amazon Web Services Region
  /// for each Amazon Web Services account.
  final String? dataSourceId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteDataSourceResponse({
    this.arn,
    this.dataSourceId,
    this.requestId,
    this.status,
  });

  factory DeleteDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return DeleteDataSourceResponse(
      arn: json['Arn'] as String?,
      dataSourceId: json['DataSourceId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSourceId = this.dataSourceId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteFolderMembershipResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteFolderMembershipResponse({
    this.requestId,
    this.status,
  });

  factory DeleteFolderMembershipResponse.fromJson(Map<String, dynamic> json) {
    return DeleteFolderMembershipResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class DeleteFolderResponse {
  /// The Amazon Resource Name of the deleted folder.
  final String? arn;

  /// The ID of the folder.
  final String? folderId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteFolderResponse({
    this.arn,
    this.folderId,
    this.requestId,
    this.status,
  });

  factory DeleteFolderResponse.fromJson(Map<String, dynamic> json) {
    return DeleteFolderResponse(
      arn: json['Arn'] as String?,
      folderId: json['FolderId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final folderId = this.folderId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (folderId != null) 'FolderId': folderId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteGroupMembershipResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteGroupMembershipResponse({
    this.requestId,
    this.status,
  });

  factory DeleteGroupMembershipResponse.fromJson(Map<String, dynamic> json) {
    return DeleteGroupMembershipResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteGroupResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteGroupResponse({
    this.requestId,
    this.status,
  });

  factory DeleteGroupResponse.fromJson(Map<String, dynamic> json) {
    return DeleteGroupResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteIAMPolicyAssignmentResponse {
  /// The name of the assignment.
  final String? assignmentName;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteIAMPolicyAssignmentResponse({
    this.assignmentName,
    this.requestId,
    this.status,
  });

  factory DeleteIAMPolicyAssignmentResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteIAMPolicyAssignmentResponse(
      assignmentName: json['AssignmentName'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final assignmentName = this.assignmentName;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (assignmentName != null) 'AssignmentName': assignmentName,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteIdentityPropagationConfigResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteIdentityPropagationConfigResponse({
    this.requestId,
    this.status,
  });

  factory DeleteIdentityPropagationConfigResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteIdentityPropagationConfigResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteNamespaceResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteNamespaceResponse({
    this.requestId,
    this.status,
  });

  factory DeleteNamespaceResponse.fromJson(Map<String, dynamic> json) {
    return DeleteNamespaceResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) for the refresh schedule.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The ID of the refresh schedule.
  final String? scheduleId;

  /// The HTTP status of the request.
  final int? status;

  DeleteRefreshScheduleResponse({
    this.arn,
    this.requestId,
    this.scheduleId,
    this.status,
  });

  factory DeleteRefreshScheduleResponse.fromJson(Map<String, dynamic> json) {
    return DeleteRefreshScheduleResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      scheduleId: json['ScheduleId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final scheduleId = this.scheduleId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (scheduleId != null) 'ScheduleId': scheduleId,
    };
  }
}

class DeleteRoleCustomPermissionResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteRoleCustomPermissionResponse({
    this.requestId,
    this.status,
  });

  factory DeleteRoleCustomPermissionResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteRoleCustomPermissionResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class DeleteRoleMembershipResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteRoleMembershipResponse({
    this.requestId,
    this.status,
  });

  factory DeleteRoleMembershipResponse.fromJson(Map<String, dynamic> json) {
    return DeleteRoleMembershipResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteTemplateAliasResponse {
  /// The name for the template alias.
  final String? aliasName;

  /// The Amazon Resource Name (ARN) of the template you want to delete.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// An ID for the template associated with the deletion.
  final String? templateId;

  DeleteTemplateAliasResponse({
    this.aliasName,
    this.arn,
    this.requestId,
    this.status,
    this.templateId,
  });

  factory DeleteTemplateAliasResponse.fromJson(Map<String, dynamic> json) {
    return DeleteTemplateAliasResponse(
      aliasName: json['AliasName'] as String?,
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateId: json['TemplateId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final aliasName = this.aliasName;
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final templateId = this.templateId;
    return {
      if (aliasName != null) 'AliasName': aliasName,
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (templateId != null) 'TemplateId': templateId,
    };
  }
}

class DeleteTemplateResponse {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// An ID for the template.
  final String? templateId;

  DeleteTemplateResponse({
    this.arn,
    this.requestId,
    this.status,
    this.templateId,
  });

  factory DeleteTemplateResponse.fromJson(Map<String, dynamic> json) {
    return DeleteTemplateResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateId: json['TemplateId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final templateId = this.templateId;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (templateId != null) 'TemplateId': templateId,
    };
  }
}

class DeleteThemeAliasResponse {
  /// The name for the theme alias.
  final String? aliasName;

  /// The Amazon Resource Name (ARN) of the theme resource using the deleted
  /// alias.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// An ID for the theme associated with the deletion.
  final String? themeId;

  DeleteThemeAliasResponse({
    this.aliasName,
    this.arn,
    this.requestId,
    this.status,
    this.themeId,
  });

  factory DeleteThemeAliasResponse.fromJson(Map<String, dynamic> json) {
    return DeleteThemeAliasResponse(
      aliasName: json['AliasName'] as String?,
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeId: json['ThemeId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final aliasName = this.aliasName;
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final themeId = this.themeId;
    return {
      if (aliasName != null) 'AliasName': aliasName,
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (themeId != null) 'ThemeId': themeId,
    };
  }
}

class DeleteThemeResponse {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// An ID for the theme.
  final String? themeId;

  DeleteThemeResponse({
    this.arn,
    this.requestId,
    this.status,
    this.themeId,
  });

  factory DeleteThemeResponse.fromJson(Map<String, dynamic> json) {
    return DeleteThemeResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeId: json['ThemeId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final themeId = this.themeId;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (themeId != null) 'ThemeId': themeId,
    };
  }
}

class DeleteTopicRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? datasetArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  DeleteTopicRefreshScheduleResponse({
    this.datasetArn,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory DeleteTopicRefreshScheduleResponse.fromJson(
      Map<String, dynamic> json) {
    return DeleteTopicRefreshScheduleResponse(
      datasetArn: json['DatasetArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final datasetArn = this.datasetArn;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (datasetArn != null) 'DatasetArn': datasetArn,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class DeleteTopicResponse {
  /// The Amazon Resource Name (ARN) of the topic.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID of the topic that you want to delete. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  DeleteTopicResponse({
    this.arn,
    this.requestId,
    this.status,
    this.topicId,
  });

  factory DeleteTopicResponse.fromJson(Map<String, dynamic> json) {
    return DeleteTopicResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final topicId = this.topicId;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class DeleteUserByPrincipalIdResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteUserByPrincipalIdResponse({
    this.requestId,
    this.status,
  });

  factory DeleteUserByPrincipalIdResponse.fromJson(Map<String, dynamic> json) {
    return DeleteUserByPrincipalIdResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteUserResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DeleteUserResponse({
    this.requestId,
    this.status,
  });

  factory DeleteUserResponse.fromJson(Map<String, dynamic> json) {
    return DeleteUserResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DeleteVPCConnectionResponse {
  /// The Amazon Resource Name (ARN) of the deleted VPC connection.
  final String? arn;

  /// The availability status of the VPC connection.
  final VPCConnectionAvailabilityStatus? availabilityStatus;

  /// The deletion status of the VPC connection.
  final VPCConnectionResourceStatus? deletionStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID of the VPC connection that you're creating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  final String? vPCConnectionId;

  DeleteVPCConnectionResponse({
    this.arn,
    this.availabilityStatus,
    this.deletionStatus,
    this.requestId,
    this.status,
    this.vPCConnectionId,
  });

  factory DeleteVPCConnectionResponse.fromJson(Map<String, dynamic> json) {
    return DeleteVPCConnectionResponse(
      arn: json['Arn'] as String?,
      availabilityStatus: (json['AvailabilityStatus'] as String?)
          ?.toVPCConnectionAvailabilityStatus(),
      deletionStatus:
          (json['DeletionStatus'] as String?)?.toVPCConnectionResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      vPCConnectionId: json['VPCConnectionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final availabilityStatus = this.availabilityStatus;
    final deletionStatus = this.deletionStatus;
    final requestId = this.requestId;
    final status = this.status;
    final vPCConnectionId = this.vPCConnectionId;
    return {
      if (arn != null) 'Arn': arn,
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
      if (deletionStatus != null) 'DeletionStatus': deletionStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (vPCConnectionId != null) 'VPCConnectionId': vPCConnectionId,
    };
  }
}

class DescribeAccountCustomizationResponse {
  /// The Amazon QuickSight customizations that exist in the current Amazon Web
  /// Services Region.
  final AccountCustomization? accountCustomization;

  /// The Amazon Resource Name (ARN) of the customization that's associated with
  /// this Amazon Web Services account.
  final String? arn;

  /// The ID for the Amazon Web Services account that you're describing.
  final String? awsAccountId;

  /// The Amazon QuickSight namespace that you're describing.
  final String? namespace;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeAccountCustomizationResponse({
    this.accountCustomization,
    this.arn,
    this.awsAccountId,
    this.namespace,
    this.requestId,
    this.status,
  });

  factory DescribeAccountCustomizationResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAccountCustomizationResponse(
      accountCustomization: json['AccountCustomization'] != null
          ? AccountCustomization.fromJson(
              json['AccountCustomization'] as Map<String, dynamic>)
          : null,
      arn: json['Arn'] as String?,
      awsAccountId: json['AwsAccountId'] as String?,
      namespace: json['Namespace'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountCustomization = this.accountCustomization;
    final arn = this.arn;
    final awsAccountId = this.awsAccountId;
    final namespace = this.namespace;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (accountCustomization != null)
        'AccountCustomization': accountCustomization,
      if (arn != null) 'Arn': arn,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (namespace != null) 'Namespace': namespace,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeAccountSettingsResponse {
  /// The Amazon QuickSight settings for this Amazon Web Services account. This
  /// information includes the edition of Amazon Amazon QuickSight that you
  /// subscribed to (Standard or Enterprise) and the notification email for the
  /// Amazon QuickSight subscription.
  ///
  /// In the QuickSight console, the Amazon QuickSight subscription is sometimes
  /// referred to as a QuickSight "account" even though it's technically not an
  /// account by itself. Instead, it's a subscription to the Amazon QuickSight
  /// service for your Amazon Web Services account. The edition that you subscribe
  /// to applies to Amazon QuickSight in every Amazon Web Services Region where
  /// you use it.
  final AccountSettings? accountSettings;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeAccountSettingsResponse({
    this.accountSettings,
    this.requestId,
    this.status,
  });

  factory DescribeAccountSettingsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeAccountSettingsResponse(
      accountSettings: json['AccountSettings'] != null
          ? AccountSettings.fromJson(
              json['AccountSettings'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountSettings = this.accountSettings;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (accountSettings != null) 'AccountSettings': accountSettings,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeAccountSubscriptionResponse {
  /// A structure that contains the following elements:
  ///
  /// <ul>
  /// <li>
  /// Your Amazon QuickSight account name.
  /// </li>
  /// <li>
  /// The edition of Amazon QuickSight that your account is using.
  /// </li>
  /// <li>
  /// The notification email address that is associated with the Amazon QuickSight
  /// account.
  /// </li>
  /// <li>
  /// The authentication type of the Amazon QuickSight account.
  /// </li>
  /// <li>
  /// The status of the Amazon QuickSight account's subscription.
  /// </li>
  /// </ul>
  final AccountInfo? accountInfo;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeAccountSubscriptionResponse({
    this.accountInfo,
    this.requestId,
    this.status,
  });

  factory DescribeAccountSubscriptionResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAccountSubscriptionResponse(
      accountInfo: json['AccountInfo'] != null
          ? AccountInfo.fromJson(json['AccountInfo'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountInfo = this.accountInfo;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (accountInfo != null) 'AccountInfo': accountInfo,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeAnalysisDefinitionResponse {
  /// The ID of the analysis described.
  final String? analysisId;

  /// The definition of an analysis.
  ///
  /// A definition is the data model of all features in a Dashboard, Template, or
  /// Analysis.
  final AnalysisDefinition? definition;

  /// Errors associated with the analysis.
  final List<AnalysisError>? errors;

  /// The descriptive name of the analysis.
  final String? name;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// Status associated with the analysis.
  ///
  /// <ul>
  /// <li>
  /// <code>CREATION_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>CREATION_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_FAILED</code>
  /// </li>
  /// <li>
  /// <code>DELETED</code>
  /// </li>
  /// </ul>
  final ResourceStatus? resourceStatus;

  /// The HTTP status of the request.
  final int? status;

  /// The ARN of the theme of the analysis.
  final String? themeArn;

  DescribeAnalysisDefinitionResponse({
    this.analysisId,
    this.definition,
    this.errors,
    this.name,
    this.requestId,
    this.resourceStatus,
    this.status,
    this.themeArn,
  });

  factory DescribeAnalysisDefinitionResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAnalysisDefinitionResponse(
      analysisId: json['AnalysisId'] as String?,
      definition: json['Definition'] != null
          ? AnalysisDefinition.fromJson(
              json['Definition'] as Map<String, dynamic>)
          : null,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => AnalysisError.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      requestId: json['RequestId'] as String?,
      resourceStatus: (json['ResourceStatus'] as String?)?.toResourceStatus(),
      status: json['Status'] as int?,
      themeArn: json['ThemeArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final definition = this.definition;
    final errors = this.errors;
    final name = this.name;
    final requestId = this.requestId;
    final resourceStatus = this.resourceStatus;
    final status = this.status;
    final themeArn = this.themeArn;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (definition != null) 'Definition': definition,
      if (errors != null) 'Errors': errors,
      if (name != null) 'Name': name,
      if (requestId != null) 'RequestId': requestId,
      if (resourceStatus != null) 'ResourceStatus': resourceStatus.toValue(),
      if (themeArn != null) 'ThemeArn': themeArn,
    };
  }
}

class DescribeAnalysisPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the analysis whose permissions you're
  /// describing.
  final String? analysisArn;

  /// The ID of the analysis whose permissions you're describing.
  final String? analysisId;

  /// A structure that describes the principals and the resource-level permissions
  /// on an analysis.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeAnalysisPermissionsResponse({
    this.analysisArn,
    this.analysisId,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory DescribeAnalysisPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAnalysisPermissionsResponse(
      analysisArn: json['AnalysisArn'] as String?,
      analysisId: json['AnalysisId'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisArn = this.analysisArn;
    final analysisId = this.analysisId;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisArn != null) 'AnalysisArn': analysisArn,
      if (analysisId != null) 'AnalysisId': analysisId,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeAnalysisResponse {
  /// A metadata structure that contains summary information for the analysis that
  /// you're describing.
  final Analysis? analysis;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeAnalysisResponse({
    this.analysis,
    this.requestId,
    this.status,
  });

  factory DescribeAnalysisResponse.fromJson(Map<String, dynamic> json) {
    return DescribeAnalysisResponse(
      analysis: json['Analysis'] != null
          ? Analysis.fromJson(json['Analysis'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysis = this.analysis;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysis != null) 'Analysis': analysis,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeAssetBundleExportJobResponse {
  /// The Amazon Resource Name (ARN) for the export job.
  final String? arn;

  /// The ID of the job. The job ID is set when you start a new job with a
  /// <code>StartAssetBundleExportJob</code> API call.
  final String? assetBundleExportJobId;

  /// The ID of the Amazon Web Services account that the export job was executed
  /// in.
  final String? awsAccountId;

  /// The CloudFormation override property configuration for the export job.
  final AssetBundleCloudFormationOverridePropertyConfiguration?
      cloudFormationOverridePropertyConfiguration;

  /// The time that the export job was created.
  final DateTime? createdTime;

  /// The URL to download the exported asset bundle data from.
  ///
  /// This URL is available only after the job has succeeded. This URL is valid
  /// for 5 minutes after issuance. Call <code>DescribeAssetBundleExportJob</code>
  /// again for a fresh URL if needed.
  ///
  /// The downloaded asset bundle is a zip file named
  /// <code>assetbundle-{jobId}.qs</code>. The file has a <code>.qs</code>
  /// extension.
  ///
  /// This URL can't be used in a <code>StartAssetBundleImportJob</code> API call
  /// and should only be used for download purposes.
  final String? downloadUrl;

  /// An array of error records that describes any failures that occurred during
  /// the export job processing.
  ///
  /// Error records accumulate while the job runs. The complete set of error
  /// records is available after the job has completed and failed.
  final List<AssetBundleExportJobError>? errors;

  /// The format of the exported asset bundle. A <code>QUICKSIGHT_JSON</code>
  /// formatted file can be used to make a <code>StartAssetBundleImportJob</code>
  /// API call. A <code>CLOUDFORMATION_JSON</code> formatted file can be used in
  /// the CloudFormation console and with the CloudFormation APIs.
  final AssetBundleExportFormat? exportFormat;

  /// The include dependencies flag.
  final bool? includeAllDependencies;

  /// The include permissions flag.
  final bool? includePermissions;

  /// The include tags flag.
  final bool? includeTags;

  /// Indicates the status of a job through its queuing and execution.
  ///
  /// Poll this <code>DescribeAssetBundleExportApi</code> until
  /// <code>JobStatus</code> is either <code>SUCCESSFUL</code> or
  /// <code>FAILED</code>.
  final AssetBundleExportJobStatus? jobStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// A list of resource ARNs that exported with the job.
  final List<String>? resourceArns;

  /// The HTTP status of the response.
  final int? status;

  /// The validation strategy that is used to export the analysis or dashboard.
  final AssetBundleExportJobValidationStrategy? validationStrategy;

  /// An array of warning records that describe the analysis or dashboard that is
  /// exported. This array includes UI errors that can be skipped during the
  /// validation process.
  ///
  /// This property only appears if <code>StrictModeForAllResources</code> in
  /// <code>ValidationStrategy</code> is set to <code>FALSE</code>.
  final List<AssetBundleExportJobWarning>? warnings;

  DescribeAssetBundleExportJobResponse({
    this.arn,
    this.assetBundleExportJobId,
    this.awsAccountId,
    this.cloudFormationOverridePropertyConfiguration,
    this.createdTime,
    this.downloadUrl,
    this.errors,
    this.exportFormat,
    this.includeAllDependencies,
    this.includePermissions,
    this.includeTags,
    this.jobStatus,
    this.requestId,
    this.resourceArns,
    this.status,
    this.validationStrategy,
    this.warnings,
  });

  factory DescribeAssetBundleExportJobResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAssetBundleExportJobResponse(
      arn: json['Arn'] as String?,
      assetBundleExportJobId: json['AssetBundleExportJobId'] as String?,
      awsAccountId: json['AwsAccountId'] as String?,
      cloudFormationOverridePropertyConfiguration:
          json['CloudFormationOverridePropertyConfiguration'] != null
              ? AssetBundleCloudFormationOverridePropertyConfiguration.fromJson(
                  json['CloudFormationOverridePropertyConfiguration']
                      as Map<String, dynamic>)
              : null,
      createdTime: timeStampFromJson(json['CreatedTime']),
      downloadUrl: json['DownloadUrl'] as String?,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleExportJobError.fromJson(e as Map<String, dynamic>))
          .toList(),
      exportFormat:
          (json['ExportFormat'] as String?)?.toAssetBundleExportFormat(),
      includeAllDependencies: json['IncludeAllDependencies'] as bool?,
      includePermissions: json['IncludePermissions'] as bool?,
      includeTags: json['IncludeTags'] as bool?,
      jobStatus: (json['JobStatus'] as String?)?.toAssetBundleExportJobStatus(),
      requestId: json['RequestId'] as String?,
      resourceArns: (json['ResourceArns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      status: json['Status'] as int?,
      validationStrategy: json['ValidationStrategy'] != null
          ? AssetBundleExportJobValidationStrategy.fromJson(
              json['ValidationStrategy'] as Map<String, dynamic>)
          : null,
      warnings: (json['Warnings'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleExportJobWarning.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assetBundleExportJobId = this.assetBundleExportJobId;
    final awsAccountId = this.awsAccountId;
    final cloudFormationOverridePropertyConfiguration =
        this.cloudFormationOverridePropertyConfiguration;
    final createdTime = this.createdTime;
    final downloadUrl = this.downloadUrl;
    final errors = this.errors;
    final exportFormat = this.exportFormat;
    final includeAllDependencies = this.includeAllDependencies;
    final includePermissions = this.includePermissions;
    final includeTags = this.includeTags;
    final jobStatus = this.jobStatus;
    final requestId = this.requestId;
    final resourceArns = this.resourceArns;
    final status = this.status;
    final validationStrategy = this.validationStrategy;
    final warnings = this.warnings;
    return {
      if (arn != null) 'Arn': arn,
      if (assetBundleExportJobId != null)
        'AssetBundleExportJobId': assetBundleExportJobId,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (cloudFormationOverridePropertyConfiguration != null)
        'CloudFormationOverridePropertyConfiguration':
            cloudFormationOverridePropertyConfiguration,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (downloadUrl != null) 'DownloadUrl': downloadUrl,
      if (errors != null) 'Errors': errors,
      if (exportFormat != null) 'ExportFormat': exportFormat.toValue(),
      if (includeAllDependencies != null)
        'IncludeAllDependencies': includeAllDependencies,
      if (includePermissions != null) 'IncludePermissions': includePermissions,
      if (includeTags != null) 'IncludeTags': includeTags,
      if (jobStatus != null) 'JobStatus': jobStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (resourceArns != null) 'ResourceArns': resourceArns,
      if (validationStrategy != null) 'ValidationStrategy': validationStrategy,
      if (warnings != null) 'Warnings': warnings,
    };
  }
}

class DescribeAssetBundleImportJobResponse {
  /// The Amazon Resource Name (ARN) for the import job.
  final String? arn;

  /// The ID of the job. The job ID is set when you start a new job with a
  /// <code>StartAssetBundleImportJob</code> API call.
  final String? assetBundleImportJobId;

  /// The source of the asset bundle zip file that contains the data that is
  /// imported by the job.
  final AssetBundleImportSourceDescription? assetBundleImportSource;

  /// The ID of the Amazon Web Services account the import job was executed in.
  final String? awsAccountId;

  /// The time that the import job was created.
  final DateTime? createdTime;

  /// An array of error records that describes any failures that occurred during
  /// the export job processing.
  ///
  /// Error records accumulate while the job is still running. The complete set of
  /// error records is available after the job has completed and failed.
  final List<AssetBundleImportJobError>? errors;

  /// The failure action for the import job.
  final AssetBundleImportFailureAction? failureAction;

  /// Indicates the status of a job through its queuing and execution.
  ///
  /// Poll the <code>DescribeAssetBundleImport</code> API until
  /// <code>JobStatus</code> returns one of the following values:
  ///
  /// <ul>
  /// <li>
  /// <code>SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>FAILED</code>
  /// </li>
  /// <li>
  /// <code>FAILED_ROLLBACK_COMPLETED</code>
  /// </li>
  /// <li>
  /// <code>FAILED_ROLLBACK_ERROR</code>
  /// </li>
  /// </ul>
  final AssetBundleImportJobStatus? jobStatus;

  /// Optional overrides that are applied to the resource configuration before
  /// import.
  final AssetBundleImportJobOverrideParameters? overrideParameters;

  /// Optional permission overrides that are applied to the resource configuration
  /// before import.
  final AssetBundleImportJobOverridePermissions? overridePermissions;

  /// Optional tag overrides that are applied to the resource configuration before
  /// import.
  final AssetBundleImportJobOverrideTags? overrideTags;

  /// An optional validation strategy override for all analyses and dashboards to
  /// be applied to the resource configuration before import.
  final AssetBundleImportJobOverrideValidationStrategy?
      overrideValidationStrategy;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// An array of error records that describes any failures that occurred while an
  /// import job was attempting a rollback.
  ///
  /// Error records accumulate while the job is still running. The complete set of
  /// error records is available after the job has completed and failed.
  final List<AssetBundleImportJobError>? rollbackErrors;

  /// The HTTP status of the response.
  final int? status;

  /// An array of warning records that describe all permitted errors that are
  /// encountered during the import job.
  final List<AssetBundleImportJobWarning>? warnings;

  DescribeAssetBundleImportJobResponse({
    this.arn,
    this.assetBundleImportJobId,
    this.assetBundleImportSource,
    this.awsAccountId,
    this.createdTime,
    this.errors,
    this.failureAction,
    this.jobStatus,
    this.overrideParameters,
    this.overridePermissions,
    this.overrideTags,
    this.overrideValidationStrategy,
    this.requestId,
    this.rollbackErrors,
    this.status,
    this.warnings,
  });

  factory DescribeAssetBundleImportJobResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeAssetBundleImportJobResponse(
      arn: json['Arn'] as String?,
      assetBundleImportJobId: json['AssetBundleImportJobId'] as String?,
      assetBundleImportSource: json['AssetBundleImportSource'] != null
          ? AssetBundleImportSourceDescription.fromJson(
              json['AssetBundleImportSource'] as Map<String, dynamic>)
          : null,
      awsAccountId: json['AwsAccountId'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobError.fromJson(e as Map<String, dynamic>))
          .toList(),
      failureAction: (json['FailureAction'] as String?)
          ?.toAssetBundleImportFailureAction(),
      jobStatus: (json['JobStatus'] as String?)?.toAssetBundleImportJobStatus(),
      overrideParameters: json['OverrideParameters'] != null
          ? AssetBundleImportJobOverrideParameters.fromJson(
              json['OverrideParameters'] as Map<String, dynamic>)
          : null,
      overridePermissions: json['OverridePermissions'] != null
          ? AssetBundleImportJobOverridePermissions.fromJson(
              json['OverridePermissions'] as Map<String, dynamic>)
          : null,
      overrideTags: json['OverrideTags'] != null
          ? AssetBundleImportJobOverrideTags.fromJson(
              json['OverrideTags'] as Map<String, dynamic>)
          : null,
      overrideValidationStrategy: json['OverrideValidationStrategy'] != null
          ? AssetBundleImportJobOverrideValidationStrategy.fromJson(
              json['OverrideValidationStrategy'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      rollbackErrors: (json['RollbackErrors'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobError.fromJson(e as Map<String, dynamic>))
          .toList(),
      status: json['Status'] as int?,
      warnings: (json['Warnings'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobWarning.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assetBundleImportJobId = this.assetBundleImportJobId;
    final assetBundleImportSource = this.assetBundleImportSource;
    final awsAccountId = this.awsAccountId;
    final createdTime = this.createdTime;
    final errors = this.errors;
    final failureAction = this.failureAction;
    final jobStatus = this.jobStatus;
    final overrideParameters = this.overrideParameters;
    final overridePermissions = this.overridePermissions;
    final overrideTags = this.overrideTags;
    final overrideValidationStrategy = this.overrideValidationStrategy;
    final requestId = this.requestId;
    final rollbackErrors = this.rollbackErrors;
    final status = this.status;
    final warnings = this.warnings;
    return {
      if (arn != null) 'Arn': arn,
      if (assetBundleImportJobId != null)
        'AssetBundleImportJobId': assetBundleImportJobId,
      if (assetBundleImportSource != null)
        'AssetBundleImportSource': assetBundleImportSource,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (errors != null) 'Errors': errors,
      if (failureAction != null) 'FailureAction': failureAction.toValue(),
      if (jobStatus != null) 'JobStatus': jobStatus.toValue(),
      if (overrideParameters != null) 'OverrideParameters': overrideParameters,
      if (overridePermissions != null)
        'OverridePermissions': overridePermissions,
      if (overrideTags != null) 'OverrideTags': overrideTags,
      if (overrideValidationStrategy != null)
        'OverrideValidationStrategy': overrideValidationStrategy,
      if (requestId != null) 'RequestId': requestId,
      if (rollbackErrors != null) 'RollbackErrors': rollbackErrors,
      if (warnings != null) 'Warnings': warnings,
    };
  }
}

class DescribeDashboardDefinitionResponse {
  /// The ID of the dashboard described.
  final String? dashboardId;

  /// Options for publishing the dashboard:
  ///
  /// <ul>
  /// <li>
  /// <code>AvailabilityStatus</code> for <code>AdHocFilteringOption</code> - This
  /// status can be either <code>ENABLED</code> or <code>DISABLED</code>. When
  /// this is set to <code>DISABLED</code>, Amazon QuickSight disables the left
  /// filter pane on the published dashboard, which can be used for ad hoc
  /// (one-time) filtering. This option is <code>ENABLED</code> by default.
  /// </li>
  /// <li>
  /// <code>AvailabilityStatus</code> for <code>ExportToCSVOption</code> - This
  /// status can be either <code>ENABLED</code> or <code>DISABLED</code>. The
  /// visual option to export data to .CSV format isn't enabled when this is set
  /// to <code>DISABLED</code>. This option is <code>ENABLED</code> by default.
  /// </li>
  /// <li>
  /// <code>VisibilityState</code> for <code>SheetControlsOption</code> - This
  /// visibility state can be either <code>COLLAPSED</code> or
  /// <code>EXPANDED</code>. This option is <code>COLLAPSED</code> by default.
  /// </li>
  /// </ul>
  final DashboardPublishOptions? dashboardPublishOptions;

  /// The definition of a dashboard.
  ///
  /// A definition is the data model of all features in a Dashboard, Template, or
  /// Analysis.
  final DashboardVersionDefinition? definition;

  /// Errors associated with this dashboard version.
  final List<DashboardError>? errors;

  /// The display name of the dashboard.
  final String? name;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// Status associated with the dashboard version.
  ///
  /// <ul>
  /// <li>
  /// <code>CREATION_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>CREATION_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_FAILED</code>
  /// </li>
  /// <li>
  /// <code>DELETED</code>
  /// </li>
  /// </ul>
  final ResourceStatus? resourceStatus;

  /// The HTTP status of the request.
  final int? status;

  /// The ARN of the theme of the dashboard.
  final String? themeArn;

  DescribeDashboardDefinitionResponse({
    this.dashboardId,
    this.dashboardPublishOptions,
    this.definition,
    this.errors,
    this.name,
    this.requestId,
    this.resourceStatus,
    this.status,
    this.themeArn,
  });

  factory DescribeDashboardDefinitionResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDashboardDefinitionResponse(
      dashboardId: json['DashboardId'] as String?,
      dashboardPublishOptions: json['DashboardPublishOptions'] != null
          ? DashboardPublishOptions.fromJson(
              json['DashboardPublishOptions'] as Map<String, dynamic>)
          : null,
      definition: json['Definition'] != null
          ? DashboardVersionDefinition.fromJson(
              json['Definition'] as Map<String, dynamic>)
          : null,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => DashboardError.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      requestId: json['RequestId'] as String?,
      resourceStatus: (json['ResourceStatus'] as String?)?.toResourceStatus(),
      status: json['Status'] as int?,
      themeArn: json['ThemeArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardId = this.dashboardId;
    final dashboardPublishOptions = this.dashboardPublishOptions;
    final definition = this.definition;
    final errors = this.errors;
    final name = this.name;
    final requestId = this.requestId;
    final resourceStatus = this.resourceStatus;
    final status = this.status;
    final themeArn = this.themeArn;
    return {
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (dashboardPublishOptions != null)
        'DashboardPublishOptions': dashboardPublishOptions,
      if (definition != null) 'Definition': definition,
      if (errors != null) 'Errors': errors,
      if (name != null) 'Name': name,
      if (requestId != null) 'RequestId': requestId,
      if (resourceStatus != null) 'ResourceStatus': resourceStatus.toValue(),
      if (themeArn != null) 'ThemeArn': themeArn,
    };
  }
}

class DescribeDashboardPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the dashboard.
  final String? dashboardArn;

  /// The ID for the dashboard.
  final String? dashboardId;

  /// A structure that contains the configuration of a shareable link that grants
  /// access to the dashboard. Your users can use the link to view and interact
  /// with the dashboard, if the dashboard has been shared with them. For more
  /// information about sharing dashboards, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sharing-a-dashboard.html">Sharing
  /// Dashboards</a>.
  final LinkSharingConfiguration? linkSharingConfiguration;

  /// A structure that contains the permissions for the dashboard.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeDashboardPermissionsResponse({
    this.dashboardArn,
    this.dashboardId,
    this.linkSharingConfiguration,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory DescribeDashboardPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDashboardPermissionsResponse(
      dashboardArn: json['DashboardArn'] as String?,
      dashboardId: json['DashboardId'] as String?,
      linkSharingConfiguration: json['LinkSharingConfiguration'] != null
          ? LinkSharingConfiguration.fromJson(
              json['LinkSharingConfiguration'] as Map<String, dynamic>)
          : null,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardArn = this.dashboardArn;
    final dashboardId = this.dashboardId;
    final linkSharingConfiguration = this.linkSharingConfiguration;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardArn != null) 'DashboardArn': dashboardArn,
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (linkSharingConfiguration != null)
        'LinkSharingConfiguration': linkSharingConfiguration,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeDashboardResponse {
  /// Information about the dashboard.
  final Dashboard? dashboard;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of this request.
  final int? status;

  DescribeDashboardResponse({
    this.dashboard,
    this.requestId,
    this.status,
  });

  factory DescribeDashboardResponse.fromJson(Map<String, dynamic> json) {
    return DescribeDashboardResponse(
      dashboard: json['Dashboard'] != null
          ? Dashboard.fromJson(json['Dashboard'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboard = this.dashboard;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboard != null) 'Dashboard': dashboard,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeDashboardSnapshotJobResponse {
  /// The Amazon Resource Name (ARN) for the snapshot job. The job ARN is
  /// generated when you start a new job with a
  /// <code>StartDashboardSnapshotJob</code> API call.
  final String? arn;

  /// The ID of the Amazon Web Services account that the dashboard snapshot job is
  /// executed in.
  final String? awsAccountId;

  /// The time that the snapshot job was created.
  final DateTime? createdTime;

  /// The ID of the dashboard that you have started a snapshot job for.
  final String? dashboardId;

  /// Indicates the status of a job. The status updates as the job executes. This
  /// shows one of the following values.
  ///
  /// <ul>
  /// <li>
  /// <code>COMPLETED</code> - The job was completed successfully.
  /// </li>
  /// <li>
  /// <code>FAILED</code> - The job failed to execute.
  /// </li>
  /// <li>
  /// <code>QUEUED</code> - The job is queued and hasn't started yet.
  /// </li>
  /// <li>
  /// <code>RUNNING</code> - The job is still running.
  /// </li>
  /// </ul>
  final SnapshotJobStatus? jobStatus;

  /// The time that the snapshot job status was last updated.
  final DateTime? lastUpdatedTime;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The snapshot configuration of the job. This information is provided when you
  /// make a <code>StartDashboardSnapshotJob</code> API call.
  final SnapshotConfiguration? snapshotConfiguration;

  /// The ID of the job to be described. The job ID is set when you start a new
  /// job with a <code>StartDashboardSnapshotJob</code> API call.
  final String? snapshotJobId;

  /// The HTTP status of the request
  final int? status;

  /// The user configuration for the snapshot job. This information is provided
  /// when you make a <code>StartDashboardSnapshotJob</code> API call.
  final SnapshotUserConfigurationRedacted? userConfiguration;

  DescribeDashboardSnapshotJobResponse({
    this.arn,
    this.awsAccountId,
    this.createdTime,
    this.dashboardId,
    this.jobStatus,
    this.lastUpdatedTime,
    this.requestId,
    this.snapshotConfiguration,
    this.snapshotJobId,
    this.status,
    this.userConfiguration,
  });

  factory DescribeDashboardSnapshotJobResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDashboardSnapshotJobResponse(
      arn: json['Arn'] as String?,
      awsAccountId: json['AwsAccountId'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      dashboardId: json['DashboardId'] as String?,
      jobStatus: (json['JobStatus'] as String?)?.toSnapshotJobStatus(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      requestId: json['RequestId'] as String?,
      snapshotConfiguration: json['SnapshotConfiguration'] != null
          ? SnapshotConfiguration.fromJson(
              json['SnapshotConfiguration'] as Map<String, dynamic>)
          : null,
      snapshotJobId: json['SnapshotJobId'] as String?,
      status: json['Status'] as int?,
      userConfiguration: json['UserConfiguration'] != null
          ? SnapshotUserConfigurationRedacted.fromJson(
              json['UserConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final awsAccountId = this.awsAccountId;
    final createdTime = this.createdTime;
    final dashboardId = this.dashboardId;
    final jobStatus = this.jobStatus;
    final lastUpdatedTime = this.lastUpdatedTime;
    final requestId = this.requestId;
    final snapshotConfiguration = this.snapshotConfiguration;
    final snapshotJobId = this.snapshotJobId;
    final status = this.status;
    final userConfiguration = this.userConfiguration;
    return {
      if (arn != null) 'Arn': arn,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (jobStatus != null) 'JobStatus': jobStatus.toValue(),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (requestId != null) 'RequestId': requestId,
      if (snapshotConfiguration != null)
        'SnapshotConfiguration': snapshotConfiguration,
      if (snapshotJobId != null) 'SnapshotJobId': snapshotJobId,
      if (status != null) 'Status': status,
      if (userConfiguration != null) 'UserConfiguration': userConfiguration,
    };
  }
}

class DescribeDashboardSnapshotJobResultResponse {
  /// The Amazon Resource Name (ARN) for the snapshot job. The job ARN is
  /// generated when you start a new job with a
  /// <code>StartDashboardSnapshotJob</code> API call.
  final String? arn;

  /// The time that a snapshot job was created.
  final DateTime? createdTime;

  /// Displays information for the error that caused a job to fail.
  final SnapshotJobErrorInfo? errorInfo;

  /// Indicates the status of a job after it has reached a terminal state. A
  /// finished snapshot job will retuen a <code>COMPLETED</code> or
  /// <code>FAILED</code> status.
  final SnapshotJobStatus? jobStatus;

  /// The time that a snapshot job status was last updated.
  final DateTime? lastUpdatedTime;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The result of the snapshot job. Jobs that have successfully completed will
  /// return the S3Uri where they are located. Jobs that have failedwill return
  /// information on the error that caused the job to fail.
  final SnapshotJobResult? result;

  /// The HTTP status of the request
  final int? status;

  DescribeDashboardSnapshotJobResultResponse({
    this.arn,
    this.createdTime,
    this.errorInfo,
    this.jobStatus,
    this.lastUpdatedTime,
    this.requestId,
    this.result,
    this.status,
  });

  factory DescribeDashboardSnapshotJobResultResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDashboardSnapshotJobResultResponse(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      errorInfo: json['ErrorInfo'] != null
          ? SnapshotJobErrorInfo.fromJson(
              json['ErrorInfo'] as Map<String, dynamic>)
          : null,
      jobStatus: (json['JobStatus'] as String?)?.toSnapshotJobStatus(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      requestId: json['RequestId'] as String?,
      result: json['Result'] != null
          ? SnapshotJobResult.fromJson(json['Result'] as Map<String, dynamic>)
          : null,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final errorInfo = this.errorInfo;
    final jobStatus = this.jobStatus;
    final lastUpdatedTime = this.lastUpdatedTime;
    final requestId = this.requestId;
    final result = this.result;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (errorInfo != null) 'ErrorInfo': errorInfo,
      if (jobStatus != null) 'JobStatus': jobStatus.toValue(),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (requestId != null) 'RequestId': requestId,
      if (result != null) 'Result': result,
    };
  }
}

class DescribeDataSetPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? dataSetArn;

  /// The ID for the dataset that you want to create. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? dataSetId;

  /// A list of resource permissions on the dataset.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeDataSetPermissionsResponse({
    this.dataSetArn,
    this.dataSetId,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory DescribeDataSetPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDataSetPermissionsResponse(
      dataSetArn: json['DataSetArn'] as String?,
      dataSetId: json['DataSetId'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetArn = this.dataSetArn;
    final dataSetId = this.dataSetId;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSetArn != null) 'DataSetArn': dataSetArn,
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeDataSetRefreshPropertiesResponse {
  /// The dataset refresh properties.
  final DataSetRefreshProperties? dataSetRefreshProperties;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeDataSetRefreshPropertiesResponse({
    this.dataSetRefreshProperties,
    this.requestId,
    this.status,
  });

  factory DescribeDataSetRefreshPropertiesResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDataSetRefreshPropertiesResponse(
      dataSetRefreshProperties: json['DataSetRefreshProperties'] != null
          ? DataSetRefreshProperties.fromJson(
              json['DataSetRefreshProperties'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetRefreshProperties = this.dataSetRefreshProperties;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSetRefreshProperties != null)
        'DataSetRefreshProperties': dataSetRefreshProperties,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeDataSetResponse {
  /// Information on the dataset.
  final DataSet? dataSet;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeDataSetResponse({
    this.dataSet,
    this.requestId,
    this.status,
  });

  factory DescribeDataSetResponse.fromJson(Map<String, dynamic> json) {
    return DescribeDataSetResponse(
      dataSet: json['DataSet'] != null
          ? DataSet.fromJson(json['DataSet'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSet = this.dataSet;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSet != null) 'DataSet': dataSet,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeDataSourcePermissionsResponse {
  /// The Amazon Resource Name (ARN) of the data source.
  final String? dataSourceArn;

  /// The ID of the data source. This ID is unique per Amazon Web Services Region
  /// for each Amazon Web Services account.
  final String? dataSourceId;

  /// A list of resource permissions on the data source.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeDataSourcePermissionsResponse({
    this.dataSourceArn,
    this.dataSourceId,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory DescribeDataSourcePermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeDataSourcePermissionsResponse(
      dataSourceArn: json['DataSourceArn'] as String?,
      dataSourceId: json['DataSourceId'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceArn = this.dataSourceArn;
    final dataSourceId = this.dataSourceId;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSourceArn != null) 'DataSourceArn': dataSourceArn,
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeDataSourceResponse {
  /// The information on the data source.
  final DataSource? dataSource;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeDataSourceResponse({
    this.dataSource,
    this.requestId,
    this.status,
  });

  factory DescribeDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return DescribeDataSourceResponse(
      dataSource: json['DataSource'] != null
          ? DataSource.fromJson(json['DataSource'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSource = this.dataSource;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSource != null) 'DataSource': dataSource,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeFolderPermissionsResponse {
  /// The Amazon Resource Name (ARN) for the folder.
  final String? arn;

  /// The ID of the folder.
  final String? folderId;

  /// The pagination token for the next set of results, or null if there are no
  /// more results.
  final String? nextToken;

  /// Information about the permissions on the folder.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeFolderPermissionsResponse({
    this.arn,
    this.folderId,
    this.nextToken,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory DescribeFolderPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeFolderPermissionsResponse(
      arn: json['Arn'] as String?,
      folderId: json['FolderId'] as String?,
      nextToken: json['NextToken'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final folderId = this.folderId;
    final nextToken = this.nextToken;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (folderId != null) 'FolderId': folderId,
      if (nextToken != null) 'NextToken': nextToken,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeFolderResolvedPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the folder.
  final String? arn;

  /// The ID of the folder.
  final String? folderId;

  /// A pagination token for the next set of results, or null if there are no more
  /// results.
  final String? nextToken;

  /// Information about the permissions for the folder.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeFolderResolvedPermissionsResponse({
    this.arn,
    this.folderId,
    this.nextToken,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory DescribeFolderResolvedPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeFolderResolvedPermissionsResponse(
      arn: json['Arn'] as String?,
      folderId: json['FolderId'] as String?,
      nextToken: json['NextToken'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final folderId = this.folderId;
    final nextToken = this.nextToken;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (folderId != null) 'FolderId': folderId,
      if (nextToken != null) 'NextToken': nextToken,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeFolderResponse {
  /// Information about the folder.
  final Folder? folder;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeFolderResponse({
    this.folder,
    this.requestId,
    this.status,
  });

  factory DescribeFolderResponse.fromJson(Map<String, dynamic> json) {
    return DescribeFolderResponse(
      folder: json['Folder'] != null
          ? Folder.fromJson(json['Folder'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final folder = this.folder;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (folder != null) 'Folder': folder,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeGroupMembershipResponse {
  final GroupMember? groupMember;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeGroupMembershipResponse({
    this.groupMember,
    this.requestId,
    this.status,
  });

  factory DescribeGroupMembershipResponse.fromJson(Map<String, dynamic> json) {
    return DescribeGroupMembershipResponse(
      groupMember: json['GroupMember'] != null
          ? GroupMember.fromJson(json['GroupMember'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupMember = this.groupMember;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (groupMember != null) 'GroupMember': groupMember,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeGroupResponse {
  /// The name of the group.
  final Group? group;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeGroupResponse({
    this.group,
    this.requestId,
    this.status,
  });

  factory DescribeGroupResponse.fromJson(Map<String, dynamic> json) {
    return DescribeGroupResponse(
      group: json['Group'] != null
          ? Group.fromJson(json['Group'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final group = this.group;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (group != null) 'Group': group,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeIAMPolicyAssignmentResponse {
  /// Information describing the IAM policy assignment.
  final IAMPolicyAssignment? iAMPolicyAssignment;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeIAMPolicyAssignmentResponse({
    this.iAMPolicyAssignment,
    this.requestId,
    this.status,
  });

  factory DescribeIAMPolicyAssignmentResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeIAMPolicyAssignmentResponse(
      iAMPolicyAssignment: json['IAMPolicyAssignment'] != null
          ? IAMPolicyAssignment.fromJson(
              json['IAMPolicyAssignment'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final iAMPolicyAssignment = this.iAMPolicyAssignment;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (iAMPolicyAssignment != null)
        'IAMPolicyAssignment': iAMPolicyAssignment,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeIngestionResponse {
  /// Information about the ingestion.
  final Ingestion? ingestion;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeIngestionResponse({
    this.ingestion,
    this.requestId,
    this.status,
  });

  factory DescribeIngestionResponse.fromJson(Map<String, dynamic> json) {
    return DescribeIngestionResponse(
      ingestion: json['Ingestion'] != null
          ? Ingestion.fromJson(json['Ingestion'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final ingestion = this.ingestion;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (ingestion != null) 'Ingestion': ingestion,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeIpRestrictionResponse {
  /// The ID of the Amazon Web Services account that contains the IP rules.
  final String? awsAccountId;

  /// A value that specifies whether IP rules are turned on.
  final bool? enabled;

  /// A map that describes the IP rules with CIDR range and description.
  final Map<String, String>? ipRestrictionRuleMap;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A map of allowed VPC endpoint IDs and their rule descriptions.
  final Map<String, String>? vpcEndpointIdRestrictionRuleMap;

  /// A map of allowed VPC IDs and their rule descriptions.
  final Map<String, String>? vpcIdRestrictionRuleMap;

  DescribeIpRestrictionResponse({
    this.awsAccountId,
    this.enabled,
    this.ipRestrictionRuleMap,
    this.requestId,
    this.status,
    this.vpcEndpointIdRestrictionRuleMap,
    this.vpcIdRestrictionRuleMap,
  });

  factory DescribeIpRestrictionResponse.fromJson(Map<String, dynamic> json) {
    return DescribeIpRestrictionResponse(
      awsAccountId: json['AwsAccountId'] as String?,
      enabled: json['Enabled'] as bool?,
      ipRestrictionRuleMap:
          (json['IpRestrictionRuleMap'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      vpcEndpointIdRestrictionRuleMap:
          (json['VpcEndpointIdRestrictionRuleMap'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
      vpcIdRestrictionRuleMap:
          (json['VpcIdRestrictionRuleMap'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final enabled = this.enabled;
    final ipRestrictionRuleMap = this.ipRestrictionRuleMap;
    final requestId = this.requestId;
    final status = this.status;
    final vpcEndpointIdRestrictionRuleMap =
        this.vpcEndpointIdRestrictionRuleMap;
    final vpcIdRestrictionRuleMap = this.vpcIdRestrictionRuleMap;
    return {
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (enabled != null) 'Enabled': enabled,
      if (ipRestrictionRuleMap != null)
        'IpRestrictionRuleMap': ipRestrictionRuleMap,
      if (requestId != null) 'RequestId': requestId,
      if (vpcEndpointIdRestrictionRuleMap != null)
        'VpcEndpointIdRestrictionRuleMap': vpcEndpointIdRestrictionRuleMap,
      if (vpcIdRestrictionRuleMap != null)
        'VpcIdRestrictionRuleMap': vpcIdRestrictionRuleMap,
    };
  }
}

class DescribeKeyRegistrationResponse {
  /// The ID of the Amazon Web Services account that contains the customer managed
  /// key registration specified in the request.
  final String? awsAccountId;

  /// A list of <code>RegisteredCustomerManagedKey</code> objects in a Amazon
  /// QuickSight account.
  final List<RegisteredCustomerManagedKey>? keyRegistration;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeKeyRegistrationResponse({
    this.awsAccountId,
    this.keyRegistration,
    this.requestId,
    this.status,
  });

  factory DescribeKeyRegistrationResponse.fromJson(Map<String, dynamic> json) {
    return DescribeKeyRegistrationResponse(
      awsAccountId: json['AwsAccountId'] as String?,
      keyRegistration: (json['KeyRegistration'] as List?)
          ?.whereNotNull()
          .map((e) =>
              RegisteredCustomerManagedKey.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final keyRegistration = this.keyRegistration;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (keyRegistration != null) 'KeyRegistration': keyRegistration,
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class DescribeNamespaceResponse {
  /// The information about the namespace that you're describing. The response
  /// includes the namespace ARN, name, Amazon Web Services Region, creation
  /// status, and identity store. <code>DescribeNamespace</code> also works for
  /// namespaces that are in the process of being created. For incomplete
  /// namespaces, this API operation lists the namespace error types and messages
  /// associated with the creation process.
  final NamespaceInfoV2? namespace;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeNamespaceResponse({
    this.namespace,
    this.requestId,
    this.status,
  });

  factory DescribeNamespaceResponse.fromJson(Map<String, dynamic> json) {
    return DescribeNamespaceResponse(
      namespace: json['Namespace'] != null
          ? NamespaceInfoV2.fromJson(json['Namespace'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final namespace = this.namespace;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (namespace != null) 'Namespace': namespace,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) for the refresh schedule.
  final String? arn;

  /// The refresh schedule.
  final RefreshSchedule? refreshSchedule;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeRefreshScheduleResponse({
    this.arn,
    this.refreshSchedule,
    this.requestId,
    this.status,
  });

  factory DescribeRefreshScheduleResponse.fromJson(Map<String, dynamic> json) {
    return DescribeRefreshScheduleResponse(
      arn: json['Arn'] as String?,
      refreshSchedule: json['RefreshSchedule'] != null
          ? RefreshSchedule.fromJson(
              json['RefreshSchedule'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final refreshSchedule = this.refreshSchedule;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (refreshSchedule != null) 'RefreshSchedule': refreshSchedule,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeRoleCustomPermissionResponse {
  /// The name of the custom permission that is described.
  final String? customPermissionsName;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeRoleCustomPermissionResponse({
    this.customPermissionsName,
    this.requestId,
    this.status,
  });

  factory DescribeRoleCustomPermissionResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeRoleCustomPermissionResponse(
      customPermissionsName: json['CustomPermissionsName'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final customPermissionsName = this.customPermissionsName;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (customPermissionsName != null)
        'CustomPermissionsName': customPermissionsName,
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class DescribeTemplateAliasResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Information about the template alias.
  final TemplateAlias? templateAlias;

  DescribeTemplateAliasResponse({
    this.requestId,
    this.status,
    this.templateAlias,
  });

  factory DescribeTemplateAliasResponse.fromJson(Map<String, dynamic> json) {
    return DescribeTemplateAliasResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateAlias: json['TemplateAlias'] != null
          ? TemplateAlias.fromJson(
              json['TemplateAlias'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final templateAlias = this.templateAlias;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (templateAlias != null) 'TemplateAlias': templateAlias,
    };
  }
}

class DescribeTemplateDefinitionResponse {
  /// The definition of the template.
  ///
  /// A definition is the data model of all features in a Dashboard, Template, or
  /// Analysis.
  final TemplateVersionDefinition? definition;

  /// Errors associated with the template version.
  final List<TemplateError>? errors;

  /// The descriptive name of the template.
  final String? name;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// Status associated with the template.
  ///
  /// <ul>
  /// <li>
  /// <code>CREATION_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>CREATION_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_FAILED</code>
  /// </li>
  /// <li>
  /// <code>DELETED</code>
  /// </li>
  /// </ul>
  final ResourceStatus? resourceStatus;

  /// The HTTP status of the request.
  final int? status;

  /// The ID of the template described.
  final String? templateId;

  /// The ARN of the theme of the template.
  final String? themeArn;

  DescribeTemplateDefinitionResponse({
    this.definition,
    this.errors,
    this.name,
    this.requestId,
    this.resourceStatus,
    this.status,
    this.templateId,
    this.themeArn,
  });

  factory DescribeTemplateDefinitionResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeTemplateDefinitionResponse(
      definition: json['Definition'] != null
          ? TemplateVersionDefinition.fromJson(
              json['Definition'] as Map<String, dynamic>)
          : null,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => TemplateError.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      requestId: json['RequestId'] as String?,
      resourceStatus: (json['ResourceStatus'] as String?)?.toResourceStatus(),
      status: json['Status'] as int?,
      templateId: json['TemplateId'] as String?,
      themeArn: json['ThemeArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final definition = this.definition;
    final errors = this.errors;
    final name = this.name;
    final requestId = this.requestId;
    final resourceStatus = this.resourceStatus;
    final status = this.status;
    final templateId = this.templateId;
    final themeArn = this.themeArn;
    return {
      if (definition != null) 'Definition': definition,
      if (errors != null) 'Errors': errors,
      if (name != null) 'Name': name,
      if (requestId != null) 'RequestId': requestId,
      if (resourceStatus != null) 'ResourceStatus': resourceStatus.toValue(),
      if (templateId != null) 'TemplateId': templateId,
      if (themeArn != null) 'ThemeArn': themeArn,
    };
  }
}

class DescribeTemplatePermissionsResponse {
  /// A list of resource permissions to be set on the template.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the template.
  final String? templateArn;

  /// The ID for the template.
  final String? templateId;

  DescribeTemplatePermissionsResponse({
    this.permissions,
    this.requestId,
    this.status,
    this.templateArn,
    this.templateId,
  });

  factory DescribeTemplatePermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeTemplatePermissionsResponse(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateArn: json['TemplateArn'] as String?,
      templateId: json['TemplateId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    final templateArn = this.templateArn;
    final templateId = this.templateId;
    return {
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (templateArn != null) 'TemplateArn': templateArn,
      if (templateId != null) 'TemplateId': templateId,
    };
  }
}

class DescribeTemplateResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The template structure for the object you want to describe.
  final Template? template;

  DescribeTemplateResponse({
    this.requestId,
    this.status,
    this.template,
  });

  factory DescribeTemplateResponse.fromJson(Map<String, dynamic> json) {
    return DescribeTemplateResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      template: json['Template'] != null
          ? Template.fromJson(json['Template'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final template = this.template;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (template != null) 'Template': template,
    };
  }
}

class DescribeThemeAliasResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Information about the theme alias.
  final ThemeAlias? themeAlias;

  DescribeThemeAliasResponse({
    this.requestId,
    this.status,
    this.themeAlias,
  });

  factory DescribeThemeAliasResponse.fromJson(Map<String, dynamic> json) {
    return DescribeThemeAliasResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeAlias: json['ThemeAlias'] != null
          ? ThemeAlias.fromJson(json['ThemeAlias'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final themeAlias = this.themeAlias;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (themeAlias != null) 'ThemeAlias': themeAlias,
    };
  }
}

class DescribeThemePermissionsResponse {
  /// A list of resource permissions set on the theme.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the theme.
  final String? themeArn;

  /// The ID for the theme.
  final String? themeId;

  DescribeThemePermissionsResponse({
    this.permissions,
    this.requestId,
    this.status,
    this.themeArn,
    this.themeId,
  });

  factory DescribeThemePermissionsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeThemePermissionsResponse(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeArn: json['ThemeArn'] as String?,
      themeId: json['ThemeId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    final themeArn = this.themeArn;
    final themeId = this.themeId;
    return {
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (themeArn != null) 'ThemeArn': themeArn,
      if (themeId != null) 'ThemeId': themeId,
    };
  }
}

class DescribeThemeResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The information about the theme that you are describing.
  final Theme? theme;

  DescribeThemeResponse({
    this.requestId,
    this.status,
    this.theme,
  });

  factory DescribeThemeResponse.fromJson(Map<String, dynamic> json) {
    return DescribeThemeResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      theme: json['Theme'] != null
          ? Theme.fromJson(json['Theme'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final theme = this.theme;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (theme != null) 'Theme': theme,
    };
  }
}

class DescribeTopicPermissionsResponse {
  /// A list of resource permissions that are configured to the topic.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID of the topic that you want to describe. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  DescribeTopicPermissionsResponse({
    this.permissions,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory DescribeTopicPermissionsResponse.fromJson(Map<String, dynamic> json) {
    return DescribeTopicPermissionsResponse(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class DescribeTopicRefreshResponse {
  /// Details of the refresh, which is performed when the topic is created or
  /// updated.
  final TopicRefreshDetails? refreshDetails;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  DescribeTopicRefreshResponse({
    this.refreshDetails,
    this.requestId,
    this.status,
  });

  factory DescribeTopicRefreshResponse.fromJson(Map<String, dynamic> json) {
    return DescribeTopicRefreshResponse(
      refreshDetails: json['RefreshDetails'] != null
          ? TopicRefreshDetails.fromJson(
              json['RefreshDetails'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final refreshDetails = this.refreshDetails;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (refreshDetails != null) 'RefreshDetails': refreshDetails,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class DescribeTopicRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? datasetArn;

  /// The definition of a refresh schedule.
  final TopicRefreshSchedule? refreshSchedule;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID of the topic that contains the refresh schedule that you want to
  /// describe. This ID is unique per Amazon Web Services Region for each Amazon
  /// Web Services account.
  final String? topicId;

  DescribeTopicRefreshScheduleResponse({
    this.datasetArn,
    this.refreshSchedule,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory DescribeTopicRefreshScheduleResponse.fromJson(
      Map<String, dynamic> json) {
    return DescribeTopicRefreshScheduleResponse(
      datasetArn: json['DatasetArn'] as String?,
      refreshSchedule: json['RefreshSchedule'] != null
          ? TopicRefreshSchedule.fromJson(
              json['RefreshSchedule'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final datasetArn = this.datasetArn;
    final refreshSchedule = this.refreshSchedule;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (datasetArn != null) 'DatasetArn': datasetArn,
      if (refreshSchedule != null) 'RefreshSchedule': refreshSchedule,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class DescribeTopicResponse {
  /// The Amazon Resource Name (ARN) of the topic.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The definition of a topic.
  final TopicDetails? topic;

  /// The ID of the topic that you want to describe. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  DescribeTopicResponse({
    this.arn,
    this.requestId,
    this.status,
    this.topic,
    this.topicId,
  });

  factory DescribeTopicResponse.fromJson(Map<String, dynamic> json) {
    return DescribeTopicResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topic: json['Topic'] != null
          ? TopicDetails.fromJson(json['Topic'] as Map<String, dynamic>)
          : null,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final topic = this.topic;
    final topicId = this.topicId;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (topic != null) 'Topic': topic,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class DescribeUserResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The user name.
  final User? user;

  DescribeUserResponse({
    this.requestId,
    this.status,
    this.user,
  });

  factory DescribeUserResponse.fromJson(Map<String, dynamic> json) {
    return DescribeUserResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      user: json['User'] != null
          ? User.fromJson(json['User'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final user = this.user;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (user != null) 'User': user,
    };
  }
}

class DescribeVPCConnectionResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A response object that provides information for the specified VPC
  /// connection.
  final VPCConnection? vPCConnection;

  DescribeVPCConnectionResponse({
    this.requestId,
    this.status,
    this.vPCConnection,
  });

  factory DescribeVPCConnectionResponse.fromJson(Map<String, dynamic> json) {
    return DescribeVPCConnectionResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      vPCConnection: json['VPCConnection'] != null
          ? VPCConnection.fromJson(
              json['VPCConnection'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final vPCConnection = this.vPCConnection;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
      if (vPCConnection != null) 'VPCConnection': vPCConnection,
    };
  }
}

/// The configuration of destination parameter values.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class DestinationParameterValueConfiguration {
  /// The configuration of custom values for destination parameter in
  /// <code>DestinationParameterValueConfiguration</code>.
  final CustomValuesConfiguration? customValuesConfiguration;

  /// The configuration that selects all options.
  final SelectAllValueOptions? selectAllValueOptions;
  final ColumnIdentifier? sourceColumn;

  /// The source field ID of the destination parameter.
  final String? sourceField;

  /// The source parameter name of the destination parameter.
  final String? sourceParameterName;

  DestinationParameterValueConfiguration({
    this.customValuesConfiguration,
    this.selectAllValueOptions,
    this.sourceColumn,
    this.sourceField,
    this.sourceParameterName,
  });

  factory DestinationParameterValueConfiguration.fromJson(
      Map<String, dynamic> json) {
    return DestinationParameterValueConfiguration(
      customValuesConfiguration: json['CustomValuesConfiguration'] != null
          ? CustomValuesConfiguration.fromJson(
              json['CustomValuesConfiguration'] as Map<String, dynamic>)
          : null,
      selectAllValueOptions:
          (json['SelectAllValueOptions'] as String?)?.toSelectAllValueOptions(),
      sourceColumn: json['SourceColumn'] != null
          ? ColumnIdentifier.fromJson(
              json['SourceColumn'] as Map<String, dynamic>)
          : null,
      sourceField: json['SourceField'] as String?,
      sourceParameterName: json['SourceParameterName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final customValuesConfiguration = this.customValuesConfiguration;
    final selectAllValueOptions = this.selectAllValueOptions;
    final sourceColumn = this.sourceColumn;
    final sourceField = this.sourceField;
    final sourceParameterName = this.sourceParameterName;
    return {
      if (customValuesConfiguration != null)
        'CustomValuesConfiguration': customValuesConfiguration,
      if (selectAllValueOptions != null)
        'SelectAllValueOptions': selectAllValueOptions.toValue(),
      if (sourceColumn != null) 'SourceColumn': sourceColumn,
      if (sourceField != null) 'SourceField': sourceField,
      if (sourceParameterName != null)
        'SourceParameterName': sourceParameterName,
    };
  }
}

/// The dimension type field.
class DimensionField {
  /// The dimension type field with categorical type columns.
  final CategoricalDimensionField? categoricalDimensionField;

  /// The dimension type field with date type columns.
  final DateDimensionField? dateDimensionField;

  /// The dimension type field with numerical type columns.
  final NumericalDimensionField? numericalDimensionField;

  DimensionField({
    this.categoricalDimensionField,
    this.dateDimensionField,
    this.numericalDimensionField,
  });

  factory DimensionField.fromJson(Map<String, dynamic> json) {
    return DimensionField(
      categoricalDimensionField: json['CategoricalDimensionField'] != null
          ? CategoricalDimensionField.fromJson(
              json['CategoricalDimensionField'] as Map<String, dynamic>)
          : null,
      dateDimensionField: json['DateDimensionField'] != null
          ? DateDimensionField.fromJson(
              json['DateDimensionField'] as Map<String, dynamic>)
          : null,
      numericalDimensionField: json['NumericalDimensionField'] != null
          ? NumericalDimensionField.fromJson(
              json['NumericalDimensionField'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoricalDimensionField = this.categoricalDimensionField;
    final dateDimensionField = this.dateDimensionField;
    final numericalDimensionField = this.numericalDimensionField;
    return {
      if (categoricalDimensionField != null)
        'CategoricalDimensionField': categoricalDimensionField,
      if (dateDimensionField != null) 'DateDimensionField': dateDimensionField,
      if (numericalDimensionField != null)
        'NumericalDimensionField': numericalDimensionField,
    };
  }
}

enum DisplayFormat {
  auto,
  percent,
  currency,
  number,
  date,
  string,
}

extension DisplayFormatValueExtension on DisplayFormat {
  String toValue() {
    switch (this) {
      case DisplayFormat.auto:
        return 'AUTO';
      case DisplayFormat.percent:
        return 'PERCENT';
      case DisplayFormat.currency:
        return 'CURRENCY';
      case DisplayFormat.number:
        return 'NUMBER';
      case DisplayFormat.date:
        return 'DATE';
      case DisplayFormat.string:
        return 'STRING';
    }
  }
}

extension DisplayFormatFromString on String {
  DisplayFormat toDisplayFormat() {
    switch (this) {
      case 'AUTO':
        return DisplayFormat.auto;
      case 'PERCENT':
        return DisplayFormat.percent;
      case 'CURRENCY':
        return DisplayFormat.currency;
      case 'NUMBER':
        return DisplayFormat.number;
      case 'DATE':
        return DisplayFormat.date;
      case 'STRING':
        return DisplayFormat.string;
    }
    throw Exception('$this is not known in enum DisplayFormat');
  }
}

/// A structure that represents additional options for display formatting.
class DisplayFormatOptions {
  /// Determines the blank cell format.
  final String? blankCellFormat;

  /// The currency symbol, such as <code>USD</code>.
  final String? currencySymbol;

  /// Determines the <code>DateTime</code> format.
  final String? dateFormat;

  /// Determines the decimal separator.
  final TopicNumericSeparatorSymbol? decimalSeparator;

  /// Determines the number of fraction digits.
  final int? fractionDigits;

  /// Determines the grouping separator.
  final String? groupingSeparator;

  /// The negative format.
  final NegativeFormat? negativeFormat;

  /// The prefix value for a display format.
  final String? prefix;

  /// The suffix value for a display format.
  final String? suffix;

  /// The unit scaler. Valid values for this structure are: <code>NONE</code>,
  /// <code>AUTO</code>, <code>THOUSANDS</code>, <code>MILLIONS</code>,
  /// <code>BILLIONS</code>, and <code>TRILLIONS</code>.
  final NumberScale? unitScaler;

  /// A Boolean value that indicates whether to use blank cell format.
  final bool? useBlankCellFormat;

  /// A Boolean value that indicates whether to use grouping.
  final bool? useGrouping;

  DisplayFormatOptions({
    this.blankCellFormat,
    this.currencySymbol,
    this.dateFormat,
    this.decimalSeparator,
    this.fractionDigits,
    this.groupingSeparator,
    this.negativeFormat,
    this.prefix,
    this.suffix,
    this.unitScaler,
    this.useBlankCellFormat,
    this.useGrouping,
  });

  factory DisplayFormatOptions.fromJson(Map<String, dynamic> json) {
    return DisplayFormatOptions(
      blankCellFormat: json['BlankCellFormat'] as String?,
      currencySymbol: json['CurrencySymbol'] as String?,
      dateFormat: json['DateFormat'] as String?,
      decimalSeparator: (json['DecimalSeparator'] as String?)
          ?.toTopicNumericSeparatorSymbol(),
      fractionDigits: json['FractionDigits'] as int?,
      groupingSeparator: json['GroupingSeparator'] as String?,
      negativeFormat: json['NegativeFormat'] != null
          ? NegativeFormat.fromJson(
              json['NegativeFormat'] as Map<String, dynamic>)
          : null,
      prefix: json['Prefix'] as String?,
      suffix: json['Suffix'] as String?,
      unitScaler: (json['UnitScaler'] as String?)?.toNumberScale(),
      useBlankCellFormat: json['UseBlankCellFormat'] as bool?,
      useGrouping: json['UseGrouping'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final blankCellFormat = this.blankCellFormat;
    final currencySymbol = this.currencySymbol;
    final dateFormat = this.dateFormat;
    final decimalSeparator = this.decimalSeparator;
    final fractionDigits = this.fractionDigits;
    final groupingSeparator = this.groupingSeparator;
    final negativeFormat = this.negativeFormat;
    final prefix = this.prefix;
    final suffix = this.suffix;
    final unitScaler = this.unitScaler;
    final useBlankCellFormat = this.useBlankCellFormat;
    final useGrouping = this.useGrouping;
    return {
      if (blankCellFormat != null) 'BlankCellFormat': blankCellFormat,
      if (currencySymbol != null) 'CurrencySymbol': currencySymbol,
      if (dateFormat != null) 'DateFormat': dateFormat,
      if (decimalSeparator != null)
        'DecimalSeparator': decimalSeparator.toValue(),
      if (fractionDigits != null) 'FractionDigits': fractionDigits,
      if (groupingSeparator != null) 'GroupingSeparator': groupingSeparator,
      if (negativeFormat != null) 'NegativeFormat': negativeFormat,
      if (prefix != null) 'Prefix': prefix,
      if (suffix != null) 'Suffix': suffix,
      if (unitScaler != null) 'UnitScaler': unitScaler.toValue(),
      if (useBlankCellFormat != null) 'UseBlankCellFormat': useBlankCellFormat,
      if (useGrouping != null) 'UseGrouping': useGrouping,
    };
  }
}

/// The label options of the label that is displayed in the center of a donut
/// chart. This option isn't available for pie charts.
class DonutCenterOptions {
  /// Determines the visibility of the label in a donut chart. In the Amazon
  /// QuickSight console, this option is called <code>'Show total'</code>.
  final Visibility? labelVisibility;

  DonutCenterOptions({
    this.labelVisibility,
  });

  factory DonutCenterOptions.fromJson(Map<String, dynamic> json) {
    return DonutCenterOptions(
      labelVisibility: (json['LabelVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final labelVisibility = this.labelVisibility;
    return {
      if (labelVisibility != null) 'LabelVisibility': labelVisibility.toValue(),
    };
  }
}

/// The options for configuring a donut chart or pie chart.
class DonutOptions {
  /// The option for define the arc of the chart shape. Valid values are as
  /// follows:
  ///
  /// <ul>
  /// <li>
  /// <code>WHOLE</code> - A pie chart
  /// </li>
  /// <li>
  /// <code>SMALL</code>- A small-sized donut chart
  /// </li>
  /// <li>
  /// <code>MEDIUM</code>- A medium-sized donut chart
  /// </li>
  /// <li>
  /// <code>LARGE</code>- A large-sized donut chart
  /// </li>
  /// </ul>
  final ArcOptions? arcOptions;

  /// The label options of the label that is displayed in the center of a donut
  /// chart. This option isn't available for pie charts.
  final DonutCenterOptions? donutCenterOptions;

  DonutOptions({
    this.arcOptions,
    this.donutCenterOptions,
  });

  factory DonutOptions.fromJson(Map<String, dynamic> json) {
    return DonutOptions(
      arcOptions: json['ArcOptions'] != null
          ? ArcOptions.fromJson(json['ArcOptions'] as Map<String, dynamic>)
          : null,
      donutCenterOptions: json['DonutCenterOptions'] != null
          ? DonutCenterOptions.fromJson(
              json['DonutCenterOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arcOptions = this.arcOptions;
    final donutCenterOptions = this.donutCenterOptions;
    return {
      if (arcOptions != null) 'ArcOptions': arcOptions,
      if (donutCenterOptions != null) 'DonutCenterOptions': donutCenterOptions,
    };
  }
}

/// The drill down filter for the column hierarchies.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class DrillDownFilter {
  /// The category type drill down filter. This filter is used for string type
  /// columns.
  final CategoryDrillDownFilter? categoryFilter;

  /// The numeric equality type drill down filter. This filter is used for number
  /// type columns.
  final NumericEqualityDrillDownFilter? numericEqualityFilter;

  /// The time range drill down filter. This filter is used for date time columns.
  final TimeRangeDrillDownFilter? timeRangeFilter;

  DrillDownFilter({
    this.categoryFilter,
    this.numericEqualityFilter,
    this.timeRangeFilter,
  });

  factory DrillDownFilter.fromJson(Map<String, dynamic> json) {
    return DrillDownFilter(
      categoryFilter: json['CategoryFilter'] != null
          ? CategoryDrillDownFilter.fromJson(
              json['CategoryFilter'] as Map<String, dynamic>)
          : null,
      numericEqualityFilter: json['NumericEqualityFilter'] != null
          ? NumericEqualityDrillDownFilter.fromJson(
              json['NumericEqualityFilter'] as Map<String, dynamic>)
          : null,
      timeRangeFilter: json['TimeRangeFilter'] != null
          ? TimeRangeDrillDownFilter.fromJson(
              json['TimeRangeFilter'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryFilter = this.categoryFilter;
    final numericEqualityFilter = this.numericEqualityFilter;
    final timeRangeFilter = this.timeRangeFilter;
    return {
      if (categoryFilter != null) 'CategoryFilter': categoryFilter,
      if (numericEqualityFilter != null)
        'NumericEqualityFilter': numericEqualityFilter,
      if (timeRangeFilter != null) 'TimeRangeFilter': timeRangeFilter,
    };
  }
}

/// The display options of a control.
class DropDownControlDisplayOptions {
  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The configuration of the <code>Select all</code> options in a dropdown
  /// control.
  final ListControlSelectAllOptions? selectAllOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  DropDownControlDisplayOptions({
    this.infoIconLabelOptions,
    this.selectAllOptions,
    this.titleOptions,
  });

  factory DropDownControlDisplayOptions.fromJson(Map<String, dynamic> json) {
    return DropDownControlDisplayOptions(
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      selectAllOptions: json['SelectAllOptions'] != null
          ? ListControlSelectAllOptions.fromJson(
              json['SelectAllOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final selectAllOptions = this.selectAllOptions;
    final titleOptions = this.titleOptions;
    return {
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (selectAllOptions != null) 'SelectAllOptions': selectAllOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

/// Defines different defaults to the users or groups based on mapping.
class DynamicDefaultValue {
  /// The column that contains the default value of each user or group.
  final ColumnIdentifier defaultValueColumn;

  /// The column that contains the group name.
  final ColumnIdentifier? groupNameColumn;

  /// The column that contains the username.
  final ColumnIdentifier? userNameColumn;

  DynamicDefaultValue({
    required this.defaultValueColumn,
    this.groupNameColumn,
    this.userNameColumn,
  });

  factory DynamicDefaultValue.fromJson(Map<String, dynamic> json) {
    return DynamicDefaultValue(
      defaultValueColumn: ColumnIdentifier.fromJson(
          json['DefaultValueColumn'] as Map<String, dynamic>),
      groupNameColumn: json['GroupNameColumn'] != null
          ? ColumnIdentifier.fromJson(
              json['GroupNameColumn'] as Map<String, dynamic>)
          : null,
      userNameColumn: json['UserNameColumn'] != null
          ? ColumnIdentifier.fromJson(
              json['UserNameColumn'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultValueColumn = this.defaultValueColumn;
    final groupNameColumn = this.groupNameColumn;
    final userNameColumn = this.userNameColumn;
    return {
      'DefaultValueColumn': defaultValueColumn,
      if (groupNameColumn != null) 'GroupNameColumn': groupNameColumn,
      if (userNameColumn != null) 'UserNameColumn': userNameColumn,
    };
  }
}

enum Edition {
  standard,
  enterprise,
  enterpriseAndQ,
}

extension EditionValueExtension on Edition {
  String toValue() {
    switch (this) {
      case Edition.standard:
        return 'STANDARD';
      case Edition.enterprise:
        return 'ENTERPRISE';
      case Edition.enterpriseAndQ:
        return 'ENTERPRISE_AND_Q';
    }
  }
}

extension EditionFromString on String {
  Edition toEdition() {
    switch (this) {
      case 'STANDARD':
        return Edition.standard;
      case 'ENTERPRISE':
        return Edition.enterprise;
      case 'ENTERPRISE_AND_Q':
        return Edition.enterpriseAndQ;
    }
    throw Exception('$this is not known in enum Edition');
  }
}

enum EmbeddingIdentityType {
  iam,
  quicksight,
  anonymous,
}

extension EmbeddingIdentityTypeValueExtension on EmbeddingIdentityType {
  String toValue() {
    switch (this) {
      case EmbeddingIdentityType.iam:
        return 'IAM';
      case EmbeddingIdentityType.quicksight:
        return 'QUICKSIGHT';
      case EmbeddingIdentityType.anonymous:
        return 'ANONYMOUS';
    }
  }
}

extension EmbeddingIdentityTypeFromString on String {
  EmbeddingIdentityType toEmbeddingIdentityType() {
    switch (this) {
      case 'IAM':
        return EmbeddingIdentityType.iam;
      case 'QUICKSIGHT':
        return EmbeddingIdentityType.quicksight;
      case 'ANONYMOUS':
        return EmbeddingIdentityType.anonymous;
    }
    throw Exception('$this is not known in enum EmbeddingIdentityType');
  }
}

/// An empty visual.
///
/// Empty visuals are used in layouts but have not been configured to show any
/// data. A new visual created in the Amazon QuickSight console is considered an
/// <code>EmptyVisual</code> until a visual type is selected.
class EmptyVisual {
  /// The data set that is used in the empty visual. Every visual requires a
  /// dataset to render.
  final String dataSetIdentifier;

  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  EmptyVisual({
    required this.dataSetIdentifier,
    required this.visualId,
    this.actions,
  });

  factory EmptyVisual.fromJson(Map<String, dynamic> json) {
    return EmptyVisual(
      dataSetIdentifier: json['DataSetIdentifier'] as String,
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifier = this.dataSetIdentifier;
    final visualId = this.visualId;
    final actions = this.actions;
    return {
      'DataSetIdentifier': dataSetIdentifier,
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
    };
  }
}

/// An object, structure, or sub-structure of an analysis, template, or
/// dashboard.
class Entity {
  /// The hierarchical path of the entity within the analysis, template, or
  /// dashboard definition tree.
  final String? path;

  Entity({
    this.path,
  });

  factory Entity.fromJson(Map<String, dynamic> json) {
    return Entity(
      path: json['Path'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final path = this.path;
    return {
      if (path != null) 'Path': path,
    };
  }
}

/// Error information for the SPICE ingestion of a dataset.
class ErrorInfo {
  /// Error message.
  final String? message;

  /// Error type.
  final IngestionErrorType? type;

  ErrorInfo({
    this.message,
    this.type,
  });

  factory ErrorInfo.fromJson(Map<String, dynamic> json) {
    return ErrorInfo(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toIngestionErrorType(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// The required parameters for connecting to an Exasol data source.
class ExasolParameters {
  /// The hostname or IP address of the Exasol data source.
  final String host;

  /// The port for the Exasol data source.
  final int port;

  ExasolParameters({
    required this.host,
    required this.port,
  });

  factory ExasolParameters.fromJson(Map<String, dynamic> json) {
    return ExasolParameters(
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final host = this.host;
    final port = this.port;
    return {
      'Host': host,
      'Port': port,
    };
  }
}

/// The exclude period of <code>TimeRangeFilter</code> or
/// <code>RelativeDatesFilter</code>.
class ExcludePeriodConfiguration {
  /// The amount or number of the exclude period.
  final int amount;

  /// The granularity or unit (day, month, year) of the exclude period.
  final TimeGranularity granularity;

  /// The status of the exclude period. Choose from the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>ENABLED</code>
  /// </li>
  /// <li>
  /// <code>DISABLED</code>
  /// </li>
  /// </ul>
  final WidgetStatus? status;

  ExcludePeriodConfiguration({
    required this.amount,
    required this.granularity,
    this.status,
  });

  factory ExcludePeriodConfiguration.fromJson(Map<String, dynamic> json) {
    return ExcludePeriodConfiguration(
      amount: json['Amount'] as int,
      granularity: (json['Granularity'] as String).toTimeGranularity(),
      status: (json['Status'] as String?)?.toWidgetStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final amount = this.amount;
    final granularity = this.granularity;
    final status = this.status;
    return {
      'Amount': amount,
      'Granularity': granularity.toValue(),
      if (status != null) 'Status': status.toValue(),
    };
  }
}

/// The option that determines the hierarchy of the fields that are built within
/// a visual's field wells. These fields can't be duplicated to other visuals.
class ExplicitHierarchy {
  /// The list of columns that define the explicit hierarchy.
  final List<ColumnIdentifier> columns;

  /// The hierarchy ID of the explicit hierarchy.
  final String hierarchyId;

  /// The option that determines the drill down filters for the explicit
  /// hierarchy.
  final List<DrillDownFilter>? drillDownFilters;

  ExplicitHierarchy({
    required this.columns,
    required this.hierarchyId,
    this.drillDownFilters,
  });

  factory ExplicitHierarchy.fromJson(Map<String, dynamic> json) {
    return ExplicitHierarchy(
      columns: (json['Columns'] as List)
          .whereNotNull()
          .map((e) => ColumnIdentifier.fromJson(e as Map<String, dynamic>))
          .toList(),
      hierarchyId: json['HierarchyId'] as String,
      drillDownFilters: (json['DrillDownFilters'] as List?)
          ?.whereNotNull()
          .map((e) => DrillDownFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    final hierarchyId = this.hierarchyId;
    final drillDownFilters = this.drillDownFilters;
    return {
      'Columns': columns,
      'HierarchyId': hierarchyId,
      if (drillDownFilters != null) 'DrillDownFilters': drillDownFilters,
    };
  }
}

/// Determines if hidden fields are included in an exported dashboard.
class ExportHiddenFieldsOption {
  /// The status of the export hidden fields options of a dashbaord.
  final DashboardBehavior? availabilityStatus;

  ExportHiddenFieldsOption({
    this.availabilityStatus,
  });

  factory ExportHiddenFieldsOption.fromJson(Map<String, dynamic> json) {
    return ExportHiddenFieldsOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// Export to .csv option.
class ExportToCSVOption {
  /// Availability status.
  final DashboardBehavior? availabilityStatus;

  ExportToCSVOption({
    this.availabilityStatus,
  });

  factory ExportToCSVOption.fromJson(Map<String, dynamic> json) {
    return ExportToCSVOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// Determines whether or not hidden fields are visible on exported dashbaords.
class ExportWithHiddenFieldsOption {
  /// The status of the export with hidden fields options.
  final DashboardBehavior? availabilityStatus;

  ExportWithHiddenFieldsOption({
    this.availabilityStatus,
  });

  factory ExportWithHiddenFieldsOption.fromJson(Map<String, dynamic> json) {
    return ExportWithHiddenFieldsOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// An entry that appears when a <code>KeyRegistration</code> update to Amazon
/// QuickSight fails.
class FailedKeyRegistrationEntry {
  /// A message that provides information about why a
  /// <code>FailedKeyRegistrationEntry</code> error occurred.
  final String message;

  /// A boolean that indicates whether a <code>FailedKeyRegistrationEntry</code>
  /// resulted from user error. If the value of this property is
  /// <code>True</code>, the error was caused by user error. If the value of this
  /// property is <code>False</code>, the error occurred on the backend. If your
  /// job continues fail and with a <code>False</code> <code>SenderFault</code>
  /// value, contact Amazon Web Services Support.
  final bool senderFault;

  /// The HTTP status of a <code>FailedKeyRegistrationEntry</code> error.
  final int statusCode;

  /// The ARN of the KMS key that failed to update.
  final String? keyArn;

  FailedKeyRegistrationEntry({
    required this.message,
    required this.senderFault,
    required this.statusCode,
    this.keyArn,
  });

  factory FailedKeyRegistrationEntry.fromJson(Map<String, dynamic> json) {
    return FailedKeyRegistrationEntry(
      message: json['Message'] as String,
      senderFault: json['SenderFault'] as bool,
      statusCode: json['StatusCode'] as int,
      keyArn: json['KeyArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final senderFault = this.senderFault;
    final statusCode = this.statusCode;
    final keyArn = this.keyArn;
    return {
      'Message': message,
      'SenderFault': senderFault,
      'StatusCode': statusCode,
      if (keyArn != null) 'KeyArn': keyArn,
    };
  }
}

/// The setup for the detailed tooltip.
class FieldBasedTooltip {
  /// The visibility of <code>Show aggregations</code>.
  final Visibility? aggregationVisibility;

  /// The fields configuration in the tooltip.
  final List<TooltipItem>? tooltipFields;

  /// The type for the &gt;tooltip title. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>NONE</code>: Doesn't use the primary value as the title.
  /// </li>
  /// <li>
  /// <code>PRIMARY_VALUE</code>: Uses primary value as the title.
  /// </li>
  /// </ul>
  final TooltipTitleType? tooltipTitleType;

  FieldBasedTooltip({
    this.aggregationVisibility,
    this.tooltipFields,
    this.tooltipTitleType,
  });

  factory FieldBasedTooltip.fromJson(Map<String, dynamic> json) {
    return FieldBasedTooltip(
      aggregationVisibility:
          (json['AggregationVisibility'] as String?)?.toVisibility(),
      tooltipFields: (json['TooltipFields'] as List?)
          ?.whereNotNull()
          .map((e) => TooltipItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      tooltipTitleType:
          (json['TooltipTitleType'] as String?)?.toTooltipTitleType(),
    );
  }

  Map<String, dynamic> toJson() {
    final aggregationVisibility = this.aggregationVisibility;
    final tooltipFields = this.tooltipFields;
    final tooltipTitleType = this.tooltipTitleType;
    return {
      if (aggregationVisibility != null)
        'AggregationVisibility': aggregationVisibility.toValue(),
      if (tooltipFields != null) 'TooltipFields': tooltipFields,
      if (tooltipTitleType != null)
        'TooltipTitleType': tooltipTitleType.toValue(),
    };
  }
}

/// A FieldFolder element is a folder that contains fields and nested
/// subfolders.
class FieldFolder {
  /// A folder has a list of columns. A column can only be in one folder.
  final List<String>? columns;

  /// The description for a field folder.
  final String? description;

  FieldFolder({
    this.columns,
    this.description,
  });

  factory FieldFolder.fromJson(Map<String, dynamic> json) {
    return FieldFolder(
      columns: (json['columns'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      description: json['description'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    final description = this.description;
    return {
      if (columns != null) 'columns': columns,
      if (description != null) 'description': description,
    };
  }
}

/// The field label type.
class FieldLabelType {
  /// Indicates the field that is targeted by the field label.
  final String? fieldId;

  /// The visibility of the field label.
  final Visibility? visibility;

  FieldLabelType({
    this.fieldId,
    this.visibility,
  });

  factory FieldLabelType.fromJson(Map<String, dynamic> json) {
    return FieldLabelType(
      fieldId: json['FieldId'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final visibility = this.visibility;
    return {
      if (fieldId != null) 'FieldId': fieldId,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The field series item configuration of a line chart.
class FieldSeriesItem {
  /// The axis that you are binding the field to.
  final AxisBinding axisBinding;

  /// The field ID of the field for which you are setting the axis binding.
  final String fieldId;

  /// The options that determine the presentation of line series associated to the
  /// field.
  final LineChartSeriesSettings? settings;

  FieldSeriesItem({
    required this.axisBinding,
    required this.fieldId,
    this.settings,
  });

  factory FieldSeriesItem.fromJson(Map<String, dynamic> json) {
    return FieldSeriesItem(
      axisBinding: (json['AxisBinding'] as String).toAxisBinding(),
      fieldId: json['FieldId'] as String,
      settings: json['Settings'] != null
          ? LineChartSeriesSettings.fromJson(
              json['Settings'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final axisBinding = this.axisBinding;
    final fieldId = this.fieldId;
    final settings = this.settings;
    return {
      'AxisBinding': axisBinding.toValue(),
      'FieldId': fieldId,
      if (settings != null) 'Settings': settings,
    };
  }
}

/// The sort configuration for a field in a field well.
class FieldSort {
  /// The sort direction. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>ASC</code>: Ascending
  /// </li>
  /// <li>
  /// <code>DESC</code>: Descending
  /// </li>
  /// </ul>
  final SortDirection direction;

  /// The sort configuration target field.
  final String fieldId;

  FieldSort({
    required this.direction,
    required this.fieldId,
  });

  factory FieldSort.fromJson(Map<String, dynamic> json) {
    return FieldSort(
      direction: (json['Direction'] as String).toSortDirection(),
      fieldId: json['FieldId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final direction = this.direction;
    final fieldId = this.fieldId;
    return {
      'Direction': direction.toValue(),
      'FieldId': fieldId,
    };
  }
}

/// The field sort options in a chart configuration.
class FieldSortOptions {
  /// The sort configuration for a column that is not used in a field well.
  final ColumnSort? columnSort;

  /// The sort configuration for a field in a field well.
  final FieldSort? fieldSort;

  FieldSortOptions({
    this.columnSort,
    this.fieldSort,
  });

  factory FieldSortOptions.fromJson(Map<String, dynamic> json) {
    return FieldSortOptions(
      columnSort: json['ColumnSort'] != null
          ? ColumnSort.fromJson(json['ColumnSort'] as Map<String, dynamic>)
          : null,
      fieldSort: json['FieldSort'] != null
          ? FieldSort.fromJson(json['FieldSort'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final columnSort = this.columnSort;
    final fieldSort = this.fieldSort;
    return {
      if (columnSort != null) 'ColumnSort': columnSort,
      if (fieldSort != null) 'FieldSort': fieldSort,
    };
  }
}

/// The tooltip item for the fields.
class FieldTooltipItem {
  /// The unique ID of the field that is targeted by the tooltip.
  final String fieldId;

  /// The label of the tooltip item.
  final String? label;

  /// Determines the target of the field tooltip item in a combo chart visual.
  final TooltipTarget? tooltipTarget;

  /// The visibility of the tooltip item.
  final Visibility? visibility;

  FieldTooltipItem({
    required this.fieldId,
    this.label,
    this.tooltipTarget,
    this.visibility,
  });

  factory FieldTooltipItem.fromJson(Map<String, dynamic> json) {
    return FieldTooltipItem(
      fieldId: json['FieldId'] as String,
      label: json['Label'] as String?,
      tooltipTarget: (json['TooltipTarget'] as String?)?.toTooltipTarget(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final label = this.label;
    final tooltipTarget = this.tooltipTarget;
    final visibility = this.visibility;
    return {
      'FieldId': fieldId,
      if (label != null) 'Label': label,
      if (tooltipTarget != null) 'TooltipTarget': tooltipTarget.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

enum FileFormat {
  csv,
  tsv,
  clf,
  elf,
  xlsx,
  json,
}

extension FileFormatValueExtension on FileFormat {
  String toValue() {
    switch (this) {
      case FileFormat.csv:
        return 'CSV';
      case FileFormat.tsv:
        return 'TSV';
      case FileFormat.clf:
        return 'CLF';
      case FileFormat.elf:
        return 'ELF';
      case FileFormat.xlsx:
        return 'XLSX';
      case FileFormat.json:
        return 'JSON';
    }
  }
}

extension FileFormatFromString on String {
  FileFormat toFileFormat() {
    switch (this) {
      case 'CSV':
        return FileFormat.csv;
      case 'TSV':
        return FileFormat.tsv;
      case 'CLF':
        return FileFormat.clf;
      case 'ELF':
        return FileFormat.elf;
      case 'XLSX':
        return FileFormat.xlsx;
      case 'JSON':
        return FileFormat.json;
    }
    throw Exception('$this is not known in enum FileFormat');
  }
}

/// The aggregated field well of the filled map.
class FilledMapAggregatedFieldWells {
  /// The aggregated location field well of the filled map. Values are grouped by
  /// location fields.
  final List<DimensionField>? geospatial;

  /// The aggregated color field well of a filled map. Values are aggregated based
  /// on location fields.
  final List<MeasureField>? values;

  FilledMapAggregatedFieldWells({
    this.geospatial,
    this.values,
  });

  factory FilledMapAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return FilledMapAggregatedFieldWells(
      geospatial: (json['Geospatial'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final geospatial = this.geospatial;
    final values = this.values;
    return {
      if (geospatial != null) 'Geospatial': geospatial,
      if (values != null) 'Values': values,
    };
  }
}

/// The conditional formatting of a <code>FilledMapVisual</code>.
class FilledMapConditionalFormatting {
  /// Conditional formatting options of a <code>FilledMapVisual</code>.
  final List<FilledMapConditionalFormattingOption> conditionalFormattingOptions;

  FilledMapConditionalFormatting({
    required this.conditionalFormattingOptions,
  });

  factory FilledMapConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return FilledMapConditionalFormatting(
      conditionalFormattingOptions:
          (json['ConditionalFormattingOptions'] as List)
              .whereNotNull()
              .map((e) => FilledMapConditionalFormattingOption.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final conditionalFormattingOptions = this.conditionalFormattingOptions;
    return {
      'ConditionalFormattingOptions': conditionalFormattingOptions,
    };
  }
}

/// Conditional formatting options of a <code>FilledMapVisual</code>.
class FilledMapConditionalFormattingOption {
  /// The conditional formatting that determines the shape of the filled map.
  final FilledMapShapeConditionalFormatting shape;

  FilledMapConditionalFormattingOption({
    required this.shape,
  });

  factory FilledMapConditionalFormattingOption.fromJson(
      Map<String, dynamic> json) {
    return FilledMapConditionalFormattingOption(
      shape: FilledMapShapeConditionalFormatting.fromJson(
          json['Shape'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final shape = this.shape;
    return {
      'Shape': shape,
    };
  }
}

/// The configuration for a <code>FilledMapVisual</code>.
class FilledMapConfiguration {
  /// The field wells of the visual.
  final FilledMapFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The map style options of the filled map visual.
  final GeospatialMapStyleOptions? mapStyleOptions;

  /// The sort configuration of a <code>FilledMapVisual</code>.
  final FilledMapSortConfiguration? sortConfiguration;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;

  /// The window options of the filled map visual.
  final GeospatialWindowOptions? windowOptions;

  FilledMapConfiguration({
    this.fieldWells,
    this.interactions,
    this.legend,
    this.mapStyleOptions,
    this.sortConfiguration,
    this.tooltip,
    this.windowOptions,
  });

  factory FilledMapConfiguration.fromJson(Map<String, dynamic> json) {
    return FilledMapConfiguration(
      fieldWells: json['FieldWells'] != null
          ? FilledMapFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      mapStyleOptions: json['MapStyleOptions'] != null
          ? GeospatialMapStyleOptions.fromJson(
              json['MapStyleOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? FilledMapSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      windowOptions: json['WindowOptions'] != null
          ? GeospatialWindowOptions.fromJson(
              json['WindowOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final mapStyleOptions = this.mapStyleOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final windowOptions = this.windowOptions;
    return {
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (mapStyleOptions != null) 'MapStyleOptions': mapStyleOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (windowOptions != null) 'WindowOptions': windowOptions,
    };
  }
}

/// The field wells of a <code>FilledMapVisual</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class FilledMapFieldWells {
  /// The aggregated field well of the filled map.
  final FilledMapAggregatedFieldWells? filledMapAggregatedFieldWells;

  FilledMapFieldWells({
    this.filledMapAggregatedFieldWells,
  });

  factory FilledMapFieldWells.fromJson(Map<String, dynamic> json) {
    return FilledMapFieldWells(
      filledMapAggregatedFieldWells:
          json['FilledMapAggregatedFieldWells'] != null
              ? FilledMapAggregatedFieldWells.fromJson(
                  json['FilledMapAggregatedFieldWells'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filledMapAggregatedFieldWells = this.filledMapAggregatedFieldWells;
    return {
      if (filledMapAggregatedFieldWells != null)
        'FilledMapAggregatedFieldWells': filledMapAggregatedFieldWells,
    };
  }
}

/// The conditional formatting that determines the shape of the filled map.
class FilledMapShapeConditionalFormatting {
  /// The field ID of the filled map shape.
  final String fieldId;

  /// The conditional formatting that determines the background color of a filled
  /// map's shape.
  final ShapeConditionalFormat? format;

  FilledMapShapeConditionalFormatting({
    required this.fieldId,
    this.format,
  });

  factory FilledMapShapeConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return FilledMapShapeConditionalFormatting(
      fieldId: json['FieldId'] as String,
      format: json['Format'] != null
          ? ShapeConditionalFormat.fromJson(
              json['Format'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final format = this.format;
    return {
      'FieldId': fieldId,
      if (format != null) 'Format': format,
    };
  }
}

/// The sort configuration of a <code>FilledMapVisual</code>.
class FilledMapSortConfiguration {
  /// The sort configuration of the location fields.
  final List<FieldSortOptions>? categorySort;

  FilledMapSortConfiguration({
    this.categorySort,
  });

  factory FilledMapSortConfiguration.fromJson(Map<String, dynamic> json) {
    return FilledMapSortConfiguration(
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categorySort = this.categorySort;
    return {
      if (categorySort != null) 'CategorySort': categorySort,
    };
  }
}

/// A filled map.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating
/// filled maps</a> in the <i>Amazon QuickSight User Guide</i>.
class FilledMapVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final FilledMapConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The conditional formatting of a <code>FilledMapVisual</code>.
  final FilledMapConditionalFormatting? conditionalFormatting;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  FilledMapVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.conditionalFormatting,
    this.subtitle,
    this.title,
  });

  factory FilledMapVisual.fromJson(Map<String, dynamic> json) {
    return FilledMapVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? FilledMapConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      conditionalFormatting: json['ConditionalFormatting'] != null
          ? FilledMapConditionalFormatting.fromJson(
              json['ConditionalFormatting'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final conditionalFormatting = this.conditionalFormatting;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (conditionalFormatting != null)
        'ConditionalFormatting': conditionalFormatting,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// With a <code>Filter</code>, you can remove portions of data from a
/// particular visual or view.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class Filter {
  /// A <code>CategoryFilter</code> filters text values.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-text-filter-data-prep.html">Adding
  /// text filters</a> in the <i>Amazon QuickSight User Guide</i>.
  final CategoryFilter? categoryFilter;

  /// A <code>NumericEqualityFilter</code> filters numeric values that equal or do
  /// not equal a given numeric value.
  final NumericEqualityFilter? numericEqualityFilter;

  /// A <code>NumericRangeFilter</code> filters numeric values that are either
  /// inside or outside a given numeric range.
  final NumericRangeFilter? numericRangeFilter;

  /// A <code>RelativeDatesFilter</code> filters date values that are relative to
  /// a given date.
  final RelativeDatesFilter? relativeDatesFilter;

  /// A <code>TimeEqualityFilter</code> filters date-time values that equal or do
  /// not equal a given date/time value.
  final TimeEqualityFilter? timeEqualityFilter;

  /// A <code>TimeRangeFilter</code> filters date-time values that are either
  /// inside or outside a given date/time range.
  final TimeRangeFilter? timeRangeFilter;

  /// A <code>TopBottomFilter</code> filters data to the top or bottom values for
  /// a given column.
  final TopBottomFilter? topBottomFilter;

  Filter({
    this.categoryFilter,
    this.numericEqualityFilter,
    this.numericRangeFilter,
    this.relativeDatesFilter,
    this.timeEqualityFilter,
    this.timeRangeFilter,
    this.topBottomFilter,
  });

  factory Filter.fromJson(Map<String, dynamic> json) {
    return Filter(
      categoryFilter: json['CategoryFilter'] != null
          ? CategoryFilter.fromJson(
              json['CategoryFilter'] as Map<String, dynamic>)
          : null,
      numericEqualityFilter: json['NumericEqualityFilter'] != null
          ? NumericEqualityFilter.fromJson(
              json['NumericEqualityFilter'] as Map<String, dynamic>)
          : null,
      numericRangeFilter: json['NumericRangeFilter'] != null
          ? NumericRangeFilter.fromJson(
              json['NumericRangeFilter'] as Map<String, dynamic>)
          : null,
      relativeDatesFilter: json['RelativeDatesFilter'] != null
          ? RelativeDatesFilter.fromJson(
              json['RelativeDatesFilter'] as Map<String, dynamic>)
          : null,
      timeEqualityFilter: json['TimeEqualityFilter'] != null
          ? TimeEqualityFilter.fromJson(
              json['TimeEqualityFilter'] as Map<String, dynamic>)
          : null,
      timeRangeFilter: json['TimeRangeFilter'] != null
          ? TimeRangeFilter.fromJson(
              json['TimeRangeFilter'] as Map<String, dynamic>)
          : null,
      topBottomFilter: json['TopBottomFilter'] != null
          ? TopBottomFilter.fromJson(
              json['TopBottomFilter'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryFilter = this.categoryFilter;
    final numericEqualityFilter = this.numericEqualityFilter;
    final numericRangeFilter = this.numericRangeFilter;
    final relativeDatesFilter = this.relativeDatesFilter;
    final timeEqualityFilter = this.timeEqualityFilter;
    final timeRangeFilter = this.timeRangeFilter;
    final topBottomFilter = this.topBottomFilter;
    return {
      if (categoryFilter != null) 'CategoryFilter': categoryFilter,
      if (numericEqualityFilter != null)
        'NumericEqualityFilter': numericEqualityFilter,
      if (numericRangeFilter != null) 'NumericRangeFilter': numericRangeFilter,
      if (relativeDatesFilter != null)
        'RelativeDatesFilter': relativeDatesFilter,
      if (timeEqualityFilter != null) 'TimeEqualityFilter': timeEqualityFilter,
      if (timeRangeFilter != null) 'TimeRangeFilter': timeRangeFilter,
      if (topBottomFilter != null) 'TopBottomFilter': topBottomFilter,
    };
  }
}

enum FilterClass {
  enforcedValueFilter,
  conditionalValueFilter,
  namedValueFilter,
}

extension FilterClassValueExtension on FilterClass {
  String toValue() {
    switch (this) {
      case FilterClass.enforcedValueFilter:
        return 'ENFORCED_VALUE_FILTER';
      case FilterClass.conditionalValueFilter:
        return 'CONDITIONAL_VALUE_FILTER';
      case FilterClass.namedValueFilter:
        return 'NAMED_VALUE_FILTER';
    }
  }
}

extension FilterClassFromString on String {
  FilterClass toFilterClass() {
    switch (this) {
      case 'ENFORCED_VALUE_FILTER':
        return FilterClass.enforcedValueFilter;
      case 'CONDITIONAL_VALUE_FILTER':
        return FilterClass.conditionalValueFilter;
      case 'NAMED_VALUE_FILTER':
        return FilterClass.namedValueFilter;
    }
    throw Exception('$this is not known in enum FilterClass');
  }
}

/// The control of a filter that is used to interact with a dashboard or an
/// analysis.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class FilterControl {
  /// A control from a filter that is scoped across more than one sheet. This
  /// represents your filter control on a sheet
  final FilterCrossSheetControl? crossSheet;

  /// A control from a date filter that is used to specify date and time.
  final FilterDateTimePickerControl? dateTimePicker;

  /// A control to display a dropdown list with buttons that are used to select a
  /// single value.
  final FilterDropDownControl? dropdown;

  /// A control to display a list of buttons or boxes. This is used to select
  /// either a single value or multiple values.
  final FilterListControl? list;

  /// A control from a date filter that is used to specify the relative date.
  final FilterRelativeDateTimeControl? relativeDateTime;

  /// A control to display a horizontal toggle bar. This is used to change a value
  /// by sliding the toggle.
  final FilterSliderControl? slider;

  /// A control to display a text box that is used to enter multiple entries.
  final FilterTextAreaControl? textArea;

  /// A control to display a text box that is used to enter a single entry.
  final FilterTextFieldControl? textField;

  FilterControl({
    this.crossSheet,
    this.dateTimePicker,
    this.dropdown,
    this.list,
    this.relativeDateTime,
    this.slider,
    this.textArea,
    this.textField,
  });

  factory FilterControl.fromJson(Map<String, dynamic> json) {
    return FilterControl(
      crossSheet: json['CrossSheet'] != null
          ? FilterCrossSheetControl.fromJson(
              json['CrossSheet'] as Map<String, dynamic>)
          : null,
      dateTimePicker: json['DateTimePicker'] != null
          ? FilterDateTimePickerControl.fromJson(
              json['DateTimePicker'] as Map<String, dynamic>)
          : null,
      dropdown: json['Dropdown'] != null
          ? FilterDropDownControl.fromJson(
              json['Dropdown'] as Map<String, dynamic>)
          : null,
      list: json['List'] != null
          ? FilterListControl.fromJson(json['List'] as Map<String, dynamic>)
          : null,
      relativeDateTime: json['RelativeDateTime'] != null
          ? FilterRelativeDateTimeControl.fromJson(
              json['RelativeDateTime'] as Map<String, dynamic>)
          : null,
      slider: json['Slider'] != null
          ? FilterSliderControl.fromJson(json['Slider'] as Map<String, dynamic>)
          : null,
      textArea: json['TextArea'] != null
          ? FilterTextAreaControl.fromJson(
              json['TextArea'] as Map<String, dynamic>)
          : null,
      textField: json['TextField'] != null
          ? FilterTextFieldControl.fromJson(
              json['TextField'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final crossSheet = this.crossSheet;
    final dateTimePicker = this.dateTimePicker;
    final dropdown = this.dropdown;
    final list = this.list;
    final relativeDateTime = this.relativeDateTime;
    final slider = this.slider;
    final textArea = this.textArea;
    final textField = this.textField;
    return {
      if (crossSheet != null) 'CrossSheet': crossSheet,
      if (dateTimePicker != null) 'DateTimePicker': dateTimePicker,
      if (dropdown != null) 'Dropdown': dropdown,
      if (list != null) 'List': list,
      if (relativeDateTime != null) 'RelativeDateTime': relativeDateTime,
      if (slider != null) 'Slider': slider,
      if (textArea != null) 'TextArea': textArea,
      if (textField != null) 'TextField': textField,
    };
  }
}

/// A control from a filter that is scoped across more than one sheet. This
/// represents your filter control on a sheet
class FilterCrossSheetControl {
  /// The ID of the <code>FilterCrossSheetControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterCrossSheetControl</code>.
  final String sourceFilterId;

  /// The values that are displayed in a control can be configured to only show
  /// values that are valid based on what's selected in other controls.
  final CascadingControlConfiguration? cascadingControlConfiguration;

  FilterCrossSheetControl({
    required this.filterControlId,
    required this.sourceFilterId,
    this.cascadingControlConfiguration,
  });

  factory FilterCrossSheetControl.fromJson(Map<String, dynamic> json) {
    return FilterCrossSheetControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      cascadingControlConfiguration:
          json['CascadingControlConfiguration'] != null
              ? CascadingControlConfiguration.fromJson(
                  json['CascadingControlConfiguration'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final cascadingControlConfiguration = this.cascadingControlConfiguration;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      if (cascadingControlConfiguration != null)
        'CascadingControlConfiguration': cascadingControlConfiguration,
    };
  }
}

/// A control from a date filter that is used to specify date and time.
class FilterDateTimePickerControl {
  /// The ID of the <code>FilterDateTimePickerControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterDateTimePickerControl</code>.
  final String sourceFilterId;

  /// The title of the <code>FilterDateTimePickerControl</code>.
  final String title;

  /// The display options of a control.
  final DateTimePickerControlDisplayOptions? displayOptions;

  /// The type of the <code>FilterDropDownControl</code>. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>MULTI_SELECT</code>: The user can select multiple entries from a
  /// dropdown menu.
  /// </li>
  /// <li>
  /// <code>SINGLE_SELECT</code>: The user can select a single entry from a
  /// dropdown menu.
  /// </li>
  /// </ul>
  final SheetControlDateTimePickerType? type;

  FilterDateTimePickerControl({
    required this.filterControlId,
    required this.sourceFilterId,
    required this.title,
    this.displayOptions,
    this.type,
  });

  factory FilterDateTimePickerControl.fromJson(Map<String, dynamic> json) {
    return FilterDateTimePickerControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? DateTimePickerControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlDateTimePickerType(),
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final title = this.title;
    final displayOptions = this.displayOptions;
    final type = this.type;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A control to display a dropdown list with buttons that are used to select a
/// single value.
class FilterDropDownControl {
  /// The ID of the <code>FilterDropDownControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterDropDownControl</code>.
  final String sourceFilterId;

  /// The title of the <code>FilterDropDownControl</code>.
  final String title;

  /// The values that are displayed in a control can be configured to only show
  /// values that are valid based on what's selected in other controls.
  final CascadingControlConfiguration? cascadingControlConfiguration;

  /// The display options of the <code>FilterDropDownControl</code>.
  final DropDownControlDisplayOptions? displayOptions;

  /// A list of selectable values that are used in a control.
  final FilterSelectableValues? selectableValues;

  /// The type of the <code>FilterDropDownControl</code>. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>MULTI_SELECT</code>: The user can select multiple entries from a
  /// dropdown menu.
  /// </li>
  /// <li>
  /// <code>SINGLE_SELECT</code>: The user can select a single entry from a
  /// dropdown menu.
  /// </li>
  /// </ul>
  final SheetControlListType? type;

  FilterDropDownControl({
    required this.filterControlId,
    required this.sourceFilterId,
    required this.title,
    this.cascadingControlConfiguration,
    this.displayOptions,
    this.selectableValues,
    this.type,
  });

  factory FilterDropDownControl.fromJson(Map<String, dynamic> json) {
    return FilterDropDownControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      title: json['Title'] as String,
      cascadingControlConfiguration:
          json['CascadingControlConfiguration'] != null
              ? CascadingControlConfiguration.fromJson(
                  json['CascadingControlConfiguration'] as Map<String, dynamic>)
              : null,
      displayOptions: json['DisplayOptions'] != null
          ? DropDownControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      selectableValues: json['SelectableValues'] != null
          ? FilterSelectableValues.fromJson(
              json['SelectableValues'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlListType(),
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final title = this.title;
    final cascadingControlConfiguration = this.cascadingControlConfiguration;
    final displayOptions = this.displayOptions;
    final selectableValues = this.selectableValues;
    final type = this.type;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      'Title': title,
      if (cascadingControlConfiguration != null)
        'CascadingControlConfiguration': cascadingControlConfiguration,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (selectableValues != null) 'SelectableValues': selectableValues,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A grouping of individual filters. Filter groups are applied to the same
/// group of visuals.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/add-a-compound-filter.html">Adding
/// filter conditions (group filters) with AND and OR operators</a> in the
/// <i>Amazon QuickSight User Guide</i>.
class FilterGroup {
  /// The filter new feature which can apply filter group to all data sets. Choose
  /// one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_DATASETS</code>
  /// </li>
  /// <li>
  /// <code>SINGLE_DATASET</code>
  /// </li>
  /// </ul>
  final CrossDatasetTypes crossDataset;

  /// The value that uniquely identifies a <code>FilterGroup</code> within a
  /// dashboard, template, or analysis.
  final String filterGroupId;

  /// The list of filters that are present in a <code>FilterGroup</code>.
  final List<Filter> filters;

  /// The configuration that specifies what scope to apply to a
  /// <code>FilterGroup</code>.
  ///
  /// This is a union type structure. For this structure to be valid, only one of
  /// the attributes can be defined.
  final FilterScopeConfiguration scopeConfiguration;

  /// The status of the <code>FilterGroup</code>.
  final WidgetStatus? status;

  FilterGroup({
    required this.crossDataset,
    required this.filterGroupId,
    required this.filters,
    required this.scopeConfiguration,
    this.status,
  });

  factory FilterGroup.fromJson(Map<String, dynamic> json) {
    return FilterGroup(
      crossDataset: (json['CrossDataset'] as String).toCrossDatasetTypes(),
      filterGroupId: json['FilterGroupId'] as String,
      filters: (json['Filters'] as List)
          .whereNotNull()
          .map((e) => Filter.fromJson(e as Map<String, dynamic>))
          .toList(),
      scopeConfiguration: FilterScopeConfiguration.fromJson(
          json['ScopeConfiguration'] as Map<String, dynamic>),
      status: (json['Status'] as String?)?.toWidgetStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final crossDataset = this.crossDataset;
    final filterGroupId = this.filterGroupId;
    final filters = this.filters;
    final scopeConfiguration = this.scopeConfiguration;
    final status = this.status;
    return {
      'CrossDataset': crossDataset.toValue(),
      'FilterGroupId': filterGroupId,
      'Filters': filters,
      'ScopeConfiguration': scopeConfiguration,
      if (status != null) 'Status': status.toValue(),
    };
  }
}

/// A list of filter configurations.
class FilterListConfiguration {
  /// The match operator that is used to determine if a filter should be applied.
  final CategoryFilterMatchOperator matchOperator;

  /// The list of category values for the filter.
  final List<String>? categoryValues;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption? nullOption;

  /// Select all of the values. Null is not the assigned value of select all.
  ///
  /// <ul>
  /// <li>
  /// <code>FILTER_ALL_VALUES</code>
  /// </li>
  /// </ul>
  final CategoryFilterSelectAllOptions? selectAllOptions;

  FilterListConfiguration({
    required this.matchOperator,
    this.categoryValues,
    this.nullOption,
    this.selectAllOptions,
  });

  factory FilterListConfiguration.fromJson(Map<String, dynamic> json) {
    return FilterListConfiguration(
      matchOperator:
          (json['MatchOperator'] as String).toCategoryFilterMatchOperator(),
      categoryValues: (json['CategoryValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      nullOption: (json['NullOption'] as String?)?.toFilterNullOption(),
      selectAllOptions: (json['SelectAllOptions'] as String?)
          ?.toCategoryFilterSelectAllOptions(),
    );
  }

  Map<String, dynamic> toJson() {
    final matchOperator = this.matchOperator;
    final categoryValues = this.categoryValues;
    final nullOption = this.nullOption;
    final selectAllOptions = this.selectAllOptions;
    return {
      'MatchOperator': matchOperator.toValue(),
      if (categoryValues != null) 'CategoryValues': categoryValues,
      if (nullOption != null) 'NullOption': nullOption.toValue(),
      if (selectAllOptions != null)
        'SelectAllOptions': selectAllOptions.toValue(),
    };
  }
}

/// A control to display a list of buttons or boxes. This is used to select
/// either a single value or multiple values.
class FilterListControl {
  /// The ID of the <code>FilterListControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterListControl</code>.
  final String sourceFilterId;

  /// The title of the <code>FilterListControl</code>.
  final String title;

  /// The values that are displayed in a control can be configured to only show
  /// values that are valid based on what's selected in other controls.
  final CascadingControlConfiguration? cascadingControlConfiguration;

  /// The display options of a control.
  final ListControlDisplayOptions? displayOptions;

  /// A list of selectable values that are used in a control.
  final FilterSelectableValues? selectableValues;

  /// The type of the <code>FilterListControl</code>. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>MULTI_SELECT</code>: The user can select multiple entries from the
  /// list.
  /// </li>
  /// <li>
  /// <code>SINGLE_SELECT</code>: The user can select a single entry from the
  /// list.
  /// </li>
  /// </ul>
  final SheetControlListType? type;

  FilterListControl({
    required this.filterControlId,
    required this.sourceFilterId,
    required this.title,
    this.cascadingControlConfiguration,
    this.displayOptions,
    this.selectableValues,
    this.type,
  });

  factory FilterListControl.fromJson(Map<String, dynamic> json) {
    return FilterListControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      title: json['Title'] as String,
      cascadingControlConfiguration:
          json['CascadingControlConfiguration'] != null
              ? CascadingControlConfiguration.fromJson(
                  json['CascadingControlConfiguration'] as Map<String, dynamic>)
              : null,
      displayOptions: json['DisplayOptions'] != null
          ? ListControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      selectableValues: json['SelectableValues'] != null
          ? FilterSelectableValues.fromJson(
              json['SelectableValues'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlListType(),
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final title = this.title;
    final cascadingControlConfiguration = this.cascadingControlConfiguration;
    final displayOptions = this.displayOptions;
    final selectableValues = this.selectableValues;
    final type = this.type;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      'Title': title,
      if (cascadingControlConfiguration != null)
        'CascadingControlConfiguration': cascadingControlConfiguration,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (selectableValues != null) 'SelectableValues': selectableValues,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum FilterNullOption {
  allValues,
  nullsOnly,
  nonNullsOnly,
}

extension FilterNullOptionValueExtension on FilterNullOption {
  String toValue() {
    switch (this) {
      case FilterNullOption.allValues:
        return 'ALL_VALUES';
      case FilterNullOption.nullsOnly:
        return 'NULLS_ONLY';
      case FilterNullOption.nonNullsOnly:
        return 'NON_NULLS_ONLY';
    }
  }
}

extension FilterNullOptionFromString on String {
  FilterNullOption toFilterNullOption() {
    switch (this) {
      case 'ALL_VALUES':
        return FilterNullOption.allValues;
      case 'NULLS_ONLY':
        return FilterNullOption.nullsOnly;
      case 'NON_NULLS_ONLY':
        return FilterNullOption.nonNullsOnly;
    }
    throw Exception('$this is not known in enum FilterNullOption');
  }
}

/// A transform operation that filters rows based on a condition.
class FilterOperation {
  /// An expression that must evaluate to a Boolean value. Rows for which the
  /// expression evaluates to true are kept in the dataset.
  final String conditionExpression;

  FilterOperation({
    required this.conditionExpression,
  });

  factory FilterOperation.fromJson(Map<String, dynamic> json) {
    return FilterOperation(
      conditionExpression: json['ConditionExpression'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final conditionExpression = this.conditionExpression;
    return {
      'ConditionExpression': conditionExpression,
    };
  }
}

/// The configuration of selected fields in
/// the<code>CustomActionFilterOperation</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class FilterOperationSelectedFieldsConfiguration {
  /// The selected columns of a dataset.
  final List<ColumnIdentifier>? selectedColumns;

  /// A structure that contains the options that choose which fields are filtered
  /// in the <code>CustomActionFilterOperation</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_FIELDS</code>: Applies the filter operation to all fields.
  /// </li>
  /// </ul>
  final SelectedFieldOptions? selectedFieldOptions;

  /// Chooses the fields that are filtered in
  /// <code>CustomActionFilterOperation</code>.
  final List<String>? selectedFields;

  FilterOperationSelectedFieldsConfiguration({
    this.selectedColumns,
    this.selectedFieldOptions,
    this.selectedFields,
  });

  factory FilterOperationSelectedFieldsConfiguration.fromJson(
      Map<String, dynamic> json) {
    return FilterOperationSelectedFieldsConfiguration(
      selectedColumns: (json['SelectedColumns'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnIdentifier.fromJson(e as Map<String, dynamic>))
          .toList(),
      selectedFieldOptions:
          (json['SelectedFieldOptions'] as String?)?.toSelectedFieldOptions(),
      selectedFields: (json['SelectedFields'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final selectedColumns = this.selectedColumns;
    final selectedFieldOptions = this.selectedFieldOptions;
    final selectedFields = this.selectedFields;
    return {
      if (selectedColumns != null) 'SelectedColumns': selectedColumns,
      if (selectedFieldOptions != null)
        'SelectedFieldOptions': selectedFieldOptions.toValue(),
      if (selectedFields != null) 'SelectedFields': selectedFields,
    };
  }
}

/// The configuration of target visuals that you want to be filtered.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class FilterOperationTargetVisualsConfiguration {
  /// The configuration of the same-sheet target visuals that you want to be
  /// filtered.
  final SameSheetTargetVisualConfiguration? sameSheetTargetVisualConfiguration;

  FilterOperationTargetVisualsConfiguration({
    this.sameSheetTargetVisualConfiguration,
  });

  factory FilterOperationTargetVisualsConfiguration.fromJson(
      Map<String, dynamic> json) {
    return FilterOperationTargetVisualsConfiguration(
      sameSheetTargetVisualConfiguration:
          json['SameSheetTargetVisualConfiguration'] != null
              ? SameSheetTargetVisualConfiguration.fromJson(
                  json['SameSheetTargetVisualConfiguration']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sameSheetTargetVisualConfiguration =
        this.sameSheetTargetVisualConfiguration;
    return {
      if (sameSheetTargetVisualConfiguration != null)
        'SameSheetTargetVisualConfiguration':
            sameSheetTargetVisualConfiguration,
    };
  }
}

enum FilterOperator {
  stringEquals,
  stringLike,
}

extension FilterOperatorValueExtension on FilterOperator {
  String toValue() {
    switch (this) {
      case FilterOperator.stringEquals:
        return 'StringEquals';
      case FilterOperator.stringLike:
        return 'StringLike';
    }
  }
}

extension FilterOperatorFromString on String {
  FilterOperator toFilterOperator() {
    switch (this) {
      case 'StringEquals':
        return FilterOperator.stringEquals;
      case 'StringLike':
        return FilterOperator.stringLike;
    }
    throw Exception('$this is not known in enum FilterOperator');
  }
}

/// A control from a date filter that is used to specify the relative date.
class FilterRelativeDateTimeControl {
  /// The ID of the <code>FilterTextAreaControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterTextAreaControl</code>.
  final String sourceFilterId;

  /// The title of the <code>FilterTextAreaControl</code>.
  final String title;

  /// The display options of a control.
  final RelativeDateTimeControlDisplayOptions? displayOptions;

  FilterRelativeDateTimeControl({
    required this.filterControlId,
    required this.sourceFilterId,
    required this.title,
    this.displayOptions,
  });

  factory FilterRelativeDateTimeControl.fromJson(Map<String, dynamic> json) {
    return FilterRelativeDateTimeControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? RelativeDateTimeControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final title = this.title;
    final displayOptions = this.displayOptions;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// The scope configuration for a <code>FilterGroup</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class FilterScopeConfiguration {
  /// The configuration that applies a filter to all sheets. When you choose
  /// <code>AllSheets</code> as the value for a
  /// <code>FilterScopeConfiguration</code>, this filter is applied to all visuals
  /// of all sheets in an Analysis, Dashboard, or Template. The
  /// <code>AllSheetsFilterScopeConfiguration</code> is chosen.
  final AllSheetsFilterScopeConfiguration? allSheets;

  /// The configuration for applying a filter to specific sheets.
  final SelectedSheetsFilterScopeConfiguration? selectedSheets;

  FilterScopeConfiguration({
    this.allSheets,
    this.selectedSheets,
  });

  factory FilterScopeConfiguration.fromJson(Map<String, dynamic> json) {
    return FilterScopeConfiguration(
      allSheets: json['AllSheets'] != null
          ? AllSheetsFilterScopeConfiguration.fromJson(
              json['AllSheets'] as Map<String, dynamic>)
          : null,
      selectedSheets: json['SelectedSheets'] != null
          ? SelectedSheetsFilterScopeConfiguration.fromJson(
              json['SelectedSheets'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final allSheets = this.allSheets;
    final selectedSheets = this.selectedSheets;
    return {
      if (allSheets != null) 'AllSheets': allSheets,
      if (selectedSheets != null) 'SelectedSheets': selectedSheets,
    };
  }
}

/// A list of selectable values that are used in a control.
class FilterSelectableValues {
  /// The values that are used in the <code>FilterSelectableValues</code>.
  final List<String>? values;

  FilterSelectableValues({
    this.values,
  });

  factory FilterSelectableValues.fromJson(Map<String, dynamic> json) {
    return FilterSelectableValues(
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final values = this.values;
    return {
      if (values != null) 'Values': values,
    };
  }
}

/// A control to display a horizontal toggle bar. This is used to change a value
/// by sliding the toggle.
class FilterSliderControl {
  /// The ID of the <code>FilterSliderControl</code>.
  final String filterControlId;

  /// The larger value that is displayed at the right of the slider.
  final double maximumValue;

  /// The smaller value that is displayed at the left of the slider.
  final double minimumValue;

  /// The source filter ID of the <code>FilterSliderControl</code>.
  final String sourceFilterId;

  /// The number of increments that the slider bar is divided into.
  final double stepSize;

  /// The title of the <code>FilterSliderControl</code>.
  final String title;

  /// The display options of a control.
  final SliderControlDisplayOptions? displayOptions;

  /// The type of the <code>FilterSliderControl</code>. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>SINGLE_POINT</code>: Filter against(equals) a single data point.
  /// </li>
  /// <li>
  /// <code>RANGE</code>: Filter data that is in a specified range.
  /// </li>
  /// </ul>
  final SheetControlSliderType? type;

  FilterSliderControl({
    required this.filterControlId,
    required this.maximumValue,
    required this.minimumValue,
    required this.sourceFilterId,
    required this.stepSize,
    required this.title,
    this.displayOptions,
    this.type,
  });

  factory FilterSliderControl.fromJson(Map<String, dynamic> json) {
    return FilterSliderControl(
      filterControlId: json['FilterControlId'] as String,
      maximumValue: json['MaximumValue'] as double,
      minimumValue: json['MinimumValue'] as double,
      sourceFilterId: json['SourceFilterId'] as String,
      stepSize: json['StepSize'] as double,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? SliderControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlSliderType(),
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final maximumValue = this.maximumValue;
    final minimumValue = this.minimumValue;
    final sourceFilterId = this.sourceFilterId;
    final stepSize = this.stepSize;
    final title = this.title;
    final displayOptions = this.displayOptions;
    final type = this.type;
    return {
      'FilterControlId': filterControlId,
      'MaximumValue': maximumValue,
      'MinimumValue': minimumValue,
      'SourceFilterId': sourceFilterId,
      'StepSize': stepSize,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A control to display a text box that is used to enter multiple entries.
class FilterTextAreaControl {
  /// The ID of the <code>FilterTextAreaControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterTextAreaControl</code>.
  final String sourceFilterId;

  /// The title of the <code>FilterTextAreaControl</code>.
  final String title;

  /// The delimiter that is used to separate the lines in text.
  final String? delimiter;

  /// The display options of a control.
  final TextAreaControlDisplayOptions? displayOptions;

  FilterTextAreaControl({
    required this.filterControlId,
    required this.sourceFilterId,
    required this.title,
    this.delimiter,
    this.displayOptions,
  });

  factory FilterTextAreaControl.fromJson(Map<String, dynamic> json) {
    return FilterTextAreaControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      title: json['Title'] as String,
      delimiter: json['Delimiter'] as String?,
      displayOptions: json['DisplayOptions'] != null
          ? TextAreaControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final title = this.title;
    final delimiter = this.delimiter;
    final displayOptions = this.displayOptions;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      'Title': title,
      if (delimiter != null) 'Delimiter': delimiter,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// A control to display a text box that is used to enter a single entry.
class FilterTextFieldControl {
  /// The ID of the <code>FilterTextFieldControl</code>.
  final String filterControlId;

  /// The source filter ID of the <code>FilterTextFieldControl</code>.
  final String sourceFilterId;

  /// The title of the <code>FilterTextFieldControl</code>.
  final String title;

  /// The display options of a control.
  final TextFieldControlDisplayOptions? displayOptions;

  FilterTextFieldControl({
    required this.filterControlId,
    required this.sourceFilterId,
    required this.title,
    this.displayOptions,
  });

  factory FilterTextFieldControl.fromJson(Map<String, dynamic> json) {
    return FilterTextFieldControl(
      filterControlId: json['FilterControlId'] as String,
      sourceFilterId: json['SourceFilterId'] as String,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? TextFieldControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filterControlId = this.filterControlId;
    final sourceFilterId = this.sourceFilterId;
    final title = this.title;
    final displayOptions = this.displayOptions;
    return {
      'FilterControlId': filterControlId,
      'SourceFilterId': sourceFilterId,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

enum FilterVisualScope {
  allVisuals,
  selectedVisuals,
}

extension FilterVisualScopeValueExtension on FilterVisualScope {
  String toValue() {
    switch (this) {
      case FilterVisualScope.allVisuals:
        return 'ALL_VISUALS';
      case FilterVisualScope.selectedVisuals:
        return 'SELECTED_VISUALS';
    }
  }
}

extension FilterVisualScopeFromString on String {
  FilterVisualScope toFilterVisualScope() {
    switch (this) {
      case 'ALL_VISUALS':
        return FilterVisualScope.allVisuals;
      case 'SELECTED_VISUALS':
        return FilterVisualScope.selectedVisuals;
    }
    throw Exception('$this is not known in enum FilterVisualScope');
  }
}

/// A folder in Amazon QuickSight.
class Folder {
  /// The Amazon Resource Name (ARN) for the folder.
  final String? arn;

  /// The time that the folder was created.
  final DateTime? createdTime;

  /// The ID of the folder.
  final String? folderId;

  /// An array of ancestor ARN strings for the folder.
  final List<String>? folderPath;

  /// The type of folder it is.
  final FolderType? folderType;

  /// The time that the folder was last updated.
  final DateTime? lastUpdatedTime;

  /// A display name for the folder.
  final String? name;

  /// The sharing scope of the folder.
  final SharingModel? sharingModel;

  Folder({
    this.arn,
    this.createdTime,
    this.folderId,
    this.folderPath,
    this.folderType,
    this.lastUpdatedTime,
    this.name,
    this.sharingModel,
  });

  factory Folder.fromJson(Map<String, dynamic> json) {
    return Folder(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      folderId: json['FolderId'] as String?,
      folderPath: (json['FolderPath'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      folderType: (json['FolderType'] as String?)?.toFolderType(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      sharingModel: (json['SharingModel'] as String?)?.toSharingModel(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final folderId = this.folderId;
    final folderPath = this.folderPath;
    final folderType = this.folderType;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final sharingModel = this.sharingModel;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (folderId != null) 'FolderId': folderId,
      if (folderPath != null) 'FolderPath': folderPath,
      if (folderType != null) 'FolderType': folderType.toValue(),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (sharingModel != null) 'SharingModel': sharingModel.toValue(),
    };
  }
}

enum FolderFilterAttribute {
  parentFolderArn,
  directQuicksightOwner,
  directQuicksightSoleOwner,
  directQuicksightViewerOrOwner,
  quicksightOwner,
  quicksightViewerOrOwner,
  folderName,
}

extension FolderFilterAttributeValueExtension on FolderFilterAttribute {
  String toValue() {
    switch (this) {
      case FolderFilterAttribute.parentFolderArn:
        return 'PARENT_FOLDER_ARN';
      case FolderFilterAttribute.directQuicksightOwner:
        return 'DIRECT_QUICKSIGHT_OWNER';
      case FolderFilterAttribute.directQuicksightSoleOwner:
        return 'DIRECT_QUICKSIGHT_SOLE_OWNER';
      case FolderFilterAttribute.directQuicksightViewerOrOwner:
        return 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER';
      case FolderFilterAttribute.quicksightOwner:
        return 'QUICKSIGHT_OWNER';
      case FolderFilterAttribute.quicksightViewerOrOwner:
        return 'QUICKSIGHT_VIEWER_OR_OWNER';
      case FolderFilterAttribute.folderName:
        return 'FOLDER_NAME';
    }
  }
}

extension FolderFilterAttributeFromString on String {
  FolderFilterAttribute toFolderFilterAttribute() {
    switch (this) {
      case 'PARENT_FOLDER_ARN':
        return FolderFilterAttribute.parentFolderArn;
      case 'DIRECT_QUICKSIGHT_OWNER':
        return FolderFilterAttribute.directQuicksightOwner;
      case 'DIRECT_QUICKSIGHT_SOLE_OWNER':
        return FolderFilterAttribute.directQuicksightSoleOwner;
      case 'DIRECT_QUICKSIGHT_VIEWER_OR_OWNER':
        return FolderFilterAttribute.directQuicksightViewerOrOwner;
      case 'QUICKSIGHT_OWNER':
        return FolderFilterAttribute.quicksightOwner;
      case 'QUICKSIGHT_VIEWER_OR_OWNER':
        return FolderFilterAttribute.quicksightViewerOrOwner;
      case 'FOLDER_NAME':
        return FolderFilterAttribute.folderName;
    }
    throw Exception('$this is not known in enum FolderFilterAttribute');
  }
}

/// An asset in a Amazon QuickSight folder, such as a dashboard, analysis, or
/// dataset.
class FolderMember {
  /// The ID of an asset in the folder.
  final String? memberId;

  /// The type of asset that it is.
  final MemberType? memberType;

  FolderMember({
    this.memberId,
    this.memberType,
  });

  factory FolderMember.fromJson(Map<String, dynamic> json) {
    return FolderMember(
      memberId: json['MemberId'] as String?,
      memberType: (json['MemberType'] as String?)?.toMemberType(),
    );
  }

  Map<String, dynamic> toJson() {
    final memberId = this.memberId;
    final memberType = this.memberType;
    return {
      if (memberId != null) 'MemberId': memberId,
      if (memberType != null) 'MemberType': memberType.toValue(),
    };
  }
}

/// A filter to use to search an Amazon QuickSight folder.
class FolderSearchFilter {
  /// The name of a value that you want to use in the filter. For example,
  /// <code>"Name": "QUICKSIGHT_OWNER"</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or group,
  /// and any folders with that ARN listed as one of the folder's owners or
  /// viewers are returned. Implicit permissions from folders or groups are
  /// considered.
  /// </li>
  /// <li>
  /// <code>QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and any
  /// folders with that ARN listed as one of the owners of the folders are
  /// returned. Implicit permissions from folders or groups are considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_SOLE_OWNER</code>: Provide an ARN of a user or
  /// group, and any folders with that ARN listed as the only owner of the folder
  /// are returned. Implicit permissions from folders or groups are not
  /// considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_OWNER</code>: Provide an ARN of a user or group, and
  /// any folders with that ARN listed as one of the owners of the folders are
  /// returned. Implicit permissions from folders or groups are not considered.
  /// </li>
  /// <li>
  /// <code>DIRECT_QUICKSIGHT_VIEWER_OR_OWNER</code>: Provide an ARN of a user or
  /// group, and any folders with that ARN listed as one of the owners or viewers
  /// of the folders are returned. Implicit permissions from folders or groups are
  /// not considered.
  /// </li>
  /// <li>
  /// <code>FOLDER_NAME</code>: Any folders whose names have a substring match to
  /// this value will be returned.
  /// </li>
  /// <li>
  /// <code>PARENT_FOLDER_ARN</code>: Provide an ARN of a folder, and any folders
  /// that are directly under that parent folder are returned. If you choose to
  /// use this option and leave the value blank, all root-level folders in the
  /// account are returned.
  /// </li>
  /// </ul>
  final FolderFilterAttribute? name;

  /// The comparison operator that you want to use as a filter, for example
  /// <code>"Operator": "StringEquals"</code>. Valid values are
  /// <code>"StringEquals"</code> and <code>"StringLike"</code>.
  ///
  /// If you set the operator value to <code>"StringEquals"</code>, you need to
  /// provide an ownership related filter in the <code>"NAME"</code> field and the
  /// arn of the user or group whose folders you want to search in the
  /// <code>"Value"</code> field. For example,
  /// <code>"Name":"DIRECT_QUICKSIGHT_OWNER", "Operator": "StringEquals", "Value":
  /// "arn:aws:quicksight:us-east-1:1:user/default/UserName1"</code>.
  ///
  /// If you set the value to <code>"StringLike"</code>, you need to provide the
  /// name of the folders you are searching for. For example,
  /// <code>"Name":"FOLDER_NAME", "Operator": "StringLike", "Value":
  /// "Test"</code>. The <code>"StringLike"</code> operator only supports the
  /// <code>NAME</code> value <code>FOLDER_NAME</code>.
  final FilterOperator? operator;

  /// The value of the named item (in this example,
  /// <code>PARENT_FOLDER_ARN</code>), that you want to use as a filter. For
  /// example, <code>"Value":
  /// "arn:aws:quicksight:us-east-1:1:folder/folderId"</code>.
  final String? value;

  FolderSearchFilter({
    this.name,
    this.operator,
    this.value,
  });

  Map<String, dynamic> toJson() {
    final name = this.name;
    final operator = this.operator;
    final value = this.value;
    return {
      if (name != null) 'Name': name.toValue(),
      if (operator != null) 'Operator': operator.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

/// A summary of information about an existing Amazon QuickSight folder.
class FolderSummary {
  /// The Amazon Resource Name (ARN) of the folder.
  final String? arn;

  /// The time that the folder was created.
  final DateTime? createdTime;

  /// The ID of the folder.
  final String? folderId;

  /// The type of folder.
  final FolderType? folderType;

  /// The time that the folder was last updated.
  final DateTime? lastUpdatedTime;

  /// The display name of the folder.
  final String? name;

  /// The sharing scope of the folder.
  final SharingModel? sharingModel;

  FolderSummary({
    this.arn,
    this.createdTime,
    this.folderId,
    this.folderType,
    this.lastUpdatedTime,
    this.name,
    this.sharingModel,
  });

  factory FolderSummary.fromJson(Map<String, dynamic> json) {
    return FolderSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      folderId: json['FolderId'] as String?,
      folderType: (json['FolderType'] as String?)?.toFolderType(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      sharingModel: (json['SharingModel'] as String?)?.toSharingModel(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final folderId = this.folderId;
    final folderType = this.folderType;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final sharingModel = this.sharingModel;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (folderId != null) 'FolderId': folderId,
      if (folderType != null) 'FolderType': folderType.toValue(),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (sharingModel != null) 'SharingModel': sharingModel.toValue(),
    };
  }
}

enum FolderType {
  shared,
  restricted,
}

extension FolderTypeValueExtension on FolderType {
  String toValue() {
    switch (this) {
      case FolderType.shared:
        return 'SHARED';
      case FolderType.restricted:
        return 'RESTRICTED';
    }
  }
}

extension FolderTypeFromString on String {
  FolderType toFolderType() {
    switch (this) {
      case 'SHARED':
        return FolderType.shared;
      case 'RESTRICTED':
        return FolderType.restricted;
    }
    throw Exception('$this is not known in enum FolderType');
  }
}

/// Determines the font settings.
class Font {
  /// Determines the font family settings.
  final String? fontFamily;

  Font({
    this.fontFamily,
  });

  factory Font.fromJson(Map<String, dynamic> json) {
    return Font(
      fontFamily: json['FontFamily'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fontFamily = this.fontFamily;
    return {
      if (fontFamily != null) 'FontFamily': fontFamily,
    };
  }
}

/// Configures the display properties of the given text.
class FontConfiguration {
  /// Determines the color of the text.
  final String? fontColor;

  /// Determines the appearance of decorative lines on the text.
  final FontDecoration? fontDecoration;

  /// The option that determines the text display size.
  final FontSize? fontSize;

  /// Determines the text display face that is inherited by the given font family.
  final FontStyle? fontStyle;

  /// The option that determines the text display weight, or boldness.
  final FontWeight? fontWeight;

  FontConfiguration({
    this.fontColor,
    this.fontDecoration,
    this.fontSize,
    this.fontStyle,
    this.fontWeight,
  });

  factory FontConfiguration.fromJson(Map<String, dynamic> json) {
    return FontConfiguration(
      fontColor: json['FontColor'] as String?,
      fontDecoration: (json['FontDecoration'] as String?)?.toFontDecoration(),
      fontSize: json['FontSize'] != null
          ? FontSize.fromJson(json['FontSize'] as Map<String, dynamic>)
          : null,
      fontStyle: (json['FontStyle'] as String?)?.toFontStyle(),
      fontWeight: json['FontWeight'] != null
          ? FontWeight.fromJson(json['FontWeight'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fontColor = this.fontColor;
    final fontDecoration = this.fontDecoration;
    final fontSize = this.fontSize;
    final fontStyle = this.fontStyle;
    final fontWeight = this.fontWeight;
    return {
      if (fontColor != null) 'FontColor': fontColor,
      if (fontDecoration != null) 'FontDecoration': fontDecoration.toValue(),
      if (fontSize != null) 'FontSize': fontSize,
      if (fontStyle != null) 'FontStyle': fontStyle.toValue(),
      if (fontWeight != null) 'FontWeight': fontWeight,
    };
  }
}

enum FontDecoration {
  underline,
  none,
}

extension FontDecorationValueExtension on FontDecoration {
  String toValue() {
    switch (this) {
      case FontDecoration.underline:
        return 'UNDERLINE';
      case FontDecoration.none:
        return 'NONE';
    }
  }
}

extension FontDecorationFromString on String {
  FontDecoration toFontDecoration() {
    switch (this) {
      case 'UNDERLINE':
        return FontDecoration.underline;
      case 'NONE':
        return FontDecoration.none;
    }
    throw Exception('$this is not known in enum FontDecoration');
  }
}

/// The option that determines the text display size.
class FontSize {
  /// The lexical name for the text size, proportional to its surrounding context.
  final RelativeFontSize? relative;

  FontSize({
    this.relative,
  });

  factory FontSize.fromJson(Map<String, dynamic> json) {
    return FontSize(
      relative: (json['Relative'] as String?)?.toRelativeFontSize(),
    );
  }

  Map<String, dynamic> toJson() {
    final relative = this.relative;
    return {
      if (relative != null) 'Relative': relative.toValue(),
    };
  }
}

enum FontStyle {
  normal,
  italic,
}

extension FontStyleValueExtension on FontStyle {
  String toValue() {
    switch (this) {
      case FontStyle.normal:
        return 'NORMAL';
      case FontStyle.italic:
        return 'ITALIC';
    }
  }
}

extension FontStyleFromString on String {
  FontStyle toFontStyle() {
    switch (this) {
      case 'NORMAL':
        return FontStyle.normal;
      case 'ITALIC':
        return FontStyle.italic;
    }
    throw Exception('$this is not known in enum FontStyle');
  }
}

/// The option that determines the text display weight, or boldness.
class FontWeight {
  /// The lexical name for the level of boldness of the text display.
  final FontWeightName? name;

  FontWeight({
    this.name,
  });

  factory FontWeight.fromJson(Map<String, dynamic> json) {
    return FontWeight(
      name: (json['Name'] as String?)?.toFontWeightName(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    return {
      if (name != null) 'Name': name.toValue(),
    };
  }
}

enum FontWeightName {
  normal,
  bold,
}

extension FontWeightNameValueExtension on FontWeightName {
  String toValue() {
    switch (this) {
      case FontWeightName.normal:
        return 'NORMAL';
      case FontWeightName.bold:
        return 'BOLD';
    }
  }
}

extension FontWeightNameFromString on String {
  FontWeightName toFontWeightName() {
    switch (this) {
      case 'NORMAL':
        return FontWeightName.normal;
      case 'BOLD':
        return FontWeightName.bold;
    }
    throw Exception('$this is not known in enum FontWeightName');
  }
}

/// The forecast computation configuration.
class ForecastComputation {
  /// The ID for a computation.
  final String computationId;

  /// The custom seasonality value setup of a forecast computation.
  final int? customSeasonalityValue;

  /// The lower boundary setup of a forecast computation.
  final double? lowerBoundary;

  /// The name of a computation.
  final String? name;

  /// The periods backward setup of a forecast computation.
  final int? periodsBackward;

  /// The periods forward setup of a forecast computation.
  final int? periodsForward;

  /// The prediction interval setup of a forecast computation.
  final int? predictionInterval;

  /// The seasonality setup of a forecast computation. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>AUTOMATIC</code>
  /// </li>
  /// <li>
  /// <code>CUSTOM</code>: Checks the custom seasonality value.
  /// </li>
  /// </ul>
  final ForecastComputationSeasonality? seasonality;

  /// The time field that is used in a computation.
  final DimensionField? time;

  /// The upper boundary setup of a forecast computation.
  final double? upperBoundary;

  /// The value field that is used in a computation.
  final MeasureField? value;

  ForecastComputation({
    required this.computationId,
    this.customSeasonalityValue,
    this.lowerBoundary,
    this.name,
    this.periodsBackward,
    this.periodsForward,
    this.predictionInterval,
    this.seasonality,
    this.time,
    this.upperBoundary,
    this.value,
  });

  factory ForecastComputation.fromJson(Map<String, dynamic> json) {
    return ForecastComputation(
      computationId: json['ComputationId'] as String,
      customSeasonalityValue: json['CustomSeasonalityValue'] as int?,
      lowerBoundary: json['LowerBoundary'] as double?,
      name: json['Name'] as String?,
      periodsBackward: json['PeriodsBackward'] as int?,
      periodsForward: json['PeriodsForward'] as int?,
      predictionInterval: json['PredictionInterval'] as int?,
      seasonality:
          (json['Seasonality'] as String?)?.toForecastComputationSeasonality(),
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
      upperBoundary: json['UpperBoundary'] as double?,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final customSeasonalityValue = this.customSeasonalityValue;
    final lowerBoundary = this.lowerBoundary;
    final name = this.name;
    final periodsBackward = this.periodsBackward;
    final periodsForward = this.periodsForward;
    final predictionInterval = this.predictionInterval;
    final seasonality = this.seasonality;
    final time = this.time;
    final upperBoundary = this.upperBoundary;
    final value = this.value;
    return {
      'ComputationId': computationId,
      if (customSeasonalityValue != null)
        'CustomSeasonalityValue': customSeasonalityValue,
      if (lowerBoundary != null) 'LowerBoundary': lowerBoundary,
      if (name != null) 'Name': name,
      if (periodsBackward != null) 'PeriodsBackward': periodsBackward,
      if (periodsForward != null) 'PeriodsForward': periodsForward,
      if (predictionInterval != null) 'PredictionInterval': predictionInterval,
      if (seasonality != null) 'Seasonality': seasonality.toValue(),
      if (time != null) 'Time': time,
      if (upperBoundary != null) 'UpperBoundary': upperBoundary,
      if (value != null) 'Value': value,
    };
  }
}

enum ForecastComputationSeasonality {
  automatic,
  custom,
}

extension ForecastComputationSeasonalityValueExtension
    on ForecastComputationSeasonality {
  String toValue() {
    switch (this) {
      case ForecastComputationSeasonality.automatic:
        return 'AUTOMATIC';
      case ForecastComputationSeasonality.custom:
        return 'CUSTOM';
    }
  }
}

extension ForecastComputationSeasonalityFromString on String {
  ForecastComputationSeasonality toForecastComputationSeasonality() {
    switch (this) {
      case 'AUTOMATIC':
        return ForecastComputationSeasonality.automatic;
      case 'CUSTOM':
        return ForecastComputationSeasonality.custom;
    }
    throw Exception(
        '$this is not known in enum ForecastComputationSeasonality');
  }
}

/// The forecast configuration that is used in a line chart's display
/// properties.
class ForecastConfiguration {
  /// The forecast properties setup of a forecast in the line chart.
  final TimeBasedForecastProperties? forecastProperties;

  /// The forecast scenario of a forecast in the line chart.
  final ForecastScenario? scenario;

  ForecastConfiguration({
    this.forecastProperties,
    this.scenario,
  });

  factory ForecastConfiguration.fromJson(Map<String, dynamic> json) {
    return ForecastConfiguration(
      forecastProperties: json['ForecastProperties'] != null
          ? TimeBasedForecastProperties.fromJson(
              json['ForecastProperties'] as Map<String, dynamic>)
          : null,
      scenario: json['Scenario'] != null
          ? ForecastScenario.fromJson(json['Scenario'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final forecastProperties = this.forecastProperties;
    final scenario = this.scenario;
    return {
      if (forecastProperties != null) 'ForecastProperties': forecastProperties,
      if (scenario != null) 'Scenario': scenario,
    };
  }
}

/// The forecast scenario of a forecast in the line chart.
class ForecastScenario {
  /// The what-if analysis forecast setup with the target date.
  final WhatIfPointScenario? whatIfPointScenario;

  /// The what-if analysis forecast setup with the date range.
  final WhatIfRangeScenario? whatIfRangeScenario;

  ForecastScenario({
    this.whatIfPointScenario,
    this.whatIfRangeScenario,
  });

  factory ForecastScenario.fromJson(Map<String, dynamic> json) {
    return ForecastScenario(
      whatIfPointScenario: json['WhatIfPointScenario'] != null
          ? WhatIfPointScenario.fromJson(
              json['WhatIfPointScenario'] as Map<String, dynamic>)
          : null,
      whatIfRangeScenario: json['WhatIfRangeScenario'] != null
          ? WhatIfRangeScenario.fromJson(
              json['WhatIfRangeScenario'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final whatIfPointScenario = this.whatIfPointScenario;
    final whatIfRangeScenario = this.whatIfRangeScenario;
    return {
      if (whatIfPointScenario != null)
        'WhatIfPointScenario': whatIfPointScenario,
      if (whatIfRangeScenario != null)
        'WhatIfRangeScenario': whatIfRangeScenario,
    };
  }
}

/// The formatting configuration for all types of field.
class FormatConfiguration {
  /// Formatting configuration for <code>DateTime</code> fields.
  final DateTimeFormatConfiguration? dateTimeFormatConfiguration;

  /// Formatting configuration for number fields.
  final NumberFormatConfiguration? numberFormatConfiguration;

  /// Formatting configuration for string fields.
  final StringFormatConfiguration? stringFormatConfiguration;

  FormatConfiguration({
    this.dateTimeFormatConfiguration,
    this.numberFormatConfiguration,
    this.stringFormatConfiguration,
  });

  factory FormatConfiguration.fromJson(Map<String, dynamic> json) {
    return FormatConfiguration(
      dateTimeFormatConfiguration: json['DateTimeFormatConfiguration'] != null
          ? DateTimeFormatConfiguration.fromJson(
              json['DateTimeFormatConfiguration'] as Map<String, dynamic>)
          : null,
      numberFormatConfiguration: json['NumberFormatConfiguration'] != null
          ? NumberFormatConfiguration.fromJson(
              json['NumberFormatConfiguration'] as Map<String, dynamic>)
          : null,
      stringFormatConfiguration: json['StringFormatConfiguration'] != null
          ? StringFormatConfiguration.fromJson(
              json['StringFormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeFormatConfiguration = this.dateTimeFormatConfiguration;
    final numberFormatConfiguration = this.numberFormatConfiguration;
    final stringFormatConfiguration = this.stringFormatConfiguration;
    return {
      if (dateTimeFormatConfiguration != null)
        'DateTimeFormatConfiguration': dateTimeFormatConfiguration,
      if (numberFormatConfiguration != null)
        'NumberFormatConfiguration': numberFormatConfiguration,
      if (stringFormatConfiguration != null)
        'StringFormatConfiguration': stringFormatConfiguration,
    };
  }
}

/// Configuration options for the canvas of a free-form layout.
class FreeFormLayoutCanvasSizeOptions {
  /// The options that determine the sizing of the canvas used in a free-form
  /// layout.
  final FreeFormLayoutScreenCanvasSizeOptions? screenCanvasSizeOptions;

  FreeFormLayoutCanvasSizeOptions({
    this.screenCanvasSizeOptions,
  });

  factory FreeFormLayoutCanvasSizeOptions.fromJson(Map<String, dynamic> json) {
    return FreeFormLayoutCanvasSizeOptions(
      screenCanvasSizeOptions: json['ScreenCanvasSizeOptions'] != null
          ? FreeFormLayoutScreenCanvasSizeOptions.fromJson(
              json['ScreenCanvasSizeOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final screenCanvasSizeOptions = this.screenCanvasSizeOptions;
    return {
      if (screenCanvasSizeOptions != null)
        'ScreenCanvasSizeOptions': screenCanvasSizeOptions,
    };
  }
}

/// The configuration of a free-form layout.
class FreeFormLayoutConfiguration {
  /// The elements that are included in a free-form layout.
  final List<FreeFormLayoutElement> elements;
  final FreeFormLayoutCanvasSizeOptions? canvasSizeOptions;

  FreeFormLayoutConfiguration({
    required this.elements,
    this.canvasSizeOptions,
  });

  factory FreeFormLayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return FreeFormLayoutConfiguration(
      elements: (json['Elements'] as List)
          .whereNotNull()
          .map((e) => FreeFormLayoutElement.fromJson(e as Map<String, dynamic>))
          .toList(),
      canvasSizeOptions: json['CanvasSizeOptions'] != null
          ? FreeFormLayoutCanvasSizeOptions.fromJson(
              json['CanvasSizeOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final elements = this.elements;
    final canvasSizeOptions = this.canvasSizeOptions;
    return {
      'Elements': elements,
      if (canvasSizeOptions != null) 'CanvasSizeOptions': canvasSizeOptions,
    };
  }
}

/// An element within a free-form layout.
class FreeFormLayoutElement {
  /// A unique identifier for an element within a free-form layout.
  final String elementId;

  /// The type of element.
  final LayoutElementType elementType;

  /// The height of an element within a free-form layout.
  final String height;

  /// The width of an element within a free-form layout.
  final String width;

  /// The x-axis coordinate of the element.
  final String xAxisLocation;

  /// The y-axis coordinate of the element.
  final String yAxisLocation;

  /// The background style configuration of a free-form layout element.
  final FreeFormLayoutElementBackgroundStyle? backgroundStyle;

  /// The border style configuration of a free-form layout element.
  final FreeFormLayoutElementBorderStyle? borderStyle;

  /// The loading animation configuration of a free-form layout element.
  final LoadingAnimation? loadingAnimation;

  /// The rendering rules that determine when an element should be displayed
  /// within a free-form layout.
  final List<SheetElementRenderingRule>? renderingRules;

  /// The border style configuration of a free-form layout element. This border
  /// style is used when the element is selected.
  final FreeFormLayoutElementBorderStyle? selectedBorderStyle;

  /// The visibility of an element within a free-form layout.
  final Visibility? visibility;

  FreeFormLayoutElement({
    required this.elementId,
    required this.elementType,
    required this.height,
    required this.width,
    required this.xAxisLocation,
    required this.yAxisLocation,
    this.backgroundStyle,
    this.borderStyle,
    this.loadingAnimation,
    this.renderingRules,
    this.selectedBorderStyle,
    this.visibility,
  });

  factory FreeFormLayoutElement.fromJson(Map<String, dynamic> json) {
    return FreeFormLayoutElement(
      elementId: json['ElementId'] as String,
      elementType: (json['ElementType'] as String).toLayoutElementType(),
      height: json['Height'] as String,
      width: json['Width'] as String,
      xAxisLocation: json['XAxisLocation'] as String,
      yAxisLocation: json['YAxisLocation'] as String,
      backgroundStyle: json['BackgroundStyle'] != null
          ? FreeFormLayoutElementBackgroundStyle.fromJson(
              json['BackgroundStyle'] as Map<String, dynamic>)
          : null,
      borderStyle: json['BorderStyle'] != null
          ? FreeFormLayoutElementBorderStyle.fromJson(
              json['BorderStyle'] as Map<String, dynamic>)
          : null,
      loadingAnimation: json['LoadingAnimation'] != null
          ? LoadingAnimation.fromJson(
              json['LoadingAnimation'] as Map<String, dynamic>)
          : null,
      renderingRules: (json['RenderingRules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              SheetElementRenderingRule.fromJson(e as Map<String, dynamic>))
          .toList(),
      selectedBorderStyle: json['SelectedBorderStyle'] != null
          ? FreeFormLayoutElementBorderStyle.fromJson(
              json['SelectedBorderStyle'] as Map<String, dynamic>)
          : null,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final elementId = this.elementId;
    final elementType = this.elementType;
    final height = this.height;
    final width = this.width;
    final xAxisLocation = this.xAxisLocation;
    final yAxisLocation = this.yAxisLocation;
    final backgroundStyle = this.backgroundStyle;
    final borderStyle = this.borderStyle;
    final loadingAnimation = this.loadingAnimation;
    final renderingRules = this.renderingRules;
    final selectedBorderStyle = this.selectedBorderStyle;
    final visibility = this.visibility;
    return {
      'ElementId': elementId,
      'ElementType': elementType.toValue(),
      'Height': height,
      'Width': width,
      'XAxisLocation': xAxisLocation,
      'YAxisLocation': yAxisLocation,
      if (backgroundStyle != null) 'BackgroundStyle': backgroundStyle,
      if (borderStyle != null) 'BorderStyle': borderStyle,
      if (loadingAnimation != null) 'LoadingAnimation': loadingAnimation,
      if (renderingRules != null) 'RenderingRules': renderingRules,
      if (selectedBorderStyle != null)
        'SelectedBorderStyle': selectedBorderStyle,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The background style configuration of a free-form layout element.
class FreeFormLayoutElementBackgroundStyle {
  /// The background color of a free-form layout element.
  final String? color;

  /// The background visibility of a free-form layout element.
  final Visibility? visibility;

  FreeFormLayoutElementBackgroundStyle({
    this.color,
    this.visibility,
  });

  factory FreeFormLayoutElementBackgroundStyle.fromJson(
      Map<String, dynamic> json) {
    return FreeFormLayoutElementBackgroundStyle(
      color: json['Color'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final visibility = this.visibility;
    return {
      if (color != null) 'Color': color,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The background style configuration of a free-form layout element.
class FreeFormLayoutElementBorderStyle {
  /// The border color of a free-form layout element.
  final String? color;

  /// The border visibility of a free-form layout element.
  final Visibility? visibility;

  FreeFormLayoutElementBorderStyle({
    this.color,
    this.visibility,
  });

  factory FreeFormLayoutElementBorderStyle.fromJson(Map<String, dynamic> json) {
    return FreeFormLayoutElementBorderStyle(
      color: json['Color'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final visibility = this.visibility;
    return {
      if (color != null) 'Color': color,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The options that determine the sizing of the canvas used in a free-form
/// layout.
class FreeFormLayoutScreenCanvasSizeOptions {
  /// The width that the view port will be optimized for when the layout renders.
  final String optimizedViewPortWidth;

  FreeFormLayoutScreenCanvasSizeOptions({
    required this.optimizedViewPortWidth,
  });

  factory FreeFormLayoutScreenCanvasSizeOptions.fromJson(
      Map<String, dynamic> json) {
    return FreeFormLayoutScreenCanvasSizeOptions(
      optimizedViewPortWidth: json['OptimizedViewPortWidth'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final optimizedViewPortWidth = this.optimizedViewPortWidth;
    return {
      'OptimizedViewPortWidth': optimizedViewPortWidth,
    };
  }
}

/// The free-form layout configuration of a section.
class FreeFormSectionLayoutConfiguration {
  /// The elements that are included in the free-form layout.
  final List<FreeFormLayoutElement> elements;

  FreeFormSectionLayoutConfiguration({
    required this.elements,
  });

  factory FreeFormSectionLayoutConfiguration.fromJson(
      Map<String, dynamic> json) {
    return FreeFormSectionLayoutConfiguration(
      elements: (json['Elements'] as List)
          .whereNotNull()
          .map((e) => FreeFormLayoutElement.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final elements = this.elements;
    return {
      'Elements': elements,
    };
  }
}

/// The field well configuration of a <code>FunnelChartVisual</code>.
class FunnelChartAggregatedFieldWells {
  /// The category field wells of a funnel chart. Values are grouped by category
  /// fields.
  final List<DimensionField>? category;

  /// The value field wells of a funnel chart. Values are aggregated based on
  /// categories.
  final List<MeasureField>? values;

  FunnelChartAggregatedFieldWells({
    this.category,
    this.values,
  });

  factory FunnelChartAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return FunnelChartAggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final values = this.values;
    return {
      if (category != null) 'Category': category,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a <code>FunnelChartVisual</code>.
class FunnelChartConfiguration {
  /// The label options of the categories that are displayed in a
  /// <code>FunnelChartVisual</code>.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The options that determine the presentation of the data labels.
  final FunnelChartDataLabelOptions? dataLabelOptions;

  /// The field well configuration of a <code>FunnelChartVisual</code>.
  final FunnelChartFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The sort configuration of a <code>FunnelChartVisual</code>.
  final FunnelChartSortConfiguration? sortConfiguration;

  /// The tooltip configuration of a <code>FunnelChartVisual</code>.
  final TooltipOptions? tooltip;

  /// The label options for the values that are displayed in a
  /// <code>FunnelChartVisual</code>.
  final ChartAxisLabelOptions? valueLabelOptions;

  /// The visual palette configuration of a <code>FunnelChartVisual</code>.
  final VisualPalette? visualPalette;

  FunnelChartConfiguration({
    this.categoryLabelOptions,
    this.dataLabelOptions,
    this.fieldWells,
    this.interactions,
    this.sortConfiguration,
    this.tooltip,
    this.valueLabelOptions,
    this.visualPalette,
  });

  factory FunnelChartConfiguration.fromJson(Map<String, dynamic> json) {
    return FunnelChartConfiguration(
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      dataLabelOptions: json['DataLabelOptions'] != null
          ? FunnelChartDataLabelOptions.fromJson(
              json['DataLabelOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? FunnelChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? FunnelChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      valueLabelOptions: json['ValueLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ValueLabelOptions'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryLabelOptions = this.categoryLabelOptions;
    final dataLabelOptions = this.dataLabelOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final valueLabelOptions = this.valueLabelOptions;
    final visualPalette = this.visualPalette;
    return {
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (dataLabelOptions != null) 'DataLabelOptions': dataLabelOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (valueLabelOptions != null) 'ValueLabelOptions': valueLabelOptions,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The options that determine the presentation of the data labels.
class FunnelChartDataLabelOptions {
  /// The visibility of the category labels within the data labels.
  final Visibility? categoryLabelVisibility;

  /// The color of the data label text.
  final String? labelColor;

  /// The font configuration for the data labels.
  ///
  /// Only the <code>FontSize</code> attribute of the font configuration is used
  /// for data labels.
  final FontConfiguration? labelFontConfiguration;

  /// Determines the style of the metric labels.
  final FunnelChartMeasureDataLabelStyle? measureDataLabelStyle;

  /// The visibility of the measure labels within the data labels.
  final Visibility? measureLabelVisibility;

  /// Determines the positioning of the data label relative to a section of the
  /// funnel.
  final DataLabelPosition? position;

  /// The visibility option that determines if data labels are displayed.
  final Visibility? visibility;

  FunnelChartDataLabelOptions({
    this.categoryLabelVisibility,
    this.labelColor,
    this.labelFontConfiguration,
    this.measureDataLabelStyle,
    this.measureLabelVisibility,
    this.position,
    this.visibility,
  });

  factory FunnelChartDataLabelOptions.fromJson(Map<String, dynamic> json) {
    return FunnelChartDataLabelOptions(
      categoryLabelVisibility:
          (json['CategoryLabelVisibility'] as String?)?.toVisibility(),
      labelColor: json['LabelColor'] as String?,
      labelFontConfiguration: json['LabelFontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['LabelFontConfiguration'] as Map<String, dynamic>)
          : null,
      measureDataLabelStyle: (json['MeasureDataLabelStyle'] as String?)
          ?.toFunnelChartMeasureDataLabelStyle(),
      measureLabelVisibility:
          (json['MeasureLabelVisibility'] as String?)?.toVisibility(),
      position: (json['Position'] as String?)?.toDataLabelPosition(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryLabelVisibility = this.categoryLabelVisibility;
    final labelColor = this.labelColor;
    final labelFontConfiguration = this.labelFontConfiguration;
    final measureDataLabelStyle = this.measureDataLabelStyle;
    final measureLabelVisibility = this.measureLabelVisibility;
    final position = this.position;
    final visibility = this.visibility;
    return {
      if (categoryLabelVisibility != null)
        'CategoryLabelVisibility': categoryLabelVisibility.toValue(),
      if (labelColor != null) 'LabelColor': labelColor,
      if (labelFontConfiguration != null)
        'LabelFontConfiguration': labelFontConfiguration,
      if (measureDataLabelStyle != null)
        'MeasureDataLabelStyle': measureDataLabelStyle.toValue(),
      if (measureLabelVisibility != null)
        'MeasureLabelVisibility': measureLabelVisibility.toValue(),
      if (position != null) 'Position': position.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The field well configuration of a <code>FunnelChartVisual</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class FunnelChartFieldWells {
  /// The field well configuration of a <code>FunnelChartVisual</code>.
  final FunnelChartAggregatedFieldWells? funnelChartAggregatedFieldWells;

  FunnelChartFieldWells({
    this.funnelChartAggregatedFieldWells,
  });

  factory FunnelChartFieldWells.fromJson(Map<String, dynamic> json) {
    return FunnelChartFieldWells(
      funnelChartAggregatedFieldWells:
          json['FunnelChartAggregatedFieldWells'] != null
              ? FunnelChartAggregatedFieldWells.fromJson(
                  json['FunnelChartAggregatedFieldWells']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final funnelChartAggregatedFieldWells =
        this.funnelChartAggregatedFieldWells;
    return {
      if (funnelChartAggregatedFieldWells != null)
        'FunnelChartAggregatedFieldWells': funnelChartAggregatedFieldWells,
    };
  }
}

enum FunnelChartMeasureDataLabelStyle {
  valueOnly,
  percentageByFirstStage,
  percentageByPreviousStage,
  valueAndPercentageByFirstStage,
  valueAndPercentageByPreviousStage,
}

extension FunnelChartMeasureDataLabelStyleValueExtension
    on FunnelChartMeasureDataLabelStyle {
  String toValue() {
    switch (this) {
      case FunnelChartMeasureDataLabelStyle.valueOnly:
        return 'VALUE_ONLY';
      case FunnelChartMeasureDataLabelStyle.percentageByFirstStage:
        return 'PERCENTAGE_BY_FIRST_STAGE';
      case FunnelChartMeasureDataLabelStyle.percentageByPreviousStage:
        return 'PERCENTAGE_BY_PREVIOUS_STAGE';
      case FunnelChartMeasureDataLabelStyle.valueAndPercentageByFirstStage:
        return 'VALUE_AND_PERCENTAGE_BY_FIRST_STAGE';
      case FunnelChartMeasureDataLabelStyle.valueAndPercentageByPreviousStage:
        return 'VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE';
    }
  }
}

extension FunnelChartMeasureDataLabelStyleFromString on String {
  FunnelChartMeasureDataLabelStyle toFunnelChartMeasureDataLabelStyle() {
    switch (this) {
      case 'VALUE_ONLY':
        return FunnelChartMeasureDataLabelStyle.valueOnly;
      case 'PERCENTAGE_BY_FIRST_STAGE':
        return FunnelChartMeasureDataLabelStyle.percentageByFirstStage;
      case 'PERCENTAGE_BY_PREVIOUS_STAGE':
        return FunnelChartMeasureDataLabelStyle.percentageByPreviousStage;
      case 'VALUE_AND_PERCENTAGE_BY_FIRST_STAGE':
        return FunnelChartMeasureDataLabelStyle.valueAndPercentageByFirstStage;
      case 'VALUE_AND_PERCENTAGE_BY_PREVIOUS_STAGE':
        return FunnelChartMeasureDataLabelStyle
            .valueAndPercentageByPreviousStage;
    }
    throw Exception(
        '$this is not known in enum FunnelChartMeasureDataLabelStyle');
  }
}

/// The sort configuration of a <code>FunnelChartVisual</code>.
class FunnelChartSortConfiguration {
  /// The limit on the number of categories displayed.
  final ItemsLimitConfiguration? categoryItemsLimit;

  /// The sort configuration of the category fields.
  final List<FieldSortOptions>? categorySort;

  FunnelChartSortConfiguration({
    this.categoryItemsLimit,
    this.categorySort,
  });

  factory FunnelChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return FunnelChartSortConfiguration(
      categoryItemsLimit: json['CategoryItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['CategoryItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimit = this.categoryItemsLimit;
    final categorySort = this.categorySort;
    return {
      if (categoryItemsLimit != null) 'CategoryItemsLimit': categoryItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
    };
  }
}

/// A funnel chart.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using
/// funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.
class FunnelChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a <code>FunnelChartVisual</code>.
  final FunnelChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  FunnelChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory FunnelChartVisual.fromJson(Map<String, dynamic> json) {
    return FunnelChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? FunnelChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The options that determine the presentation of the arc of a
/// <code>GaugeChartVisual</code>.
class GaugeChartArcConditionalFormatting {
  /// The conditional formatting of the arc foreground color.
  final ConditionalFormattingColor? foregroundColor;

  GaugeChartArcConditionalFormatting({
    this.foregroundColor,
  });

  factory GaugeChartArcConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return GaugeChartArcConditionalFormatting(
      foregroundColor: json['ForegroundColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['ForegroundColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final foregroundColor = this.foregroundColor;
    return {
      if (foregroundColor != null) 'ForegroundColor': foregroundColor,
    };
  }
}

/// The color configuration of a <code>GaugeChartVisual</code>.
class GaugeChartColorConfiguration {
  /// The background color configuration of a <code>GaugeChartVisual</code>.
  final String? backgroundColor;

  /// The foreground color configuration of a <code>GaugeChartVisual</code>.
  final String? foregroundColor;

  GaugeChartColorConfiguration({
    this.backgroundColor,
    this.foregroundColor,
  });

  factory GaugeChartColorConfiguration.fromJson(Map<String, dynamic> json) {
    return GaugeChartColorConfiguration(
      backgroundColor: json['BackgroundColor'] as String?,
      foregroundColor: json['ForegroundColor'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final backgroundColor = this.backgroundColor;
    final foregroundColor = this.foregroundColor;
    return {
      if (backgroundColor != null) 'BackgroundColor': backgroundColor,
      if (foregroundColor != null) 'ForegroundColor': foregroundColor,
    };
  }
}

/// The conditional formatting of a <code>GaugeChartVisual</code>.
class GaugeChartConditionalFormatting {
  /// Conditional formatting options of a <code>GaugeChartVisual</code>.
  final List<GaugeChartConditionalFormattingOption>?
      conditionalFormattingOptions;

  GaugeChartConditionalFormatting({
    this.conditionalFormattingOptions,
  });

  factory GaugeChartConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return GaugeChartConditionalFormatting(
      conditionalFormattingOptions:
          (json['ConditionalFormattingOptions'] as List?)
              ?.whereNotNull()
              .map((e) => GaugeChartConditionalFormattingOption.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final conditionalFormattingOptions = this.conditionalFormattingOptions;
    return {
      if (conditionalFormattingOptions != null)
        'ConditionalFormattingOptions': conditionalFormattingOptions,
    };
  }
}

/// Conditional formatting options of a <code>GaugeChartVisual</code>.
class GaugeChartConditionalFormattingOption {
  /// The options that determine the presentation of the arc of a
  /// <code>GaugeChartVisual</code>.
  final GaugeChartArcConditionalFormatting? arc;

  /// The conditional formatting for the primary value of a
  /// <code>GaugeChartVisual</code>.
  final GaugeChartPrimaryValueConditionalFormatting? primaryValue;

  GaugeChartConditionalFormattingOption({
    this.arc,
    this.primaryValue,
  });

  factory GaugeChartConditionalFormattingOption.fromJson(
      Map<String, dynamic> json) {
    return GaugeChartConditionalFormattingOption(
      arc: json['Arc'] != null
          ? GaugeChartArcConditionalFormatting.fromJson(
              json['Arc'] as Map<String, dynamic>)
          : null,
      primaryValue: json['PrimaryValue'] != null
          ? GaugeChartPrimaryValueConditionalFormatting.fromJson(
              json['PrimaryValue'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arc = this.arc;
    final primaryValue = this.primaryValue;
    return {
      if (arc != null) 'Arc': arc,
      if (primaryValue != null) 'PrimaryValue': primaryValue,
    };
  }
}

/// The configuration of a <code>GaugeChartVisual</code>.
class GaugeChartConfiguration {
  /// The color configuration of a <code>GaugeChartVisual</code>.
  final GaugeChartColorConfiguration? colorConfiguration;

  /// The data label configuration of a <code>GaugeChartVisual</code>.
  final DataLabelOptions? dataLabels;

  /// The field well configuration of a <code>GaugeChartVisual</code>.
  final GaugeChartFieldWells? fieldWells;

  /// The options that determine the presentation of the
  /// <code>GaugeChartVisual</code>.
  final GaugeChartOptions? gaugeChartOptions;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The tooltip configuration of a <code>GaugeChartVisual</code>.
  final TooltipOptions? tooltipOptions;

  /// The visual palette configuration of a <code>GaugeChartVisual</code>.
  final VisualPalette? visualPalette;

  GaugeChartConfiguration({
    this.colorConfiguration,
    this.dataLabels,
    this.fieldWells,
    this.gaugeChartOptions,
    this.interactions,
    this.tooltipOptions,
    this.visualPalette,
  });

  factory GaugeChartConfiguration.fromJson(Map<String, dynamic> json) {
    return GaugeChartConfiguration(
      colorConfiguration: json['ColorConfiguration'] != null
          ? GaugeChartColorConfiguration.fromJson(
              json['ColorConfiguration'] as Map<String, dynamic>)
          : null,
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? GaugeChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      gaugeChartOptions: json['GaugeChartOptions'] != null
          ? GaugeChartOptions.fromJson(
              json['GaugeChartOptions'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      tooltipOptions: json['TooltipOptions'] != null
          ? TooltipOptions.fromJson(
              json['TooltipOptions'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final colorConfiguration = this.colorConfiguration;
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final gaugeChartOptions = this.gaugeChartOptions;
    final interactions = this.interactions;
    final tooltipOptions = this.tooltipOptions;
    final visualPalette = this.visualPalette;
    return {
      if (colorConfiguration != null) 'ColorConfiguration': colorConfiguration,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (gaugeChartOptions != null) 'GaugeChartOptions': gaugeChartOptions,
      if (interactions != null) 'Interactions': interactions,
      if (tooltipOptions != null) 'TooltipOptions': tooltipOptions,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The field well configuration of a <code>GaugeChartVisual</code>.
class GaugeChartFieldWells {
  /// The target value field wells of a <code>GaugeChartVisual</code>.
  final List<MeasureField>? targetValues;

  /// The value field wells of a <code>GaugeChartVisual</code>.
  final List<MeasureField>? values;

  GaugeChartFieldWells({
    this.targetValues,
    this.values,
  });

  factory GaugeChartFieldWells.fromJson(Map<String, dynamic> json) {
    return GaugeChartFieldWells(
      targetValues: (json['TargetValues'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final targetValues = this.targetValues;
    final values = this.values;
    return {
      if (targetValues != null) 'TargetValues': targetValues,
      if (values != null) 'Values': values,
    };
  }
}

/// The options that determine the presentation of the
/// <code>GaugeChartVisual</code>.
class GaugeChartOptions {
  /// The arc configuration of a <code>GaugeChartVisual</code>.
  final ArcConfiguration? arc;

  /// The arc axis configuration of a <code>GaugeChartVisual</code>.
  final ArcAxisConfiguration? arcAxis;

  /// The comparison configuration of a <code>GaugeChartVisual</code>.
  final ComparisonConfiguration? comparison;

  /// The options that determine the primary value display type.
  final PrimaryValueDisplayType? primaryValueDisplayType;

  /// The options that determine the primary value font configuration.
  final FontConfiguration? primaryValueFontConfiguration;

  GaugeChartOptions({
    this.arc,
    this.arcAxis,
    this.comparison,
    this.primaryValueDisplayType,
    this.primaryValueFontConfiguration,
  });

  factory GaugeChartOptions.fromJson(Map<String, dynamic> json) {
    return GaugeChartOptions(
      arc: json['Arc'] != null
          ? ArcConfiguration.fromJson(json['Arc'] as Map<String, dynamic>)
          : null,
      arcAxis: json['ArcAxis'] != null
          ? ArcAxisConfiguration.fromJson(
              json['ArcAxis'] as Map<String, dynamic>)
          : null,
      comparison: json['Comparison'] != null
          ? ComparisonConfiguration.fromJson(
              json['Comparison'] as Map<String, dynamic>)
          : null,
      primaryValueDisplayType: (json['PrimaryValueDisplayType'] as String?)
          ?.toPrimaryValueDisplayType(),
      primaryValueFontConfiguration:
          json['PrimaryValueFontConfiguration'] != null
              ? FontConfiguration.fromJson(
                  json['PrimaryValueFontConfiguration'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arc = this.arc;
    final arcAxis = this.arcAxis;
    final comparison = this.comparison;
    final primaryValueDisplayType = this.primaryValueDisplayType;
    final primaryValueFontConfiguration = this.primaryValueFontConfiguration;
    return {
      if (arc != null) 'Arc': arc,
      if (arcAxis != null) 'ArcAxis': arcAxis,
      if (comparison != null) 'Comparison': comparison,
      if (primaryValueDisplayType != null)
        'PrimaryValueDisplayType': primaryValueDisplayType.toValue(),
      if (primaryValueFontConfiguration != null)
        'PrimaryValueFontConfiguration': primaryValueFontConfiguration,
    };
  }
}

/// The conditional formatting for the primary value of a
/// <code>GaugeChartVisual</code>.
class GaugeChartPrimaryValueConditionalFormatting {
  /// The conditional formatting of the primary value icon.
  final ConditionalFormattingIcon? icon;

  /// The conditional formatting of the primary value text color.
  final ConditionalFormattingColor? textColor;

  GaugeChartPrimaryValueConditionalFormatting({
    this.icon,
    this.textColor,
  });

  factory GaugeChartPrimaryValueConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return GaugeChartPrimaryValueConditionalFormatting(
      icon: json['Icon'] != null
          ? ConditionalFormattingIcon.fromJson(
              json['Icon'] as Map<String, dynamic>)
          : null,
      textColor: json['TextColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['TextColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final icon = this.icon;
    final textColor = this.textColor;
    return {
      if (icon != null) 'Icon': icon,
      if (textColor != null) 'TextColor': textColor,
    };
  }
}

/// A gauge chart.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using
/// gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.
class GaugeChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a <code>GaugeChartVisual</code>.
  final GaugeChartConfiguration? chartConfiguration;

  /// The conditional formatting of a <code>GaugeChartVisual</code>.
  final GaugeChartConditionalFormatting? conditionalFormatting;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  GaugeChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.conditionalFormatting,
    this.subtitle,
    this.title,
  });

  factory GaugeChartVisual.fromJson(Map<String, dynamic> json) {
    return GaugeChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? GaugeChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      conditionalFormatting: json['ConditionalFormatting'] != null
          ? GaugeChartConditionalFormatting.fromJson(
              json['ConditionalFormatting'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final conditionalFormatting = this.conditionalFormatting;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (conditionalFormatting != null)
        'ConditionalFormatting': conditionalFormatting,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

class GenerateEmbedUrlForAnonymousUserResponse {
  /// The Amazon Resource Name (ARN) to use for the anonymous Amazon QuickSight
  /// user.
  final String anonymousUserArn;

  /// The embed URL for the dashboard.
  final String embedUrl;

  /// The Amazon Web Services request ID for this operation.
  final String requestId;

  /// The HTTP status of the request.
  final int status;

  GenerateEmbedUrlForAnonymousUserResponse({
    required this.anonymousUserArn,
    required this.embedUrl,
    required this.requestId,
    required this.status,
  });

  factory GenerateEmbedUrlForAnonymousUserResponse.fromJson(
      Map<String, dynamic> json) {
    return GenerateEmbedUrlForAnonymousUserResponse(
      anonymousUserArn: json['AnonymousUserArn'] as String,
      embedUrl: json['EmbedUrl'] as String,
      requestId: json['RequestId'] as String,
      status: json['Status'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final anonymousUserArn = this.anonymousUserArn;
    final embedUrl = this.embedUrl;
    final requestId = this.requestId;
    final status = this.status;
    return {
      'AnonymousUserArn': anonymousUserArn,
      'EmbedUrl': embedUrl,
      'RequestId': requestId,
    };
  }
}

class GenerateEmbedUrlForRegisteredUserResponse {
  /// The embed URL for the Amazon QuickSight dashboard, visual, Q search bar,
  /// Generative Q&amp;A experience, or console.
  final String embedUrl;

  /// The Amazon Web Services request ID for this operation.
  final String requestId;

  /// The HTTP status of the request.
  final int status;

  GenerateEmbedUrlForRegisteredUserResponse({
    required this.embedUrl,
    required this.requestId,
    required this.status,
  });

  factory GenerateEmbedUrlForRegisteredUserResponse.fromJson(
      Map<String, dynamic> json) {
    return GenerateEmbedUrlForRegisteredUserResponse(
      embedUrl: json['EmbedUrl'] as String,
      requestId: json['RequestId'] as String,
      status: json['Status'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final embedUrl = this.embedUrl;
    final requestId = this.requestId;
    final status = this.status;
    return {
      'EmbedUrl': embedUrl,
      'RequestId': requestId,
    };
  }
}

/// Geospatial column group that denotes a hierarchy.
class GeoSpatialColumnGroup {
  /// Columns in this hierarchy.
  final List<String> columns;

  /// A display name for the hierarchy.
  final String name;

  /// Country code.
  final GeoSpatialCountryCode? countryCode;

  GeoSpatialColumnGroup({
    required this.columns,
    required this.name,
    this.countryCode,
  });

  factory GeoSpatialColumnGroup.fromJson(Map<String, dynamic> json) {
    return GeoSpatialColumnGroup(
      columns: (json['Columns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      name: json['Name'] as String,
      countryCode: (json['CountryCode'] as String?)?.toGeoSpatialCountryCode(),
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    final name = this.name;
    final countryCode = this.countryCode;
    return {
      'Columns': columns,
      'Name': name,
      if (countryCode != null) 'CountryCode': countryCode.toValue(),
    };
  }
}

enum GeoSpatialCountryCode {
  us,
}

extension GeoSpatialCountryCodeValueExtension on GeoSpatialCountryCode {
  String toValue() {
    switch (this) {
      case GeoSpatialCountryCode.us:
        return 'US';
    }
  }
}

extension GeoSpatialCountryCodeFromString on String {
  GeoSpatialCountryCode toGeoSpatialCountryCode() {
    switch (this) {
      case 'US':
        return GeoSpatialCountryCode.us;
    }
    throw Exception('$this is not known in enum GeoSpatialCountryCode');
  }
}

enum GeoSpatialDataRole {
  country,
  state,
  county,
  city,
  postcode,
  longitude,
  latitude,
}

extension GeoSpatialDataRoleValueExtension on GeoSpatialDataRole {
  String toValue() {
    switch (this) {
      case GeoSpatialDataRole.country:
        return 'COUNTRY';
      case GeoSpatialDataRole.state:
        return 'STATE';
      case GeoSpatialDataRole.county:
        return 'COUNTY';
      case GeoSpatialDataRole.city:
        return 'CITY';
      case GeoSpatialDataRole.postcode:
        return 'POSTCODE';
      case GeoSpatialDataRole.longitude:
        return 'LONGITUDE';
      case GeoSpatialDataRole.latitude:
        return 'LATITUDE';
    }
  }
}

extension GeoSpatialDataRoleFromString on String {
  GeoSpatialDataRole toGeoSpatialDataRole() {
    switch (this) {
      case 'COUNTRY':
        return GeoSpatialDataRole.country;
      case 'STATE':
        return GeoSpatialDataRole.state;
      case 'COUNTY':
        return GeoSpatialDataRole.county;
      case 'CITY':
        return GeoSpatialDataRole.city;
      case 'POSTCODE':
        return GeoSpatialDataRole.postcode;
      case 'LONGITUDE':
        return GeoSpatialDataRole.longitude;
      case 'LATITUDE':
        return GeoSpatialDataRole.latitude;
    }
    throw Exception('$this is not known in enum GeoSpatialDataRole');
  }
}

/// The bound options (north, south, west, east) of the geospatial window
/// options.
class GeospatialCoordinateBounds {
  /// The longitude of the east bound of the geospatial coordinate bounds.
  final double east;

  /// The latitude of the north bound of the geospatial coordinate bounds.
  final double north;

  /// The latitude of the south bound of the geospatial coordinate bounds.
  final double south;

  /// The longitude of the west bound of the geospatial coordinate bounds.
  final double west;

  GeospatialCoordinateBounds({
    required this.east,
    required this.north,
    required this.south,
    required this.west,
  });

  factory GeospatialCoordinateBounds.fromJson(Map<String, dynamic> json) {
    return GeospatialCoordinateBounds(
      east: json['East'] as double,
      north: json['North'] as double,
      south: json['South'] as double,
      west: json['West'] as double,
    );
  }

  Map<String, dynamic> toJson() {
    final east = this.east;
    final north = this.north;
    final south = this.south;
    final west = this.west;
    return {
      'East': east,
      'North': north,
      'South': south,
      'West': west,
    };
  }
}

/// The color scale specification for the heatmap point style.
class GeospatialHeatmapColorScale {
  /// The list of colors to be used in heatmap point style.
  final List<GeospatialHeatmapDataColor>? colors;

  GeospatialHeatmapColorScale({
    this.colors,
  });

  factory GeospatialHeatmapColorScale.fromJson(Map<String, dynamic> json) {
    return GeospatialHeatmapColorScale(
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) =>
              GeospatialHeatmapDataColor.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final colors = this.colors;
    return {
      if (colors != null) 'Colors': colors,
    };
  }
}

/// The heatmap configuration of the geospatial point style.
class GeospatialHeatmapConfiguration {
  /// The color scale specification for the heatmap point style.
  final GeospatialHeatmapColorScale? heatmapColor;

  GeospatialHeatmapConfiguration({
    this.heatmapColor,
  });

  factory GeospatialHeatmapConfiguration.fromJson(Map<String, dynamic> json) {
    return GeospatialHeatmapConfiguration(
      heatmapColor: json['HeatmapColor'] != null
          ? GeospatialHeatmapColorScale.fromJson(
              json['HeatmapColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final heatmapColor = this.heatmapColor;
    return {
      if (heatmapColor != null) 'HeatmapColor': heatmapColor,
    };
  }
}

/// The color to be used in the heatmap point style.
class GeospatialHeatmapDataColor {
  /// The hex color to be used in the heatmap point style.
  final String color;

  GeospatialHeatmapDataColor({
    required this.color,
  });

  factory GeospatialHeatmapDataColor.fromJson(Map<String, dynamic> json) {
    return GeospatialHeatmapDataColor(
      color: json['Color'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    return {
      'Color': color,
    };
  }
}

/// The aggregated field wells for a geospatial map.
class GeospatialMapAggregatedFieldWells {
  /// The color field wells of a geospatial map.
  final List<DimensionField>? colors;

  /// The geospatial field wells of a geospatial map. Values are grouped by
  /// geospatial fields.
  final List<DimensionField>? geospatial;

  /// The size field wells of a geospatial map. Values are aggregated based on
  /// geospatial fields.
  final List<MeasureField>? values;

  GeospatialMapAggregatedFieldWells({
    this.colors,
    this.geospatial,
    this.values,
  });

  factory GeospatialMapAggregatedFieldWells.fromJson(
      Map<String, dynamic> json) {
    return GeospatialMapAggregatedFieldWells(
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      geospatial: (json['Geospatial'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final colors = this.colors;
    final geospatial = this.geospatial;
    final values = this.values;
    return {
      if (colors != null) 'Colors': colors,
      if (geospatial != null) 'Geospatial': geospatial,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a <code>GeospatialMapVisual</code>.
class GeospatialMapConfiguration {
  /// The field wells of the visual.
  final GeospatialMapFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The map style options of the geospatial map.
  final GeospatialMapStyleOptions? mapStyleOptions;

  /// The point style options of the geospatial map.
  final GeospatialPointStyleOptions? pointStyleOptions;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;
  final VisualPalette? visualPalette;

  /// The window options of the geospatial map.
  final GeospatialWindowOptions? windowOptions;

  GeospatialMapConfiguration({
    this.fieldWells,
    this.interactions,
    this.legend,
    this.mapStyleOptions,
    this.pointStyleOptions,
    this.tooltip,
    this.visualPalette,
    this.windowOptions,
  });

  factory GeospatialMapConfiguration.fromJson(Map<String, dynamic> json) {
    return GeospatialMapConfiguration(
      fieldWells: json['FieldWells'] != null
          ? GeospatialMapFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      mapStyleOptions: json['MapStyleOptions'] != null
          ? GeospatialMapStyleOptions.fromJson(
              json['MapStyleOptions'] as Map<String, dynamic>)
          : null,
      pointStyleOptions: json['PointStyleOptions'] != null
          ? GeospatialPointStyleOptions.fromJson(
              json['PointStyleOptions'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
      windowOptions: json['WindowOptions'] != null
          ? GeospatialWindowOptions.fromJson(
              json['WindowOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final mapStyleOptions = this.mapStyleOptions;
    final pointStyleOptions = this.pointStyleOptions;
    final tooltip = this.tooltip;
    final visualPalette = this.visualPalette;
    final windowOptions = this.windowOptions;
    return {
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (mapStyleOptions != null) 'MapStyleOptions': mapStyleOptions,
      if (pointStyleOptions != null) 'PointStyleOptions': pointStyleOptions,
      if (tooltip != null) 'Tooltip': tooltip,
      if (visualPalette != null) 'VisualPalette': visualPalette,
      if (windowOptions != null) 'WindowOptions': windowOptions,
    };
  }
}

/// The field wells of a <code>GeospatialMapVisual</code>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class GeospatialMapFieldWells {
  /// The aggregated field well for a geospatial map.
  final GeospatialMapAggregatedFieldWells? geospatialMapAggregatedFieldWells;

  GeospatialMapFieldWells({
    this.geospatialMapAggregatedFieldWells,
  });

  factory GeospatialMapFieldWells.fromJson(Map<String, dynamic> json) {
    return GeospatialMapFieldWells(
      geospatialMapAggregatedFieldWells:
          json['GeospatialMapAggregatedFieldWells'] != null
              ? GeospatialMapAggregatedFieldWells.fromJson(
                  json['GeospatialMapAggregatedFieldWells']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final geospatialMapAggregatedFieldWells =
        this.geospatialMapAggregatedFieldWells;
    return {
      if (geospatialMapAggregatedFieldWells != null)
        'GeospatialMapAggregatedFieldWells': geospatialMapAggregatedFieldWells,
    };
  }
}

/// The map style options of the geospatial map.
class GeospatialMapStyleOptions {
  /// The base map style of the geospatial map.
  final BaseMapStyleType? baseMapStyle;

  GeospatialMapStyleOptions({
    this.baseMapStyle,
  });

  factory GeospatialMapStyleOptions.fromJson(Map<String, dynamic> json) {
    return GeospatialMapStyleOptions(
      baseMapStyle: (json['BaseMapStyle'] as String?)?.toBaseMapStyleType(),
    );
  }

  Map<String, dynamic> toJson() {
    final baseMapStyle = this.baseMapStyle;
    return {
      if (baseMapStyle != null) 'BaseMapStyle': baseMapStyle.toValue(),
    };
  }
}

/// A geospatial map or a points on map visual.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating
/// point maps</a> in the <i>Amazon QuickSight User Guide</i>.
class GeospatialMapVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final GeospatialMapConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  GeospatialMapVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory GeospatialMapVisual.fromJson(Map<String, dynamic> json) {
    return GeospatialMapVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? GeospatialMapConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The point style of the geospatial map.
class GeospatialPointStyleOptions {
  /// The cluster marker configuration of the geospatial point style.
  final ClusterMarkerConfiguration? clusterMarkerConfiguration;

  /// The heatmap configuration of the geospatial point style.
  final GeospatialHeatmapConfiguration? heatmapConfiguration;

  /// The selected point styles (point, cluster) of the geospatial map.
  final GeospatialSelectedPointStyle? selectedPointStyle;

  GeospatialPointStyleOptions({
    this.clusterMarkerConfiguration,
    this.heatmapConfiguration,
    this.selectedPointStyle,
  });

  factory GeospatialPointStyleOptions.fromJson(Map<String, dynamic> json) {
    return GeospatialPointStyleOptions(
      clusterMarkerConfiguration: json['ClusterMarkerConfiguration'] != null
          ? ClusterMarkerConfiguration.fromJson(
              json['ClusterMarkerConfiguration'] as Map<String, dynamic>)
          : null,
      heatmapConfiguration: json['HeatmapConfiguration'] != null
          ? GeospatialHeatmapConfiguration.fromJson(
              json['HeatmapConfiguration'] as Map<String, dynamic>)
          : null,
      selectedPointStyle: (json['SelectedPointStyle'] as String?)
          ?.toGeospatialSelectedPointStyle(),
    );
  }

  Map<String, dynamic> toJson() {
    final clusterMarkerConfiguration = this.clusterMarkerConfiguration;
    final heatmapConfiguration = this.heatmapConfiguration;
    final selectedPointStyle = this.selectedPointStyle;
    return {
      if (clusterMarkerConfiguration != null)
        'ClusterMarkerConfiguration': clusterMarkerConfiguration,
      if (heatmapConfiguration != null)
        'HeatmapConfiguration': heatmapConfiguration,
      if (selectedPointStyle != null)
        'SelectedPointStyle': selectedPointStyle.toValue(),
    };
  }
}

enum GeospatialSelectedPointStyle {
  point,
  cluster,
  heatmap,
}

extension GeospatialSelectedPointStyleValueExtension
    on GeospatialSelectedPointStyle {
  String toValue() {
    switch (this) {
      case GeospatialSelectedPointStyle.point:
        return 'POINT';
      case GeospatialSelectedPointStyle.cluster:
        return 'CLUSTER';
      case GeospatialSelectedPointStyle.heatmap:
        return 'HEATMAP';
    }
  }
}

extension GeospatialSelectedPointStyleFromString on String {
  GeospatialSelectedPointStyle toGeospatialSelectedPointStyle() {
    switch (this) {
      case 'POINT':
        return GeospatialSelectedPointStyle.point;
      case 'CLUSTER':
        return GeospatialSelectedPointStyle.cluster;
      case 'HEATMAP':
        return GeospatialSelectedPointStyle.heatmap;
    }
    throw Exception('$this is not known in enum GeospatialSelectedPointStyle');
  }
}

/// The window options of the geospatial map visual.
class GeospatialWindowOptions {
  /// The bounds options (north, south, west, east) of the geospatial window
  /// options.
  final GeospatialCoordinateBounds? bounds;

  /// The map zoom modes (manual, auto) of the geospatial window options.
  final MapZoomMode? mapZoomMode;

  GeospatialWindowOptions({
    this.bounds,
    this.mapZoomMode,
  });

  factory GeospatialWindowOptions.fromJson(Map<String, dynamic> json) {
    return GeospatialWindowOptions(
      bounds: json['Bounds'] != null
          ? GeospatialCoordinateBounds.fromJson(
              json['Bounds'] as Map<String, dynamic>)
          : null,
      mapZoomMode: (json['MapZoomMode'] as String?)?.toMapZoomMode(),
    );
  }

  Map<String, dynamic> toJson() {
    final bounds = this.bounds;
    final mapZoomMode = this.mapZoomMode;
    return {
      if (bounds != null) 'Bounds': bounds,
      if (mapZoomMode != null) 'MapZoomMode': mapZoomMode.toValue(),
    };
  }
}

/// Output returned from the <code>GetDashboardEmbedUrl</code> operation.
class GetDashboardEmbedUrlResponse {
  /// A single-use URL that you can put into your server-side webpage to embed
  /// your dashboard. This URL is valid for 5 minutes. The API operation provides
  /// the URL with an <code>auth_code</code> value that enables one (and only one)
  /// sign-on to a user session that is valid for 10 hours.
  final String? embedUrl;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  GetDashboardEmbedUrlResponse({
    this.embedUrl,
    this.requestId,
    this.status,
  });

  factory GetDashboardEmbedUrlResponse.fromJson(Map<String, dynamic> json) {
    return GetDashboardEmbedUrlResponse(
      embedUrl: json['EmbedUrl'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final embedUrl = this.embedUrl;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (embedUrl != null) 'EmbedUrl': embedUrl,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class GetSessionEmbedUrlResponse {
  /// A single-use URL that you can put into your server-side web page to embed
  /// your Amazon QuickSight session. This URL is valid for 5 minutes. The API
  /// operation provides the URL with an <code>auth_code</code> value that enables
  /// one (and only one) sign-on to a user session that is valid for 10 hours.
  final String? embedUrl;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  GetSessionEmbedUrlResponse({
    this.embedUrl,
    this.requestId,
    this.status,
  });

  factory GetSessionEmbedUrlResponse.fromJson(Map<String, dynamic> json) {
    return GetSessionEmbedUrlResponse(
      embedUrl: json['EmbedUrl'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final embedUrl = this.embedUrl;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (embedUrl != null) 'EmbedUrl': embedUrl,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// Determines the border options for a table visual.
class GlobalTableBorderOptions {
  /// Determines the options for side specific border.
  final TableSideBorderOptions? sideSpecificBorder;

  /// Determines the options for uniform border.
  final TableBorderOptions? uniformBorder;

  GlobalTableBorderOptions({
    this.sideSpecificBorder,
    this.uniformBorder,
  });

  factory GlobalTableBorderOptions.fromJson(Map<String, dynamic> json) {
    return GlobalTableBorderOptions(
      sideSpecificBorder: json['SideSpecificBorder'] != null
          ? TableSideBorderOptions.fromJson(
              json['SideSpecificBorder'] as Map<String, dynamic>)
          : null,
      uniformBorder: json['UniformBorder'] != null
          ? TableBorderOptions.fromJson(
              json['UniformBorder'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sideSpecificBorder = this.sideSpecificBorder;
    final uniformBorder = this.uniformBorder;
    return {
      if (sideSpecificBorder != null) 'SideSpecificBorder': sideSpecificBorder,
      if (uniformBorder != null) 'UniformBorder': uniformBorder,
    };
  }
}

/// Determines the gradient color settings.
class GradientColor {
  /// The list of gradient color stops.
  final List<GradientStop>? stops;

  GradientColor({
    this.stops,
  });

  factory GradientColor.fromJson(Map<String, dynamic> json) {
    return GradientColor(
      stops: (json['Stops'] as List?)
          ?.whereNotNull()
          .map((e) => GradientStop.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final stops = this.stops;
    return {
      if (stops != null) 'Stops': stops,
    };
  }
}

/// Determines the gradient stop configuration.
class GradientStop {
  /// Determines gradient offset value.
  final double gradientOffset;

  /// Determines the color.
  final String? color;

  /// Determines the data value.
  final double? dataValue;

  GradientStop({
    required this.gradientOffset,
    this.color,
    this.dataValue,
  });

  factory GradientStop.fromJson(Map<String, dynamic> json) {
    return GradientStop(
      gradientOffset: json['GradientOffset'] as double,
      color: json['Color'] as String?,
      dataValue: json['DataValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final gradientOffset = this.gradientOffset;
    final color = this.color;
    final dataValue = this.dataValue;
    return {
      'GradientOffset': gradientOffset,
      if (color != null) 'Color': color,
      if (dataValue != null) 'DataValue': dataValue,
    };
  }
}

/// Configuration options for the canvas of a grid layout.
class GridLayoutCanvasSizeOptions {
  /// The options that determine the sizing of the canvas used in a grid layout.
  final GridLayoutScreenCanvasSizeOptions? screenCanvasSizeOptions;

  GridLayoutCanvasSizeOptions({
    this.screenCanvasSizeOptions,
  });

  factory GridLayoutCanvasSizeOptions.fromJson(Map<String, dynamic> json) {
    return GridLayoutCanvasSizeOptions(
      screenCanvasSizeOptions: json['ScreenCanvasSizeOptions'] != null
          ? GridLayoutScreenCanvasSizeOptions.fromJson(
              json['ScreenCanvasSizeOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final screenCanvasSizeOptions = this.screenCanvasSizeOptions;
    return {
      if (screenCanvasSizeOptions != null)
        'ScreenCanvasSizeOptions': screenCanvasSizeOptions,
    };
  }
}

/// The configuration for a grid layout. Also called a tiled layout.
///
/// Visuals snap to a grid with standard spacing and alignment. Dashboards are
/// displayed as designed, with options to fit to screen or view at actual size.
class GridLayoutConfiguration {
  /// The elements that are included in a grid layout.
  final List<GridLayoutElement> elements;
  final GridLayoutCanvasSizeOptions? canvasSizeOptions;

  GridLayoutConfiguration({
    required this.elements,
    this.canvasSizeOptions,
  });

  factory GridLayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return GridLayoutConfiguration(
      elements: (json['Elements'] as List)
          .whereNotNull()
          .map((e) => GridLayoutElement.fromJson(e as Map<String, dynamic>))
          .toList(),
      canvasSizeOptions: json['CanvasSizeOptions'] != null
          ? GridLayoutCanvasSizeOptions.fromJson(
              json['CanvasSizeOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final elements = this.elements;
    final canvasSizeOptions = this.canvasSizeOptions;
    return {
      'Elements': elements,
      if (canvasSizeOptions != null) 'CanvasSizeOptions': canvasSizeOptions,
    };
  }
}

/// An element within a grid layout.
class GridLayoutElement {
  /// The width of a grid element expressed as a number of grid columns.
  final int columnSpan;

  /// A unique identifier for an element within a grid layout.
  final String elementId;

  /// The type of element.
  final LayoutElementType elementType;

  /// The height of a grid element expressed as a number of grid rows.
  final int rowSpan;

  /// The column index for the upper left corner of an element.
  final int? columnIndex;

  /// The row index for the upper left corner of an element.
  final int? rowIndex;

  GridLayoutElement({
    required this.columnSpan,
    required this.elementId,
    required this.elementType,
    required this.rowSpan,
    this.columnIndex,
    this.rowIndex,
  });

  factory GridLayoutElement.fromJson(Map<String, dynamic> json) {
    return GridLayoutElement(
      columnSpan: json['ColumnSpan'] as int,
      elementId: json['ElementId'] as String,
      elementType: (json['ElementType'] as String).toLayoutElementType(),
      rowSpan: json['RowSpan'] as int,
      columnIndex: json['ColumnIndex'] as int?,
      rowIndex: json['RowIndex'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final columnSpan = this.columnSpan;
    final elementId = this.elementId;
    final elementType = this.elementType;
    final rowSpan = this.rowSpan;
    final columnIndex = this.columnIndex;
    final rowIndex = this.rowIndex;
    return {
      'ColumnSpan': columnSpan,
      'ElementId': elementId,
      'ElementType': elementType.toValue(),
      'RowSpan': rowSpan,
      if (columnIndex != null) 'ColumnIndex': columnIndex,
      if (rowIndex != null) 'RowIndex': rowIndex,
    };
  }
}

/// The options that determine the sizing of the canvas used in a grid layout.
class GridLayoutScreenCanvasSizeOptions {
  /// This value determines the layout behavior when the viewport is resized.
  ///
  /// <ul>
  /// <li>
  /// <code>FIXED</code>: A fixed width will be used when optimizing the layout.
  /// In the Amazon QuickSight console, this option is called
  /// <code>Classic</code>.
  /// </li>
  /// <li>
  /// <code>RESPONSIVE</code>: The width of the canvas will be responsive and
  /// optimized to the view port. In the Amazon QuickSight console, this option is
  /// called <code>Tiled</code>.
  /// </li>
  /// </ul>
  final ResizeOption resizeOption;

  /// The width that the view port will be optimized for when the layout renders.
  final String? optimizedViewPortWidth;

  GridLayoutScreenCanvasSizeOptions({
    required this.resizeOption,
    this.optimizedViewPortWidth,
  });

  factory GridLayoutScreenCanvasSizeOptions.fromJson(
      Map<String, dynamic> json) {
    return GridLayoutScreenCanvasSizeOptions(
      resizeOption: (json['ResizeOption'] as String).toResizeOption(),
      optimizedViewPortWidth: json['OptimizedViewPortWidth'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final resizeOption = this.resizeOption;
    final optimizedViewPortWidth = this.optimizedViewPortWidth;
    return {
      'ResizeOption': resizeOption.toValue(),
      if (optimizedViewPortWidth != null)
        'OptimizedViewPortWidth': optimizedViewPortWidth,
    };
  }
}

/// A <i>group</i> in Amazon QuickSight consists of a set of users. You can use
/// groups to make it easier to manage access and security.
class Group {
  /// The Amazon Resource Name (ARN) for the group.
  final String? arn;

  /// The group description.
  final String? description;

  /// The name of the group.
  final String? groupName;

  /// The principal ID of the group.
  final String? principalId;

  Group({
    this.arn,
    this.description,
    this.groupName,
    this.principalId,
  });

  factory Group.fromJson(Map<String, dynamic> json) {
    return Group(
      arn: json['Arn'] as String?,
      description: json['Description'] as String?,
      groupName: json['GroupName'] as String?,
      principalId: json['PrincipalId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final description = this.description;
    final groupName = this.groupName;
    final principalId = this.principalId;
    return {
      if (arn != null) 'Arn': arn,
      if (description != null) 'Description': description,
      if (groupName != null) 'GroupName': groupName,
      if (principalId != null) 'PrincipalId': principalId,
    };
  }
}

enum GroupFilterAttribute {
  groupName,
}

extension GroupFilterAttributeValueExtension on GroupFilterAttribute {
  String toValue() {
    switch (this) {
      case GroupFilterAttribute.groupName:
        return 'GROUP_NAME';
    }
  }
}

extension GroupFilterAttributeFromString on String {
  GroupFilterAttribute toGroupFilterAttribute() {
    switch (this) {
      case 'GROUP_NAME':
        return GroupFilterAttribute.groupName;
    }
    throw Exception('$this is not known in enum GroupFilterAttribute');
  }
}

enum GroupFilterOperator {
  startsWith,
}

extension GroupFilterOperatorValueExtension on GroupFilterOperator {
  String toValue() {
    switch (this) {
      case GroupFilterOperator.startsWith:
        return 'StartsWith';
    }
  }
}

extension GroupFilterOperatorFromString on String {
  GroupFilterOperator toGroupFilterOperator() {
    switch (this) {
      case 'StartsWith':
        return GroupFilterOperator.startsWith;
    }
    throw Exception('$this is not known in enum GroupFilterOperator');
  }
}

/// A member of an Amazon QuickSight group. Currently, group members must be
/// users. Groups can't be members of another group. .
class GroupMember {
  /// The Amazon Resource Name (ARN) for the group member (user).
  final String? arn;

  /// The name of the group member (user).
  final String? memberName;

  GroupMember({
    this.arn,
    this.memberName,
  });

  factory GroupMember.fromJson(Map<String, dynamic> json) {
    return GroupMember(
      arn: json['Arn'] as String?,
      memberName: json['MemberName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final memberName = this.memberName;
    return {
      if (arn != null) 'Arn': arn,
      if (memberName != null) 'MemberName': memberName,
    };
  }
}

/// A <code>GroupSearchFilter</code> object that you want to apply to your
/// search.
class GroupSearchFilter {
  /// The name of the value that you want to use as a filter, for example
  /// <code>"Name": "GROUP_NAME"</code>. Currently, the only supported name is
  /// <code>GROUP_NAME</code>.
  final GroupFilterAttribute name;

  /// The comparison operator that you want to use as a filter, for example
  /// <code>"Operator": "StartsWith"</code>. Currently, the only supported
  /// operator is <code>StartsWith</code>.
  final GroupFilterOperator operator;

  /// The value of the named item, in this case <code>GROUP_NAME</code>, that you
  /// want to use as a filter.
  final String value;

  GroupSearchFilter({
    required this.name,
    required this.operator,
    required this.value,
  });

  Map<String, dynamic> toJson() {
    final name = this.name;
    final operator = this.operator;
    final value = this.value;
    return {
      'Name': name.toValue(),
      'Operator': operator.toValue(),
      'Value': value,
    };
  }
}

/// The growth rate computation configuration.
class GrowthRateComputation {
  /// The ID for a computation.
  final String computationId;

  /// The name of a computation.
  final String? name;

  /// The period size setup of a growth rate computation.
  final int? periodSize;

  /// The time field that is used in a computation.
  final DimensionField? time;

  /// The value field that is used in a computation.
  final MeasureField? value;

  GrowthRateComputation({
    required this.computationId,
    this.name,
    this.periodSize,
    this.time,
    this.value,
  });

  factory GrowthRateComputation.fromJson(Map<String, dynamic> json) {
    return GrowthRateComputation(
      computationId: json['ComputationId'] as String,
      name: json['Name'] as String?,
      periodSize: json['PeriodSize'] as int?,
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final name = this.name;
    final periodSize = this.periodSize;
    final time = this.time;
    final value = this.value;
    return {
      'ComputationId': computationId,
      if (name != null) 'Name': name,
      if (periodSize != null) 'PeriodSize': periodSize,
      if (time != null) 'Time': time,
      if (value != null) 'Value': value,
    };
  }
}

/// The display options for gutter spacing between tiles on a sheet.
class GutterStyle {
  /// This Boolean value controls whether to display a gutter space between sheet
  /// tiles.
  final bool? show;

  GutterStyle({
    this.show,
  });

  factory GutterStyle.fromJson(Map<String, dynamic> json) {
    return GutterStyle(
      show: json['Show'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final show = this.show;
    return {
      if (show != null) 'Show': show,
    };
  }
}

/// The configuration of a header or footer section.
class HeaderFooterSectionConfiguration {
  /// The layout configuration of the header or footer section.
  final SectionLayoutConfiguration layout;

  /// The unique identifier of the header or footer section.
  final String sectionId;

  /// The style options of a header or footer section.
  final SectionStyle? style;

  HeaderFooterSectionConfiguration({
    required this.layout,
    required this.sectionId,
    this.style,
  });

  factory HeaderFooterSectionConfiguration.fromJson(Map<String, dynamic> json) {
    return HeaderFooterSectionConfiguration(
      layout: SectionLayoutConfiguration.fromJson(
          json['Layout'] as Map<String, dynamic>),
      sectionId: json['SectionId'] as String,
      style: json['Style'] != null
          ? SectionStyle.fromJson(json['Style'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final layout = this.layout;
    final sectionId = this.sectionId;
    final style = this.style;
    return {
      'Layout': layout,
      'SectionId': sectionId,
      if (style != null) 'Style': style,
    };
  }
}

/// The aggregated field wells of a heat map.
class HeatMapAggregatedFieldWells {
  /// The columns field well of a heat map.
  final List<DimensionField>? columns;

  /// The rows field well of a heat map.
  final List<DimensionField>? rows;

  /// The values field well of a heat map.
  final List<MeasureField>? values;

  HeatMapAggregatedFieldWells({
    this.columns,
    this.rows,
    this.values,
  });

  factory HeatMapAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return HeatMapAggregatedFieldWells(
      columns: (json['Columns'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      rows: (json['Rows'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    final rows = this.rows;
    final values = this.values;
    return {
      if (columns != null) 'Columns': columns,
      if (rows != null) 'Rows': rows,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a heat map.
class HeatMapConfiguration {
  /// The color options (gradient color, point of divergence) in a heat map.
  final ColorScale? colorScale;

  /// The label options of the column that is displayed in a heat map.
  final ChartAxisLabelOptions? columnLabelOptions;

  /// The options that determine if visual data labels are displayed.
  final DataLabelOptions? dataLabels;

  /// The field wells of the visual.
  final HeatMapFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The label options of the row that is displayed in a <code>heat map</code>.
  final ChartAxisLabelOptions? rowLabelOptions;

  /// The sort configuration of a heat map.
  final HeatMapSortConfiguration? sortConfiguration;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;

  HeatMapConfiguration({
    this.colorScale,
    this.columnLabelOptions,
    this.dataLabels,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.rowLabelOptions,
    this.sortConfiguration,
    this.tooltip,
  });

  factory HeatMapConfiguration.fromJson(Map<String, dynamic> json) {
    return HeatMapConfiguration(
      colorScale: json['ColorScale'] != null
          ? ColorScale.fromJson(json['ColorScale'] as Map<String, dynamic>)
          : null,
      columnLabelOptions: json['ColumnLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ColumnLabelOptions'] as Map<String, dynamic>)
          : null,
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? HeatMapFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      rowLabelOptions: json['RowLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['RowLabelOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? HeatMapSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final colorScale = this.colorScale;
    final columnLabelOptions = this.columnLabelOptions;
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final rowLabelOptions = this.rowLabelOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    return {
      if (colorScale != null) 'ColorScale': colorScale,
      if (columnLabelOptions != null) 'ColumnLabelOptions': columnLabelOptions,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (rowLabelOptions != null) 'RowLabelOptions': rowLabelOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
    };
  }
}

/// The field well configuration of a heat map.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class HeatMapFieldWells {
  /// The aggregated field wells of a heat map.
  final HeatMapAggregatedFieldWells? heatMapAggregatedFieldWells;

  HeatMapFieldWells({
    this.heatMapAggregatedFieldWells,
  });

  factory HeatMapFieldWells.fromJson(Map<String, dynamic> json) {
    return HeatMapFieldWells(
      heatMapAggregatedFieldWells: json['HeatMapAggregatedFieldWells'] != null
          ? HeatMapAggregatedFieldWells.fromJson(
              json['HeatMapAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final heatMapAggregatedFieldWells = this.heatMapAggregatedFieldWells;
    return {
      if (heatMapAggregatedFieldWells != null)
        'HeatMapAggregatedFieldWells': heatMapAggregatedFieldWells,
    };
  }
}

/// The sort configuration of a heat map.
class HeatMapSortConfiguration {
  /// The limit on the number of columns that are displayed in a heat map.
  final ItemsLimitConfiguration? heatMapColumnItemsLimitConfiguration;

  /// The column sort configuration for heat map for columns that aren't a part of
  /// a field well.
  final List<FieldSortOptions>? heatMapColumnSort;

  /// The limit on the number of rows that are displayed in a heat map.
  final ItemsLimitConfiguration? heatMapRowItemsLimitConfiguration;

  /// The field sort configuration of the rows fields.
  final List<FieldSortOptions>? heatMapRowSort;

  HeatMapSortConfiguration({
    this.heatMapColumnItemsLimitConfiguration,
    this.heatMapColumnSort,
    this.heatMapRowItemsLimitConfiguration,
    this.heatMapRowSort,
  });

  factory HeatMapSortConfiguration.fromJson(Map<String, dynamic> json) {
    return HeatMapSortConfiguration(
      heatMapColumnItemsLimitConfiguration:
          json['HeatMapColumnItemsLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['HeatMapColumnItemsLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      heatMapColumnSort: (json['HeatMapColumnSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      heatMapRowItemsLimitConfiguration:
          json['HeatMapRowItemsLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['HeatMapRowItemsLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      heatMapRowSort: (json['HeatMapRowSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final heatMapColumnItemsLimitConfiguration =
        this.heatMapColumnItemsLimitConfiguration;
    final heatMapColumnSort = this.heatMapColumnSort;
    final heatMapRowItemsLimitConfiguration =
        this.heatMapRowItemsLimitConfiguration;
    final heatMapRowSort = this.heatMapRowSort;
    return {
      if (heatMapColumnItemsLimitConfiguration != null)
        'HeatMapColumnItemsLimitConfiguration':
            heatMapColumnItemsLimitConfiguration,
      if (heatMapColumnSort != null) 'HeatMapColumnSort': heatMapColumnSort,
      if (heatMapRowItemsLimitConfiguration != null)
        'HeatMapRowItemsLimitConfiguration': heatMapRowItemsLimitConfiguration,
      if (heatMapRowSort != null) 'HeatMapRowSort': heatMapRowSort,
    };
  }
}

/// A heat map.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using
/// heat maps</a> in the <i>Amazon QuickSight User Guide</i>.
class HeatMapVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a heat map.
  final HeatMapConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  HeatMapVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory HeatMapVisual.fromJson(Map<String, dynamic> json) {
    return HeatMapVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? HeatMapConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The field well configuration of a histogram.
class HistogramAggregatedFieldWells {
  /// The value field wells of a histogram. Values are aggregated by
  /// <code>COUNT</code> or <code>DISTINCT_COUNT</code>.
  final List<MeasureField>? values;

  HistogramAggregatedFieldWells({
    this.values,
  });

  factory HistogramAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return HistogramAggregatedFieldWells(
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final values = this.values;
    return {
      if (values != null) 'Values': values,
    };
  }
}

/// The options that determine the presentation of histogram bins.
class HistogramBinOptions {
  /// The options that determine the bin count of a histogram.
  final BinCountOptions? binCount;

  /// The options that determine the bin width of a histogram.
  final BinWidthOptions? binWidth;

  /// The options that determine the selected bin type.
  final HistogramBinType? selectedBinType;

  /// The options that determine the bin start value.
  final double? startValue;

  HistogramBinOptions({
    this.binCount,
    this.binWidth,
    this.selectedBinType,
    this.startValue,
  });

  factory HistogramBinOptions.fromJson(Map<String, dynamic> json) {
    return HistogramBinOptions(
      binCount: json['BinCount'] != null
          ? BinCountOptions.fromJson(json['BinCount'] as Map<String, dynamic>)
          : null,
      binWidth: json['BinWidth'] != null
          ? BinWidthOptions.fromJson(json['BinWidth'] as Map<String, dynamic>)
          : null,
      selectedBinType:
          (json['SelectedBinType'] as String?)?.toHistogramBinType(),
      startValue: json['StartValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final binCount = this.binCount;
    final binWidth = this.binWidth;
    final selectedBinType = this.selectedBinType;
    final startValue = this.startValue;
    return {
      if (binCount != null) 'BinCount': binCount,
      if (binWidth != null) 'BinWidth': binWidth,
      if (selectedBinType != null) 'SelectedBinType': selectedBinType.toValue(),
      if (startValue != null) 'StartValue': startValue,
    };
  }
}

enum HistogramBinType {
  binCount,
  binWidth,
}

extension HistogramBinTypeValueExtension on HistogramBinType {
  String toValue() {
    switch (this) {
      case HistogramBinType.binCount:
        return 'BIN_COUNT';
      case HistogramBinType.binWidth:
        return 'BIN_WIDTH';
    }
  }
}

extension HistogramBinTypeFromString on String {
  HistogramBinType toHistogramBinType() {
    switch (this) {
      case 'BIN_COUNT':
        return HistogramBinType.binCount;
      case 'BIN_WIDTH':
        return HistogramBinType.binWidth;
    }
    throw Exception('$this is not known in enum HistogramBinType');
  }
}

/// The configuration for a <code>HistogramVisual</code>.
class HistogramConfiguration {
  /// The options that determine the presentation of histogram bins.
  final HistogramBinOptions? binOptions;

  /// The data label configuration of a histogram.
  final DataLabelOptions? dataLabels;

  /// The field well configuration of a histogram.
  final HistogramFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The tooltip configuration of a histogram.
  final TooltipOptions? tooltip;

  /// The visual palette configuration of a histogram.
  final VisualPalette? visualPalette;

  /// The options that determine the presentation of the x-axis.
  final AxisDisplayOptions? xAxisDisplayOptions;

  /// The options that determine the presentation of the x-axis label.
  final ChartAxisLabelOptions? xAxisLabelOptions;

  /// The options that determine the presentation of the y-axis.
  final AxisDisplayOptions? yAxisDisplayOptions;

  HistogramConfiguration({
    this.binOptions,
    this.dataLabels,
    this.fieldWells,
    this.interactions,
    this.tooltip,
    this.visualPalette,
    this.xAxisDisplayOptions,
    this.xAxisLabelOptions,
    this.yAxisDisplayOptions,
  });

  factory HistogramConfiguration.fromJson(Map<String, dynamic> json) {
    return HistogramConfiguration(
      binOptions: json['BinOptions'] != null
          ? HistogramBinOptions.fromJson(
              json['BinOptions'] as Map<String, dynamic>)
          : null,
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? HistogramFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
      xAxisDisplayOptions: json['XAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['XAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      xAxisLabelOptions: json['XAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['XAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      yAxisDisplayOptions: json['YAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['YAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final binOptions = this.binOptions;
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final tooltip = this.tooltip;
    final visualPalette = this.visualPalette;
    final xAxisDisplayOptions = this.xAxisDisplayOptions;
    final xAxisLabelOptions = this.xAxisLabelOptions;
    final yAxisDisplayOptions = this.yAxisDisplayOptions;
    return {
      if (binOptions != null) 'BinOptions': binOptions,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (tooltip != null) 'Tooltip': tooltip,
      if (visualPalette != null) 'VisualPalette': visualPalette,
      if (xAxisDisplayOptions != null)
        'XAxisDisplayOptions': xAxisDisplayOptions,
      if (xAxisLabelOptions != null) 'XAxisLabelOptions': xAxisLabelOptions,
      if (yAxisDisplayOptions != null)
        'YAxisDisplayOptions': yAxisDisplayOptions,
    };
  }
}

/// The field well configuration of a histogram.
class HistogramFieldWells {
  /// The field well configuration of a histogram.
  final HistogramAggregatedFieldWells? histogramAggregatedFieldWells;

  HistogramFieldWells({
    this.histogramAggregatedFieldWells,
  });

  factory HistogramFieldWells.fromJson(Map<String, dynamic> json) {
    return HistogramFieldWells(
      histogramAggregatedFieldWells:
          json['HistogramAggregatedFieldWells'] != null
              ? HistogramAggregatedFieldWells.fromJson(
                  json['HistogramAggregatedFieldWells'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final histogramAggregatedFieldWells = this.histogramAggregatedFieldWells;
    return {
      if (histogramAggregatedFieldWells != null)
        'HistogramAggregatedFieldWells': histogramAggregatedFieldWells,
    };
  }
}

/// A histogram.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using
/// histograms</a> in the <i>Amazon QuickSight User Guide</i>.
class HistogramVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration for a <code>HistogramVisual</code>.
  final HistogramConfiguration? chartConfiguration;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  HistogramVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.subtitle,
    this.title,
  });

  factory HistogramVisual.fromJson(Map<String, dynamic> json) {
    return HistogramVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? HistogramConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

enum HorizontalTextAlignment {
  left,
  center,
  right,
  auto,
}

extension HorizontalTextAlignmentValueExtension on HorizontalTextAlignment {
  String toValue() {
    switch (this) {
      case HorizontalTextAlignment.left:
        return 'LEFT';
      case HorizontalTextAlignment.center:
        return 'CENTER';
      case HorizontalTextAlignment.right:
        return 'RIGHT';
      case HorizontalTextAlignment.auto:
        return 'AUTO';
    }
  }
}

extension HorizontalTextAlignmentFromString on String {
  HorizontalTextAlignment toHorizontalTextAlignment() {
    switch (this) {
      case 'LEFT':
        return HorizontalTextAlignment.left;
      case 'CENTER':
        return HorizontalTextAlignment.center;
      case 'RIGHT':
        return HorizontalTextAlignment.right;
      case 'AUTO':
        return HorizontalTextAlignment.auto;
    }
    throw Exception('$this is not known in enum HorizontalTextAlignment');
  }
}

/// An Identity and Access Management (IAM) policy assignment.
class IAMPolicyAssignment {
  /// Assignment ID.
  final String? assignmentId;

  /// Assignment name.
  final String? assignmentName;

  /// Assignment status.
  final AssignmentStatus? assignmentStatus;

  /// The Amazon Web Services account ID.
  final String? awsAccountId;

  /// Identities.
  final Map<String, List<String>>? identities;

  /// The Amazon Resource Name (ARN) for the IAM policy.
  final String? policyArn;

  IAMPolicyAssignment({
    this.assignmentId,
    this.assignmentName,
    this.assignmentStatus,
    this.awsAccountId,
    this.identities,
    this.policyArn,
  });

  factory IAMPolicyAssignment.fromJson(Map<String, dynamic> json) {
    return IAMPolicyAssignment(
      assignmentId: json['AssignmentId'] as String?,
      assignmentName: json['AssignmentName'] as String?,
      assignmentStatus:
          (json['AssignmentStatus'] as String?)?.toAssignmentStatus(),
      awsAccountId: json['AwsAccountId'] as String?,
      identities: (json['Identities'] as Map<String, dynamic>?)?.map((k, e) =>
          MapEntry(
              k, (e as List).whereNotNull().map((e) => e as String).toList())),
      policyArn: json['PolicyArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final assignmentId = this.assignmentId;
    final assignmentName = this.assignmentName;
    final assignmentStatus = this.assignmentStatus;
    final awsAccountId = this.awsAccountId;
    final identities = this.identities;
    final policyArn = this.policyArn;
    return {
      if (assignmentId != null) 'AssignmentId': assignmentId,
      if (assignmentName != null) 'AssignmentName': assignmentName,
      if (assignmentStatus != null)
        'AssignmentStatus': assignmentStatus.toValue(),
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (identities != null) 'Identities': identities,
      if (policyArn != null) 'PolicyArn': policyArn,
    };
  }
}

/// IAM policy assignment summary.
class IAMPolicyAssignmentSummary {
  /// Assignment name.
  final String? assignmentName;

  /// Assignment status.
  final AssignmentStatus? assignmentStatus;

  IAMPolicyAssignmentSummary({
    this.assignmentName,
    this.assignmentStatus,
  });

  factory IAMPolicyAssignmentSummary.fromJson(Map<String, dynamic> json) {
    return IAMPolicyAssignmentSummary(
      assignmentName: json['AssignmentName'] as String?,
      assignmentStatus:
          (json['AssignmentStatus'] as String?)?.toAssignmentStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final assignmentName = this.assignmentName;
    final assignmentStatus = this.assignmentStatus;
    return {
      if (assignmentName != null) 'AssignmentName': assignmentName,
      if (assignmentStatus != null)
        'AssignmentStatus': assignmentStatus.toValue(),
    };
  }
}

enum Icon {
  caretUp,
  caretDown,
  plus,
  minus,
  arrowUp,
  arrowDown,
  arrowLeft,
  arrowUpLeft,
  arrowDownLeft,
  arrowRight,
  arrowUpRight,
  arrowDownRight,
  faceUp,
  faceDown,
  faceFlat,
  oneBar,
  twoBar,
  threeBar,
  circle,
  triangle,
  square,
  flag,
  thumbsUp,
  thumbsDown,
  checkmark,
  x,
}

extension IconValueExtension on Icon {
  String toValue() {
    switch (this) {
      case Icon.caretUp:
        return 'CARET_UP';
      case Icon.caretDown:
        return 'CARET_DOWN';
      case Icon.plus:
        return 'PLUS';
      case Icon.minus:
        return 'MINUS';
      case Icon.arrowUp:
        return 'ARROW_UP';
      case Icon.arrowDown:
        return 'ARROW_DOWN';
      case Icon.arrowLeft:
        return 'ARROW_LEFT';
      case Icon.arrowUpLeft:
        return 'ARROW_UP_LEFT';
      case Icon.arrowDownLeft:
        return 'ARROW_DOWN_LEFT';
      case Icon.arrowRight:
        return 'ARROW_RIGHT';
      case Icon.arrowUpRight:
        return 'ARROW_UP_RIGHT';
      case Icon.arrowDownRight:
        return 'ARROW_DOWN_RIGHT';
      case Icon.faceUp:
        return 'FACE_UP';
      case Icon.faceDown:
        return 'FACE_DOWN';
      case Icon.faceFlat:
        return 'FACE_FLAT';
      case Icon.oneBar:
        return 'ONE_BAR';
      case Icon.twoBar:
        return 'TWO_BAR';
      case Icon.threeBar:
        return 'THREE_BAR';
      case Icon.circle:
        return 'CIRCLE';
      case Icon.triangle:
        return 'TRIANGLE';
      case Icon.square:
        return 'SQUARE';
      case Icon.flag:
        return 'FLAG';
      case Icon.thumbsUp:
        return 'THUMBS_UP';
      case Icon.thumbsDown:
        return 'THUMBS_DOWN';
      case Icon.checkmark:
        return 'CHECKMARK';
      case Icon.x:
        return 'X';
    }
  }
}

extension IconFromString on String {
  Icon toIcon() {
    switch (this) {
      case 'CARET_UP':
        return Icon.caretUp;
      case 'CARET_DOWN':
        return Icon.caretDown;
      case 'PLUS':
        return Icon.plus;
      case 'MINUS':
        return Icon.minus;
      case 'ARROW_UP':
        return Icon.arrowUp;
      case 'ARROW_DOWN':
        return Icon.arrowDown;
      case 'ARROW_LEFT':
        return Icon.arrowLeft;
      case 'ARROW_UP_LEFT':
        return Icon.arrowUpLeft;
      case 'ARROW_DOWN_LEFT':
        return Icon.arrowDownLeft;
      case 'ARROW_RIGHT':
        return Icon.arrowRight;
      case 'ARROW_UP_RIGHT':
        return Icon.arrowUpRight;
      case 'ARROW_DOWN_RIGHT':
        return Icon.arrowDownRight;
      case 'FACE_UP':
        return Icon.faceUp;
      case 'FACE_DOWN':
        return Icon.faceDown;
      case 'FACE_FLAT':
        return Icon.faceFlat;
      case 'ONE_BAR':
        return Icon.oneBar;
      case 'TWO_BAR':
        return Icon.twoBar;
      case 'THREE_BAR':
        return Icon.threeBar;
      case 'CIRCLE':
        return Icon.circle;
      case 'TRIANGLE':
        return Icon.triangle;
      case 'SQUARE':
        return Icon.square;
      case 'FLAG':
        return Icon.flag;
      case 'THUMBS_UP':
        return Icon.thumbsUp;
      case 'THUMBS_DOWN':
        return Icon.thumbsDown;
      case 'CHECKMARK':
        return Icon.checkmark;
      case 'X':
        return Icon.x;
    }
    throw Exception('$this is not known in enum Icon');
  }
}

/// The parameters for an IAM Identity Center configuration.
class IdentityCenterConfiguration {
  /// A Boolean option that controls whether Trusted Identity Propagation should
  /// be used.
  final bool? enableIdentityPropagation;

  IdentityCenterConfiguration({
    this.enableIdentityPropagation,
  });

  factory IdentityCenterConfiguration.fromJson(Map<String, dynamic> json) {
    return IdentityCenterConfiguration(
      enableIdentityPropagation: json['EnableIdentityPropagation'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final enableIdentityPropagation = this.enableIdentityPropagation;
    return {
      if (enableIdentityPropagation != null)
        'EnableIdentityPropagation': enableIdentityPropagation,
    };
  }
}

enum IdentityStore {
  quicksight,
}

extension IdentityStoreValueExtension on IdentityStore {
  String toValue() {
    switch (this) {
      case IdentityStore.quicksight:
        return 'QUICKSIGHT';
    }
  }
}

extension IdentityStoreFromString on String {
  IdentityStore toIdentityStore() {
    switch (this) {
      case 'QUICKSIGHT':
        return IdentityStore.quicksight;
    }
    throw Exception('$this is not known in enum IdentityStore');
  }
}

enum IdentityType {
  iam,
  quicksight,
  iamIdentityCenter,
}

extension IdentityTypeValueExtension on IdentityType {
  String toValue() {
    switch (this) {
      case IdentityType.iam:
        return 'IAM';
      case IdentityType.quicksight:
        return 'QUICKSIGHT';
      case IdentityType.iamIdentityCenter:
        return 'IAM_IDENTITY_CENTER';
    }
  }
}

extension IdentityTypeFromString on String {
  IdentityType toIdentityType() {
    switch (this) {
      case 'IAM':
        return IdentityType.iam;
      case 'QUICKSIGHT':
        return IdentityType.quicksight;
      case 'IAM_IDENTITY_CENTER':
        return IdentityType.iamIdentityCenter;
    }
    throw Exception('$this is not known in enum IdentityType');
  }
}

/// The incremental refresh configuration for a dataset.
class IncrementalRefresh {
  /// The lookback window setup for an incremental refresh configuration.
  final LookbackWindow lookbackWindow;

  IncrementalRefresh({
    required this.lookbackWindow,
  });

  factory IncrementalRefresh.fromJson(Map<String, dynamic> json) {
    return IncrementalRefresh(
      lookbackWindow: LookbackWindow.fromJson(
          json['LookbackWindow'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final lookbackWindow = this.lookbackWindow;
    return {
      'LookbackWindow': lookbackWindow,
    };
  }
}

/// Information about the SPICE ingestion for a dataset.
class Ingestion {
  /// The Amazon Resource Name (ARN) of the resource.
  final String arn;

  /// The time that this ingestion started.
  final DateTime createdTime;

  /// Ingestion status.
  final IngestionStatus ingestionStatus;

  /// Error information for this ingestion.
  final ErrorInfo? errorInfo;

  /// Ingestion ID.
  final String? ingestionId;

  /// The size of the data ingested, in bytes.
  final int? ingestionSizeInBytes;

  /// The time that this ingestion took, measured in seconds.
  final int? ingestionTimeInSeconds;
  final QueueInfo? queueInfo;

  /// Event source for this ingestion.
  final IngestionRequestSource? requestSource;

  /// Type of this ingestion.
  final IngestionRequestType? requestType;
  final RowInfo? rowInfo;

  Ingestion({
    required this.arn,
    required this.createdTime,
    required this.ingestionStatus,
    this.errorInfo,
    this.ingestionId,
    this.ingestionSizeInBytes,
    this.ingestionTimeInSeconds,
    this.queueInfo,
    this.requestSource,
    this.requestType,
    this.rowInfo,
  });

  factory Ingestion.fromJson(Map<String, dynamic> json) {
    return Ingestion(
      arn: json['Arn'] as String,
      createdTime: nonNullableTimeStampFromJson(json['CreatedTime'] as Object),
      ingestionStatus: (json['IngestionStatus'] as String).toIngestionStatus(),
      errorInfo: json['ErrorInfo'] != null
          ? ErrorInfo.fromJson(json['ErrorInfo'] as Map<String, dynamic>)
          : null,
      ingestionId: json['IngestionId'] as String?,
      ingestionSizeInBytes: json['IngestionSizeInBytes'] as int?,
      ingestionTimeInSeconds: json['IngestionTimeInSeconds'] as int?,
      queueInfo: json['QueueInfo'] != null
          ? QueueInfo.fromJson(json['QueueInfo'] as Map<String, dynamic>)
          : null,
      requestSource:
          (json['RequestSource'] as String?)?.toIngestionRequestSource(),
      requestType: (json['RequestType'] as String?)?.toIngestionRequestType(),
      rowInfo: json['RowInfo'] != null
          ? RowInfo.fromJson(json['RowInfo'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final ingestionStatus = this.ingestionStatus;
    final errorInfo = this.errorInfo;
    final ingestionId = this.ingestionId;
    final ingestionSizeInBytes = this.ingestionSizeInBytes;
    final ingestionTimeInSeconds = this.ingestionTimeInSeconds;
    final queueInfo = this.queueInfo;
    final requestSource = this.requestSource;
    final requestType = this.requestType;
    final rowInfo = this.rowInfo;
    return {
      'Arn': arn,
      'CreatedTime': unixTimestampToJson(createdTime),
      'IngestionStatus': ingestionStatus.toValue(),
      if (errorInfo != null) 'ErrorInfo': errorInfo,
      if (ingestionId != null) 'IngestionId': ingestionId,
      if (ingestionSizeInBytes != null)
        'IngestionSizeInBytes': ingestionSizeInBytes,
      if (ingestionTimeInSeconds != null)
        'IngestionTimeInSeconds': ingestionTimeInSeconds,
      if (queueInfo != null) 'QueueInfo': queueInfo,
      if (requestSource != null) 'RequestSource': requestSource.toValue(),
      if (requestType != null) 'RequestType': requestType.toValue(),
      if (rowInfo != null) 'RowInfo': rowInfo,
    };
  }
}

enum IngestionErrorType {
  failureToAssumeRole,
  ingestionSuperseded,
  ingestionCanceled,
  dataSetDeleted,
  dataSetNotSpice,
  s3UploadedFileDeleted,
  s3ManifestError,
  dataToleranceException,
  spiceTableNotFound,
  dataSetSizeLimitExceeded,
  rowSizeLimitExceeded,
  accountCapacityLimitExceeded,
  customerError,
  dataSourceNotFound,
  iamRoleNotAvailable,
  connectionFailure,
  sqlTableNotFound,
  permissionDenied,
  sslCertificateValidationFailure,
  oauthTokenFailure,
  sourceApiLimitExceededFailure,
  passwordAuthenticationFailure,
  sqlSchemaMismatchError,
  invalidDateFormat,
  invalidDataprepSyntax,
  sourceResourceLimitExceeded,
  sqlInvalidParameterValue,
  queryTimeout,
  sqlNumericOverflow,
  unresolvableHost,
  unroutableHost,
  sqlException,
  s3FileInaccessible,
  iotFileNotFound,
  iotDataSetFileEmpty,
  invalidDataSourceConfig,
  dataSourceAuthFailed,
  dataSourceConnectionFailed,
  failureToProcessJsonFile,
  internalServiceError,
  refreshSuppressedByEdit,
  permissionNotFound,
  elasticsearchCursorNotEnabled,
  cursorNotEnabled,
  duplicateColumnNamesFound,
}

extension IngestionErrorTypeValueExtension on IngestionErrorType {
  String toValue() {
    switch (this) {
      case IngestionErrorType.failureToAssumeRole:
        return 'FAILURE_TO_ASSUME_ROLE';
      case IngestionErrorType.ingestionSuperseded:
        return 'INGESTION_SUPERSEDED';
      case IngestionErrorType.ingestionCanceled:
        return 'INGESTION_CANCELED';
      case IngestionErrorType.dataSetDeleted:
        return 'DATA_SET_DELETED';
      case IngestionErrorType.dataSetNotSpice:
        return 'DATA_SET_NOT_SPICE';
      case IngestionErrorType.s3UploadedFileDeleted:
        return 'S3_UPLOADED_FILE_DELETED';
      case IngestionErrorType.s3ManifestError:
        return 'S3_MANIFEST_ERROR';
      case IngestionErrorType.dataToleranceException:
        return 'DATA_TOLERANCE_EXCEPTION';
      case IngestionErrorType.spiceTableNotFound:
        return 'SPICE_TABLE_NOT_FOUND';
      case IngestionErrorType.dataSetSizeLimitExceeded:
        return 'DATA_SET_SIZE_LIMIT_EXCEEDED';
      case IngestionErrorType.rowSizeLimitExceeded:
        return 'ROW_SIZE_LIMIT_EXCEEDED';
      case IngestionErrorType.accountCapacityLimitExceeded:
        return 'ACCOUNT_CAPACITY_LIMIT_EXCEEDED';
      case IngestionErrorType.customerError:
        return 'CUSTOMER_ERROR';
      case IngestionErrorType.dataSourceNotFound:
        return 'DATA_SOURCE_NOT_FOUND';
      case IngestionErrorType.iamRoleNotAvailable:
        return 'IAM_ROLE_NOT_AVAILABLE';
      case IngestionErrorType.connectionFailure:
        return 'CONNECTION_FAILURE';
      case IngestionErrorType.sqlTableNotFound:
        return 'SQL_TABLE_NOT_FOUND';
      case IngestionErrorType.permissionDenied:
        return 'PERMISSION_DENIED';
      case IngestionErrorType.sslCertificateValidationFailure:
        return 'SSL_CERTIFICATE_VALIDATION_FAILURE';
      case IngestionErrorType.oauthTokenFailure:
        return 'OAUTH_TOKEN_FAILURE';
      case IngestionErrorType.sourceApiLimitExceededFailure:
        return 'SOURCE_API_LIMIT_EXCEEDED_FAILURE';
      case IngestionErrorType.passwordAuthenticationFailure:
        return 'PASSWORD_AUTHENTICATION_FAILURE';
      case IngestionErrorType.sqlSchemaMismatchError:
        return 'SQL_SCHEMA_MISMATCH_ERROR';
      case IngestionErrorType.invalidDateFormat:
        return 'INVALID_DATE_FORMAT';
      case IngestionErrorType.invalidDataprepSyntax:
        return 'INVALID_DATAPREP_SYNTAX';
      case IngestionErrorType.sourceResourceLimitExceeded:
        return 'SOURCE_RESOURCE_LIMIT_EXCEEDED';
      case IngestionErrorType.sqlInvalidParameterValue:
        return 'SQL_INVALID_PARAMETER_VALUE';
      case IngestionErrorType.queryTimeout:
        return 'QUERY_TIMEOUT';
      case IngestionErrorType.sqlNumericOverflow:
        return 'SQL_NUMERIC_OVERFLOW';
      case IngestionErrorType.unresolvableHost:
        return 'UNRESOLVABLE_HOST';
      case IngestionErrorType.unroutableHost:
        return 'UNROUTABLE_HOST';
      case IngestionErrorType.sqlException:
        return 'SQL_EXCEPTION';
      case IngestionErrorType.s3FileInaccessible:
        return 'S3_FILE_INACCESSIBLE';
      case IngestionErrorType.iotFileNotFound:
        return 'IOT_FILE_NOT_FOUND';
      case IngestionErrorType.iotDataSetFileEmpty:
        return 'IOT_DATA_SET_FILE_EMPTY';
      case IngestionErrorType.invalidDataSourceConfig:
        return 'INVALID_DATA_SOURCE_CONFIG';
      case IngestionErrorType.dataSourceAuthFailed:
        return 'DATA_SOURCE_AUTH_FAILED';
      case IngestionErrorType.dataSourceConnectionFailed:
        return 'DATA_SOURCE_CONNECTION_FAILED';
      case IngestionErrorType.failureToProcessJsonFile:
        return 'FAILURE_TO_PROCESS_JSON_FILE';
      case IngestionErrorType.internalServiceError:
        return 'INTERNAL_SERVICE_ERROR';
      case IngestionErrorType.refreshSuppressedByEdit:
        return 'REFRESH_SUPPRESSED_BY_EDIT';
      case IngestionErrorType.permissionNotFound:
        return 'PERMISSION_NOT_FOUND';
      case IngestionErrorType.elasticsearchCursorNotEnabled:
        return 'ELASTICSEARCH_CURSOR_NOT_ENABLED';
      case IngestionErrorType.cursorNotEnabled:
        return 'CURSOR_NOT_ENABLED';
      case IngestionErrorType.duplicateColumnNamesFound:
        return 'DUPLICATE_COLUMN_NAMES_FOUND';
    }
  }
}

extension IngestionErrorTypeFromString on String {
  IngestionErrorType toIngestionErrorType() {
    switch (this) {
      case 'FAILURE_TO_ASSUME_ROLE':
        return IngestionErrorType.failureToAssumeRole;
      case 'INGESTION_SUPERSEDED':
        return IngestionErrorType.ingestionSuperseded;
      case 'INGESTION_CANCELED':
        return IngestionErrorType.ingestionCanceled;
      case 'DATA_SET_DELETED':
        return IngestionErrorType.dataSetDeleted;
      case 'DATA_SET_NOT_SPICE':
        return IngestionErrorType.dataSetNotSpice;
      case 'S3_UPLOADED_FILE_DELETED':
        return IngestionErrorType.s3UploadedFileDeleted;
      case 'S3_MANIFEST_ERROR':
        return IngestionErrorType.s3ManifestError;
      case 'DATA_TOLERANCE_EXCEPTION':
        return IngestionErrorType.dataToleranceException;
      case 'SPICE_TABLE_NOT_FOUND':
        return IngestionErrorType.spiceTableNotFound;
      case 'DATA_SET_SIZE_LIMIT_EXCEEDED':
        return IngestionErrorType.dataSetSizeLimitExceeded;
      case 'ROW_SIZE_LIMIT_EXCEEDED':
        return IngestionErrorType.rowSizeLimitExceeded;
      case 'ACCOUNT_CAPACITY_LIMIT_EXCEEDED':
        return IngestionErrorType.accountCapacityLimitExceeded;
      case 'CUSTOMER_ERROR':
        return IngestionErrorType.customerError;
      case 'DATA_SOURCE_NOT_FOUND':
        return IngestionErrorType.dataSourceNotFound;
      case 'IAM_ROLE_NOT_AVAILABLE':
        return IngestionErrorType.iamRoleNotAvailable;
      case 'CONNECTION_FAILURE':
        return IngestionErrorType.connectionFailure;
      case 'SQL_TABLE_NOT_FOUND':
        return IngestionErrorType.sqlTableNotFound;
      case 'PERMISSION_DENIED':
        return IngestionErrorType.permissionDenied;
      case 'SSL_CERTIFICATE_VALIDATION_FAILURE':
        return IngestionErrorType.sslCertificateValidationFailure;
      case 'OAUTH_TOKEN_FAILURE':
        return IngestionErrorType.oauthTokenFailure;
      case 'SOURCE_API_LIMIT_EXCEEDED_FAILURE':
        return IngestionErrorType.sourceApiLimitExceededFailure;
      case 'PASSWORD_AUTHENTICATION_FAILURE':
        return IngestionErrorType.passwordAuthenticationFailure;
      case 'SQL_SCHEMA_MISMATCH_ERROR':
        return IngestionErrorType.sqlSchemaMismatchError;
      case 'INVALID_DATE_FORMAT':
        return IngestionErrorType.invalidDateFormat;
      case 'INVALID_DATAPREP_SYNTAX':
        return IngestionErrorType.invalidDataprepSyntax;
      case 'SOURCE_RESOURCE_LIMIT_EXCEEDED':
        return IngestionErrorType.sourceResourceLimitExceeded;
      case 'SQL_INVALID_PARAMETER_VALUE':
        return IngestionErrorType.sqlInvalidParameterValue;
      case 'QUERY_TIMEOUT':
        return IngestionErrorType.queryTimeout;
      case 'SQL_NUMERIC_OVERFLOW':
        return IngestionErrorType.sqlNumericOverflow;
      case 'UNRESOLVABLE_HOST':
        return IngestionErrorType.unresolvableHost;
      case 'UNROUTABLE_HOST':
        return IngestionErrorType.unroutableHost;
      case 'SQL_EXCEPTION':
        return IngestionErrorType.sqlException;
      case 'S3_FILE_INACCESSIBLE':
        return IngestionErrorType.s3FileInaccessible;
      case 'IOT_FILE_NOT_FOUND':
        return IngestionErrorType.iotFileNotFound;
      case 'IOT_DATA_SET_FILE_EMPTY':
        return IngestionErrorType.iotDataSetFileEmpty;
      case 'INVALID_DATA_SOURCE_CONFIG':
        return IngestionErrorType.invalidDataSourceConfig;
      case 'DATA_SOURCE_AUTH_FAILED':
        return IngestionErrorType.dataSourceAuthFailed;
      case 'DATA_SOURCE_CONNECTION_FAILED':
        return IngestionErrorType.dataSourceConnectionFailed;
      case 'FAILURE_TO_PROCESS_JSON_FILE':
        return IngestionErrorType.failureToProcessJsonFile;
      case 'INTERNAL_SERVICE_ERROR':
        return IngestionErrorType.internalServiceError;
      case 'REFRESH_SUPPRESSED_BY_EDIT':
        return IngestionErrorType.refreshSuppressedByEdit;
      case 'PERMISSION_NOT_FOUND':
        return IngestionErrorType.permissionNotFound;
      case 'ELASTICSEARCH_CURSOR_NOT_ENABLED':
        return IngestionErrorType.elasticsearchCursorNotEnabled;
      case 'CURSOR_NOT_ENABLED':
        return IngestionErrorType.cursorNotEnabled;
      case 'DUPLICATE_COLUMN_NAMES_FOUND':
        return IngestionErrorType.duplicateColumnNamesFound;
    }
    throw Exception('$this is not known in enum IngestionErrorType');
  }
}

enum IngestionRequestSource {
  manual,
  scheduled,
}

extension IngestionRequestSourceValueExtension on IngestionRequestSource {
  String toValue() {
    switch (this) {
      case IngestionRequestSource.manual:
        return 'MANUAL';
      case IngestionRequestSource.scheduled:
        return 'SCHEDULED';
    }
  }
}

extension IngestionRequestSourceFromString on String {
  IngestionRequestSource toIngestionRequestSource() {
    switch (this) {
      case 'MANUAL':
        return IngestionRequestSource.manual;
      case 'SCHEDULED':
        return IngestionRequestSource.scheduled;
    }
    throw Exception('$this is not known in enum IngestionRequestSource');
  }
}

/// This defines the type of ingestion request. This is returned as part of
/// create ingestion response.
enum IngestionRequestType {
  initialIngestion,
  edit,
  incrementalRefresh,
  fullRefresh,
}

extension IngestionRequestTypeValueExtension on IngestionRequestType {
  String toValue() {
    switch (this) {
      case IngestionRequestType.initialIngestion:
        return 'INITIAL_INGESTION';
      case IngestionRequestType.edit:
        return 'EDIT';
      case IngestionRequestType.incrementalRefresh:
        return 'INCREMENTAL_REFRESH';
      case IngestionRequestType.fullRefresh:
        return 'FULL_REFRESH';
    }
  }
}

extension IngestionRequestTypeFromString on String {
  IngestionRequestType toIngestionRequestType() {
    switch (this) {
      case 'INITIAL_INGESTION':
        return IngestionRequestType.initialIngestion;
      case 'EDIT':
        return IngestionRequestType.edit;
      case 'INCREMENTAL_REFRESH':
        return IngestionRequestType.incrementalRefresh;
      case 'FULL_REFRESH':
        return IngestionRequestType.fullRefresh;
    }
    throw Exception('$this is not known in enum IngestionRequestType');
  }
}

enum IngestionStatus {
  initialized,
  queued,
  running,
  failed,
  completed,
  cancelled,
}

extension IngestionStatusValueExtension on IngestionStatus {
  String toValue() {
    switch (this) {
      case IngestionStatus.initialized:
        return 'INITIALIZED';
      case IngestionStatus.queued:
        return 'QUEUED';
      case IngestionStatus.running:
        return 'RUNNING';
      case IngestionStatus.failed:
        return 'FAILED';
      case IngestionStatus.completed:
        return 'COMPLETED';
      case IngestionStatus.cancelled:
        return 'CANCELLED';
    }
  }
}

extension IngestionStatusFromString on String {
  IngestionStatus toIngestionStatus() {
    switch (this) {
      case 'INITIALIZED':
        return IngestionStatus.initialized;
      case 'QUEUED':
        return IngestionStatus.queued;
      case 'RUNNING':
        return IngestionStatus.running;
      case 'FAILED':
        return IngestionStatus.failed;
      case 'COMPLETED':
        return IngestionStatus.completed;
      case 'CANCELLED':
        return IngestionStatus.cancelled;
    }
    throw Exception('$this is not known in enum IngestionStatus');
  }
}

/// This defines the type of ingestion user wants to trigger. This is part of
/// create ingestion request.
enum IngestionType {
  incrementalRefresh,
  fullRefresh,
}

extension IngestionTypeValueExtension on IngestionType {
  String toValue() {
    switch (this) {
      case IngestionType.incrementalRefresh:
        return 'INCREMENTAL_REFRESH';
      case IngestionType.fullRefresh:
        return 'FULL_REFRESH';
    }
  }
}

extension IngestionTypeFromString on String {
  IngestionType toIngestionType() {
    switch (this) {
      case 'INCREMENTAL_REFRESH':
        return IngestionType.incrementalRefresh;
      case 'FULL_REFRESH':
        return IngestionType.fullRefresh;
    }
    throw Exception('$this is not known in enum IngestionType');
  }
}

/// Metadata for a column that is used as the input of a transform operation.
class InputColumn {
  /// The name of this column in the underlying data source.
  final String name;

  /// The data type of the column.
  final InputColumnDataType type;

  /// The sub data type of the column. Sub types are only available for decimal
  /// columns that are part of a SPICE dataset.
  final ColumnDataSubType? subType;

  InputColumn({
    required this.name,
    required this.type,
    this.subType,
  });

  factory InputColumn.fromJson(Map<String, dynamic> json) {
    return InputColumn(
      name: json['Name'] as String,
      type: (json['Type'] as String).toInputColumnDataType(),
      subType: (json['SubType'] as String?)?.toColumnDataSubType(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final type = this.type;
    final subType = this.subType;
    return {
      'Name': name,
      'Type': type.toValue(),
      if (subType != null) 'SubType': subType.toValue(),
    };
  }
}

enum InputColumnDataType {
  string,
  integer,
  decimal,
  datetime,
  bit,
  boolean,
  json,
}

extension InputColumnDataTypeValueExtension on InputColumnDataType {
  String toValue() {
    switch (this) {
      case InputColumnDataType.string:
        return 'STRING';
      case InputColumnDataType.integer:
        return 'INTEGER';
      case InputColumnDataType.decimal:
        return 'DECIMAL';
      case InputColumnDataType.datetime:
        return 'DATETIME';
      case InputColumnDataType.bit:
        return 'BIT';
      case InputColumnDataType.boolean:
        return 'BOOLEAN';
      case InputColumnDataType.json:
        return 'JSON';
    }
  }
}

extension InputColumnDataTypeFromString on String {
  InputColumnDataType toInputColumnDataType() {
    switch (this) {
      case 'STRING':
        return InputColumnDataType.string;
      case 'INTEGER':
        return InputColumnDataType.integer;
      case 'DECIMAL':
        return InputColumnDataType.decimal;
      case 'DATETIME':
        return InputColumnDataType.datetime;
      case 'BIT':
        return InputColumnDataType.bit;
      case 'BOOLEAN':
        return InputColumnDataType.boolean;
      case 'JSON':
        return InputColumnDataType.json;
    }
    throw Exception('$this is not known in enum InputColumnDataType');
  }
}

/// The configuration of an insight visual.
class InsightConfiguration {
  /// The computations configurations of the insight visual
  final List<Computation>? computations;

  /// The custom narrative of the insight visual.
  final CustomNarrativeOptions? customNarrative;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  InsightConfiguration({
    this.computations,
    this.customNarrative,
    this.interactions,
  });

  factory InsightConfiguration.fromJson(Map<String, dynamic> json) {
    return InsightConfiguration(
      computations: (json['Computations'] as List?)
          ?.whereNotNull()
          .map((e) => Computation.fromJson(e as Map<String, dynamic>))
          .toList(),
      customNarrative: json['CustomNarrative'] != null
          ? CustomNarrativeOptions.fromJson(
              json['CustomNarrative'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computations = this.computations;
    final customNarrative = this.customNarrative;
    final interactions = this.interactions;
    return {
      if (computations != null) 'Computations': computations,
      if (customNarrative != null) 'CustomNarrative': customNarrative,
      if (interactions != null) 'Interactions': interactions,
    };
  }
}

/// An insight visual.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working
/// with insights</a> in the <i>Amazon QuickSight User Guide</i>.
class InsightVisual {
  /// The dataset that is used in the insight visual.
  final String dataSetIdentifier;

  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of an insight visual.
  final InsightConfiguration? insightConfiguration;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  InsightVisual({
    required this.dataSetIdentifier,
    required this.visualId,
    this.actions,
    this.insightConfiguration,
    this.subtitle,
    this.title,
  });

  factory InsightVisual.fromJson(Map<String, dynamic> json) {
    return InsightVisual(
      dataSetIdentifier: json['DataSetIdentifier'] as String,
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      insightConfiguration: json['InsightConfiguration'] != null
          ? InsightConfiguration.fromJson(
              json['InsightConfiguration'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifier = this.dataSetIdentifier;
    final visualId = this.visualId;
    final actions = this.actions;
    final insightConfiguration = this.insightConfiguration;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'DataSetIdentifier': dataSetIdentifier,
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (insightConfiguration != null)
        'InsightConfiguration': insightConfiguration,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// An integer parameter for a dataset.
class IntegerDatasetParameter {
  /// An identifier for the integer parameter created in the dataset.
  final String id;

  /// The name of the integer parameter that is created in the dataset.
  final String name;

  /// The value type of the dataset parameter. Valid values are <code>single
  /// value</code> or <code>multi value</code>.
  final DatasetParameterValueType valueType;

  /// A list of default values for a given integer parameter. This structure only
  /// accepts static values.
  final IntegerDatasetParameterDefaultValues? defaultValues;

  IntegerDatasetParameter({
    required this.id,
    required this.name,
    required this.valueType,
    this.defaultValues,
  });

  factory IntegerDatasetParameter.fromJson(Map<String, dynamic> json) {
    return IntegerDatasetParameter(
      id: json['Id'] as String,
      name: json['Name'] as String,
      valueType: (json['ValueType'] as String).toDatasetParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? IntegerDatasetParameterDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final name = this.name;
    final valueType = this.valueType;
    final defaultValues = this.defaultValues;
    return {
      'Id': id,
      'Name': name,
      'ValueType': valueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
    };
  }
}

/// The default values of an integer parameter.
class IntegerDatasetParameterDefaultValues {
  /// A list of static default values for a given integer parameter.
  final List<int>? staticValues;

  IntegerDatasetParameterDefaultValues({
    this.staticValues,
  });

  factory IntegerDatasetParameterDefaultValues.fromJson(
      Map<String, dynamic> json) {
    return IntegerDatasetParameterDefaultValues(
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final staticValues = this.staticValues;
    return {
      if (staticValues != null) 'StaticValues': staticValues,
    };
  }
}

/// The default values of the <code>IntegerParameterDeclaration</code>.
class IntegerDefaultValues {
  /// The dynamic value of the <code>IntegerDefaultValues</code>. Different
  /// defaults are displayed according to users, groups, and values mapping.
  final DynamicDefaultValue? dynamicValue;

  /// The static values of the <code>IntegerDefaultValues</code>.
  final List<int>? staticValues;

  IntegerDefaultValues({
    this.dynamicValue,
    this.staticValues,
  });

  factory IntegerDefaultValues.fromJson(Map<String, dynamic> json) {
    return IntegerDefaultValues(
      dynamicValue: json['DynamicValue'] != null
          ? DynamicDefaultValue.fromJson(
              json['DynamicValue'] as Map<String, dynamic>)
          : null,
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dynamicValue = this.dynamicValue;
    final staticValues = this.staticValues;
    return {
      if (dynamicValue != null) 'DynamicValue': dynamicValue,
      if (staticValues != null) 'StaticValues': staticValues,
    };
  }
}

/// An integer parameter.
class IntegerParameter {
  /// The name of the integer parameter.
  final String name;

  /// The values for the integer parameter.
  final List<int> values;

  IntegerParameter({
    required this.name,
    required this.values,
  });

  factory IntegerParameter.fromJson(Map<String, dynamic> json) {
    return IntegerParameter(
      name: json['Name'] as String,
      values:
          (json['Values'] as List).whereNotNull().map((e) => e as int).toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final values = this.values;
    return {
      'Name': name,
      'Values': values,
    };
  }
}

/// A parameter declaration for the <code>Integer</code> data type.
class IntegerParameterDeclaration {
  /// The name of the parameter that is being declared.
  final String name;

  /// The value type determines whether the parameter is a single-value or
  /// multi-value parameter.
  final ParameterValueType parameterValueType;

  /// The default values of a parameter. If the parameter is a single-value
  /// parameter, a maximum of one default value can be provided.
  final IntegerDefaultValues? defaultValues;
  final List<MappedDataSetParameter>? mappedDataSetParameters;

  /// A parameter declaration for the <code>Integer</code> data type.
  final IntegerValueWhenUnsetConfiguration? valueWhenUnset;

  IntegerParameterDeclaration({
    required this.name,
    required this.parameterValueType,
    this.defaultValues,
    this.mappedDataSetParameters,
    this.valueWhenUnset,
  });

  factory IntegerParameterDeclaration.fromJson(Map<String, dynamic> json) {
    return IntegerParameterDeclaration(
      name: json['Name'] as String,
      parameterValueType:
          (json['ParameterValueType'] as String).toParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? IntegerDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
      mappedDataSetParameters: (json['MappedDataSetParameters'] as List?)
          ?.whereNotNull()
          .map(
              (e) => MappedDataSetParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      valueWhenUnset: json['ValueWhenUnset'] != null
          ? IntegerValueWhenUnsetConfiguration.fromJson(
              json['ValueWhenUnset'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final parameterValueType = this.parameterValueType;
    final defaultValues = this.defaultValues;
    final mappedDataSetParameters = this.mappedDataSetParameters;
    final valueWhenUnset = this.valueWhenUnset;
    return {
      'Name': name,
      'ParameterValueType': parameterValueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
      if (mappedDataSetParameters != null)
        'MappedDataSetParameters': mappedDataSetParameters,
      if (valueWhenUnset != null) 'ValueWhenUnset': valueWhenUnset,
    };
  }
}

/// A parameter declaration for the <code>Integer</code> data type.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class IntegerValueWhenUnsetConfiguration {
  /// A custom value that's used when the value of a parameter isn't set.
  final int? customValue;

  /// The built-in options for default values. The value can be one of the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>RECOMMENDED</code>: The recommended value.
  /// </li>
  /// <li>
  /// <code>NULL</code>: The <code>NULL</code> value.
  /// </li>
  /// </ul>
  final ValueWhenUnsetOption? valueWhenUnsetOption;

  IntegerValueWhenUnsetConfiguration({
    this.customValue,
    this.valueWhenUnsetOption,
  });

  factory IntegerValueWhenUnsetConfiguration.fromJson(
      Map<String, dynamic> json) {
    return IntegerValueWhenUnsetConfiguration(
      customValue: json['CustomValue'] as int?,
      valueWhenUnsetOption:
          (json['ValueWhenUnsetOption'] as String?)?.toValueWhenUnsetOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final customValue = this.customValue;
    final valueWhenUnsetOption = this.valueWhenUnsetOption;
    return {
      if (customValue != null) 'CustomValue': customValue,
      if (valueWhenUnsetOption != null)
        'ValueWhenUnsetOption': valueWhenUnsetOption.toValue(),
    };
  }
}

/// The limit configuration of the visual display for an axis.
class ItemsLimitConfiguration {
  /// The limit on how many items of a field are showed in the chart. For example,
  /// the number of slices that are displayed in a pie chart.
  final int? itemsLimit;

  /// The <code>Show other</code> of an axis in the chart. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>INCLUDE</code>
  /// </li>
  /// <li>
  /// <code>EXCLUDE</code>
  /// </li>
  /// </ul>
  final OtherCategories? otherCategories;

  ItemsLimitConfiguration({
    this.itemsLimit,
    this.otherCategories,
  });

  factory ItemsLimitConfiguration.fromJson(Map<String, dynamic> json) {
    return ItemsLimitConfiguration(
      itemsLimit: json['ItemsLimit'] as int?,
      otherCategories:
          (json['OtherCategories'] as String?)?.toOtherCategories(),
    );
  }

  Map<String, dynamic> toJson() {
    final itemsLimit = this.itemsLimit;
    final otherCategories = this.otherCategories;
    return {
      if (itemsLimit != null) 'ItemsLimit': itemsLimit,
      if (otherCategories != null) 'OtherCategories': otherCategories.toValue(),
    };
  }
}

/// The parameters for Jira.
class JiraParameters {
  /// The base URL of the Jira site.
  final String siteBaseUrl;

  JiraParameters({
    required this.siteBaseUrl,
  });

  factory JiraParameters.fromJson(Map<String, dynamic> json) {
    return JiraParameters(
      siteBaseUrl: json['SiteBaseUrl'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final siteBaseUrl = this.siteBaseUrl;
    return {
      'SiteBaseUrl': siteBaseUrl,
    };
  }
}

/// The instructions associated with a join.
class JoinInstruction {
  /// The operand on the left side of a join.
  final String leftOperand;

  /// The join instructions provided in the <code>ON</code> clause of a join.
  final String onClause;

  /// The operand on the right side of a join.
  final String rightOperand;

  /// The type of join that it is.
  final JoinType type;

  /// Join key properties of the left operand.
  final JoinKeyProperties? leftJoinKeyProperties;

  /// Join key properties of the right operand.
  final JoinKeyProperties? rightJoinKeyProperties;

  JoinInstruction({
    required this.leftOperand,
    required this.onClause,
    required this.rightOperand,
    required this.type,
    this.leftJoinKeyProperties,
    this.rightJoinKeyProperties,
  });

  factory JoinInstruction.fromJson(Map<String, dynamic> json) {
    return JoinInstruction(
      leftOperand: json['LeftOperand'] as String,
      onClause: json['OnClause'] as String,
      rightOperand: json['RightOperand'] as String,
      type: (json['Type'] as String).toJoinType(),
      leftJoinKeyProperties: json['LeftJoinKeyProperties'] != null
          ? JoinKeyProperties.fromJson(
              json['LeftJoinKeyProperties'] as Map<String, dynamic>)
          : null,
      rightJoinKeyProperties: json['RightJoinKeyProperties'] != null
          ? JoinKeyProperties.fromJson(
              json['RightJoinKeyProperties'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final leftOperand = this.leftOperand;
    final onClause = this.onClause;
    final rightOperand = this.rightOperand;
    final type = this.type;
    final leftJoinKeyProperties = this.leftJoinKeyProperties;
    final rightJoinKeyProperties = this.rightJoinKeyProperties;
    return {
      'LeftOperand': leftOperand,
      'OnClause': onClause,
      'RightOperand': rightOperand,
      'Type': type.toValue(),
      if (leftJoinKeyProperties != null)
        'LeftJoinKeyProperties': leftJoinKeyProperties,
      if (rightJoinKeyProperties != null)
        'RightJoinKeyProperties': rightJoinKeyProperties,
    };
  }
}

/// Properties associated with the columns participating in a join.
class JoinKeyProperties {
  /// A value that indicates that a row in a table is uniquely identified by the
  /// columns in a join key. This is used by Amazon QuickSight to optimize query
  /// performance.
  final bool? uniqueKey;

  JoinKeyProperties({
    this.uniqueKey,
  });

  factory JoinKeyProperties.fromJson(Map<String, dynamic> json) {
    return JoinKeyProperties(
      uniqueKey: json['UniqueKey'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final uniqueKey = this.uniqueKey;
    return {
      if (uniqueKey != null) 'UniqueKey': uniqueKey,
    };
  }
}

enum JoinType {
  inner,
  outer,
  left,
  right,
}

extension JoinTypeValueExtension on JoinType {
  String toValue() {
    switch (this) {
      case JoinType.inner:
        return 'INNER';
      case JoinType.outer:
        return 'OUTER';
      case JoinType.left:
        return 'LEFT';
      case JoinType.right:
        return 'RIGHT';
    }
  }
}

extension JoinTypeFromString on String {
  JoinType toJoinType() {
    switch (this) {
      case 'INNER':
        return JoinType.inner;
      case 'OUTER':
        return JoinType.outer;
      case 'LEFT':
        return JoinType.left;
      case 'RIGHT':
        return JoinType.right;
    }
    throw Exception('$this is not known in enum JoinType');
  }
}

/// The conditional formatting for the actual value of a KPI visual.
class KPIActualValueConditionalFormatting {
  /// The conditional formatting of the actual value's icon.
  final ConditionalFormattingIcon? icon;

  /// The conditional formatting of the actual value's text color.
  final ConditionalFormattingColor? textColor;

  KPIActualValueConditionalFormatting({
    this.icon,
    this.textColor,
  });

  factory KPIActualValueConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return KPIActualValueConditionalFormatting(
      icon: json['Icon'] != null
          ? ConditionalFormattingIcon.fromJson(
              json['Icon'] as Map<String, dynamic>)
          : null,
      textColor: json['TextColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['TextColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final icon = this.icon;
    final textColor = this.textColor;
    return {
      if (icon != null) 'Icon': icon,
      if (textColor != null) 'TextColor': textColor,
    };
  }
}

/// The conditional formatting for the comparison value of a KPI visual.
class KPIComparisonValueConditionalFormatting {
  /// The conditional formatting of the comparison value's icon.
  final ConditionalFormattingIcon? icon;

  /// The conditional formatting of the comparison value's text color.
  final ConditionalFormattingColor? textColor;

  KPIComparisonValueConditionalFormatting({
    this.icon,
    this.textColor,
  });

  factory KPIComparisonValueConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return KPIComparisonValueConditionalFormatting(
      icon: json['Icon'] != null
          ? ConditionalFormattingIcon.fromJson(
              json['Icon'] as Map<String, dynamic>)
          : null,
      textColor: json['TextColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['TextColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final icon = this.icon;
    final textColor = this.textColor;
    return {
      if (icon != null) 'Icon': icon,
      if (textColor != null) 'TextColor': textColor,
    };
  }
}

/// The conditional formatting of a KPI visual.
class KPIConditionalFormatting {
  /// The conditional formatting options of a KPI visual.
  final List<KPIConditionalFormattingOption>? conditionalFormattingOptions;

  KPIConditionalFormatting({
    this.conditionalFormattingOptions,
  });

  factory KPIConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return KPIConditionalFormatting(
      conditionalFormattingOptions:
          (json['ConditionalFormattingOptions'] as List?)
              ?.whereNotNull()
              .map((e) => KPIConditionalFormattingOption.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final conditionalFormattingOptions = this.conditionalFormattingOptions;
    return {
      if (conditionalFormattingOptions != null)
        'ConditionalFormattingOptions': conditionalFormattingOptions,
    };
  }
}

/// The conditional formatting options of a KPI visual.
class KPIConditionalFormattingOption {
  /// The conditional formatting for the actual value of a KPI visual.
  final KPIActualValueConditionalFormatting? actualValue;

  /// The conditional formatting for the comparison value of a KPI visual.
  final KPIComparisonValueConditionalFormatting? comparisonValue;

  /// The conditional formatting for the primary value of a KPI visual.
  final KPIPrimaryValueConditionalFormatting? primaryValue;

  /// The conditional formatting for the progress bar of a KPI visual.
  final KPIProgressBarConditionalFormatting? progressBar;

  KPIConditionalFormattingOption({
    this.actualValue,
    this.comparisonValue,
    this.primaryValue,
    this.progressBar,
  });

  factory KPIConditionalFormattingOption.fromJson(Map<String, dynamic> json) {
    return KPIConditionalFormattingOption(
      actualValue: json['ActualValue'] != null
          ? KPIActualValueConditionalFormatting.fromJson(
              json['ActualValue'] as Map<String, dynamic>)
          : null,
      comparisonValue: json['ComparisonValue'] != null
          ? KPIComparisonValueConditionalFormatting.fromJson(
              json['ComparisonValue'] as Map<String, dynamic>)
          : null,
      primaryValue: json['PrimaryValue'] != null
          ? KPIPrimaryValueConditionalFormatting.fromJson(
              json['PrimaryValue'] as Map<String, dynamic>)
          : null,
      progressBar: json['ProgressBar'] != null
          ? KPIProgressBarConditionalFormatting.fromJson(
              json['ProgressBar'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final actualValue = this.actualValue;
    final comparisonValue = this.comparisonValue;
    final primaryValue = this.primaryValue;
    final progressBar = this.progressBar;
    return {
      if (actualValue != null) 'ActualValue': actualValue,
      if (comparisonValue != null) 'ComparisonValue': comparisonValue,
      if (primaryValue != null) 'PrimaryValue': primaryValue,
      if (progressBar != null) 'ProgressBar': progressBar,
    };
  }
}

/// The configuration of a KPI visual.
class KPIConfiguration {
  /// The field well configuration of a KPI visual.
  final KPIFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The options that determine the presentation of a KPI visual.
  final KPIOptions? kPIOptions;

  /// The sort configuration of a KPI visual.
  final KPISortConfiguration? sortConfiguration;

  KPIConfiguration({
    this.fieldWells,
    this.interactions,
    this.kPIOptions,
    this.sortConfiguration,
  });

  factory KPIConfiguration.fromJson(Map<String, dynamic> json) {
    return KPIConfiguration(
      fieldWells: json['FieldWells'] != null
          ? KPIFieldWells.fromJson(json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      kPIOptions: json['KPIOptions'] != null
          ? KPIOptions.fromJson(json['KPIOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? KPISortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final kPIOptions = this.kPIOptions;
    final sortConfiguration = this.sortConfiguration;
    return {
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (kPIOptions != null) 'KPIOptions': kPIOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
    };
  }
}

/// The field well configuration of a KPI visual.
class KPIFieldWells {
  /// The target value field wells of a KPI visual.
  final List<MeasureField>? targetValues;

  /// The trend group field wells of a KPI visual.
  final List<DimensionField>? trendGroups;

  /// The value field wells of a KPI visual.
  final List<MeasureField>? values;

  KPIFieldWells({
    this.targetValues,
    this.trendGroups,
    this.values,
  });

  factory KPIFieldWells.fromJson(Map<String, dynamic> json) {
    return KPIFieldWells(
      targetValues: (json['TargetValues'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      trendGroups: (json['TrendGroups'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final targetValues = this.targetValues;
    final trendGroups = this.trendGroups;
    final values = this.values;
    return {
      if (targetValues != null) 'TargetValues': targetValues,
      if (trendGroups != null) 'TrendGroups': trendGroups,
      if (values != null) 'Values': values,
    };
  }
}

/// The options that determine the presentation of a KPI visual.
class KPIOptions {
  /// The comparison configuration of a KPI visual.
  final ComparisonConfiguration? comparison;

  /// The options that determine the primary value display type.
  final PrimaryValueDisplayType? primaryValueDisplayType;

  /// The options that determine the primary value font configuration.
  final FontConfiguration? primaryValueFontConfiguration;

  /// The options that determine the presentation of the progress bar of a KPI
  /// visual.
  final ProgressBarOptions? progressBar;

  /// The options that determine the presentation of the secondary value of a KPI
  /// visual.
  final SecondaryValueOptions? secondaryValue;

  /// The options that determine the secondary value font configuration.
  final FontConfiguration? secondaryValueFontConfiguration;

  /// The options that determine the visibility, color, type, and tooltip
  /// visibility of the sparkline of a KPI visual.
  final KPISparklineOptions? sparkline;

  /// The options that determine the presentation of trend arrows in a KPI visual.
  final TrendArrowOptions? trendArrows;

  /// The options that determine the layout a KPI visual.
  final KPIVisualLayoutOptions? visualLayoutOptions;

  KPIOptions({
    this.comparison,
    this.primaryValueDisplayType,
    this.primaryValueFontConfiguration,
    this.progressBar,
    this.secondaryValue,
    this.secondaryValueFontConfiguration,
    this.sparkline,
    this.trendArrows,
    this.visualLayoutOptions,
  });

  factory KPIOptions.fromJson(Map<String, dynamic> json) {
    return KPIOptions(
      comparison: json['Comparison'] != null
          ? ComparisonConfiguration.fromJson(
              json['Comparison'] as Map<String, dynamic>)
          : null,
      primaryValueDisplayType: (json['PrimaryValueDisplayType'] as String?)
          ?.toPrimaryValueDisplayType(),
      primaryValueFontConfiguration:
          json['PrimaryValueFontConfiguration'] != null
              ? FontConfiguration.fromJson(
                  json['PrimaryValueFontConfiguration'] as Map<String, dynamic>)
              : null,
      progressBar: json['ProgressBar'] != null
          ? ProgressBarOptions.fromJson(
              json['ProgressBar'] as Map<String, dynamic>)
          : null,
      secondaryValue: json['SecondaryValue'] != null
          ? SecondaryValueOptions.fromJson(
              json['SecondaryValue'] as Map<String, dynamic>)
          : null,
      secondaryValueFontConfiguration:
          json['SecondaryValueFontConfiguration'] != null
              ? FontConfiguration.fromJson(
                  json['SecondaryValueFontConfiguration']
                      as Map<String, dynamic>)
              : null,
      sparkline: json['Sparkline'] != null
          ? KPISparklineOptions.fromJson(
              json['Sparkline'] as Map<String, dynamic>)
          : null,
      trendArrows: json['TrendArrows'] != null
          ? TrendArrowOptions.fromJson(
              json['TrendArrows'] as Map<String, dynamic>)
          : null,
      visualLayoutOptions: json['VisualLayoutOptions'] != null
          ? KPIVisualLayoutOptions.fromJson(
              json['VisualLayoutOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final comparison = this.comparison;
    final primaryValueDisplayType = this.primaryValueDisplayType;
    final primaryValueFontConfiguration = this.primaryValueFontConfiguration;
    final progressBar = this.progressBar;
    final secondaryValue = this.secondaryValue;
    final secondaryValueFontConfiguration =
        this.secondaryValueFontConfiguration;
    final sparkline = this.sparkline;
    final trendArrows = this.trendArrows;
    final visualLayoutOptions = this.visualLayoutOptions;
    return {
      if (comparison != null) 'Comparison': comparison,
      if (primaryValueDisplayType != null)
        'PrimaryValueDisplayType': primaryValueDisplayType.toValue(),
      if (primaryValueFontConfiguration != null)
        'PrimaryValueFontConfiguration': primaryValueFontConfiguration,
      if (progressBar != null) 'ProgressBar': progressBar,
      if (secondaryValue != null) 'SecondaryValue': secondaryValue,
      if (secondaryValueFontConfiguration != null)
        'SecondaryValueFontConfiguration': secondaryValueFontConfiguration,
      if (sparkline != null) 'Sparkline': sparkline,
      if (trendArrows != null) 'TrendArrows': trendArrows,
      if (visualLayoutOptions != null)
        'VisualLayoutOptions': visualLayoutOptions,
    };
  }
}

/// The conditional formatting for the primary value of a KPI visual.
class KPIPrimaryValueConditionalFormatting {
  /// The conditional formatting of the primary value's icon.
  final ConditionalFormattingIcon? icon;

  /// The conditional formatting of the primary value's text color.
  final ConditionalFormattingColor? textColor;

  KPIPrimaryValueConditionalFormatting({
    this.icon,
    this.textColor,
  });

  factory KPIPrimaryValueConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return KPIPrimaryValueConditionalFormatting(
      icon: json['Icon'] != null
          ? ConditionalFormattingIcon.fromJson(
              json['Icon'] as Map<String, dynamic>)
          : null,
      textColor: json['TextColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['TextColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final icon = this.icon;
    final textColor = this.textColor;
    return {
      if (icon != null) 'Icon': icon,
      if (textColor != null) 'TextColor': textColor,
    };
  }
}

/// The conditional formatting for the progress bar of a KPI visual.
class KPIProgressBarConditionalFormatting {
  /// The conditional formatting of the progress bar's foreground color.
  final ConditionalFormattingColor? foregroundColor;

  KPIProgressBarConditionalFormatting({
    this.foregroundColor,
  });

  factory KPIProgressBarConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return KPIProgressBarConditionalFormatting(
      foregroundColor: json['ForegroundColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['ForegroundColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final foregroundColor = this.foregroundColor;
    return {
      if (foregroundColor != null) 'ForegroundColor': foregroundColor,
    };
  }
}

/// The sort configuration of a KPI visual.
class KPISortConfiguration {
  /// The sort configuration of the trend group fields.
  final List<FieldSortOptions>? trendGroupSort;

  KPISortConfiguration({
    this.trendGroupSort,
  });

  factory KPISortConfiguration.fromJson(Map<String, dynamic> json) {
    return KPISortConfiguration(
      trendGroupSort: (json['TrendGroupSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final trendGroupSort = this.trendGroupSort;
    return {
      if (trendGroupSort != null) 'TrendGroupSort': trendGroupSort,
    };
  }
}

/// The options that determine the visibility, color, type, and tooltip
/// visibility of the sparkline of a KPI visual.
class KPISparklineOptions {
  /// The type of the sparkline.
  final KPISparklineType type;

  /// The color of the sparkline.
  final String? color;

  /// The tooltip visibility of the sparkline.
  final Visibility? tooltipVisibility;

  /// The visibility of the sparkline.
  final Visibility? visibility;

  KPISparklineOptions({
    required this.type,
    this.color,
    this.tooltipVisibility,
    this.visibility,
  });

  factory KPISparklineOptions.fromJson(Map<String, dynamic> json) {
    return KPISparklineOptions(
      type: (json['Type'] as String).toKPISparklineType(),
      color: json['Color'] as String?,
      tooltipVisibility: (json['TooltipVisibility'] as String?)?.toVisibility(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    final color = this.color;
    final tooltipVisibility = this.tooltipVisibility;
    final visibility = this.visibility;
    return {
      'Type': type.toValue(),
      if (color != null) 'Color': color,
      if (tooltipVisibility != null)
        'TooltipVisibility': tooltipVisibility.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

enum KPISparklineType {
  line,
  area,
}

extension KPISparklineTypeValueExtension on KPISparklineType {
  String toValue() {
    switch (this) {
      case KPISparklineType.line:
        return 'LINE';
      case KPISparklineType.area:
        return 'AREA';
    }
  }
}

extension KPISparklineTypeFromString on String {
  KPISparklineType toKPISparklineType() {
    switch (this) {
      case 'LINE':
        return KPISparklineType.line;
      case 'AREA':
        return KPISparklineType.area;
    }
    throw Exception('$this is not known in enum KPISparklineType');
  }
}

/// A key performance indicator (KPI).
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using
/// KPIs</a> in the <i>Amazon QuickSight User Guide</i>.
class KPIVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a KPI visual.
  final KPIConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The conditional formatting of a KPI visual.
  final KPIConditionalFormatting? conditionalFormatting;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  KPIVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.conditionalFormatting,
    this.subtitle,
    this.title,
  });

  factory KPIVisual.fromJson(Map<String, dynamic> json) {
    return KPIVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? KPIConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      conditionalFormatting: json['ConditionalFormatting'] != null
          ? KPIConditionalFormatting.fromJson(
              json['ConditionalFormatting'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final conditionalFormatting = this.conditionalFormatting;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (conditionalFormatting != null)
        'ConditionalFormatting': conditionalFormatting,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The options that determine the layout a KPI visual.
class KPIVisualLayoutOptions {
  /// The standard layout of the KPI visual.
  final KPIVisualStandardLayout? standardLayout;

  KPIVisualLayoutOptions({
    this.standardLayout,
  });

  factory KPIVisualLayoutOptions.fromJson(Map<String, dynamic> json) {
    return KPIVisualLayoutOptions(
      standardLayout: json['StandardLayout'] != null
          ? KPIVisualStandardLayout.fromJson(
              json['StandardLayout'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final standardLayout = this.standardLayout;
    return {
      if (standardLayout != null) 'StandardLayout': standardLayout,
    };
  }
}

/// The standard layout of the KPI visual.
class KPIVisualStandardLayout {
  /// The standard layout type.
  final KPIVisualStandardLayoutType type;

  KPIVisualStandardLayout({
    required this.type,
  });

  factory KPIVisualStandardLayout.fromJson(Map<String, dynamic> json) {
    return KPIVisualStandardLayout(
      type: (json['Type'] as String).toKPIVisualStandardLayoutType(),
    );
  }

  Map<String, dynamic> toJson() {
    final type = this.type;
    return {
      'Type': type.toValue(),
    };
  }
}

enum KPIVisualStandardLayoutType {
  classic,
  vertical,
}

extension KPIVisualStandardLayoutTypeValueExtension
    on KPIVisualStandardLayoutType {
  String toValue() {
    switch (this) {
      case KPIVisualStandardLayoutType.classic:
        return 'CLASSIC';
      case KPIVisualStandardLayoutType.vertical:
        return 'VERTICAL';
    }
  }
}

extension KPIVisualStandardLayoutTypeFromString on String {
  KPIVisualStandardLayoutType toKPIVisualStandardLayoutType() {
    switch (this) {
      case 'CLASSIC':
        return KPIVisualStandardLayoutType.classic;
      case 'VERTICAL':
        return KPIVisualStandardLayoutType.vertical;
    }
    throw Exception('$this is not known in enum KPIVisualStandardLayoutType');
  }
}

/// The share label options for the labels.
class LabelOptions {
  /// The text for the label.
  final String? customLabel;

  /// The font configuration of the label.
  final FontConfiguration? fontConfiguration;

  /// Determines whether or not the label is visible.
  final Visibility? visibility;

  LabelOptions({
    this.customLabel,
    this.fontConfiguration,
    this.visibility,
  });

  factory LabelOptions.fromJson(Map<String, dynamic> json) {
    return LabelOptions(
      customLabel: json['CustomLabel'] as String?,
      fontConfiguration: json['FontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['FontConfiguration'] as Map<String, dynamic>)
          : null,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final customLabel = this.customLabel;
    final fontConfiguration = this.fontConfiguration;
    final visibility = this.visibility;
    return {
      if (customLabel != null) 'CustomLabel': customLabel,
      if (fontConfiguration != null) 'FontConfiguration': fontConfiguration,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// A <code>Layout</code> defines the placement of elements within a sheet.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types
/// of layout</a> in the <i>Amazon QuickSight User Guide</i>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class Layout {
  /// The configuration that determines what the type of layout for a sheet.
  final LayoutConfiguration configuration;

  Layout({
    required this.configuration,
  });

  factory Layout.fromJson(Map<String, dynamic> json) {
    return Layout(
      configuration: LayoutConfiguration.fromJson(
          json['Configuration'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final configuration = this.configuration;
    return {
      'Configuration': configuration,
    };
  }
}

/// The configuration that determines what the type of layout will be used on a
/// sheet.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class LayoutConfiguration {
  /// A free-form is optimized for a fixed width and has more control over the
  /// exact placement of layout elements.
  final FreeFormLayoutConfiguration? freeFormLayout;

  /// A type of layout that can be used on a sheet. In a grid layout, visuals snap
  /// to a grid with standard spacing and alignment. Dashboards are displayed as
  /// designed, with options to fit to screen or view at actual size. A grid
  /// layout can be configured to behave in one of two ways when the viewport is
  /// resized: <code>FIXED</code> or <code>RESPONSIVE</code>.
  final GridLayoutConfiguration? gridLayout;

  /// A section based layout organizes visuals into multiple sections and has
  /// customized header, footer and page break.
  final SectionBasedLayoutConfiguration? sectionBasedLayout;

  LayoutConfiguration({
    this.freeFormLayout,
    this.gridLayout,
    this.sectionBasedLayout,
  });

  factory LayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return LayoutConfiguration(
      freeFormLayout: json['FreeFormLayout'] != null
          ? FreeFormLayoutConfiguration.fromJson(
              json['FreeFormLayout'] as Map<String, dynamic>)
          : null,
      gridLayout: json['GridLayout'] != null
          ? GridLayoutConfiguration.fromJson(
              json['GridLayout'] as Map<String, dynamic>)
          : null,
      sectionBasedLayout: json['SectionBasedLayout'] != null
          ? SectionBasedLayoutConfiguration.fromJson(
              json['SectionBasedLayout'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final freeFormLayout = this.freeFormLayout;
    final gridLayout = this.gridLayout;
    final sectionBasedLayout = this.sectionBasedLayout;
    return {
      if (freeFormLayout != null) 'FreeFormLayout': freeFormLayout,
      if (gridLayout != null) 'GridLayout': gridLayout,
      if (sectionBasedLayout != null) 'SectionBasedLayout': sectionBasedLayout,
    };
  }
}

enum LayoutElementType {
  visual,
  filterControl,
  parameterControl,
  textBox,
}

extension LayoutElementTypeValueExtension on LayoutElementType {
  String toValue() {
    switch (this) {
      case LayoutElementType.visual:
        return 'VISUAL';
      case LayoutElementType.filterControl:
        return 'FILTER_CONTROL';
      case LayoutElementType.parameterControl:
        return 'PARAMETER_CONTROL';
      case LayoutElementType.textBox:
        return 'TEXT_BOX';
    }
  }
}

extension LayoutElementTypeFromString on String {
  LayoutElementType toLayoutElementType() {
    switch (this) {
      case 'VISUAL':
        return LayoutElementType.visual;
      case 'FILTER_CONTROL':
        return LayoutElementType.filterControl;
      case 'PARAMETER_CONTROL':
        return LayoutElementType.parameterControl;
      case 'TEXT_BOX':
        return LayoutElementType.textBox;
    }
    throw Exception('$this is not known in enum LayoutElementType');
  }
}

/// The options for the legend setup of a visual.
class LegendOptions {
  /// The height of the legend. If this value is omitted, a default height is used
  /// when rendering.
  final String? height;

  /// The positions for the legend. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>AUTO</code>
  /// </li>
  /// <li>
  /// <code>RIGHT</code>
  /// </li>
  /// <li>
  /// <code>BOTTOM</code>
  /// </li>
  /// <li>
  /// <code>LEFT</code>
  /// </li>
  /// </ul>
  final LegendPosition? position;

  /// The custom title for the legend.
  final LabelOptions? title;

  /// Determines whether or not the legend is visible.
  final Visibility? visibility;

  /// The width of the legend. If this value is omitted, a default width is used
  /// when rendering.
  final String? width;

  LegendOptions({
    this.height,
    this.position,
    this.title,
    this.visibility,
    this.width,
  });

  factory LegendOptions.fromJson(Map<String, dynamic> json) {
    return LegendOptions(
      height: json['Height'] as String?,
      position: (json['Position'] as String?)?.toLegendPosition(),
      title: json['Title'] != null
          ? LabelOptions.fromJson(json['Title'] as Map<String, dynamic>)
          : null,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
      width: json['Width'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final height = this.height;
    final position = this.position;
    final title = this.title;
    final visibility = this.visibility;
    final width = this.width;
    return {
      if (height != null) 'Height': height,
      if (position != null) 'Position': position.toValue(),
      if (title != null) 'Title': title,
      if (visibility != null) 'Visibility': visibility.toValue(),
      if (width != null) 'Width': width,
    };
  }
}

enum LegendPosition {
  auto,
  right,
  bottom,
  top,
}

extension LegendPositionValueExtension on LegendPosition {
  String toValue() {
    switch (this) {
      case LegendPosition.auto:
        return 'AUTO';
      case LegendPosition.right:
        return 'RIGHT';
      case LegendPosition.bottom:
        return 'BOTTOM';
      case LegendPosition.top:
        return 'TOP';
    }
  }
}

extension LegendPositionFromString on String {
  LegendPosition toLegendPosition() {
    switch (this) {
      case 'AUTO':
        return LegendPosition.auto;
      case 'RIGHT':
        return LegendPosition.right;
      case 'BOTTOM':
        return LegendPosition.bottom;
      case 'TOP':
        return LegendPosition.top;
    }
    throw Exception('$this is not known in enum LegendPosition');
  }
}

/// The field well configuration of a line chart.
class LineChartAggregatedFieldWells {
  /// The category field wells of a line chart. Values are grouped by category
  /// fields.
  final List<DimensionField>? category;

  /// The color field wells of a line chart. Values are grouped by category
  /// fields.
  final List<DimensionField>? colors;

  /// The small multiples field well of a line chart.
  final List<DimensionField>? smallMultiples;

  /// The value field wells of a line chart. Values are aggregated based on
  /// categories.
  final List<MeasureField>? values;

  LineChartAggregatedFieldWells({
    this.category,
    this.colors,
    this.smallMultiples,
    this.values,
  });

  factory LineChartAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return LineChartAggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      smallMultiples: (json['SmallMultiples'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final colors = this.colors;
    final smallMultiples = this.smallMultiples;
    final values = this.values;
    return {
      if (category != null) 'Category': category,
      if (colors != null) 'Colors': colors,
      if (smallMultiples != null) 'SmallMultiples': smallMultiples,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a line chart.
class LineChartConfiguration {
  /// The default configuration of a line chart's contribution analysis.
  final List<ContributionAnalysisDefault>? contributionAnalysisDefaults;

  /// The data label configuration of a line chart.
  final DataLabelOptions? dataLabels;

  /// The options that determine the default presentation of all line series in
  /// <code>LineChartVisual</code>.
  final LineChartDefaultSeriesSettings? defaultSeriesSettings;

  /// The field well configuration of a line chart.
  final LineChartFieldWells? fieldWells;

  /// The forecast configuration of a line chart.
  final List<ForecastConfiguration>? forecastConfigurations;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend configuration of a line chart.
  final LegendOptions? legend;

  /// The series axis configuration of a line chart.
  final LineSeriesAxisDisplayOptions? primaryYAxisDisplayOptions;

  /// The options that determine the presentation of the y-axis label.
  final ChartAxisLabelOptions? primaryYAxisLabelOptions;

  /// The reference lines configuration of a line chart.
  final List<ReferenceLine>? referenceLines;

  /// The series axis configuration of a line chart.
  final LineSeriesAxisDisplayOptions? secondaryYAxisDisplayOptions;

  /// The options that determine the presentation of the secondary y-axis label.
  final ChartAxisLabelOptions? secondaryYAxisLabelOptions;

  /// The series item configuration of a line chart.
  final List<SeriesItem>? series;
  final SingleAxisOptions? singleAxisOptions;

  /// The small multiples setup for the visual.
  final SmallMultiplesOptions? smallMultiplesOptions;

  /// The sort configuration of a line chart.
  final LineChartSortConfiguration? sortConfiguration;

  /// The tooltip configuration of a line chart.
  final TooltipOptions? tooltip;

  /// Determines the type of the line chart.
  final LineChartType? type;

  /// The visual palette configuration of a line chart.
  final VisualPalette? visualPalette;

  /// The options that determine the presentation of the x-axis.
  final AxisDisplayOptions? xAxisDisplayOptions;

  /// The options that determine the presentation of the x-axis label.
  final ChartAxisLabelOptions? xAxisLabelOptions;

  LineChartConfiguration({
    this.contributionAnalysisDefaults,
    this.dataLabels,
    this.defaultSeriesSettings,
    this.fieldWells,
    this.forecastConfigurations,
    this.interactions,
    this.legend,
    this.primaryYAxisDisplayOptions,
    this.primaryYAxisLabelOptions,
    this.referenceLines,
    this.secondaryYAxisDisplayOptions,
    this.secondaryYAxisLabelOptions,
    this.series,
    this.singleAxisOptions,
    this.smallMultiplesOptions,
    this.sortConfiguration,
    this.tooltip,
    this.type,
    this.visualPalette,
    this.xAxisDisplayOptions,
    this.xAxisLabelOptions,
  });

  factory LineChartConfiguration.fromJson(Map<String, dynamic> json) {
    return LineChartConfiguration(
      contributionAnalysisDefaults: (json['ContributionAnalysisDefaults']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              ContributionAnalysisDefault.fromJson(e as Map<String, dynamic>))
          .toList(),
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      defaultSeriesSettings: json['DefaultSeriesSettings'] != null
          ? LineChartDefaultSeriesSettings.fromJson(
              json['DefaultSeriesSettings'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? LineChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      forecastConfigurations: (json['ForecastConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) => ForecastConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      primaryYAxisDisplayOptions: json['PrimaryYAxisDisplayOptions'] != null
          ? LineSeriesAxisDisplayOptions.fromJson(
              json['PrimaryYAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      primaryYAxisLabelOptions: json['PrimaryYAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['PrimaryYAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      referenceLines: (json['ReferenceLines'] as List?)
          ?.whereNotNull()
          .map((e) => ReferenceLine.fromJson(e as Map<String, dynamic>))
          .toList(),
      secondaryYAxisDisplayOptions: json['SecondaryYAxisDisplayOptions'] != null
          ? LineSeriesAxisDisplayOptions.fromJson(
              json['SecondaryYAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      secondaryYAxisLabelOptions: json['SecondaryYAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['SecondaryYAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      series: (json['Series'] as List?)
          ?.whereNotNull()
          .map((e) => SeriesItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      singleAxisOptions: json['SingleAxisOptions'] != null
          ? SingleAxisOptions.fromJson(
              json['SingleAxisOptions'] as Map<String, dynamic>)
          : null,
      smallMultiplesOptions: json['SmallMultiplesOptions'] != null
          ? SmallMultiplesOptions.fromJson(
              json['SmallMultiplesOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? LineChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toLineChartType(),
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
      xAxisDisplayOptions: json['XAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['XAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      xAxisLabelOptions: json['XAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['XAxisLabelOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contributionAnalysisDefaults = this.contributionAnalysisDefaults;
    final dataLabels = this.dataLabels;
    final defaultSeriesSettings = this.defaultSeriesSettings;
    final fieldWells = this.fieldWells;
    final forecastConfigurations = this.forecastConfigurations;
    final interactions = this.interactions;
    final legend = this.legend;
    final primaryYAxisDisplayOptions = this.primaryYAxisDisplayOptions;
    final primaryYAxisLabelOptions = this.primaryYAxisLabelOptions;
    final referenceLines = this.referenceLines;
    final secondaryYAxisDisplayOptions = this.secondaryYAxisDisplayOptions;
    final secondaryYAxisLabelOptions = this.secondaryYAxisLabelOptions;
    final series = this.series;
    final singleAxisOptions = this.singleAxisOptions;
    final smallMultiplesOptions = this.smallMultiplesOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final type = this.type;
    final visualPalette = this.visualPalette;
    final xAxisDisplayOptions = this.xAxisDisplayOptions;
    final xAxisLabelOptions = this.xAxisLabelOptions;
    return {
      if (contributionAnalysisDefaults != null)
        'ContributionAnalysisDefaults': contributionAnalysisDefaults,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (defaultSeriesSettings != null)
        'DefaultSeriesSettings': defaultSeriesSettings,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (forecastConfigurations != null)
        'ForecastConfigurations': forecastConfigurations,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (primaryYAxisDisplayOptions != null)
        'PrimaryYAxisDisplayOptions': primaryYAxisDisplayOptions,
      if (primaryYAxisLabelOptions != null)
        'PrimaryYAxisLabelOptions': primaryYAxisLabelOptions,
      if (referenceLines != null) 'ReferenceLines': referenceLines,
      if (secondaryYAxisDisplayOptions != null)
        'SecondaryYAxisDisplayOptions': secondaryYAxisDisplayOptions,
      if (secondaryYAxisLabelOptions != null)
        'SecondaryYAxisLabelOptions': secondaryYAxisLabelOptions,
      if (series != null) 'Series': series,
      if (singleAxisOptions != null) 'SingleAxisOptions': singleAxisOptions,
      if (smallMultiplesOptions != null)
        'SmallMultiplesOptions': smallMultiplesOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (type != null) 'Type': type.toValue(),
      if (visualPalette != null) 'VisualPalette': visualPalette,
      if (xAxisDisplayOptions != null)
        'XAxisDisplayOptions': xAxisDisplayOptions,
      if (xAxisLabelOptions != null) 'XAxisLabelOptions': xAxisLabelOptions,
    };
  }
}

/// The options that determine the default presentation of all line series in
/// <code>LineChartVisual</code>.
class LineChartDefaultSeriesSettings {
  /// The axis to which you are binding all line series to.
  final AxisBinding? axisBinding;

  /// Line styles options for all line series in the visual.
  final LineChartLineStyleSettings? lineStyleSettings;

  /// Marker styles options for all line series in the visual.
  final LineChartMarkerStyleSettings? markerStyleSettings;

  LineChartDefaultSeriesSettings({
    this.axisBinding,
    this.lineStyleSettings,
    this.markerStyleSettings,
  });

  factory LineChartDefaultSeriesSettings.fromJson(Map<String, dynamic> json) {
    return LineChartDefaultSeriesSettings(
      axisBinding: (json['AxisBinding'] as String?)?.toAxisBinding(),
      lineStyleSettings: json['LineStyleSettings'] != null
          ? LineChartLineStyleSettings.fromJson(
              json['LineStyleSettings'] as Map<String, dynamic>)
          : null,
      markerStyleSettings: json['MarkerStyleSettings'] != null
          ? LineChartMarkerStyleSettings.fromJson(
              json['MarkerStyleSettings'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final axisBinding = this.axisBinding;
    final lineStyleSettings = this.lineStyleSettings;
    final markerStyleSettings = this.markerStyleSettings;
    return {
      if (axisBinding != null) 'AxisBinding': axisBinding.toValue(),
      if (lineStyleSettings != null) 'LineStyleSettings': lineStyleSettings,
      if (markerStyleSettings != null)
        'MarkerStyleSettings': markerStyleSettings,
    };
  }
}

/// The field well configuration of a line chart.
class LineChartFieldWells {
  /// The field well configuration of a line chart.
  final LineChartAggregatedFieldWells? lineChartAggregatedFieldWells;

  LineChartFieldWells({
    this.lineChartAggregatedFieldWells,
  });

  factory LineChartFieldWells.fromJson(Map<String, dynamic> json) {
    return LineChartFieldWells(
      lineChartAggregatedFieldWells:
          json['LineChartAggregatedFieldWells'] != null
              ? LineChartAggregatedFieldWells.fromJson(
                  json['LineChartAggregatedFieldWells'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final lineChartAggregatedFieldWells = this.lineChartAggregatedFieldWells;
    return {
      if (lineChartAggregatedFieldWells != null)
        'LineChartAggregatedFieldWells': lineChartAggregatedFieldWells,
    };
  }
}

enum LineChartLineStyle {
  solid,
  dotted,
  dashed,
}

extension LineChartLineStyleValueExtension on LineChartLineStyle {
  String toValue() {
    switch (this) {
      case LineChartLineStyle.solid:
        return 'SOLID';
      case LineChartLineStyle.dotted:
        return 'DOTTED';
      case LineChartLineStyle.dashed:
        return 'DASHED';
    }
  }
}

extension LineChartLineStyleFromString on String {
  LineChartLineStyle toLineChartLineStyle() {
    switch (this) {
      case 'SOLID':
        return LineChartLineStyle.solid;
      case 'DOTTED':
        return LineChartLineStyle.dotted;
      case 'DASHED':
        return LineChartLineStyle.dashed;
    }
    throw Exception('$this is not known in enum LineChartLineStyle');
  }
}

/// Line styles options for a line series in <code>LineChartVisual</code>.
class LineChartLineStyleSettings {
  /// Interpolation style for line series.
  ///
  /// <ul>
  /// <li>
  /// <code>LINEAR</code>: Show as default, linear style.
  /// </li>
  /// <li>
  /// <code>SMOOTH</code>: Show as a smooth curve.
  /// </li>
  /// <li>
  /// <code>STEPPED</code>: Show steps in line.
  /// </li>
  /// </ul>
  final LineInterpolation? lineInterpolation;

  /// Line style for line series.
  ///
  /// <ul>
  /// <li>
  /// <code>SOLID</code>: Show as a solid line.
  /// </li>
  /// <li>
  /// <code>DOTTED</code>: Show as a dotted line.
  /// </li>
  /// <li>
  /// <code>DASHED</code>: Show as a dashed line.
  /// </li>
  /// </ul>
  final LineChartLineStyle? lineStyle;

  /// Configuration option that determines whether to show the line for the
  /// series.
  final Visibility? lineVisibility;

  /// Width that determines the line thickness.
  final String? lineWidth;

  LineChartLineStyleSettings({
    this.lineInterpolation,
    this.lineStyle,
    this.lineVisibility,
    this.lineWidth,
  });

  factory LineChartLineStyleSettings.fromJson(Map<String, dynamic> json) {
    return LineChartLineStyleSettings(
      lineInterpolation:
          (json['LineInterpolation'] as String?)?.toLineInterpolation(),
      lineStyle: (json['LineStyle'] as String?)?.toLineChartLineStyle(),
      lineVisibility: (json['LineVisibility'] as String?)?.toVisibility(),
      lineWidth: json['LineWidth'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final lineInterpolation = this.lineInterpolation;
    final lineStyle = this.lineStyle;
    final lineVisibility = this.lineVisibility;
    final lineWidth = this.lineWidth;
    return {
      if (lineInterpolation != null)
        'LineInterpolation': lineInterpolation.toValue(),
      if (lineStyle != null) 'LineStyle': lineStyle.toValue(),
      if (lineVisibility != null) 'LineVisibility': lineVisibility.toValue(),
      if (lineWidth != null) 'LineWidth': lineWidth,
    };
  }
}

enum LineChartMarkerShape {
  circle,
  triangle,
  square,
  diamond,
  roundedSquare,
}

extension LineChartMarkerShapeValueExtension on LineChartMarkerShape {
  String toValue() {
    switch (this) {
      case LineChartMarkerShape.circle:
        return 'CIRCLE';
      case LineChartMarkerShape.triangle:
        return 'TRIANGLE';
      case LineChartMarkerShape.square:
        return 'SQUARE';
      case LineChartMarkerShape.diamond:
        return 'DIAMOND';
      case LineChartMarkerShape.roundedSquare:
        return 'ROUNDED_SQUARE';
    }
  }
}

extension LineChartMarkerShapeFromString on String {
  LineChartMarkerShape toLineChartMarkerShape() {
    switch (this) {
      case 'CIRCLE':
        return LineChartMarkerShape.circle;
      case 'TRIANGLE':
        return LineChartMarkerShape.triangle;
      case 'SQUARE':
        return LineChartMarkerShape.square;
      case 'DIAMOND':
        return LineChartMarkerShape.diamond;
      case 'ROUNDED_SQUARE':
        return LineChartMarkerShape.roundedSquare;
    }
    throw Exception('$this is not known in enum LineChartMarkerShape');
  }
}

/// Marker styles options for a line series in <code>LineChartVisual</code>.
class LineChartMarkerStyleSettings {
  /// Color of marker in the series.
  final String? markerColor;

  /// Shape option for markers in the series.
  ///
  /// <ul>
  /// <li>
  /// <code>CIRCLE</code>: Show marker as a circle.
  /// </li>
  /// <li>
  /// <code>TRIANGLE</code>: Show marker as a triangle.
  /// </li>
  /// <li>
  /// <code>SQUARE</code>: Show marker as a square.
  /// </li>
  /// <li>
  /// <code>DIAMOND</code>: Show marker as a diamond.
  /// </li>
  /// <li>
  /// <code>ROUNDED_SQUARE</code>: Show marker as a rounded square.
  /// </li>
  /// </ul>
  final LineChartMarkerShape? markerShape;

  /// Size of marker in the series.
  final String? markerSize;

  /// Configuration option that determines whether to show the markers in the
  /// series.
  final Visibility? markerVisibility;

  LineChartMarkerStyleSettings({
    this.markerColor,
    this.markerShape,
    this.markerSize,
    this.markerVisibility,
  });

  factory LineChartMarkerStyleSettings.fromJson(Map<String, dynamic> json) {
    return LineChartMarkerStyleSettings(
      markerColor: json['MarkerColor'] as String?,
      markerShape: (json['MarkerShape'] as String?)?.toLineChartMarkerShape(),
      markerSize: json['MarkerSize'] as String?,
      markerVisibility: (json['MarkerVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final markerColor = this.markerColor;
    final markerShape = this.markerShape;
    final markerSize = this.markerSize;
    final markerVisibility = this.markerVisibility;
    return {
      if (markerColor != null) 'MarkerColor': markerColor,
      if (markerShape != null) 'MarkerShape': markerShape.toValue(),
      if (markerSize != null) 'MarkerSize': markerSize,
      if (markerVisibility != null)
        'MarkerVisibility': markerVisibility.toValue(),
    };
  }
}

/// The options that determine the presentation of a line series in the visual
class LineChartSeriesSettings {
  /// Line styles options for a line series in <code>LineChartVisual</code>.
  final LineChartLineStyleSettings? lineStyleSettings;

  /// Marker styles options for a line series in <code>LineChartVisual</code>.
  final LineChartMarkerStyleSettings? markerStyleSettings;

  LineChartSeriesSettings({
    this.lineStyleSettings,
    this.markerStyleSettings,
  });

  factory LineChartSeriesSettings.fromJson(Map<String, dynamic> json) {
    return LineChartSeriesSettings(
      lineStyleSettings: json['LineStyleSettings'] != null
          ? LineChartLineStyleSettings.fromJson(
              json['LineStyleSettings'] as Map<String, dynamic>)
          : null,
      markerStyleSettings: json['MarkerStyleSettings'] != null
          ? LineChartMarkerStyleSettings.fromJson(
              json['MarkerStyleSettings'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final lineStyleSettings = this.lineStyleSettings;
    final markerStyleSettings = this.markerStyleSettings;
    return {
      if (lineStyleSettings != null) 'LineStyleSettings': lineStyleSettings,
      if (markerStyleSettings != null)
        'MarkerStyleSettings': markerStyleSettings,
    };
  }
}

/// The sort configuration of a line chart.
class LineChartSortConfiguration {
  /// The limit on the number of categories that are displayed in a line chart.
  final ItemsLimitConfiguration? categoryItemsLimitConfiguration;

  /// The sort configuration of the category fields.
  final List<FieldSortOptions>? categorySort;

  /// The limit on the number of lines that are displayed in a line chart.
  final ItemsLimitConfiguration? colorItemsLimitConfiguration;

  /// The limit on the number of small multiples panels that are displayed.
  final ItemsLimitConfiguration? smallMultiplesLimitConfiguration;

  /// The sort configuration of the small multiples field.
  final List<FieldSortOptions>? smallMultiplesSort;

  LineChartSortConfiguration({
    this.categoryItemsLimitConfiguration,
    this.categorySort,
    this.colorItemsLimitConfiguration,
    this.smallMultiplesLimitConfiguration,
    this.smallMultiplesSort,
  });

  factory LineChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return LineChartSortConfiguration(
      categoryItemsLimitConfiguration:
          json['CategoryItemsLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['CategoryItemsLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      colorItemsLimitConfiguration: json['ColorItemsLimitConfiguration'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['ColorItemsLimitConfiguration'] as Map<String, dynamic>)
          : null,
      smallMultiplesLimitConfiguration:
          json['SmallMultiplesLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['SmallMultiplesLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      smallMultiplesSort: (json['SmallMultiplesSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimitConfiguration =
        this.categoryItemsLimitConfiguration;
    final categorySort = this.categorySort;
    final colorItemsLimitConfiguration = this.colorItemsLimitConfiguration;
    final smallMultiplesLimitConfiguration =
        this.smallMultiplesLimitConfiguration;
    final smallMultiplesSort = this.smallMultiplesSort;
    return {
      if (categoryItemsLimitConfiguration != null)
        'CategoryItemsLimitConfiguration': categoryItemsLimitConfiguration,
      if (categorySort != null) 'CategorySort': categorySort,
      if (colorItemsLimitConfiguration != null)
        'ColorItemsLimitConfiguration': colorItemsLimitConfiguration,
      if (smallMultiplesLimitConfiguration != null)
        'SmallMultiplesLimitConfiguration': smallMultiplesLimitConfiguration,
      if (smallMultiplesSort != null) 'SmallMultiplesSort': smallMultiplesSort,
    };
  }
}

enum LineChartType {
  line,
  area,
  stackedArea,
}

extension LineChartTypeValueExtension on LineChartType {
  String toValue() {
    switch (this) {
      case LineChartType.line:
        return 'LINE';
      case LineChartType.area:
        return 'AREA';
      case LineChartType.stackedArea:
        return 'STACKED_AREA';
    }
  }
}

extension LineChartTypeFromString on String {
  LineChartType toLineChartType() {
    switch (this) {
      case 'LINE':
        return LineChartType.line;
      case 'AREA':
        return LineChartType.area;
      case 'STACKED_AREA':
        return LineChartType.stackedArea;
    }
    throw Exception('$this is not known in enum LineChartType');
  }
}

/// A line chart.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using
/// line charts</a> in the <i>Amazon QuickSight User Guide</i>.
class LineChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a line chart.
  final LineChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  LineChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory LineChartVisual.fromJson(Map<String, dynamic> json) {
    return LineChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? LineChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

enum LineInterpolation {
  linear,
  smooth,
  stepped,
}

extension LineInterpolationValueExtension on LineInterpolation {
  String toValue() {
    switch (this) {
      case LineInterpolation.linear:
        return 'LINEAR';
      case LineInterpolation.smooth:
        return 'SMOOTH';
      case LineInterpolation.stepped:
        return 'STEPPED';
    }
  }
}

extension LineInterpolationFromString on String {
  LineInterpolation toLineInterpolation() {
    switch (this) {
      case 'LINEAR':
        return LineInterpolation.linear;
      case 'SMOOTH':
        return LineInterpolation.smooth;
      case 'STEPPED':
        return LineInterpolation.stepped;
    }
    throw Exception('$this is not known in enum LineInterpolation');
  }
}

/// The series axis configuration of a line chart.
class LineSeriesAxisDisplayOptions {
  /// The options that determine the presentation of the line series axis.
  final AxisDisplayOptions? axisOptions;

  /// The configuration options that determine how missing data is treated during
  /// the rendering of a line chart.
  final List<MissingDataConfiguration>? missingDataConfigurations;

  LineSeriesAxisDisplayOptions({
    this.axisOptions,
    this.missingDataConfigurations,
  });

  factory LineSeriesAxisDisplayOptions.fromJson(Map<String, dynamic> json) {
    return LineSeriesAxisDisplayOptions(
      axisOptions: json['AxisOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['AxisOptions'] as Map<String, dynamic>)
          : null,
      missingDataConfigurations: (json['MissingDataConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) =>
              MissingDataConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final axisOptions = this.axisOptions;
    final missingDataConfigurations = this.missingDataConfigurations;
    return {
      if (axisOptions != null) 'AxisOptions': axisOptions,
      if (missingDataConfigurations != null)
        'MissingDataConfigurations': missingDataConfigurations,
    };
  }
}

/// A structure that contains the configuration of a shareable link to the
/// dashboard.
class LinkSharingConfiguration {
  /// A structure that contains the permissions of a shareable link.
  final List<ResourcePermission>? permissions;

  LinkSharingConfiguration({
    this.permissions,
  });

  factory LinkSharingConfiguration.fromJson(Map<String, dynamic> json) {
    return LinkSharingConfiguration(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    return {
      if (permissions != null) 'Permissions': permissions,
    };
  }
}

class ListAnalysesResponse {
  /// Metadata describing each of the analyses that are listed.
  final List<AnalysisSummary>? analysisSummaryList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListAnalysesResponse({
    this.analysisSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListAnalysesResponse.fromJson(Map<String, dynamic> json) {
    return ListAnalysesResponse(
      analysisSummaryList: (json['AnalysisSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => AnalysisSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisSummaryList = this.analysisSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisSummaryList != null)
        'AnalysisSummaryList': analysisSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListAssetBundleExportJobsResponse {
  /// A list of export job summaries.
  final List<AssetBundleExportJobSummary>? assetBundleExportJobSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListAssetBundleExportJobsResponse({
    this.assetBundleExportJobSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListAssetBundleExportJobsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListAssetBundleExportJobsResponse(
      assetBundleExportJobSummaryList: (json['AssetBundleExportJobSummaryList']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleExportJobSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final assetBundleExportJobSummaryList =
        this.assetBundleExportJobSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (assetBundleExportJobSummaryList != null)
        'AssetBundleExportJobSummaryList': assetBundleExportJobSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListAssetBundleImportJobsResponse {
  /// A list of import job summaries.
  final List<AssetBundleImportJobSummary>? assetBundleImportJobSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the response.
  final int? status;

  ListAssetBundleImportJobsResponse({
    this.assetBundleImportJobSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListAssetBundleImportJobsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListAssetBundleImportJobsResponse(
      assetBundleImportJobSummaryList: (json['AssetBundleImportJobSummaryList']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              AssetBundleImportJobSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final assetBundleImportJobSummaryList =
        this.assetBundleImportJobSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (assetBundleImportJobSummaryList != null)
        'AssetBundleImportJobSummaryList': assetBundleImportJobSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// The display options of a control.
class ListControlDisplayOptions {
  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The configuration of the search options in a list control.
  final ListControlSearchOptions? searchOptions;

  /// The configuration of the <code>Select all</code> options in a list control.
  final ListControlSelectAllOptions? selectAllOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  ListControlDisplayOptions({
    this.infoIconLabelOptions,
    this.searchOptions,
    this.selectAllOptions,
    this.titleOptions,
  });

  factory ListControlDisplayOptions.fromJson(Map<String, dynamic> json) {
    return ListControlDisplayOptions(
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      searchOptions: json['SearchOptions'] != null
          ? ListControlSearchOptions.fromJson(
              json['SearchOptions'] as Map<String, dynamic>)
          : null,
      selectAllOptions: json['SelectAllOptions'] != null
          ? ListControlSelectAllOptions.fromJson(
              json['SelectAllOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final searchOptions = this.searchOptions;
    final selectAllOptions = this.selectAllOptions;
    final titleOptions = this.titleOptions;
    return {
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (searchOptions != null) 'SearchOptions': searchOptions,
      if (selectAllOptions != null) 'SelectAllOptions': selectAllOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

/// The configuration of the search options in a list control.
class ListControlSearchOptions {
  /// The visibility configuration of the search options in a list control.
  final Visibility? visibility;

  ListControlSearchOptions({
    this.visibility,
  });

  factory ListControlSearchOptions.fromJson(Map<String, dynamic> json) {
    return ListControlSearchOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The configuration of the <code>Select all</code> options in a list control.
class ListControlSelectAllOptions {
  /// The visibility configuration of the <code>Select all</code> options in a
  /// list control.
  final Visibility? visibility;

  ListControlSelectAllOptions({
    this.visibility,
  });

  factory ListControlSelectAllOptions.fromJson(Map<String, dynamic> json) {
    return ListControlSelectAllOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

class ListDashboardVersionsResponse {
  /// A structure that contains information about each version of the dashboard.
  final List<DashboardVersionSummary>? dashboardVersionSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListDashboardVersionsResponse({
    this.dashboardVersionSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListDashboardVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListDashboardVersionsResponse(
      dashboardVersionSummaryList:
          (json['DashboardVersionSummaryList'] as List?)
              ?.whereNotNull()
              .map((e) =>
                  DashboardVersionSummary.fromJson(e as Map<String, dynamic>))
              .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardVersionSummaryList = this.dashboardVersionSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardVersionSummaryList != null)
        'DashboardVersionSummaryList': dashboardVersionSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListDashboardsResponse {
  /// A structure that contains all of the dashboards in your Amazon Web Services
  /// account. This structure provides basic information about the dashboards.
  final List<DashboardSummary>? dashboardSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListDashboardsResponse({
    this.dashboardSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListDashboardsResponse.fromJson(Map<String, dynamic> json) {
    return ListDashboardsResponse(
      dashboardSummaryList: (json['DashboardSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => DashboardSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardSummaryList = this.dashboardSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardSummaryList != null)
        'DashboardSummaryList': dashboardSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListDataSetsResponse {
  /// The list of dataset summaries.
  final List<DataSetSummary>? dataSetSummaries;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListDataSetsResponse({
    this.dataSetSummaries,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListDataSetsResponse.fromJson(Map<String, dynamic> json) {
    return ListDataSetsResponse(
      dataSetSummaries: (json['DataSetSummaries'] as List?)
          ?.whereNotNull()
          .map((e) => DataSetSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetSummaries = this.dataSetSummaries;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSetSummaries != null) 'DataSetSummaries': dataSetSummaries,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListDataSourcesResponse {
  /// A list of data sources.
  final List<DataSource>? dataSources;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListDataSourcesResponse({
    this.dataSources,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListDataSourcesResponse.fromJson(Map<String, dynamic> json) {
    return ListDataSourcesResponse(
      dataSources: (json['DataSources'] as List?)
          ?.whereNotNull()
          .map((e) => DataSource.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSources = this.dataSources;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSources != null) 'DataSources': dataSources,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListFolderMembersResponse {
  /// A structure that contains all of the folder members (dashboards, analyses,
  /// and datasets) in the folder.
  final List<MemberIdArnPair>? folderMemberList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListFolderMembersResponse({
    this.folderMemberList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListFolderMembersResponse.fromJson(Map<String, dynamic> json) {
    return ListFolderMembersResponse(
      folderMemberList: (json['FolderMemberList'] as List?)
          ?.whereNotNull()
          .map((e) => MemberIdArnPair.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final folderMemberList = this.folderMemberList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (folderMemberList != null) 'FolderMemberList': folderMemberList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListFoldersResponse {
  /// A structure that contains all of the folders in the Amazon Web Services
  /// account. This structure provides basic information about the folders.
  final List<FolderSummary>? folderSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListFoldersResponse({
    this.folderSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListFoldersResponse.fromJson(Map<String, dynamic> json) {
    return ListFoldersResponse(
      folderSummaryList: (json['FolderSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => FolderSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final folderSummaryList = this.folderSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (folderSummaryList != null) 'FolderSummaryList': folderSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListGroupMembershipsResponse {
  /// The list of the members of the group.
  final List<GroupMember>? groupMemberList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListGroupMembershipsResponse({
    this.groupMemberList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListGroupMembershipsResponse.fromJson(Map<String, dynamic> json) {
    return ListGroupMembershipsResponse(
      groupMemberList: (json['GroupMemberList'] as List?)
          ?.whereNotNull()
          .map((e) => GroupMember.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupMemberList = this.groupMemberList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (groupMemberList != null) 'GroupMemberList': groupMemberList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListGroupsResponse {
  /// The list of the groups.
  final List<Group>? groupList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListGroupsResponse({
    this.groupList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListGroupsResponse.fromJson(Map<String, dynamic> json) {
    return ListGroupsResponse(
      groupList: (json['GroupList'] as List?)
          ?.whereNotNull()
          .map((e) => Group.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupList = this.groupList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (groupList != null) 'GroupList': groupList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListIAMPolicyAssignmentsForUserResponse {
  /// The active assignments for this user.
  final List<ActiveIAMPolicyAssignment>? activeAssignments;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListIAMPolicyAssignmentsForUserResponse({
    this.activeAssignments,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListIAMPolicyAssignmentsForUserResponse.fromJson(
      Map<String, dynamic> json) {
    return ListIAMPolicyAssignmentsForUserResponse(
      activeAssignments: (json['ActiveAssignments'] as List?)
          ?.whereNotNull()
          .map((e) =>
              ActiveIAMPolicyAssignment.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final activeAssignments = this.activeAssignments;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (activeAssignments != null) 'ActiveAssignments': activeAssignments,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListIAMPolicyAssignmentsResponse {
  /// Information describing the IAM policy assignments.
  final List<IAMPolicyAssignmentSummary>? iAMPolicyAssignments;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListIAMPolicyAssignmentsResponse({
    this.iAMPolicyAssignments,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListIAMPolicyAssignmentsResponse.fromJson(Map<String, dynamic> json) {
    return ListIAMPolicyAssignmentsResponse(
      iAMPolicyAssignments: (json['IAMPolicyAssignments'] as List?)
          ?.whereNotNull()
          .map((e) =>
              IAMPolicyAssignmentSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final iAMPolicyAssignments = this.iAMPolicyAssignments;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (iAMPolicyAssignments != null)
        'IAMPolicyAssignments': iAMPolicyAssignments,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListIdentityPropagationConfigsResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// A list of services and their authorized targets that the Amazon QuickSight
  /// IAM Identity Center application can access.
  final List<AuthorizedTargetsByService>? services;

  /// The HTTP status of the request.
  final int? status;

  ListIdentityPropagationConfigsResponse({
    this.nextToken,
    this.requestId,
    this.services,
    this.status,
  });

  factory ListIdentityPropagationConfigsResponse.fromJson(
      Map<String, dynamic> json) {
    return ListIdentityPropagationConfigsResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      services: (json['Services'] as List?)
          ?.whereNotNull()
          .map((e) =>
              AuthorizedTargetsByService.fromJson(e as Map<String, dynamic>))
          .toList(),
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final services = this.services;
    final status = this.status;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (services != null) 'Services': services,
    };
  }
}

class ListIngestionsResponse {
  /// A list of the ingestions.
  final List<Ingestion>? ingestions;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListIngestionsResponse({
    this.ingestions,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListIngestionsResponse.fromJson(Map<String, dynamic> json) {
    return ListIngestionsResponse(
      ingestions: (json['Ingestions'] as List?)
          ?.whereNotNull()
          .map((e) => Ingestion.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final ingestions = this.ingestions;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (ingestions != null) 'Ingestions': ingestions,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListNamespacesResponse {
  /// The information about the namespaces in this Amazon Web Services account.
  /// The response includes the namespace ARN, name, Amazon Web Services Region,
  /// notification email address, creation status, and identity store.
  final List<NamespaceInfoV2>? namespaces;

  /// A unique pagination token that can be used in a subsequent request.
  /// Receiving <code>NextToken</code> in your response inticates that there is
  /// more data that can be returned. To receive the data, make another
  /// <code>ListNamespaces</code> API call with the returned token to retrieve the
  /// next page of data. Each token is valid for 24 hours. If you try to make a
  /// <code>ListNamespaces</code> API call with an expired token, you will receive
  /// a <code>HTTP 400 InvalidNextTokenException</code> error.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListNamespacesResponse({
    this.namespaces,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListNamespacesResponse.fromJson(Map<String, dynamic> json) {
    return ListNamespacesResponse(
      namespaces: (json['Namespaces'] as List?)
          ?.whereNotNull()
          .map((e) => NamespaceInfoV2.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final namespaces = this.namespaces;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (namespaces != null) 'Namespaces': namespaces,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListRefreshSchedulesResponse {
  /// The list of refresh schedules for the dataset.
  final List<RefreshSchedule>? refreshSchedules;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListRefreshSchedulesResponse({
    this.refreshSchedules,
    this.requestId,
    this.status,
  });

  factory ListRefreshSchedulesResponse.fromJson(Map<String, dynamic> json) {
    return ListRefreshSchedulesResponse(
      refreshSchedules: (json['RefreshSchedules'] as List?)
          ?.whereNotNull()
          .map((e) => RefreshSchedule.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final refreshSchedules = this.refreshSchedules;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (refreshSchedules != null) 'RefreshSchedules': refreshSchedules,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListRoleMembershipsResponse {
  /// The list of groups associated with a role
  final List<String>? membersList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListRoleMembershipsResponse({
    this.membersList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListRoleMembershipsResponse.fromJson(Map<String, dynamic> json) {
    return ListRoleMembershipsResponse(
      membersList: (json['MembersList'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final membersList = this.membersList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (membersList != null) 'MembersList': membersList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListTagsForResourceResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Contains a map of the key-value pairs for the resource tag or tags assigned
  /// to the resource.
  final List<Tag>? tags;

  ListTagsForResourceResponse({
    this.requestId,
    this.status,
    this.tags,
  });

  factory ListTagsForResourceResponse.fromJson(Map<String, dynamic> json) {
    return ListTagsForResourceResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      tags: (json['Tags'] as List?)
          ?.whereNotNull()
          .map((e) => Tag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final tags = this.tags;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (tags != null) 'Tags': tags,
    };
  }
}

class ListTemplateAliasesResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A structure containing the list of the template's aliases.
  final List<TemplateAlias>? templateAliasList;

  ListTemplateAliasesResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.templateAliasList,
  });

  factory ListTemplateAliasesResponse.fromJson(Map<String, dynamic> json) {
    return ListTemplateAliasesResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateAliasList: (json['TemplateAliasList'] as List?)
          ?.whereNotNull()
          .map((e) => TemplateAlias.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final templateAliasList = this.templateAliasList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (templateAliasList != null) 'TemplateAliasList': templateAliasList,
    };
  }
}

class ListTemplateVersionsResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A structure containing a list of all the versions of the specified template.
  final List<TemplateVersionSummary>? templateVersionSummaryList;

  ListTemplateVersionsResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.templateVersionSummaryList,
  });

  factory ListTemplateVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListTemplateVersionsResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateVersionSummaryList: (json['TemplateVersionSummaryList'] as List?)
          ?.whereNotNull()
          .map(
              (e) => TemplateVersionSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final templateVersionSummaryList = this.templateVersionSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (templateVersionSummaryList != null)
        'TemplateVersionSummaryList': templateVersionSummaryList,
    };
  }
}

class ListTemplatesResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A structure containing information about the templates in the list.
  final List<TemplateSummary>? templateSummaryList;

  ListTemplatesResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.templateSummaryList,
  });

  factory ListTemplatesResponse.fromJson(Map<String, dynamic> json) {
    return ListTemplatesResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateSummaryList: (json['TemplateSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => TemplateSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final templateSummaryList = this.templateSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (templateSummaryList != null)
        'TemplateSummaryList': templateSummaryList,
    };
  }
}

class ListThemeAliasesResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A structure containing the list of the theme's aliases.
  final List<ThemeAlias>? themeAliasList;

  ListThemeAliasesResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.themeAliasList,
  });

  factory ListThemeAliasesResponse.fromJson(Map<String, dynamic> json) {
    return ListThemeAliasesResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeAliasList: (json['ThemeAliasList'] as List?)
          ?.whereNotNull()
          .map((e) => ThemeAlias.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final themeAliasList = this.themeAliasList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (themeAliasList != null) 'ThemeAliasList': themeAliasList,
    };
  }
}

class ListThemeVersionsResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A structure containing a list of all the versions of the specified theme.
  final List<ThemeVersionSummary>? themeVersionSummaryList;

  ListThemeVersionsResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.themeVersionSummaryList,
  });

  factory ListThemeVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListThemeVersionsResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeVersionSummaryList: (json['ThemeVersionSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => ThemeVersionSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final themeVersionSummaryList = this.themeVersionSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (themeVersionSummaryList != null)
        'ThemeVersionSummaryList': themeVersionSummaryList,
    };
  }
}

class ListThemesResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Information about the themes in the list.
  final List<ThemeSummary>? themeSummaryList;

  ListThemesResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.themeSummaryList,
  });

  factory ListThemesResponse.fromJson(Map<String, dynamic> json) {
    return ListThemesResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeSummaryList: (json['ThemeSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => ThemeSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final themeSummaryList = this.themeSummaryList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (themeSummaryList != null) 'ThemeSummaryList': themeSummaryList,
    };
  }
}

class ListTopicRefreshSchedulesResponse {
  /// The list of topic refresh schedules.
  final List<TopicRefreshScheduleSummary>? refreshSchedules;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID for the topic that you want to describe. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  ListTopicRefreshSchedulesResponse({
    this.refreshSchedules,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory ListTopicRefreshSchedulesResponse.fromJson(
      Map<String, dynamic> json) {
    return ListTopicRefreshSchedulesResponse(
      refreshSchedules: (json['RefreshSchedules'] as List?)
          ?.whereNotNull()
          .map((e) =>
              TopicRefreshScheduleSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final refreshSchedules = this.refreshSchedules;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (refreshSchedules != null) 'RefreshSchedules': refreshSchedules,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class ListTopicsResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A list of topic summaries.
  final List<TopicSummary>? topicsSummaries;

  ListTopicsResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.topicsSummaries,
  });

  factory ListTopicsResponse.fromJson(Map<String, dynamic> json) {
    return ListTopicsResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicsSummaries: (json['TopicsSummaries'] as List?)
          ?.whereNotNull()
          .map((e) => TopicSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final topicsSummaries = this.topicsSummaries;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (topicsSummaries != null) 'TopicsSummaries': topicsSummaries,
    };
  }
}

class ListUserGroupsResponse {
  /// The list of groups the user is a member of.
  final List<Group>? groupList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  ListUserGroupsResponse({
    this.groupList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory ListUserGroupsResponse.fromJson(Map<String, dynamic> json) {
    return ListUserGroupsResponse(
      groupList: (json['GroupList'] as List?)
          ?.whereNotNull()
          .map((e) => Group.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupList = this.groupList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (groupList != null) 'GroupList': groupList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class ListUsersResponse {
  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The list of users.
  final List<User>? userList;

  ListUsersResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.userList,
  });

  factory ListUsersResponse.fromJson(Map<String, dynamic> json) {
    return ListUsersResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      userList: (json['UserList'] as List?)
          ?.whereNotNull()
          .map((e) => User.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final userList = this.userList;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (userList != null) 'UserList': userList,
    };
  }
}

class ListVPCConnectionsResponse {
  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// A <code>VPCConnectionSummaries</code> object that returns a summary of VPC
  /// connection objects.
  final List<VPCConnectionSummary>? vPCConnectionSummaries;

  ListVPCConnectionsResponse({
    this.nextToken,
    this.requestId,
    this.status,
    this.vPCConnectionSummaries,
  });

  factory ListVPCConnectionsResponse.fromJson(Map<String, dynamic> json) {
    return ListVPCConnectionsResponse(
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      vPCConnectionSummaries: (json['VPCConnectionSummaries'] as List?)
          ?.whereNotNull()
          .map((e) => VPCConnectionSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    final vPCConnectionSummaries = this.vPCConnectionSummaries;
    return {
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
      if (vPCConnectionSummaries != null)
        'VPCConnectionSummaries': vPCConnectionSummaries,
    };
  }
}

/// The configuration of loading animation in free-form layout.
class LoadingAnimation {
  /// The visibility configuration of <code>LoadingAnimation</code>.
  final Visibility? visibility;

  LoadingAnimation({
    this.visibility,
  });

  factory LoadingAnimation.fromJson(Map<String, dynamic> json) {
    return LoadingAnimation(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The navigation configuration for
/// <code>CustomActionNavigationOperation</code>.
class LocalNavigationConfiguration {
  /// The sheet that is targeted for navigation in the same analysis.
  final String targetSheetId;

  LocalNavigationConfiguration({
    required this.targetSheetId,
  });

  factory LocalNavigationConfiguration.fromJson(Map<String, dynamic> json) {
    return LocalNavigationConfiguration(
      targetSheetId: json['TargetSheetId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final targetSheetId = this.targetSheetId;
    return {
      'TargetSheetId': targetSheetId,
    };
  }
}

/// A <i>logical table</i> is a unit that joins and that data transformations
/// operate on. A logical table has a source, which can be either a physical
/// table or result of a join. When a logical table points to a physical table,
/// the logical table acts as a mutable copy of that physical table through
/// transform operations.
class LogicalTable {
  /// A display name for the logical table.
  final String alias;

  /// Source of this logical table.
  final LogicalTableSource source;

  /// Transform operations that act on this logical table. For this structure to
  /// be valid, only one of the attributes can be non-null.
  final List<TransformOperation>? dataTransforms;

  LogicalTable({
    required this.alias,
    required this.source,
    this.dataTransforms,
  });

  factory LogicalTable.fromJson(Map<String, dynamic> json) {
    return LogicalTable(
      alias: json['Alias'] as String,
      source:
          LogicalTableSource.fromJson(json['Source'] as Map<String, dynamic>),
      dataTransforms: (json['DataTransforms'] as List?)
          ?.whereNotNull()
          .map((e) => TransformOperation.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final alias = this.alias;
    final source = this.source;
    final dataTransforms = this.dataTransforms;
    return {
      'Alias': alias,
      'Source': source,
      if (dataTransforms != null) 'DataTransforms': dataTransforms,
    };
  }
}

/// Information about the source of a logical table. This is a variant type
/// structure. For this structure to be valid, only one of the attributes can be
/// non-null.
class LogicalTableSource {
  /// The Amazon Resource Number (ARN) of the parent dataset.
  final String? dataSetArn;

  /// Specifies the result of a join of two logical tables.
  final JoinInstruction? joinInstruction;

  /// Physical table ID.
  final String? physicalTableId;

  LogicalTableSource({
    this.dataSetArn,
    this.joinInstruction,
    this.physicalTableId,
  });

  factory LogicalTableSource.fromJson(Map<String, dynamic> json) {
    return LogicalTableSource(
      dataSetArn: json['DataSetArn'] as String?,
      joinInstruction: json['JoinInstruction'] != null
          ? JoinInstruction.fromJson(
              json['JoinInstruction'] as Map<String, dynamic>)
          : null,
      physicalTableId: json['PhysicalTableId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetArn = this.dataSetArn;
    final joinInstruction = this.joinInstruction;
    final physicalTableId = this.physicalTableId;
    return {
      if (dataSetArn != null) 'DataSetArn': dataSetArn,
      if (joinInstruction != null) 'JoinInstruction': joinInstruction,
      if (physicalTableId != null) 'PhysicalTableId': physicalTableId,
    };
  }
}

/// The text format for a subtitle.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class LongFormatText {
  /// Plain text format.
  final String? plainText;

  /// Rich text. Examples of rich text include bold, underline, and italics.
  final String? richText;

  LongFormatText({
    this.plainText,
    this.richText,
  });

  factory LongFormatText.fromJson(Map<String, dynamic> json) {
    return LongFormatText(
      plainText: json['PlainText'] as String?,
      richText: json['RichText'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final plainText = this.plainText;
    final richText = this.richText;
    return {
      if (plainText != null) 'PlainText': plainText,
      if (richText != null) 'RichText': richText,
    };
  }
}

/// The lookback window setup of an incremental refresh configuration.
class LookbackWindow {
  /// The name of the lookback window column.
  final String columnName;

  /// The lookback window column size.
  final int size;

  /// The size unit that is used for the lookback window column. Valid values for
  /// this structure are <code>HOUR</code>, <code>DAY</code>, and
  /// <code>WEEK</code>.
  final LookbackWindowSizeUnit sizeUnit;

  LookbackWindow({
    required this.columnName,
    required this.size,
    required this.sizeUnit,
  });

  factory LookbackWindow.fromJson(Map<String, dynamic> json) {
    return LookbackWindow(
      columnName: json['ColumnName'] as String,
      size: json['Size'] as int,
      sizeUnit: (json['SizeUnit'] as String).toLookbackWindowSizeUnit(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final size = this.size;
    final sizeUnit = this.sizeUnit;
    return {
      'ColumnName': columnName,
      'Size': size,
      'SizeUnit': sizeUnit.toValue(),
    };
  }
}

enum LookbackWindowSizeUnit {
  hour,
  day,
  week,
}

extension LookbackWindowSizeUnitValueExtension on LookbackWindowSizeUnit {
  String toValue() {
    switch (this) {
      case LookbackWindowSizeUnit.hour:
        return 'HOUR';
      case LookbackWindowSizeUnit.day:
        return 'DAY';
      case LookbackWindowSizeUnit.week:
        return 'WEEK';
    }
  }
}

extension LookbackWindowSizeUnitFromString on String {
  LookbackWindowSizeUnit toLookbackWindowSizeUnit() {
    switch (this) {
      case 'HOUR':
        return LookbackWindowSizeUnit.hour;
      case 'DAY':
        return LookbackWindowSizeUnit.day;
      case 'WEEK':
        return LookbackWindowSizeUnit.week;
    }
    throw Exception('$this is not known in enum LookbackWindowSizeUnit');
  }
}

/// Amazon S3 manifest file location.
class ManifestFileLocation {
  /// Amazon S3 bucket.
  final String bucket;

  /// Amazon S3 key that identifies an object.
  final String key;

  ManifestFileLocation({
    required this.bucket,
    required this.key,
  });

  factory ManifestFileLocation.fromJson(Map<String, dynamic> json) {
    return ManifestFileLocation(
      bucket: json['Bucket'] as String,
      key: json['Key'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final bucket = this.bucket;
    final key = this.key;
    return {
      'Bucket': bucket,
      'Key': key,
    };
  }
}

enum MapZoomMode {
  auto,
  manual,
}

extension MapZoomModeValueExtension on MapZoomMode {
  String toValue() {
    switch (this) {
      case MapZoomMode.auto:
        return 'AUTO';
      case MapZoomMode.manual:
        return 'MANUAL';
    }
  }
}

extension MapZoomModeFromString on String {
  MapZoomMode toMapZoomMode() {
    switch (this) {
      case 'AUTO':
        return MapZoomMode.auto;
      case 'MANUAL':
        return MapZoomMode.manual;
    }
    throw Exception('$this is not known in enum MapZoomMode');
  }
}

/// A dataset parameter that is mapped to an analysis parameter.
class MappedDataSetParameter {
  /// A unique name that identifies a dataset within the analysis or dashboard.
  final String dataSetIdentifier;

  /// The name of the dataset parameter.
  final String dataSetParameterName;

  MappedDataSetParameter({
    required this.dataSetIdentifier,
    required this.dataSetParameterName,
  });

  factory MappedDataSetParameter.fromJson(Map<String, dynamic> json) {
    return MappedDataSetParameter(
      dataSetIdentifier: json['DataSetIdentifier'] as String,
      dataSetParameterName: json['DataSetParameterName'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetIdentifier = this.dataSetIdentifier;
    final dataSetParameterName = this.dataSetParameterName;
    return {
      'DataSetIdentifier': dataSetIdentifier,
      'DataSetParameterName': dataSetParameterName,
    };
  }
}

/// The display options for margins around the outside edge of sheets.
class MarginStyle {
  /// This Boolean value controls whether to display sheet margins.
  final bool? show;

  MarginStyle({
    this.show,
  });

  factory MarginStyle.fromJson(Map<String, dynamic> json) {
    return MarginStyle(
      show: json['Show'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final show = this.show;
    return {
      if (show != null) 'Show': show,
    };
  }
}

/// The parameters for MariaDB.
class MariaDbParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Port.
  final int port;

  MariaDbParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory MariaDbParameters.fromJson(Map<String, dynamic> json) {
    return MariaDbParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

/// The maximum label of a data path label.
class MaximumLabelType {
  /// The visibility of the maximum label.
  final Visibility? visibility;

  MaximumLabelType({
    this.visibility,
  });

  factory MaximumLabelType.fromJson(Map<String, dynamic> json) {
    return MaximumLabelType(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The maximum and minimum computation configuration.
class MaximumMinimumComputation {
  /// The ID for a computation.
  final String computationId;

  /// The type of computation. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// MAXIMUM: A maximum computation.
  /// </li>
  /// <li>
  /// MINIMUM: A minimum computation.
  /// </li>
  /// </ul>
  final MaximumMinimumComputationType type;

  /// The name of a computation.
  final String? name;

  /// The time field that is used in a computation.
  final DimensionField? time;

  /// The value field that is used in a computation.
  final MeasureField? value;

  MaximumMinimumComputation({
    required this.computationId,
    required this.type,
    this.name,
    this.time,
    this.value,
  });

  factory MaximumMinimumComputation.fromJson(Map<String, dynamic> json) {
    return MaximumMinimumComputation(
      computationId: json['ComputationId'] as String,
      type: (json['Type'] as String).toMaximumMinimumComputationType(),
      name: json['Name'] as String?,
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final type = this.type;
    final name = this.name;
    final time = this.time;
    final value = this.value;
    return {
      'ComputationId': computationId,
      'Type': type.toValue(),
      if (name != null) 'Name': name,
      if (time != null) 'Time': time,
      if (value != null) 'Value': value,
    };
  }
}

enum MaximumMinimumComputationType {
  maximum,
  minimum,
}

extension MaximumMinimumComputationTypeValueExtension
    on MaximumMinimumComputationType {
  String toValue() {
    switch (this) {
      case MaximumMinimumComputationType.maximum:
        return 'MAXIMUM';
      case MaximumMinimumComputationType.minimum:
        return 'MINIMUM';
    }
  }
}

extension MaximumMinimumComputationTypeFromString on String {
  MaximumMinimumComputationType toMaximumMinimumComputationType() {
    switch (this) {
      case 'MAXIMUM':
        return MaximumMinimumComputationType.maximum;
      case 'MINIMUM':
        return MaximumMinimumComputationType.minimum;
    }
    throw Exception('$this is not known in enum MaximumMinimumComputationType');
  }
}

/// The measure (metric) type field.
class MeasureField {
  /// The calculated measure field only used in pivot tables.
  final CalculatedMeasureField? calculatedMeasureField;

  /// The measure type field with categorical type columns.
  final CategoricalMeasureField? categoricalMeasureField;

  /// The measure type field with date type columns.
  final DateMeasureField? dateMeasureField;

  /// The measure type field with numerical type columns.
  final NumericalMeasureField? numericalMeasureField;

  MeasureField({
    this.calculatedMeasureField,
    this.categoricalMeasureField,
    this.dateMeasureField,
    this.numericalMeasureField,
  });

  factory MeasureField.fromJson(Map<String, dynamic> json) {
    return MeasureField(
      calculatedMeasureField: json['CalculatedMeasureField'] != null
          ? CalculatedMeasureField.fromJson(
              json['CalculatedMeasureField'] as Map<String, dynamic>)
          : null,
      categoricalMeasureField: json['CategoricalMeasureField'] != null
          ? CategoricalMeasureField.fromJson(
              json['CategoricalMeasureField'] as Map<String, dynamic>)
          : null,
      dateMeasureField: json['DateMeasureField'] != null
          ? DateMeasureField.fromJson(
              json['DateMeasureField'] as Map<String, dynamic>)
          : null,
      numericalMeasureField: json['NumericalMeasureField'] != null
          ? NumericalMeasureField.fromJson(
              json['NumericalMeasureField'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final calculatedMeasureField = this.calculatedMeasureField;
    final categoricalMeasureField = this.categoricalMeasureField;
    final dateMeasureField = this.dateMeasureField;
    final numericalMeasureField = this.numericalMeasureField;
    return {
      if (calculatedMeasureField != null)
        'CalculatedMeasureField': calculatedMeasureField,
      if (categoricalMeasureField != null)
        'CategoricalMeasureField': categoricalMeasureField,
      if (dateMeasureField != null) 'DateMeasureField': dateMeasureField,
      if (numericalMeasureField != null)
        'NumericalMeasureField': numericalMeasureField,
    };
  }
}

/// An object that consists of a member Amazon Resource Name (ARN) and a member
/// ID.
class MemberIdArnPair {
  /// The Amazon Resource Name (ARN) of the member.
  final String? memberArn;

  /// The ID of the member.
  final String? memberId;

  MemberIdArnPair({
    this.memberArn,
    this.memberId,
  });

  factory MemberIdArnPair.fromJson(Map<String, dynamic> json) {
    return MemberIdArnPair(
      memberArn: json['MemberArn'] as String?,
      memberId: json['MemberId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final memberArn = this.memberArn;
    final memberId = this.memberId;
    return {
      if (memberArn != null) 'MemberArn': memberArn,
      if (memberId != null) 'MemberId': memberId,
    };
  }
}

enum MemberType {
  dashboard,
  analysis,
  dataset,
  datasource,
  topic,
}

extension MemberTypeValueExtension on MemberType {
  String toValue() {
    switch (this) {
      case MemberType.dashboard:
        return 'DASHBOARD';
      case MemberType.analysis:
        return 'ANALYSIS';
      case MemberType.dataset:
        return 'DATASET';
      case MemberType.datasource:
        return 'DATASOURCE';
      case MemberType.topic:
        return 'TOPIC';
    }
  }
}

extension MemberTypeFromString on String {
  MemberType toMemberType() {
    switch (this) {
      case 'DASHBOARD':
        return MemberType.dashboard;
      case 'ANALYSIS':
        return MemberType.analysis;
      case 'DATASET':
        return MemberType.dataset;
      case 'DATASOURCE':
        return MemberType.datasource;
      case 'TOPIC':
        return MemberType.topic;
    }
    throw Exception('$this is not known in enum MemberType');
  }
}

/// The metric comparison computation configuration.
class MetricComparisonComputation {
  /// The ID for a computation.
  final String computationId;

  /// The field that is used in a metric comparison from value setup.
  final MeasureField? fromValue;

  /// The name of a computation.
  final String? name;

  /// The field that is used in a metric comparison to value setup.
  final MeasureField? targetValue;

  /// The time field that is used in a computation.
  final DimensionField? time;

  MetricComparisonComputation({
    required this.computationId,
    this.fromValue,
    this.name,
    this.targetValue,
    this.time,
  });

  factory MetricComparisonComputation.fromJson(Map<String, dynamic> json) {
    return MetricComparisonComputation(
      computationId: json['ComputationId'] as String,
      fromValue: json['FromValue'] != null
          ? MeasureField.fromJson(json['FromValue'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      targetValue: json['TargetValue'] != null
          ? MeasureField.fromJson(json['TargetValue'] as Map<String, dynamic>)
          : null,
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final fromValue = this.fromValue;
    final name = this.name;
    final targetValue = this.targetValue;
    final time = this.time;
    return {
      'ComputationId': computationId,
      if (fromValue != null) 'FromValue': fromValue,
      if (name != null) 'Name': name,
      if (targetValue != null) 'TargetValue': targetValue,
      if (time != null) 'Time': time,
    };
  }
}

/// The minimum label of a data path label.
class MinimumLabelType {
  /// The visibility of the minimum label.
  final Visibility? visibility;

  MinimumLabelType({
    this.visibility,
  });

  factory MinimumLabelType.fromJson(Map<String, dynamic> json) {
    return MinimumLabelType(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The configuration options that determine how missing data is treated during
/// the rendering of a line chart.
class MissingDataConfiguration {
  /// The treatment option that determines how missing data should be rendered.
  /// Choose from the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>INTERPOLATE</code>: Interpolate missing values between the prior and
  /// the next known value.
  /// </li>
  /// <li>
  /// <code>SHOW_AS_ZERO</code>: Show missing values as the value <code>0</code>.
  /// </li>
  /// <li>
  /// <code>SHOW_AS_BLANK</code>: Display a blank space when rendering missing
  /// data.
  /// </li>
  /// </ul>
  final MissingDataTreatmentOption? treatmentOption;

  MissingDataConfiguration({
    this.treatmentOption,
  });

  factory MissingDataConfiguration.fromJson(Map<String, dynamic> json) {
    return MissingDataConfiguration(
      treatmentOption:
          (json['TreatmentOption'] as String?)?.toMissingDataTreatmentOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final treatmentOption = this.treatmentOption;
    return {
      if (treatmentOption != null) 'TreatmentOption': treatmentOption.toValue(),
    };
  }
}

enum MissingDataTreatmentOption {
  interpolate,
  showAsZero,
  showAsBlank,
}

extension MissingDataTreatmentOptionValueExtension
    on MissingDataTreatmentOption {
  String toValue() {
    switch (this) {
      case MissingDataTreatmentOption.interpolate:
        return 'INTERPOLATE';
      case MissingDataTreatmentOption.showAsZero:
        return 'SHOW_AS_ZERO';
      case MissingDataTreatmentOption.showAsBlank:
        return 'SHOW_AS_BLANK';
    }
  }
}

extension MissingDataTreatmentOptionFromString on String {
  MissingDataTreatmentOption toMissingDataTreatmentOption() {
    switch (this) {
      case 'INTERPOLATE':
        return MissingDataTreatmentOption.interpolate;
      case 'SHOW_AS_ZERO':
        return MissingDataTreatmentOption.showAsZero;
      case 'SHOW_AS_BLANK':
        return MissingDataTreatmentOption.showAsBlank;
    }
    throw Exception('$this is not known in enum MissingDataTreatmentOption');
  }
}

/// The parameters for MySQL.
class MySqlParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Port.
  final int port;

  MySqlParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory MySqlParameters.fromJson(Map<String, dynamic> json) {
    return MySqlParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

enum NamedEntityAggType {
  sum,
  min,
  max,
  count,
  average,
  distinctCount,
  stdev,
  stdevp,
  $var,
  varp,
  percentile,
  median,
  custom,
}

extension NamedEntityAggTypeValueExtension on NamedEntityAggType {
  String toValue() {
    switch (this) {
      case NamedEntityAggType.sum:
        return 'SUM';
      case NamedEntityAggType.min:
        return 'MIN';
      case NamedEntityAggType.max:
        return 'MAX';
      case NamedEntityAggType.count:
        return 'COUNT';
      case NamedEntityAggType.average:
        return 'AVERAGE';
      case NamedEntityAggType.distinctCount:
        return 'DISTINCT_COUNT';
      case NamedEntityAggType.stdev:
        return 'STDEV';
      case NamedEntityAggType.stdevp:
        return 'STDEVP';
      case NamedEntityAggType.$var:
        return 'VAR';
      case NamedEntityAggType.varp:
        return 'VARP';
      case NamedEntityAggType.percentile:
        return 'PERCENTILE';
      case NamedEntityAggType.median:
        return 'MEDIAN';
      case NamedEntityAggType.custom:
        return 'CUSTOM';
    }
  }
}

extension NamedEntityAggTypeFromString on String {
  NamedEntityAggType toNamedEntityAggType() {
    switch (this) {
      case 'SUM':
        return NamedEntityAggType.sum;
      case 'MIN':
        return NamedEntityAggType.min;
      case 'MAX':
        return NamedEntityAggType.max;
      case 'COUNT':
        return NamedEntityAggType.count;
      case 'AVERAGE':
        return NamedEntityAggType.average;
      case 'DISTINCT_COUNT':
        return NamedEntityAggType.distinctCount;
      case 'STDEV':
        return NamedEntityAggType.stdev;
      case 'STDEVP':
        return NamedEntityAggType.stdevp;
      case 'VAR':
        return NamedEntityAggType.$var;
      case 'VARP':
        return NamedEntityAggType.varp;
      case 'PERCENTILE':
        return NamedEntityAggType.percentile;
      case 'MEDIAN':
        return NamedEntityAggType.median;
      case 'CUSTOM':
        return NamedEntityAggType.custom;
    }
    throw Exception('$this is not known in enum NamedEntityAggType');
  }
}

/// A structure that represents a named entity.
class NamedEntityDefinition {
  /// The name of the entity.
  final String? fieldName;

  /// The definition of a metric.
  final NamedEntityDefinitionMetric? metric;

  /// The property name to be used for the named entity.
  final String? propertyName;

  /// The property role. Valid values for this structure are <code>PRIMARY</code>
  /// and <code>ID</code>.
  final PropertyRole? propertyRole;

  /// The property usage. Valid values for this structure are
  /// <code>INHERIT</code>, <code>DIMENSION</code>, and <code>MEASURE</code>.
  final PropertyUsage? propertyUsage;

  NamedEntityDefinition({
    this.fieldName,
    this.metric,
    this.propertyName,
    this.propertyRole,
    this.propertyUsage,
  });

  factory NamedEntityDefinition.fromJson(Map<String, dynamic> json) {
    return NamedEntityDefinition(
      fieldName: json['FieldName'] as String?,
      metric: json['Metric'] != null
          ? NamedEntityDefinitionMetric.fromJson(
              json['Metric'] as Map<String, dynamic>)
          : null,
      propertyName: json['PropertyName'] as String?,
      propertyRole: (json['PropertyRole'] as String?)?.toPropertyRole(),
      propertyUsage: (json['PropertyUsage'] as String?)?.toPropertyUsage(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldName = this.fieldName;
    final metric = this.metric;
    final propertyName = this.propertyName;
    final propertyRole = this.propertyRole;
    final propertyUsage = this.propertyUsage;
    return {
      if (fieldName != null) 'FieldName': fieldName,
      if (metric != null) 'Metric': metric,
      if (propertyName != null) 'PropertyName': propertyName,
      if (propertyRole != null) 'PropertyRole': propertyRole.toValue(),
      if (propertyUsage != null) 'PropertyUsage': propertyUsage.toValue(),
    };
  }
}

/// A structure that represents a metric.
class NamedEntityDefinitionMetric {
  /// The aggregation of a named entity. Valid values for this structure are
  /// <code>SUM</code>, <code>MIN</code>, <code>MAX</code>, <code>COUNT</code>,
  /// <code>AVERAGE</code>, <code>DISTINCT_COUNT</code>, <code>STDEV</code>,
  /// <code>STDEVP</code>, <code>VAR</code>, <code>VARP</code>,
  /// <code>PERCENTILE</code>, <code>MEDIAN</code>, and <code>CUSTOM</code>.
  final NamedEntityAggType? aggregation;

  /// The additional parameters for an aggregation function.
  final Map<String, String>? aggregationFunctionParameters;

  NamedEntityDefinitionMetric({
    this.aggregation,
    this.aggregationFunctionParameters,
  });

  factory NamedEntityDefinitionMetric.fromJson(Map<String, dynamic> json) {
    return NamedEntityDefinitionMetric(
      aggregation: (json['Aggregation'] as String?)?.toNamedEntityAggType(),
      aggregationFunctionParameters:
          (json['AggregationFunctionParameters'] as Map<String, dynamic>?)
              ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final aggregation = this.aggregation;
    final aggregationFunctionParameters = this.aggregationFunctionParameters;
    return {
      if (aggregation != null) 'Aggregation': aggregation.toValue(),
      if (aggregationFunctionParameters != null)
        'AggregationFunctionParameters': aggregationFunctionParameters,
    };
  }
}

enum NamedFilterAggType {
  noAggregation,
  sum,
  average,
  count,
  distinctCount,
  max,
  median,
  min,
  stdev,
  stdevp,
  $var,
  varp,
}

extension NamedFilterAggTypeValueExtension on NamedFilterAggType {
  String toValue() {
    switch (this) {
      case NamedFilterAggType.noAggregation:
        return 'NO_AGGREGATION';
      case NamedFilterAggType.sum:
        return 'SUM';
      case NamedFilterAggType.average:
        return 'AVERAGE';
      case NamedFilterAggType.count:
        return 'COUNT';
      case NamedFilterAggType.distinctCount:
        return 'DISTINCT_COUNT';
      case NamedFilterAggType.max:
        return 'MAX';
      case NamedFilterAggType.median:
        return 'MEDIAN';
      case NamedFilterAggType.min:
        return 'MIN';
      case NamedFilterAggType.stdev:
        return 'STDEV';
      case NamedFilterAggType.stdevp:
        return 'STDEVP';
      case NamedFilterAggType.$var:
        return 'VAR';
      case NamedFilterAggType.varp:
        return 'VARP';
    }
  }
}

extension NamedFilterAggTypeFromString on String {
  NamedFilterAggType toNamedFilterAggType() {
    switch (this) {
      case 'NO_AGGREGATION':
        return NamedFilterAggType.noAggregation;
      case 'SUM':
        return NamedFilterAggType.sum;
      case 'AVERAGE':
        return NamedFilterAggType.average;
      case 'COUNT':
        return NamedFilterAggType.count;
      case 'DISTINCT_COUNT':
        return NamedFilterAggType.distinctCount;
      case 'MAX':
        return NamedFilterAggType.max;
      case 'MEDIAN':
        return NamedFilterAggType.median;
      case 'MIN':
        return NamedFilterAggType.min;
      case 'STDEV':
        return NamedFilterAggType.stdev;
      case 'STDEVP':
        return NamedFilterAggType.stdevp;
      case 'VAR':
        return NamedFilterAggType.$var;
      case 'VARP':
        return NamedFilterAggType.varp;
    }
    throw Exception('$this is not known in enum NamedFilterAggType');
  }
}

enum NamedFilterType {
  categoryFilter,
  numericEqualityFilter,
  numericRangeFilter,
  dateRangeFilter,
  relativeDateFilter,
}

extension NamedFilterTypeValueExtension on NamedFilterType {
  String toValue() {
    switch (this) {
      case NamedFilterType.categoryFilter:
        return 'CATEGORY_FILTER';
      case NamedFilterType.numericEqualityFilter:
        return 'NUMERIC_EQUALITY_FILTER';
      case NamedFilterType.numericRangeFilter:
        return 'NUMERIC_RANGE_FILTER';
      case NamedFilterType.dateRangeFilter:
        return 'DATE_RANGE_FILTER';
      case NamedFilterType.relativeDateFilter:
        return 'RELATIVE_DATE_FILTER';
    }
  }
}

extension NamedFilterTypeFromString on String {
  NamedFilterType toNamedFilterType() {
    switch (this) {
      case 'CATEGORY_FILTER':
        return NamedFilterType.categoryFilter;
      case 'NUMERIC_EQUALITY_FILTER':
        return NamedFilterType.numericEqualityFilter;
      case 'NUMERIC_RANGE_FILTER':
        return NamedFilterType.numericRangeFilter;
      case 'DATE_RANGE_FILTER':
        return NamedFilterType.dateRangeFilter;
      case 'RELATIVE_DATE_FILTER':
        return NamedFilterType.relativeDateFilter;
    }
    throw Exception('$this is not known in enum NamedFilterType');
  }
}

/// Errors that occur during namespace creation.
class NamespaceError {
  /// The message for the error.
  final String? message;

  /// The error type.
  final NamespaceErrorType? type;

  NamespaceError({
    this.message,
    this.type,
  });

  factory NamespaceError.fromJson(Map<String, dynamic> json) {
    return NamespaceError(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toNamespaceErrorType(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum NamespaceErrorType {
  permissionDenied,
  internalServiceError,
}

extension NamespaceErrorTypeValueExtension on NamespaceErrorType {
  String toValue() {
    switch (this) {
      case NamespaceErrorType.permissionDenied:
        return 'PERMISSION_DENIED';
      case NamespaceErrorType.internalServiceError:
        return 'INTERNAL_SERVICE_ERROR';
    }
  }
}

extension NamespaceErrorTypeFromString on String {
  NamespaceErrorType toNamespaceErrorType() {
    switch (this) {
      case 'PERMISSION_DENIED':
        return NamespaceErrorType.permissionDenied;
      case 'INTERNAL_SERVICE_ERROR':
        return NamespaceErrorType.internalServiceError;
    }
    throw Exception('$this is not known in enum NamespaceErrorType');
  }
}

/// The error type.
class NamespaceInfoV2 {
  /// The namespace ARN.
  final String? arn;

  /// The namespace Amazon Web Services Region.
  final String? capacityRegion;

  /// The creation status of a namespace that is not yet completely created.
  final NamespaceStatus? creationStatus;

  /// The identity store used for the namespace.
  final IdentityStore? identityStore;

  /// The name of the error.
  final String? name;

  /// An error that occurred when the namespace was created.
  final NamespaceError? namespaceError;

  NamespaceInfoV2({
    this.arn,
    this.capacityRegion,
    this.creationStatus,
    this.identityStore,
    this.name,
    this.namespaceError,
  });

  factory NamespaceInfoV2.fromJson(Map<String, dynamic> json) {
    return NamespaceInfoV2(
      arn: json['Arn'] as String?,
      capacityRegion: json['CapacityRegion'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toNamespaceStatus(),
      identityStore: (json['IdentityStore'] as String?)?.toIdentityStore(),
      name: json['Name'] as String?,
      namespaceError: json['NamespaceError'] != null
          ? NamespaceError.fromJson(
              json['NamespaceError'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final capacityRegion = this.capacityRegion;
    final creationStatus = this.creationStatus;
    final identityStore = this.identityStore;
    final name = this.name;
    final namespaceError = this.namespaceError;
    return {
      if (arn != null) 'Arn': arn,
      if (capacityRegion != null) 'CapacityRegion': capacityRegion,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (identityStore != null) 'IdentityStore': identityStore.toValue(),
      if (name != null) 'Name': name,
      if (namespaceError != null) 'NamespaceError': namespaceError,
    };
  }
}

enum NamespaceStatus {
  created,
  creating,
  deleting,
  retryableFailure,
  nonRetryableFailure,
}

extension NamespaceStatusValueExtension on NamespaceStatus {
  String toValue() {
    switch (this) {
      case NamespaceStatus.created:
        return 'CREATED';
      case NamespaceStatus.creating:
        return 'CREATING';
      case NamespaceStatus.deleting:
        return 'DELETING';
      case NamespaceStatus.retryableFailure:
        return 'RETRYABLE_FAILURE';
      case NamespaceStatus.nonRetryableFailure:
        return 'NON_RETRYABLE_FAILURE';
    }
  }
}

extension NamespaceStatusFromString on String {
  NamespaceStatus toNamespaceStatus() {
    switch (this) {
      case 'CREATED':
        return NamespaceStatus.created;
      case 'CREATING':
        return NamespaceStatus.creating;
      case 'DELETING':
        return NamespaceStatus.deleting;
      case 'RETRYABLE_FAILURE':
        return NamespaceStatus.retryableFailure;
      case 'NON_RETRYABLE_FAILURE':
        return NamespaceStatus.nonRetryableFailure;
    }
    throw Exception('$this is not known in enum NamespaceStatus');
  }
}

/// A structure that represents a negative format.
class NegativeFormat {
  /// The prefix for a negative format.
  final String? prefix;

  /// The suffix for a negative format.
  final String? suffix;

  NegativeFormat({
    this.prefix,
    this.suffix,
  });

  factory NegativeFormat.fromJson(Map<String, dynamic> json) {
    return NegativeFormat(
      prefix: json['Prefix'] as String?,
      suffix: json['Suffix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final prefix = this.prefix;
    final suffix = this.suffix;
    return {
      if (prefix != null) 'Prefix': prefix,
      if (suffix != null) 'Suffix': suffix,
    };
  }
}

/// The options that determine the negative value configuration.
class NegativeValueConfiguration {
  /// Determines the display mode of the negative value configuration.
  final NegativeValueDisplayMode displayMode;

  NegativeValueConfiguration({
    required this.displayMode,
  });

  factory NegativeValueConfiguration.fromJson(Map<String, dynamic> json) {
    return NegativeValueConfiguration(
      displayMode: (json['DisplayMode'] as String).toNegativeValueDisplayMode(),
    );
  }

  Map<String, dynamic> toJson() {
    final displayMode = this.displayMode;
    return {
      'DisplayMode': displayMode.toValue(),
    };
  }
}

enum NegativeValueDisplayMode {
  positive,
  negative,
}

extension NegativeValueDisplayModeValueExtension on NegativeValueDisplayMode {
  String toValue() {
    switch (this) {
      case NegativeValueDisplayMode.positive:
        return 'POSITIVE';
      case NegativeValueDisplayMode.negative:
        return 'NEGATIVE';
    }
  }
}

extension NegativeValueDisplayModeFromString on String {
  NegativeValueDisplayMode toNegativeValueDisplayMode() {
    switch (this) {
      case 'POSITIVE':
        return NegativeValueDisplayMode.positive;
      case 'NEGATIVE':
        return NegativeValueDisplayMode.negative;
    }
    throw Exception('$this is not known in enum NegativeValueDisplayMode');
  }
}

/// The structure that contains information about a network interface.
class NetworkInterface {
  /// The availability zone that the network interface resides in.
  final String? availabilityZone;

  /// An error message.
  final String? errorMessage;

  /// The network interface ID.
  final String? networkInterfaceId;

  /// The status of the network interface.
  final NetworkInterfaceStatus? status;

  /// The subnet ID associated with the network interface.
  final String? subnetId;

  NetworkInterface({
    this.availabilityZone,
    this.errorMessage,
    this.networkInterfaceId,
    this.status,
    this.subnetId,
  });

  factory NetworkInterface.fromJson(Map<String, dynamic> json) {
    return NetworkInterface(
      availabilityZone: json['AvailabilityZone'] as String?,
      errorMessage: json['ErrorMessage'] as String?,
      networkInterfaceId: json['NetworkInterfaceId'] as String?,
      status: (json['Status'] as String?)?.toNetworkInterfaceStatus(),
      subnetId: json['SubnetId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityZone = this.availabilityZone;
    final errorMessage = this.errorMessage;
    final networkInterfaceId = this.networkInterfaceId;
    final status = this.status;
    final subnetId = this.subnetId;
    return {
      if (availabilityZone != null) 'AvailabilityZone': availabilityZone,
      if (errorMessage != null) 'ErrorMessage': errorMessage,
      if (networkInterfaceId != null) 'NetworkInterfaceId': networkInterfaceId,
      if (status != null) 'Status': status.toValue(),
      if (subnetId != null) 'SubnetId': subnetId,
    };
  }
}

enum NetworkInterfaceStatus {
  creating,
  available,
  creationFailed,
  updating,
  updateFailed,
  deleting,
  deleted,
  deletionFailed,
  deletionScheduled,
  attachmentFailedRollbackFailed,
}

extension NetworkInterfaceStatusValueExtension on NetworkInterfaceStatus {
  String toValue() {
    switch (this) {
      case NetworkInterfaceStatus.creating:
        return 'CREATING';
      case NetworkInterfaceStatus.available:
        return 'AVAILABLE';
      case NetworkInterfaceStatus.creationFailed:
        return 'CREATION_FAILED';
      case NetworkInterfaceStatus.updating:
        return 'UPDATING';
      case NetworkInterfaceStatus.updateFailed:
        return 'UPDATE_FAILED';
      case NetworkInterfaceStatus.deleting:
        return 'DELETING';
      case NetworkInterfaceStatus.deleted:
        return 'DELETED';
      case NetworkInterfaceStatus.deletionFailed:
        return 'DELETION_FAILED';
      case NetworkInterfaceStatus.deletionScheduled:
        return 'DELETION_SCHEDULED';
      case NetworkInterfaceStatus.attachmentFailedRollbackFailed:
        return 'ATTACHMENT_FAILED_ROLLBACK_FAILED';
    }
  }
}

extension NetworkInterfaceStatusFromString on String {
  NetworkInterfaceStatus toNetworkInterfaceStatus() {
    switch (this) {
      case 'CREATING':
        return NetworkInterfaceStatus.creating;
      case 'AVAILABLE':
        return NetworkInterfaceStatus.available;
      case 'CREATION_FAILED':
        return NetworkInterfaceStatus.creationFailed;
      case 'UPDATING':
        return NetworkInterfaceStatus.updating;
      case 'UPDATE_FAILED':
        return NetworkInterfaceStatus.updateFailed;
      case 'DELETING':
        return NetworkInterfaceStatus.deleting;
      case 'DELETED':
        return NetworkInterfaceStatus.deleted;
      case 'DELETION_FAILED':
        return NetworkInterfaceStatus.deletionFailed;
      case 'DELETION_SCHEDULED':
        return NetworkInterfaceStatus.deletionScheduled;
      case 'ATTACHMENT_FAILED_ROLLBACK_FAILED':
        return NetworkInterfaceStatus.attachmentFailedRollbackFailed;
    }
    throw Exception('$this is not known in enum NetworkInterfaceStatus');
  }
}

/// The configuration that overrides the existing default values for a dataset
/// parameter that is inherited from another dataset.
class NewDefaultValues {
  /// A list of static default values for a given date time parameter.
  final List<DateTime>? dateTimeStaticValues;

  /// A list of static default values for a given decimal parameter.
  final List<double>? decimalStaticValues;

  /// A list of static default values for a given integer parameter.
  final List<int>? integerStaticValues;

  /// A list of static default values for a given string parameter.
  final List<String>? stringStaticValues;

  NewDefaultValues({
    this.dateTimeStaticValues,
    this.decimalStaticValues,
    this.integerStaticValues,
    this.stringStaticValues,
  });

  factory NewDefaultValues.fromJson(Map<String, dynamic> json) {
    return NewDefaultValues(
      dateTimeStaticValues: (json['DateTimeStaticValues'] as List?)
          ?.whereNotNull()
          .map(nonNullableTimeStampFromJson)
          .toList(),
      decimalStaticValues: (json['DecimalStaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as double)
          .toList(),
      integerStaticValues: (json['IntegerStaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as int)
          .toList(),
      stringStaticValues: (json['StringStaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeStaticValues = this.dateTimeStaticValues;
    final decimalStaticValues = this.decimalStaticValues;
    final integerStaticValues = this.integerStaticValues;
    final stringStaticValues = this.stringStaticValues;
    return {
      if (dateTimeStaticValues != null)
        'DateTimeStaticValues':
            dateTimeStaticValues.map(unixTimestampToJson).toList(),
      if (decimalStaticValues != null)
        'DecimalStaticValues': decimalStaticValues,
      if (integerStaticValues != null)
        'IntegerStaticValues': integerStaticValues,
      if (stringStaticValues != null) 'StringStaticValues': stringStaticValues,
    };
  }
}

/// The options that determine the null value format configuration.
class NullValueFormatConfiguration {
  /// Determines the null string of null values.
  final String nullString;

  NullValueFormatConfiguration({
    required this.nullString,
  });

  factory NullValueFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return NullValueFormatConfiguration(
      nullString: json['NullString'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final nullString = this.nullString;
    return {
      'NullString': nullString,
    };
  }
}

/// The options that determine the number display format configuration.
class NumberDisplayFormatConfiguration {
  /// The option that determines the decimal places configuration.
  final DecimalPlacesConfiguration? decimalPlacesConfiguration;

  /// The options that determine the negative value configuration.
  final NegativeValueConfiguration? negativeValueConfiguration;

  /// The options that determine the null value format configuration.
  final NullValueFormatConfiguration? nullValueFormatConfiguration;

  /// Determines the number scale value of the number format.
  final NumberScale? numberScale;

  /// Determines the prefix value of the number format.
  final String? prefix;

  /// The options that determine the numeric separator configuration.
  final NumericSeparatorConfiguration? separatorConfiguration;

  /// Determines the suffix value of the number format.
  final String? suffix;

  NumberDisplayFormatConfiguration({
    this.decimalPlacesConfiguration,
    this.negativeValueConfiguration,
    this.nullValueFormatConfiguration,
    this.numberScale,
    this.prefix,
    this.separatorConfiguration,
    this.suffix,
  });

  factory NumberDisplayFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return NumberDisplayFormatConfiguration(
      decimalPlacesConfiguration: json['DecimalPlacesConfiguration'] != null
          ? DecimalPlacesConfiguration.fromJson(
              json['DecimalPlacesConfiguration'] as Map<String, dynamic>)
          : null,
      negativeValueConfiguration: json['NegativeValueConfiguration'] != null
          ? NegativeValueConfiguration.fromJson(
              json['NegativeValueConfiguration'] as Map<String, dynamic>)
          : null,
      nullValueFormatConfiguration: json['NullValueFormatConfiguration'] != null
          ? NullValueFormatConfiguration.fromJson(
              json['NullValueFormatConfiguration'] as Map<String, dynamic>)
          : null,
      numberScale: (json['NumberScale'] as String?)?.toNumberScale(),
      prefix: json['Prefix'] as String?,
      separatorConfiguration: json['SeparatorConfiguration'] != null
          ? NumericSeparatorConfiguration.fromJson(
              json['SeparatorConfiguration'] as Map<String, dynamic>)
          : null,
      suffix: json['Suffix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final decimalPlacesConfiguration = this.decimalPlacesConfiguration;
    final negativeValueConfiguration = this.negativeValueConfiguration;
    final nullValueFormatConfiguration = this.nullValueFormatConfiguration;
    final numberScale = this.numberScale;
    final prefix = this.prefix;
    final separatorConfiguration = this.separatorConfiguration;
    final suffix = this.suffix;
    return {
      if (decimalPlacesConfiguration != null)
        'DecimalPlacesConfiguration': decimalPlacesConfiguration,
      if (negativeValueConfiguration != null)
        'NegativeValueConfiguration': negativeValueConfiguration,
      if (nullValueFormatConfiguration != null)
        'NullValueFormatConfiguration': nullValueFormatConfiguration,
      if (numberScale != null) 'NumberScale': numberScale.toValue(),
      if (prefix != null) 'Prefix': prefix,
      if (separatorConfiguration != null)
        'SeparatorConfiguration': separatorConfiguration,
      if (suffix != null) 'Suffix': suffix,
    };
  }
}

/// Formatting configuration for number fields.
class NumberFormatConfiguration {
  /// The options that determine the numeric format configuration.
  final NumericFormatConfiguration? formatConfiguration;

  NumberFormatConfiguration({
    this.formatConfiguration,
  });

  factory NumberFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return NumberFormatConfiguration(
      formatConfiguration: json['FormatConfiguration'] != null
          ? NumericFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final formatConfiguration = this.formatConfiguration;
    return {
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
    };
  }
}

enum NumberScale {
  none,
  auto,
  thousands,
  millions,
  billions,
  trillions,
}

extension NumberScaleValueExtension on NumberScale {
  String toValue() {
    switch (this) {
      case NumberScale.none:
        return 'NONE';
      case NumberScale.auto:
        return 'AUTO';
      case NumberScale.thousands:
        return 'THOUSANDS';
      case NumberScale.millions:
        return 'MILLIONS';
      case NumberScale.billions:
        return 'BILLIONS';
      case NumberScale.trillions:
        return 'TRILLIONS';
    }
  }
}

extension NumberScaleFromString on String {
  NumberScale toNumberScale() {
    switch (this) {
      case 'NONE':
        return NumberScale.none;
      case 'AUTO':
        return NumberScale.auto;
      case 'THOUSANDS':
        return NumberScale.thousands;
      case 'MILLIONS':
        return NumberScale.millions;
      case 'BILLIONS':
        return NumberScale.billions;
      case 'TRILLIONS':
        return NumberScale.trillions;
    }
    throw Exception('$this is not known in enum NumberScale');
  }
}

/// The options for an axis with a numeric field.
class NumericAxisOptions {
  /// The range setup of a numeric axis.
  final AxisDisplayRange? range;

  /// The scale setup of a numeric axis.
  final AxisScale? scale;

  NumericAxisOptions({
    this.range,
    this.scale,
  });

  factory NumericAxisOptions.fromJson(Map<String, dynamic> json) {
    return NumericAxisOptions(
      range: json['Range'] != null
          ? AxisDisplayRange.fromJson(json['Range'] as Map<String, dynamic>)
          : null,
      scale: json['Scale'] != null
          ? AxisScale.fromJson(json['Scale'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final range = this.range;
    final scale = this.scale;
    return {
      if (range != null) 'Range': range,
      if (scale != null) 'Scale': scale,
    };
  }
}

/// The numeric equality type drill down filter.
class NumericEqualityDrillDownFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// The value of the double input numeric drill down filter.
  final double value;

  NumericEqualityDrillDownFilter({
    required this.column,
    required this.value,
  });

  factory NumericEqualityDrillDownFilter.fromJson(Map<String, dynamic> json) {
    return NumericEqualityDrillDownFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      value: json['Value'] as double,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final value = this.value;
    return {
      'Column': column,
      'Value': value,
    };
  }
}

/// A <code>NumericEqualityFilter</code> filters values that are equal to the
/// specified value.
class NumericEqualityFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// The match operator that is used to determine if a filter should be applied.
  final NumericEqualityMatchOperator matchOperator;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption nullOption;

  /// The aggregation function of the filter.
  final AggregationFunction? aggregationFunction;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  /// The parameter whose value should be used for the filter value.
  final String? parameterName;

  /// Select all of the values. Null is not the assigned value of select all.
  ///
  /// <ul>
  /// <li>
  /// <code>FILTER_ALL_VALUES</code>
  /// </li>
  /// </ul>
  final NumericFilterSelectAllOptions? selectAllOptions;

  /// The input value.
  final double? value;

  NumericEqualityFilter({
    required this.column,
    required this.filterId,
    required this.matchOperator,
    required this.nullOption,
    this.aggregationFunction,
    this.defaultFilterControlConfiguration,
    this.parameterName,
    this.selectAllOptions,
    this.value,
  });

  factory NumericEqualityFilter.fromJson(Map<String, dynamic> json) {
    return NumericEqualityFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      matchOperator:
          (json['MatchOperator'] as String).toNumericEqualityMatchOperator(),
      nullOption: (json['NullOption'] as String).toFilterNullOption(),
      aggregationFunction: json['AggregationFunction'] != null
          ? AggregationFunction.fromJson(
              json['AggregationFunction'] as Map<String, dynamic>)
          : null,
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
      parameterName: json['ParameterName'] as String?,
      selectAllOptions: (json['SelectAllOptions'] as String?)
          ?.toNumericFilterSelectAllOptions(),
      value: json['Value'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final filterId = this.filterId;
    final matchOperator = this.matchOperator;
    final nullOption = this.nullOption;
    final aggregationFunction = this.aggregationFunction;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    final parameterName = this.parameterName;
    final selectAllOptions = this.selectAllOptions;
    final value = this.value;
    return {
      'Column': column,
      'FilterId': filterId,
      'MatchOperator': matchOperator.toValue(),
      'NullOption': nullOption.toValue(),
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction,
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
      if (parameterName != null) 'ParameterName': parameterName,
      if (selectAllOptions != null)
        'SelectAllOptions': selectAllOptions.toValue(),
      if (value != null) 'Value': value,
    };
  }
}

enum NumericEqualityMatchOperator {
  equals,
  doesNotEqual,
}

extension NumericEqualityMatchOperatorValueExtension
    on NumericEqualityMatchOperator {
  String toValue() {
    switch (this) {
      case NumericEqualityMatchOperator.equals:
        return 'EQUALS';
      case NumericEqualityMatchOperator.doesNotEqual:
        return 'DOES_NOT_EQUAL';
    }
  }
}

extension NumericEqualityMatchOperatorFromString on String {
  NumericEqualityMatchOperator toNumericEqualityMatchOperator() {
    switch (this) {
      case 'EQUALS':
        return NumericEqualityMatchOperator.equals;
      case 'DOES_NOT_EQUAL':
        return NumericEqualityMatchOperator.doesNotEqual;
    }
    throw Exception('$this is not known in enum NumericEqualityMatchOperator');
  }
}

enum NumericFilterSelectAllOptions {
  filterAllValues,
}

extension NumericFilterSelectAllOptionsValueExtension
    on NumericFilterSelectAllOptions {
  String toValue() {
    switch (this) {
      case NumericFilterSelectAllOptions.filterAllValues:
        return 'FILTER_ALL_VALUES';
    }
  }
}

extension NumericFilterSelectAllOptionsFromString on String {
  NumericFilterSelectAllOptions toNumericFilterSelectAllOptions() {
    switch (this) {
      case 'FILTER_ALL_VALUES':
        return NumericFilterSelectAllOptions.filterAllValues;
    }
    throw Exception('$this is not known in enum NumericFilterSelectAllOptions');
  }
}

/// The options that determine the numeric format configuration.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class NumericFormatConfiguration {
  /// The options that determine the currency display format configuration.
  final CurrencyDisplayFormatConfiguration? currencyDisplayFormatConfiguration;

  /// The options that determine the number display format configuration.
  final NumberDisplayFormatConfiguration? numberDisplayFormatConfiguration;

  /// The options that determine the percentage display format configuration.
  final PercentageDisplayFormatConfiguration?
      percentageDisplayFormatConfiguration;

  NumericFormatConfiguration({
    this.currencyDisplayFormatConfiguration,
    this.numberDisplayFormatConfiguration,
    this.percentageDisplayFormatConfiguration,
  });

  factory NumericFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return NumericFormatConfiguration(
      currencyDisplayFormatConfiguration:
          json['CurrencyDisplayFormatConfiguration'] != null
              ? CurrencyDisplayFormatConfiguration.fromJson(
                  json['CurrencyDisplayFormatConfiguration']
                      as Map<String, dynamic>)
              : null,
      numberDisplayFormatConfiguration:
          json['NumberDisplayFormatConfiguration'] != null
              ? NumberDisplayFormatConfiguration.fromJson(
                  json['NumberDisplayFormatConfiguration']
                      as Map<String, dynamic>)
              : null,
      percentageDisplayFormatConfiguration:
          json['PercentageDisplayFormatConfiguration'] != null
              ? PercentageDisplayFormatConfiguration.fromJson(
                  json['PercentageDisplayFormatConfiguration']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final currencyDisplayFormatConfiguration =
        this.currencyDisplayFormatConfiguration;
    final numberDisplayFormatConfiguration =
        this.numberDisplayFormatConfiguration;
    final percentageDisplayFormatConfiguration =
        this.percentageDisplayFormatConfiguration;
    return {
      if (currencyDisplayFormatConfiguration != null)
        'CurrencyDisplayFormatConfiguration':
            currencyDisplayFormatConfiguration,
      if (numberDisplayFormatConfiguration != null)
        'NumberDisplayFormatConfiguration': numberDisplayFormatConfiguration,
      if (percentageDisplayFormatConfiguration != null)
        'PercentageDisplayFormatConfiguration':
            percentageDisplayFormatConfiguration,
    };
  }
}

/// A <code>NumericRangeFilter</code> filters values that are within the value
/// range.
class NumericRangeFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption nullOption;

  /// The aggregation function of the filter.
  final AggregationFunction? aggregationFunction;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  /// Determines whether the maximum value in the filter value range should be
  /// included in the filtered results.
  final bool? includeMaximum;

  /// Determines whether the minimum value in the filter value range should be
  /// included in the filtered results.
  final bool? includeMinimum;

  /// The maximum value for the filter value range.
  final NumericRangeFilterValue? rangeMaximum;

  /// The minimum value for the filter value range.
  final NumericRangeFilterValue? rangeMinimum;

  /// Select all of the values. Null is not the assigned value of select all.
  ///
  /// <ul>
  /// <li>
  /// <code>FILTER_ALL_VALUES</code>
  /// </li>
  /// </ul>
  final NumericFilterSelectAllOptions? selectAllOptions;

  NumericRangeFilter({
    required this.column,
    required this.filterId,
    required this.nullOption,
    this.aggregationFunction,
    this.defaultFilterControlConfiguration,
    this.includeMaximum,
    this.includeMinimum,
    this.rangeMaximum,
    this.rangeMinimum,
    this.selectAllOptions,
  });

  factory NumericRangeFilter.fromJson(Map<String, dynamic> json) {
    return NumericRangeFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      nullOption: (json['NullOption'] as String).toFilterNullOption(),
      aggregationFunction: json['AggregationFunction'] != null
          ? AggregationFunction.fromJson(
              json['AggregationFunction'] as Map<String, dynamic>)
          : null,
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
      includeMaximum: json['IncludeMaximum'] as bool?,
      includeMinimum: json['IncludeMinimum'] as bool?,
      rangeMaximum: json['RangeMaximum'] != null
          ? NumericRangeFilterValue.fromJson(
              json['RangeMaximum'] as Map<String, dynamic>)
          : null,
      rangeMinimum: json['RangeMinimum'] != null
          ? NumericRangeFilterValue.fromJson(
              json['RangeMinimum'] as Map<String, dynamic>)
          : null,
      selectAllOptions: (json['SelectAllOptions'] as String?)
          ?.toNumericFilterSelectAllOptions(),
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final filterId = this.filterId;
    final nullOption = this.nullOption;
    final aggregationFunction = this.aggregationFunction;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    final includeMaximum = this.includeMaximum;
    final includeMinimum = this.includeMinimum;
    final rangeMaximum = this.rangeMaximum;
    final rangeMinimum = this.rangeMinimum;
    final selectAllOptions = this.selectAllOptions;
    return {
      'Column': column,
      'FilterId': filterId,
      'NullOption': nullOption.toValue(),
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction,
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
      if (includeMaximum != null) 'IncludeMaximum': includeMaximum,
      if (includeMinimum != null) 'IncludeMinimum': includeMinimum,
      if (rangeMaximum != null) 'RangeMaximum': rangeMaximum,
      if (rangeMinimum != null) 'RangeMinimum': rangeMinimum,
      if (selectAllOptions != null)
        'SelectAllOptions': selectAllOptions.toValue(),
    };
  }
}

/// The value input pf the numeric range filter.
class NumericRangeFilterValue {
  /// The parameter that is used in the numeric range.
  final String? parameter;

  /// The static value of the numeric range filter.
  final double? staticValue;

  NumericRangeFilterValue({
    this.parameter,
    this.staticValue,
  });

  factory NumericRangeFilterValue.fromJson(Map<String, dynamic> json) {
    return NumericRangeFilterValue(
      parameter: json['Parameter'] as String?,
      staticValue: json['StaticValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final parameter = this.parameter;
    final staticValue = this.staticValue;
    return {
      if (parameter != null) 'Parameter': parameter,
      if (staticValue != null) 'StaticValue': staticValue,
    };
  }
}

/// The options that determine the numeric separator configuration.
class NumericSeparatorConfiguration {
  /// Determines the decimal separator.
  final NumericSeparatorSymbol? decimalSeparator;

  /// The options that determine the thousands separator configuration.
  final ThousandSeparatorOptions? thousandsSeparator;

  NumericSeparatorConfiguration({
    this.decimalSeparator,
    this.thousandsSeparator,
  });

  factory NumericSeparatorConfiguration.fromJson(Map<String, dynamic> json) {
    return NumericSeparatorConfiguration(
      decimalSeparator:
          (json['DecimalSeparator'] as String?)?.toNumericSeparatorSymbol(),
      thousandsSeparator: json['ThousandsSeparator'] != null
          ? ThousandSeparatorOptions.fromJson(
              json['ThousandsSeparator'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final decimalSeparator = this.decimalSeparator;
    final thousandsSeparator = this.thousandsSeparator;
    return {
      if (decimalSeparator != null)
        'DecimalSeparator': decimalSeparator.toValue(),
      if (thousandsSeparator != null) 'ThousandsSeparator': thousandsSeparator,
    };
  }
}

enum NumericSeparatorSymbol {
  comma,
  dot,
  space,
}

extension NumericSeparatorSymbolValueExtension on NumericSeparatorSymbol {
  String toValue() {
    switch (this) {
      case NumericSeparatorSymbol.comma:
        return 'COMMA';
      case NumericSeparatorSymbol.dot:
        return 'DOT';
      case NumericSeparatorSymbol.space:
        return 'SPACE';
    }
  }
}

extension NumericSeparatorSymbolFromString on String {
  NumericSeparatorSymbol toNumericSeparatorSymbol() {
    switch (this) {
      case 'COMMA':
        return NumericSeparatorSymbol.comma;
      case 'DOT':
        return NumericSeparatorSymbol.dot;
      case 'SPACE':
        return NumericSeparatorSymbol.space;
    }
    throw Exception('$this is not known in enum NumericSeparatorSymbol');
  }
}

/// Aggregation for numerical values.
class NumericalAggregationFunction {
  /// An aggregation based on the percentile of values in a dimension or measure.
  final PercentileAggregation? percentileAggregation;

  /// Built-in aggregation functions for numerical values.
  ///
  /// <ul>
  /// <li>
  /// <code>SUM</code>: The sum of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>AVERAGE</code>: The average of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>MIN</code>: The minimum value of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>MAX</code>: The maximum value of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>COUNT</code>: The count of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>DISTINCT_COUNT</code>: The count of distinct values in a dimension or
  /// measure.
  /// </li>
  /// <li>
  /// <code>VAR</code>: The variance of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>VARP</code>: The partitioned variance of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>STDEV</code>: The standard deviation of a dimension or measure.
  /// </li>
  /// <li>
  /// <code>STDEVP</code>: The partitioned standard deviation of a dimension or
  /// measure.
  /// </li>
  /// <li>
  /// <code>MEDIAN</code>: The median value of a dimension or measure.
  /// </li>
  /// </ul>
  final SimpleNumericalAggregationFunction? simpleNumericalAggregation;

  NumericalAggregationFunction({
    this.percentileAggregation,
    this.simpleNumericalAggregation,
  });

  factory NumericalAggregationFunction.fromJson(Map<String, dynamic> json) {
    return NumericalAggregationFunction(
      percentileAggregation: json['PercentileAggregation'] != null
          ? PercentileAggregation.fromJson(
              json['PercentileAggregation'] as Map<String, dynamic>)
          : null,
      simpleNumericalAggregation:
          (json['SimpleNumericalAggregation'] as String?)
              ?.toSimpleNumericalAggregationFunction(),
    );
  }

  Map<String, dynamic> toJson() {
    final percentileAggregation = this.percentileAggregation;
    final simpleNumericalAggregation = this.simpleNumericalAggregation;
    return {
      if (percentileAggregation != null)
        'PercentileAggregation': percentileAggregation,
      if (simpleNumericalAggregation != null)
        'SimpleNumericalAggregation': simpleNumericalAggregation.toValue(),
    };
  }
}

/// The dimension type field with numerical type columns.
class NumericalDimensionField {
  /// The column that is used in the <code>NumericalDimensionField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The format configuration of the field.
  final NumberFormatConfiguration? formatConfiguration;

  /// The custom hierarchy ID.
  final String? hierarchyId;

  NumericalDimensionField({
    required this.column,
    required this.fieldId,
    this.formatConfiguration,
    this.hierarchyId,
  });

  factory NumericalDimensionField.fromJson(Map<String, dynamic> json) {
    return NumericalDimensionField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      formatConfiguration: json['FormatConfiguration'] != null
          ? NumberFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
      hierarchyId: json['HierarchyId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final formatConfiguration = this.formatConfiguration;
    final hierarchyId = this.hierarchyId;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
      if (hierarchyId != null) 'HierarchyId': hierarchyId,
    };
  }
}

/// The measure type field with numerical type columns.
class NumericalMeasureField {
  /// The column that is used in the <code>NumericalMeasureField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The aggregation function of the measure field.
  final NumericalAggregationFunction? aggregationFunction;

  /// The format configuration of the field.
  final NumberFormatConfiguration? formatConfiguration;

  NumericalMeasureField({
    required this.column,
    required this.fieldId,
    this.aggregationFunction,
    this.formatConfiguration,
  });

  factory NumericalMeasureField.fromJson(Map<String, dynamic> json) {
    return NumericalMeasureField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      aggregationFunction: json['AggregationFunction'] != null
          ? NumericalAggregationFunction.fromJson(
              json['AggregationFunction'] as Map<String, dynamic>)
          : null,
      formatConfiguration: json['FormatConfiguration'] != null
          ? NumberFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final aggregationFunction = this.aggregationFunction;
    final formatConfiguration = this.formatConfiguration;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (aggregationFunction != null)
        'AggregationFunction': aggregationFunction,
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
    };
  }
}

/// The parameters for Oracle.
class OracleParameters {
  /// The database.
  final String database;

  /// An Oracle host.
  final String host;

  /// The port.
  final int port;

  OracleParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory OracleParameters.fromJson(Map<String, dynamic> json) {
    return OracleParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

enum OtherCategories {
  include,
  exclude,
}

extension OtherCategoriesValueExtension on OtherCategories {
  String toValue() {
    switch (this) {
      case OtherCategories.include:
        return 'INCLUDE';
      case OtherCategories.exclude:
        return 'EXCLUDE';
    }
  }
}

extension OtherCategoriesFromString on String {
  OtherCategories toOtherCategories() {
    switch (this) {
      case 'INCLUDE':
        return OtherCategories.include;
      case 'EXCLUDE':
        return OtherCategories.exclude;
    }
    throw Exception('$this is not known in enum OtherCategories');
  }
}

/// Output column.
class OutputColumn {
  /// A description for a column.
  final String? description;

  /// The display name of the column..
  final String? name;

  /// The sub data type of the column.
  final ColumnDataSubType? subType;

  /// The data type of the column.
  final ColumnDataType? type;

  OutputColumn({
    this.description,
    this.name,
    this.subType,
    this.type,
  });

  factory OutputColumn.fromJson(Map<String, dynamic> json) {
    return OutputColumn(
      description: json['Description'] as String?,
      name: json['Name'] as String?,
      subType: (json['SubType'] as String?)?.toColumnDataSubType(),
      type: (json['Type'] as String?)?.toColumnDataType(),
    );
  }

  Map<String, dynamic> toJson() {
    final description = this.description;
    final name = this.name;
    final subType = this.subType;
    final type = this.type;
    return {
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (subType != null) 'SubType': subType.toValue(),
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A transform operation that overrides the dataset parameter values that are
/// defined in another dataset.
class OverrideDatasetParameterOperation {
  /// The name of the parameter to be overridden with different values.
  final String parameterName;

  /// The new default values for the parameter.
  final NewDefaultValues? newDefaultValues;

  /// The new name for the parameter.
  final String? newParameterName;

  OverrideDatasetParameterOperation({
    required this.parameterName,
    this.newDefaultValues,
    this.newParameterName,
  });

  factory OverrideDatasetParameterOperation.fromJson(
      Map<String, dynamic> json) {
    return OverrideDatasetParameterOperation(
      parameterName: json['ParameterName'] as String,
      newDefaultValues: json['NewDefaultValues'] != null
          ? NewDefaultValues.fromJson(
              json['NewDefaultValues'] as Map<String, dynamic>)
          : null,
      newParameterName: json['NewParameterName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final parameterName = this.parameterName;
    final newDefaultValues = this.newDefaultValues;
    final newParameterName = this.newParameterName;
    return {
      'ParameterName': parameterName,
      if (newDefaultValues != null) 'NewDefaultValues': newDefaultValues,
      if (newParameterName != null) 'NewParameterName': newParameterName,
    };
  }
}

/// The pagination configuration for a table visual or boxplot.
class PaginationConfiguration {
  /// Indicates the page number.
  final int pageNumber;

  /// Indicates how many items render in one page.
  final int pageSize;

  PaginationConfiguration({
    required this.pageNumber,
    required this.pageSize,
  });

  factory PaginationConfiguration.fromJson(Map<String, dynamic> json) {
    return PaginationConfiguration(
      pageNumber: json['PageNumber'] as int,
      pageSize: json['PageSize'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final pageNumber = this.pageNumber;
    final pageSize = this.pageSize;
    return {
      'PageNumber': pageNumber,
      'PageSize': pageSize,
    };
  }
}

enum PanelBorderStyle {
  solid,
  dashed,
  dotted,
}

extension PanelBorderStyleValueExtension on PanelBorderStyle {
  String toValue() {
    switch (this) {
      case PanelBorderStyle.solid:
        return 'SOLID';
      case PanelBorderStyle.dashed:
        return 'DASHED';
      case PanelBorderStyle.dotted:
        return 'DOTTED';
    }
  }
}

extension PanelBorderStyleFromString on String {
  PanelBorderStyle toPanelBorderStyle() {
    switch (this) {
      case 'SOLID':
        return PanelBorderStyle.solid;
      case 'DASHED':
        return PanelBorderStyle.dashed;
      case 'DOTTED':
        return PanelBorderStyle.dotted;
    }
    throw Exception('$this is not known in enum PanelBorderStyle');
  }
}

/// A collection of options that configure how each panel displays in a small
/// multiples chart.
class PanelConfiguration {
  /// Sets the background color for each panel.
  final String? backgroundColor;

  /// Determines whether or not a background for each small multiples panel is
  /// rendered.
  final Visibility? backgroundVisibility;

  /// Sets the line color of panel borders.
  final String? borderColor;

  /// Sets the line style of panel borders.
  final PanelBorderStyle? borderStyle;

  /// Sets the line thickness of panel borders.
  final String? borderThickness;

  /// Determines whether or not each panel displays a border.
  final Visibility? borderVisibility;

  /// Sets the total amount of negative space to display between sibling panels.
  final String? gutterSpacing;

  /// Determines whether or not negative space between sibling panels is rendered.
  final Visibility? gutterVisibility;

  /// Configures the title display within each small multiples panel.
  final PanelTitleOptions? title;

  PanelConfiguration({
    this.backgroundColor,
    this.backgroundVisibility,
    this.borderColor,
    this.borderStyle,
    this.borderThickness,
    this.borderVisibility,
    this.gutterSpacing,
    this.gutterVisibility,
    this.title,
  });

  factory PanelConfiguration.fromJson(Map<String, dynamic> json) {
    return PanelConfiguration(
      backgroundColor: json['BackgroundColor'] as String?,
      backgroundVisibility:
          (json['BackgroundVisibility'] as String?)?.toVisibility(),
      borderColor: json['BorderColor'] as String?,
      borderStyle: (json['BorderStyle'] as String?)?.toPanelBorderStyle(),
      borderThickness: json['BorderThickness'] as String?,
      borderVisibility: (json['BorderVisibility'] as String?)?.toVisibility(),
      gutterSpacing: json['GutterSpacing'] as String?,
      gutterVisibility: (json['GutterVisibility'] as String?)?.toVisibility(),
      title: json['Title'] != null
          ? PanelTitleOptions.fromJson(json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final backgroundColor = this.backgroundColor;
    final backgroundVisibility = this.backgroundVisibility;
    final borderColor = this.borderColor;
    final borderStyle = this.borderStyle;
    final borderThickness = this.borderThickness;
    final borderVisibility = this.borderVisibility;
    final gutterSpacing = this.gutterSpacing;
    final gutterVisibility = this.gutterVisibility;
    final title = this.title;
    return {
      if (backgroundColor != null) 'BackgroundColor': backgroundColor,
      if (backgroundVisibility != null)
        'BackgroundVisibility': backgroundVisibility.toValue(),
      if (borderColor != null) 'BorderColor': borderColor,
      if (borderStyle != null) 'BorderStyle': borderStyle.toValue(),
      if (borderThickness != null) 'BorderThickness': borderThickness,
      if (borderVisibility != null)
        'BorderVisibility': borderVisibility.toValue(),
      if (gutterSpacing != null) 'GutterSpacing': gutterSpacing,
      if (gutterVisibility != null)
        'GutterVisibility': gutterVisibility.toValue(),
      if (title != null) 'Title': title,
    };
  }
}

/// The options that determine the title styles for each small multiples panel.
class PanelTitleOptions {
  final FontConfiguration? fontConfiguration;

  /// Sets the horizontal text alignment of the title within each panel.
  final HorizontalTextAlignment? horizontalTextAlignment;

  /// Determines whether or not panel titles are displayed.
  final Visibility? visibility;

  PanelTitleOptions({
    this.fontConfiguration,
    this.horizontalTextAlignment,
    this.visibility,
  });

  factory PanelTitleOptions.fromJson(Map<String, dynamic> json) {
    return PanelTitleOptions(
      fontConfiguration: json['FontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['FontConfiguration'] as Map<String, dynamic>)
          : null,
      horizontalTextAlignment: (json['HorizontalTextAlignment'] as String?)
          ?.toHorizontalTextAlignment(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final fontConfiguration = this.fontConfiguration;
    final horizontalTextAlignment = this.horizontalTextAlignment;
    final visibility = this.visibility;
    return {
      if (fontConfiguration != null) 'FontConfiguration': fontConfiguration,
      if (horizontalTextAlignment != null)
        'HorizontalTextAlignment': horizontalTextAlignment.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

enum PaperOrientation {
  portrait,
  landscape,
}

extension PaperOrientationValueExtension on PaperOrientation {
  String toValue() {
    switch (this) {
      case PaperOrientation.portrait:
        return 'PORTRAIT';
      case PaperOrientation.landscape:
        return 'LANDSCAPE';
    }
  }
}

extension PaperOrientationFromString on String {
  PaperOrientation toPaperOrientation() {
    switch (this) {
      case 'PORTRAIT':
        return PaperOrientation.portrait;
      case 'LANDSCAPE':
        return PaperOrientation.landscape;
    }
    throw Exception('$this is not known in enum PaperOrientation');
  }
}

enum PaperSize {
  usLetter,
  usLegal,
  usTabloidLedger,
  a0,
  a1,
  a2,
  a3,
  a4,
  a5,
  jisB4,
  jisB5,
}

extension PaperSizeValueExtension on PaperSize {
  String toValue() {
    switch (this) {
      case PaperSize.usLetter:
        return 'US_LETTER';
      case PaperSize.usLegal:
        return 'US_LEGAL';
      case PaperSize.usTabloidLedger:
        return 'US_TABLOID_LEDGER';
      case PaperSize.a0:
        return 'A0';
      case PaperSize.a1:
        return 'A1';
      case PaperSize.a2:
        return 'A2';
      case PaperSize.a3:
        return 'A3';
      case PaperSize.a4:
        return 'A4';
      case PaperSize.a5:
        return 'A5';
      case PaperSize.jisB4:
        return 'JIS_B4';
      case PaperSize.jisB5:
        return 'JIS_B5';
    }
  }
}

extension PaperSizeFromString on String {
  PaperSize toPaperSize() {
    switch (this) {
      case 'US_LETTER':
        return PaperSize.usLetter;
      case 'US_LEGAL':
        return PaperSize.usLegal;
      case 'US_TABLOID_LEDGER':
        return PaperSize.usTabloidLedger;
      case 'A0':
        return PaperSize.a0;
      case 'A1':
        return PaperSize.a1;
      case 'A2':
        return PaperSize.a2;
      case 'A3':
        return PaperSize.a3;
      case 'A4':
        return PaperSize.a4;
      case 'A5':
        return PaperSize.a5;
      case 'JIS_B4':
        return PaperSize.jisB4;
      case 'JIS_B5':
        return PaperSize.jisB5;
    }
    throw Exception('$this is not known in enum PaperSize');
  }
}

/// The control of a parameter that users can interact with in a dashboard or an
/// analysis.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class ParameterControl {
  /// A control from a date parameter that specifies date and time.
  final ParameterDateTimePickerControl? dateTimePicker;

  /// A control to display a dropdown list with buttons that are used to select a
  /// single value.
  final ParameterDropDownControl? dropdown;

  /// A control to display a list with buttons or boxes that are used to select
  /// either a single value or multiple values.
  final ParameterListControl? list;

  /// A control to display a horizontal toggle bar. This is used to change a value
  /// by sliding the toggle.
  final ParameterSliderControl? slider;

  /// A control to display a text box that is used to enter multiple entries.
  final ParameterTextAreaControl? textArea;

  /// A control to display a text box that is used to enter a single entry.
  final ParameterTextFieldControl? textField;

  ParameterControl({
    this.dateTimePicker,
    this.dropdown,
    this.list,
    this.slider,
    this.textArea,
    this.textField,
  });

  factory ParameterControl.fromJson(Map<String, dynamic> json) {
    return ParameterControl(
      dateTimePicker: json['DateTimePicker'] != null
          ? ParameterDateTimePickerControl.fromJson(
              json['DateTimePicker'] as Map<String, dynamic>)
          : null,
      dropdown: json['Dropdown'] != null
          ? ParameterDropDownControl.fromJson(
              json['Dropdown'] as Map<String, dynamic>)
          : null,
      list: json['List'] != null
          ? ParameterListControl.fromJson(json['List'] as Map<String, dynamic>)
          : null,
      slider: json['Slider'] != null
          ? ParameterSliderControl.fromJson(
              json['Slider'] as Map<String, dynamic>)
          : null,
      textArea: json['TextArea'] != null
          ? ParameterTextAreaControl.fromJson(
              json['TextArea'] as Map<String, dynamic>)
          : null,
      textField: json['TextField'] != null
          ? ParameterTextFieldControl.fromJson(
              json['TextField'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimePicker = this.dateTimePicker;
    final dropdown = this.dropdown;
    final list = this.list;
    final slider = this.slider;
    final textArea = this.textArea;
    final textField = this.textField;
    return {
      if (dateTimePicker != null) 'DateTimePicker': dateTimePicker,
      if (dropdown != null) 'Dropdown': dropdown,
      if (list != null) 'List': list,
      if (slider != null) 'Slider': slider,
      if (textArea != null) 'TextArea': textArea,
      if (textField != null) 'TextField': textField,
    };
  }
}

/// A control from a date parameter that specifies date and time.
class ParameterDateTimePickerControl {
  /// The ID of the <code>ParameterDateTimePickerControl</code>.
  final String parameterControlId;

  /// The name of the <code>ParameterDateTimePickerControl</code>.
  final String sourceParameterName;

  /// The title of the <code>ParameterDateTimePickerControl</code>.
  final String title;

  /// The display options of a control.
  final DateTimePickerControlDisplayOptions? displayOptions;

  ParameterDateTimePickerControl({
    required this.parameterControlId,
    required this.sourceParameterName,
    required this.title,
    this.displayOptions,
  });

  factory ParameterDateTimePickerControl.fromJson(Map<String, dynamic> json) {
    return ParameterDateTimePickerControl(
      parameterControlId: json['ParameterControlId'] as String,
      sourceParameterName: json['SourceParameterName'] as String,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? DateTimePickerControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final parameterControlId = this.parameterControlId;
    final sourceParameterName = this.sourceParameterName;
    final title = this.title;
    final displayOptions = this.displayOptions;
    return {
      'ParameterControlId': parameterControlId,
      'SourceParameterName': sourceParameterName,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// The declaration definition of a parameter.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters
/// in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class ParameterDeclaration {
  /// A parameter declaration for the <code>DateTime</code> data type.
  final DateTimeParameterDeclaration? dateTimeParameterDeclaration;

  /// A parameter declaration for the <code>Decimal</code> data type.
  final DecimalParameterDeclaration? decimalParameterDeclaration;

  /// A parameter declaration for the <code>Integer</code> data type.
  final IntegerParameterDeclaration? integerParameterDeclaration;

  /// A parameter declaration for the <code>String</code> data type.
  final StringParameterDeclaration? stringParameterDeclaration;

  ParameterDeclaration({
    this.dateTimeParameterDeclaration,
    this.decimalParameterDeclaration,
    this.integerParameterDeclaration,
    this.stringParameterDeclaration,
  });

  factory ParameterDeclaration.fromJson(Map<String, dynamic> json) {
    return ParameterDeclaration(
      dateTimeParameterDeclaration: json['DateTimeParameterDeclaration'] != null
          ? DateTimeParameterDeclaration.fromJson(
              json['DateTimeParameterDeclaration'] as Map<String, dynamic>)
          : null,
      decimalParameterDeclaration: json['DecimalParameterDeclaration'] != null
          ? DecimalParameterDeclaration.fromJson(
              json['DecimalParameterDeclaration'] as Map<String, dynamic>)
          : null,
      integerParameterDeclaration: json['IntegerParameterDeclaration'] != null
          ? IntegerParameterDeclaration.fromJson(
              json['IntegerParameterDeclaration'] as Map<String, dynamic>)
          : null,
      stringParameterDeclaration: json['StringParameterDeclaration'] != null
          ? StringParameterDeclaration.fromJson(
              json['StringParameterDeclaration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeParameterDeclaration = this.dateTimeParameterDeclaration;
    final decimalParameterDeclaration = this.decimalParameterDeclaration;
    final integerParameterDeclaration = this.integerParameterDeclaration;
    final stringParameterDeclaration = this.stringParameterDeclaration;
    return {
      if (dateTimeParameterDeclaration != null)
        'DateTimeParameterDeclaration': dateTimeParameterDeclaration,
      if (decimalParameterDeclaration != null)
        'DecimalParameterDeclaration': decimalParameterDeclaration,
      if (integerParameterDeclaration != null)
        'IntegerParameterDeclaration': integerParameterDeclaration,
      if (stringParameterDeclaration != null)
        'StringParameterDeclaration': stringParameterDeclaration,
    };
  }
}

/// A control to display a dropdown list with buttons that are used to select a
/// single value.
class ParameterDropDownControl {
  /// The ID of the <code>ParameterDropDownControl</code>.
  final String parameterControlId;

  /// The source parameter name of the <code>ParameterDropDownControl</code>.
  final String sourceParameterName;

  /// The title of the <code>ParameterDropDownControl</code>.
  final String title;

  /// The values that are displayed in a control can be configured to only show
  /// values that are valid based on what's selected in other controls.
  final CascadingControlConfiguration? cascadingControlConfiguration;

  /// The display options of a control.
  final DropDownControlDisplayOptions? displayOptions;

  /// A list of selectable values that are used in a control.
  final ParameterSelectableValues? selectableValues;

  /// The type parameter name of the <code>ParameterDropDownControl</code>.
  final SheetControlListType? type;

  ParameterDropDownControl({
    required this.parameterControlId,
    required this.sourceParameterName,
    required this.title,
    this.cascadingControlConfiguration,
    this.displayOptions,
    this.selectableValues,
    this.type,
  });

  factory ParameterDropDownControl.fromJson(Map<String, dynamic> json) {
    return ParameterDropDownControl(
      parameterControlId: json['ParameterControlId'] as String,
      sourceParameterName: json['SourceParameterName'] as String,
      title: json['Title'] as String,
      cascadingControlConfiguration:
          json['CascadingControlConfiguration'] != null
              ? CascadingControlConfiguration.fromJson(
                  json['CascadingControlConfiguration'] as Map<String, dynamic>)
              : null,
      displayOptions: json['DisplayOptions'] != null
          ? DropDownControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      selectableValues: json['SelectableValues'] != null
          ? ParameterSelectableValues.fromJson(
              json['SelectableValues'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlListType(),
    );
  }

  Map<String, dynamic> toJson() {
    final parameterControlId = this.parameterControlId;
    final sourceParameterName = this.sourceParameterName;
    final title = this.title;
    final cascadingControlConfiguration = this.cascadingControlConfiguration;
    final displayOptions = this.displayOptions;
    final selectableValues = this.selectableValues;
    final type = this.type;
    return {
      'ParameterControlId': parameterControlId,
      'SourceParameterName': sourceParameterName,
      'Title': title,
      if (cascadingControlConfiguration != null)
        'CascadingControlConfiguration': cascadingControlConfiguration,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (selectableValues != null) 'SelectableValues': selectableValues,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A control to display a list with buttons or boxes that are used to select
/// either a single value or multiple values.
class ParameterListControl {
  /// The ID of the <code>ParameterListControl</code>.
  final String parameterControlId;

  /// The source parameter name of the <code>ParameterListControl</code>.
  final String sourceParameterName;

  /// The title of the <code>ParameterListControl</code>.
  final String title;

  /// The values that are displayed in a control can be configured to only show
  /// values that are valid based on what's selected in other controls.
  final CascadingControlConfiguration? cascadingControlConfiguration;

  /// The display options of a control.
  final ListControlDisplayOptions? displayOptions;

  /// A list of selectable values that are used in a control.
  final ParameterSelectableValues? selectableValues;

  /// The type of <code>ParameterListControl</code>.
  final SheetControlListType? type;

  ParameterListControl({
    required this.parameterControlId,
    required this.sourceParameterName,
    required this.title,
    this.cascadingControlConfiguration,
    this.displayOptions,
    this.selectableValues,
    this.type,
  });

  factory ParameterListControl.fromJson(Map<String, dynamic> json) {
    return ParameterListControl(
      parameterControlId: json['ParameterControlId'] as String,
      sourceParameterName: json['SourceParameterName'] as String,
      title: json['Title'] as String,
      cascadingControlConfiguration:
          json['CascadingControlConfiguration'] != null
              ? CascadingControlConfiguration.fromJson(
                  json['CascadingControlConfiguration'] as Map<String, dynamic>)
              : null,
      displayOptions: json['DisplayOptions'] != null
          ? ListControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
      selectableValues: json['SelectableValues'] != null
          ? ParameterSelectableValues.fromJson(
              json['SelectableValues'] as Map<String, dynamic>)
          : null,
      type: (json['Type'] as String?)?.toSheetControlListType(),
    );
  }

  Map<String, dynamic> toJson() {
    final parameterControlId = this.parameterControlId;
    final sourceParameterName = this.sourceParameterName;
    final title = this.title;
    final cascadingControlConfiguration = this.cascadingControlConfiguration;
    final displayOptions = this.displayOptions;
    final selectableValues = this.selectableValues;
    final type = this.type;
    return {
      'ParameterControlId': parameterControlId,
      'SourceParameterName': sourceParameterName,
      'Title': title,
      if (cascadingControlConfiguration != null)
        'CascadingControlConfiguration': cascadingControlConfiguration,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
      if (selectableValues != null) 'SelectableValues': selectableValues,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

/// A list of selectable values that are used in a control.
class ParameterSelectableValues {
  /// The column identifier that fetches values from the data set.
  final ColumnIdentifier? linkToDataSetColumn;

  /// The values that are used in <code>ParameterSelectableValues</code>.
  final List<String>? values;

  ParameterSelectableValues({
    this.linkToDataSetColumn,
    this.values,
  });

  factory ParameterSelectableValues.fromJson(Map<String, dynamic> json) {
    return ParameterSelectableValues(
      linkToDataSetColumn: json['LinkToDataSetColumn'] != null
          ? ColumnIdentifier.fromJson(
              json['LinkToDataSetColumn'] as Map<String, dynamic>)
          : null,
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final linkToDataSetColumn = this.linkToDataSetColumn;
    final values = this.values;
    return {
      if (linkToDataSetColumn != null)
        'LinkToDataSetColumn': linkToDataSetColumn,
      if (values != null) 'Values': values,
    };
  }
}

/// A control to display a horizontal toggle bar. This is used to change a value
/// by sliding the toggle.
class ParameterSliderControl {
  /// The larger value that is displayed at the right of the slider.
  final double maximumValue;

  /// The smaller value that is displayed at the left of the slider.
  final double minimumValue;

  /// The ID of the <code>ParameterSliderControl</code>.
  final String parameterControlId;

  /// The source parameter name of the <code>ParameterSliderControl</code>.
  final String sourceParameterName;

  /// The number of increments that the slider bar is divided into.
  final double stepSize;

  /// The title of the <code>ParameterSliderControl</code>.
  final String title;

  /// The display options of a control.
  final SliderControlDisplayOptions? displayOptions;

  ParameterSliderControl({
    required this.maximumValue,
    required this.minimumValue,
    required this.parameterControlId,
    required this.sourceParameterName,
    required this.stepSize,
    required this.title,
    this.displayOptions,
  });

  factory ParameterSliderControl.fromJson(Map<String, dynamic> json) {
    return ParameterSliderControl(
      maximumValue: json['MaximumValue'] as double,
      minimumValue: json['MinimumValue'] as double,
      parameterControlId: json['ParameterControlId'] as String,
      sourceParameterName: json['SourceParameterName'] as String,
      stepSize: json['StepSize'] as double,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? SliderControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final maximumValue = this.maximumValue;
    final minimumValue = this.minimumValue;
    final parameterControlId = this.parameterControlId;
    final sourceParameterName = this.sourceParameterName;
    final stepSize = this.stepSize;
    final title = this.title;
    final displayOptions = this.displayOptions;
    return {
      'MaximumValue': maximumValue,
      'MinimumValue': minimumValue,
      'ParameterControlId': parameterControlId,
      'SourceParameterName': sourceParameterName,
      'StepSize': stepSize,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// A control to display a text box that is used to enter multiple entries.
class ParameterTextAreaControl {
  /// The ID of the <code>ParameterTextAreaControl</code>.
  final String parameterControlId;

  /// The source parameter name of the <code>ParameterTextAreaControl</code>.
  final String sourceParameterName;

  /// The title of the <code>ParameterTextAreaControl</code>.
  final String title;

  /// The delimiter that is used to separate the lines in text.
  final String? delimiter;

  /// The display options of a control.
  final TextAreaControlDisplayOptions? displayOptions;

  ParameterTextAreaControl({
    required this.parameterControlId,
    required this.sourceParameterName,
    required this.title,
    this.delimiter,
    this.displayOptions,
  });

  factory ParameterTextAreaControl.fromJson(Map<String, dynamic> json) {
    return ParameterTextAreaControl(
      parameterControlId: json['ParameterControlId'] as String,
      sourceParameterName: json['SourceParameterName'] as String,
      title: json['Title'] as String,
      delimiter: json['Delimiter'] as String?,
      displayOptions: json['DisplayOptions'] != null
          ? TextAreaControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final parameterControlId = this.parameterControlId;
    final sourceParameterName = this.sourceParameterName;
    final title = this.title;
    final delimiter = this.delimiter;
    final displayOptions = this.displayOptions;
    return {
      'ParameterControlId': parameterControlId,
      'SourceParameterName': sourceParameterName,
      'Title': title,
      if (delimiter != null) 'Delimiter': delimiter,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

/// A control to display a text box that is used to enter a single entry.
class ParameterTextFieldControl {
  /// The ID of the <code>ParameterTextFieldControl</code>.
  final String parameterControlId;

  /// The source parameter name of the <code>ParameterTextFieldControl</code>.
  final String sourceParameterName;

  /// The title of the <code>ParameterTextFieldControl</code>.
  final String title;

  /// The display options of a control.
  final TextFieldControlDisplayOptions? displayOptions;

  ParameterTextFieldControl({
    required this.parameterControlId,
    required this.sourceParameterName,
    required this.title,
    this.displayOptions,
  });

  factory ParameterTextFieldControl.fromJson(Map<String, dynamic> json) {
    return ParameterTextFieldControl(
      parameterControlId: json['ParameterControlId'] as String,
      sourceParameterName: json['SourceParameterName'] as String,
      title: json['Title'] as String,
      displayOptions: json['DisplayOptions'] != null
          ? TextFieldControlDisplayOptions.fromJson(
              json['DisplayOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final parameterControlId = this.parameterControlId;
    final sourceParameterName = this.sourceParameterName;
    final title = this.title;
    final displayOptions = this.displayOptions;
    return {
      'ParameterControlId': parameterControlId,
      'SourceParameterName': sourceParameterName,
      'Title': title,
      if (displayOptions != null) 'DisplayOptions': displayOptions,
    };
  }
}

enum ParameterValueType {
  multiValued,
  singleValued,
}

extension ParameterValueTypeValueExtension on ParameterValueType {
  String toValue() {
    switch (this) {
      case ParameterValueType.multiValued:
        return 'MULTI_VALUED';
      case ParameterValueType.singleValued:
        return 'SINGLE_VALUED';
    }
  }
}

extension ParameterValueTypeFromString on String {
  ParameterValueType toParameterValueType() {
    switch (this) {
      case 'MULTI_VALUED':
        return ParameterValueType.multiValued;
      case 'SINGLE_VALUED':
        return ParameterValueType.singleValued;
    }
    throw Exception('$this is not known in enum ParameterValueType');
  }
}

/// A list of Amazon QuickSight parameters and the list's override values.
class Parameters {
  /// The parameters that have a data type of date-time.
  final List<DateTimeParameter>? dateTimeParameters;

  /// The parameters that have a data type of decimal.
  final List<DecimalParameter>? decimalParameters;

  /// The parameters that have a data type of integer.
  final List<IntegerParameter>? integerParameters;

  /// The parameters that have a data type of string.
  final List<StringParameter>? stringParameters;

  Parameters({
    this.dateTimeParameters,
    this.decimalParameters,
    this.integerParameters,
    this.stringParameters,
  });

  factory Parameters.fromJson(Map<String, dynamic> json) {
    return Parameters(
      dateTimeParameters: (json['DateTimeParameters'] as List?)
          ?.whereNotNull()
          .map((e) => DateTimeParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      decimalParameters: (json['DecimalParameters'] as List?)
          ?.whereNotNull()
          .map((e) => DecimalParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      integerParameters: (json['IntegerParameters'] as List?)
          ?.whereNotNull()
          .map((e) => IntegerParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      stringParameters: (json['StringParameters'] as List?)
          ?.whereNotNull()
          .map((e) => StringParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeParameters = this.dateTimeParameters;
    final decimalParameters = this.decimalParameters;
    final integerParameters = this.integerParameters;
    final stringParameters = this.stringParameters;
    return {
      if (dateTimeParameters != null) 'DateTimeParameters': dateTimeParameters,
      if (decimalParameters != null) 'DecimalParameters': decimalParameters,
      if (integerParameters != null) 'IntegerParameters': integerParameters,
      if (stringParameters != null) 'StringParameters': stringParameters,
    };
  }
}

/// The percent range in the visible range.
class PercentVisibleRange {
  /// The lower bound of the range.
  final double? from;

  /// The top bound of the range.
  final double? to;

  PercentVisibleRange({
    this.from,
    this.to,
  });

  factory PercentVisibleRange.fromJson(Map<String, dynamic> json) {
    return PercentVisibleRange(
      from: json['From'] as double?,
      to: json['To'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final from = this.from;
    final to = this.to;
    return {
      if (from != null) 'From': from,
      if (to != null) 'To': to,
    };
  }
}

/// The options that determine the percentage display format configuration.
class PercentageDisplayFormatConfiguration {
  /// The option that determines the decimal places configuration.
  final DecimalPlacesConfiguration? decimalPlacesConfiguration;

  /// The options that determine the negative value configuration.
  final NegativeValueConfiguration? negativeValueConfiguration;

  /// The options that determine the null value format configuration.
  final NullValueFormatConfiguration? nullValueFormatConfiguration;

  /// Determines the prefix value of the percentage format.
  final String? prefix;

  /// The options that determine the numeric separator configuration.
  final NumericSeparatorConfiguration? separatorConfiguration;

  /// Determines the suffix value of the percentage format.
  final String? suffix;

  PercentageDisplayFormatConfiguration({
    this.decimalPlacesConfiguration,
    this.negativeValueConfiguration,
    this.nullValueFormatConfiguration,
    this.prefix,
    this.separatorConfiguration,
    this.suffix,
  });

  factory PercentageDisplayFormatConfiguration.fromJson(
      Map<String, dynamic> json) {
    return PercentageDisplayFormatConfiguration(
      decimalPlacesConfiguration: json['DecimalPlacesConfiguration'] != null
          ? DecimalPlacesConfiguration.fromJson(
              json['DecimalPlacesConfiguration'] as Map<String, dynamic>)
          : null,
      negativeValueConfiguration: json['NegativeValueConfiguration'] != null
          ? NegativeValueConfiguration.fromJson(
              json['NegativeValueConfiguration'] as Map<String, dynamic>)
          : null,
      nullValueFormatConfiguration: json['NullValueFormatConfiguration'] != null
          ? NullValueFormatConfiguration.fromJson(
              json['NullValueFormatConfiguration'] as Map<String, dynamic>)
          : null,
      prefix: json['Prefix'] as String?,
      separatorConfiguration: json['SeparatorConfiguration'] != null
          ? NumericSeparatorConfiguration.fromJson(
              json['SeparatorConfiguration'] as Map<String, dynamic>)
          : null,
      suffix: json['Suffix'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final decimalPlacesConfiguration = this.decimalPlacesConfiguration;
    final negativeValueConfiguration = this.negativeValueConfiguration;
    final nullValueFormatConfiguration = this.nullValueFormatConfiguration;
    final prefix = this.prefix;
    final separatorConfiguration = this.separatorConfiguration;
    final suffix = this.suffix;
    return {
      if (decimalPlacesConfiguration != null)
        'DecimalPlacesConfiguration': decimalPlacesConfiguration,
      if (negativeValueConfiguration != null)
        'NegativeValueConfiguration': negativeValueConfiguration,
      if (nullValueFormatConfiguration != null)
        'NullValueFormatConfiguration': nullValueFormatConfiguration,
      if (prefix != null) 'Prefix': prefix,
      if (separatorConfiguration != null)
        'SeparatorConfiguration': separatorConfiguration,
      if (suffix != null) 'Suffix': suffix,
    };
  }
}

/// An aggregation based on the percentile of values in a dimension or measure.
class PercentileAggregation {
  /// The percentile value. This value can be any numeric constant 0100. A
  /// percentile value of 50 computes the median value of the measure.
  final double? percentileValue;

  PercentileAggregation({
    this.percentileValue,
  });

  factory PercentileAggregation.fromJson(Map<String, dynamic> json) {
    return PercentileAggregation(
      percentileValue: json['PercentileValue'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final percentileValue = this.percentileValue;
    return {
      if (percentileValue != null) 'PercentileValue': percentileValue,
    };
  }
}

/// The period over period computation configuration.
class PeriodOverPeriodComputation {
  /// The ID for a computation.
  final String computationId;

  /// The name of a computation.
  final String? name;

  /// The time field that is used in a computation.
  final DimensionField? time;

  /// The value field that is used in a computation.
  final MeasureField? value;

  PeriodOverPeriodComputation({
    required this.computationId,
    this.name,
    this.time,
    this.value,
  });

  factory PeriodOverPeriodComputation.fromJson(Map<String, dynamic> json) {
    return PeriodOverPeriodComputation(
      computationId: json['ComputationId'] as String,
      name: json['Name'] as String?,
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final name = this.name;
    final time = this.time;
    final value = this.value;
    return {
      'ComputationId': computationId,
      if (name != null) 'Name': name,
      if (time != null) 'Time': time,
      if (value != null) 'Value': value,
    };
  }
}

/// The period to date computation configuration.
class PeriodToDateComputation {
  /// The ID for a computation.
  final String computationId;

  /// The name of a computation.
  final String? name;

  /// The time granularity setup of period to date computation. Choose from the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// YEAR: Year to date.
  /// </li>
  /// <li>
  /// MONTH: Month to date.
  /// </li>
  /// </ul>
  final TimeGranularity? periodTimeGranularity;

  /// The time field that is used in a computation.
  final DimensionField? time;

  /// The value field that is used in a computation.
  final MeasureField? value;

  PeriodToDateComputation({
    required this.computationId,
    this.name,
    this.periodTimeGranularity,
    this.time,
    this.value,
  });

  factory PeriodToDateComputation.fromJson(Map<String, dynamic> json) {
    return PeriodToDateComputation(
      computationId: json['ComputationId'] as String,
      name: json['Name'] as String?,
      periodTimeGranularity:
          (json['PeriodTimeGranularity'] as String?)?.toTimeGranularity(),
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final name = this.name;
    final periodTimeGranularity = this.periodTimeGranularity;
    final time = this.time;
    final value = this.value;
    return {
      'ComputationId': computationId,
      if (name != null) 'Name': name,
      if (periodTimeGranularity != null)
        'PeriodTimeGranularity': periodTimeGranularity.toValue(),
      if (time != null) 'Time': time,
      if (value != null) 'Value': value,
    };
  }
}

/// A view of a data source that contains information about the shape of the
/// data in the underlying source. This is a variant type structure. For this
/// structure to be valid, only one of the attributes can be non-null.
class PhysicalTable {
  /// A physical table type built from the results of the custom SQL query.
  final CustomSql? customSql;

  /// A physical table type for relational data sources.
  final RelationalTable? relationalTable;

  /// A physical table type for as S3 data source.
  final S3Source? s3Source;

  PhysicalTable({
    this.customSql,
    this.relationalTable,
    this.s3Source,
  });

  factory PhysicalTable.fromJson(Map<String, dynamic> json) {
    return PhysicalTable(
      customSql: json['CustomSql'] != null
          ? CustomSql.fromJson(json['CustomSql'] as Map<String, dynamic>)
          : null,
      relationalTable: json['RelationalTable'] != null
          ? RelationalTable.fromJson(
              json['RelationalTable'] as Map<String, dynamic>)
          : null,
      s3Source: json['S3Source'] != null
          ? S3Source.fromJson(json['S3Source'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customSql = this.customSql;
    final relationalTable = this.relationalTable;
    final s3Source = this.s3Source;
    return {
      if (customSql != null) 'CustomSql': customSql,
      if (relationalTable != null) 'RelationalTable': relationalTable,
      if (s3Source != null) 'S3Source': s3Source,
    };
  }
}

/// The field well configuration of a pie chart.
class PieChartAggregatedFieldWells {
  /// The category (group/color) field wells of a pie chart.
  final List<DimensionField>? category;

  /// The small multiples field well of a pie chart.
  final List<DimensionField>? smallMultiples;

  /// The value field wells of a pie chart. Values are aggregated based on
  /// categories.
  final List<MeasureField>? values;

  PieChartAggregatedFieldWells({
    this.category,
    this.smallMultiples,
    this.values,
  });

  factory PieChartAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return PieChartAggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      smallMultiples: (json['SmallMultiples'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final smallMultiples = this.smallMultiples;
    final values = this.values;
    return {
      if (category != null) 'Category': category,
      if (smallMultiples != null) 'SmallMultiples': smallMultiples,
      if (values != null) 'Values': values,
    };
  }
}

/// The configuration of a pie chart.
class PieChartConfiguration {
  /// The label options of the group/color that is displayed in a pie chart.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The contribution analysis (anomaly configuration) setup of the visual.
  final List<ContributionAnalysisDefault>? contributionAnalysisDefaults;

  /// The options that determine if visual data labels are displayed.
  final DataLabelOptions? dataLabels;

  /// The options that determine the shape of the chart. This option determines
  /// whether the chart is a pie chart or a donut chart.
  final DonutOptions? donutOptions;

  /// The field wells of the visual.
  final PieChartFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The small multiples setup for the visual.
  final SmallMultiplesOptions? smallMultiplesOptions;

  /// The sort configuration of a pie chart.
  final PieChartSortConfiguration? sortConfiguration;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;

  /// The label options for the value that is displayed in a pie chart.
  final ChartAxisLabelOptions? valueLabelOptions;

  /// The palette (chart color) display setup of the visual.
  final VisualPalette? visualPalette;

  PieChartConfiguration({
    this.categoryLabelOptions,
    this.contributionAnalysisDefaults,
    this.dataLabels,
    this.donutOptions,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.smallMultiplesOptions,
    this.sortConfiguration,
    this.tooltip,
    this.valueLabelOptions,
    this.visualPalette,
  });

  factory PieChartConfiguration.fromJson(Map<String, dynamic> json) {
    return PieChartConfiguration(
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      contributionAnalysisDefaults: (json['ContributionAnalysisDefaults']
              as List?)
          ?.whereNotNull()
          .map((e) =>
              ContributionAnalysisDefault.fromJson(e as Map<String, dynamic>))
          .toList(),
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      donutOptions: json['DonutOptions'] != null
          ? DonutOptions.fromJson(json['DonutOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? PieChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      smallMultiplesOptions: json['SmallMultiplesOptions'] != null
          ? SmallMultiplesOptions.fromJson(
              json['SmallMultiplesOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? PieChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      valueLabelOptions: json['ValueLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ValueLabelOptions'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryLabelOptions = this.categoryLabelOptions;
    final contributionAnalysisDefaults = this.contributionAnalysisDefaults;
    final dataLabels = this.dataLabels;
    final donutOptions = this.donutOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final smallMultiplesOptions = this.smallMultiplesOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final valueLabelOptions = this.valueLabelOptions;
    final visualPalette = this.visualPalette;
    return {
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (contributionAnalysisDefaults != null)
        'ContributionAnalysisDefaults': contributionAnalysisDefaults,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (donutOptions != null) 'DonutOptions': donutOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (smallMultiplesOptions != null)
        'SmallMultiplesOptions': smallMultiplesOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (valueLabelOptions != null) 'ValueLabelOptions': valueLabelOptions,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The field well configuration of a pie chart.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class PieChartFieldWells {
  /// The field well configuration of a pie chart.
  final PieChartAggregatedFieldWells? pieChartAggregatedFieldWells;

  PieChartFieldWells({
    this.pieChartAggregatedFieldWells,
  });

  factory PieChartFieldWells.fromJson(Map<String, dynamic> json) {
    return PieChartFieldWells(
      pieChartAggregatedFieldWells: json['PieChartAggregatedFieldWells'] != null
          ? PieChartAggregatedFieldWells.fromJson(
              json['PieChartAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final pieChartAggregatedFieldWells = this.pieChartAggregatedFieldWells;
    return {
      if (pieChartAggregatedFieldWells != null)
        'PieChartAggregatedFieldWells': pieChartAggregatedFieldWells,
    };
  }
}

/// The sort configuration of a pie chart.
class PieChartSortConfiguration {
  /// The limit on the number of categories that are displayed in a pie chart.
  final ItemsLimitConfiguration? categoryItemsLimit;

  /// The sort configuration of the category fields.
  final List<FieldSortOptions>? categorySort;

  /// The limit on the number of small multiples panels that are displayed.
  final ItemsLimitConfiguration? smallMultiplesLimitConfiguration;

  /// The sort configuration of the small multiples field.
  final List<FieldSortOptions>? smallMultiplesSort;

  PieChartSortConfiguration({
    this.categoryItemsLimit,
    this.categorySort,
    this.smallMultiplesLimitConfiguration,
    this.smallMultiplesSort,
  });

  factory PieChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return PieChartSortConfiguration(
      categoryItemsLimit: json['CategoryItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['CategoryItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      smallMultiplesLimitConfiguration:
          json['SmallMultiplesLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['SmallMultiplesLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      smallMultiplesSort: (json['SmallMultiplesSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimit = this.categoryItemsLimit;
    final categorySort = this.categorySort;
    final smallMultiplesLimitConfiguration =
        this.smallMultiplesLimitConfiguration;
    final smallMultiplesSort = this.smallMultiplesSort;
    return {
      if (categoryItemsLimit != null) 'CategoryItemsLimit': categoryItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
      if (smallMultiplesLimitConfiguration != null)
        'SmallMultiplesLimitConfiguration': smallMultiplesLimitConfiguration,
      if (smallMultiplesSort != null) 'SmallMultiplesSort': smallMultiplesSort,
    };
  }
}

/// A pie or donut chart.
///
/// The <code>PieChartVisual</code> structure describes a visual that is a
/// member of the pie chart family.
///
/// The following charts can be described by using this structure:
///
/// <ul>
/// <li>
/// Pie charts
/// </li>
/// <li>
/// Donut charts
/// </li>
/// </ul>
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using
/// pie charts</a> in the <i>Amazon QuickSight User Guide</i>.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/donut-chart.html">Using
/// donut charts</a> in the <i>Amazon QuickSight User Guide</i>.
class PieChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a pie chart.
  final PieChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  PieChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory PieChartVisual.fromJson(Map<String, dynamic> json) {
    return PieChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? PieChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The field sort options for a pivot table sort configuration.
class PivotFieldSortOptions {
  /// The field ID for the field sort options.
  final String fieldId;

  /// The sort by field for the field sort options.
  final PivotTableSortBy sortBy;

  PivotFieldSortOptions({
    required this.fieldId,
    required this.sortBy,
  });

  factory PivotFieldSortOptions.fromJson(Map<String, dynamic> json) {
    return PivotFieldSortOptions(
      fieldId: json['FieldId'] as String,
      sortBy: PivotTableSortBy.fromJson(json['SortBy'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final sortBy = this.sortBy;
    return {
      'FieldId': fieldId,
      'SortBy': sortBy,
    };
  }
}

/// The aggregated field well for the pivot table.
class PivotTableAggregatedFieldWells {
  /// The columns field well for a pivot table. Values are grouped by columns
  /// fields.
  final List<DimensionField>? columns;

  /// The rows field well for a pivot table. Values are grouped by rows fields.
  final List<DimensionField>? rows;

  /// The values field well for a pivot table. Values are aggregated based on rows
  /// and columns fields.
  final List<MeasureField>? values;

  PivotTableAggregatedFieldWells({
    this.columns,
    this.rows,
    this.values,
  });

  factory PivotTableAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return PivotTableAggregatedFieldWells(
      columns: (json['Columns'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      rows: (json['Rows'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    final rows = this.rows;
    final values = this.values;
    return {
      if (columns != null) 'Columns': columns,
      if (rows != null) 'Rows': rows,
      if (values != null) 'Values': values,
    };
  }
}

/// The cell conditional formatting option for a pivot table.
class PivotTableCellConditionalFormatting {
  /// The field ID of the cell for conditional formatting.
  final String fieldId;

  /// The scope of the cell for conditional formatting.
  final PivotTableConditionalFormattingScope? scope;

  /// A list of cell scopes for conditional formatting.
  final List<PivotTableConditionalFormattingScope>? scopes;

  /// The text format of the cell for conditional formatting.
  final TextConditionalFormat? textFormat;

  PivotTableCellConditionalFormatting({
    required this.fieldId,
    this.scope,
    this.scopes,
    this.textFormat,
  });

  factory PivotTableCellConditionalFormatting.fromJson(
      Map<String, dynamic> json) {
    return PivotTableCellConditionalFormatting(
      fieldId: json['FieldId'] as String,
      scope: json['Scope'] != null
          ? PivotTableConditionalFormattingScope.fromJson(
              json['Scope'] as Map<String, dynamic>)
          : null,
      scopes: (json['Scopes'] as List?)
          ?.whereNotNull()
          .map((e) => PivotTableConditionalFormattingScope.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      textFormat: json['TextFormat'] != null
          ? TextConditionalFormat.fromJson(
              json['TextFormat'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final scope = this.scope;
    final scopes = this.scopes;
    final textFormat = this.textFormat;
    return {
      'FieldId': fieldId,
      if (scope != null) 'Scope': scope,
      if (scopes != null) 'Scopes': scopes,
      if (textFormat != null) 'TextFormat': textFormat,
    };
  }
}

/// The conditional formatting for a <code>PivotTableVisual</code>.
class PivotTableConditionalFormatting {
  /// Conditional formatting options for a <code>PivotTableVisual</code>.
  final List<PivotTableConditionalFormattingOption>?
      conditionalFormattingOptions;

  PivotTableConditionalFormatting({
    this.conditionalFormattingOptions,
  });

  factory PivotTableConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return PivotTableConditionalFormatting(
      conditionalFormattingOptions:
          (json['ConditionalFormattingOptions'] as List?)
              ?.whereNotNull()
              .map((e) => PivotTableConditionalFormattingOption.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final conditionalFormattingOptions = this.conditionalFormattingOptions;
    return {
      if (conditionalFormattingOptions != null)
        'ConditionalFormattingOptions': conditionalFormattingOptions,
    };
  }
}

/// Conditional formatting options for a <code>PivotTableVisual</code>.
class PivotTableConditionalFormattingOption {
  /// The cell conditional formatting option for a pivot table.
  final PivotTableCellConditionalFormatting? cell;

  PivotTableConditionalFormattingOption({
    this.cell,
  });

  factory PivotTableConditionalFormattingOption.fromJson(
      Map<String, dynamic> json) {
    return PivotTableConditionalFormattingOption(
      cell: json['Cell'] != null
          ? PivotTableCellConditionalFormatting.fromJson(
              json['Cell'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cell = this.cell;
    return {
      if (cell != null) 'Cell': cell,
    };
  }
}

/// The scope of the cell for conditional formatting.
class PivotTableConditionalFormattingScope {
  /// The role (field, field total, grand total) of the cell for conditional
  /// formatting.
  final PivotTableConditionalFormattingScopeRole? role;

  PivotTableConditionalFormattingScope({
    this.role,
  });

  factory PivotTableConditionalFormattingScope.fromJson(
      Map<String, dynamic> json) {
    return PivotTableConditionalFormattingScope(
      role: (json['Role'] as String?)
          ?.toPivotTableConditionalFormattingScopeRole(),
    );
  }

  Map<String, dynamic> toJson() {
    final role = this.role;
    return {
      if (role != null) 'Role': role.toValue(),
    };
  }
}

enum PivotTableConditionalFormattingScopeRole {
  field,
  fieldTotal,
  grandTotal,
}

extension PivotTableConditionalFormattingScopeRoleValueExtension
    on PivotTableConditionalFormattingScopeRole {
  String toValue() {
    switch (this) {
      case PivotTableConditionalFormattingScopeRole.field:
        return 'FIELD';
      case PivotTableConditionalFormattingScopeRole.fieldTotal:
        return 'FIELD_TOTAL';
      case PivotTableConditionalFormattingScopeRole.grandTotal:
        return 'GRAND_TOTAL';
    }
  }
}

extension PivotTableConditionalFormattingScopeRoleFromString on String {
  PivotTableConditionalFormattingScopeRole
      toPivotTableConditionalFormattingScopeRole() {
    switch (this) {
      case 'FIELD':
        return PivotTableConditionalFormattingScopeRole.field;
      case 'FIELD_TOTAL':
        return PivotTableConditionalFormattingScopeRole.fieldTotal;
      case 'GRAND_TOTAL':
        return PivotTableConditionalFormattingScopeRole.grandTotal;
    }
    throw Exception(
        '$this is not known in enum PivotTableConditionalFormattingScopeRole');
  }
}

/// The configuration for a <code>PivotTableVisual</code>.
class PivotTableConfiguration {
  /// The field options for a pivot table visual.
  final PivotTableFieldOptions? fieldOptions;

  /// The field wells of the visual.
  final PivotTableFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The paginated report options for a pivot table visual.
  final PivotTablePaginatedReportOptions? paginatedReportOptions;

  /// The sort configuration for a <code>PivotTableVisual</code>.
  final PivotTableSortConfiguration? sortConfiguration;

  /// The table options for a pivot table visual.
  final PivotTableOptions? tableOptions;

  /// The total options for a pivot table visual.
  final PivotTableTotalOptions? totalOptions;

  PivotTableConfiguration({
    this.fieldOptions,
    this.fieldWells,
    this.interactions,
    this.paginatedReportOptions,
    this.sortConfiguration,
    this.tableOptions,
    this.totalOptions,
  });

  factory PivotTableConfiguration.fromJson(Map<String, dynamic> json) {
    return PivotTableConfiguration(
      fieldOptions: json['FieldOptions'] != null
          ? PivotTableFieldOptions.fromJson(
              json['FieldOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? PivotTableFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      paginatedReportOptions: json['PaginatedReportOptions'] != null
          ? PivotTablePaginatedReportOptions.fromJson(
              json['PaginatedReportOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? PivotTableSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tableOptions: json['TableOptions'] != null
          ? PivotTableOptions.fromJson(
              json['TableOptions'] as Map<String, dynamic>)
          : null,
      totalOptions: json['TotalOptions'] != null
          ? PivotTableTotalOptions.fromJson(
              json['TotalOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldOptions = this.fieldOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final paginatedReportOptions = this.paginatedReportOptions;
    final sortConfiguration = this.sortConfiguration;
    final tableOptions = this.tableOptions;
    final totalOptions = this.totalOptions;
    return {
      if (fieldOptions != null) 'FieldOptions': fieldOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (paginatedReportOptions != null)
        'PaginatedReportOptions': paginatedReportOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tableOptions != null) 'TableOptions': tableOptions,
      if (totalOptions != null) 'TotalOptions': totalOptions,
    };
  }
}

/// The data path options for the pivot table field options.
class PivotTableDataPathOption {
  /// The list of data path values for the data path options.
  final List<DataPathValue> dataPathList;

  /// The width of the data path option.
  final String? width;

  PivotTableDataPathOption({
    required this.dataPathList,
    this.width,
  });

  factory PivotTableDataPathOption.fromJson(Map<String, dynamic> json) {
    return PivotTableDataPathOption(
      dataPathList: (json['DataPathList'] as List)
          .whereNotNull()
          .map((e) => DataPathValue.fromJson(e as Map<String, dynamic>))
          .toList(),
      width: json['Width'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataPathList = this.dataPathList;
    final width = this.width;
    return {
      'DataPathList': dataPathList,
      if (width != null) 'Width': width,
    };
  }
}

enum PivotTableDataPathType {
  hierarchyRowsLayoutColumn,
  multipleRowMetricsColumn,
  emptyColumnHeader,
  countMetricColumn,
}

extension PivotTableDataPathTypeValueExtension on PivotTableDataPathType {
  String toValue() {
    switch (this) {
      case PivotTableDataPathType.hierarchyRowsLayoutColumn:
        return 'HIERARCHY_ROWS_LAYOUT_COLUMN';
      case PivotTableDataPathType.multipleRowMetricsColumn:
        return 'MULTIPLE_ROW_METRICS_COLUMN';
      case PivotTableDataPathType.emptyColumnHeader:
        return 'EMPTY_COLUMN_HEADER';
      case PivotTableDataPathType.countMetricColumn:
        return 'COUNT_METRIC_COLUMN';
    }
  }
}

extension PivotTableDataPathTypeFromString on String {
  PivotTableDataPathType toPivotTableDataPathType() {
    switch (this) {
      case 'HIERARCHY_ROWS_LAYOUT_COLUMN':
        return PivotTableDataPathType.hierarchyRowsLayoutColumn;
      case 'MULTIPLE_ROW_METRICS_COLUMN':
        return PivotTableDataPathType.multipleRowMetricsColumn;
      case 'EMPTY_COLUMN_HEADER':
        return PivotTableDataPathType.emptyColumnHeader;
      case 'COUNT_METRIC_COLUMN':
        return PivotTableDataPathType.countMetricColumn;
    }
    throw Exception('$this is not known in enum PivotTableDataPathType');
  }
}

enum PivotTableFieldCollapseState {
  collapsed,
  expanded,
}

extension PivotTableFieldCollapseStateValueExtension
    on PivotTableFieldCollapseState {
  String toValue() {
    switch (this) {
      case PivotTableFieldCollapseState.collapsed:
        return 'COLLAPSED';
      case PivotTableFieldCollapseState.expanded:
        return 'EXPANDED';
    }
  }
}

extension PivotTableFieldCollapseStateFromString on String {
  PivotTableFieldCollapseState toPivotTableFieldCollapseState() {
    switch (this) {
      case 'COLLAPSED':
        return PivotTableFieldCollapseState.collapsed;
      case 'EXPANDED':
        return PivotTableFieldCollapseState.expanded;
    }
    throw Exception('$this is not known in enum PivotTableFieldCollapseState');
  }
}

/// The collapse state options for the pivot table field options.
class PivotTableFieldCollapseStateOption {
  /// A tagged-union object that sets the collapse state.
  final PivotTableFieldCollapseStateTarget target;

  /// The state of the field target of a pivot table. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>COLLAPSED</code>
  /// </li>
  /// <li>
  /// <code>EXPANDED</code>
  /// </li>
  /// </ul>
  final PivotTableFieldCollapseState? state;

  PivotTableFieldCollapseStateOption({
    required this.target,
    this.state,
  });

  factory PivotTableFieldCollapseStateOption.fromJson(
      Map<String, dynamic> json) {
    return PivotTableFieldCollapseStateOption(
      target: PivotTableFieldCollapseStateTarget.fromJson(
          json['Target'] as Map<String, dynamic>),
      state: (json['State'] as String?)?.toPivotTableFieldCollapseState(),
    );
  }

  Map<String, dynamic> toJson() {
    final target = this.target;
    final state = this.state;
    return {
      'Target': target,
      if (state != null) 'State': state.toValue(),
    };
  }
}

/// The target of a pivot table field collapse state.
class PivotTableFieldCollapseStateTarget {
  /// The data path of the pivot table's header. Used to set the collapse state.
  final List<DataPathValue>? fieldDataPathValues;

  /// The field ID of the pivot table that the collapse state needs to be set to.
  final String? fieldId;

  PivotTableFieldCollapseStateTarget({
    this.fieldDataPathValues,
    this.fieldId,
  });

  factory PivotTableFieldCollapseStateTarget.fromJson(
      Map<String, dynamic> json) {
    return PivotTableFieldCollapseStateTarget(
      fieldDataPathValues: (json['FieldDataPathValues'] as List?)
          ?.whereNotNull()
          .map((e) => DataPathValue.fromJson(e as Map<String, dynamic>))
          .toList(),
      fieldId: json['FieldId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldDataPathValues = this.fieldDataPathValues;
    final fieldId = this.fieldId;
    return {
      if (fieldDataPathValues != null)
        'FieldDataPathValues': fieldDataPathValues,
      if (fieldId != null) 'FieldId': fieldId,
    };
  }
}

/// The selected field options for the pivot table field options.
class PivotTableFieldOption {
  /// The field ID of the pivot table field.
  final String fieldId;

  /// The custom label of the pivot table field.
  final String? customLabel;

  /// The visibility of the pivot table field.
  final Visibility? visibility;

  PivotTableFieldOption({
    required this.fieldId,
    this.customLabel,
    this.visibility,
  });

  factory PivotTableFieldOption.fromJson(Map<String, dynamic> json) {
    return PivotTableFieldOption(
      fieldId: json['FieldId'] as String,
      customLabel: json['CustomLabel'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final customLabel = this.customLabel;
    final visibility = this.visibility;
    return {
      'FieldId': fieldId,
      if (customLabel != null) 'CustomLabel': customLabel,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The field options for a pivot table visual.
class PivotTableFieldOptions {
  /// The collapse state options for the pivot table field options.
  final List<PivotTableFieldCollapseStateOption>? collapseStateOptions;

  /// The data path options for the pivot table field options.
  final List<PivotTableDataPathOption>? dataPathOptions;

  /// The selected field options for the pivot table field options.
  final List<PivotTableFieldOption>? selectedFieldOptions;

  PivotTableFieldOptions({
    this.collapseStateOptions,
    this.dataPathOptions,
    this.selectedFieldOptions,
  });

  factory PivotTableFieldOptions.fromJson(Map<String, dynamic> json) {
    return PivotTableFieldOptions(
      collapseStateOptions: (json['CollapseStateOptions'] as List?)
          ?.whereNotNull()
          .map((e) => PivotTableFieldCollapseStateOption.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      dataPathOptions: (json['DataPathOptions'] as List?)
          ?.whereNotNull()
          .map((e) =>
              PivotTableDataPathOption.fromJson(e as Map<String, dynamic>))
          .toList(),
      selectedFieldOptions: (json['SelectedFieldOptions'] as List?)
          ?.whereNotNull()
          .map((e) => PivotTableFieldOption.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final collapseStateOptions = this.collapseStateOptions;
    final dataPathOptions = this.dataPathOptions;
    final selectedFieldOptions = this.selectedFieldOptions;
    return {
      if (collapseStateOptions != null)
        'CollapseStateOptions': collapseStateOptions,
      if (dataPathOptions != null) 'DataPathOptions': dataPathOptions,
      if (selectedFieldOptions != null)
        'SelectedFieldOptions': selectedFieldOptions,
    };
  }
}

/// The optional configuration of subtotals cells.
class PivotTableFieldSubtotalOptions {
  /// The field ID of the subtotal options.
  final String? fieldId;

  PivotTableFieldSubtotalOptions({
    this.fieldId,
  });

  factory PivotTableFieldSubtotalOptions.fromJson(Map<String, dynamic> json) {
    return PivotTableFieldSubtotalOptions(
      fieldId: json['FieldId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    return {
      if (fieldId != null) 'FieldId': fieldId,
    };
  }
}

/// The field wells for a pivot table visual.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class PivotTableFieldWells {
  /// The aggregated field well for the pivot table.
  final PivotTableAggregatedFieldWells? pivotTableAggregatedFieldWells;

  PivotTableFieldWells({
    this.pivotTableAggregatedFieldWells,
  });

  factory PivotTableFieldWells.fromJson(Map<String, dynamic> json) {
    return PivotTableFieldWells(
      pivotTableAggregatedFieldWells: json['PivotTableAggregatedFieldWells'] !=
              null
          ? PivotTableAggregatedFieldWells.fromJson(
              json['PivotTableAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final pivotTableAggregatedFieldWells = this.pivotTableAggregatedFieldWells;
    return {
      if (pivotTableAggregatedFieldWells != null)
        'PivotTableAggregatedFieldWells': pivotTableAggregatedFieldWells,
    };
  }
}

enum PivotTableMetricPlacement {
  row,
  column,
}

extension PivotTableMetricPlacementValueExtension on PivotTableMetricPlacement {
  String toValue() {
    switch (this) {
      case PivotTableMetricPlacement.row:
        return 'ROW';
      case PivotTableMetricPlacement.column:
        return 'COLUMN';
    }
  }
}

extension PivotTableMetricPlacementFromString on String {
  PivotTableMetricPlacement toPivotTableMetricPlacement() {
    switch (this) {
      case 'ROW':
        return PivotTableMetricPlacement.row;
      case 'COLUMN':
        return PivotTableMetricPlacement.column;
    }
    throw Exception('$this is not known in enum PivotTableMetricPlacement');
  }
}

/// The table options for a pivot table visual.
class PivotTableOptions {
  /// The table cell style of cells.
  final TableCellStyle? cellStyle;

  /// The visibility setting of a pivot table's collapsed row dimension fields. If
  /// the value of this structure is <code>HIDDEN</code>, all collapsed columns in
  /// a pivot table are automatically hidden. The default value is
  /// <code>VISIBLE</code>.
  final Visibility? collapsedRowDimensionsVisibility;

  /// The table cell style of the column header.
  final TableCellStyle? columnHeaderStyle;

  /// The visibility of the column names.
  final Visibility? columnNamesVisibility;

  /// The default cell width of the pivot table.
  final String? defaultCellWidth;

  /// The metric placement (row, column) options.
  final PivotTableMetricPlacement? metricPlacement;

  /// The row alternate color options (widget status, row alternate colors).
  final RowAlternateColorOptions? rowAlternateColorOptions;

  /// The table cell style of row field names.
  final TableCellStyle? rowFieldNamesStyle;

  /// The table cell style of the row headers.
  final TableCellStyle? rowHeaderStyle;

  /// The options for the label that is located above the row headers. This option
  /// is only applicable when <code>RowsLayout</code> is set to
  /// <code>HIERARCHY</code>.
  final PivotTableRowsLabelOptions? rowsLabelOptions;

  /// The layout for the row dimension headers of a pivot table. Choose one of the
  /// following options.
  ///
  /// <ul>
  /// <li>
  /// <code>TABULAR</code>: (Default) Each row field is displayed in a separate
  /// column.
  /// </li>
  /// <li>
  /// <code>HIERARCHY</code>: All row fields are displayed in a single column.
  /// Indentation is used to differentiate row headers of different fields.
  /// </li>
  /// </ul>
  final PivotTableRowsLayout? rowsLayout;

  /// The visibility of the single metric options.
  final Visibility? singleMetricVisibility;

  /// Determines the visibility of the pivot table.
  final Visibility? toggleButtonsVisibility;

  PivotTableOptions({
    this.cellStyle,
    this.collapsedRowDimensionsVisibility,
    this.columnHeaderStyle,
    this.columnNamesVisibility,
    this.defaultCellWidth,
    this.metricPlacement,
    this.rowAlternateColorOptions,
    this.rowFieldNamesStyle,
    this.rowHeaderStyle,
    this.rowsLabelOptions,
    this.rowsLayout,
    this.singleMetricVisibility,
    this.toggleButtonsVisibility,
  });

  factory PivotTableOptions.fromJson(Map<String, dynamic> json) {
    return PivotTableOptions(
      cellStyle: json['CellStyle'] != null
          ? TableCellStyle.fromJson(json['CellStyle'] as Map<String, dynamic>)
          : null,
      collapsedRowDimensionsVisibility:
          (json['CollapsedRowDimensionsVisibility'] as String?)?.toVisibility(),
      columnHeaderStyle: json['ColumnHeaderStyle'] != null
          ? TableCellStyle.fromJson(
              json['ColumnHeaderStyle'] as Map<String, dynamic>)
          : null,
      columnNamesVisibility:
          (json['ColumnNamesVisibility'] as String?)?.toVisibility(),
      defaultCellWidth: json['DefaultCellWidth'] as String?,
      metricPlacement:
          (json['MetricPlacement'] as String?)?.toPivotTableMetricPlacement(),
      rowAlternateColorOptions: json['RowAlternateColorOptions'] != null
          ? RowAlternateColorOptions.fromJson(
              json['RowAlternateColorOptions'] as Map<String, dynamic>)
          : null,
      rowFieldNamesStyle: json['RowFieldNamesStyle'] != null
          ? TableCellStyle.fromJson(
              json['RowFieldNamesStyle'] as Map<String, dynamic>)
          : null,
      rowHeaderStyle: json['RowHeaderStyle'] != null
          ? TableCellStyle.fromJson(
              json['RowHeaderStyle'] as Map<String, dynamic>)
          : null,
      rowsLabelOptions: json['RowsLabelOptions'] != null
          ? PivotTableRowsLabelOptions.fromJson(
              json['RowsLabelOptions'] as Map<String, dynamic>)
          : null,
      rowsLayout: (json['RowsLayout'] as String?)?.toPivotTableRowsLayout(),
      singleMetricVisibility:
          (json['SingleMetricVisibility'] as String?)?.toVisibility(),
      toggleButtonsVisibility:
          (json['ToggleButtonsVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final cellStyle = this.cellStyle;
    final collapsedRowDimensionsVisibility =
        this.collapsedRowDimensionsVisibility;
    final columnHeaderStyle = this.columnHeaderStyle;
    final columnNamesVisibility = this.columnNamesVisibility;
    final defaultCellWidth = this.defaultCellWidth;
    final metricPlacement = this.metricPlacement;
    final rowAlternateColorOptions = this.rowAlternateColorOptions;
    final rowFieldNamesStyle = this.rowFieldNamesStyle;
    final rowHeaderStyle = this.rowHeaderStyle;
    final rowsLabelOptions = this.rowsLabelOptions;
    final rowsLayout = this.rowsLayout;
    final singleMetricVisibility = this.singleMetricVisibility;
    final toggleButtonsVisibility = this.toggleButtonsVisibility;
    return {
      if (cellStyle != null) 'CellStyle': cellStyle,
      if (collapsedRowDimensionsVisibility != null)
        'CollapsedRowDimensionsVisibility':
            collapsedRowDimensionsVisibility.toValue(),
      if (columnHeaderStyle != null) 'ColumnHeaderStyle': columnHeaderStyle,
      if (columnNamesVisibility != null)
        'ColumnNamesVisibility': columnNamesVisibility.toValue(),
      if (defaultCellWidth != null) 'DefaultCellWidth': defaultCellWidth,
      if (metricPlacement != null) 'MetricPlacement': metricPlacement.toValue(),
      if (rowAlternateColorOptions != null)
        'RowAlternateColorOptions': rowAlternateColorOptions,
      if (rowFieldNamesStyle != null) 'RowFieldNamesStyle': rowFieldNamesStyle,
      if (rowHeaderStyle != null) 'RowHeaderStyle': rowHeaderStyle,
      if (rowsLabelOptions != null) 'RowsLabelOptions': rowsLabelOptions,
      if (rowsLayout != null) 'RowsLayout': rowsLayout.toValue(),
      if (singleMetricVisibility != null)
        'SingleMetricVisibility': singleMetricVisibility.toValue(),
      if (toggleButtonsVisibility != null)
        'ToggleButtonsVisibility': toggleButtonsVisibility.toValue(),
    };
  }
}

/// The paginated report options for a pivot table visual.
class PivotTablePaginatedReportOptions {
  /// The visibility of the repeating header rows on each page.
  final Visibility? overflowColumnHeaderVisibility;

  /// The visibility of the printing table overflow across pages.
  final Visibility? verticalOverflowVisibility;

  PivotTablePaginatedReportOptions({
    this.overflowColumnHeaderVisibility,
    this.verticalOverflowVisibility,
  });

  factory PivotTablePaginatedReportOptions.fromJson(Map<String, dynamic> json) {
    return PivotTablePaginatedReportOptions(
      overflowColumnHeaderVisibility:
          (json['OverflowColumnHeaderVisibility'] as String?)?.toVisibility(),
      verticalOverflowVisibility:
          (json['VerticalOverflowVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final overflowColumnHeaderVisibility = this.overflowColumnHeaderVisibility;
    final verticalOverflowVisibility = this.verticalOverflowVisibility;
    return {
      if (overflowColumnHeaderVisibility != null)
        'OverflowColumnHeaderVisibility':
            overflowColumnHeaderVisibility.toValue(),
      if (verticalOverflowVisibility != null)
        'VerticalOverflowVisibility': verticalOverflowVisibility.toValue(),
    };
  }
}

/// The options for the label thta is located above the row headers. This option
/// is only applicable when <code>RowsLayout</code> is set to
/// <code>HIERARCHY</code>.
class PivotTableRowsLabelOptions {
  /// The custom label string for the rows label.
  final String? customLabel;

  /// The visibility of the rows label.
  final Visibility? visibility;

  PivotTableRowsLabelOptions({
    this.customLabel,
    this.visibility,
  });

  factory PivotTableRowsLabelOptions.fromJson(Map<String, dynamic> json) {
    return PivotTableRowsLabelOptions(
      customLabel: json['CustomLabel'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final customLabel = this.customLabel;
    final visibility = this.visibility;
    return {
      if (customLabel != null) 'CustomLabel': customLabel,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

enum PivotTableRowsLayout {
  tabular,
  hierarchy,
}

extension PivotTableRowsLayoutValueExtension on PivotTableRowsLayout {
  String toValue() {
    switch (this) {
      case PivotTableRowsLayout.tabular:
        return 'TABULAR';
      case PivotTableRowsLayout.hierarchy:
        return 'HIERARCHY';
    }
  }
}

extension PivotTableRowsLayoutFromString on String {
  PivotTableRowsLayout toPivotTableRowsLayout() {
    switch (this) {
      case 'TABULAR':
        return PivotTableRowsLayout.tabular;
      case 'HIERARCHY':
        return PivotTableRowsLayout.hierarchy;
    }
    throw Exception('$this is not known in enum PivotTableRowsLayout');
  }
}

/// The sort by field for the field sort options.
class PivotTableSortBy {
  /// The column sort (field id, direction) for the pivot table sort by options.
  final ColumnSort? column;

  /// The data path sort (data path value, direction) for the pivot table sort by
  /// options.
  final DataPathSort? dataPath;

  /// The field sort (field id, direction) for the pivot table sort by options.
  final FieldSort? field;

  PivotTableSortBy({
    this.column,
    this.dataPath,
    this.field,
  });

  factory PivotTableSortBy.fromJson(Map<String, dynamic> json) {
    return PivotTableSortBy(
      column: json['Column'] != null
          ? ColumnSort.fromJson(json['Column'] as Map<String, dynamic>)
          : null,
      dataPath: json['DataPath'] != null
          ? DataPathSort.fromJson(json['DataPath'] as Map<String, dynamic>)
          : null,
      field: json['Field'] != null
          ? FieldSort.fromJson(json['Field'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final dataPath = this.dataPath;
    final field = this.field;
    return {
      if (column != null) 'Column': column,
      if (dataPath != null) 'DataPath': dataPath,
      if (field != null) 'Field': field,
    };
  }
}

/// The sort configuration for a <code>PivotTableVisual</code>.
class PivotTableSortConfiguration {
  /// The field sort options for a pivot table sort configuration.
  final List<PivotFieldSortOptions>? fieldSortOptions;

  PivotTableSortConfiguration({
    this.fieldSortOptions,
  });

  factory PivotTableSortConfiguration.fromJson(Map<String, dynamic> json) {
    return PivotTableSortConfiguration(
      fieldSortOptions: (json['FieldSortOptions'] as List?)
          ?.whereNotNull()
          .map((e) => PivotFieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldSortOptions = this.fieldSortOptions;
    return {
      if (fieldSortOptions != null) 'FieldSortOptions': fieldSortOptions,
    };
  }
}

enum PivotTableSubtotalLevel {
  all,
  custom,
  last,
}

extension PivotTableSubtotalLevelValueExtension on PivotTableSubtotalLevel {
  String toValue() {
    switch (this) {
      case PivotTableSubtotalLevel.all:
        return 'ALL';
      case PivotTableSubtotalLevel.custom:
        return 'CUSTOM';
      case PivotTableSubtotalLevel.last:
        return 'LAST';
    }
  }
}

extension PivotTableSubtotalLevelFromString on String {
  PivotTableSubtotalLevel toPivotTableSubtotalLevel() {
    switch (this) {
      case 'ALL':
        return PivotTableSubtotalLevel.all;
      case 'CUSTOM':
        return PivotTableSubtotalLevel.custom;
      case 'LAST':
        return PivotTableSubtotalLevel.last;
    }
    throw Exception('$this is not known in enum PivotTableSubtotalLevel');
  }
}

/// The total options for a pivot table visual.
class PivotTableTotalOptions {
  /// The column subtotal options.
  final SubtotalOptions? columnSubtotalOptions;

  /// The column total options.
  final PivotTotalOptions? columnTotalOptions;

  /// The row subtotal options.
  final SubtotalOptions? rowSubtotalOptions;

  /// The row total options.
  final PivotTotalOptions? rowTotalOptions;

  PivotTableTotalOptions({
    this.columnSubtotalOptions,
    this.columnTotalOptions,
    this.rowSubtotalOptions,
    this.rowTotalOptions,
  });

  factory PivotTableTotalOptions.fromJson(Map<String, dynamic> json) {
    return PivotTableTotalOptions(
      columnSubtotalOptions: json['ColumnSubtotalOptions'] != null
          ? SubtotalOptions.fromJson(
              json['ColumnSubtotalOptions'] as Map<String, dynamic>)
          : null,
      columnTotalOptions: json['ColumnTotalOptions'] != null
          ? PivotTotalOptions.fromJson(
              json['ColumnTotalOptions'] as Map<String, dynamic>)
          : null,
      rowSubtotalOptions: json['RowSubtotalOptions'] != null
          ? SubtotalOptions.fromJson(
              json['RowSubtotalOptions'] as Map<String, dynamic>)
          : null,
      rowTotalOptions: json['RowTotalOptions'] != null
          ? PivotTotalOptions.fromJson(
              json['RowTotalOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final columnSubtotalOptions = this.columnSubtotalOptions;
    final columnTotalOptions = this.columnTotalOptions;
    final rowSubtotalOptions = this.rowSubtotalOptions;
    final rowTotalOptions = this.rowTotalOptions;
    return {
      if (columnSubtotalOptions != null)
        'ColumnSubtotalOptions': columnSubtotalOptions,
      if (columnTotalOptions != null) 'ColumnTotalOptions': columnTotalOptions,
      if (rowSubtotalOptions != null) 'RowSubtotalOptions': rowSubtotalOptions,
      if (rowTotalOptions != null) 'RowTotalOptions': rowTotalOptions,
    };
  }
}

/// A pivot table.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using
/// pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.
class PivotTableVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final PivotTableConfiguration? chartConfiguration;

  /// The conditional formatting for a <code>PivotTableVisual</code>.
  final PivotTableConditionalFormatting? conditionalFormatting;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  PivotTableVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.conditionalFormatting,
    this.subtitle,
    this.title,
  });

  factory PivotTableVisual.fromJson(Map<String, dynamic> json) {
    return PivotTableVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? PivotTableConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      conditionalFormatting: json['ConditionalFormatting'] != null
          ? PivotTableConditionalFormatting.fromJson(
              json['ConditionalFormatting'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final conditionalFormatting = this.conditionalFormatting;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (conditionalFormatting != null)
        'ConditionalFormatting': conditionalFormatting,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The optional configuration of totals cells in a
/// <code>PivotTableVisual</code>.
class PivotTotalOptions {
  /// The custom label string for the total cells.
  final String? customLabel;

  /// The cell styling options for the total of header cells.
  final TableCellStyle? metricHeaderCellStyle;

  /// The placement (start, end) for the total cells.
  final TableTotalsPlacement? placement;

  /// The scroll status (pinned, scrolled) for the total cells.
  final TableTotalsScrollStatus? scrollStatus;

  /// The total aggregation options for each value field.
  final List<TotalAggregationOption>? totalAggregationOptions;

  /// The cell styling options for the total cells.
  final TableCellStyle? totalCellStyle;

  /// The visibility configuration for the total cells.
  final Visibility? totalsVisibility;

  /// The cell styling options for the totals of value cells.
  final TableCellStyle? valueCellStyle;

  PivotTotalOptions({
    this.customLabel,
    this.metricHeaderCellStyle,
    this.placement,
    this.scrollStatus,
    this.totalAggregationOptions,
    this.totalCellStyle,
    this.totalsVisibility,
    this.valueCellStyle,
  });

  factory PivotTotalOptions.fromJson(Map<String, dynamic> json) {
    return PivotTotalOptions(
      customLabel: json['CustomLabel'] as String?,
      metricHeaderCellStyle: json['MetricHeaderCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['MetricHeaderCellStyle'] as Map<String, dynamic>)
          : null,
      placement: (json['Placement'] as String?)?.toTableTotalsPlacement(),
      scrollStatus:
          (json['ScrollStatus'] as String?)?.toTableTotalsScrollStatus(),
      totalAggregationOptions: (json['TotalAggregationOptions'] as List?)
          ?.whereNotNull()
          .map(
              (e) => TotalAggregationOption.fromJson(e as Map<String, dynamic>))
          .toList(),
      totalCellStyle: json['TotalCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['TotalCellStyle'] as Map<String, dynamic>)
          : null,
      totalsVisibility: (json['TotalsVisibility'] as String?)?.toVisibility(),
      valueCellStyle: json['ValueCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['ValueCellStyle'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customLabel = this.customLabel;
    final metricHeaderCellStyle = this.metricHeaderCellStyle;
    final placement = this.placement;
    final scrollStatus = this.scrollStatus;
    final totalAggregationOptions = this.totalAggregationOptions;
    final totalCellStyle = this.totalCellStyle;
    final totalsVisibility = this.totalsVisibility;
    final valueCellStyle = this.valueCellStyle;
    return {
      if (customLabel != null) 'CustomLabel': customLabel,
      if (metricHeaderCellStyle != null)
        'MetricHeaderCellStyle': metricHeaderCellStyle,
      if (placement != null) 'Placement': placement.toValue(),
      if (scrollStatus != null) 'ScrollStatus': scrollStatus.toValue(),
      if (totalAggregationOptions != null)
        'TotalAggregationOptions': totalAggregationOptions,
      if (totalCellStyle != null) 'TotalCellStyle': totalCellStyle,
      if (totalsVisibility != null)
        'TotalsVisibility': totalsVisibility.toValue(),
      if (valueCellStyle != null) 'ValueCellStyle': valueCellStyle,
    };
  }
}

/// The parameters for PostgreSQL.
class PostgreSqlParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Port.
  final int port;

  PostgreSqlParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory PostgreSqlParameters.fromJson(Map<String, dynamic> json) {
    return PostgreSqlParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

/// The option that determines the hierarchy of the fields that are defined
/// during data preparation. These fields are available to use in any analysis
/// that uses the data source.
class PredefinedHierarchy {
  /// The list of columns that define the predefined hierarchy.
  final List<ColumnIdentifier> columns;

  /// The hierarchy ID of the predefined hierarchy.
  final String hierarchyId;

  /// The option that determines the drill down filters for the predefined
  /// hierarchy.
  final List<DrillDownFilter>? drillDownFilters;

  PredefinedHierarchy({
    required this.columns,
    required this.hierarchyId,
    this.drillDownFilters,
  });

  factory PredefinedHierarchy.fromJson(Map<String, dynamic> json) {
    return PredefinedHierarchy(
      columns: (json['Columns'] as List)
          .whereNotNull()
          .map((e) => ColumnIdentifier.fromJson(e as Map<String, dynamic>))
          .toList(),
      hierarchyId: json['HierarchyId'] as String,
      drillDownFilters: (json['DrillDownFilters'] as List?)
          ?.whereNotNull()
          .map((e) => DrillDownFilter.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columns = this.columns;
    final hierarchyId = this.hierarchyId;
    final drillDownFilters = this.drillDownFilters;
    return {
      'Columns': columns,
      'HierarchyId': hierarchyId,
      if (drillDownFilters != null) 'DrillDownFilters': drillDownFilters,
    };
  }
}

/// The parameters for Presto.
class PrestoParameters {
  /// Catalog.
  final String catalog;

  /// Host.
  final String host;

  /// Port.
  final int port;

  PrestoParameters({
    required this.catalog,
    required this.host,
    required this.port,
  });

  factory PrestoParameters.fromJson(Map<String, dynamic> json) {
    return PrestoParameters(
      catalog: json['Catalog'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final catalog = this.catalog;
    final host = this.host;
    final port = this.port;
    return {
      'Catalog': catalog,
      'Host': host,
      'Port': port,
    };
  }
}

enum PrimaryValueDisplayType {
  hidden,
  comparison,
  actual,
}

extension PrimaryValueDisplayTypeValueExtension on PrimaryValueDisplayType {
  String toValue() {
    switch (this) {
      case PrimaryValueDisplayType.hidden:
        return 'HIDDEN';
      case PrimaryValueDisplayType.comparison:
        return 'COMPARISON';
      case PrimaryValueDisplayType.actual:
        return 'ACTUAL';
    }
  }
}

extension PrimaryValueDisplayTypeFromString on String {
  PrimaryValueDisplayType toPrimaryValueDisplayType() {
    switch (this) {
      case 'HIDDEN':
        return PrimaryValueDisplayType.hidden;
      case 'COMPARISON':
        return PrimaryValueDisplayType.comparison;
      case 'ACTUAL':
        return PrimaryValueDisplayType.actual;
    }
    throw Exception('$this is not known in enum PrimaryValueDisplayType');
  }
}

/// The options that determine the presentation of the progress bar of a KPI
/// visual.
class ProgressBarOptions {
  /// The visibility of the progress bar.
  final Visibility? visibility;

  ProgressBarOptions({
    this.visibility,
  });

  factory ProgressBarOptions.fromJson(Map<String, dynamic> json) {
    return ProgressBarOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// A transform operation that projects columns. Operations that come after a
/// projection can only refer to projected columns.
class ProjectOperation {
  /// Projected columns.
  final List<String> projectedColumns;

  ProjectOperation({
    required this.projectedColumns,
  });

  factory ProjectOperation.fromJson(Map<String, dynamic> json) {
    return ProjectOperation(
      projectedColumns: (json['ProjectedColumns'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final projectedColumns = this.projectedColumns;
    return {
      'ProjectedColumns': projectedColumns,
    };
  }
}

enum PropertyRole {
  primary,
  id,
}

extension PropertyRoleValueExtension on PropertyRole {
  String toValue() {
    switch (this) {
      case PropertyRole.primary:
        return 'PRIMARY';
      case PropertyRole.id:
        return 'ID';
    }
  }
}

extension PropertyRoleFromString on String {
  PropertyRole toPropertyRole() {
    switch (this) {
      case 'PRIMARY':
        return PropertyRole.primary;
      case 'ID':
        return PropertyRole.id;
    }
    throw Exception('$this is not known in enum PropertyRole');
  }
}

enum PropertyUsage {
  inherit,
  dimension,
  measure,
}

extension PropertyUsageValueExtension on PropertyUsage {
  String toValue() {
    switch (this) {
      case PropertyUsage.inherit:
        return 'INHERIT';
      case PropertyUsage.dimension:
        return 'DIMENSION';
      case PropertyUsage.measure:
        return 'MEASURE';
    }
  }
}

extension PropertyUsageFromString on String {
  PropertyUsage toPropertyUsage() {
    switch (this) {
      case 'INHERIT':
        return PropertyUsage.inherit;
      case 'DIMENSION':
        return PropertyUsage.dimension;
      case 'MEASURE':
        return PropertyUsage.measure;
    }
    throw Exception('$this is not known in enum PropertyUsage');
  }
}

enum PurchaseMode {
  manual,
  autoPurchase,
}

extension PurchaseModeValueExtension on PurchaseMode {
  String toValue() {
    switch (this) {
      case PurchaseMode.manual:
        return 'MANUAL';
      case PurchaseMode.autoPurchase:
        return 'AUTO_PURCHASE';
    }
  }
}

extension PurchaseModeFromString on String {
  PurchaseMode toPurchaseMode() {
    switch (this) {
      case 'MANUAL':
        return PurchaseMode.manual;
      case 'AUTO_PURCHASE':
        return PurchaseMode.autoPurchase;
    }
    throw Exception('$this is not known in enum PurchaseMode');
  }
}

class PutDataSetRefreshPropertiesResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  PutDataSetRefreshPropertiesResponse({
    this.requestId,
    this.status,
  });

  factory PutDataSetRefreshPropertiesResponse.fromJson(
      Map<String, dynamic> json) {
    return PutDataSetRefreshPropertiesResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// Information about a queued dataset SPICE ingestion.
class QueueInfo {
  /// The ID of the ongoing ingestion. The queued ingestion is waiting for the
  /// ongoing ingestion to complete.
  final String queuedIngestion;

  /// The ID of the queued ingestion.
  final String waitingOnIngestion;

  QueueInfo({
    required this.queuedIngestion,
    required this.waitingOnIngestion,
  });

  factory QueueInfo.fromJson(Map<String, dynamic> json) {
    return QueueInfo(
      queuedIngestion: json['QueuedIngestion'] as String,
      waitingOnIngestion: json['WaitingOnIngestion'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final queuedIngestion = this.queuedIngestion;
    final waitingOnIngestion = this.waitingOnIngestion;
    return {
      'QueuedIngestion': queuedIngestion,
      'WaitingOnIngestion': waitingOnIngestion,
    };
  }
}

/// The aggregated field well configuration of a <code>RadarChartVisual</code>.
class RadarChartAggregatedFieldWells {
  /// The aggregated field well categories of a radar chart.
  final List<DimensionField>? category;

  /// The color that are assigned to the aggregated field wells of a radar chart.
  final List<DimensionField>? color;

  /// The values that are assigned to the aggregated field wells of a radar chart.
  final List<MeasureField>? values;

  RadarChartAggregatedFieldWells({
    this.category,
    this.color,
    this.values,
  });

  factory RadarChartAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return RadarChartAggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      color: (json['Color'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final color = this.color;
    final values = this.values;
    return {
      if (category != null) 'Category': category,
      if (color != null) 'Color': color,
      if (values != null) 'Values': values,
    };
  }
}

/// The configured style settings of a radar chart.
class RadarChartAreaStyleSettings {
  /// The visibility settings of a radar chart.
  final Visibility? visibility;

  RadarChartAreaStyleSettings({
    this.visibility,
  });

  factory RadarChartAreaStyleSettings.fromJson(Map<String, dynamic> json) {
    return RadarChartAreaStyleSettings(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

enum RadarChartAxesRangeScale {
  auto,
  independent,
  shared,
}

extension RadarChartAxesRangeScaleValueExtension on RadarChartAxesRangeScale {
  String toValue() {
    switch (this) {
      case RadarChartAxesRangeScale.auto:
        return 'AUTO';
      case RadarChartAxesRangeScale.independent:
        return 'INDEPENDENT';
      case RadarChartAxesRangeScale.shared:
        return 'SHARED';
    }
  }
}

extension RadarChartAxesRangeScaleFromString on String {
  RadarChartAxesRangeScale toRadarChartAxesRangeScale() {
    switch (this) {
      case 'AUTO':
        return RadarChartAxesRangeScale.auto;
      case 'INDEPENDENT':
        return RadarChartAxesRangeScale.independent;
      case 'SHARED':
        return RadarChartAxesRangeScale.shared;
    }
    throw Exception('$this is not known in enum RadarChartAxesRangeScale');
  }
}

/// The configuration of a <code>RadarChartVisual</code>.
class RadarChartConfiguration {
  /// Determines the visibility of the colors of alternatign bands in a radar
  /// chart.
  final Visibility? alternateBandColorsVisibility;

  /// The color of the even-numbered alternate bands of a radar chart.
  final String? alternateBandEvenColor;

  /// The color of the odd-numbered alternate bands of a radar chart.
  final String? alternateBandOddColor;

  /// The axis behavior options of a radar chart.
  final RadarChartAxesRangeScale? axesRangeScale;

  /// The base sreies settings of a radar chart.
  final RadarChartSeriesSettings? baseSeriesSettings;

  /// The category axis of a radar chart.
  final AxisDisplayOptions? categoryAxis;

  /// The category label options of a radar chart.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The color axis of a radar chart.
  final AxisDisplayOptions? colorAxis;

  /// The color label options of a radar chart.
  final ChartAxisLabelOptions? colorLabelOptions;

  /// The field well configuration of a <code>RadarChartVisual</code>.
  final RadarChartFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The shape of the radar chart.
  final RadarChartShape? shape;

  /// The sort configuration of a <code>RadarChartVisual</code>.
  final RadarChartSortConfiguration? sortConfiguration;

  /// The start angle of a radar chart's axis.
  final double? startAngle;

  /// The palette (chart color) display setup of the visual.
  final VisualPalette? visualPalette;

  RadarChartConfiguration({
    this.alternateBandColorsVisibility,
    this.alternateBandEvenColor,
    this.alternateBandOddColor,
    this.axesRangeScale,
    this.baseSeriesSettings,
    this.categoryAxis,
    this.categoryLabelOptions,
    this.colorAxis,
    this.colorLabelOptions,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.shape,
    this.sortConfiguration,
    this.startAngle,
    this.visualPalette,
  });

  factory RadarChartConfiguration.fromJson(Map<String, dynamic> json) {
    return RadarChartConfiguration(
      alternateBandColorsVisibility:
          (json['AlternateBandColorsVisibility'] as String?)?.toVisibility(),
      alternateBandEvenColor: json['AlternateBandEvenColor'] as String?,
      alternateBandOddColor: json['AlternateBandOddColor'] as String?,
      axesRangeScale:
          (json['AxesRangeScale'] as String?)?.toRadarChartAxesRangeScale(),
      baseSeriesSettings: json['BaseSeriesSettings'] != null
          ? RadarChartSeriesSettings.fromJson(
              json['BaseSeriesSettings'] as Map<String, dynamic>)
          : null,
      categoryAxis: json['CategoryAxis'] != null
          ? AxisDisplayOptions.fromJson(
              json['CategoryAxis'] as Map<String, dynamic>)
          : null,
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      colorAxis: json['ColorAxis'] != null
          ? AxisDisplayOptions.fromJson(
              json['ColorAxis'] as Map<String, dynamic>)
          : null,
      colorLabelOptions: json['ColorLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ColorLabelOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? RadarChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      shape: (json['Shape'] as String?)?.toRadarChartShape(),
      sortConfiguration: json['SortConfiguration'] != null
          ? RadarChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      startAngle: json['StartAngle'] as double?,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final alternateBandColorsVisibility = this.alternateBandColorsVisibility;
    final alternateBandEvenColor = this.alternateBandEvenColor;
    final alternateBandOddColor = this.alternateBandOddColor;
    final axesRangeScale = this.axesRangeScale;
    final baseSeriesSettings = this.baseSeriesSettings;
    final categoryAxis = this.categoryAxis;
    final categoryLabelOptions = this.categoryLabelOptions;
    final colorAxis = this.colorAxis;
    final colorLabelOptions = this.colorLabelOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final shape = this.shape;
    final sortConfiguration = this.sortConfiguration;
    final startAngle = this.startAngle;
    final visualPalette = this.visualPalette;
    return {
      if (alternateBandColorsVisibility != null)
        'AlternateBandColorsVisibility':
            alternateBandColorsVisibility.toValue(),
      if (alternateBandEvenColor != null)
        'AlternateBandEvenColor': alternateBandEvenColor,
      if (alternateBandOddColor != null)
        'AlternateBandOddColor': alternateBandOddColor,
      if (axesRangeScale != null) 'AxesRangeScale': axesRangeScale.toValue(),
      if (baseSeriesSettings != null) 'BaseSeriesSettings': baseSeriesSettings,
      if (categoryAxis != null) 'CategoryAxis': categoryAxis,
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (colorAxis != null) 'ColorAxis': colorAxis,
      if (colorLabelOptions != null) 'ColorLabelOptions': colorLabelOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (shape != null) 'Shape': shape.toValue(),
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (startAngle != null) 'StartAngle': startAngle,
      if (visualPalette != null) 'VisualPalette': visualPalette,
    };
  }
}

/// The field wells of a radar chart visual.
class RadarChartFieldWells {
  /// The aggregated field wells of a radar chart visual.
  final RadarChartAggregatedFieldWells? radarChartAggregatedFieldWells;

  RadarChartFieldWells({
    this.radarChartAggregatedFieldWells,
  });

  factory RadarChartFieldWells.fromJson(Map<String, dynamic> json) {
    return RadarChartFieldWells(
      radarChartAggregatedFieldWells: json['RadarChartAggregatedFieldWells'] !=
              null
          ? RadarChartAggregatedFieldWells.fromJson(
              json['RadarChartAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final radarChartAggregatedFieldWells = this.radarChartAggregatedFieldWells;
    return {
      if (radarChartAggregatedFieldWells != null)
        'RadarChartAggregatedFieldWells': radarChartAggregatedFieldWells,
    };
  }
}

/// The series settings of a radar chart.
class RadarChartSeriesSettings {
  /// The area style settings of a radar chart.
  final RadarChartAreaStyleSettings? areaStyleSettings;

  RadarChartSeriesSettings({
    this.areaStyleSettings,
  });

  factory RadarChartSeriesSettings.fromJson(Map<String, dynamic> json) {
    return RadarChartSeriesSettings(
      areaStyleSettings: json['AreaStyleSettings'] != null
          ? RadarChartAreaStyleSettings.fromJson(
              json['AreaStyleSettings'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final areaStyleSettings = this.areaStyleSettings;
    return {
      if (areaStyleSettings != null) 'AreaStyleSettings': areaStyleSettings,
    };
  }
}

enum RadarChartShape {
  circle,
  polygon,
}

extension RadarChartShapeValueExtension on RadarChartShape {
  String toValue() {
    switch (this) {
      case RadarChartShape.circle:
        return 'CIRCLE';
      case RadarChartShape.polygon:
        return 'POLYGON';
    }
  }
}

extension RadarChartShapeFromString on String {
  RadarChartShape toRadarChartShape() {
    switch (this) {
      case 'CIRCLE':
        return RadarChartShape.circle;
      case 'POLYGON':
        return RadarChartShape.polygon;
    }
    throw Exception('$this is not known in enum RadarChartShape');
  }
}

/// The sort configuration of a <code>RadarChartVisual</code>.
class RadarChartSortConfiguration {
  /// The category items limit for a radar chart.
  final ItemsLimitConfiguration? categoryItemsLimit;

  /// The category sort options of a radar chart.
  final List<FieldSortOptions>? categorySort;

  /// The color items limit of a radar chart.
  final ItemsLimitConfiguration? colorItemsLimit;

  /// The color sort configuration of a radar chart.
  final List<FieldSortOptions>? colorSort;

  RadarChartSortConfiguration({
    this.categoryItemsLimit,
    this.categorySort,
    this.colorItemsLimit,
    this.colorSort,
  });

  factory RadarChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return RadarChartSortConfiguration(
      categoryItemsLimit: json['CategoryItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['CategoryItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
      colorItemsLimit: json['ColorItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['ColorItemsLimit'] as Map<String, dynamic>)
          : null,
      colorSort: (json['ColorSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimit = this.categoryItemsLimit;
    final categorySort = this.categorySort;
    final colorItemsLimit = this.colorItemsLimit;
    final colorSort = this.colorSort;
    return {
      if (categoryItemsLimit != null) 'CategoryItemsLimit': categoryItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
      if (colorItemsLimit != null) 'ColorItemsLimit': colorItemsLimit,
      if (colorSort != null) 'ColorSort': colorSort,
    };
  }
}

/// A radar chart visual.
class RadarChartVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final RadarChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  RadarChartVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory RadarChartVisual.fromJson(Map<String, dynamic> json) {
    return RadarChartVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? RadarChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// A structure that represents a range constant.
class RangeConstant {
  /// The maximum value for a range constant.
  final String? maximum;

  /// The minimum value for a range constant.
  final String? minimum;

  RangeConstant({
    this.maximum,
    this.minimum,
  });

  factory RangeConstant.fromJson(Map<String, dynamic> json) {
    return RangeConstant(
      maximum: json['Maximum'] as String?,
      minimum: json['Minimum'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final maximum = this.maximum;
    final minimum = this.minimum;
    return {
      if (maximum != null) 'Maximum': maximum,
      if (minimum != null) 'Minimum': minimum,
    };
  }
}

/// The range ends label type of a data path label.
class RangeEndsLabelType {
  /// The visibility of the range ends label.
  final Visibility? visibility;

  RangeEndsLabelType({
    this.visibility,
  });

  factory RangeEndsLabelType.fromJson(Map<String, dynamic> json) {
    return RangeEndsLabelType(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The parameters for Amazon RDS.
class RdsParameters {
  /// Database.
  final String database;

  /// Instance ID.
  final String instanceId;

  RdsParameters({
    required this.database,
    required this.instanceId,
  });

  factory RdsParameters.fromJson(Map<String, dynamic> json) {
    return RdsParameters(
      database: json['Database'] as String,
      instanceId: json['InstanceId'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final instanceId = this.instanceId;
    return {
      'Database': database,
      'InstanceId': instanceId,
    };
  }
}

/// A structure that grants Amazon QuickSight access to your cluster and make a
/// call to the <code>redshift:GetClusterCredentials</code> API. For more
/// information on the <code>redshift:GetClusterCredentials</code> API, see <a
/// href="https://docs.aws.amazon.com/redshift/latest/APIReference/API_GetClusterCredentials.html">
/// <code>GetClusterCredentials</code> </a>.
class RedshiftIAMParameters {
  /// Use the <code>RoleArn</code> structure to allow Amazon QuickSight to call
  /// <code>redshift:GetClusterCredentials</code> on your cluster. The calling
  /// principal must have <code>iam:PassRole</code> access to pass the role to
  /// Amazon QuickSight. The role's trust policy must allow the Amazon QuickSight
  /// service principal to assume the role.
  final String roleArn;

  /// Automatically creates a database user. If your database doesn't have a
  /// <code>DatabaseUser</code>, set this parameter to <code>True</code>. If there
  /// is no <code>DatabaseUser</code>, Amazon QuickSight can't connect to your
  /// cluster. The <code>RoleArn</code> that you use for this operation must grant
  /// access to <code>redshift:CreateClusterUser</code> to successfully create the
  /// user.
  final bool? autoCreateDatabaseUser;

  /// A list of groups whose permissions will be granted to Amazon QuickSight to
  /// access the cluster. These permissions are combined with the permissions
  /// granted to Amazon QuickSight by the <code>DatabaseUser</code>. If you choose
  /// to include this parameter, the <code>RoleArn</code> must grant access to
  /// <code>redshift:JoinGroup</code>.
  final List<String>? databaseGroups;

  /// The user whose permissions and group memberships will be used by Amazon
  /// QuickSight to access the cluster. If this user already exists in your
  /// database, Amazon QuickSight is granted the same permissions that the user
  /// has. If the user doesn't exist, set the value of
  /// <code>AutoCreateDatabaseUser</code> to <code>True</code> to create a new
  /// user with PUBLIC permissions.
  final String? databaseUser;

  RedshiftIAMParameters({
    required this.roleArn,
    this.autoCreateDatabaseUser,
    this.databaseGroups,
    this.databaseUser,
  });

  factory RedshiftIAMParameters.fromJson(Map<String, dynamic> json) {
    return RedshiftIAMParameters(
      roleArn: json['RoleArn'] as String,
      autoCreateDatabaseUser: json['AutoCreateDatabaseUser'] as bool?,
      databaseGroups: (json['DatabaseGroups'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      databaseUser: json['DatabaseUser'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final roleArn = this.roleArn;
    final autoCreateDatabaseUser = this.autoCreateDatabaseUser;
    final databaseGroups = this.databaseGroups;
    final databaseUser = this.databaseUser;
    return {
      'RoleArn': roleArn,
      if (autoCreateDatabaseUser != null)
        'AutoCreateDatabaseUser': autoCreateDatabaseUser,
      if (databaseGroups != null) 'DatabaseGroups': databaseGroups,
      if (databaseUser != null) 'DatabaseUser': databaseUser,
    };
  }
}

/// The parameters for Amazon Redshift. The <code>ClusterId</code> field can be
/// blank if <code>Host</code> and <code>Port</code> are both set. The
/// <code>Host</code> and <code>Port</code> fields can be blank if the
/// <code>ClusterId</code> field is set.
class RedshiftParameters {
  /// Database.
  final String database;

  /// Cluster ID. This field can be blank if the <code>Host</code> and
  /// <code>Port</code> are provided.
  final String? clusterId;

  /// Host. This field can be blank if <code>ClusterId</code> is provided.
  final String? host;

  /// An optional parameter that uses IAM authentication to grant Amazon
  /// QuickSight access to your cluster. This parameter can be used instead of <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_DataSourceCredentials.html">DataSourceCredentials</a>.
  final RedshiftIAMParameters? iAMParameters;

  /// An optional parameter that configures IAM Identity Center authentication to
  /// grant Amazon QuickSight access to your cluster.
  ///
  /// This parameter can only be specified if your Amazon QuickSight account is
  /// configured with IAM Identity Center.
  final IdentityCenterConfiguration? identityCenterConfiguration;

  /// Port. This field can be blank if the <code>ClusterId</code> is provided.
  final int? port;

  RedshiftParameters({
    required this.database,
    this.clusterId,
    this.host,
    this.iAMParameters,
    this.identityCenterConfiguration,
    this.port,
  });

  factory RedshiftParameters.fromJson(Map<String, dynamic> json) {
    return RedshiftParameters(
      database: json['Database'] as String,
      clusterId: json['ClusterId'] as String?,
      host: json['Host'] as String?,
      iAMParameters: json['IAMParameters'] != null
          ? RedshiftIAMParameters.fromJson(
              json['IAMParameters'] as Map<String, dynamic>)
          : null,
      identityCenterConfiguration: json['IdentityCenterConfiguration'] != null
          ? IdentityCenterConfiguration.fromJson(
              json['IdentityCenterConfiguration'] as Map<String, dynamic>)
          : null,
      port: json['Port'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final clusterId = this.clusterId;
    final host = this.host;
    final iAMParameters = this.iAMParameters;
    final identityCenterConfiguration = this.identityCenterConfiguration;
    final port = this.port;
    return {
      'Database': database,
      if (clusterId != null) 'ClusterId': clusterId,
      if (host != null) 'Host': host,
      if (iAMParameters != null) 'IAMParameters': iAMParameters,
      if (identityCenterConfiguration != null)
        'IdentityCenterConfiguration': identityCenterConfiguration,
      if (port != null) 'Port': port,
    };
  }
}

/// The reference line visual display options.
class ReferenceLine {
  /// The data configuration of the reference line.
  final ReferenceLineDataConfiguration dataConfiguration;

  /// The label configuration of the reference line.
  final ReferenceLineLabelConfiguration? labelConfiguration;

  /// The status of the reference line. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>ENABLE</code>
  /// </li>
  /// <li>
  /// <code>DISABLE</code>
  /// </li>
  /// </ul>
  final WidgetStatus? status;

  /// The style configuration of the reference line.
  final ReferenceLineStyleConfiguration? styleConfiguration;

  ReferenceLine({
    required this.dataConfiguration,
    this.labelConfiguration,
    this.status,
    this.styleConfiguration,
  });

  factory ReferenceLine.fromJson(Map<String, dynamic> json) {
    return ReferenceLine(
      dataConfiguration: ReferenceLineDataConfiguration.fromJson(
          json['DataConfiguration'] as Map<String, dynamic>),
      labelConfiguration: json['LabelConfiguration'] != null
          ? ReferenceLineLabelConfiguration.fromJson(
              json['LabelConfiguration'] as Map<String, dynamic>)
          : null,
      status: (json['Status'] as String?)?.toWidgetStatus(),
      styleConfiguration: json['StyleConfiguration'] != null
          ? ReferenceLineStyleConfiguration.fromJson(
              json['StyleConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataConfiguration = this.dataConfiguration;
    final labelConfiguration = this.labelConfiguration;
    final status = this.status;
    final styleConfiguration = this.styleConfiguration;
    return {
      'DataConfiguration': dataConfiguration,
      if (labelConfiguration != null) 'LabelConfiguration': labelConfiguration,
      if (status != null) 'Status': status.toValue(),
      if (styleConfiguration != null) 'StyleConfiguration': styleConfiguration,
    };
  }
}

/// The configuration for a custom label on a <code>ReferenceLine</code>.
class ReferenceLineCustomLabelConfiguration {
  /// The string text of the custom label.
  final String customLabel;

  ReferenceLineCustomLabelConfiguration({
    required this.customLabel,
  });

  factory ReferenceLineCustomLabelConfiguration.fromJson(
      Map<String, dynamic> json) {
    return ReferenceLineCustomLabelConfiguration(
      customLabel: json['CustomLabel'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final customLabel = this.customLabel;
    return {
      'CustomLabel': customLabel,
    };
  }
}

/// The data configuration of the reference line.
class ReferenceLineDataConfiguration {
  /// The axis binding type of the reference line. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>PrimaryY</code>
  /// </li>
  /// <li>
  /// <code>SecondaryY</code>
  /// </li>
  /// </ul>
  final AxisBinding? axisBinding;

  /// The dynamic configuration of the reference line data configuration.
  final ReferenceLineDynamicDataConfiguration? dynamicConfiguration;

  /// The series type of the reference line data configuration. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>BAR</code>
  /// </li>
  /// <li>
  /// <code>LINE</code>
  /// </li>
  /// </ul>
  final ReferenceLineSeriesType? seriesType;

  /// The static data configuration of the reference line data configuration.
  final ReferenceLineStaticDataConfiguration? staticConfiguration;

  ReferenceLineDataConfiguration({
    this.axisBinding,
    this.dynamicConfiguration,
    this.seriesType,
    this.staticConfiguration,
  });

  factory ReferenceLineDataConfiguration.fromJson(Map<String, dynamic> json) {
    return ReferenceLineDataConfiguration(
      axisBinding: (json['AxisBinding'] as String?)?.toAxisBinding(),
      dynamicConfiguration: json['DynamicConfiguration'] != null
          ? ReferenceLineDynamicDataConfiguration.fromJson(
              json['DynamicConfiguration'] as Map<String, dynamic>)
          : null,
      seriesType: (json['SeriesType'] as String?)?.toReferenceLineSeriesType(),
      staticConfiguration: json['StaticConfiguration'] != null
          ? ReferenceLineStaticDataConfiguration.fromJson(
              json['StaticConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final axisBinding = this.axisBinding;
    final dynamicConfiguration = this.dynamicConfiguration;
    final seriesType = this.seriesType;
    final staticConfiguration = this.staticConfiguration;
    return {
      if (axisBinding != null) 'AxisBinding': axisBinding.toValue(),
      if (dynamicConfiguration != null)
        'DynamicConfiguration': dynamicConfiguration,
      if (seriesType != null) 'SeriesType': seriesType.toValue(),
      if (staticConfiguration != null)
        'StaticConfiguration': staticConfiguration,
    };
  }
}

/// The dynamic configuration of the reference line data configuration.
class ReferenceLineDynamicDataConfiguration {
  /// The calculation that is used in the dynamic data.
  final NumericalAggregationFunction calculation;

  /// The column that the dynamic data targets.
  final ColumnIdentifier column;

  /// The aggregation function that is used in the dynamic data.
  final AggregationFunction? measureAggregationFunction;

  ReferenceLineDynamicDataConfiguration({
    required this.calculation,
    required this.column,
    this.measureAggregationFunction,
  });

  factory ReferenceLineDynamicDataConfiguration.fromJson(
      Map<String, dynamic> json) {
    return ReferenceLineDynamicDataConfiguration(
      calculation: NumericalAggregationFunction.fromJson(
          json['Calculation'] as Map<String, dynamic>),
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      measureAggregationFunction: json['MeasureAggregationFunction'] != null
          ? AggregationFunction.fromJson(
              json['MeasureAggregationFunction'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final calculation = this.calculation;
    final column = this.column;
    final measureAggregationFunction = this.measureAggregationFunction;
    return {
      'Calculation': calculation,
      'Column': column,
      if (measureAggregationFunction != null)
        'MeasureAggregationFunction': measureAggregationFunction,
    };
  }
}

/// The label configuration of a reference line.
class ReferenceLineLabelConfiguration {
  /// The custom label configuration of the label in a reference line.
  final ReferenceLineCustomLabelConfiguration? customLabelConfiguration;

  /// The font color configuration of the label in a reference line.
  final String? fontColor;

  /// The font configuration of the label in a reference line.
  final FontConfiguration? fontConfiguration;

  /// The horizontal position configuration of the label in a reference line.
  /// Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>LEFT</code>
  /// </li>
  /// <li>
  /// <code>CENTER</code>
  /// </li>
  /// <li>
  /// <code>RIGHT</code>
  /// </li>
  /// </ul>
  final ReferenceLineLabelHorizontalPosition? horizontalPosition;

  /// The value label configuration of the label in a reference line.
  final ReferenceLineValueLabelConfiguration? valueLabelConfiguration;

  /// The vertical position configuration of the label in a reference line. Choose
  /// one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>ABOVE</code>
  /// </li>
  /// <li>
  /// <code>BELOW</code>
  /// </li>
  /// </ul>
  final ReferenceLineLabelVerticalPosition? verticalPosition;

  ReferenceLineLabelConfiguration({
    this.customLabelConfiguration,
    this.fontColor,
    this.fontConfiguration,
    this.horizontalPosition,
    this.valueLabelConfiguration,
    this.verticalPosition,
  });

  factory ReferenceLineLabelConfiguration.fromJson(Map<String, dynamic> json) {
    return ReferenceLineLabelConfiguration(
      customLabelConfiguration: json['CustomLabelConfiguration'] != null
          ? ReferenceLineCustomLabelConfiguration.fromJson(
              json['CustomLabelConfiguration'] as Map<String, dynamic>)
          : null,
      fontColor: json['FontColor'] as String?,
      fontConfiguration: json['FontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['FontConfiguration'] as Map<String, dynamic>)
          : null,
      horizontalPosition: (json['HorizontalPosition'] as String?)
          ?.toReferenceLineLabelHorizontalPosition(),
      valueLabelConfiguration: json['ValueLabelConfiguration'] != null
          ? ReferenceLineValueLabelConfiguration.fromJson(
              json['ValueLabelConfiguration'] as Map<String, dynamic>)
          : null,
      verticalPosition: (json['VerticalPosition'] as String?)
          ?.toReferenceLineLabelVerticalPosition(),
    );
  }

  Map<String, dynamic> toJson() {
    final customLabelConfiguration = this.customLabelConfiguration;
    final fontColor = this.fontColor;
    final fontConfiguration = this.fontConfiguration;
    final horizontalPosition = this.horizontalPosition;
    final valueLabelConfiguration = this.valueLabelConfiguration;
    final verticalPosition = this.verticalPosition;
    return {
      if (customLabelConfiguration != null)
        'CustomLabelConfiguration': customLabelConfiguration,
      if (fontColor != null) 'FontColor': fontColor,
      if (fontConfiguration != null) 'FontConfiguration': fontConfiguration,
      if (horizontalPosition != null)
        'HorizontalPosition': horizontalPosition.toValue(),
      if (valueLabelConfiguration != null)
        'ValueLabelConfiguration': valueLabelConfiguration,
      if (verticalPosition != null)
        'VerticalPosition': verticalPosition.toValue(),
    };
  }
}

enum ReferenceLineLabelHorizontalPosition {
  left,
  center,
  right,
}

extension ReferenceLineLabelHorizontalPositionValueExtension
    on ReferenceLineLabelHorizontalPosition {
  String toValue() {
    switch (this) {
      case ReferenceLineLabelHorizontalPosition.left:
        return 'LEFT';
      case ReferenceLineLabelHorizontalPosition.center:
        return 'CENTER';
      case ReferenceLineLabelHorizontalPosition.right:
        return 'RIGHT';
    }
  }
}

extension ReferenceLineLabelHorizontalPositionFromString on String {
  ReferenceLineLabelHorizontalPosition
      toReferenceLineLabelHorizontalPosition() {
    switch (this) {
      case 'LEFT':
        return ReferenceLineLabelHorizontalPosition.left;
      case 'CENTER':
        return ReferenceLineLabelHorizontalPosition.center;
      case 'RIGHT':
        return ReferenceLineLabelHorizontalPosition.right;
    }
    throw Exception(
        '$this is not known in enum ReferenceLineLabelHorizontalPosition');
  }
}

enum ReferenceLineLabelVerticalPosition {
  above,
  below,
}

extension ReferenceLineLabelVerticalPositionValueExtension
    on ReferenceLineLabelVerticalPosition {
  String toValue() {
    switch (this) {
      case ReferenceLineLabelVerticalPosition.above:
        return 'ABOVE';
      case ReferenceLineLabelVerticalPosition.below:
        return 'BELOW';
    }
  }
}

extension ReferenceLineLabelVerticalPositionFromString on String {
  ReferenceLineLabelVerticalPosition toReferenceLineLabelVerticalPosition() {
    switch (this) {
      case 'ABOVE':
        return ReferenceLineLabelVerticalPosition.above;
      case 'BELOW':
        return ReferenceLineLabelVerticalPosition.below;
    }
    throw Exception(
        '$this is not known in enum ReferenceLineLabelVerticalPosition');
  }
}

enum ReferenceLinePatternType {
  solid,
  dashed,
  dotted,
}

extension ReferenceLinePatternTypeValueExtension on ReferenceLinePatternType {
  String toValue() {
    switch (this) {
      case ReferenceLinePatternType.solid:
        return 'SOLID';
      case ReferenceLinePatternType.dashed:
        return 'DASHED';
      case ReferenceLinePatternType.dotted:
        return 'DOTTED';
    }
  }
}

extension ReferenceLinePatternTypeFromString on String {
  ReferenceLinePatternType toReferenceLinePatternType() {
    switch (this) {
      case 'SOLID':
        return ReferenceLinePatternType.solid;
      case 'DASHED':
        return ReferenceLinePatternType.dashed;
      case 'DOTTED':
        return ReferenceLinePatternType.dotted;
    }
    throw Exception('$this is not known in enum ReferenceLinePatternType');
  }
}

enum ReferenceLineSeriesType {
  bar,
  line,
}

extension ReferenceLineSeriesTypeValueExtension on ReferenceLineSeriesType {
  String toValue() {
    switch (this) {
      case ReferenceLineSeriesType.bar:
        return 'BAR';
      case ReferenceLineSeriesType.line:
        return 'LINE';
    }
  }
}

extension ReferenceLineSeriesTypeFromString on String {
  ReferenceLineSeriesType toReferenceLineSeriesType() {
    switch (this) {
      case 'BAR':
        return ReferenceLineSeriesType.bar;
      case 'LINE':
        return ReferenceLineSeriesType.line;
    }
    throw Exception('$this is not known in enum ReferenceLineSeriesType');
  }
}

/// The static data configuration of the reference line data configuration.
class ReferenceLineStaticDataConfiguration {
  /// The double input of the static data.
  final double value;

  ReferenceLineStaticDataConfiguration({
    required this.value,
  });

  factory ReferenceLineStaticDataConfiguration.fromJson(
      Map<String, dynamic> json) {
    return ReferenceLineStaticDataConfiguration(
      value: json['Value'] as double,
    );
  }

  Map<String, dynamic> toJson() {
    final value = this.value;
    return {
      'Value': value,
    };
  }
}

/// The style configuration of the reference line.
class ReferenceLineStyleConfiguration {
  /// The hex color of the reference line.
  final String? color;

  /// The pattern type of the line style. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>SOLID</code>
  /// </li>
  /// <li>
  /// <code>DASHED</code>
  /// </li>
  /// <li>
  /// <code>DOTTED</code>
  /// </li>
  /// </ul>
  final ReferenceLinePatternType? pattern;

  ReferenceLineStyleConfiguration({
    this.color,
    this.pattern,
  });

  factory ReferenceLineStyleConfiguration.fromJson(Map<String, dynamic> json) {
    return ReferenceLineStyleConfiguration(
      color: json['Color'] as String?,
      pattern: (json['Pattern'] as String?)?.toReferenceLinePatternType(),
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final pattern = this.pattern;
    return {
      if (color != null) 'Color': color,
      if (pattern != null) 'Pattern': pattern.toValue(),
    };
  }
}

/// The value label configuration of the label in a reference line.
class ReferenceLineValueLabelConfiguration {
  /// The format configuration of the value label.
  final NumericFormatConfiguration? formatConfiguration;

  /// The relative position of the value label. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>BEFORE_CUSTOM_LABEL</code>
  /// </li>
  /// <li>
  /// <code>AFTER_CUSTOM_LABEL</code>
  /// </li>
  /// </ul>
  final ReferenceLineValueLabelRelativePosition? relativePosition;

  ReferenceLineValueLabelConfiguration({
    this.formatConfiguration,
    this.relativePosition,
  });

  factory ReferenceLineValueLabelConfiguration.fromJson(
      Map<String, dynamic> json) {
    return ReferenceLineValueLabelConfiguration(
      formatConfiguration: json['FormatConfiguration'] != null
          ? NumericFormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
      relativePosition: (json['RelativePosition'] as String?)
          ?.toReferenceLineValueLabelRelativePosition(),
    );
  }

  Map<String, dynamic> toJson() {
    final formatConfiguration = this.formatConfiguration;
    final relativePosition = this.relativePosition;
    return {
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
      if (relativePosition != null)
        'RelativePosition': relativePosition.toValue(),
    };
  }
}

enum ReferenceLineValueLabelRelativePosition {
  beforeCustomLabel,
  afterCustomLabel,
}

extension ReferenceLineValueLabelRelativePositionValueExtension
    on ReferenceLineValueLabelRelativePosition {
  String toValue() {
    switch (this) {
      case ReferenceLineValueLabelRelativePosition.beforeCustomLabel:
        return 'BEFORE_CUSTOM_LABEL';
      case ReferenceLineValueLabelRelativePosition.afterCustomLabel:
        return 'AFTER_CUSTOM_LABEL';
    }
  }
}

extension ReferenceLineValueLabelRelativePositionFromString on String {
  ReferenceLineValueLabelRelativePosition
      toReferenceLineValueLabelRelativePosition() {
    switch (this) {
      case 'BEFORE_CUSTOM_LABEL':
        return ReferenceLineValueLabelRelativePosition.beforeCustomLabel;
      case 'AFTER_CUSTOM_LABEL':
        return ReferenceLineValueLabelRelativePosition.afterCustomLabel;
    }
    throw Exception(
        '$this is not known in enum ReferenceLineValueLabelRelativePosition');
  }
}

/// The refresh configuration of a dataset.
class RefreshConfiguration {
  /// The incremental refresh for the dataset.
  final IncrementalRefresh incrementalRefresh;

  RefreshConfiguration({
    required this.incrementalRefresh,
  });

  factory RefreshConfiguration.fromJson(Map<String, dynamic> json) {
    return RefreshConfiguration(
      incrementalRefresh: IncrementalRefresh.fromJson(
          json['IncrementalRefresh'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final incrementalRefresh = this.incrementalRefresh;
    return {
      'IncrementalRefresh': incrementalRefresh,
    };
  }
}

/// Specifies the interval between each scheduled refresh of a dataset.
class RefreshFrequency {
  /// The interval between scheduled refreshes. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>MINUTE15</code>: The dataset refreshes every 15 minutes. This value is
  /// only supported for incremental refreshes. This interval can only be used for
  /// one schedule per dataset.
  /// </li>
  /// <li>
  /// <code>MINUTE30</code>:The dataset refreshes every 30 minutes. This value is
  /// only supported for incremental refreshes. This interval can only be used for
  /// one schedule per dataset.
  /// </li>
  /// <li>
  /// <code>HOURLY</code>: The dataset refreshes every hour. This interval can
  /// only be used for one schedule per dataset.
  /// </li>
  /// <li>
  /// <code>DAILY</code>: The dataset refreshes every day.
  /// </li>
  /// <li>
  /// <code>WEEKLY</code>: The dataset refreshes every week.
  /// </li>
  /// <li>
  /// <code>MONTHLY</code>: The dataset refreshes every month.
  /// </li>
  /// </ul>
  final RefreshInterval interval;

  /// The day of the week that you want to schedule the refresh on. This value is
  /// required for weekly and monthly refresh intervals.
  final ScheduleRefreshOnEntity? refreshOnDay;

  /// The time of day that you want the datset to refresh. This value is expressed
  /// in HH:MM format. This field is not required for schedules that refresh
  /// hourly.
  final String? timeOfTheDay;

  /// The timezone that you want the refresh schedule to use. The timezone ID must
  /// match a corresponding ID found on
  /// <code>java.util.time.getAvailableIDs()</code>.
  final String? timezone;

  RefreshFrequency({
    required this.interval,
    this.refreshOnDay,
    this.timeOfTheDay,
    this.timezone,
  });

  factory RefreshFrequency.fromJson(Map<String, dynamic> json) {
    return RefreshFrequency(
      interval: (json['Interval'] as String).toRefreshInterval(),
      refreshOnDay: json['RefreshOnDay'] != null
          ? ScheduleRefreshOnEntity.fromJson(
              json['RefreshOnDay'] as Map<String, dynamic>)
          : null,
      timeOfTheDay: json['TimeOfTheDay'] as String?,
      timezone: json['Timezone'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final interval = this.interval;
    final refreshOnDay = this.refreshOnDay;
    final timeOfTheDay = this.timeOfTheDay;
    final timezone = this.timezone;
    return {
      'Interval': interval.toValue(),
      if (refreshOnDay != null) 'RefreshOnDay': refreshOnDay,
      if (timeOfTheDay != null) 'TimeOfTheDay': timeOfTheDay,
      if (timezone != null) 'Timezone': timezone,
    };
  }
}

enum RefreshInterval {
  minute15,
  minute30,
  hourly,
  daily,
  weekly,
  monthly,
}

extension RefreshIntervalValueExtension on RefreshInterval {
  String toValue() {
    switch (this) {
      case RefreshInterval.minute15:
        return 'MINUTE15';
      case RefreshInterval.minute30:
        return 'MINUTE30';
      case RefreshInterval.hourly:
        return 'HOURLY';
      case RefreshInterval.daily:
        return 'DAILY';
      case RefreshInterval.weekly:
        return 'WEEKLY';
      case RefreshInterval.monthly:
        return 'MONTHLY';
    }
  }
}

extension RefreshIntervalFromString on String {
  RefreshInterval toRefreshInterval() {
    switch (this) {
      case 'MINUTE15':
        return RefreshInterval.minute15;
      case 'MINUTE30':
        return RefreshInterval.minute30;
      case 'HOURLY':
        return RefreshInterval.hourly;
      case 'DAILY':
        return RefreshInterval.daily;
      case 'WEEKLY':
        return RefreshInterval.weekly;
      case 'MONTHLY':
        return RefreshInterval.monthly;
    }
    throw Exception('$this is not known in enum RefreshInterval');
  }
}

/// The refresh schedule of a dataset.
class RefreshSchedule {
  /// The type of refresh that a datset undergoes. Valid values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>FULL_REFRESH</code>: A complete refresh of a dataset.
  /// </li>
  /// <li>
  /// <code>INCREMENTAL_REFRESH</code>: A partial refresh of some rows of a
  /// dataset, based on the time window specified.
  /// </li>
  /// </ul>
  /// For more information on full and incremental refreshes, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/refreshing-imported-data.html">Refreshing
  /// SPICE data</a> in the <i>Amazon QuickSight User Guide</i>.
  final IngestionType refreshType;

  /// The frequency for the refresh schedule.
  final RefreshFrequency scheduleFrequency;

  /// An identifier for the refresh schedule.
  final String scheduleId;

  /// The Amazon Resource Name (ARN) for the refresh schedule.
  final String? arn;

  /// Time after which the refresh schedule can be started, expressed in
  /// <code>YYYY-MM-DDTHH:MM:SS</code> format.
  final DateTime? startAfterDateTime;

  RefreshSchedule({
    required this.refreshType,
    required this.scheduleFrequency,
    required this.scheduleId,
    this.arn,
    this.startAfterDateTime,
  });

  factory RefreshSchedule.fromJson(Map<String, dynamic> json) {
    return RefreshSchedule(
      refreshType: (json['RefreshType'] as String).toIngestionType(),
      scheduleFrequency: RefreshFrequency.fromJson(
          json['ScheduleFrequency'] as Map<String, dynamic>),
      scheduleId: json['ScheduleId'] as String,
      arn: json['Arn'] as String?,
      startAfterDateTime: timeStampFromJson(json['StartAfterDateTime']),
    );
  }

  Map<String, dynamic> toJson() {
    final refreshType = this.refreshType;
    final scheduleFrequency = this.scheduleFrequency;
    final scheduleId = this.scheduleId;
    final arn = this.arn;
    final startAfterDateTime = this.startAfterDateTime;
    return {
      'RefreshType': refreshType.toValue(),
      'ScheduleFrequency': scheduleFrequency,
      'ScheduleId': scheduleId,
      if (arn != null) 'Arn': arn,
      if (startAfterDateTime != null)
        'StartAfterDateTime': unixTimestampToJson(startAfterDateTime),
    };
  }
}

class RegisterUserResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The user's user name.
  final User? user;

  /// The URL the user visits to complete registration and provide a password.
  /// This is returned only for users with an identity type of
  /// <code>QUICKSIGHT</code>.
  final String? userInvitationUrl;

  RegisterUserResponse({
    this.requestId,
    this.status,
    this.user,
    this.userInvitationUrl,
  });

  factory RegisterUserResponse.fromJson(Map<String, dynamic> json) {
    return RegisterUserResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      user: json['User'] != null
          ? User.fromJson(json['User'] as Map<String, dynamic>)
          : null,
      userInvitationUrl: json['UserInvitationUrl'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final user = this.user;
    final userInvitationUrl = this.userInvitationUrl;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (user != null) 'User': user,
      if (userInvitationUrl != null) 'UserInvitationUrl': userInvitationUrl,
    };
  }
}

/// A customer managed key structure that contains the information listed below:
///
/// <ul>
/// <li>
/// <code>KeyArn</code> - The ARN of a KMS key that is registered to a Amazon
/// QuickSight account for encryption and decryption use.
/// </li>
/// <li>
/// <code>DefaultKey</code> - Indicates whether the current key is set as the
/// default key for encryption and decryption use.
/// </li>
/// </ul>
class RegisteredCustomerManagedKey {
  /// Indicates whether a <code>RegisteredCustomerManagedKey</code> is set as the
  /// default key for encryption and decryption use.
  final bool? defaultKey;

  /// The ARN of the KMS key that is registered to a Amazon QuickSight account for
  /// encryption and decryption use.
  final String? keyArn;

  RegisteredCustomerManagedKey({
    this.defaultKey,
    this.keyArn,
  });

  factory RegisteredCustomerManagedKey.fromJson(Map<String, dynamic> json) {
    return RegisteredCustomerManagedKey(
      defaultKey: json['DefaultKey'] as bool?,
      keyArn: json['KeyArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final defaultKey = this.defaultKey;
    final keyArn = this.keyArn;
    return {
      if (defaultKey != null) 'DefaultKey': defaultKey,
      if (keyArn != null) 'KeyArn': keyArn,
    };
  }
}

/// The feature configurations of an embedded Amazon QuickSight console.
class RegisteredUserConsoleFeatureConfigurations {
  /// The state persistence configurations of an embedded Amazon QuickSight
  /// console.
  final StatePersistenceConfigurations? statePersistence;

  RegisteredUserConsoleFeatureConfigurations({
    this.statePersistence,
  });

  Map<String, dynamic> toJson() {
    final statePersistence = this.statePersistence;
    return {
      if (statePersistence != null) 'StatePersistence': statePersistence,
    };
  }
}

/// Information about the dashboard you want to embed.
class RegisteredUserDashboardEmbeddingConfiguration {
  /// The dashboard ID for the dashboard that you want the user to see first. This
  /// ID is included in the output URL. When the URL in response is accessed,
  /// Amazon QuickSight renders this dashboard if the user has permissions to view
  /// it.
  ///
  /// If the user does not have permission to view this dashboard, they see a
  /// permissions error message.
  final String initialDashboardId;

  /// The feature configurations of an embbedded Amazon QuickSight dashboard.
  final RegisteredUserDashboardFeatureConfigurations? featureConfigurations;

  RegisteredUserDashboardEmbeddingConfiguration({
    required this.initialDashboardId,
    this.featureConfigurations,
  });

  Map<String, dynamic> toJson() {
    final initialDashboardId = this.initialDashboardId;
    final featureConfigurations = this.featureConfigurations;
    return {
      'InitialDashboardId': initialDashboardId,
      if (featureConfigurations != null)
        'FeatureConfigurations': featureConfigurations,
    };
  }
}

/// The feature configuration for an embedded dashboard.
class RegisteredUserDashboardFeatureConfigurations {
  /// The bookmarks configuration for an embedded dashboard in Amazon QuickSight.
  final BookmarksConfigurations? bookmarks;

  /// The state persistence settings of an embedded dashboard.
  final StatePersistenceConfigurations? statePersistence;

  RegisteredUserDashboardFeatureConfigurations({
    this.bookmarks,
    this.statePersistence,
  });

  Map<String, dynamic> toJson() {
    final bookmarks = this.bookmarks;
    final statePersistence = this.statePersistence;
    return {
      if (bookmarks != null) 'Bookmarks': bookmarks,
      if (statePersistence != null) 'StatePersistence': statePersistence,
    };
  }
}

/// The experience that you are embedding. You can use this object to generate a
/// url that embeds a visual into your application.
class RegisteredUserDashboardVisualEmbeddingConfiguration {
  /// The visual ID for the visual that you want the user to embed. This ID is
  /// included in the output URL. When the URL in response is accessed, Amazon
  /// QuickSight renders this visual.
  ///
  /// The Amazon Resource Name (ARN) of the dashboard that the visual belongs to
  /// must be included in the <code>AuthorizedResourceArns</code> parameter.
  /// Otherwise, the request will fail with
  /// <code>InvalidParameterValueException</code>.
  final DashboardVisualId initialDashboardVisualId;

  RegisteredUserDashboardVisualEmbeddingConfiguration({
    required this.initialDashboardVisualId,
  });

  Map<String, dynamic> toJson() {
    final initialDashboardVisualId = this.initialDashboardVisualId;
    return {
      'InitialDashboardVisualId': initialDashboardVisualId,
    };
  }
}

/// The type of experience you want to embed. For registered users, you can
/// embed Amazon QuickSight dashboards or the Amazon QuickSight console.
/// <note>
/// Exactly one of the experience configurations is required. You can choose
/// <code>Dashboard</code> or <code>QuickSightConsole</code>. You cannot choose
/// more than one experience configuration.
/// </note>
class RegisteredUserEmbeddingExperienceConfiguration {
  /// The configuration details for providing a dashboard embedding experience.
  final RegisteredUserDashboardEmbeddingConfiguration? dashboard;

  /// The type of embedding experience. In this case, Amazon QuickSight visuals.
  final RegisteredUserDashboardVisualEmbeddingConfiguration? dashboardVisual;

  /// The configuration details for embedding the Generative Q&amp;A experience.
  ///
  /// For more information about embedding the Generative Q&amp;A experience, see
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html">Embedding
  /// Overview</a> in the <i>Amazon QuickSight User Guide</i>.
  final RegisteredUserGenerativeQnAEmbeddingConfiguration? generativeQnA;

  /// The configuration details for embedding the Q search bar.
  ///
  /// For more information about embedding the Q search bar, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedding-overview.html">Embedding
  /// Overview</a> in the <i>Amazon QuickSight User Guide</i>.
  final RegisteredUserQSearchBarEmbeddingConfiguration? qSearchBar;

  /// The configuration details for providing each Amazon QuickSight console
  /// embedding experience. This can be used along with custom permissions to
  /// restrict access to certain features. For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing
  /// Access to the Amazon QuickSight Console</a> in the <i>Amazon QuickSight User
  /// Guide</i>.
  ///
  /// Use <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_GenerateEmbedUrlForRegisteredUser.html">GenerateEmbedUrlForRegisteredUser</a>
  /// </code> where you want to provide an authoring portal that allows users to
  /// create data sources, datasets, analyses, and dashboards. The users who
  /// accesses an embedded Amazon QuickSight console needs to belong to the author
  /// or admin security cohort. If you want to restrict permissions to some of
  /// these features, add a custom permissions profile to the user with the <code>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_UpdateUser.html">UpdateUser</a>
  /// </code> API operation. Use the <code> <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/APIReference/API_RegisterUser.html">RegisterUser</a>
  /// </code> API operation to add a new user with a custom permission profile
  /// attached. For more information, see the following sections in the <i>Amazon
  /// QuickSight User Guide</i>:
  ///
  /// <ul>
  /// <li>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/embedded-analytics-full-console-for-authenticated-users.html">Embedding
  /// the Full Functionality of the Amazon QuickSight Console for Authenticated
  /// Users</a>
  /// </li>
  /// <li>
  /// <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/customizing-permissions-to-the-quicksight-console.html">Customizing
  /// Access to the Amazon QuickSight Console</a>
  /// </li>
  /// </ul>
  /// For more information about the high-level steps for embedding and for an
  /// interactive demo of the ways you can customize embedding, visit the <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-portal.html">Amazon
  /// QuickSight Developer Portal</a>.
  final RegisteredUserQuickSightConsoleEmbeddingConfiguration?
      quickSightConsole;

  RegisteredUserEmbeddingExperienceConfiguration({
    this.dashboard,
    this.dashboardVisual,
    this.generativeQnA,
    this.qSearchBar,
    this.quickSightConsole,
  });

  Map<String, dynamic> toJson() {
    final dashboard = this.dashboard;
    final dashboardVisual = this.dashboardVisual;
    final generativeQnA = this.generativeQnA;
    final qSearchBar = this.qSearchBar;
    final quickSightConsole = this.quickSightConsole;
    return {
      if (dashboard != null) 'Dashboard': dashboard,
      if (dashboardVisual != null) 'DashboardVisual': dashboardVisual,
      if (generativeQnA != null) 'GenerativeQnA': generativeQnA,
      if (qSearchBar != null) 'QSearchBar': qSearchBar,
      if (quickSightConsole != null) 'QuickSightConsole': quickSightConsole,
    };
  }
}

/// An object that provides information about the configuration of a Generative
/// Q&amp;A experience.
class RegisteredUserGenerativeQnAEmbeddingConfiguration {
  /// The ID of the new Q reader experience topic that you want to make the
  /// starting topic in the Generative Q&amp;A experience. You can find a topic ID
  /// by navigating to the Topics pane in the Amazon QuickSight application and
  /// opening a topic. The ID is in the URL for the topic that you open.
  ///
  /// If you don't specify an initial topic or you specify a legacy topic, a list
  /// of all shared new reader experience topics is shown in the Generative
  /// Q&amp;A experience for your readers. When you select an initial new reader
  /// experience topic, you can specify whether or not readers are allowed to
  /// select other new reader experience topics from the available ones in the
  /// list.
  final String? initialTopicId;

  RegisteredUserGenerativeQnAEmbeddingConfiguration({
    this.initialTopicId,
  });

  Map<String, dynamic> toJson() {
    final initialTopicId = this.initialTopicId;
    return {
      if (initialTopicId != null) 'InitialTopicId': initialTopicId,
    };
  }
}

/// Information about the Q search bar embedding experience.
class RegisteredUserQSearchBarEmbeddingConfiguration {
  /// The ID of the legacy Q topic that you want to use as the starting topic in
  /// the Q search bar. To locate the topic ID of the topic that you want to use,
  /// open the <a href="https://quicksight.aws.amazon.com/">Amazon QuickSight
  /// console</a>, navigate to the <b>Topics</b> pane, and choose thre topic that
  /// you want to use. The <code>TopicID</code> is located in the URL of the topic
  /// that opens. When you select an initial topic, you can specify whether or not
  /// readers are allowed to select other topics from the list of available
  /// topics.
  ///
  /// If you don't specify an initial topic or if you specify a new reader
  /// experience topic, a list of all shared legacy topics is shown in the Q bar.
  final String? initialTopicId;

  RegisteredUserQSearchBarEmbeddingConfiguration({
    this.initialTopicId,
  });

  Map<String, dynamic> toJson() {
    final initialTopicId = this.initialTopicId;
    return {
      if (initialTopicId != null) 'InitialTopicId': initialTopicId,
    };
  }
}

/// Information about the Amazon QuickSight console that you want to embed.
class RegisteredUserQuickSightConsoleEmbeddingConfiguration {
  /// The embedding configuration of an embedded Amazon QuickSight console.
  final RegisteredUserConsoleFeatureConfigurations? featureConfigurations;

  /// The initial URL path for the Amazon QuickSight console.
  /// <code>InitialPath</code> is required.
  ///
  /// The entry point URL is constrained to the following paths:
  ///
  /// <ul>
  /// <li>
  /// <code>/start</code>
  /// </li>
  /// <li>
  /// <code>/start/analyses</code>
  /// </li>
  /// <li>
  /// <code>/start/dashboards</code>
  /// </li>
  /// <li>
  /// <code>/start/favorites</code>
  /// </li>
  /// <li>
  /// <code>/dashboards/DashboardId</code>. <i>DashboardId</i> is the actual ID
  /// key from the Amazon QuickSight console URL of the dashboard.
  /// </li>
  /// <li>
  /// <code>/analyses/AnalysisId</code>. <i>AnalysisId</i> is the actual ID key
  /// from the Amazon QuickSight console URL of the analysis.
  /// </li>
  /// </ul>
  final String? initialPath;

  RegisteredUserQuickSightConsoleEmbeddingConfiguration({
    this.featureConfigurations,
    this.initialPath,
  });

  Map<String, dynamic> toJson() {
    final featureConfigurations = this.featureConfigurations;
    final initialPath = this.initialPath;
    return {
      if (featureConfigurations != null)
        'FeatureConfigurations': featureConfigurations,
      if (initialPath != null) 'InitialPath': initialPath,
    };
  }
}

/// A physical table type for relational data sources.
class RelationalTable {
  /// The Amazon Resource Name (ARN) for the data source.
  final String dataSourceArn;

  /// The column schema of the table.
  final List<InputColumn> inputColumns;

  /// The name of the relational table.
  final String name;

  /// The catalog associated with a table.
  final String? catalog;

  /// The schema name. This name applies to certain relational database engines.
  final String? schema;

  RelationalTable({
    required this.dataSourceArn,
    required this.inputColumns,
    required this.name,
    this.catalog,
    this.schema,
  });

  factory RelationalTable.fromJson(Map<String, dynamic> json) {
    return RelationalTable(
      dataSourceArn: json['DataSourceArn'] as String,
      inputColumns: (json['InputColumns'] as List)
          .whereNotNull()
          .map((e) => InputColumn.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String,
      catalog: json['Catalog'] as String?,
      schema: json['Schema'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceArn = this.dataSourceArn;
    final inputColumns = this.inputColumns;
    final name = this.name;
    final catalog = this.catalog;
    final schema = this.schema;
    return {
      'DataSourceArn': dataSourceArn,
      'InputColumns': inputColumns,
      'Name': name,
      if (catalog != null) 'Catalog': catalog,
      if (schema != null) 'Schema': schema,
    };
  }
}

/// The display options of a control.
class RelativeDateTimeControlDisplayOptions {
  /// Customize how dates are formatted in controls.
  final String? dateTimeFormat;

  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  RelativeDateTimeControlDisplayOptions({
    this.dateTimeFormat,
    this.infoIconLabelOptions,
    this.titleOptions,
  });

  factory RelativeDateTimeControlDisplayOptions.fromJson(
      Map<String, dynamic> json) {
    return RelativeDateTimeControlDisplayOptions(
      dateTimeFormat: json['DateTimeFormat'] as String?,
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dateTimeFormat = this.dateTimeFormat;
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final titleOptions = this.titleOptions;
    return {
      if (dateTimeFormat != null) 'DateTimeFormat': dateTimeFormat,
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

enum RelativeDateType {
  previous,
  $this,
  last,
  now,
  next,
}

extension RelativeDateTypeValueExtension on RelativeDateType {
  String toValue() {
    switch (this) {
      case RelativeDateType.previous:
        return 'PREVIOUS';
      case RelativeDateType.$this:
        return 'THIS';
      case RelativeDateType.last:
        return 'LAST';
      case RelativeDateType.now:
        return 'NOW';
      case RelativeDateType.next:
        return 'NEXT';
    }
  }
}

extension RelativeDateTypeFromString on String {
  RelativeDateType toRelativeDateType() {
    switch (this) {
      case 'PREVIOUS':
        return RelativeDateType.previous;
      case 'THIS':
        return RelativeDateType.$this;
      case 'LAST':
        return RelativeDateType.last;
      case 'NOW':
        return RelativeDateType.now;
      case 'NEXT':
        return RelativeDateType.next;
    }
    throw Exception('$this is not known in enum RelativeDateType');
  }
}

/// A <code>RelativeDatesFilter</code> filters relative dates values.
class RelativeDatesFilter {
  /// The date configuration of the filter.
  final AnchorDateConfiguration anchorDateConfiguration;

  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption nullOption;

  /// The range date type of the filter. Choose one of the options below:
  ///
  /// <ul>
  /// <li>
  /// <code>PREVIOUS</code>
  /// </li>
  /// <li>
  /// <code>THIS</code>
  /// </li>
  /// <li>
  /// <code>LAST</code>
  /// </li>
  /// <li>
  /// <code>NOW</code>
  /// </li>
  /// <li>
  /// <code>NEXT</code>
  /// </li>
  /// </ul>
  final RelativeDateType relativeDateType;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TimeGranularity timeGranularity;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  /// The configuration for the exclude period of the filter.
  final ExcludePeriodConfiguration? excludePeriodConfiguration;

  /// The minimum granularity (period granularity) of the relative dates filter.
  final TimeGranularity? minimumGranularity;

  /// The parameter whose value should be used for the filter value.
  final String? parameterName;

  /// The date value of the filter.
  final int? relativeDateValue;

  RelativeDatesFilter({
    required this.anchorDateConfiguration,
    required this.column,
    required this.filterId,
    required this.nullOption,
    required this.relativeDateType,
    required this.timeGranularity,
    this.defaultFilterControlConfiguration,
    this.excludePeriodConfiguration,
    this.minimumGranularity,
    this.parameterName,
    this.relativeDateValue,
  });

  factory RelativeDatesFilter.fromJson(Map<String, dynamic> json) {
    return RelativeDatesFilter(
      anchorDateConfiguration: AnchorDateConfiguration.fromJson(
          json['AnchorDateConfiguration'] as Map<String, dynamic>),
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      nullOption: (json['NullOption'] as String).toFilterNullOption(),
      relativeDateType:
          (json['RelativeDateType'] as String).toRelativeDateType(),
      timeGranularity: (json['TimeGranularity'] as String).toTimeGranularity(),
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
      excludePeriodConfiguration: json['ExcludePeriodConfiguration'] != null
          ? ExcludePeriodConfiguration.fromJson(
              json['ExcludePeriodConfiguration'] as Map<String, dynamic>)
          : null,
      minimumGranularity:
          (json['MinimumGranularity'] as String?)?.toTimeGranularity(),
      parameterName: json['ParameterName'] as String?,
      relativeDateValue: json['RelativeDateValue'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final anchorDateConfiguration = this.anchorDateConfiguration;
    final column = this.column;
    final filterId = this.filterId;
    final nullOption = this.nullOption;
    final relativeDateType = this.relativeDateType;
    final timeGranularity = this.timeGranularity;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    final excludePeriodConfiguration = this.excludePeriodConfiguration;
    final minimumGranularity = this.minimumGranularity;
    final parameterName = this.parameterName;
    final relativeDateValue = this.relativeDateValue;
    return {
      'AnchorDateConfiguration': anchorDateConfiguration,
      'Column': column,
      'FilterId': filterId,
      'NullOption': nullOption.toValue(),
      'RelativeDateType': relativeDateType.toValue(),
      'TimeGranularity': timeGranularity.toValue(),
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
      if (excludePeriodConfiguration != null)
        'ExcludePeriodConfiguration': excludePeriodConfiguration,
      if (minimumGranularity != null)
        'MinimumGranularity': minimumGranularity.toValue(),
      if (parameterName != null) 'ParameterName': parameterName,
      if (relativeDateValue != null) 'RelativeDateValue': relativeDateValue,
    };
  }
}

enum RelativeFontSize {
  extraSmall,
  small,
  medium,
  large,
  extraLarge,
}

extension RelativeFontSizeValueExtension on RelativeFontSize {
  String toValue() {
    switch (this) {
      case RelativeFontSize.extraSmall:
        return 'EXTRA_SMALL';
      case RelativeFontSize.small:
        return 'SMALL';
      case RelativeFontSize.medium:
        return 'MEDIUM';
      case RelativeFontSize.large:
        return 'LARGE';
      case RelativeFontSize.extraLarge:
        return 'EXTRA_LARGE';
    }
  }
}

extension RelativeFontSizeFromString on String {
  RelativeFontSize toRelativeFontSize() {
    switch (this) {
      case 'EXTRA_SMALL':
        return RelativeFontSize.extraSmall;
      case 'SMALL':
        return RelativeFontSize.small;
      case 'MEDIUM':
        return RelativeFontSize.medium;
      case 'LARGE':
        return RelativeFontSize.large;
      case 'EXTRA_LARGE':
        return RelativeFontSize.extraLarge;
    }
    throw Exception('$this is not known in enum RelativeFontSize');
  }
}

/// A transform operation that renames a column.
class RenameColumnOperation {
  /// The name of the column to be renamed.
  final String columnName;

  /// The new name for the column.
  final String newColumnName;

  RenameColumnOperation({
    required this.columnName,
    required this.newColumnName,
  });

  factory RenameColumnOperation.fromJson(Map<String, dynamic> json) {
    return RenameColumnOperation(
      columnName: json['ColumnName'] as String,
      newColumnName: json['NewColumnName'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final newColumnName = this.newColumnName;
    return {
      'ColumnName': columnName,
      'NewColumnName': newColumnName,
    };
  }
}

enum ResizeOption {
  fixed,
  responsive,
}

extension ResizeOptionValueExtension on ResizeOption {
  String toValue() {
    switch (this) {
      case ResizeOption.fixed:
        return 'FIXED';
      case ResizeOption.responsive:
        return 'RESPONSIVE';
    }
  }
}

extension ResizeOptionFromString on String {
  ResizeOption toResizeOption() {
    switch (this) {
      case 'FIXED':
        return ResizeOption.fixed;
      case 'RESPONSIVE':
        return ResizeOption.responsive;
    }
    throw Exception('$this is not known in enum ResizeOption');
  }
}

/// Permission for the resource.
class ResourcePermission {
  /// The IAM action to grant or revoke permissions on.
  final List<String> actions;

  /// The Amazon Resource Name (ARN) of the principal. This can be one of the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// The ARN of an Amazon QuickSight user or group associated with a data source
  /// or dataset. (This is common.)
  /// </li>
  /// <li>
  /// The ARN of an Amazon QuickSight user, group, or namespace associated with an
  /// analysis, dashboard, template, or theme. (This is common.)
  /// </li>
  /// <li>
  /// The ARN of an Amazon Web Services account root: This is an IAM ARN rather
  /// than a QuickSight ARN. Use this option only to share resources (templates)
  /// across Amazon Web Services accounts. (This is less common.)
  /// </li>
  /// </ul>
  final String principal;

  ResourcePermission({
    required this.actions,
    required this.principal,
  });

  factory ResourcePermission.fromJson(Map<String, dynamic> json) {
    return ResourcePermission(
      actions: (json['Actions'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
      principal: json['Principal'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final actions = this.actions;
    final principal = this.principal;
    return {
      'Actions': actions,
      'Principal': principal,
    };
  }
}

enum ResourceStatus {
  creationInProgress,
  creationSuccessful,
  creationFailed,
  updateInProgress,
  updateSuccessful,
  updateFailed,
  deleted,
}

extension ResourceStatusValueExtension on ResourceStatus {
  String toValue() {
    switch (this) {
      case ResourceStatus.creationInProgress:
        return 'CREATION_IN_PROGRESS';
      case ResourceStatus.creationSuccessful:
        return 'CREATION_SUCCESSFUL';
      case ResourceStatus.creationFailed:
        return 'CREATION_FAILED';
      case ResourceStatus.updateInProgress:
        return 'UPDATE_IN_PROGRESS';
      case ResourceStatus.updateSuccessful:
        return 'UPDATE_SUCCESSFUL';
      case ResourceStatus.updateFailed:
        return 'UPDATE_FAILED';
      case ResourceStatus.deleted:
        return 'DELETED';
    }
  }
}

extension ResourceStatusFromString on String {
  ResourceStatus toResourceStatus() {
    switch (this) {
      case 'CREATION_IN_PROGRESS':
        return ResourceStatus.creationInProgress;
      case 'CREATION_SUCCESSFUL':
        return ResourceStatus.creationSuccessful;
      case 'CREATION_FAILED':
        return ResourceStatus.creationFailed;
      case 'UPDATE_IN_PROGRESS':
        return ResourceStatus.updateInProgress;
      case 'UPDATE_SUCCESSFUL':
        return ResourceStatus.updateSuccessful;
      case 'UPDATE_FAILED':
        return ResourceStatus.updateFailed;
      case 'DELETED':
        return ResourceStatus.deleted;
    }
    throw Exception('$this is not known in enum ResourceStatus');
  }
}

class RestoreAnalysisResponse {
  /// The ID of the analysis that you're restoring.
  final String? analysisId;

  /// The Amazon Resource Name (ARN) of the analysis that you're restoring.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  RestoreAnalysisResponse({
    this.analysisId,
    this.arn,
    this.requestId,
    this.status,
  });

  factory RestoreAnalysisResponse.fromJson(Map<String, dynamic> json) {
    return RestoreAnalysisResponse(
      analysisId: json['AnalysisId'] as String?,
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

enum Role {
  admin,
  author,
  reader,
  adminPro,
  authorPro,
  readerPro,
}

extension RoleValueExtension on Role {
  String toValue() {
    switch (this) {
      case Role.admin:
        return 'ADMIN';
      case Role.author:
        return 'AUTHOR';
      case Role.reader:
        return 'READER';
      case Role.adminPro:
        return 'ADMIN_PRO';
      case Role.authorPro:
        return 'AUTHOR_PRO';
      case Role.readerPro:
        return 'READER_PRO';
    }
  }
}

extension RoleFromString on String {
  Role toRole() {
    switch (this) {
      case 'ADMIN':
        return Role.admin;
      case 'AUTHOR':
        return Role.author;
      case 'READER':
        return Role.reader;
      case 'ADMIN_PRO':
        return Role.adminPro;
      case 'AUTHOR_PRO':
        return Role.authorPro;
      case 'READER_PRO':
        return Role.readerPro;
    }
    throw Exception('$this is not known in enum Role');
  }
}

/// The rolling date configuration of a date time filter.
class RollingDateConfiguration {
  /// The expression of the rolling date configuration.
  final String expression;

  /// The data set that is used in the rolling date configuration.
  final String? dataSetIdentifier;

  RollingDateConfiguration({
    required this.expression,
    this.dataSetIdentifier,
  });

  factory RollingDateConfiguration.fromJson(Map<String, dynamic> json) {
    return RollingDateConfiguration(
      expression: json['Expression'] as String,
      dataSetIdentifier: json['DataSetIdentifier'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final expression = this.expression;
    final dataSetIdentifier = this.dataSetIdentifier;
    return {
      'Expression': expression,
      if (dataSetIdentifier != null) 'DataSetIdentifier': dataSetIdentifier,
    };
  }
}

/// Determines the row alternate color options.
class RowAlternateColorOptions {
  /// Determines the list of row alternate colors.
  final List<String>? rowAlternateColors;

  /// Determines the widget status.
  final WidgetStatus? status;

  /// The primary background color options for alternate rows.
  final WidgetStatus? usePrimaryBackgroundColor;

  RowAlternateColorOptions({
    this.rowAlternateColors,
    this.status,
    this.usePrimaryBackgroundColor,
  });

  factory RowAlternateColorOptions.fromJson(Map<String, dynamic> json) {
    return RowAlternateColorOptions(
      rowAlternateColors: (json['RowAlternateColors'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      status: (json['Status'] as String?)?.toWidgetStatus(),
      usePrimaryBackgroundColor:
          (json['UsePrimaryBackgroundColor'] as String?)?.toWidgetStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final rowAlternateColors = this.rowAlternateColors;
    final status = this.status;
    final usePrimaryBackgroundColor = this.usePrimaryBackgroundColor;
    return {
      if (rowAlternateColors != null) 'RowAlternateColors': rowAlternateColors,
      if (status != null) 'Status': status.toValue(),
      if (usePrimaryBackgroundColor != null)
        'UsePrimaryBackgroundColor': usePrimaryBackgroundColor.toValue(),
    };
  }
}

/// Information about rows for a data set SPICE ingestion.
class RowInfo {
  /// The number of rows that were not ingested.
  final int? rowsDropped;

  /// The number of rows that were ingested.
  final int? rowsIngested;

  /// The total number of rows in the dataset.
  final int? totalRowsInDataset;

  RowInfo({
    this.rowsDropped,
    this.rowsIngested,
    this.totalRowsInDataset,
  });

  factory RowInfo.fromJson(Map<String, dynamic> json) {
    return RowInfo(
      rowsDropped: json['RowsDropped'] as int?,
      rowsIngested: json['RowsIngested'] as int?,
      totalRowsInDataset: json['TotalRowsInDataset'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final rowsDropped = this.rowsDropped;
    final rowsIngested = this.rowsIngested;
    final totalRowsInDataset = this.totalRowsInDataset;
    return {
      if (rowsDropped != null) 'RowsDropped': rowsDropped,
      if (rowsIngested != null) 'RowsIngested': rowsIngested,
      if (totalRowsInDataset != null) 'TotalRowsInDataset': totalRowsInDataset,
    };
  }
}

/// Information about a dataset that contains permissions for row-level security
/// (RLS). The permissions dataset maps fields to users or groups. For more
/// information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/restrict-access-to-a-data-set-using-row-level-security.html">Using
/// Row-Level Security (RLS) to Restrict Access to a Dataset</a> in the
/// <i>Amazon QuickSight User Guide</i>.
///
/// The option to deny permissions by setting <code>PermissionPolicy</code> to
/// <code>DENY_ACCESS</code> is not supported for new RLS datasets.
class RowLevelPermissionDataSet {
  /// The Amazon Resource Name (ARN) of the dataset that contains permissions for
  /// RLS.
  final String arn;

  /// The type of permissions to use when interpreting the permissions for RLS.
  /// <code>DENY_ACCESS</code> is included for backward compatibility only.
  final RowLevelPermissionPolicy permissionPolicy;

  /// The user or group rules associated with the dataset that contains
  /// permissions for RLS.
  ///
  /// By default, <code>FormatVersion</code> is <code>VERSION_1</code>. When
  /// <code>FormatVersion</code> is <code>VERSION_1</code>, <code>UserName</code>
  /// and <code>GroupName</code> are required. When <code>FormatVersion</code> is
  /// <code>VERSION_2</code>, <code>UserARN</code> and <code>GroupARN</code> are
  /// required, and <code>Namespace</code> must not exist.
  final RowLevelPermissionFormatVersion? formatVersion;

  /// The namespace associated with the dataset that contains permissions for RLS.
  final String? namespace;

  /// The status of the row-level security permission dataset. If enabled, the
  /// status is <code>ENABLED</code>. If disabled, the status is
  /// <code>DISABLED</code>.
  final Status? status;

  RowLevelPermissionDataSet({
    required this.arn,
    required this.permissionPolicy,
    this.formatVersion,
    this.namespace,
    this.status,
  });

  factory RowLevelPermissionDataSet.fromJson(Map<String, dynamic> json) {
    return RowLevelPermissionDataSet(
      arn: json['Arn'] as String,
      permissionPolicy:
          (json['PermissionPolicy'] as String).toRowLevelPermissionPolicy(),
      formatVersion: (json['FormatVersion'] as String?)
          ?.toRowLevelPermissionFormatVersion(),
      namespace: json['Namespace'] as String?,
      status: (json['Status'] as String?)?.toStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final permissionPolicy = this.permissionPolicy;
    final formatVersion = this.formatVersion;
    final namespace = this.namespace;
    final status = this.status;
    return {
      'Arn': arn,
      'PermissionPolicy': permissionPolicy.toValue(),
      if (formatVersion != null) 'FormatVersion': formatVersion.toValue(),
      if (namespace != null) 'Namespace': namespace,
      if (status != null) 'Status': status.toValue(),
    };
  }
}

enum RowLevelPermissionFormatVersion {
  version_1,
  version_2,
}

extension RowLevelPermissionFormatVersionValueExtension
    on RowLevelPermissionFormatVersion {
  String toValue() {
    switch (this) {
      case RowLevelPermissionFormatVersion.version_1:
        return 'VERSION_1';
      case RowLevelPermissionFormatVersion.version_2:
        return 'VERSION_2';
    }
  }
}

extension RowLevelPermissionFormatVersionFromString on String {
  RowLevelPermissionFormatVersion toRowLevelPermissionFormatVersion() {
    switch (this) {
      case 'VERSION_1':
        return RowLevelPermissionFormatVersion.version_1;
      case 'VERSION_2':
        return RowLevelPermissionFormatVersion.version_2;
    }
    throw Exception(
        '$this is not known in enum RowLevelPermissionFormatVersion');
  }
}

enum RowLevelPermissionPolicy {
  grantAccess,
  denyAccess,
}

extension RowLevelPermissionPolicyValueExtension on RowLevelPermissionPolicy {
  String toValue() {
    switch (this) {
      case RowLevelPermissionPolicy.grantAccess:
        return 'GRANT_ACCESS';
      case RowLevelPermissionPolicy.denyAccess:
        return 'DENY_ACCESS';
    }
  }
}

extension RowLevelPermissionPolicyFromString on String {
  RowLevelPermissionPolicy toRowLevelPermissionPolicy() {
    switch (this) {
      case 'GRANT_ACCESS':
        return RowLevelPermissionPolicy.grantAccess;
      case 'DENY_ACCESS':
        return RowLevelPermissionPolicy.denyAccess;
    }
    throw Exception('$this is not known in enum RowLevelPermissionPolicy');
  }
}

/// The configuration of tags on a dataset to set row-level security.
class RowLevelPermissionTagConfiguration {
  /// A set of rules associated with row-level security, such as the tag names and
  /// columns that they are assigned to.
  final List<RowLevelPermissionTagRule> tagRules;

  /// The status of row-level security tags. If enabled, the status is
  /// <code>ENABLED</code>. If disabled, the status is <code>DISABLED</code>.
  final Status? status;

  /// A list of tag configuration rules to apply to a dataset. All tag
  /// configurations have the OR condition. Tags within each tile will be joined
  /// (AND). At least one rule in this structure must have all tag values assigned
  /// to it to apply Row-level security (RLS) to the dataset.
  final List<List<String>>? tagRuleConfigurations;

  RowLevelPermissionTagConfiguration({
    required this.tagRules,
    this.status,
    this.tagRuleConfigurations,
  });

  factory RowLevelPermissionTagConfiguration.fromJson(
      Map<String, dynamic> json) {
    return RowLevelPermissionTagConfiguration(
      tagRules: (json['TagRules'] as List)
          .whereNotNull()
          .map((e) =>
              RowLevelPermissionTagRule.fromJson(e as Map<String, dynamic>))
          .toList(),
      status: (json['Status'] as String?)?.toStatus(),
      tagRuleConfigurations: (json['TagRuleConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) =>
              (e as List).whereNotNull().map((e) => e as String).toList())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final tagRules = this.tagRules;
    final status = this.status;
    final tagRuleConfigurations = this.tagRuleConfigurations;
    return {
      'TagRules': tagRules,
      if (status != null) 'Status': status.toValue(),
      if (tagRuleConfigurations != null)
        'TagRuleConfigurations': tagRuleConfigurations,
    };
  }
}

/// A set of rules associated with a tag.
class RowLevelPermissionTagRule {
  /// The column name that a tag key is assigned to.
  final String columnName;

  /// The unique key for a tag.
  final String tagKey;

  /// A string that you want to use to filter by all the values in a column in the
  /// dataset and dont want to list the values one by one. For example, you can
  /// use an asterisk as your match all value.
  final String? matchAllValue;

  /// A string that you want to use to delimit the values when you pass the values
  /// at run time. For example, you can delimit the values with a comma.
  final String? tagMultiValueDelimiter;

  RowLevelPermissionTagRule({
    required this.columnName,
    required this.tagKey,
    this.matchAllValue,
    this.tagMultiValueDelimiter,
  });

  factory RowLevelPermissionTagRule.fromJson(Map<String, dynamic> json) {
    return RowLevelPermissionTagRule(
      columnName: json['ColumnName'] as String,
      tagKey: json['TagKey'] as String,
      matchAllValue: json['MatchAllValue'] as String?,
      tagMultiValueDelimiter: json['TagMultiValueDelimiter'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final tagKey = this.tagKey;
    final matchAllValue = this.matchAllValue;
    final tagMultiValueDelimiter = this.tagMultiValueDelimiter;
    return {
      'ColumnName': columnName,
      'TagKey': tagKey,
      if (matchAllValue != null) 'MatchAllValue': matchAllValue,
      if (tagMultiValueDelimiter != null)
        'TagMultiValueDelimiter': tagMultiValueDelimiter,
    };
  }
}

/// An optional structure that contains the Amazon S3 bucket configuration that
/// the generated snapshots are stored in. If you don't provide this
/// information, generated snapshots are stored in the default Amazon QuickSight
/// bucket.
class S3BucketConfiguration {
  /// The name of an existing Amazon S3 bucket where the generated snapshot
  /// artifacts are sent.
  final String bucketName;

  /// The prefix of the Amazon S3 bucket that the generated snapshots are stored
  /// in.
  final String bucketPrefix;

  /// The region that the Amazon S3 bucket is located in. The bucket must be
  /// located in the same region that the <code>StartDashboardSnapshotJob</code>
  /// API call is made.
  final String bucketRegion;

  S3BucketConfiguration({
    required this.bucketName,
    required this.bucketPrefix,
    required this.bucketRegion,
  });

  factory S3BucketConfiguration.fromJson(Map<String, dynamic> json) {
    return S3BucketConfiguration(
      bucketName: json['BucketName'] as String,
      bucketPrefix: json['BucketPrefix'] as String,
      bucketRegion: json['BucketRegion'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final bucketName = this.bucketName;
    final bucketPrefix = this.bucketPrefix;
    final bucketRegion = this.bucketRegion;
    return {
      'BucketName': bucketName,
      'BucketPrefix': bucketPrefix,
      'BucketRegion': bucketRegion,
    };
  }
}

/// The parameters for S3.
class S3Parameters {
  /// Location of the Amazon S3 manifest file. This is NULL if the manifest file
  /// was uploaded into Amazon QuickSight.
  final ManifestFileLocation manifestFileLocation;

  /// Use the <code>RoleArn</code> structure to override an account-wide role for
  /// a specific S3 data source. For example, say an account administrator has
  /// turned off all S3 access with an account-wide role. The administrator can
  /// then use <code>RoleArn</code> to bypass the account-wide role and allow S3
  /// access for the single S3 data source that is specified in the structure,
  /// even if the account-wide role forbidding S3 access is still active.
  final String? roleArn;

  S3Parameters({
    required this.manifestFileLocation,
    this.roleArn,
  });

  factory S3Parameters.fromJson(Map<String, dynamic> json) {
    return S3Parameters(
      manifestFileLocation: ManifestFileLocation.fromJson(
          json['ManifestFileLocation'] as Map<String, dynamic>),
      roleArn: json['RoleArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final manifestFileLocation = this.manifestFileLocation;
    final roleArn = this.roleArn;
    return {
      'ManifestFileLocation': manifestFileLocation,
      if (roleArn != null) 'RoleArn': roleArn,
    };
  }
}

/// A physical table type for an S3 data source.
class S3Source {
  /// The Amazon Resource Name (ARN) for the data source.
  final String dataSourceArn;

  /// A physical table type for an S3 data source.
  /// <note>
  /// For files that aren't JSON, only <code>STRING</code> data types are
  /// supported in input columns.
  /// </note>
  final List<InputColumn> inputColumns;

  /// Information about the format for the S3 source file or files.
  final UploadSettings? uploadSettings;

  S3Source({
    required this.dataSourceArn,
    required this.inputColumns,
    this.uploadSettings,
  });

  factory S3Source.fromJson(Map<String, dynamic> json) {
    return S3Source(
      dataSourceArn: json['DataSourceArn'] as String,
      inputColumns: (json['InputColumns'] as List)
          .whereNotNull()
          .map((e) => InputColumn.fromJson(e as Map<String, dynamic>))
          .toList(),
      uploadSettings: json['UploadSettings'] != null
          ? UploadSettings.fromJson(
              json['UploadSettings'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceArn = this.dataSourceArn;
    final inputColumns = this.inputColumns;
    final uploadSettings = this.uploadSettings;
    return {
      'DataSourceArn': dataSourceArn,
      'InputColumns': inputColumns,
      if (uploadSettings != null) 'UploadSettings': uploadSettings,
    };
  }
}

/// The configuration of the same-sheet target visuals that you want to be
/// filtered.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class SameSheetTargetVisualConfiguration {
  /// The options that choose the target visual in the same sheet.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VISUALS</code>: Applies the filter operation to all visuals in the
  /// same sheet.
  /// </li>
  /// </ul>
  final TargetVisualOptions? targetVisualOptions;

  /// A list of the target visual IDs that are located in the same sheet of the
  /// analysis.
  final List<String>? targetVisuals;

  SameSheetTargetVisualConfiguration({
    this.targetVisualOptions,
    this.targetVisuals,
  });

  factory SameSheetTargetVisualConfiguration.fromJson(
      Map<String, dynamic> json) {
    return SameSheetTargetVisualConfiguration(
      targetVisualOptions:
          (json['TargetVisualOptions'] as String?)?.toTargetVisualOptions(),
      targetVisuals: (json['TargetVisuals'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final targetVisualOptions = this.targetVisualOptions;
    final targetVisuals = this.targetVisuals;
    return {
      if (targetVisualOptions != null)
        'TargetVisualOptions': targetVisualOptions.toValue(),
      if (targetVisuals != null) 'TargetVisuals': targetVisuals,
    };
  }
}

/// The field well configuration of a sankey diagram.
class SankeyDiagramAggregatedFieldWells {
  /// The destination field wells of a sankey diagram.
  final List<DimensionField>? destination;

  /// The source field wells of a sankey diagram.
  final List<DimensionField>? source;

  /// The weight field wells of a sankey diagram.
  final List<MeasureField>? weight;

  SankeyDiagramAggregatedFieldWells({
    this.destination,
    this.source,
    this.weight,
  });

  factory SankeyDiagramAggregatedFieldWells.fromJson(
      Map<String, dynamic> json) {
    return SankeyDiagramAggregatedFieldWells(
      destination: (json['Destination'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      source: (json['Source'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      weight: (json['Weight'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final destination = this.destination;
    final source = this.source;
    final weight = this.weight;
    return {
      if (destination != null) 'Destination': destination,
      if (source != null) 'Source': source,
      if (weight != null) 'Weight': weight,
    };
  }
}

/// The configuration of a sankey diagram.
class SankeyDiagramChartConfiguration {
  /// The data label configuration of a sankey diagram.
  final DataLabelOptions? dataLabels;

  /// The field well configuration of a sankey diagram.
  final SankeyDiagramFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The sort configuration of a sankey diagram.
  final SankeyDiagramSortConfiguration? sortConfiguration;

  SankeyDiagramChartConfiguration({
    this.dataLabels,
    this.fieldWells,
    this.interactions,
    this.sortConfiguration,
  });

  factory SankeyDiagramChartConfiguration.fromJson(Map<String, dynamic> json) {
    return SankeyDiagramChartConfiguration(
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? SankeyDiagramFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? SankeyDiagramSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final sortConfiguration = this.sortConfiguration;
    return {
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
    };
  }
}

/// The field well configuration of a sankey diagram.
class SankeyDiagramFieldWells {
  /// The field well configuration of a sankey diagram.
  final SankeyDiagramAggregatedFieldWells? sankeyDiagramAggregatedFieldWells;

  SankeyDiagramFieldWells({
    this.sankeyDiagramAggregatedFieldWells,
  });

  factory SankeyDiagramFieldWells.fromJson(Map<String, dynamic> json) {
    return SankeyDiagramFieldWells(
      sankeyDiagramAggregatedFieldWells:
          json['SankeyDiagramAggregatedFieldWells'] != null
              ? SankeyDiagramAggregatedFieldWells.fromJson(
                  json['SankeyDiagramAggregatedFieldWells']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sankeyDiagramAggregatedFieldWells =
        this.sankeyDiagramAggregatedFieldWells;
    return {
      if (sankeyDiagramAggregatedFieldWells != null)
        'SankeyDiagramAggregatedFieldWells': sankeyDiagramAggregatedFieldWells,
    };
  }
}

/// The sort configuration of a sankey diagram.
class SankeyDiagramSortConfiguration {
  /// The limit on the number of destination nodes that are displayed in a sankey
  /// diagram.
  final ItemsLimitConfiguration? destinationItemsLimit;

  /// The limit on the number of source nodes that are displayed in a sankey
  /// diagram.
  final ItemsLimitConfiguration? sourceItemsLimit;

  /// The sort configuration of the weight fields.
  final List<FieldSortOptions>? weightSort;

  SankeyDiagramSortConfiguration({
    this.destinationItemsLimit,
    this.sourceItemsLimit,
    this.weightSort,
  });

  factory SankeyDiagramSortConfiguration.fromJson(Map<String, dynamic> json) {
    return SankeyDiagramSortConfiguration(
      destinationItemsLimit: json['DestinationItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['DestinationItemsLimit'] as Map<String, dynamic>)
          : null,
      sourceItemsLimit: json['SourceItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['SourceItemsLimit'] as Map<String, dynamic>)
          : null,
      weightSort: (json['WeightSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final destinationItemsLimit = this.destinationItemsLimit;
    final sourceItemsLimit = this.sourceItemsLimit;
    final weightSort = this.weightSort;
    return {
      if (destinationItemsLimit != null)
        'DestinationItemsLimit': destinationItemsLimit,
      if (sourceItemsLimit != null) 'SourceItemsLimit': sourceItemsLimit,
      if (weightSort != null) 'WeightSort': weightSort,
    };
  }
}

/// A sankey diagram.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using
/// Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.
class SankeyDiagramVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration of a sankey diagram.
  final SankeyDiagramChartConfiguration? chartConfiguration;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  SankeyDiagramVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.subtitle,
    this.title,
  });

  factory SankeyDiagramVisual.fromJson(Map<String, dynamic> json) {
    return SankeyDiagramVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? SankeyDiagramChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The aggregated field well of a scatter plot.
class ScatterPlotCategoricallyAggregatedFieldWells {
  /// The category field well of a scatter plot.
  final List<DimensionField>? category;

  /// The label field well of a scatter plot.
  final List<DimensionField>? label;

  /// The size field well of a scatter plot.
  final List<MeasureField>? size;

  /// The x-axis field well of a scatter plot.
  ///
  /// The x-axis is aggregated by category.
  final List<MeasureField>? xAxis;

  /// The y-axis field well of a scatter plot.
  ///
  /// The y-axis is aggregated by category.
  final List<MeasureField>? yAxis;

  ScatterPlotCategoricallyAggregatedFieldWells({
    this.category,
    this.label,
    this.size,
    this.xAxis,
    this.yAxis,
  });

  factory ScatterPlotCategoricallyAggregatedFieldWells.fromJson(
      Map<String, dynamic> json) {
    return ScatterPlotCategoricallyAggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      label: (json['Label'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      size: (json['Size'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      xAxis: (json['XAxis'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      yAxis: (json['YAxis'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final label = this.label;
    final size = this.size;
    final xAxis = this.xAxis;
    final yAxis = this.yAxis;
    return {
      if (category != null) 'Category': category,
      if (label != null) 'Label': label,
      if (size != null) 'Size': size,
      if (xAxis != null) 'XAxis': xAxis,
      if (yAxis != null) 'YAxis': yAxis,
    };
  }
}

/// The configuration of a scatter plot.
class ScatterPlotConfiguration {
  /// The options that determine if visual data labels are displayed.
  final DataLabelOptions? dataLabels;

  /// The field wells of the visual.
  final ScatterPlotFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The sort configuration of a scatter plot.
  final ScatterPlotSortConfiguration? sortConfiguration;

  /// The legend display setup of the visual.
  final TooltipOptions? tooltip;

  /// The palette (chart color) display setup of the visual.
  final VisualPalette? visualPalette;

  /// The label display options (grid line, range, scale, and axis step) of the
  /// scatter plot's x-axis.
  final AxisDisplayOptions? xAxisDisplayOptions;

  /// The label options (label text, label visibility, and sort icon visibility)
  /// of the scatter plot's x-axis.
  final ChartAxisLabelOptions? xAxisLabelOptions;

  /// The label display options (grid line, range, scale, and axis step) of the
  /// scatter plot's y-axis.
  final AxisDisplayOptions? yAxisDisplayOptions;

  /// The label options (label text, label visibility, and sort icon visibility)
  /// of the scatter plot's y-axis.
  final ChartAxisLabelOptions? yAxisLabelOptions;

  ScatterPlotConfiguration({
    this.dataLabels,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.sortConfiguration,
    this.tooltip,
    this.visualPalette,
    this.xAxisDisplayOptions,
    this.xAxisLabelOptions,
    this.yAxisDisplayOptions,
    this.yAxisLabelOptions,
  });

  factory ScatterPlotConfiguration.fromJson(Map<String, dynamic> json) {
    return ScatterPlotConfiguration(
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? ScatterPlotFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? ScatterPlotSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
      xAxisDisplayOptions: json['XAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['XAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      xAxisLabelOptions: json['XAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['XAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      yAxisDisplayOptions: json['YAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['YAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      yAxisLabelOptions: json['YAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['YAxisLabelOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    final visualPalette = this.visualPalette;
    final xAxisDisplayOptions = this.xAxisDisplayOptions;
    final xAxisLabelOptions = this.xAxisLabelOptions;
    final yAxisDisplayOptions = this.yAxisDisplayOptions;
    final yAxisLabelOptions = this.yAxisLabelOptions;
    return {
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
      if (visualPalette != null) 'VisualPalette': visualPalette,
      if (xAxisDisplayOptions != null)
        'XAxisDisplayOptions': xAxisDisplayOptions,
      if (xAxisLabelOptions != null) 'XAxisLabelOptions': xAxisLabelOptions,
      if (yAxisDisplayOptions != null)
        'YAxisDisplayOptions': yAxisDisplayOptions,
      if (yAxisLabelOptions != null) 'YAxisLabelOptions': yAxisLabelOptions,
    };
  }
}

/// The field well configuration of a scatter plot.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class ScatterPlotFieldWells {
  /// The aggregated field wells of a scatter plot. The x and y-axes of scatter
  /// plots with aggregated field wells are aggregated by category, label, or
  /// both.
  final ScatterPlotCategoricallyAggregatedFieldWells?
      scatterPlotCategoricallyAggregatedFieldWells;

  /// The unaggregated field wells of a scatter plot. The x and y-axes of these
  /// scatter plots are unaggregated.
  final ScatterPlotUnaggregatedFieldWells? scatterPlotUnaggregatedFieldWells;

  ScatterPlotFieldWells({
    this.scatterPlotCategoricallyAggregatedFieldWells,
    this.scatterPlotUnaggregatedFieldWells,
  });

  factory ScatterPlotFieldWells.fromJson(Map<String, dynamic> json) {
    return ScatterPlotFieldWells(
      scatterPlotCategoricallyAggregatedFieldWells:
          json['ScatterPlotCategoricallyAggregatedFieldWells'] != null
              ? ScatterPlotCategoricallyAggregatedFieldWells.fromJson(
                  json['ScatterPlotCategoricallyAggregatedFieldWells']
                      as Map<String, dynamic>)
              : null,
      scatterPlotUnaggregatedFieldWells:
          json['ScatterPlotUnaggregatedFieldWells'] != null
              ? ScatterPlotUnaggregatedFieldWells.fromJson(
                  json['ScatterPlotUnaggregatedFieldWells']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final scatterPlotCategoricallyAggregatedFieldWells =
        this.scatterPlotCategoricallyAggregatedFieldWells;
    final scatterPlotUnaggregatedFieldWells =
        this.scatterPlotUnaggregatedFieldWells;
    return {
      if (scatterPlotCategoricallyAggregatedFieldWells != null)
        'ScatterPlotCategoricallyAggregatedFieldWells':
            scatterPlotCategoricallyAggregatedFieldWells,
      if (scatterPlotUnaggregatedFieldWells != null)
        'ScatterPlotUnaggregatedFieldWells': scatterPlotUnaggregatedFieldWells,
    };
  }
}

/// The sort configuration of a scatter plot.
class ScatterPlotSortConfiguration {
  final ItemsLimitConfiguration? scatterPlotLimitConfiguration;

  ScatterPlotSortConfiguration({
    this.scatterPlotLimitConfiguration,
  });

  factory ScatterPlotSortConfiguration.fromJson(Map<String, dynamic> json) {
    return ScatterPlotSortConfiguration(
      scatterPlotLimitConfiguration:
          json['ScatterPlotLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['ScatterPlotLimitConfiguration'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final scatterPlotLimitConfiguration = this.scatterPlotLimitConfiguration;
    return {
      if (scatterPlotLimitConfiguration != null)
        'ScatterPlotLimitConfiguration': scatterPlotLimitConfiguration,
    };
  }
}

/// The unaggregated field wells of a scatter plot.
class ScatterPlotUnaggregatedFieldWells {
  /// The category field well of a scatter plot.
  final List<DimensionField>? category;

  /// The label field well of a scatter plot.
  final List<DimensionField>? label;

  /// The size field well of a scatter plot.
  final List<MeasureField>? size;

  /// The x-axis field well of a scatter plot.
  ///
  /// The x-axis is a dimension field and cannot be aggregated.
  final List<DimensionField>? xAxis;

  /// The y-axis field well of a scatter plot.
  ///
  /// The y-axis is a dimension field and cannot be aggregated.
  final List<DimensionField>? yAxis;

  ScatterPlotUnaggregatedFieldWells({
    this.category,
    this.label,
    this.size,
    this.xAxis,
    this.yAxis,
  });

  factory ScatterPlotUnaggregatedFieldWells.fromJson(
      Map<String, dynamic> json) {
    return ScatterPlotUnaggregatedFieldWells(
      category: (json['Category'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      label: (json['Label'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      size: (json['Size'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      xAxis: (json['XAxis'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      yAxis: (json['YAxis'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final category = this.category;
    final label = this.label;
    final size = this.size;
    final xAxis = this.xAxis;
    final yAxis = this.yAxis;
    return {
      if (category != null) 'Category': category,
      if (label != null) 'Label': label,
      if (size != null) 'Size': size,
      if (xAxis != null) 'XAxis': xAxis,
      if (yAxis != null) 'YAxis': yAxis,
    };
  }
}

/// A scatter plot.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using
/// scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.
class ScatterPlotVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final ScatterPlotConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  ScatterPlotVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory ScatterPlotVisual.fromJson(Map<String, dynamic> json) {
    return ScatterPlotVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? ScatterPlotConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The refresh on entity for weekly or monthly schedules.
class ScheduleRefreshOnEntity {
  /// The day of the month that you want to schedule refresh on.
  final String? dayOfMonth;

  /// The day of the week that you want to schedule a refresh on.
  final DayOfWeek? dayOfWeek;

  ScheduleRefreshOnEntity({
    this.dayOfMonth,
    this.dayOfWeek,
  });

  factory ScheduleRefreshOnEntity.fromJson(Map<String, dynamic> json) {
    return ScheduleRefreshOnEntity(
      dayOfMonth: json['DayOfMonth'] as String?,
      dayOfWeek: (json['DayOfWeek'] as String?)?.toDayOfWeek(),
    );
  }

  Map<String, dynamic> toJson() {
    final dayOfMonth = this.dayOfMonth;
    final dayOfWeek = this.dayOfWeek;
    return {
      if (dayOfMonth != null) 'DayOfMonth': dayOfMonth,
      if (dayOfWeek != null) 'DayOfWeek': dayOfWeek.toValue(),
    };
  }
}

/// The visual display options for a data zoom scroll bar.
class ScrollBarOptions {
  /// The visibility of the data zoom scroll bar.
  final Visibility? visibility;

  /// The visibility range for the data zoom scroll bar.
  final VisibleRangeOptions? visibleRange;

  ScrollBarOptions({
    this.visibility,
    this.visibleRange,
  });

  factory ScrollBarOptions.fromJson(Map<String, dynamic> json) {
    return ScrollBarOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
      visibleRange: json['VisibleRange'] != null
          ? VisibleRangeOptions.fromJson(
              json['VisibleRange'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    final visibleRange = this.visibleRange;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
      if (visibleRange != null) 'VisibleRange': visibleRange,
    };
  }
}

class SearchAnalysesResponse {
  /// Metadata describing the analyses that you searched for.
  final List<AnalysisSummary>? analysisSummaryList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  SearchAnalysesResponse({
    this.analysisSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory SearchAnalysesResponse.fromJson(Map<String, dynamic> json) {
    return SearchAnalysesResponse(
      analysisSummaryList: (json['AnalysisSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => AnalysisSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisSummaryList = this.analysisSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisSummaryList != null)
        'AnalysisSummaryList': analysisSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class SearchDashboardsResponse {
  /// The list of dashboards owned by the user specified in <code>Filters</code>
  /// in your request.
  final List<DashboardSummary>? dashboardSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  SearchDashboardsResponse({
    this.dashboardSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory SearchDashboardsResponse.fromJson(Map<String, dynamic> json) {
    return SearchDashboardsResponse(
      dashboardSummaryList: (json['DashboardSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => DashboardSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardSummaryList = this.dashboardSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardSummaryList != null)
        'DashboardSummaryList': dashboardSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class SearchDataSetsResponse {
  /// A <code>DataSetSummaries</code> object that returns a summary of a dataset.
  final List<DataSetSummary>? dataSetSummaries;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  SearchDataSetsResponse({
    this.dataSetSummaries,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory SearchDataSetsResponse.fromJson(Map<String, dynamic> json) {
    return SearchDataSetsResponse(
      dataSetSummaries: (json['DataSetSummaries'] as List?)
          ?.whereNotNull()
          .map((e) => DataSetSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetSummaries = this.dataSetSummaries;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSetSummaries != null) 'DataSetSummaries': dataSetSummaries,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class SearchDataSourcesResponse {
  /// A <code>DataSourceSummaries</code> object that returns a summary of a data
  /// source.
  final List<DataSourceSummary>? dataSourceSummaries;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  SearchDataSourcesResponse({
    this.dataSourceSummaries,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory SearchDataSourcesResponse.fromJson(Map<String, dynamic> json) {
    return SearchDataSourcesResponse(
      dataSourceSummaries: (json['DataSourceSummaries'] as List?)
          ?.whereNotNull()
          .map((e) => DataSourceSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceSummaries = this.dataSourceSummaries;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSourceSummaries != null)
        'DataSourceSummaries': dataSourceSummaries,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class SearchFoldersResponse {
  /// A structure that contains all of the folders in the Amazon Web Services
  /// account. This structure provides basic information about the folders.
  final List<FolderSummary>? folderSummaryList;

  /// The token for the next set of results, or null if there are no more results.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  SearchFoldersResponse({
    this.folderSummaryList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory SearchFoldersResponse.fromJson(Map<String, dynamic> json) {
    return SearchFoldersResponse(
      folderSummaryList: (json['FolderSummaryList'] as List?)
          ?.whereNotNull()
          .map((e) => FolderSummary.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final folderSummaryList = this.folderSummaryList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (folderSummaryList != null) 'FolderSummaryList': folderSummaryList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class SearchGroupsResponse {
  /// A list of groups in a specified namespace that match the filters you set in
  /// your <code>SearchGroups</code> request.
  final List<Group>? groupList;

  /// A pagination token that can be used in a subsequent request.
  final String? nextToken;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  SearchGroupsResponse({
    this.groupList,
    this.nextToken,
    this.requestId,
    this.status,
  });

  factory SearchGroupsResponse.fromJson(Map<String, dynamic> json) {
    return SearchGroupsResponse(
      groupList: (json['GroupList'] as List?)
          ?.whereNotNull()
          .map((e) => Group.fromJson(e as Map<String, dynamic>))
          .toList(),
      nextToken: json['NextToken'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final groupList = this.groupList;
    final nextToken = this.nextToken;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (groupList != null) 'GroupList': groupList,
      if (nextToken != null) 'NextToken': nextToken,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

/// The options that determine the presentation of the secondary value of a KPI
/// visual.
class SecondaryValueOptions {
  /// Determines the visibility of the secondary value.
  final Visibility? visibility;

  SecondaryValueOptions({
    this.visibility,
  });

  factory SecondaryValueOptions.fromJson(Map<String, dynamic> json) {
    return SecondaryValueOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The configuration of a page break after a section.
class SectionAfterPageBreak {
  /// The option that enables or disables a page break at the end of a section.
  final SectionPageBreakStatus? status;

  SectionAfterPageBreak({
    this.status,
  });

  factory SectionAfterPageBreak.fromJson(Map<String, dynamic> json) {
    return SectionAfterPageBreak(
      status: (json['Status'] as String?)?.toSectionPageBreakStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final status = this.status;
    return {
      if (status != null) 'Status': status.toValue(),
    };
  }
}

/// The options for the canvas of a section-based layout.
class SectionBasedLayoutCanvasSizeOptions {
  /// The options for a paper canvas of a section-based layout.
  final SectionBasedLayoutPaperCanvasSizeOptions? paperCanvasSizeOptions;

  SectionBasedLayoutCanvasSizeOptions({
    this.paperCanvasSizeOptions,
  });

  factory SectionBasedLayoutCanvasSizeOptions.fromJson(
      Map<String, dynamic> json) {
    return SectionBasedLayoutCanvasSizeOptions(
      paperCanvasSizeOptions: json['PaperCanvasSizeOptions'] != null
          ? SectionBasedLayoutPaperCanvasSizeOptions.fromJson(
              json['PaperCanvasSizeOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final paperCanvasSizeOptions = this.paperCanvasSizeOptions;
    return {
      if (paperCanvasSizeOptions != null)
        'PaperCanvasSizeOptions': paperCanvasSizeOptions,
    };
  }
}

/// The configuration for a section-based layout.
class SectionBasedLayoutConfiguration {
  /// A list of body section configurations.
  final List<BodySectionConfiguration> bodySections;

  /// The options for the canvas of a section-based layout.
  final SectionBasedLayoutCanvasSizeOptions canvasSizeOptions;

  /// A list of footer section configurations.
  final List<HeaderFooterSectionConfiguration> footerSections;

  /// A list of header section configurations.
  final List<HeaderFooterSectionConfiguration> headerSections;

  SectionBasedLayoutConfiguration({
    required this.bodySections,
    required this.canvasSizeOptions,
    required this.footerSections,
    required this.headerSections,
  });

  factory SectionBasedLayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return SectionBasedLayoutConfiguration(
      bodySections: (json['BodySections'] as List)
          .whereNotNull()
          .map((e) =>
              BodySectionConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      canvasSizeOptions: SectionBasedLayoutCanvasSizeOptions.fromJson(
          json['CanvasSizeOptions'] as Map<String, dynamic>),
      footerSections: (json['FooterSections'] as List)
          .whereNotNull()
          .map((e) => HeaderFooterSectionConfiguration.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      headerSections: (json['HeaderSections'] as List)
          .whereNotNull()
          .map((e) => HeaderFooterSectionConfiguration.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final bodySections = this.bodySections;
    final canvasSizeOptions = this.canvasSizeOptions;
    final footerSections = this.footerSections;
    final headerSections = this.headerSections;
    return {
      'BodySections': bodySections,
      'CanvasSizeOptions': canvasSizeOptions,
      'FooterSections': footerSections,
      'HeaderSections': headerSections,
    };
  }
}

/// The options for a paper canvas of a section-based layout.
class SectionBasedLayoutPaperCanvasSizeOptions {
  /// Defines the spacing between the canvas content and the top, bottom, left,
  /// and right edges.
  final Spacing? paperMargin;

  /// The paper orientation that is used to define canvas dimensions. Choose one
  /// of the following options:
  ///
  /// <ul>
  /// <li>
  /// PORTRAIT
  /// </li>
  /// <li>
  /// LANDSCAPE
  /// </li>
  /// </ul>
  final PaperOrientation? paperOrientation;

  /// The paper size that is used to define canvas dimensions.
  final PaperSize? paperSize;

  SectionBasedLayoutPaperCanvasSizeOptions({
    this.paperMargin,
    this.paperOrientation,
    this.paperSize,
  });

  factory SectionBasedLayoutPaperCanvasSizeOptions.fromJson(
      Map<String, dynamic> json) {
    return SectionBasedLayoutPaperCanvasSizeOptions(
      paperMargin: json['PaperMargin'] != null
          ? Spacing.fromJson(json['PaperMargin'] as Map<String, dynamic>)
          : null,
      paperOrientation:
          (json['PaperOrientation'] as String?)?.toPaperOrientation(),
      paperSize: (json['PaperSize'] as String?)?.toPaperSize(),
    );
  }

  Map<String, dynamic> toJson() {
    final paperMargin = this.paperMargin;
    final paperOrientation = this.paperOrientation;
    final paperSize = this.paperSize;
    return {
      if (paperMargin != null) 'PaperMargin': paperMargin,
      if (paperOrientation != null)
        'PaperOrientation': paperOrientation.toValue(),
      if (paperSize != null) 'PaperSize': paperSize.toValue(),
    };
  }
}

/// The layout configuration of a section.
class SectionLayoutConfiguration {
  /// The free-form layout configuration of a section.
  final FreeFormSectionLayoutConfiguration freeFormLayout;

  SectionLayoutConfiguration({
    required this.freeFormLayout,
  });

  factory SectionLayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return SectionLayoutConfiguration(
      freeFormLayout: FreeFormSectionLayoutConfiguration.fromJson(
          json['FreeFormLayout'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final freeFormLayout = this.freeFormLayout;
    return {
      'FreeFormLayout': freeFormLayout,
    };
  }
}

/// The configuration of a page break for a section.
class SectionPageBreakConfiguration {
  /// The configuration of a page break after a section.
  final SectionAfterPageBreak? after;

  SectionPageBreakConfiguration({
    this.after,
  });

  factory SectionPageBreakConfiguration.fromJson(Map<String, dynamic> json) {
    return SectionPageBreakConfiguration(
      after: json['After'] != null
          ? SectionAfterPageBreak.fromJson(
              json['After'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final after = this.after;
    return {
      if (after != null) 'After': after,
    };
  }
}

enum SectionPageBreakStatus {
  enabled,
  disabled,
}

extension SectionPageBreakStatusValueExtension on SectionPageBreakStatus {
  String toValue() {
    switch (this) {
      case SectionPageBreakStatus.enabled:
        return 'ENABLED';
      case SectionPageBreakStatus.disabled:
        return 'DISABLED';
    }
  }
}

extension SectionPageBreakStatusFromString on String {
  SectionPageBreakStatus toSectionPageBreakStatus() {
    switch (this) {
      case 'ENABLED':
        return SectionPageBreakStatus.enabled;
      case 'DISABLED':
        return SectionPageBreakStatus.disabled;
    }
    throw Exception('$this is not known in enum SectionPageBreakStatus');
  }
}

/// The options that style a section.
class SectionStyle {
  /// The height of a section.
  ///
  /// Heights can only be defined for header and footer sections. The default
  /// height margin is 0.5 inches.
  final String? height;

  /// The spacing between section content and its top, bottom, left, and right
  /// edges.
  ///
  /// There is no padding by default.
  final Spacing? padding;

  SectionStyle({
    this.height,
    this.padding,
  });

  factory SectionStyle.fromJson(Map<String, dynamic> json) {
    return SectionStyle(
      height: json['Height'] as String?,
      padding: json['Padding'] != null
          ? Spacing.fromJson(json['Padding'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final height = this.height;
    final padding = this.padding;
    return {
      if (height != null) 'Height': height,
      if (padding != null) 'Padding': padding,
    };
  }
}

enum SelectAllValueOptions {
  allValues,
}

extension SelectAllValueOptionsValueExtension on SelectAllValueOptions {
  String toValue() {
    switch (this) {
      case SelectAllValueOptions.allValues:
        return 'ALL_VALUES';
    }
  }
}

extension SelectAllValueOptionsFromString on String {
  SelectAllValueOptions toSelectAllValueOptions() {
    switch (this) {
      case 'ALL_VALUES':
        return SelectAllValueOptions.allValues;
    }
    throw Exception('$this is not known in enum SelectAllValueOptions');
  }
}

enum SelectedFieldOptions {
  allFields,
}

extension SelectedFieldOptionsValueExtension on SelectedFieldOptions {
  String toValue() {
    switch (this) {
      case SelectedFieldOptions.allFields:
        return 'ALL_FIELDS';
    }
  }
}

extension SelectedFieldOptionsFromString on String {
  SelectedFieldOptions toSelectedFieldOptions() {
    switch (this) {
      case 'ALL_FIELDS':
        return SelectedFieldOptions.allFields;
    }
    throw Exception('$this is not known in enum SelectedFieldOptions');
  }
}

/// The configuration for applying a filter to specific sheets or visuals. You
/// can apply this filter to multiple visuals that are on one sheet or to all
/// visuals on a sheet.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class SelectedSheetsFilterScopeConfiguration {
  /// The sheet ID and visual IDs of the sheet and visuals that the filter is
  /// applied to.
  final List<SheetVisualScopingConfiguration>? sheetVisualScopingConfigurations;

  SelectedSheetsFilterScopeConfiguration({
    this.sheetVisualScopingConfigurations,
  });

  factory SelectedSheetsFilterScopeConfiguration.fromJson(
      Map<String, dynamic> json) {
    return SelectedSheetsFilterScopeConfiguration(
      sheetVisualScopingConfigurations:
          (json['SheetVisualScopingConfigurations'] as List?)
              ?.whereNotNull()
              .map((e) => SheetVisualScopingConfiguration.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final sheetVisualScopingConfigurations =
        this.sheetVisualScopingConfigurations;
    return {
      if (sheetVisualScopingConfigurations != null)
        'SheetVisualScopingConfigurations': sheetVisualScopingConfigurations,
    };
  }
}

enum SelectedTooltipType {
  basic,
  detailed,
}

extension SelectedTooltipTypeValueExtension on SelectedTooltipType {
  String toValue() {
    switch (this) {
      case SelectedTooltipType.basic:
        return 'BASIC';
      case SelectedTooltipType.detailed:
        return 'DETAILED';
    }
  }
}

extension SelectedTooltipTypeFromString on String {
  SelectedTooltipType toSelectedTooltipType() {
    switch (this) {
      case 'BASIC':
        return SelectedTooltipType.basic;
      case 'DETAILED':
        return SelectedTooltipType.detailed;
    }
    throw Exception('$this is not known in enum SelectedTooltipType');
  }
}

/// A structure that represents a semantic entity type.
class SemanticEntityType {
  /// The semantic entity sub type name.
  final String? subTypeName;

  /// The semantic entity type name.
  final String? typeName;

  /// The semantic entity type parameters.
  final Map<String, String>? typeParameters;

  SemanticEntityType({
    this.subTypeName,
    this.typeName,
    this.typeParameters,
  });

  factory SemanticEntityType.fromJson(Map<String, dynamic> json) {
    return SemanticEntityType(
      subTypeName: json['SubTypeName'] as String?,
      typeName: json['TypeName'] as String?,
      typeParameters: (json['TypeParameters'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final subTypeName = this.subTypeName;
    final typeName = this.typeName;
    final typeParameters = this.typeParameters;
    return {
      if (subTypeName != null) 'SubTypeName': subTypeName,
      if (typeName != null) 'TypeName': typeName,
      if (typeParameters != null) 'TypeParameters': typeParameters,
    };
  }
}

/// A structure that represents a semantic type.
class SemanticType {
  /// The semantic type falsey cell value.
  final String? falseyCellValue;

  /// The other names or aliases for the false cell value.
  final List<String>? falseyCellValueSynonyms;

  /// The semantic type sub type name.
  final String? subTypeName;

  /// The semantic type truthy cell value.
  final String? truthyCellValue;

  /// The other names or aliases for the true cell value.
  final List<String>? truthyCellValueSynonyms;

  /// The semantic type name.
  final String? typeName;

  /// The semantic type parameters.
  final Map<String, String>? typeParameters;

  SemanticType({
    this.falseyCellValue,
    this.falseyCellValueSynonyms,
    this.subTypeName,
    this.truthyCellValue,
    this.truthyCellValueSynonyms,
    this.typeName,
    this.typeParameters,
  });

  factory SemanticType.fromJson(Map<String, dynamic> json) {
    return SemanticType(
      falseyCellValue: json['FalseyCellValue'] as String?,
      falseyCellValueSynonyms: (json['FalseyCellValueSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      subTypeName: json['SubTypeName'] as String?,
      truthyCellValue: json['TruthyCellValue'] as String?,
      truthyCellValueSynonyms: (json['TruthyCellValueSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      typeName: json['TypeName'] as String?,
      typeParameters: (json['TypeParameters'] as Map<String, dynamic>?)
          ?.map((k, e) => MapEntry(k, e as String)),
    );
  }

  Map<String, dynamic> toJson() {
    final falseyCellValue = this.falseyCellValue;
    final falseyCellValueSynonyms = this.falseyCellValueSynonyms;
    final subTypeName = this.subTypeName;
    final truthyCellValue = this.truthyCellValue;
    final truthyCellValueSynonyms = this.truthyCellValueSynonyms;
    final typeName = this.typeName;
    final typeParameters = this.typeParameters;
    return {
      if (falseyCellValue != null) 'FalseyCellValue': falseyCellValue,
      if (falseyCellValueSynonyms != null)
        'FalseyCellValueSynonyms': falseyCellValueSynonyms,
      if (subTypeName != null) 'SubTypeName': subTypeName,
      if (truthyCellValue != null) 'TruthyCellValue': truthyCellValue,
      if (truthyCellValueSynonyms != null)
        'TruthyCellValueSynonyms': truthyCellValueSynonyms,
      if (typeName != null) 'TypeName': typeName,
      if (typeParameters != null) 'TypeParameters': typeParameters,
    };
  }
}

/// The series item configuration of a line chart.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class SeriesItem {
  /// The data field series item configuration of a line chart.
  final DataFieldSeriesItem? dataFieldSeriesItem;

  /// The field series item configuration of a line chart.
  final FieldSeriesItem? fieldSeriesItem;

  SeriesItem({
    this.dataFieldSeriesItem,
    this.fieldSeriesItem,
  });

  factory SeriesItem.fromJson(Map<String, dynamic> json) {
    return SeriesItem(
      dataFieldSeriesItem: json['DataFieldSeriesItem'] != null
          ? DataFieldSeriesItem.fromJson(
              json['DataFieldSeriesItem'] as Map<String, dynamic>)
          : null,
      fieldSeriesItem: json['FieldSeriesItem'] != null
          ? FieldSeriesItem.fromJson(
              json['FieldSeriesItem'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataFieldSeriesItem = this.dataFieldSeriesItem;
    final fieldSeriesItem = this.fieldSeriesItem;
    return {
      if (dataFieldSeriesItem != null)
        'DataFieldSeriesItem': dataFieldSeriesItem,
      if (fieldSeriesItem != null) 'FieldSeriesItem': fieldSeriesItem,
    };
  }
}

/// The parameters for ServiceNow.
class ServiceNowParameters {
  /// URL of the base site.
  final String siteBaseUrl;

  ServiceNowParameters({
    required this.siteBaseUrl,
  });

  factory ServiceNowParameters.fromJson(Map<String, dynamic> json) {
    return ServiceNowParameters(
      siteBaseUrl: json['SiteBaseUrl'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final siteBaseUrl = this.siteBaseUrl;
    return {
      'SiteBaseUrl': siteBaseUrl,
    };
  }
}

enum ServiceType {
  redshift,
}

extension ServiceTypeValueExtension on ServiceType {
  String toValue() {
    switch (this) {
      case ServiceType.redshift:
        return 'REDSHIFT';
    }
  }
}

extension ServiceTypeFromString on String {
  ServiceType toServiceType() {
    switch (this) {
      case 'REDSHIFT':
        return ServiceType.redshift;
    }
    throw Exception('$this is not known in enum ServiceType');
  }
}

/// The key-value pair used for the row-level security tags feature.
class SessionTag {
  /// The key for the tag.
  final String key;

  /// The value that you want to assign the tag.
  final String value;

  SessionTag({
    required this.key,
    required this.value,
  });

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      'Key': key,
      'Value': value,
    };
  }
}

/// The configuration of adding parameters in action.
class SetParameterValueConfiguration {
  /// The destination parameter name of the
  /// <code>SetParameterValueConfiguration</code>.
  final String destinationParameterName;
  final DestinationParameterValueConfiguration value;

  SetParameterValueConfiguration({
    required this.destinationParameterName,
    required this.value,
  });

  factory SetParameterValueConfiguration.fromJson(Map<String, dynamic> json) {
    return SetParameterValueConfiguration(
      destinationParameterName: json['DestinationParameterName'] as String,
      value: DestinationParameterValueConfiguration.fromJson(
          json['Value'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final destinationParameterName = this.destinationParameterName;
    final value = this.value;
    return {
      'DestinationParameterName': destinationParameterName,
      'Value': value,
    };
  }
}

/// The shape conditional formatting of a filled map visual.
class ShapeConditionalFormat {
  /// The conditional formatting for the shape background color of a filled map
  /// visual.
  final ConditionalFormattingColor backgroundColor;

  ShapeConditionalFormat({
    required this.backgroundColor,
  });

  factory ShapeConditionalFormat.fromJson(Map<String, dynamic> json) {
    return ShapeConditionalFormat(
      backgroundColor: ConditionalFormattingColor.fromJson(
          json['BackgroundColor'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final backgroundColor = this.backgroundColor;
    return {
      'BackgroundColor': backgroundColor,
    };
  }
}

enum SharingModel {
  account,
  namespace,
}

extension SharingModelValueExtension on SharingModel {
  String toValue() {
    switch (this) {
      case SharingModel.account:
        return 'ACCOUNT';
      case SharingModel.namespace:
        return 'NAMESPACE';
    }
  }
}

extension SharingModelFromString on String {
  SharingModel toSharingModel() {
    switch (this) {
      case 'ACCOUNT':
        return SharingModel.account;
      case 'NAMESPACE':
        return SharingModel.namespace;
    }
    throw Exception('$this is not known in enum SharingModel');
  }
}

/// A <i>sheet</i>, which is an object that contains a set of visuals that are
/// viewed together on one page in Amazon QuickSight. Every analysis and
/// dashboard contains at least one sheet. Each sheet contains at least one
/// visualization widget, for example a chart, pivot table, or narrative
/// insight. Sheets can be associated with other components, such as controls,
/// filters, and so on.
class Sheet {
  /// The name of a sheet. This name is displayed on the sheet's tab in the Amazon
  /// QuickSight console.
  final String? name;

  /// The unique identifier associated with a sheet.
  final String? sheetId;

  Sheet({
    this.name,
    this.sheetId,
  });

  factory Sheet.fromJson(Map<String, dynamic> json) {
    return Sheet(
      name: json['Name'] as String?,
      sheetId: json['SheetId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final sheetId = this.sheetId;
    return {
      if (name != null) 'Name': name,
      if (sheetId != null) 'SheetId': sheetId,
    };
  }
}

enum SheetContentType {
  paginated,
  interactive,
}

extension SheetContentTypeValueExtension on SheetContentType {
  String toValue() {
    switch (this) {
      case SheetContentType.paginated:
        return 'PAGINATED';
      case SheetContentType.interactive:
        return 'INTERACTIVE';
    }
  }
}

extension SheetContentTypeFromString on String {
  SheetContentType toSheetContentType() {
    switch (this) {
      case 'PAGINATED':
        return SheetContentType.paginated;
      case 'INTERACTIVE':
        return SheetContentType.interactive;
    }
    throw Exception('$this is not known in enum SheetContentType');
  }
}

enum SheetControlDateTimePickerType {
  singleValued,
  dateRange,
}

extension SheetControlDateTimePickerTypeValueExtension
    on SheetControlDateTimePickerType {
  String toValue() {
    switch (this) {
      case SheetControlDateTimePickerType.singleValued:
        return 'SINGLE_VALUED';
      case SheetControlDateTimePickerType.dateRange:
        return 'DATE_RANGE';
    }
  }
}

extension SheetControlDateTimePickerTypeFromString on String {
  SheetControlDateTimePickerType toSheetControlDateTimePickerType() {
    switch (this) {
      case 'SINGLE_VALUED':
        return SheetControlDateTimePickerType.singleValued;
      case 'DATE_RANGE':
        return SheetControlDateTimePickerType.dateRange;
    }
    throw Exception(
        '$this is not known in enum SheetControlDateTimePickerType');
  }
}

/// A control to display info icons for filters and parameters.
class SheetControlInfoIconLabelOptions {
  /// The text content of info icon.
  final String? infoIconText;

  /// The visibility configuration of info icon label options.
  final Visibility? visibility;

  SheetControlInfoIconLabelOptions({
    this.infoIconText,
    this.visibility,
  });

  factory SheetControlInfoIconLabelOptions.fromJson(Map<String, dynamic> json) {
    return SheetControlInfoIconLabelOptions(
      infoIconText: json['InfoIconText'] as String?,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final infoIconText = this.infoIconText;
    final visibility = this.visibility;
    return {
      if (infoIconText != null) 'InfoIconText': infoIconText,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// A grid layout to define the placement of sheet control.
class SheetControlLayout {
  /// The configuration that determines the elements and canvas size options of
  /// sheet control.
  final SheetControlLayoutConfiguration configuration;

  SheetControlLayout({
    required this.configuration,
  });

  factory SheetControlLayout.fromJson(Map<String, dynamic> json) {
    return SheetControlLayout(
      configuration: SheetControlLayoutConfiguration.fromJson(
          json['Configuration'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final configuration = this.configuration;
    return {
      'Configuration': configuration,
    };
  }
}

/// The configuration that determines the elements and canvas size options of
/// sheet control.
class SheetControlLayoutConfiguration {
  /// The configuration that determines the elements and canvas size options of
  /// sheet control.
  final GridLayoutConfiguration? gridLayout;

  SheetControlLayoutConfiguration({
    this.gridLayout,
  });

  factory SheetControlLayoutConfiguration.fromJson(Map<String, dynamic> json) {
    return SheetControlLayoutConfiguration(
      gridLayout: json['GridLayout'] != null
          ? GridLayoutConfiguration.fromJson(
              json['GridLayout'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final gridLayout = this.gridLayout;
    return {
      if (gridLayout != null) 'GridLayout': gridLayout,
    };
  }
}

enum SheetControlListType {
  multiSelect,
  singleSelect,
}

extension SheetControlListTypeValueExtension on SheetControlListType {
  String toValue() {
    switch (this) {
      case SheetControlListType.multiSelect:
        return 'MULTI_SELECT';
      case SheetControlListType.singleSelect:
        return 'SINGLE_SELECT';
    }
  }
}

extension SheetControlListTypeFromString on String {
  SheetControlListType toSheetControlListType() {
    switch (this) {
      case 'MULTI_SELECT':
        return SheetControlListType.multiSelect;
      case 'SINGLE_SELECT':
        return SheetControlListType.singleSelect;
    }
    throw Exception('$this is not known in enum SheetControlListType');
  }
}

enum SheetControlSliderType {
  singlePoint,
  range,
}

extension SheetControlSliderTypeValueExtension on SheetControlSliderType {
  String toValue() {
    switch (this) {
      case SheetControlSliderType.singlePoint:
        return 'SINGLE_POINT';
      case SheetControlSliderType.range:
        return 'RANGE';
    }
  }
}

extension SheetControlSliderTypeFromString on String {
  SheetControlSliderType toSheetControlSliderType() {
    switch (this) {
      case 'SINGLE_POINT':
        return SheetControlSliderType.singlePoint;
      case 'RANGE':
        return SheetControlSliderType.range;
    }
    throw Exception('$this is not known in enum SheetControlSliderType');
  }
}

/// Sheet controls option.
class SheetControlsOption {
  /// Visibility state.
  final DashboardUIState? visibilityState;

  SheetControlsOption({
    this.visibilityState,
  });

  factory SheetControlsOption.fromJson(Map<String, dynamic> json) {
    return SheetControlsOption(
      visibilityState:
          (json['VisibilityState'] as String?)?.toDashboardUIState(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibilityState = this.visibilityState;
    return {
      if (visibilityState != null) 'VisibilityState': visibilityState.toValue(),
    };
  }
}

/// A sheet is an object that contains a set of visuals that are viewed together
/// on one page in a paginated report. Every analysis and dashboard must contain
/// at least one sheet.
class SheetDefinition {
  /// The unique identifier of a sheet.
  final String sheetId;

  /// The layout content type of the sheet. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>PAGINATED</code>: Creates a sheet for a paginated report.
  /// </li>
  /// <li>
  /// <code>INTERACTIVE</code>: Creates a sheet for an interactive dashboard.
  /// </li>
  /// </ul>
  final SheetContentType? contentType;

  /// A description of the sheet.
  final String? description;

  /// The list of filter controls that are on a sheet.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/filter-controls.html">Adding
  /// filter controls to analysis sheets</a> in the <i>Amazon QuickSight User
  /// Guide</i>.
  final List<FilterControl>? filterControls;

  /// Layouts define how the components of a sheet are arranged.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/types-of-layout.html">Types
  /// of layout</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<Layout>? layouts;

  /// The name of the sheet. This name is displayed on the sheet's tab in the
  /// Amazon QuickSight console.
  final String? name;

  /// The list of parameter controls that are on a sheet.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-controls.html">Using
  /// a Control with a Parameter in Amazon QuickSight</a> in the <i>Amazon
  /// QuickSight User Guide</i>.
  final List<ParameterControl>? parameterControls;

  /// The control layouts of the sheet.
  final List<SheetControlLayout>? sheetControlLayouts;

  /// The text boxes that are on a sheet.
  final List<SheetTextBox>? textBoxes;

  /// The title of the sheet.
  final String? title;

  /// A list of the visuals that are on a sheet. Visual placement is determined by
  /// the layout of the sheet.
  final List<Visual>? visuals;

  SheetDefinition({
    required this.sheetId,
    this.contentType,
    this.description,
    this.filterControls,
    this.layouts,
    this.name,
    this.parameterControls,
    this.sheetControlLayouts,
    this.textBoxes,
    this.title,
    this.visuals,
  });

  factory SheetDefinition.fromJson(Map<String, dynamic> json) {
    return SheetDefinition(
      sheetId: json['SheetId'] as String,
      contentType: (json['ContentType'] as String?)?.toSheetContentType(),
      description: json['Description'] as String?,
      filterControls: (json['FilterControls'] as List?)
          ?.whereNotNull()
          .map((e) => FilterControl.fromJson(e as Map<String, dynamic>))
          .toList(),
      layouts: (json['Layouts'] as List?)
          ?.whereNotNull()
          .map((e) => Layout.fromJson(e as Map<String, dynamic>))
          .toList(),
      name: json['Name'] as String?,
      parameterControls: (json['ParameterControls'] as List?)
          ?.whereNotNull()
          .map((e) => ParameterControl.fromJson(e as Map<String, dynamic>))
          .toList(),
      sheetControlLayouts: (json['SheetControlLayouts'] as List?)
          ?.whereNotNull()
          .map((e) => SheetControlLayout.fromJson(e as Map<String, dynamic>))
          .toList(),
      textBoxes: (json['TextBoxes'] as List?)
          ?.whereNotNull()
          .map((e) => SheetTextBox.fromJson(e as Map<String, dynamic>))
          .toList(),
      title: json['Title'] as String?,
      visuals: (json['Visuals'] as List?)
          ?.whereNotNull()
          .map((e) => Visual.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final sheetId = this.sheetId;
    final contentType = this.contentType;
    final description = this.description;
    final filterControls = this.filterControls;
    final layouts = this.layouts;
    final name = this.name;
    final parameterControls = this.parameterControls;
    final sheetControlLayouts = this.sheetControlLayouts;
    final textBoxes = this.textBoxes;
    final title = this.title;
    final visuals = this.visuals;
    return {
      'SheetId': sheetId,
      if (contentType != null) 'ContentType': contentType.toValue(),
      if (description != null) 'Description': description,
      if (filterControls != null) 'FilterControls': filterControls,
      if (layouts != null) 'Layouts': layouts,
      if (name != null) 'Name': name,
      if (parameterControls != null) 'ParameterControls': parameterControls,
      if (sheetControlLayouts != null)
        'SheetControlLayouts': sheetControlLayouts,
      if (textBoxes != null) 'TextBoxes': textBoxes,
      if (title != null) 'Title': title,
      if (visuals != null) 'Visuals': visuals,
    };
  }
}

/// The override configuration of the rendering rules of a sheet.
class SheetElementConfigurationOverrides {
  /// Determines whether or not the overrides are visible. Choose one of the
  /// following options:
  ///
  /// <ul>
  /// <li>
  /// <code>VISIBLE</code>
  /// </li>
  /// <li>
  /// <code>HIDDEN</code>
  /// </li>
  /// </ul>
  final Visibility? visibility;

  SheetElementConfigurationOverrides({
    this.visibility,
  });

  factory SheetElementConfigurationOverrides.fromJson(
      Map<String, dynamic> json) {
    return SheetElementConfigurationOverrides(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The rendering rules of a sheet that uses a free-form layout.
class SheetElementRenderingRule {
  /// The override configuration of the rendering rules of a sheet.
  final SheetElementConfigurationOverrides configurationOverrides;

  /// The expression of the rendering rules of a sheet.
  final String expression;

  SheetElementRenderingRule({
    required this.configurationOverrides,
    required this.expression,
  });

  factory SheetElementRenderingRule.fromJson(Map<String, dynamic> json) {
    return SheetElementRenderingRule(
      configurationOverrides: SheetElementConfigurationOverrides.fromJson(
          json['ConfigurationOverrides'] as Map<String, dynamic>),
      expression: json['Expression'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final configurationOverrides = this.configurationOverrides;
    final expression = this.expression;
    return {
      'ConfigurationOverrides': configurationOverrides,
      'Expression': expression,
    };
  }
}

/// The sheet layout maximization options of a dashbaord.
class SheetLayoutElementMaximizationOption {
  /// The status of the sheet layout maximization options of a dashbaord.
  final DashboardBehavior? availabilityStatus;

  SheetLayoutElementMaximizationOption({
    this.availabilityStatus,
  });

  factory SheetLayoutElementMaximizationOption.fromJson(
      Map<String, dynamic> json) {
    return SheetLayoutElementMaximizationOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// The theme display options for sheets.
class SheetStyle {
  /// The display options for tiles.
  final TileStyle? tile;

  /// The layout options for tiles.
  final TileLayoutStyle? tileLayout;

  SheetStyle({
    this.tile,
    this.tileLayout,
  });

  factory SheetStyle.fromJson(Map<String, dynamic> json) {
    return SheetStyle(
      tile: json['Tile'] != null
          ? TileStyle.fromJson(json['Tile'] as Map<String, dynamic>)
          : null,
      tileLayout: json['TileLayout'] != null
          ? TileLayoutStyle.fromJson(json['TileLayout'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final tile = this.tile;
    final tileLayout = this.tileLayout;
    return {
      if (tile != null) 'Tile': tile,
      if (tileLayout != null) 'TileLayout': tileLayout,
    };
  }
}

/// A text box.
class SheetTextBox {
  /// The unique identifier for a text box. This identifier must be unique within
  /// the context of a dashboard, template, or analysis. Two dashboards, analyses,
  /// or templates can have text boxes that share identifiers.
  final String sheetTextBoxId;

  /// The content that is displayed in the text box.
  final String? content;

  SheetTextBox({
    required this.sheetTextBoxId,
    this.content,
  });

  factory SheetTextBox.fromJson(Map<String, dynamic> json) {
    return SheetTextBox(
      sheetTextBoxId: json['SheetTextBoxId'] as String,
      content: json['Content'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final sheetTextBoxId = this.sheetTextBoxId;
    final content = this.content;
    return {
      'SheetTextBoxId': sheetTextBoxId,
      if (content != null) 'Content': content,
    };
  }
}

/// The filter that is applied to the options.
class SheetVisualScopingConfiguration {
  /// The scope of the applied entities. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VISUALS</code>
  /// </li>
  /// <li>
  /// <code>SELECTED_VISUALS</code>
  /// </li>
  /// </ul>
  final FilterVisualScope scope;

  /// The selected sheet that the filter is applied to.
  final String sheetId;

  /// The selected visuals that the filter is applied to.
  final List<String>? visualIds;

  SheetVisualScopingConfiguration({
    required this.scope,
    required this.sheetId,
    this.visualIds,
  });

  factory SheetVisualScopingConfiguration.fromJson(Map<String, dynamic> json) {
    return SheetVisualScopingConfiguration(
      scope: (json['Scope'] as String).toFilterVisualScope(),
      sheetId: json['SheetId'] as String,
      visualIds: (json['VisualIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final scope = this.scope;
    final sheetId = this.sheetId;
    final visualIds = this.visualIds;
    return {
      'Scope': scope.toValue(),
      'SheetId': sheetId,
      if (visualIds != null) 'VisualIds': visualIds,
    };
  }
}

/// The text format for the title.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class ShortFormatText {
  /// Plain text format.
  final String? plainText;

  /// Rich text. Examples of rich text include bold, underline, and italics.
  final String? richText;

  ShortFormatText({
    this.plainText,
    this.richText,
  });

  factory ShortFormatText.fromJson(Map<String, dynamic> json) {
    return ShortFormatText(
      plainText: json['PlainText'] as String?,
      richText: json['RichText'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final plainText = this.plainText;
    final richText = this.richText;
    return {
      if (plainText != null) 'PlainText': plainText,
      if (richText != null) 'RichText': richText,
    };
  }
}

/// A <code>SignupResponse</code> object that contains a summary of a newly
/// created account.
class SignupResponse {
  /// A Boolean that is <code>TRUE</code> if the Amazon QuickSight uses IAM as an
  /// authentication method.
  final bool? iAMUser;

  /// The name of your Amazon QuickSight account.
  final String? accountName;

  /// The type of Active Directory that is being used to authenticate the Amazon
  /// QuickSight account. Valid values are <code>SIMPLE_AD</code>,
  /// <code>AD_CONNECTOR</code>, and <code>MICROSOFT_AD</code>.
  final String? directoryType;

  /// The user login name for your Amazon QuickSight account.
  final String? userLoginName;

  SignupResponse({
    this.iAMUser,
    this.accountName,
    this.directoryType,
    this.userLoginName,
  });

  factory SignupResponse.fromJson(Map<String, dynamic> json) {
    return SignupResponse(
      iAMUser: json['IAMUser'] as bool?,
      accountName: json['accountName'] as String?,
      directoryType: json['directoryType'] as String?,
      userLoginName: json['userLoginName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final iAMUser = this.iAMUser;
    final accountName = this.accountName;
    final directoryType = this.directoryType;
    final userLoginName = this.userLoginName;
    return {
      if (iAMUser != null) 'IAMUser': iAMUser,
      if (accountName != null) 'accountName': accountName,
      if (directoryType != null) 'directoryType': directoryType,
      if (userLoginName != null) 'userLoginName': userLoginName,
    };
  }
}

enum SimpleAttributeAggregationFunction {
  uniqueValue,
}

extension SimpleAttributeAggregationFunctionValueExtension
    on SimpleAttributeAggregationFunction {
  String toValue() {
    switch (this) {
      case SimpleAttributeAggregationFunction.uniqueValue:
        return 'UNIQUE_VALUE';
    }
  }
}

extension SimpleAttributeAggregationFunctionFromString on String {
  SimpleAttributeAggregationFunction toSimpleAttributeAggregationFunction() {
    switch (this) {
      case 'UNIQUE_VALUE':
        return SimpleAttributeAggregationFunction.uniqueValue;
    }
    throw Exception(
        '$this is not known in enum SimpleAttributeAggregationFunction');
  }
}

/// The simple cluster marker of the cluster marker.
class SimpleClusterMarker {
  /// The color of the simple cluster marker.
  final String? color;

  SimpleClusterMarker({
    this.color,
  });

  factory SimpleClusterMarker.fromJson(Map<String, dynamic> json) {
    return SimpleClusterMarker(
      color: json['Color'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    return {
      if (color != null) 'Color': color,
    };
  }
}

enum SimpleNumericalAggregationFunction {
  sum,
  average,
  min,
  max,
  count,
  distinctCount,
  $var,
  varp,
  stdev,
  stdevp,
  median,
}

extension SimpleNumericalAggregationFunctionValueExtension
    on SimpleNumericalAggregationFunction {
  String toValue() {
    switch (this) {
      case SimpleNumericalAggregationFunction.sum:
        return 'SUM';
      case SimpleNumericalAggregationFunction.average:
        return 'AVERAGE';
      case SimpleNumericalAggregationFunction.min:
        return 'MIN';
      case SimpleNumericalAggregationFunction.max:
        return 'MAX';
      case SimpleNumericalAggregationFunction.count:
        return 'COUNT';
      case SimpleNumericalAggregationFunction.distinctCount:
        return 'DISTINCT_COUNT';
      case SimpleNumericalAggregationFunction.$var:
        return 'VAR';
      case SimpleNumericalAggregationFunction.varp:
        return 'VARP';
      case SimpleNumericalAggregationFunction.stdev:
        return 'STDEV';
      case SimpleNumericalAggregationFunction.stdevp:
        return 'STDEVP';
      case SimpleNumericalAggregationFunction.median:
        return 'MEDIAN';
    }
  }
}

extension SimpleNumericalAggregationFunctionFromString on String {
  SimpleNumericalAggregationFunction toSimpleNumericalAggregationFunction() {
    switch (this) {
      case 'SUM':
        return SimpleNumericalAggregationFunction.sum;
      case 'AVERAGE':
        return SimpleNumericalAggregationFunction.average;
      case 'MIN':
        return SimpleNumericalAggregationFunction.min;
      case 'MAX':
        return SimpleNumericalAggregationFunction.max;
      case 'COUNT':
        return SimpleNumericalAggregationFunction.count;
      case 'DISTINCT_COUNT':
        return SimpleNumericalAggregationFunction.distinctCount;
      case 'VAR':
        return SimpleNumericalAggregationFunction.$var;
      case 'VARP':
        return SimpleNumericalAggregationFunction.varp;
      case 'STDEV':
        return SimpleNumericalAggregationFunction.stdev;
      case 'STDEVP':
        return SimpleNumericalAggregationFunction.stdevp;
      case 'MEDIAN':
        return SimpleNumericalAggregationFunction.median;
    }
    throw Exception(
        '$this is not known in enum SimpleNumericalAggregationFunction');
  }
}

enum SimpleTotalAggregationFunction {
  $default,
  sum,
  average,
  min,
  max,
  none,
}

extension SimpleTotalAggregationFunctionValueExtension
    on SimpleTotalAggregationFunction {
  String toValue() {
    switch (this) {
      case SimpleTotalAggregationFunction.$default:
        return 'DEFAULT';
      case SimpleTotalAggregationFunction.sum:
        return 'SUM';
      case SimpleTotalAggregationFunction.average:
        return 'AVERAGE';
      case SimpleTotalAggregationFunction.min:
        return 'MIN';
      case SimpleTotalAggregationFunction.max:
        return 'MAX';
      case SimpleTotalAggregationFunction.none:
        return 'NONE';
    }
  }
}

extension SimpleTotalAggregationFunctionFromString on String {
  SimpleTotalAggregationFunction toSimpleTotalAggregationFunction() {
    switch (this) {
      case 'DEFAULT':
        return SimpleTotalAggregationFunction.$default;
      case 'SUM':
        return SimpleTotalAggregationFunction.sum;
      case 'AVERAGE':
        return SimpleTotalAggregationFunction.average;
      case 'MIN':
        return SimpleTotalAggregationFunction.min;
      case 'MAX':
        return SimpleTotalAggregationFunction.max;
      case 'NONE':
        return SimpleTotalAggregationFunction.none;
    }
    throw Exception(
        '$this is not known in enum SimpleTotalAggregationFunction');
  }
}

/// The settings of a chart's single axis configuration.
class SingleAxisOptions {
  /// The Y axis options of a single axis configuration.
  final YAxisOptions? yAxisOptions;

  SingleAxisOptions({
    this.yAxisOptions,
  });

  factory SingleAxisOptions.fromJson(Map<String, dynamic> json) {
    return SingleAxisOptions(
      yAxisOptions: json['YAxisOptions'] != null
          ? YAxisOptions.fromJson(json['YAxisOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final yAxisOptions = this.yAxisOptions;
    return {
      if (yAxisOptions != null) 'YAxisOptions': yAxisOptions,
    };
  }
}

enum SingleYAxisOption {
  primaryYAxis,
}

extension SingleYAxisOptionValueExtension on SingleYAxisOption {
  String toValue() {
    switch (this) {
      case SingleYAxisOption.primaryYAxis:
        return 'PRIMARY_Y_AXIS';
    }
  }
}

extension SingleYAxisOptionFromString on String {
  SingleYAxisOption toSingleYAxisOption() {
    switch (this) {
      case 'PRIMARY_Y_AXIS':
        return SingleYAxisOption.primaryYAxis;
    }
    throw Exception('$this is not known in enum SingleYAxisOption');
  }
}

/// The display options of a control.
class SliderControlDisplayOptions {
  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  SliderControlDisplayOptions({
    this.infoIconLabelOptions,
    this.titleOptions,
  });

  factory SliderControlDisplayOptions.fromJson(Map<String, dynamic> json) {
    return SliderControlDisplayOptions(
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final titleOptions = this.titleOptions;
    return {
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

enum SmallMultiplesAxisPlacement {
  outside,
  inside,
}

extension SmallMultiplesAxisPlacementValueExtension
    on SmallMultiplesAxisPlacement {
  String toValue() {
    switch (this) {
      case SmallMultiplesAxisPlacement.outside:
        return 'OUTSIDE';
      case SmallMultiplesAxisPlacement.inside:
        return 'INSIDE';
    }
  }
}

extension SmallMultiplesAxisPlacementFromString on String {
  SmallMultiplesAxisPlacement toSmallMultiplesAxisPlacement() {
    switch (this) {
      case 'OUTSIDE':
        return SmallMultiplesAxisPlacement.outside;
      case 'INSIDE':
        return SmallMultiplesAxisPlacement.inside;
    }
    throw Exception('$this is not known in enum SmallMultiplesAxisPlacement');
  }
}

/// Configures the properties of a chart's axes that are used by small multiples
/// panels.
class SmallMultiplesAxisProperties {
  /// Defines the placement of the axis. By default, axes are rendered
  /// <code>OUTSIDE</code> of the panels. Axes with <code>INDEPENDENT</code> scale
  /// are rendered <code>INSIDE</code> the panels.
  final SmallMultiplesAxisPlacement? placement;

  /// Determines whether scale of the axes are shared or independent. The default
  /// value is <code>SHARED</code>.
  final SmallMultiplesAxisScale? scale;

  SmallMultiplesAxisProperties({
    this.placement,
    this.scale,
  });

  factory SmallMultiplesAxisProperties.fromJson(Map<String, dynamic> json) {
    return SmallMultiplesAxisProperties(
      placement:
          (json['Placement'] as String?)?.toSmallMultiplesAxisPlacement(),
      scale: (json['Scale'] as String?)?.toSmallMultiplesAxisScale(),
    );
  }

  Map<String, dynamic> toJson() {
    final placement = this.placement;
    final scale = this.scale;
    return {
      if (placement != null) 'Placement': placement.toValue(),
      if (scale != null) 'Scale': scale.toValue(),
    };
  }
}

enum SmallMultiplesAxisScale {
  shared,
  independent,
}

extension SmallMultiplesAxisScaleValueExtension on SmallMultiplesAxisScale {
  String toValue() {
    switch (this) {
      case SmallMultiplesAxisScale.shared:
        return 'SHARED';
      case SmallMultiplesAxisScale.independent:
        return 'INDEPENDENT';
    }
  }
}

extension SmallMultiplesAxisScaleFromString on String {
  SmallMultiplesAxisScale toSmallMultiplesAxisScale() {
    switch (this) {
      case 'SHARED':
        return SmallMultiplesAxisScale.shared;
      case 'INDEPENDENT':
        return SmallMultiplesAxisScale.independent;
    }
    throw Exception('$this is not known in enum SmallMultiplesAxisScale');
  }
}

/// Options that determine the layout and display options of a chart's small
/// multiples.
class SmallMultiplesOptions {
  /// Sets the maximum number of visible columns to display in the grid of small
  /// multiples panels.
  ///
  /// The default is <code>Auto</code>, which automatically adjusts the columns in
  /// the grid to fit the overall layout and size of the given chart.
  final int? maxVisibleColumns;

  /// Sets the maximum number of visible rows to display in the grid of small
  /// multiples panels.
  ///
  /// The default value is <code>Auto</code>, which automatically adjusts the rows
  /// in the grid to fit the overall layout and size of the given chart.
  final int? maxVisibleRows;

  /// Configures the display options for each small multiples panel.
  final PanelConfiguration? panelConfiguration;

  /// The properties of a small multiples X axis.
  final SmallMultiplesAxisProperties? xAxis;

  /// The properties of a small multiples Y axis.
  final SmallMultiplesAxisProperties? yAxis;

  SmallMultiplesOptions({
    this.maxVisibleColumns,
    this.maxVisibleRows,
    this.panelConfiguration,
    this.xAxis,
    this.yAxis,
  });

  factory SmallMultiplesOptions.fromJson(Map<String, dynamic> json) {
    return SmallMultiplesOptions(
      maxVisibleColumns: json['MaxVisibleColumns'] as int?,
      maxVisibleRows: json['MaxVisibleRows'] as int?,
      panelConfiguration: json['PanelConfiguration'] != null
          ? PanelConfiguration.fromJson(
              json['PanelConfiguration'] as Map<String, dynamic>)
          : null,
      xAxis: json['XAxis'] != null
          ? SmallMultiplesAxisProperties.fromJson(
              json['XAxis'] as Map<String, dynamic>)
          : null,
      yAxis: json['YAxis'] != null
          ? SmallMultiplesAxisProperties.fromJson(
              json['YAxis'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final maxVisibleColumns = this.maxVisibleColumns;
    final maxVisibleRows = this.maxVisibleRows;
    final panelConfiguration = this.panelConfiguration;
    final xAxis = this.xAxis;
    final yAxis = this.yAxis;
    return {
      if (maxVisibleColumns != null) 'MaxVisibleColumns': maxVisibleColumns,
      if (maxVisibleRows != null) 'MaxVisibleRows': maxVisibleRows,
      if (panelConfiguration != null) 'PanelConfiguration': panelConfiguration,
      if (xAxis != null) 'XAxis': xAxis,
      if (yAxis != null) 'YAxis': yAxis,
    };
  }
}

/// A structure that contains information on the anonymous user configuration.
class SnapshotAnonymousUser {
  /// The tags to be used for row-level security (RLS). Make sure that the
  /// relevant datasets have RLS tags configured before you start a snapshot
  /// export job. You can configure the RLS tags of a dataset with a
  /// <code>DataSet$RowLevelPermissionTagConfiguration</code> API call.
  ///
  /// These are not the tags that are used for Amazon Web Services resource
  /// tagging. For more information on row level security in Amazon QuickSight,
  /// see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/quicksight-dev-rls-tags.html">Using
  /// Row-Level Security (RLS) with Tags</a>in the <i>Amazon QuickSight User
  /// Guide</i>.
  final List<SessionTag>? rowLevelPermissionTags;

  SnapshotAnonymousUser({
    this.rowLevelPermissionTags,
  });

  Map<String, dynamic> toJson() {
    final rowLevelPermissionTags = this.rowLevelPermissionTags;
    return {
      if (rowLevelPermissionTags != null)
        'RowLevelPermissionTags': rowLevelPermissionTags,
    };
  }
}

/// Use this structure to redact sensitive information that you provide about an
/// anonymous user from the snapshot.
class SnapshotAnonymousUserRedacted {
  /// The tag keys for the <code>RowLevelPermissionTags</code>.
  final List<String>? rowLevelPermissionTagKeys;

  SnapshotAnonymousUserRedacted({
    this.rowLevelPermissionTagKeys,
  });

  factory SnapshotAnonymousUserRedacted.fromJson(Map<String, dynamic> json) {
    return SnapshotAnonymousUserRedacted(
      rowLevelPermissionTagKeys: (json['RowLevelPermissionTagKeys'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final rowLevelPermissionTagKeys = this.rowLevelPermissionTagKeys;
    return {
      if (rowLevelPermissionTagKeys != null)
        'RowLevelPermissionTagKeys': rowLevelPermissionTagKeys,
    };
  }
}

/// Describes the configuration of the dashboard snapshot.
class SnapshotConfiguration {
  /// A list of <code>SnapshotJobResultFileGroup</code> objects that contain
  /// information about the snapshot that is generated. This list can hold a
  /// maximum of 6 <code>FileGroup</code> configurations.
  final List<SnapshotFileGroup> fileGroups;

  /// A structure that contains information on the Amazon S3 bucket that the
  /// generated snapshot is stored in.
  final SnapshotDestinationConfiguration? destinationConfiguration;
  final Parameters? parameters;

  SnapshotConfiguration({
    required this.fileGroups,
    this.destinationConfiguration,
    this.parameters,
  });

  factory SnapshotConfiguration.fromJson(Map<String, dynamic> json) {
    return SnapshotConfiguration(
      fileGroups: (json['FileGroups'] as List)
          .whereNotNull()
          .map((e) => SnapshotFileGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      destinationConfiguration: json['DestinationConfiguration'] != null
          ? SnapshotDestinationConfiguration.fromJson(
              json['DestinationConfiguration'] as Map<String, dynamic>)
          : null,
      parameters: json['Parameters'] != null
          ? Parameters.fromJson(json['Parameters'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fileGroups = this.fileGroups;
    final destinationConfiguration = this.destinationConfiguration;
    final parameters = this.parameters;
    return {
      'FileGroups': fileGroups,
      if (destinationConfiguration != null)
        'DestinationConfiguration': destinationConfiguration,
      if (parameters != null) 'Parameters': parameters,
    };
  }
}

/// A structure that contains information on the Amazon S3 destinations of the
/// generated snapshot.
class SnapshotDestinationConfiguration {
  /// A list of <code>SnapshotS3DestinationConfiguration</code> objects that
  /// contain Amazon S3 destination configurations. This structure can hold a
  /// maximum of 1 <code>S3DestinationConfiguration</code>.
  final List<SnapshotS3DestinationConfiguration>? s3Destinations;

  SnapshotDestinationConfiguration({
    this.s3Destinations,
  });

  factory SnapshotDestinationConfiguration.fromJson(Map<String, dynamic> json) {
    return SnapshotDestinationConfiguration(
      s3Destinations: (json['S3Destinations'] as List?)
          ?.whereNotNull()
          .map((e) => SnapshotS3DestinationConfiguration.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final s3Destinations = this.s3Destinations;
    return {
      if (s3Destinations != null) 'S3Destinations': s3Destinations,
    };
  }
}

/// A structure that contains the information for the snapshot that you want to
/// generate. This information is provided by you when you start a new snapshot
/// job.
class SnapshotFile {
  /// The format of the snapshot file to be generated. You can choose between
  /// <code>CSV</code>, <code>Excel</code>, or <code>PDF</code>.
  final SnapshotFileFormatType formatType;

  /// A list of <code>SnapshotFileSheetSelection</code> objects that contain
  /// information on the dashboard sheet that is exported. These objects provide
  /// information about the snapshot artifacts that are generated during the job.
  /// This structure can hold a maximum of 5 CSV configurations, 5 Excel
  /// configurations, or 1 configuration for PDF.
  final List<SnapshotFileSheetSelection> sheetSelections;

  SnapshotFile({
    required this.formatType,
    required this.sheetSelections,
  });

  factory SnapshotFile.fromJson(Map<String, dynamic> json) {
    return SnapshotFile(
      formatType: (json['FormatType'] as String).toSnapshotFileFormatType(),
      sheetSelections: (json['SheetSelections'] as List)
          .whereNotNull()
          .map((e) =>
              SnapshotFileSheetSelection.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final formatType = this.formatType;
    final sheetSelections = this.sheetSelections;
    return {
      'FormatType': formatType.toValue(),
      'SheetSelections': sheetSelections,
    };
  }
}

enum SnapshotFileFormatType {
  csv,
  pdf,
  excel,
}

extension SnapshotFileFormatTypeValueExtension on SnapshotFileFormatType {
  String toValue() {
    switch (this) {
      case SnapshotFileFormatType.csv:
        return 'CSV';
      case SnapshotFileFormatType.pdf:
        return 'PDF';
      case SnapshotFileFormatType.excel:
        return 'EXCEL';
    }
  }
}

extension SnapshotFileFormatTypeFromString on String {
  SnapshotFileFormatType toSnapshotFileFormatType() {
    switch (this) {
      case 'CSV':
        return SnapshotFileFormatType.csv;
      case 'PDF':
        return SnapshotFileFormatType.pdf;
      case 'EXCEL':
        return SnapshotFileFormatType.excel;
    }
    throw Exception('$this is not known in enum SnapshotFileFormatType');
  }
}

/// A structure that contains the information on the snapshot files.
class SnapshotFileGroup {
  /// A list of <code>SnapshotFile</code> objects that contain the information on
  /// the snapshot files that need to be generated. This structure can hold 1
  /// configuration at a time.
  final List<SnapshotFile>? files;

  SnapshotFileGroup({
    this.files,
  });

  factory SnapshotFileGroup.fromJson(Map<String, dynamic> json) {
    return SnapshotFileGroup(
      files: (json['Files'] as List?)
          ?.whereNotNull()
          .map((e) => SnapshotFile.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final files = this.files;
    return {
      if (files != null) 'Files': files,
    };
  }
}

/// A structure that contains information that identifies the snapshot that
/// needs to be generated.
class SnapshotFileSheetSelection {
  /// The selection scope of the visuals on a sheet of a dashboard that you are
  /// generating a snapthot of. You can choose one of the following options.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VISUALS</code> - Selects all visuals that are on the sheet. This
  /// value is required if the snapshot is a PDF.
  /// </li>
  /// <li>
  /// <code>SELECTED_VISUALS</code> - Select the visual that you want to add to
  /// the snapshot. This value is required if the snapshot is a CSV or Excel
  /// workbook.
  /// </li>
  /// </ul>
  final SnapshotFileSheetSelectionScope selectionScope;

  /// The sheet ID of the dashboard to generate the snapshot artifact from. This
  /// value is required for CSV, Excel, and PDF format types.
  final String sheetId;

  /// A structure that lists the IDs of the visuals in the selected sheet.
  /// Supported visual types are table, pivot table visuals. This value is
  /// required if you are generating a CSV or Excel workbook. This value supports
  /// a maximum of 1 visual ID for CSV and 5 visual IDs across up to 5 sheet
  /// selections for Excel. If you are generating an Excel workbook, the order of
  /// the visual IDs provided in this structure determines the order of the
  /// worksheets in the Excel file.
  final List<String>? visualIds;

  SnapshotFileSheetSelection({
    required this.selectionScope,
    required this.sheetId,
    this.visualIds,
  });

  factory SnapshotFileSheetSelection.fromJson(Map<String, dynamic> json) {
    return SnapshotFileSheetSelection(
      selectionScope: (json['SelectionScope'] as String)
          .toSnapshotFileSheetSelectionScope(),
      sheetId: json['SheetId'] as String,
      visualIds: (json['VisualIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final selectionScope = this.selectionScope;
    final sheetId = this.sheetId;
    final visualIds = this.visualIds;
    return {
      'SelectionScope': selectionScope.toValue(),
      'SheetId': sheetId,
      if (visualIds != null) 'VisualIds': visualIds,
    };
  }
}

enum SnapshotFileSheetSelectionScope {
  allVisuals,
  selectedVisuals,
}

extension SnapshotFileSheetSelectionScopeValueExtension
    on SnapshotFileSheetSelectionScope {
  String toValue() {
    switch (this) {
      case SnapshotFileSheetSelectionScope.allVisuals:
        return 'ALL_VISUALS';
      case SnapshotFileSheetSelectionScope.selectedVisuals:
        return 'SELECTED_VISUALS';
    }
  }
}

extension SnapshotFileSheetSelectionScopeFromString on String {
  SnapshotFileSheetSelectionScope toSnapshotFileSheetSelectionScope() {
    switch (this) {
      case 'ALL_VISUALS':
        return SnapshotFileSheetSelectionScope.allVisuals;
      case 'SELECTED_VISUALS':
        return SnapshotFileSheetSelectionScope.selectedVisuals;
    }
    throw Exception(
        '$this is not known in enum SnapshotFileSheetSelectionScope');
  }
}

/// An object that contains information on the error that caused the snapshot
/// job to fail.
class SnapshotJobErrorInfo {
  /// The error message.
  final String? errorMessage;

  /// The error type.
  final String? errorType;

  SnapshotJobErrorInfo({
    this.errorMessage,
    this.errorType,
  });

  factory SnapshotJobErrorInfo.fromJson(Map<String, dynamic> json) {
    return SnapshotJobErrorInfo(
      errorMessage: json['ErrorMessage'] as String?,
      errorType: json['ErrorType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorMessage = this.errorMessage;
    final errorType = this.errorType;
    return {
      if (errorMessage != null) 'ErrorMessage': errorMessage,
      if (errorType != null) 'ErrorType': errorType,
    };
  }
}

/// An object that provides information on the result of a snapshot job. This
/// object provides information about the job, the job status, and the location
/// of the generated file.
class SnapshotJobResult {
  /// A list of <code>AnonymousUserSnapshotJobResult</code> objects that contain
  /// information on anonymous users and their user configurations. This data
  /// provided by you when you make a <code>StartDashboardSnapshotJob</code> API
  /// call.
  final List<AnonymousUserSnapshotJobResult>? anonymousUsers;

  SnapshotJobResult({
    this.anonymousUsers,
  });

  factory SnapshotJobResult.fromJson(Map<String, dynamic> json) {
    return SnapshotJobResult(
      anonymousUsers: (json['AnonymousUsers'] as List?)
          ?.whereNotNull()
          .map((e) => AnonymousUserSnapshotJobResult.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final anonymousUsers = this.anonymousUsers;
    return {
      if (anonymousUsers != null) 'AnonymousUsers': anonymousUsers,
    };
  }
}

/// Information on the error that caused the snapshot job to fail.
class SnapshotJobResultErrorInfo {
  /// The error message.
  final String? errorMessage;

  /// The error type.
  final String? errorType;

  SnapshotJobResultErrorInfo({
    this.errorMessage,
    this.errorType,
  });

  factory SnapshotJobResultErrorInfo.fromJson(Map<String, dynamic> json) {
    return SnapshotJobResultErrorInfo(
      errorMessage: json['ErrorMessage'] as String?,
      errorType: json['ErrorType'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorMessage = this.errorMessage;
    final errorType = this.errorType;
    return {
      if (errorMessage != null) 'ErrorMessage': errorMessage,
      if (errorType != null) 'ErrorType': errorType,
    };
  }
}

/// A structure that contains information on the generated snapshot file groups.
class SnapshotJobResultFileGroup {
  /// A list of <code>SnapshotFile</code> objects.
  final List<SnapshotFile>? files;

  /// A list of <code>SnapshotJobS3Result</code> objects.
  final List<SnapshotJobS3Result>? s3Results;

  SnapshotJobResultFileGroup({
    this.files,
    this.s3Results,
  });

  factory SnapshotJobResultFileGroup.fromJson(Map<String, dynamic> json) {
    return SnapshotJobResultFileGroup(
      files: (json['Files'] as List?)
          ?.whereNotNull()
          .map((e) => SnapshotFile.fromJson(e as Map<String, dynamic>))
          .toList(),
      s3Results: (json['S3Results'] as List?)
          ?.whereNotNull()
          .map((e) => SnapshotJobS3Result.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final files = this.files;
    final s3Results = this.s3Results;
    return {
      if (files != null) 'Files': files,
      if (s3Results != null) 'S3Results': s3Results,
    };
  }
}

/// The Amazon S3 result from the snapshot job. The result includes the
/// <code>DestinationConfiguration</code> and the Amazon S3 Uri. If an error
/// occured during the job, the result returns information on the error.
class SnapshotJobS3Result {
  /// An array of error records that describe any failures that occur while the
  /// dashboard snapshot job runs.
  final List<SnapshotJobResultErrorInfo>? errorInfo;

  /// A list of Amazon S3 bucket configurations that are provided when you make a
  /// <code>StartDashboardSnapshotJob</code> API call.
  final SnapshotS3DestinationConfiguration? s3DestinationConfiguration;

  /// The Amazon S3 Uri.
  final String? s3Uri;

  SnapshotJobS3Result({
    this.errorInfo,
    this.s3DestinationConfiguration,
    this.s3Uri,
  });

  factory SnapshotJobS3Result.fromJson(Map<String, dynamic> json) {
    return SnapshotJobS3Result(
      errorInfo: (json['ErrorInfo'] as List?)
          ?.whereNotNull()
          .map((e) =>
              SnapshotJobResultErrorInfo.fromJson(e as Map<String, dynamic>))
          .toList(),
      s3DestinationConfiguration: json['S3DestinationConfiguration'] != null
          ? SnapshotS3DestinationConfiguration.fromJson(
              json['S3DestinationConfiguration'] as Map<String, dynamic>)
          : null,
      s3Uri: json['S3Uri'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final errorInfo = this.errorInfo;
    final s3DestinationConfiguration = this.s3DestinationConfiguration;
    final s3Uri = this.s3Uri;
    return {
      if (errorInfo != null) 'ErrorInfo': errorInfo,
      if (s3DestinationConfiguration != null)
        'S3DestinationConfiguration': s3DestinationConfiguration,
      if (s3Uri != null) 'S3Uri': s3Uri,
    };
  }
}

enum SnapshotJobStatus {
  queued,
  running,
  completed,
  failed,
}

extension SnapshotJobStatusValueExtension on SnapshotJobStatus {
  String toValue() {
    switch (this) {
      case SnapshotJobStatus.queued:
        return 'QUEUED';
      case SnapshotJobStatus.running:
        return 'RUNNING';
      case SnapshotJobStatus.completed:
        return 'COMPLETED';
      case SnapshotJobStatus.failed:
        return 'FAILED';
    }
  }
}

extension SnapshotJobStatusFromString on String {
  SnapshotJobStatus toSnapshotJobStatus() {
    switch (this) {
      case 'QUEUED':
        return SnapshotJobStatus.queued;
      case 'RUNNING':
        return SnapshotJobStatus.running;
      case 'COMPLETED':
        return SnapshotJobStatus.completed;
      case 'FAILED':
        return SnapshotJobStatus.failed;
    }
    throw Exception('$this is not known in enum SnapshotJobStatus');
  }
}

/// A structure that describes the Amazon S3 settings to use to save the
/// generated dashboard snapshot.
class SnapshotS3DestinationConfiguration {
  /// A structure that contains details about the Amazon S3 bucket that the
  /// generated dashboard snapshot is saved in.
  final S3BucketConfiguration bucketConfiguration;

  SnapshotS3DestinationConfiguration({
    required this.bucketConfiguration,
  });

  factory SnapshotS3DestinationConfiguration.fromJson(
      Map<String, dynamic> json) {
    return SnapshotS3DestinationConfiguration(
      bucketConfiguration: S3BucketConfiguration.fromJson(
          json['BucketConfiguration'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final bucketConfiguration = this.bucketConfiguration;
    return {
      'BucketConfiguration': bucketConfiguration,
    };
  }
}

/// A structure that contains information about the users that the dashboard
/// snapshot is generated for.
class SnapshotUserConfiguration {
  /// An array of records that describe the anonymous users that the dashboard
  /// snapshot is generated for.
  final List<SnapshotAnonymousUser>? anonymousUsers;

  SnapshotUserConfiguration({
    this.anonymousUsers,
  });

  Map<String, dynamic> toJson() {
    final anonymousUsers = this.anonymousUsers;
    return {
      if (anonymousUsers != null) 'AnonymousUsers': anonymousUsers,
    };
  }
}

/// A structure that contains information about the users that the dashboard
/// snapshot is generated for. Sensitive user information is excluded.
class SnapshotUserConfigurationRedacted {
  /// An array of records that describe anonymous users that the dashboard
  /// snapshot is generated for. Sensitive user information is excluded.
  final List<SnapshotAnonymousUserRedacted>? anonymousUsers;

  SnapshotUserConfigurationRedacted({
    this.anonymousUsers,
  });

  factory SnapshotUserConfigurationRedacted.fromJson(
      Map<String, dynamic> json) {
    return SnapshotUserConfigurationRedacted(
      anonymousUsers: (json['AnonymousUsers'] as List?)
          ?.whereNotNull()
          .map((e) =>
              SnapshotAnonymousUserRedacted.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final anonymousUsers = this.anonymousUsers;
    return {
      if (anonymousUsers != null) 'AnonymousUsers': anonymousUsers,
    };
  }
}

/// The parameters for Snowflake.
class SnowflakeParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Warehouse.
  final String warehouse;

  SnowflakeParameters({
    required this.database,
    required this.host,
    required this.warehouse,
  });

  factory SnowflakeParameters.fromJson(Map<String, dynamic> json) {
    return SnowflakeParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      warehouse: json['Warehouse'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final warehouse = this.warehouse;
    return {
      'Database': database,
      'Host': host,
      'Warehouse': warehouse,
    };
  }
}

enum SortDirection {
  asc,
  desc,
}

extension SortDirectionValueExtension on SortDirection {
  String toValue() {
    switch (this) {
      case SortDirection.asc:
        return 'ASC';
      case SortDirection.desc:
        return 'DESC';
    }
  }
}

extension SortDirectionFromString on String {
  SortDirection toSortDirection() {
    switch (this) {
      case 'ASC':
        return SortDirection.asc;
      case 'DESC':
        return SortDirection.desc;
    }
    throw Exception('$this is not known in enum SortDirection');
  }
}

/// The configuration of spacing (often a margin or padding).
class Spacing {
  /// Define the bottom spacing.
  final String? bottom;

  /// Define the left spacing.
  final String? left;

  /// Define the right spacing.
  final String? right;

  /// Define the top spacing.
  final String? top;

  Spacing({
    this.bottom,
    this.left,
    this.right,
    this.top,
  });

  factory Spacing.fromJson(Map<String, dynamic> json) {
    return Spacing(
      bottom: json['Bottom'] as String?,
      left: json['Left'] as String?,
      right: json['Right'] as String?,
      top: json['Top'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final bottom = this.bottom;
    final left = this.left;
    final right = this.right;
    final top = this.top;
    return {
      if (bottom != null) 'Bottom': bottom,
      if (left != null) 'Left': left,
      if (right != null) 'Right': right,
      if (top != null) 'Top': top,
    };
  }
}

/// The parameters for Spark.
class SparkParameters {
  /// Host.
  final String host;

  /// Port.
  final int port;

  SparkParameters({
    required this.host,
    required this.port,
  });

  factory SparkParameters.fromJson(Map<String, dynamic> json) {
    return SparkParameters(
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final host = this.host;
    final port = this.port;
    return {
      'Host': host,
      'Port': port,
    };
  }
}

enum SpecialValue {
  empty,
  $null,
  other,
}

extension SpecialValueValueExtension on SpecialValue {
  String toValue() {
    switch (this) {
      case SpecialValue.empty:
        return 'EMPTY';
      case SpecialValue.$null:
        return 'NULL';
      case SpecialValue.other:
        return 'OTHER';
    }
  }
}

extension SpecialValueFromString on String {
  SpecialValue toSpecialValue() {
    switch (this) {
      case 'EMPTY':
        return SpecialValue.empty;
      case 'NULL':
        return SpecialValue.$null;
      case 'OTHER':
        return SpecialValue.other;
    }
    throw Exception('$this is not known in enum SpecialValue');
  }
}

/// The parameters for SQL Server.
class SqlServerParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Port.
  final int port;

  SqlServerParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory SqlServerParameters.fromJson(Map<String, dynamic> json) {
    return SqlServerParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

/// Secure Socket Layer (SSL) properties that apply when Amazon QuickSight
/// connects to your underlying data source.
class SslProperties {
  /// A Boolean option to control whether SSL should be disabled.
  final bool? disableSsl;

  SslProperties({
    this.disableSsl,
  });

  factory SslProperties.fromJson(Map<String, dynamic> json) {
    return SslProperties(
      disableSsl: json['DisableSsl'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final disableSsl = this.disableSsl;
    return {
      if (disableSsl != null) 'DisableSsl': disableSsl,
    };
  }
}

/// The parameters that are required to connect to a Starburst data source.
class StarburstParameters {
  /// The catalog name for the Starburst data source.
  final String catalog;

  /// The host name of the Starburst data source.
  final String host;

  /// The port for the Starburst data source.
  final int port;

  /// The product type for the Starburst data source.
  final StarburstProductType? productType;

  StarburstParameters({
    required this.catalog,
    required this.host,
    required this.port,
    this.productType,
  });

  factory StarburstParameters.fromJson(Map<String, dynamic> json) {
    return StarburstParameters(
      catalog: json['Catalog'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
      productType: (json['ProductType'] as String?)?.toStarburstProductType(),
    );
  }

  Map<String, dynamic> toJson() {
    final catalog = this.catalog;
    final host = this.host;
    final port = this.port;
    final productType = this.productType;
    return {
      'Catalog': catalog,
      'Host': host,
      'Port': port,
      if (productType != null) 'ProductType': productType.toValue(),
    };
  }
}

enum StarburstProductType {
  galaxy,
  enterprise,
}

extension StarburstProductTypeValueExtension on StarburstProductType {
  String toValue() {
    switch (this) {
      case StarburstProductType.galaxy:
        return 'GALAXY';
      case StarburstProductType.enterprise:
        return 'ENTERPRISE';
    }
  }
}

extension StarburstProductTypeFromString on String {
  StarburstProductType toStarburstProductType() {
    switch (this) {
      case 'GALAXY':
        return StarburstProductType.galaxy;
      case 'ENTERPRISE':
        return StarburstProductType.enterprise;
    }
    throw Exception('$this is not known in enum StarburstProductType');
  }
}

class StartAssetBundleExportJobResponse {
  /// The Amazon Resource Name (ARN) for the export job.
  final String? arn;

  /// The ID of the job. This ID is unique while the job is running. After the job
  /// is completed, you can reuse this ID for another job.
  final String? assetBundleExportJobId;

  /// The Amazon Web Services response ID for this operation.
  final String? requestId;

  /// The HTTP status of the response.
  final int? status;

  StartAssetBundleExportJobResponse({
    this.arn,
    this.assetBundleExportJobId,
    this.requestId,
    this.status,
  });

  factory StartAssetBundleExportJobResponse.fromJson(
      Map<String, dynamic> json) {
    return StartAssetBundleExportJobResponse(
      arn: json['Arn'] as String?,
      assetBundleExportJobId: json['AssetBundleExportJobId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assetBundleExportJobId = this.assetBundleExportJobId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (assetBundleExportJobId != null)
        'AssetBundleExportJobId': assetBundleExportJobId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class StartAssetBundleImportJobResponse {
  /// The Amazon Resource Name (ARN) for the import job.
  final String? arn;

  /// The ID of the job. This ID is unique while the job is running. After the job
  /// is completed, you can reuse this ID for another job.
  final String? assetBundleImportJobId;

  /// The Amazon Web Services response ID for this operation.
  final String? requestId;

  /// The HTTP status of the response.
  final int? status;

  StartAssetBundleImportJobResponse({
    this.arn,
    this.assetBundleImportJobId,
    this.requestId,
    this.status,
  });

  factory StartAssetBundleImportJobResponse.fromJson(
      Map<String, dynamic> json) {
    return StartAssetBundleImportJobResponse(
      arn: json['Arn'] as String?,
      assetBundleImportJobId: json['AssetBundleImportJobId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final assetBundleImportJobId = this.assetBundleImportJobId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (assetBundleImportJobId != null)
        'AssetBundleImportJobId': assetBundleImportJobId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class StartDashboardSnapshotJobResponse {
  /// The Amazon Resource Name (ARN) for the dashboard snapshot job.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The ID of the job. The job ID is set when you start a new job with a
  /// <code>StartDashboardSnapshotJob</code> API call.
  final String? snapshotJobId;

  /// The HTTP status of the request
  final int? status;

  StartDashboardSnapshotJobResponse({
    this.arn,
    this.requestId,
    this.snapshotJobId,
    this.status,
  });

  factory StartDashboardSnapshotJobResponse.fromJson(
      Map<String, dynamic> json) {
    return StartDashboardSnapshotJobResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      snapshotJobId: json['SnapshotJobId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final snapshotJobId = this.snapshotJobId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (snapshotJobId != null) 'SnapshotJobId': snapshotJobId,
    };
  }
}

/// The state perssitence configuration of an embedded dashboard.
class StatePersistenceConfigurations {
  /// Determines if a Amazon QuickSight dashboard's state persistence settings are
  /// turned on or off.
  final bool enabled;

  StatePersistenceConfigurations({
    required this.enabled,
  });

  Map<String, dynamic> toJson() {
    final enabled = this.enabled;
    return {
      'Enabled': enabled,
    };
  }
}

enum Status {
  enabled,
  disabled,
}

extension StatusValueExtension on Status {
  String toValue() {
    switch (this) {
      case Status.enabled:
        return 'ENABLED';
      case Status.disabled:
        return 'DISABLED';
    }
  }
}

extension StatusFromString on String {
  Status toStatus() {
    switch (this) {
      case 'ENABLED':
        return Status.enabled;
      case 'DISABLED':
        return Status.disabled;
    }
    throw Exception('$this is not known in enum Status');
  }
}

/// A string parameter for a dataset.
class StringDatasetParameter {
  /// An identifier for the string parameter that is created in the dataset.
  final String id;

  /// The name of the string parameter that is created in the dataset.
  final String name;

  /// The value type of the dataset parameter. Valid values are <code>single
  /// value</code> or <code>multi value</code>.
  final DatasetParameterValueType valueType;

  /// A list of default values for a given string dataset parameter type. This
  /// structure only accepts static values.
  final StringDatasetParameterDefaultValues? defaultValues;

  StringDatasetParameter({
    required this.id,
    required this.name,
    required this.valueType,
    this.defaultValues,
  });

  factory StringDatasetParameter.fromJson(Map<String, dynamic> json) {
    return StringDatasetParameter(
      id: json['Id'] as String,
      name: json['Name'] as String,
      valueType: (json['ValueType'] as String).toDatasetParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? StringDatasetParameterDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final id = this.id;
    final name = this.name;
    final valueType = this.valueType;
    final defaultValues = this.defaultValues;
    return {
      'Id': id,
      'Name': name,
      'ValueType': valueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
    };
  }
}

/// The default values of a string parameter.
class StringDatasetParameterDefaultValues {
  /// A list of static default values for a given string parameter.
  final List<String>? staticValues;

  StringDatasetParameterDefaultValues({
    this.staticValues,
  });

  factory StringDatasetParameterDefaultValues.fromJson(
      Map<String, dynamic> json) {
    return StringDatasetParameterDefaultValues(
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final staticValues = this.staticValues;
    return {
      if (staticValues != null) 'StaticValues': staticValues,
    };
  }
}

/// The default values of the <code>StringParameterDeclaration</code>.
class StringDefaultValues {
  /// The dynamic value of the <code>StringDefaultValues</code>. Different
  /// defaults displayed according to users, groups, and values mapping.
  final DynamicDefaultValue? dynamicValue;

  /// The static values of the <code>DecimalDefaultValues</code>.
  final List<String>? staticValues;

  StringDefaultValues({
    this.dynamicValue,
    this.staticValues,
  });

  factory StringDefaultValues.fromJson(Map<String, dynamic> json) {
    return StringDefaultValues(
      dynamicValue: json['DynamicValue'] != null
          ? DynamicDefaultValue.fromJson(
              json['DynamicValue'] as Map<String, dynamic>)
          : null,
      staticValues: (json['StaticValues'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dynamicValue = this.dynamicValue;
    final staticValues = this.staticValues;
    return {
      if (dynamicValue != null) 'DynamicValue': dynamicValue,
      if (staticValues != null) 'StaticValues': staticValues,
    };
  }
}

/// Formatting configuration for string fields.
class StringFormatConfiguration {
  /// The options that determine the null value format configuration.
  final NullValueFormatConfiguration? nullValueFormatConfiguration;

  /// The formatting configuration for numeric strings.
  final NumericFormatConfiguration? numericFormatConfiguration;

  StringFormatConfiguration({
    this.nullValueFormatConfiguration,
    this.numericFormatConfiguration,
  });

  factory StringFormatConfiguration.fromJson(Map<String, dynamic> json) {
    return StringFormatConfiguration(
      nullValueFormatConfiguration: json['NullValueFormatConfiguration'] != null
          ? NullValueFormatConfiguration.fromJson(
              json['NullValueFormatConfiguration'] as Map<String, dynamic>)
          : null,
      numericFormatConfiguration: json['NumericFormatConfiguration'] != null
          ? NumericFormatConfiguration.fromJson(
              json['NumericFormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final nullValueFormatConfiguration = this.nullValueFormatConfiguration;
    final numericFormatConfiguration = this.numericFormatConfiguration;
    return {
      if (nullValueFormatConfiguration != null)
        'NullValueFormatConfiguration': nullValueFormatConfiguration,
      if (numericFormatConfiguration != null)
        'NumericFormatConfiguration': numericFormatConfiguration,
    };
  }
}

/// A string parameter.
class StringParameter {
  /// A display name for a string parameter.
  final String name;

  /// The values of a string parameter.
  final List<String> values;

  StringParameter({
    required this.name,
    required this.values,
  });

  factory StringParameter.fromJson(Map<String, dynamic> json) {
    return StringParameter(
      name: json['Name'] as String,
      values: (json['Values'] as List)
          .whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final values = this.values;
    return {
      'Name': name,
      'Values': values,
    };
  }
}

/// A parameter declaration for the <code>String</code> data type.
class StringParameterDeclaration {
  /// The name of the parameter that is being declared.
  final String name;

  /// The value type determines whether the parameter is a single-value or
  /// multi-value parameter.
  final ParameterValueType parameterValueType;

  /// The default values of a parameter. If the parameter is a single-value
  /// parameter, a maximum of one default value can be provided.
  final StringDefaultValues? defaultValues;
  final List<MappedDataSetParameter>? mappedDataSetParameters;

  /// The configuration that defines the default value of a <code>String</code>
  /// parameter when a value has not been set.
  final StringValueWhenUnsetConfiguration? valueWhenUnset;

  StringParameterDeclaration({
    required this.name,
    required this.parameterValueType,
    this.defaultValues,
    this.mappedDataSetParameters,
    this.valueWhenUnset,
  });

  factory StringParameterDeclaration.fromJson(Map<String, dynamic> json) {
    return StringParameterDeclaration(
      name: json['Name'] as String,
      parameterValueType:
          (json['ParameterValueType'] as String).toParameterValueType(),
      defaultValues: json['DefaultValues'] != null
          ? StringDefaultValues.fromJson(
              json['DefaultValues'] as Map<String, dynamic>)
          : null,
      mappedDataSetParameters: (json['MappedDataSetParameters'] as List?)
          ?.whereNotNull()
          .map(
              (e) => MappedDataSetParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      valueWhenUnset: json['ValueWhenUnset'] != null
          ? StringValueWhenUnsetConfiguration.fromJson(
              json['ValueWhenUnset'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final name = this.name;
    final parameterValueType = this.parameterValueType;
    final defaultValues = this.defaultValues;
    final mappedDataSetParameters = this.mappedDataSetParameters;
    final valueWhenUnset = this.valueWhenUnset;
    return {
      'Name': name,
      'ParameterValueType': parameterValueType.toValue(),
      if (defaultValues != null) 'DefaultValues': defaultValues,
      if (mappedDataSetParameters != null)
        'MappedDataSetParameters': mappedDataSetParameters,
      if (valueWhenUnset != null) 'ValueWhenUnset': valueWhenUnset,
    };
  }
}

/// The configuration that defines the default value of a <code>String</code>
/// parameter when a value has not been set.
class StringValueWhenUnsetConfiguration {
  /// A custom value that's used when the value of a parameter isn't set.
  final String? customValue;

  /// The built-in options for default values. The value can be one of the
  /// following:
  ///
  /// <ul>
  /// <li>
  /// <code>RECOMMENDED</code>: The recommended value.
  /// </li>
  /// <li>
  /// <code>NULL</code>: The <code>NULL</code> value.
  /// </li>
  /// </ul>
  final ValueWhenUnsetOption? valueWhenUnsetOption;

  StringValueWhenUnsetConfiguration({
    this.customValue,
    this.valueWhenUnsetOption,
  });

  factory StringValueWhenUnsetConfiguration.fromJson(
      Map<String, dynamic> json) {
    return StringValueWhenUnsetConfiguration(
      customValue: json['CustomValue'] as String?,
      valueWhenUnsetOption:
          (json['ValueWhenUnsetOption'] as String?)?.toValueWhenUnsetOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final customValue = this.customValue;
    final valueWhenUnsetOption = this.valueWhenUnsetOption;
    return {
      if (customValue != null) 'CustomValue': customValue,
      if (valueWhenUnsetOption != null)
        'ValueWhenUnsetOption': valueWhenUnsetOption.toValue(),
    };
  }
}

enum StyledCellType {
  total,
  metricHeader,
  value,
}

extension StyledCellTypeValueExtension on StyledCellType {
  String toValue() {
    switch (this) {
      case StyledCellType.total:
        return 'TOTAL';
      case StyledCellType.metricHeader:
        return 'METRIC_HEADER';
      case StyledCellType.value:
        return 'VALUE';
    }
  }
}

extension StyledCellTypeFromString on String {
  StyledCellType toStyledCellType() {
    switch (this) {
      case 'TOTAL':
        return StyledCellType.total;
      case 'METRIC_HEADER':
        return StyledCellType.metricHeader;
      case 'VALUE':
        return StyledCellType.value;
    }
    throw Exception('$this is not known in enum StyledCellType');
  }
}

/// The subtotal options.
class SubtotalOptions {
  /// The custom label string for the subtotal cells.
  final String? customLabel;

  /// The field level (all, custom, last) for the subtotal cells.
  final PivotTableSubtotalLevel? fieldLevel;

  /// The optional configuration of subtotal cells.
  final List<PivotTableFieldSubtotalOptions>? fieldLevelOptions;

  /// The cell styling options for the subtotals of header cells.
  final TableCellStyle? metricHeaderCellStyle;

  /// The style targets options for subtotals.
  final List<TableStyleTarget>? styleTargets;

  /// The cell styling options for the subtotal cells.
  final TableCellStyle? totalCellStyle;

  /// The visibility configuration for the subtotal cells.
  final Visibility? totalsVisibility;

  /// The cell styling options for the subtotals of value cells.
  final TableCellStyle? valueCellStyle;

  SubtotalOptions({
    this.customLabel,
    this.fieldLevel,
    this.fieldLevelOptions,
    this.metricHeaderCellStyle,
    this.styleTargets,
    this.totalCellStyle,
    this.totalsVisibility,
    this.valueCellStyle,
  });

  factory SubtotalOptions.fromJson(Map<String, dynamic> json) {
    return SubtotalOptions(
      customLabel: json['CustomLabel'] as String?,
      fieldLevel: (json['FieldLevel'] as String?)?.toPivotTableSubtotalLevel(),
      fieldLevelOptions: (json['FieldLevelOptions'] as List?)
          ?.whereNotNull()
          .map((e) => PivotTableFieldSubtotalOptions.fromJson(
              e as Map<String, dynamic>))
          .toList(),
      metricHeaderCellStyle: json['MetricHeaderCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['MetricHeaderCellStyle'] as Map<String, dynamic>)
          : null,
      styleTargets: (json['StyleTargets'] as List?)
          ?.whereNotNull()
          .map((e) => TableStyleTarget.fromJson(e as Map<String, dynamic>))
          .toList(),
      totalCellStyle: json['TotalCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['TotalCellStyle'] as Map<String, dynamic>)
          : null,
      totalsVisibility: (json['TotalsVisibility'] as String?)?.toVisibility(),
      valueCellStyle: json['ValueCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['ValueCellStyle'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customLabel = this.customLabel;
    final fieldLevel = this.fieldLevel;
    final fieldLevelOptions = this.fieldLevelOptions;
    final metricHeaderCellStyle = this.metricHeaderCellStyle;
    final styleTargets = this.styleTargets;
    final totalCellStyle = this.totalCellStyle;
    final totalsVisibility = this.totalsVisibility;
    final valueCellStyle = this.valueCellStyle;
    return {
      if (customLabel != null) 'CustomLabel': customLabel,
      if (fieldLevel != null) 'FieldLevel': fieldLevel.toValue(),
      if (fieldLevelOptions != null) 'FieldLevelOptions': fieldLevelOptions,
      if (metricHeaderCellStyle != null)
        'MetricHeaderCellStyle': metricHeaderCellStyle,
      if (styleTargets != null) 'StyleTargets': styleTargets,
      if (totalCellStyle != null) 'TotalCellStyle': totalCellStyle,
      if (totalsVisibility != null)
        'TotalsVisibility': totalsVisibility.toValue(),
      if (valueCellStyle != null) 'ValueCellStyle': valueCellStyle,
    };
  }
}

/// A success entry that occurs when a <code>KeyRegistration</code> job is
/// successfully applied to the Amazon QuickSight account.
class SuccessfulKeyRegistrationEntry {
  /// The ARN of the KMS key that is associated with the
  /// <code>SuccessfulKeyRegistrationEntry</code> entry.
  final String keyArn;

  /// The HTTP status of a <code>SuccessfulKeyRegistrationEntry</code> entry.
  final int statusCode;

  SuccessfulKeyRegistrationEntry({
    required this.keyArn,
    required this.statusCode,
  });

  factory SuccessfulKeyRegistrationEntry.fromJson(Map<String, dynamic> json) {
    return SuccessfulKeyRegistrationEntry(
      keyArn: json['KeyArn'] as String,
      statusCode: json['StatusCode'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final keyArn = this.keyArn;
    final statusCode = this.statusCode;
    return {
      'KeyArn': keyArn,
      'StatusCode': statusCode,
    };
  }
}

/// The aggregated field well for the table.
class TableAggregatedFieldWells {
  /// The group by field well for a pivot table. Values are grouped by group by
  /// fields.
  final List<DimensionField>? groupBy;

  /// The values field well for a pivot table. Values are aggregated based on
  /// group by fields.
  final List<MeasureField>? values;

  TableAggregatedFieldWells({
    this.groupBy,
    this.values,
  });

  factory TableAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return TableAggregatedFieldWells(
      groupBy: (json['GroupBy'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final groupBy = this.groupBy;
    final values = this.values;
    return {
      if (groupBy != null) 'GroupBy': groupBy,
      if (values != null) 'Values': values,
    };
  }
}

/// The border options for a table border.
class TableBorderOptions {
  /// The color of a table border.
  final String? color;

  /// The style (none, solid) of a table border.
  final TableBorderStyle? style;

  /// The thickness of a table border.
  final int? thickness;

  TableBorderOptions({
    this.color,
    this.style,
    this.thickness,
  });

  factory TableBorderOptions.fromJson(Map<String, dynamic> json) {
    return TableBorderOptions(
      color: json['Color'] as String?,
      style: (json['Style'] as String?)?.toTableBorderStyle(),
      thickness: json['Thickness'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final color = this.color;
    final style = this.style;
    final thickness = this.thickness;
    return {
      if (color != null) 'Color': color,
      if (style != null) 'Style': style.toValue(),
      if (thickness != null) 'Thickness': thickness,
    };
  }
}

enum TableBorderStyle {
  none,
  solid,
}

extension TableBorderStyleValueExtension on TableBorderStyle {
  String toValue() {
    switch (this) {
      case TableBorderStyle.none:
        return 'NONE';
      case TableBorderStyle.solid:
        return 'SOLID';
    }
  }
}

extension TableBorderStyleFromString on String {
  TableBorderStyle toTableBorderStyle() {
    switch (this) {
      case 'NONE':
        return TableBorderStyle.none;
      case 'SOLID':
        return TableBorderStyle.solid;
    }
    throw Exception('$this is not known in enum TableBorderStyle');
  }
}

/// The cell conditional formatting option for a table.
class TableCellConditionalFormatting {
  /// The field ID of the cell for conditional formatting.
  final String fieldId;

  /// The text format of the cell for conditional formatting.
  final TextConditionalFormat? textFormat;

  TableCellConditionalFormatting({
    required this.fieldId,
    this.textFormat,
  });

  factory TableCellConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return TableCellConditionalFormatting(
      fieldId: json['FieldId'] as String,
      textFormat: json['TextFormat'] != null
          ? TextConditionalFormat.fromJson(
              json['TextFormat'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final textFormat = this.textFormat;
    return {
      'FieldId': fieldId,
      if (textFormat != null) 'TextFormat': textFormat,
    };
  }
}

enum TableCellImageScalingConfiguration {
  fitToCellHeight,
  fitToCellWidth,
  doNotScale,
}

extension TableCellImageScalingConfigurationValueExtension
    on TableCellImageScalingConfiguration {
  String toValue() {
    switch (this) {
      case TableCellImageScalingConfiguration.fitToCellHeight:
        return 'FIT_TO_CELL_HEIGHT';
      case TableCellImageScalingConfiguration.fitToCellWidth:
        return 'FIT_TO_CELL_WIDTH';
      case TableCellImageScalingConfiguration.doNotScale:
        return 'DO_NOT_SCALE';
    }
  }
}

extension TableCellImageScalingConfigurationFromString on String {
  TableCellImageScalingConfiguration toTableCellImageScalingConfiguration() {
    switch (this) {
      case 'FIT_TO_CELL_HEIGHT':
        return TableCellImageScalingConfiguration.fitToCellHeight;
      case 'FIT_TO_CELL_WIDTH':
        return TableCellImageScalingConfiguration.fitToCellWidth;
      case 'DO_NOT_SCALE':
        return TableCellImageScalingConfiguration.doNotScale;
    }
    throw Exception(
        '$this is not known in enum TableCellImageScalingConfiguration');
  }
}

/// The sizing options for the table image configuration.
class TableCellImageSizingConfiguration {
  /// The cell scaling configuration of the sizing options for the table image
  /// configuration.
  final TableCellImageScalingConfiguration? tableCellImageScalingConfiguration;

  TableCellImageSizingConfiguration({
    this.tableCellImageScalingConfiguration,
  });

  factory TableCellImageSizingConfiguration.fromJson(
      Map<String, dynamic> json) {
    return TableCellImageSizingConfiguration(
      tableCellImageScalingConfiguration:
          (json['TableCellImageScalingConfiguration'] as String?)
              ?.toTableCellImageScalingConfiguration(),
    );
  }

  Map<String, dynamic> toJson() {
    final tableCellImageScalingConfiguration =
        this.tableCellImageScalingConfiguration;
    return {
      if (tableCellImageScalingConfiguration != null)
        'TableCellImageScalingConfiguration':
            tableCellImageScalingConfiguration.toValue(),
    };
  }
}

/// The table cell style for a cell in pivot table or table visual.
class TableCellStyle {
  /// The background color for the table cells.
  final String? backgroundColor;

  /// The borders for the table cells.
  final GlobalTableBorderOptions? border;

  /// The font configuration of the table cells.
  final FontConfiguration? fontConfiguration;

  /// The height color for the table cells.
  final int? height;

  /// The horizontal text alignment (left, center, right, auto) for the table
  /// cells.
  final HorizontalTextAlignment? horizontalTextAlignment;

  /// The text wrap (none, wrap) for the table cells.
  final TextWrap? textWrap;

  /// The vertical text alignment (top, middle, bottom) for the table cells.
  final VerticalTextAlignment? verticalTextAlignment;

  /// The visibility of the table cells.
  final Visibility? visibility;

  TableCellStyle({
    this.backgroundColor,
    this.border,
    this.fontConfiguration,
    this.height,
    this.horizontalTextAlignment,
    this.textWrap,
    this.verticalTextAlignment,
    this.visibility,
  });

  factory TableCellStyle.fromJson(Map<String, dynamic> json) {
    return TableCellStyle(
      backgroundColor: json['BackgroundColor'] as String?,
      border: json['Border'] != null
          ? GlobalTableBorderOptions.fromJson(
              json['Border'] as Map<String, dynamic>)
          : null,
      fontConfiguration: json['FontConfiguration'] != null
          ? FontConfiguration.fromJson(
              json['FontConfiguration'] as Map<String, dynamic>)
          : null,
      height: json['Height'] as int?,
      horizontalTextAlignment: (json['HorizontalTextAlignment'] as String?)
          ?.toHorizontalTextAlignment(),
      textWrap: (json['TextWrap'] as String?)?.toTextWrap(),
      verticalTextAlignment:
          (json['VerticalTextAlignment'] as String?)?.toVerticalTextAlignment(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final backgroundColor = this.backgroundColor;
    final border = this.border;
    final fontConfiguration = this.fontConfiguration;
    final height = this.height;
    final horizontalTextAlignment = this.horizontalTextAlignment;
    final textWrap = this.textWrap;
    final verticalTextAlignment = this.verticalTextAlignment;
    final visibility = this.visibility;
    return {
      if (backgroundColor != null) 'BackgroundColor': backgroundColor,
      if (border != null) 'Border': border,
      if (fontConfiguration != null) 'FontConfiguration': fontConfiguration,
      if (height != null) 'Height': height,
      if (horizontalTextAlignment != null)
        'HorizontalTextAlignment': horizontalTextAlignment.toValue(),
      if (textWrap != null) 'TextWrap': textWrap.toValue(),
      if (verticalTextAlignment != null)
        'VerticalTextAlignment': verticalTextAlignment.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The conditional formatting for a <code>PivotTableVisual</code>.
class TableConditionalFormatting {
  /// Conditional formatting options for a <code>PivotTableVisual</code>.
  final List<TableConditionalFormattingOption>? conditionalFormattingOptions;

  TableConditionalFormatting({
    this.conditionalFormattingOptions,
  });

  factory TableConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return TableConditionalFormatting(
      conditionalFormattingOptions:
          (json['ConditionalFormattingOptions'] as List?)
              ?.whereNotNull()
              .map((e) => TableConditionalFormattingOption.fromJson(
                  e as Map<String, dynamic>))
              .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final conditionalFormattingOptions = this.conditionalFormattingOptions;
    return {
      if (conditionalFormattingOptions != null)
        'ConditionalFormattingOptions': conditionalFormattingOptions,
    };
  }
}

/// Conditional formatting options for a <code>PivotTableVisual</code>.
class TableConditionalFormattingOption {
  /// The cell conditional formatting option for a table.
  final TableCellConditionalFormatting? cell;

  /// The row conditional formatting option for a table.
  final TableRowConditionalFormatting? row;

  TableConditionalFormattingOption({
    this.cell,
    this.row,
  });

  factory TableConditionalFormattingOption.fromJson(Map<String, dynamic> json) {
    return TableConditionalFormattingOption(
      cell: json['Cell'] != null
          ? TableCellConditionalFormatting.fromJson(
              json['Cell'] as Map<String, dynamic>)
          : null,
      row: json['Row'] != null
          ? TableRowConditionalFormatting.fromJson(
              json['Row'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cell = this.cell;
    final row = this.row;
    return {
      if (cell != null) 'Cell': cell,
      if (row != null) 'Row': row,
    };
  }
}

/// The configuration for a <code>TableVisual</code>.
class TableConfiguration {
  /// The field options for a table visual.
  final TableFieldOptions? fieldOptions;

  /// The field wells of the visual.
  final TableFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The paginated report options for a table visual.
  final TablePaginatedReportOptions? paginatedReportOptions;

  /// The sort configuration for a <code>TableVisual</code>.
  final TableSortConfiguration? sortConfiguration;

  /// A collection of inline visualizations to display within a chart.
  final List<TableInlineVisualization>? tableInlineVisualizations;

  /// The table options for a table visual.
  final TableOptions? tableOptions;

  /// The total options for a table visual.
  final TotalOptions? totalOptions;

  TableConfiguration({
    this.fieldOptions,
    this.fieldWells,
    this.interactions,
    this.paginatedReportOptions,
    this.sortConfiguration,
    this.tableInlineVisualizations,
    this.tableOptions,
    this.totalOptions,
  });

  factory TableConfiguration.fromJson(Map<String, dynamic> json) {
    return TableConfiguration(
      fieldOptions: json['FieldOptions'] != null
          ? TableFieldOptions.fromJson(
              json['FieldOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? TableFieldWells.fromJson(json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      paginatedReportOptions: json['PaginatedReportOptions'] != null
          ? TablePaginatedReportOptions.fromJson(
              json['PaginatedReportOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? TableSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tableInlineVisualizations: (json['TableInlineVisualizations'] as List?)
          ?.whereNotNull()
          .map((e) =>
              TableInlineVisualization.fromJson(e as Map<String, dynamic>))
          .toList(),
      tableOptions: json['TableOptions'] != null
          ? TableOptions.fromJson(json['TableOptions'] as Map<String, dynamic>)
          : null,
      totalOptions: json['TotalOptions'] != null
          ? TotalOptions.fromJson(json['TotalOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldOptions = this.fieldOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final paginatedReportOptions = this.paginatedReportOptions;
    final sortConfiguration = this.sortConfiguration;
    final tableInlineVisualizations = this.tableInlineVisualizations;
    final tableOptions = this.tableOptions;
    final totalOptions = this.totalOptions;
    return {
      if (fieldOptions != null) 'FieldOptions': fieldOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (paginatedReportOptions != null)
        'PaginatedReportOptions': paginatedReportOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tableInlineVisualizations != null)
        'TableInlineVisualizations': tableInlineVisualizations,
      if (tableOptions != null) 'TableOptions': tableOptions,
      if (totalOptions != null) 'TotalOptions': totalOptions,
    };
  }
}

/// The custom icon content for the table link content configuration.
class TableFieldCustomIconContent {
  /// The icon set type (link) of the custom icon content for table URL link
  /// content.
  final TableFieldIconSetType? icon;

  TableFieldCustomIconContent({
    this.icon,
  });

  factory TableFieldCustomIconContent.fromJson(Map<String, dynamic> json) {
    return TableFieldCustomIconContent(
      icon: (json['Icon'] as String?)?.toTableFieldIconSetType(),
    );
  }

  Map<String, dynamic> toJson() {
    final icon = this.icon;
    return {
      if (icon != null) 'Icon': icon.toValue(),
    };
  }
}

/// The custom text content (value, font configuration) for the table link
/// content configuration.
class TableFieldCustomTextContent {
  /// The font configuration of the custom text content for the table URL link
  /// content.
  final FontConfiguration fontConfiguration;

  /// The string value of the custom text content for the table URL link content.
  final String? value;

  TableFieldCustomTextContent({
    required this.fontConfiguration,
    this.value,
  });

  factory TableFieldCustomTextContent.fromJson(Map<String, dynamic> json) {
    return TableFieldCustomTextContent(
      fontConfiguration: FontConfiguration.fromJson(
          json['FontConfiguration'] as Map<String, dynamic>),
      value: json['Value'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fontConfiguration = this.fontConfiguration;
    final value = this.value;
    return {
      'FontConfiguration': fontConfiguration,
      if (value != null) 'Value': value,
    };
  }
}

enum TableFieldIconSetType {
  link,
}

extension TableFieldIconSetTypeValueExtension on TableFieldIconSetType {
  String toValue() {
    switch (this) {
      case TableFieldIconSetType.link:
        return 'LINK';
    }
  }
}

extension TableFieldIconSetTypeFromString on String {
  TableFieldIconSetType toTableFieldIconSetType() {
    switch (this) {
      case 'LINK':
        return TableFieldIconSetType.link;
    }
    throw Exception('$this is not known in enum TableFieldIconSetType');
  }
}

/// The image configuration of a table field URL.
class TableFieldImageConfiguration {
  /// The sizing options for the table image configuration.
  final TableCellImageSizingConfiguration? sizingOptions;

  TableFieldImageConfiguration({
    this.sizingOptions,
  });

  factory TableFieldImageConfiguration.fromJson(Map<String, dynamic> json) {
    return TableFieldImageConfiguration(
      sizingOptions: json['SizingOptions'] != null
          ? TableCellImageSizingConfiguration.fromJson(
              json['SizingOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final sizingOptions = this.sizingOptions;
    return {
      if (sizingOptions != null) 'SizingOptions': sizingOptions,
    };
  }
}

/// The link configuration of a table field URL.
class TableFieldLinkConfiguration {
  /// The URL content (text, icon) for the table link configuration.
  final TableFieldLinkContentConfiguration content;

  /// The URL target (new tab, new window, same tab) for the table link
  /// configuration.
  final URLTargetConfiguration target;

  TableFieldLinkConfiguration({
    required this.content,
    required this.target,
  });

  factory TableFieldLinkConfiguration.fromJson(Map<String, dynamic> json) {
    return TableFieldLinkConfiguration(
      content: TableFieldLinkContentConfiguration.fromJson(
          json['Content'] as Map<String, dynamic>),
      target: (json['Target'] as String).toURLTargetConfiguration(),
    );
  }

  Map<String, dynamic> toJson() {
    final content = this.content;
    final target = this.target;
    return {
      'Content': content,
      'Target': target.toValue(),
    };
  }
}

/// The URL content (text, icon) for the table link configuration.
class TableFieldLinkContentConfiguration {
  /// The custom icon content for the table link content configuration.
  final TableFieldCustomIconContent? customIconContent;

  /// The custom text content (value, font configuration) for the table link
  /// content configuration.
  final TableFieldCustomTextContent? customTextContent;

  TableFieldLinkContentConfiguration({
    this.customIconContent,
    this.customTextContent,
  });

  factory TableFieldLinkContentConfiguration.fromJson(
      Map<String, dynamic> json) {
    return TableFieldLinkContentConfiguration(
      customIconContent: json['CustomIconContent'] != null
          ? TableFieldCustomIconContent.fromJson(
              json['CustomIconContent'] as Map<String, dynamic>)
          : null,
      customTextContent: json['CustomTextContent'] != null
          ? TableFieldCustomTextContent.fromJson(
              json['CustomTextContent'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final customIconContent = this.customIconContent;
    final customTextContent = this.customTextContent;
    return {
      if (customIconContent != null) 'CustomIconContent': customIconContent,
      if (customTextContent != null) 'CustomTextContent': customTextContent,
    };
  }
}

/// The options for a table field.
class TableFieldOption {
  /// The field ID for a table field.
  final String fieldId;

  /// The custom label for a table field.
  final String? customLabel;

  /// The URL configuration for a table field.
  final TableFieldURLConfiguration? uRLStyling;

  /// The visibility of a table field.
  final Visibility? visibility;

  /// The width for a table field.
  final String? width;

  TableFieldOption({
    required this.fieldId,
    this.customLabel,
    this.uRLStyling,
    this.visibility,
    this.width,
  });

  factory TableFieldOption.fromJson(Map<String, dynamic> json) {
    return TableFieldOption(
      fieldId: json['FieldId'] as String,
      customLabel: json['CustomLabel'] as String?,
      uRLStyling: json['URLStyling'] != null
          ? TableFieldURLConfiguration.fromJson(
              json['URLStyling'] as Map<String, dynamic>)
          : null,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
      width: json['Width'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final customLabel = this.customLabel;
    final uRLStyling = this.uRLStyling;
    final visibility = this.visibility;
    final width = this.width;
    return {
      'FieldId': fieldId,
      if (customLabel != null) 'CustomLabel': customLabel,
      if (uRLStyling != null) 'URLStyling': uRLStyling,
      if (visibility != null) 'Visibility': visibility.toValue(),
      if (width != null) 'Width': width,
    };
  }
}

/// The field options of a table visual.
class TableFieldOptions {
  /// The order of the field IDs that are configured as field options for a table
  /// visual.
  final List<String>? order;

  /// The settings for the pinned columns of a table visual.
  final TablePinnedFieldOptions? pinnedFieldOptions;

  /// The field options to be configured to a table.
  final List<TableFieldOption>? selectedFieldOptions;

  TableFieldOptions({
    this.order,
    this.pinnedFieldOptions,
    this.selectedFieldOptions,
  });

  factory TableFieldOptions.fromJson(Map<String, dynamic> json) {
    return TableFieldOptions(
      order: (json['Order'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      pinnedFieldOptions: json['PinnedFieldOptions'] != null
          ? TablePinnedFieldOptions.fromJson(
              json['PinnedFieldOptions'] as Map<String, dynamic>)
          : null,
      selectedFieldOptions: (json['SelectedFieldOptions'] as List?)
          ?.whereNotNull()
          .map((e) => TableFieldOption.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final order = this.order;
    final pinnedFieldOptions = this.pinnedFieldOptions;
    final selectedFieldOptions = this.selectedFieldOptions;
    return {
      if (order != null) 'Order': order,
      if (pinnedFieldOptions != null) 'PinnedFieldOptions': pinnedFieldOptions,
      if (selectedFieldOptions != null)
        'SelectedFieldOptions': selectedFieldOptions,
    };
  }
}

/// The URL configuration for a table field.
class TableFieldURLConfiguration {
  /// The image configuration of a table field URL.
  final TableFieldImageConfiguration? imageConfiguration;

  /// The link configuration of a table field URL.
  final TableFieldLinkConfiguration? linkConfiguration;

  TableFieldURLConfiguration({
    this.imageConfiguration,
    this.linkConfiguration,
  });

  factory TableFieldURLConfiguration.fromJson(Map<String, dynamic> json) {
    return TableFieldURLConfiguration(
      imageConfiguration: json['ImageConfiguration'] != null
          ? TableFieldImageConfiguration.fromJson(
              json['ImageConfiguration'] as Map<String, dynamic>)
          : null,
      linkConfiguration: json['LinkConfiguration'] != null
          ? TableFieldLinkConfiguration.fromJson(
              json['LinkConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final imageConfiguration = this.imageConfiguration;
    final linkConfiguration = this.linkConfiguration;
    return {
      if (imageConfiguration != null) 'ImageConfiguration': imageConfiguration,
      if (linkConfiguration != null) 'LinkConfiguration': linkConfiguration,
    };
  }
}

/// The field wells for a table visual.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class TableFieldWells {
  /// The aggregated field well for the table.
  final TableAggregatedFieldWells? tableAggregatedFieldWells;

  /// The unaggregated field well for the table.
  final TableUnaggregatedFieldWells? tableUnaggregatedFieldWells;

  TableFieldWells({
    this.tableAggregatedFieldWells,
    this.tableUnaggregatedFieldWells,
  });

  factory TableFieldWells.fromJson(Map<String, dynamic> json) {
    return TableFieldWells(
      tableAggregatedFieldWells: json['TableAggregatedFieldWells'] != null
          ? TableAggregatedFieldWells.fromJson(
              json['TableAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
      tableUnaggregatedFieldWells: json['TableUnaggregatedFieldWells'] != null
          ? TableUnaggregatedFieldWells.fromJson(
              json['TableUnaggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final tableAggregatedFieldWells = this.tableAggregatedFieldWells;
    final tableUnaggregatedFieldWells = this.tableUnaggregatedFieldWells;
    return {
      if (tableAggregatedFieldWells != null)
        'TableAggregatedFieldWells': tableAggregatedFieldWells,
      if (tableUnaggregatedFieldWells != null)
        'TableUnaggregatedFieldWells': tableUnaggregatedFieldWells,
    };
  }
}

/// The inline visualization of a specific type to display within a chart.
class TableInlineVisualization {
  /// The configuration of the inline visualization of the data bars within a
  /// chart.
  final DataBarsOptions? dataBars;

  TableInlineVisualization({
    this.dataBars,
  });

  factory TableInlineVisualization.fromJson(Map<String, dynamic> json) {
    return TableInlineVisualization(
      dataBars: json['DataBars'] != null
          ? DataBarsOptions.fromJson(json['DataBars'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataBars = this.dataBars;
    return {
      if (dataBars != null) 'DataBars': dataBars,
    };
  }
}

/// The table options for a table visual.
class TableOptions {
  /// The table cell style of table cells.
  final TableCellStyle? cellStyle;

  /// The table cell style of a table header.
  final TableCellStyle? headerStyle;

  /// The orientation (vertical, horizontal) for a table.
  final TableOrientation? orientation;

  /// The row alternate color options (widget status, row alternate colors) for a
  /// table.
  final RowAlternateColorOptions? rowAlternateColorOptions;

  TableOptions({
    this.cellStyle,
    this.headerStyle,
    this.orientation,
    this.rowAlternateColorOptions,
  });

  factory TableOptions.fromJson(Map<String, dynamic> json) {
    return TableOptions(
      cellStyle: json['CellStyle'] != null
          ? TableCellStyle.fromJson(json['CellStyle'] as Map<String, dynamic>)
          : null,
      headerStyle: json['HeaderStyle'] != null
          ? TableCellStyle.fromJson(json['HeaderStyle'] as Map<String, dynamic>)
          : null,
      orientation: (json['Orientation'] as String?)?.toTableOrientation(),
      rowAlternateColorOptions: json['RowAlternateColorOptions'] != null
          ? RowAlternateColorOptions.fromJson(
              json['RowAlternateColorOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final cellStyle = this.cellStyle;
    final headerStyle = this.headerStyle;
    final orientation = this.orientation;
    final rowAlternateColorOptions = this.rowAlternateColorOptions;
    return {
      if (cellStyle != null) 'CellStyle': cellStyle,
      if (headerStyle != null) 'HeaderStyle': headerStyle,
      if (orientation != null) 'Orientation': orientation.toValue(),
      if (rowAlternateColorOptions != null)
        'RowAlternateColorOptions': rowAlternateColorOptions,
    };
  }
}

enum TableOrientation {
  vertical,
  horizontal,
}

extension TableOrientationValueExtension on TableOrientation {
  String toValue() {
    switch (this) {
      case TableOrientation.vertical:
        return 'VERTICAL';
      case TableOrientation.horizontal:
        return 'HORIZONTAL';
    }
  }
}

extension TableOrientationFromString on String {
  TableOrientation toTableOrientation() {
    switch (this) {
      case 'VERTICAL':
        return TableOrientation.vertical;
      case 'HORIZONTAL':
        return TableOrientation.horizontal;
    }
    throw Exception('$this is not known in enum TableOrientation');
  }
}

/// The paginated report options for a table visual.
class TablePaginatedReportOptions {
  /// The visibility of repeating header rows on each page.
  final Visibility? overflowColumnHeaderVisibility;

  /// The visibility of printing table overflow across pages.
  final Visibility? verticalOverflowVisibility;

  TablePaginatedReportOptions({
    this.overflowColumnHeaderVisibility,
    this.verticalOverflowVisibility,
  });

  factory TablePaginatedReportOptions.fromJson(Map<String, dynamic> json) {
    return TablePaginatedReportOptions(
      overflowColumnHeaderVisibility:
          (json['OverflowColumnHeaderVisibility'] as String?)?.toVisibility(),
      verticalOverflowVisibility:
          (json['VerticalOverflowVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final overflowColumnHeaderVisibility = this.overflowColumnHeaderVisibility;
    final verticalOverflowVisibility = this.verticalOverflowVisibility;
    return {
      if (overflowColumnHeaderVisibility != null)
        'OverflowColumnHeaderVisibility':
            overflowColumnHeaderVisibility.toValue(),
      if (verticalOverflowVisibility != null)
        'VerticalOverflowVisibility': verticalOverflowVisibility.toValue(),
    };
  }
}

/// The settings for the pinned columns of a table visual.
class TablePinnedFieldOptions {
  /// A list of columns to be pinned to the left of a table visual.
  final List<String>? pinnedLeftFields;

  TablePinnedFieldOptions({
    this.pinnedLeftFields,
  });

  factory TablePinnedFieldOptions.fromJson(Map<String, dynamic> json) {
    return TablePinnedFieldOptions(
      pinnedLeftFields: (json['PinnedLeftFields'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final pinnedLeftFields = this.pinnedLeftFields;
    return {
      if (pinnedLeftFields != null) 'PinnedLeftFields': pinnedLeftFields,
    };
  }
}

/// The conditional formatting of a table row.
class TableRowConditionalFormatting {
  /// The conditional formatting color (solid, gradient) of the background for a
  /// table row.
  final ConditionalFormattingColor? backgroundColor;

  /// The conditional formatting color (solid, gradient) of the text for a table
  /// row.
  final ConditionalFormattingColor? textColor;

  TableRowConditionalFormatting({
    this.backgroundColor,
    this.textColor,
  });

  factory TableRowConditionalFormatting.fromJson(Map<String, dynamic> json) {
    return TableRowConditionalFormatting(
      backgroundColor: json['BackgroundColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['BackgroundColor'] as Map<String, dynamic>)
          : null,
      textColor: json['TextColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['TextColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final backgroundColor = this.backgroundColor;
    final textColor = this.textColor;
    return {
      if (backgroundColor != null) 'BackgroundColor': backgroundColor,
      if (textColor != null) 'TextColor': textColor,
    };
  }
}

/// The side border options for a table.
class TableSideBorderOptions {
  /// The table border options of the bottom border.
  final TableBorderOptions? bottom;

  /// The table border options of the inner horizontal border.
  final TableBorderOptions? innerHorizontal;

  /// The table border options of the inner vertical border.
  final TableBorderOptions? innerVertical;

  /// The table border options of the left border.
  final TableBorderOptions? left;

  /// The table border options of the right border.
  final TableBorderOptions? right;

  /// The table border options of the top border.
  final TableBorderOptions? top;

  TableSideBorderOptions({
    this.bottom,
    this.innerHorizontal,
    this.innerVertical,
    this.left,
    this.right,
    this.top,
  });

  factory TableSideBorderOptions.fromJson(Map<String, dynamic> json) {
    return TableSideBorderOptions(
      bottom: json['Bottom'] != null
          ? TableBorderOptions.fromJson(json['Bottom'] as Map<String, dynamic>)
          : null,
      innerHorizontal: json['InnerHorizontal'] != null
          ? TableBorderOptions.fromJson(
              json['InnerHorizontal'] as Map<String, dynamic>)
          : null,
      innerVertical: json['InnerVertical'] != null
          ? TableBorderOptions.fromJson(
              json['InnerVertical'] as Map<String, dynamic>)
          : null,
      left: json['Left'] != null
          ? TableBorderOptions.fromJson(json['Left'] as Map<String, dynamic>)
          : null,
      right: json['Right'] != null
          ? TableBorderOptions.fromJson(json['Right'] as Map<String, dynamic>)
          : null,
      top: json['Top'] != null
          ? TableBorderOptions.fromJson(json['Top'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final bottom = this.bottom;
    final innerHorizontal = this.innerHorizontal;
    final innerVertical = this.innerVertical;
    final left = this.left;
    final right = this.right;
    final top = this.top;
    return {
      if (bottom != null) 'Bottom': bottom,
      if (innerHorizontal != null) 'InnerHorizontal': innerHorizontal,
      if (innerVertical != null) 'InnerVertical': innerVertical,
      if (left != null) 'Left': left,
      if (right != null) 'Right': right,
      if (top != null) 'Top': top,
    };
  }
}

/// The sort configuration for a <code>TableVisual</code>.
class TableSortConfiguration {
  /// The pagination configuration (page size, page number) for the table.
  final PaginationConfiguration? paginationConfiguration;

  /// The field sort options for rows in the table.
  final List<FieldSortOptions>? rowSort;

  TableSortConfiguration({
    this.paginationConfiguration,
    this.rowSort,
  });

  factory TableSortConfiguration.fromJson(Map<String, dynamic> json) {
    return TableSortConfiguration(
      paginationConfiguration: json['PaginationConfiguration'] != null
          ? PaginationConfiguration.fromJson(
              json['PaginationConfiguration'] as Map<String, dynamic>)
          : null,
      rowSort: (json['RowSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final paginationConfiguration = this.paginationConfiguration;
    final rowSort = this.rowSort;
    return {
      if (paginationConfiguration != null)
        'PaginationConfiguration': paginationConfiguration,
      if (rowSort != null) 'RowSort': rowSort,
    };
  }
}

/// The table style target.
class TableStyleTarget {
  /// The cell type of the table style target.
  final StyledCellType cellType;

  TableStyleTarget({
    required this.cellType,
  });

  factory TableStyleTarget.fromJson(Map<String, dynamic> json) {
    return TableStyleTarget(
      cellType: (json['CellType'] as String).toStyledCellType(),
    );
  }

  Map<String, dynamic> toJson() {
    final cellType = this.cellType;
    return {
      'CellType': cellType.toValue(),
    };
  }
}

enum TableTotalsPlacement {
  start,
  end,
  auto,
}

extension TableTotalsPlacementValueExtension on TableTotalsPlacement {
  String toValue() {
    switch (this) {
      case TableTotalsPlacement.start:
        return 'START';
      case TableTotalsPlacement.end:
        return 'END';
      case TableTotalsPlacement.auto:
        return 'AUTO';
    }
  }
}

extension TableTotalsPlacementFromString on String {
  TableTotalsPlacement toTableTotalsPlacement() {
    switch (this) {
      case 'START':
        return TableTotalsPlacement.start;
      case 'END':
        return TableTotalsPlacement.end;
      case 'AUTO':
        return TableTotalsPlacement.auto;
    }
    throw Exception('$this is not known in enum TableTotalsPlacement');
  }
}

enum TableTotalsScrollStatus {
  pinned,
  scrolled,
}

extension TableTotalsScrollStatusValueExtension on TableTotalsScrollStatus {
  String toValue() {
    switch (this) {
      case TableTotalsScrollStatus.pinned:
        return 'PINNED';
      case TableTotalsScrollStatus.scrolled:
        return 'SCROLLED';
    }
  }
}

extension TableTotalsScrollStatusFromString on String {
  TableTotalsScrollStatus toTableTotalsScrollStatus() {
    switch (this) {
      case 'PINNED':
        return TableTotalsScrollStatus.pinned;
      case 'SCROLLED':
        return TableTotalsScrollStatus.scrolled;
    }
    throw Exception('$this is not known in enum TableTotalsScrollStatus');
  }
}

/// The unaggregated field well for the table.
class TableUnaggregatedFieldWells {
  /// The values field well for a pivot table. Values are unaggregated for an
  /// unaggregated table.
  final List<UnaggregatedField>? values;

  TableUnaggregatedFieldWells({
    this.values,
  });

  factory TableUnaggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return TableUnaggregatedFieldWells(
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => UnaggregatedField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final values = this.values;
    return {
      if (values != null) 'Values': values,
    };
  }
}

/// A table visual.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using
/// tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.
class TableVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final TableConfiguration? chartConfiguration;

  /// The conditional formatting for a <code>PivotTableVisual</code>.
  final TableConditionalFormatting? conditionalFormatting;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  TableVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.conditionalFormatting,
    this.subtitle,
    this.title,
  });

  factory TableVisual.fromJson(Map<String, dynamic> json) {
    return TableVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? TableConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      conditionalFormatting: json['ConditionalFormatting'] != null
          ? TableConditionalFormatting.fromJson(
              json['ConditionalFormatting'] as Map<String, dynamic>)
          : null,
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final conditionalFormatting = this.conditionalFormatting;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (conditionalFormatting != null)
        'ConditionalFormatting': conditionalFormatting,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The key or keys of the key-value pairs for the resource tag or tags assigned
/// to the resource.
class Tag {
  /// Tag key.
  final String key;

  /// Tag value.
  final String value;

  Tag({
    required this.key,
    required this.value,
  });

  factory Tag.fromJson(Map<String, dynamic> json) {
    return Tag(
      key: json['Key'] as String,
      value: json['Value'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final key = this.key;
    final value = this.value;
    return {
      'Key': key,
      'Value': value,
    };
  }
}

/// A transform operation that tags a column with additional information.
class TagColumnOperation {
  /// The column that this operation acts on.
  final String columnName;

  /// The dataset column tag, currently only used for geospatial type tagging.
  /// <note>
  /// This is not tags for the Amazon Web Services tagging feature.
  /// </note>
  final List<ColumnTag> tags;

  TagColumnOperation({
    required this.columnName,
    required this.tags,
  });

  factory TagColumnOperation.fromJson(Map<String, dynamic> json) {
    return TagColumnOperation(
      columnName: json['ColumnName'] as String,
      tags: (json['Tags'] as List)
          .whereNotNull()
          .map((e) => ColumnTag.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final tags = this.tags;
    return {
      'ColumnName': columnName,
      'Tags': tags,
    };
  }
}

class TagResourceResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  TagResourceResponse({
    this.requestId,
    this.status,
  });

  factory TagResourceResponse.fromJson(Map<String, dynamic> json) {
    return TagResourceResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

enum TargetVisualOptions {
  allVisuals,
}

extension TargetVisualOptionsValueExtension on TargetVisualOptions {
  String toValue() {
    switch (this) {
      case TargetVisualOptions.allVisuals:
        return 'ALL_VISUALS';
    }
  }
}

extension TargetVisualOptionsFromString on String {
  TargetVisualOptions toTargetVisualOptions() {
    switch (this) {
      case 'ALL_VISUALS':
        return TargetVisualOptions.allVisuals;
    }
    throw Exception('$this is not known in enum TargetVisualOptions');
  }
}

/// A template object. A <i>template</i> is an entity in Amazon QuickSight that
/// encapsulates the metadata required to create an analysis and that you can
/// use to create a dashboard. A template adds a layer of abstraction by using
/// placeholders to replace the dataset associated with an analysis. You can use
/// templates to create dashboards by replacing dataset placeholders with
/// datasets that follow the same schema that was used to create the source
/// analysis and template.
///
/// You can share templates across Amazon Web Services accounts by allowing
/// users in other Amazon Web Services accounts to create a template or a
/// dashboard from an existing template.
class Template {
  /// The Amazon Resource Name (ARN) of the template.
  final String? arn;

  /// Time when this was created.
  final DateTime? createdTime;

  /// Time when this was last updated.
  final DateTime? lastUpdatedTime;

  /// The display name of the template.
  final String? name;

  /// The ID for the template. This is unique per Amazon Web Services Region for
  /// each Amazon Web Services account.
  final String? templateId;

  /// A structure describing the versions of the template.
  final TemplateVersion? version;

  Template({
    this.arn,
    this.createdTime,
    this.lastUpdatedTime,
    this.name,
    this.templateId,
    this.version,
  });

  factory Template.fromJson(Map<String, dynamic> json) {
    return Template(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      templateId: json['TemplateId'] as String?,
      version: json['Version'] != null
          ? TemplateVersion.fromJson(json['Version'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final templateId = this.templateId;
    final version = this.version;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (templateId != null) 'TemplateId': templateId,
      if (version != null) 'Version': version,
    };
  }
}

/// The template alias.
class TemplateAlias {
  /// The display name of the template alias.
  final String? aliasName;

  /// The Amazon Resource Name (ARN) of the template alias.
  final String? arn;

  /// The version number of the template alias.
  final int? templateVersionNumber;

  TemplateAlias({
    this.aliasName,
    this.arn,
    this.templateVersionNumber,
  });

  factory TemplateAlias.fromJson(Map<String, dynamic> json) {
    return TemplateAlias(
      aliasName: json['AliasName'] as String?,
      arn: json['Arn'] as String?,
      templateVersionNumber: json['TemplateVersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final aliasName = this.aliasName;
    final arn = this.arn;
    final templateVersionNumber = this.templateVersionNumber;
    return {
      if (aliasName != null) 'AliasName': aliasName,
      if (arn != null) 'Arn': arn,
      if (templateVersionNumber != null)
        'TemplateVersionNumber': templateVersionNumber,
    };
  }
}

/// List of errors that occurred when the template version creation failed.
class TemplateError {
  /// Description of the error type.
  final String? message;

  /// Type of error.
  final TemplateErrorType? type;

  /// An error path that shows which entities caused the template error.
  final List<Entity>? violatedEntities;

  TemplateError({
    this.message,
    this.type,
    this.violatedEntities,
  });

  factory TemplateError.fromJson(Map<String, dynamic> json) {
    return TemplateError(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toTemplateErrorType(),
      violatedEntities: (json['ViolatedEntities'] as List?)
          ?.whereNotNull()
          .map((e) => Entity.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    final violatedEntities = this.violatedEntities;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
      if (violatedEntities != null) 'ViolatedEntities': violatedEntities,
    };
  }
}

enum TemplateErrorType {
  sourceNotFound,
  dataSetNotFound,
  internalFailure,
  accessDenied,
}

extension TemplateErrorTypeValueExtension on TemplateErrorType {
  String toValue() {
    switch (this) {
      case TemplateErrorType.sourceNotFound:
        return 'SOURCE_NOT_FOUND';
      case TemplateErrorType.dataSetNotFound:
        return 'DATA_SET_NOT_FOUND';
      case TemplateErrorType.internalFailure:
        return 'INTERNAL_FAILURE';
      case TemplateErrorType.accessDenied:
        return 'ACCESS_DENIED';
    }
  }
}

extension TemplateErrorTypeFromString on String {
  TemplateErrorType toTemplateErrorType() {
    switch (this) {
      case 'SOURCE_NOT_FOUND':
        return TemplateErrorType.sourceNotFound;
      case 'DATA_SET_NOT_FOUND':
        return TemplateErrorType.dataSetNotFound;
      case 'INTERNAL_FAILURE':
        return TemplateErrorType.internalFailure;
      case 'ACCESS_DENIED':
        return TemplateErrorType.accessDenied;
    }
    throw Exception('$this is not known in enum TemplateErrorType');
  }
}

/// The source analysis of the template.
class TemplateSourceAnalysis {
  /// The Amazon Resource Name (ARN) of the resource.
  final String arn;

  /// A structure containing information about the dataset references used as
  /// placeholders in the template.
  final List<DataSetReference> dataSetReferences;

  TemplateSourceAnalysis({
    required this.arn,
    required this.dataSetReferences,
  });

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSetReferences = this.dataSetReferences;
    return {
      'Arn': arn,
      'DataSetReferences': dataSetReferences,
    };
  }
}

/// The source entity of the template.
class TemplateSourceEntity {
  /// The source analysis, if it is based on an analysis.
  final TemplateSourceAnalysis? sourceAnalysis;

  /// The source template, if it is based on an template.
  final TemplateSourceTemplate? sourceTemplate;

  TemplateSourceEntity({
    this.sourceAnalysis,
    this.sourceTemplate,
  });

  Map<String, dynamic> toJson() {
    final sourceAnalysis = this.sourceAnalysis;
    final sourceTemplate = this.sourceTemplate;
    return {
      if (sourceAnalysis != null) 'SourceAnalysis': sourceAnalysis,
      if (sourceTemplate != null) 'SourceTemplate': sourceTemplate,
    };
  }
}

/// The source template of the template.
class TemplateSourceTemplate {
  /// The Amazon Resource Name (ARN) of the resource.
  final String arn;

  TemplateSourceTemplate({
    required this.arn,
  });

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    return {
      'Arn': arn,
    };
  }
}

/// The template summary.
class TemplateSummary {
  /// A summary of a template.
  final String? arn;

  /// The last time that this template was created.
  final DateTime? createdTime;

  /// The last time that this template was updated.
  final DateTime? lastUpdatedTime;

  /// A structure containing a list of version numbers for the template summary.
  final int? latestVersionNumber;

  /// A display name for the template.
  final String? name;

  /// The ID of the template. This ID is unique per Amazon Web Services Region for
  /// each Amazon Web Services account.
  final String? templateId;

  TemplateSummary({
    this.arn,
    this.createdTime,
    this.lastUpdatedTime,
    this.latestVersionNumber,
    this.name,
    this.templateId,
  });

  factory TemplateSummary.fromJson(Map<String, dynamic> json) {
    return TemplateSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      latestVersionNumber: json['LatestVersionNumber'] as int?,
      name: json['Name'] as String?,
      templateId: json['TemplateId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final latestVersionNumber = this.latestVersionNumber;
    final name = this.name;
    final templateId = this.templateId;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (latestVersionNumber != null)
        'LatestVersionNumber': latestVersionNumber,
      if (name != null) 'Name': name,
      if (templateId != null) 'TemplateId': templateId,
    };
  }
}

/// A version of a template.
class TemplateVersion {
  /// The time that this template version was created.
  final DateTime? createdTime;

  /// Schema of the dataset identified by the placeholder. Any dashboard created
  /// from this template should be bound to new datasets matching the same schema
  /// described through this API operation.
  final List<DataSetConfiguration>? dataSetConfigurations;

  /// The description of the template.
  final String? description;

  /// Errors associated with this template version.
  final List<TemplateError>? errors;

  /// A list of the associated sheets with the unique identifier and name of each
  /// sheet.
  final List<Sheet>? sheets;

  /// The Amazon Resource Name (ARN) of an analysis or template that was used to
  /// create this template.
  final String? sourceEntityArn;

  /// The status that is associated with the template.
  ///
  /// <ul>
  /// <li>
  /// <code>CREATION_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>CREATION_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>CREATION_FAILED</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_IN_PROGRESS</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_SUCCESSFUL</code>
  /// </li>
  /// <li>
  /// <code>UPDATE_FAILED</code>
  /// </li>
  /// <li>
  /// <code>DELETED</code>
  /// </li>
  /// </ul>
  final ResourceStatus? status;

  /// The ARN of the theme associated with this version of the template.
  final String? themeArn;

  /// The version number of the template version.
  final int? versionNumber;

  TemplateVersion({
    this.createdTime,
    this.dataSetConfigurations,
    this.description,
    this.errors,
    this.sheets,
    this.sourceEntityArn,
    this.status,
    this.themeArn,
    this.versionNumber,
  });

  factory TemplateVersion.fromJson(Map<String, dynamic> json) {
    return TemplateVersion(
      createdTime: timeStampFromJson(json['CreatedTime']),
      dataSetConfigurations: (json['DataSetConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) => DataSetConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      description: json['Description'] as String?,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => TemplateError.fromJson(e as Map<String, dynamic>))
          .toList(),
      sheets: (json['Sheets'] as List?)
          ?.whereNotNull()
          .map((e) => Sheet.fromJson(e as Map<String, dynamic>))
          .toList(),
      sourceEntityArn: json['SourceEntityArn'] as String?,
      status: (json['Status'] as String?)?.toResourceStatus(),
      themeArn: json['ThemeArn'] as String?,
      versionNumber: json['VersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final createdTime = this.createdTime;
    final dataSetConfigurations = this.dataSetConfigurations;
    final description = this.description;
    final errors = this.errors;
    final sheets = this.sheets;
    final sourceEntityArn = this.sourceEntityArn;
    final status = this.status;
    final themeArn = this.themeArn;
    final versionNumber = this.versionNumber;
    return {
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dataSetConfigurations != null)
        'DataSetConfigurations': dataSetConfigurations,
      if (description != null) 'Description': description,
      if (errors != null) 'Errors': errors,
      if (sheets != null) 'Sheets': sheets,
      if (sourceEntityArn != null) 'SourceEntityArn': sourceEntityArn,
      if (status != null) 'Status': status.toValue(),
      if (themeArn != null) 'ThemeArn': themeArn,
      if (versionNumber != null) 'VersionNumber': versionNumber,
    };
  }
}

/// The detailed definition of a template.
class TemplateVersionDefinition {
  /// An array of dataset configurations. These configurations define the required
  /// columns for each dataset used within a template.
  final List<DataSetConfiguration> dataSetConfigurations;
  final AnalysisDefaults? analysisDefaults;

  /// An array of calculated field definitions for the template.
  final List<CalculatedField>? calculatedFields;

  /// An array of template-level column configurations. Column configurations are
  /// used to set default formatting for a column that's used throughout a
  /// template.
  final List<ColumnConfiguration>? columnConfigurations;

  /// Filter definitions for a template.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/filtering-visual-data.html">Filtering
  /// Data</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<FilterGroup>? filterGroups;

  /// An array of option definitions for a template.
  final AssetOptions? options;

  /// An array of parameter declarations for a template.
  ///
  /// <i>Parameters</i> are named variables that can transfer a value for use by
  /// an action or an object.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/parameters-in-quicksight.html">Parameters
  /// in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide</i>.
  final List<ParameterDeclaration>? parameterDeclarations;

  /// An array of sheet definitions for a template.
  final List<SheetDefinition>? sheets;

  TemplateVersionDefinition({
    required this.dataSetConfigurations,
    this.analysisDefaults,
    this.calculatedFields,
    this.columnConfigurations,
    this.filterGroups,
    this.options,
    this.parameterDeclarations,
    this.sheets,
  });

  factory TemplateVersionDefinition.fromJson(Map<String, dynamic> json) {
    return TemplateVersionDefinition(
      dataSetConfigurations: (json['DataSetConfigurations'] as List)
          .whereNotNull()
          .map((e) => DataSetConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      analysisDefaults: json['AnalysisDefaults'] != null
          ? AnalysisDefaults.fromJson(
              json['AnalysisDefaults'] as Map<String, dynamic>)
          : null,
      calculatedFields: (json['CalculatedFields'] as List?)
          ?.whereNotNull()
          .map((e) => CalculatedField.fromJson(e as Map<String, dynamic>))
          .toList(),
      columnConfigurations: (json['ColumnConfigurations'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      filterGroups: (json['FilterGroups'] as List?)
          ?.whereNotNull()
          .map((e) => FilterGroup.fromJson(e as Map<String, dynamic>))
          .toList(),
      options: json['Options'] != null
          ? AssetOptions.fromJson(json['Options'] as Map<String, dynamic>)
          : null,
      parameterDeclarations: (json['ParameterDeclarations'] as List?)
          ?.whereNotNull()
          .map((e) => ParameterDeclaration.fromJson(e as Map<String, dynamic>))
          .toList(),
      sheets: (json['Sheets'] as List?)
          ?.whereNotNull()
          .map((e) => SheetDefinition.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetConfigurations = this.dataSetConfigurations;
    final analysisDefaults = this.analysisDefaults;
    final calculatedFields = this.calculatedFields;
    final columnConfigurations = this.columnConfigurations;
    final filterGroups = this.filterGroups;
    final options = this.options;
    final parameterDeclarations = this.parameterDeclarations;
    final sheets = this.sheets;
    return {
      'DataSetConfigurations': dataSetConfigurations,
      if (analysisDefaults != null) 'AnalysisDefaults': analysisDefaults,
      if (calculatedFields != null) 'CalculatedFields': calculatedFields,
      if (columnConfigurations != null)
        'ColumnConfigurations': columnConfigurations,
      if (filterGroups != null) 'FilterGroups': filterGroups,
      if (options != null) 'Options': options,
      if (parameterDeclarations != null)
        'ParameterDeclarations': parameterDeclarations,
      if (sheets != null) 'Sheets': sheets,
    };
  }
}

/// The template version.
class TemplateVersionSummary {
  /// The Amazon Resource Name (ARN) of the template version.
  final String? arn;

  /// The time that this template version was created.
  final DateTime? createdTime;

  /// The description of the template version.
  final String? description;

  /// The status of the template version.
  final ResourceStatus? status;

  /// The version number of the template version.
  final int? versionNumber;

  TemplateVersionSummary({
    this.arn,
    this.createdTime,
    this.description,
    this.status,
    this.versionNumber,
  });

  factory TemplateVersionSummary.fromJson(Map<String, dynamic> json) {
    return TemplateVersionSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      description: json['Description'] as String?,
      status: (json['Status'] as String?)?.toResourceStatus(),
      versionNumber: json['VersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final description = this.description;
    final status = this.status;
    final versionNumber = this.versionNumber;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (description != null) 'Description': description,
      if (status != null) 'Status': status.toValue(),
      if (versionNumber != null) 'VersionNumber': versionNumber,
    };
  }
}

/// The parameters for Teradata.
class TeradataParameters {
  /// Database.
  final String database;

  /// Host.
  final String host;

  /// Port.
  final int port;

  TeradataParameters({
    required this.database,
    required this.host,
    required this.port,
  });

  factory TeradataParameters.fromJson(Map<String, dynamic> json) {
    return TeradataParameters(
      database: json['Database'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final database = this.database;
    final host = this.host;
    final port = this.port;
    return {
      'Database': database,
      'Host': host,
      'Port': port,
    };
  }
}

/// The display options of a control.
class TextAreaControlDisplayOptions {
  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The configuration of the placeholder options in a text area control.
  final TextControlPlaceholderOptions? placeholderOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  TextAreaControlDisplayOptions({
    this.infoIconLabelOptions,
    this.placeholderOptions,
    this.titleOptions,
  });

  factory TextAreaControlDisplayOptions.fromJson(Map<String, dynamic> json) {
    return TextAreaControlDisplayOptions(
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      placeholderOptions: json['PlaceholderOptions'] != null
          ? TextControlPlaceholderOptions.fromJson(
              json['PlaceholderOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final placeholderOptions = this.placeholderOptions;
    final titleOptions = this.titleOptions;
    return {
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (placeholderOptions != null) 'PlaceholderOptions': placeholderOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

/// The conditional formatting for the text.
class TextConditionalFormat {
  /// The conditional formatting for the text background color.
  final ConditionalFormattingColor? backgroundColor;

  /// The conditional formatting for the icon.
  final ConditionalFormattingIcon? icon;

  /// The conditional formatting for the text color.
  final ConditionalFormattingColor? textColor;

  TextConditionalFormat({
    this.backgroundColor,
    this.icon,
    this.textColor,
  });

  factory TextConditionalFormat.fromJson(Map<String, dynamic> json) {
    return TextConditionalFormat(
      backgroundColor: json['BackgroundColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['BackgroundColor'] as Map<String, dynamic>)
          : null,
      icon: json['Icon'] != null
          ? ConditionalFormattingIcon.fromJson(
              json['Icon'] as Map<String, dynamic>)
          : null,
      textColor: json['TextColor'] != null
          ? ConditionalFormattingColor.fromJson(
              json['TextColor'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final backgroundColor = this.backgroundColor;
    final icon = this.icon;
    final textColor = this.textColor;
    return {
      if (backgroundColor != null) 'BackgroundColor': backgroundColor,
      if (icon != null) 'Icon': icon,
      if (textColor != null) 'TextColor': textColor,
    };
  }
}

/// The configuration of the placeholder options in a text control.
class TextControlPlaceholderOptions {
  /// The visibility configuration of the placeholder options in a text control.
  final Visibility? visibility;

  TextControlPlaceholderOptions({
    this.visibility,
  });

  factory TextControlPlaceholderOptions.fromJson(Map<String, dynamic> json) {
    return TextControlPlaceholderOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The display options of a control.
class TextFieldControlDisplayOptions {
  /// The configuration of info icon label options.
  final SheetControlInfoIconLabelOptions? infoIconLabelOptions;

  /// The configuration of the placeholder options in a text field control.
  final TextControlPlaceholderOptions? placeholderOptions;

  /// The options to configure the title visibility, name, and font size.
  final LabelOptions? titleOptions;

  TextFieldControlDisplayOptions({
    this.infoIconLabelOptions,
    this.placeholderOptions,
    this.titleOptions,
  });

  factory TextFieldControlDisplayOptions.fromJson(Map<String, dynamic> json) {
    return TextFieldControlDisplayOptions(
      infoIconLabelOptions: json['InfoIconLabelOptions'] != null
          ? SheetControlInfoIconLabelOptions.fromJson(
              json['InfoIconLabelOptions'] as Map<String, dynamic>)
          : null,
      placeholderOptions: json['PlaceholderOptions'] != null
          ? TextControlPlaceholderOptions.fromJson(
              json['PlaceholderOptions'] as Map<String, dynamic>)
          : null,
      titleOptions: json['TitleOptions'] != null
          ? LabelOptions.fromJson(json['TitleOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final infoIconLabelOptions = this.infoIconLabelOptions;
    final placeholderOptions = this.placeholderOptions;
    final titleOptions = this.titleOptions;
    return {
      if (infoIconLabelOptions != null)
        'InfoIconLabelOptions': infoIconLabelOptions,
      if (placeholderOptions != null) 'PlaceholderOptions': placeholderOptions,
      if (titleOptions != null) 'TitleOptions': titleOptions,
    };
  }
}

enum TextQualifier {
  doubleQuote,
  singleQuote,
}

extension TextQualifierValueExtension on TextQualifier {
  String toValue() {
    switch (this) {
      case TextQualifier.doubleQuote:
        return 'DOUBLE_QUOTE';
      case TextQualifier.singleQuote:
        return 'SINGLE_QUOTE';
    }
  }
}

extension TextQualifierFromString on String {
  TextQualifier toTextQualifier() {
    switch (this) {
      case 'DOUBLE_QUOTE':
        return TextQualifier.doubleQuote;
      case 'SINGLE_QUOTE':
        return TextQualifier.singleQuote;
    }
    throw Exception('$this is not known in enum TextQualifier');
  }
}

enum TextWrap {
  none,
  wrap,
}

extension TextWrapValueExtension on TextWrap {
  String toValue() {
    switch (this) {
      case TextWrap.none:
        return 'NONE';
      case TextWrap.wrap:
        return 'WRAP';
    }
  }
}

extension TextWrapFromString on String {
  TextWrap toTextWrap() {
    switch (this) {
      case 'NONE':
        return TextWrap.none;
      case 'WRAP':
        return TextWrap.wrap;
    }
    throw Exception('$this is not known in enum TextWrap');
  }
}

/// Summary information about a theme.
class Theme {
  /// The Amazon Resource Name (ARN) of the theme.
  final String? arn;

  /// The date and time that the theme was created.
  final DateTime? createdTime;

  /// The date and time that the theme was last updated.
  final DateTime? lastUpdatedTime;

  /// The name that the user gives to the theme.
  final String? name;

  /// The identifier that the user gives to the theme.
  final String? themeId;

  /// The type of theme, based on how it was created. Valid values include:
  /// <code>QUICKSIGHT</code> and <code>CUSTOM</code>.
  final ThemeType? type;
  final ThemeVersion? version;

  Theme({
    this.arn,
    this.createdTime,
    this.lastUpdatedTime,
    this.name,
    this.themeId,
    this.type,
    this.version,
  });

  factory Theme.fromJson(Map<String, dynamic> json) {
    return Theme(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      themeId: json['ThemeId'] as String?,
      type: (json['Type'] as String?)?.toThemeType(),
      version: json['Version'] != null
          ? ThemeVersion.fromJson(json['Version'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final themeId = this.themeId;
    final type = this.type;
    final version = this.version;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (themeId != null) 'ThemeId': themeId,
      if (type != null) 'Type': type.toValue(),
      if (version != null) 'Version': version,
    };
  }
}

/// An alias for a theme.
class ThemeAlias {
  /// The display name of the theme alias.
  final String? aliasName;

  /// The Amazon Resource Name (ARN) of the theme alias.
  final String? arn;

  /// The version number of the theme alias.
  final int? themeVersionNumber;

  ThemeAlias({
    this.aliasName,
    this.arn,
    this.themeVersionNumber,
  });

  factory ThemeAlias.fromJson(Map<String, dynamic> json) {
    return ThemeAlias(
      aliasName: json['AliasName'] as String?,
      arn: json['Arn'] as String?,
      themeVersionNumber: json['ThemeVersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final aliasName = this.aliasName;
    final arn = this.arn;
    final themeVersionNumber = this.themeVersionNumber;
    return {
      if (aliasName != null) 'AliasName': aliasName,
      if (arn != null) 'Arn': arn,
      if (themeVersionNumber != null) 'ThemeVersionNumber': themeVersionNumber,
    };
  }
}

/// The theme configuration. This configuration contains all of the display
/// properties for a theme.
class ThemeConfiguration {
  /// Color properties that apply to chart data colors.
  final DataColorPalette? dataColorPalette;

  /// Display options related to sheets.
  final SheetStyle? sheet;
  final Typography? typography;

  /// Color properties that apply to the UI and to charts, excluding the colors
  /// that apply to data.
  final UIColorPalette? uIColorPalette;

  ThemeConfiguration({
    this.dataColorPalette,
    this.sheet,
    this.typography,
    this.uIColorPalette,
  });

  factory ThemeConfiguration.fromJson(Map<String, dynamic> json) {
    return ThemeConfiguration(
      dataColorPalette: json['DataColorPalette'] != null
          ? DataColorPalette.fromJson(
              json['DataColorPalette'] as Map<String, dynamic>)
          : null,
      sheet: json['Sheet'] != null
          ? SheetStyle.fromJson(json['Sheet'] as Map<String, dynamic>)
          : null,
      typography: json['Typography'] != null
          ? Typography.fromJson(json['Typography'] as Map<String, dynamic>)
          : null,
      uIColorPalette: json['UIColorPalette'] != null
          ? UIColorPalette.fromJson(
              json['UIColorPalette'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final dataColorPalette = this.dataColorPalette;
    final sheet = this.sheet;
    final typography = this.typography;
    final uIColorPalette = this.uIColorPalette;
    return {
      if (dataColorPalette != null) 'DataColorPalette': dataColorPalette,
      if (sheet != null) 'Sheet': sheet,
      if (typography != null) 'Typography': typography,
      if (uIColorPalette != null) 'UIColorPalette': uIColorPalette,
    };
  }
}

/// Theme error.
class ThemeError {
  /// The error message.
  final String? message;

  /// The type of error.
  final ThemeErrorType? type;

  ThemeError({
    this.message,
    this.type,
  });

  factory ThemeError.fromJson(Map<String, dynamic> json) {
    return ThemeError(
      message: json['Message'] as String?,
      type: (json['Type'] as String?)?.toThemeErrorType(),
    );
  }

  Map<String, dynamic> toJson() {
    final message = this.message;
    final type = this.type;
    return {
      if (message != null) 'Message': message,
      if (type != null) 'Type': type.toValue(),
    };
  }
}

enum ThemeErrorType {
  internalFailure,
}

extension ThemeErrorTypeValueExtension on ThemeErrorType {
  String toValue() {
    switch (this) {
      case ThemeErrorType.internalFailure:
        return 'INTERNAL_FAILURE';
    }
  }
}

extension ThemeErrorTypeFromString on String {
  ThemeErrorType toThemeErrorType() {
    switch (this) {
      case 'INTERNAL_FAILURE':
        return ThemeErrorType.internalFailure;
    }
    throw Exception('$this is not known in enum ThemeErrorType');
  }
}

/// The theme summary.
class ThemeSummary {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The date and time that this theme was created.
  final DateTime? createdTime;

  /// The last date and time that this theme was updated.
  final DateTime? lastUpdatedTime;

  /// The latest version number for the theme.
  final int? latestVersionNumber;

  /// the display name for the theme.
  final String? name;

  /// The ID of the theme. This ID is unique per Amazon Web Services Region for
  /// each Amazon Web Services account.
  final String? themeId;

  ThemeSummary({
    this.arn,
    this.createdTime,
    this.lastUpdatedTime,
    this.latestVersionNumber,
    this.name,
    this.themeId,
  });

  factory ThemeSummary.fromJson(Map<String, dynamic> json) {
    return ThemeSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      latestVersionNumber: json['LatestVersionNumber'] as int?,
      name: json['Name'] as String?,
      themeId: json['ThemeId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final lastUpdatedTime = this.lastUpdatedTime;
    final latestVersionNumber = this.latestVersionNumber;
    final name = this.name;
    final themeId = this.themeId;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (latestVersionNumber != null)
        'LatestVersionNumber': latestVersionNumber,
      if (name != null) 'Name': name,
      if (themeId != null) 'ThemeId': themeId,
    };
  }
}

enum ThemeType {
  quicksight,
  custom,
  all,
}

extension ThemeTypeValueExtension on ThemeType {
  String toValue() {
    switch (this) {
      case ThemeType.quicksight:
        return 'QUICKSIGHT';
      case ThemeType.custom:
        return 'CUSTOM';
      case ThemeType.all:
        return 'ALL';
    }
  }
}

extension ThemeTypeFromString on String {
  ThemeType toThemeType() {
    switch (this) {
      case 'QUICKSIGHT':
        return ThemeType.quicksight;
      case 'CUSTOM':
        return ThemeType.custom;
      case 'ALL':
        return ThemeType.all;
    }
    throw Exception('$this is not known in enum ThemeType');
  }
}

/// A version of a theme.
class ThemeVersion {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The Amazon QuickSight-defined ID of the theme that a custom theme inherits
  /// from. All themes initially inherit from a default Amazon QuickSight theme.
  final String? baseThemeId;

  /// The theme configuration, which contains all the theme display properties.
  final ThemeConfiguration? configuration;

  /// The date and time that this theme version was created.
  final DateTime? createdTime;

  /// The description of the theme.
  final String? description;

  /// Errors associated with the theme.
  final List<ThemeError>? errors;

  /// The status of the theme version.
  final ResourceStatus? status;

  /// The version number of the theme.
  final int? versionNumber;

  ThemeVersion({
    this.arn,
    this.baseThemeId,
    this.configuration,
    this.createdTime,
    this.description,
    this.errors,
    this.status,
    this.versionNumber,
  });

  factory ThemeVersion.fromJson(Map<String, dynamic> json) {
    return ThemeVersion(
      arn: json['Arn'] as String?,
      baseThemeId: json['BaseThemeId'] as String?,
      configuration: json['Configuration'] != null
          ? ThemeConfiguration.fromJson(
              json['Configuration'] as Map<String, dynamic>)
          : null,
      createdTime: timeStampFromJson(json['CreatedTime']),
      description: json['Description'] as String?,
      errors: (json['Errors'] as List?)
          ?.whereNotNull()
          .map((e) => ThemeError.fromJson(e as Map<String, dynamic>))
          .toList(),
      status: (json['Status'] as String?)?.toResourceStatus(),
      versionNumber: json['VersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final baseThemeId = this.baseThemeId;
    final configuration = this.configuration;
    final createdTime = this.createdTime;
    final description = this.description;
    final errors = this.errors;
    final status = this.status;
    final versionNumber = this.versionNumber;
    return {
      if (arn != null) 'Arn': arn,
      if (baseThemeId != null) 'BaseThemeId': baseThemeId,
      if (configuration != null) 'Configuration': configuration,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (description != null) 'Description': description,
      if (errors != null) 'Errors': errors,
      if (status != null) 'Status': status.toValue(),
      if (versionNumber != null) 'VersionNumber': versionNumber,
    };
  }
}

/// The theme version.
class ThemeVersionSummary {
  /// The Amazon Resource Name (ARN) of the theme version.
  final String? arn;

  /// The date and time that this theme version was created.
  final DateTime? createdTime;

  /// The description of the theme version.
  final String? description;

  /// The status of the theme version.
  final ResourceStatus? status;

  /// The version number of the theme version.
  final int? versionNumber;

  ThemeVersionSummary({
    this.arn,
    this.createdTime,
    this.description,
    this.status,
    this.versionNumber,
  });

  factory ThemeVersionSummary.fromJson(Map<String, dynamic> json) {
    return ThemeVersionSummary(
      arn: json['Arn'] as String?,
      createdTime: timeStampFromJson(json['CreatedTime']),
      description: json['Description'] as String?,
      status: (json['Status'] as String?)?.toResourceStatus(),
      versionNumber: json['VersionNumber'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final createdTime = this.createdTime;
    final description = this.description;
    final status = this.status;
    final versionNumber = this.versionNumber;
    return {
      if (arn != null) 'Arn': arn,
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (description != null) 'Description': description,
      if (status != null) 'Status': status.toValue(),
      if (versionNumber != null) 'VersionNumber': versionNumber,
    };
  }
}

/// The options that determine the thousands separator configuration.
class ThousandSeparatorOptions {
  /// Determines the thousands separator symbol.
  final NumericSeparatorSymbol? symbol;

  /// Determines the visibility of the thousands separator.
  final Visibility? visibility;

  ThousandSeparatorOptions({
    this.symbol,
    this.visibility,
  });

  factory ThousandSeparatorOptions.fromJson(Map<String, dynamic> json) {
    return ThousandSeparatorOptions(
      symbol: (json['Symbol'] as String?)?.toNumericSeparatorSymbol(),
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final symbol = this.symbol;
    final visibility = this.visibility;
    return {
      if (symbol != null) 'Symbol': symbol.toValue(),
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The display options for the layout of tiles on a sheet.
class TileLayoutStyle {
  /// The gutter settings that apply between tiles.
  final GutterStyle? gutter;

  /// The margin settings that apply around the outside edge of sheets.
  final MarginStyle? margin;

  TileLayoutStyle({
    this.gutter,
    this.margin,
  });

  factory TileLayoutStyle.fromJson(Map<String, dynamic> json) {
    return TileLayoutStyle(
      gutter: json['Gutter'] != null
          ? GutterStyle.fromJson(json['Gutter'] as Map<String, dynamic>)
          : null,
      margin: json['Margin'] != null
          ? MarginStyle.fromJson(json['Margin'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final gutter = this.gutter;
    final margin = this.margin;
    return {
      if (gutter != null) 'Gutter': gutter,
      if (margin != null) 'Margin': margin,
    };
  }
}

/// Display options related to tiles on a sheet.
class TileStyle {
  /// The border around a tile.
  final BorderStyle? border;

  TileStyle({
    this.border,
  });

  factory TileStyle.fromJson(Map<String, dynamic> json) {
    return TileStyle(
      border: json['Border'] != null
          ? BorderStyle.fromJson(json['Border'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final border = this.border;
    return {
      if (border != null) 'Border': border,
    };
  }
}

/// The forecast properties setup of a forecast in the line chart.
class TimeBasedForecastProperties {
  /// The lower boundary setup of a forecast computation.
  final double? lowerBoundary;

  /// The periods backward setup of a forecast computation.
  final int? periodsBackward;

  /// The periods forward setup of a forecast computation.
  final int? periodsForward;

  /// The prediction interval setup of a forecast computation.
  final int? predictionInterval;

  /// The seasonality setup of a forecast computation. Choose one of the following
  /// options:
  ///
  /// <ul>
  /// <li>
  /// <code>NULL</code>: The input is set to <code>NULL</code>.
  /// </li>
  /// <li>
  /// <code>NON_NULL</code>: The input is set to a custom value.
  /// </li>
  /// </ul>
  final int? seasonality;

  /// The upper boundary setup of a forecast computation.
  final double? upperBoundary;

  TimeBasedForecastProperties({
    this.lowerBoundary,
    this.periodsBackward,
    this.periodsForward,
    this.predictionInterval,
    this.seasonality,
    this.upperBoundary,
  });

  factory TimeBasedForecastProperties.fromJson(Map<String, dynamic> json) {
    return TimeBasedForecastProperties(
      lowerBoundary: json['LowerBoundary'] as double?,
      periodsBackward: json['PeriodsBackward'] as int?,
      periodsForward: json['PeriodsForward'] as int?,
      predictionInterval: json['PredictionInterval'] as int?,
      seasonality: json['Seasonality'] as int?,
      upperBoundary: json['UpperBoundary'] as double?,
    );
  }

  Map<String, dynamic> toJson() {
    final lowerBoundary = this.lowerBoundary;
    final periodsBackward = this.periodsBackward;
    final periodsForward = this.periodsForward;
    final predictionInterval = this.predictionInterval;
    final seasonality = this.seasonality;
    final upperBoundary = this.upperBoundary;
    return {
      if (lowerBoundary != null) 'LowerBoundary': lowerBoundary,
      if (periodsBackward != null) 'PeriodsBackward': periodsBackward,
      if (periodsForward != null) 'PeriodsForward': periodsForward,
      if (predictionInterval != null) 'PredictionInterval': predictionInterval,
      if (seasonality != null) 'Seasonality': seasonality,
      if (upperBoundary != null) 'UpperBoundary': upperBoundary,
    };
  }
}

/// A <code>TimeEqualityFilter</code> filters values that are equal to a given
/// value.
class TimeEqualityFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  /// The parameter whose value should be used for the filter value.
  ///
  /// This field is mutually exclusive to <code>Value</code> and
  /// <code>RollingDate</code>.
  final String? parameterName;

  /// The rolling date input for the <code>TimeEquality</code> filter.
  ///
  /// This field is mutually exclusive to <code>Value</code> and
  /// <code>ParameterName</code>.
  final RollingDateConfiguration? rollingDate;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TimeGranularity? timeGranularity;

  /// The value of a <code>TimeEquality</code> filter.
  ///
  /// This field is mutually exclusive to <code>RollingDate</code> and
  /// <code>ParameterName</code>.
  final DateTime? value;

  TimeEqualityFilter({
    required this.column,
    required this.filterId,
    this.defaultFilterControlConfiguration,
    this.parameterName,
    this.rollingDate,
    this.timeGranularity,
    this.value,
  });

  factory TimeEqualityFilter.fromJson(Map<String, dynamic> json) {
    return TimeEqualityFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
      parameterName: json['ParameterName'] as String?,
      rollingDate: json['RollingDate'] != null
          ? RollingDateConfiguration.fromJson(
              json['RollingDate'] as Map<String, dynamic>)
          : null,
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTimeGranularity(),
      value: timeStampFromJson(json['Value']),
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final filterId = this.filterId;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    final parameterName = this.parameterName;
    final rollingDate = this.rollingDate;
    final timeGranularity = this.timeGranularity;
    final value = this.value;
    return {
      'Column': column,
      'FilterId': filterId,
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
      if (parameterName != null) 'ParameterName': parameterName,
      if (rollingDate != null) 'RollingDate': rollingDate,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
      if (value != null) 'Value': unixTimestampToJson(value),
    };
  }
}

enum TimeGranularity {
  year,
  quarter,
  month,
  week,
  day,
  hour,
  minute,
  second,
  millisecond,
}

extension TimeGranularityValueExtension on TimeGranularity {
  String toValue() {
    switch (this) {
      case TimeGranularity.year:
        return 'YEAR';
      case TimeGranularity.quarter:
        return 'QUARTER';
      case TimeGranularity.month:
        return 'MONTH';
      case TimeGranularity.week:
        return 'WEEK';
      case TimeGranularity.day:
        return 'DAY';
      case TimeGranularity.hour:
        return 'HOUR';
      case TimeGranularity.minute:
        return 'MINUTE';
      case TimeGranularity.second:
        return 'SECOND';
      case TimeGranularity.millisecond:
        return 'MILLISECOND';
    }
  }
}

extension TimeGranularityFromString on String {
  TimeGranularity toTimeGranularity() {
    switch (this) {
      case 'YEAR':
        return TimeGranularity.year;
      case 'QUARTER':
        return TimeGranularity.quarter;
      case 'MONTH':
        return TimeGranularity.month;
      case 'WEEK':
        return TimeGranularity.week;
      case 'DAY':
        return TimeGranularity.day;
      case 'HOUR':
        return TimeGranularity.hour;
      case 'MINUTE':
        return TimeGranularity.minute;
      case 'SECOND':
        return TimeGranularity.second;
      case 'MILLISECOND':
        return TimeGranularity.millisecond;
    }
    throw Exception('$this is not known in enum TimeGranularity');
  }
}

/// The time range drill down filter.
class TimeRangeDrillDownFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// The maximum value for the filter value range.
  final DateTime rangeMaximum;

  /// The minimum value for the filter value range.
  final DateTime rangeMinimum;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TimeGranularity timeGranularity;

  TimeRangeDrillDownFilter({
    required this.column,
    required this.rangeMaximum,
    required this.rangeMinimum,
    required this.timeGranularity,
  });

  factory TimeRangeDrillDownFilter.fromJson(Map<String, dynamic> json) {
    return TimeRangeDrillDownFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      rangeMaximum:
          nonNullableTimeStampFromJson(json['RangeMaximum'] as Object),
      rangeMinimum:
          nonNullableTimeStampFromJson(json['RangeMinimum'] as Object),
      timeGranularity: (json['TimeGranularity'] as String).toTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final rangeMaximum = this.rangeMaximum;
    final rangeMinimum = this.rangeMinimum;
    final timeGranularity = this.timeGranularity;
    return {
      'Column': column,
      'RangeMaximum': unixTimestampToJson(rangeMaximum),
      'RangeMinimum': unixTimestampToJson(rangeMinimum),
      'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// A <code>TimeRangeFilter</code> filters values that are between two specified
/// values.
class TimeRangeFilter {
  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// This option determines how null values should be treated when filtering
  /// data.
  ///
  /// <ul>
  /// <li>
  /// <code>ALL_VALUES</code>: Include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NULLS_ONLY</code>: Only include null values in filtered results.
  /// </li>
  /// <li>
  /// <code>NON_NULLS_ONLY</code>: Exclude null values from filtered results.
  /// </li>
  /// </ul>
  final FilterNullOption nullOption;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  /// The exclude period of the time range filter.
  final ExcludePeriodConfiguration? excludePeriodConfiguration;

  /// Determines whether the maximum value in the filter value range should be
  /// included in the filtered results.
  final bool? includeMaximum;

  /// Determines whether the minimum value in the filter value range should be
  /// included in the filtered results.
  final bool? includeMinimum;

  /// The maximum value for the filter value range.
  final TimeRangeFilterValue? rangeMaximumValue;

  /// The minimum value for the filter value range.
  final TimeRangeFilterValue? rangeMinimumValue;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TimeGranularity? timeGranularity;

  TimeRangeFilter({
    required this.column,
    required this.filterId,
    required this.nullOption,
    this.defaultFilterControlConfiguration,
    this.excludePeriodConfiguration,
    this.includeMaximum,
    this.includeMinimum,
    this.rangeMaximumValue,
    this.rangeMinimumValue,
    this.timeGranularity,
  });

  factory TimeRangeFilter.fromJson(Map<String, dynamic> json) {
    return TimeRangeFilter(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      nullOption: (json['NullOption'] as String).toFilterNullOption(),
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
      excludePeriodConfiguration: json['ExcludePeriodConfiguration'] != null
          ? ExcludePeriodConfiguration.fromJson(
              json['ExcludePeriodConfiguration'] as Map<String, dynamic>)
          : null,
      includeMaximum: json['IncludeMaximum'] as bool?,
      includeMinimum: json['IncludeMinimum'] as bool?,
      rangeMaximumValue: json['RangeMaximumValue'] != null
          ? TimeRangeFilterValue.fromJson(
              json['RangeMaximumValue'] as Map<String, dynamic>)
          : null,
      rangeMinimumValue: json['RangeMinimumValue'] != null
          ? TimeRangeFilterValue.fromJson(
              json['RangeMinimumValue'] as Map<String, dynamic>)
          : null,
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final filterId = this.filterId;
    final nullOption = this.nullOption;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    final excludePeriodConfiguration = this.excludePeriodConfiguration;
    final includeMaximum = this.includeMaximum;
    final includeMinimum = this.includeMinimum;
    final rangeMaximumValue = this.rangeMaximumValue;
    final rangeMinimumValue = this.rangeMinimumValue;
    final timeGranularity = this.timeGranularity;
    return {
      'Column': column,
      'FilterId': filterId,
      'NullOption': nullOption.toValue(),
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
      if (excludePeriodConfiguration != null)
        'ExcludePeriodConfiguration': excludePeriodConfiguration,
      if (includeMaximum != null) 'IncludeMaximum': includeMaximum,
      if (includeMinimum != null) 'IncludeMinimum': includeMinimum,
      if (rangeMaximumValue != null) 'RangeMaximumValue': rangeMaximumValue,
      if (rangeMinimumValue != null) 'RangeMinimumValue': rangeMinimumValue,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// The value of a time range filter.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class TimeRangeFilterValue {
  /// The parameter type input value.
  final String? parameter;

  /// The rolling date input value.
  final RollingDateConfiguration? rollingDate;

  /// The static input value.
  final DateTime? staticValue;

  TimeRangeFilterValue({
    this.parameter,
    this.rollingDate,
    this.staticValue,
  });

  factory TimeRangeFilterValue.fromJson(Map<String, dynamic> json) {
    return TimeRangeFilterValue(
      parameter: json['Parameter'] as String?,
      rollingDate: json['RollingDate'] != null
          ? RollingDateConfiguration.fromJson(
              json['RollingDate'] as Map<String, dynamic>)
          : null,
      staticValue: timeStampFromJson(json['StaticValue']),
    );
  }

  Map<String, dynamic> toJson() {
    final parameter = this.parameter;
    final rollingDate = this.rollingDate;
    final staticValue = this.staticValue;
    return {
      if (parameter != null) 'Parameter': parameter,
      if (rollingDate != null) 'RollingDate': rollingDate,
      if (staticValue != null) 'StaticValue': unixTimestampToJson(staticValue),
    };
  }
}

/// The tooltip.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class TooltipItem {
  /// The tooltip item for the columns that are not part of a field well.
  final ColumnTooltipItem? columnTooltipItem;

  /// The tooltip item for the fields.
  final FieldTooltipItem? fieldTooltipItem;

  TooltipItem({
    this.columnTooltipItem,
    this.fieldTooltipItem,
  });

  factory TooltipItem.fromJson(Map<String, dynamic> json) {
    return TooltipItem(
      columnTooltipItem: json['ColumnTooltipItem'] != null
          ? ColumnTooltipItem.fromJson(
              json['ColumnTooltipItem'] as Map<String, dynamic>)
          : null,
      fieldTooltipItem: json['FieldTooltipItem'] != null
          ? FieldTooltipItem.fromJson(
              json['FieldTooltipItem'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final columnTooltipItem = this.columnTooltipItem;
    final fieldTooltipItem = this.fieldTooltipItem;
    return {
      if (columnTooltipItem != null) 'ColumnTooltipItem': columnTooltipItem,
      if (fieldTooltipItem != null) 'FieldTooltipItem': fieldTooltipItem,
    };
  }
}

/// The display options for the visual tooltip.
class TooltipOptions {
  /// The setup for the detailed tooltip. The tooltip setup is always saved. The
  /// display type is decided based on the tooltip type.
  final FieldBasedTooltip? fieldBasedTooltip;

  /// The selected type for the tooltip. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// <code>BASIC</code>: A basic tooltip.
  /// </li>
  /// <li>
  /// <code>DETAILED</code>: A detailed tooltip.
  /// </li>
  /// </ul>
  final SelectedTooltipType? selectedTooltipType;

  /// Determines whether or not the tooltip is visible.
  final Visibility? tooltipVisibility;

  TooltipOptions({
    this.fieldBasedTooltip,
    this.selectedTooltipType,
    this.tooltipVisibility,
  });

  factory TooltipOptions.fromJson(Map<String, dynamic> json) {
    return TooltipOptions(
      fieldBasedTooltip: json['FieldBasedTooltip'] != null
          ? FieldBasedTooltip.fromJson(
              json['FieldBasedTooltip'] as Map<String, dynamic>)
          : null,
      selectedTooltipType:
          (json['SelectedTooltipType'] as String?)?.toSelectedTooltipType(),
      tooltipVisibility: (json['TooltipVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldBasedTooltip = this.fieldBasedTooltip;
    final selectedTooltipType = this.selectedTooltipType;
    final tooltipVisibility = this.tooltipVisibility;
    return {
      if (fieldBasedTooltip != null) 'FieldBasedTooltip': fieldBasedTooltip,
      if (selectedTooltipType != null)
        'SelectedTooltipType': selectedTooltipType.toValue(),
      if (tooltipVisibility != null)
        'TooltipVisibility': tooltipVisibility.toValue(),
    };
  }
}

enum TooltipTarget {
  both,
  bar,
  line,
}

extension TooltipTargetValueExtension on TooltipTarget {
  String toValue() {
    switch (this) {
      case TooltipTarget.both:
        return 'BOTH';
      case TooltipTarget.bar:
        return 'BAR';
      case TooltipTarget.line:
        return 'LINE';
    }
  }
}

extension TooltipTargetFromString on String {
  TooltipTarget toTooltipTarget() {
    switch (this) {
      case 'BOTH':
        return TooltipTarget.both;
      case 'BAR':
        return TooltipTarget.bar;
      case 'LINE':
        return TooltipTarget.line;
    }
    throw Exception('$this is not known in enum TooltipTarget');
  }
}

enum TooltipTitleType {
  none,
  primaryValue,
}

extension TooltipTitleTypeValueExtension on TooltipTitleType {
  String toValue() {
    switch (this) {
      case TooltipTitleType.none:
        return 'NONE';
      case TooltipTitleType.primaryValue:
        return 'PRIMARY_VALUE';
    }
  }
}

extension TooltipTitleTypeFromString on String {
  TooltipTitleType toTooltipTitleType() {
    switch (this) {
      case 'NONE':
        return TooltipTitleType.none;
      case 'PRIMARY_VALUE':
        return TooltipTitleType.primaryValue;
    }
    throw Exception('$this is not known in enum TooltipTitleType');
  }
}

enum TopBottomComputationType {
  top,
  bottom,
}

extension TopBottomComputationTypeValueExtension on TopBottomComputationType {
  String toValue() {
    switch (this) {
      case TopBottomComputationType.top:
        return 'TOP';
      case TopBottomComputationType.bottom:
        return 'BOTTOM';
    }
  }
}

extension TopBottomComputationTypeFromString on String {
  TopBottomComputationType toTopBottomComputationType() {
    switch (this) {
      case 'TOP':
        return TopBottomComputationType.top;
      case 'BOTTOM':
        return TopBottomComputationType.bottom;
    }
    throw Exception('$this is not known in enum TopBottomComputationType');
  }
}

/// A <code>TopBottomFilter</code> filters values that are at the top or the
/// bottom.
class TopBottomFilter {
  /// The aggregation and sort configuration of the top bottom filter.
  final List<AggregationSortConfiguration> aggregationSortConfigurations;

  /// The column that the filter is applied to.
  final ColumnIdentifier column;

  /// An identifier that uniquely identifies a filter within a dashboard,
  /// analysis, or template.
  final String filterId;

  /// The default configurations for the associated controls. This applies only
  /// for filters that are scoped to multiple sheets.
  final DefaultFilterControlConfiguration? defaultFilterControlConfiguration;

  /// The number of items to include in the top bottom filter results.
  final int? limit;

  /// The parameter whose value should be used for the filter value.
  final String? parameterName;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TimeGranularity? timeGranularity;

  TopBottomFilter({
    required this.aggregationSortConfigurations,
    required this.column,
    required this.filterId,
    this.defaultFilterControlConfiguration,
    this.limit,
    this.parameterName,
    this.timeGranularity,
  });

  factory TopBottomFilter.fromJson(Map<String, dynamic> json) {
    return TopBottomFilter(
      aggregationSortConfigurations: (json['AggregationSortConfigurations']
              as List)
          .whereNotNull()
          .map((e) =>
              AggregationSortConfiguration.fromJson(e as Map<String, dynamic>))
          .toList(),
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      filterId: json['FilterId'] as String,
      defaultFilterControlConfiguration:
          json['DefaultFilterControlConfiguration'] != null
              ? DefaultFilterControlConfiguration.fromJson(
                  json['DefaultFilterControlConfiguration']
                      as Map<String, dynamic>)
              : null,
      limit: json['Limit'] as int?,
      parameterName: json['ParameterName'] as String?,
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final aggregationSortConfigurations = this.aggregationSortConfigurations;
    final column = this.column;
    final filterId = this.filterId;
    final defaultFilterControlConfiguration =
        this.defaultFilterControlConfiguration;
    final limit = this.limit;
    final parameterName = this.parameterName;
    final timeGranularity = this.timeGranularity;
    return {
      'AggregationSortConfigurations': aggregationSortConfigurations,
      'Column': column,
      'FilterId': filterId,
      if (defaultFilterControlConfiguration != null)
        'DefaultFilterControlConfiguration': defaultFilterControlConfiguration,
      if (limit != null) 'Limit': limit,
      if (parameterName != null) 'ParameterName': parameterName,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// The top movers and bottom movers computation setup.
class TopBottomMoversComputation {
  /// The ID for a computation.
  final String computationId;

  /// The computation type. Choose from the following options:
  ///
  /// <ul>
  /// <li>
  /// TOP: Top movers computation.
  /// </li>
  /// <li>
  /// BOTTOM: Bottom movers computation.
  /// </li>
  /// </ul>
  final TopBottomComputationType type;

  /// The category field that is used in a computation.
  final DimensionField? category;

  /// The mover size setup of the top and bottom movers computation.
  final int? moverSize;

  /// The name of a computation.
  final String? name;

  /// The sort order setup of the top and bottom movers computation.
  final TopBottomSortOrder? sortOrder;

  /// The time field that is used in a computation.
  final DimensionField? time;

  /// The value field that is used in a computation.
  final MeasureField? value;

  TopBottomMoversComputation({
    required this.computationId,
    required this.type,
    this.category,
    this.moverSize,
    this.name,
    this.sortOrder,
    this.time,
    this.value,
  });

  factory TopBottomMoversComputation.fromJson(Map<String, dynamic> json) {
    return TopBottomMoversComputation(
      computationId: json['ComputationId'] as String,
      type: (json['Type'] as String).toTopBottomComputationType(),
      category: json['Category'] != null
          ? DimensionField.fromJson(json['Category'] as Map<String, dynamic>)
          : null,
      moverSize: json['MoverSize'] as int?,
      name: json['Name'] as String?,
      sortOrder: (json['SortOrder'] as String?)?.toTopBottomSortOrder(),
      time: json['Time'] != null
          ? DimensionField.fromJson(json['Time'] as Map<String, dynamic>)
          : null,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final type = this.type;
    final category = this.category;
    final moverSize = this.moverSize;
    final name = this.name;
    final sortOrder = this.sortOrder;
    final time = this.time;
    final value = this.value;
    return {
      'ComputationId': computationId,
      'Type': type.toValue(),
      if (category != null) 'Category': category,
      if (moverSize != null) 'MoverSize': moverSize,
      if (name != null) 'Name': name,
      if (sortOrder != null) 'SortOrder': sortOrder.toValue(),
      if (time != null) 'Time': time,
      if (value != null) 'Value': value,
    };
  }
}

/// The top ranked and bottom ranked computation configuration.
class TopBottomRankedComputation {
  /// The ID for a computation.
  final String computationId;

  /// The computation type. Choose one of the following options:
  ///
  /// <ul>
  /// <li>
  /// TOP: A top ranked computation.
  /// </li>
  /// <li>
  /// BOTTOM: A bottom ranked computation.
  /// </li>
  /// </ul>
  final TopBottomComputationType type;

  /// The category field that is used in a computation.
  final DimensionField? category;

  /// The name of a computation.
  final String? name;

  /// The result size of a top and bottom ranked computation.
  final int? resultSize;

  /// The value field that is used in a computation.
  final MeasureField? value;

  TopBottomRankedComputation({
    required this.computationId,
    required this.type,
    this.category,
    this.name,
    this.resultSize,
    this.value,
  });

  factory TopBottomRankedComputation.fromJson(Map<String, dynamic> json) {
    return TopBottomRankedComputation(
      computationId: json['ComputationId'] as String,
      type: (json['Type'] as String).toTopBottomComputationType(),
      category: json['Category'] != null
          ? DimensionField.fromJson(json['Category'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
      resultSize: json['ResultSize'] as int?,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final type = this.type;
    final category = this.category;
    final name = this.name;
    final resultSize = this.resultSize;
    final value = this.value;
    return {
      'ComputationId': computationId,
      'Type': type.toValue(),
      if (category != null) 'Category': category,
      if (name != null) 'Name': name,
      if (resultSize != null) 'ResultSize': resultSize,
      if (value != null) 'Value': value,
    };
  }
}

enum TopBottomSortOrder {
  percentDifference,
  absoluteDifference,
}

extension TopBottomSortOrderValueExtension on TopBottomSortOrder {
  String toValue() {
    switch (this) {
      case TopBottomSortOrder.percentDifference:
        return 'PERCENT_DIFFERENCE';
      case TopBottomSortOrder.absoluteDifference:
        return 'ABSOLUTE_DIFFERENCE';
    }
  }
}

extension TopBottomSortOrderFromString on String {
  TopBottomSortOrder toTopBottomSortOrder() {
    switch (this) {
      case 'PERCENT_DIFFERENCE':
        return TopBottomSortOrder.percentDifference;
      case 'ABSOLUTE_DIFFERENCE':
        return TopBottomSortOrder.absoluteDifference;
    }
    throw Exception('$this is not known in enum TopBottomSortOrder');
  }
}

/// A structure that represents a calculated field.
class TopicCalculatedField {
  /// The calculated field name.
  final String calculatedFieldName;

  /// The calculated field expression.
  final String expression;

  /// The default aggregation. Valid values for this structure are
  /// <code>SUM</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>,
  /// <code>DISTINCT_COUNT</code>, and <code>AVERAGE</code>.
  final DefaultAggregation? aggregation;

  /// The list of aggregation types that are allowed for the calculated field.
  /// Valid values for this structure are <code>COUNT</code>,
  /// <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>,
  /// <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>,
  /// <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>,
  /// <code>VARP</code>, and <code>PERCENTILE</code>.
  final List<AuthorSpecifiedAggregation>? allowedAggregations;

  /// The calculated field description.
  final String? calculatedFieldDescription;

  /// The other names or aliases for the calculated field.
  final List<String>? calculatedFieldSynonyms;

  /// The other names or aliases for the calculated field cell value.
  final List<CellValueSynonym>? cellValueSynonyms;

  /// The column data role for a calculated field. Valid values for this structure
  /// are <code>DIMENSION</code> and <code>MEASURE</code>.
  final ColumnDataRole? columnDataRole;

  /// The order in which data is displayed for the calculated field when it's used
  /// in a comparative context.
  final ComparativeOrder? comparativeOrder;

  /// The default formatting definition.
  final DefaultFormatting? defaultFormatting;

  /// A Boolean value that indicates if a calculated field is visible in the
  /// autocomplete.
  final bool? disableIndexing;

  /// A boolean value that indicates if a calculated field is included in the
  /// topic.
  final bool? isIncludedInTopic;

  /// A Boolean value that indicates whether to never aggregate calculated field
  /// in filters.
  final bool? neverAggregateInFilter;

  /// The non additive for the table style target.
  final bool? nonAdditive;

  /// The list of aggregation types that are not allowed for the calculated field.
  /// Valid values for this structure are <code>COUNT</code>,
  /// <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>,
  /// <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>,
  /// <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>,
  /// <code>VARP</code>, and <code>PERCENTILE</code>.
  final List<AuthorSpecifiedAggregation>? notAllowedAggregations;

  /// The semantic type.
  final SemanticType? semanticType;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TopicTimeGranularity? timeGranularity;

  TopicCalculatedField({
    required this.calculatedFieldName,
    required this.expression,
    this.aggregation,
    this.allowedAggregations,
    this.calculatedFieldDescription,
    this.calculatedFieldSynonyms,
    this.cellValueSynonyms,
    this.columnDataRole,
    this.comparativeOrder,
    this.defaultFormatting,
    this.disableIndexing,
    this.isIncludedInTopic,
    this.neverAggregateInFilter,
    this.nonAdditive,
    this.notAllowedAggregations,
    this.semanticType,
    this.timeGranularity,
  });

  factory TopicCalculatedField.fromJson(Map<String, dynamic> json) {
    return TopicCalculatedField(
      calculatedFieldName: json['CalculatedFieldName'] as String,
      expression: json['Expression'] as String,
      aggregation: (json['Aggregation'] as String?)?.toDefaultAggregation(),
      allowedAggregations: (json['AllowedAggregations'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toAuthorSpecifiedAggregation())
          .toList(),
      calculatedFieldDescription: json['CalculatedFieldDescription'] as String?,
      calculatedFieldSynonyms: (json['CalculatedFieldSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      cellValueSynonyms: (json['CellValueSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => CellValueSynonym.fromJson(e as Map<String, dynamic>))
          .toList(),
      columnDataRole: (json['ColumnDataRole'] as String?)?.toColumnDataRole(),
      comparativeOrder: json['ComparativeOrder'] != null
          ? ComparativeOrder.fromJson(
              json['ComparativeOrder'] as Map<String, dynamic>)
          : null,
      defaultFormatting: json['DefaultFormatting'] != null
          ? DefaultFormatting.fromJson(
              json['DefaultFormatting'] as Map<String, dynamic>)
          : null,
      disableIndexing: json['DisableIndexing'] as bool?,
      isIncludedInTopic: json['IsIncludedInTopic'] as bool?,
      neverAggregateInFilter: json['NeverAggregateInFilter'] as bool?,
      nonAdditive: json['NonAdditive'] as bool?,
      notAllowedAggregations: (json['NotAllowedAggregations'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toAuthorSpecifiedAggregation())
          .toList(),
      semanticType: json['SemanticType'] != null
          ? SemanticType.fromJson(json['SemanticType'] as Map<String, dynamic>)
          : null,
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTopicTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final calculatedFieldName = this.calculatedFieldName;
    final expression = this.expression;
    final aggregation = this.aggregation;
    final allowedAggregations = this.allowedAggregations;
    final calculatedFieldDescription = this.calculatedFieldDescription;
    final calculatedFieldSynonyms = this.calculatedFieldSynonyms;
    final cellValueSynonyms = this.cellValueSynonyms;
    final columnDataRole = this.columnDataRole;
    final comparativeOrder = this.comparativeOrder;
    final defaultFormatting = this.defaultFormatting;
    final disableIndexing = this.disableIndexing;
    final isIncludedInTopic = this.isIncludedInTopic;
    final neverAggregateInFilter = this.neverAggregateInFilter;
    final nonAdditive = this.nonAdditive;
    final notAllowedAggregations = this.notAllowedAggregations;
    final semanticType = this.semanticType;
    final timeGranularity = this.timeGranularity;
    return {
      'CalculatedFieldName': calculatedFieldName,
      'Expression': expression,
      if (aggregation != null) 'Aggregation': aggregation.toValue(),
      if (allowedAggregations != null)
        'AllowedAggregations':
            allowedAggregations.map((e) => e.toValue()).toList(),
      if (calculatedFieldDescription != null)
        'CalculatedFieldDescription': calculatedFieldDescription,
      if (calculatedFieldSynonyms != null)
        'CalculatedFieldSynonyms': calculatedFieldSynonyms,
      if (cellValueSynonyms != null) 'CellValueSynonyms': cellValueSynonyms,
      if (columnDataRole != null) 'ColumnDataRole': columnDataRole.toValue(),
      if (comparativeOrder != null) 'ComparativeOrder': comparativeOrder,
      if (defaultFormatting != null) 'DefaultFormatting': defaultFormatting,
      if (disableIndexing != null) 'DisableIndexing': disableIndexing,
      if (isIncludedInTopic != null) 'IsIncludedInTopic': isIncludedInTopic,
      if (neverAggregateInFilter != null)
        'NeverAggregateInFilter': neverAggregateInFilter,
      if (nonAdditive != null) 'NonAdditive': nonAdditive,
      if (notAllowedAggregations != null)
        'NotAllowedAggregations':
            notAllowedAggregations.map((e) => e.toValue()).toList(),
      if (semanticType != null) 'SemanticType': semanticType,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// A structure that represents a category filter.
class TopicCategoryFilter {
  /// The category filter function. Valid values for this structure are
  /// <code>EXACT</code> and <code>CONTAINS</code>.
  final CategoryFilterFunction? categoryFilterFunction;

  /// The category filter type. This element is used to specify whether a filter
  /// is a simple category filter or an inverse category filter.
  final CategoryFilterType? categoryFilterType;

  /// The constant used in a category filter.
  final TopicCategoryFilterConstant? constant;

  /// A Boolean value that indicates if the filter is inverse.
  final bool? inverse;

  TopicCategoryFilter({
    this.categoryFilterFunction,
    this.categoryFilterType,
    this.constant,
    this.inverse,
  });

  factory TopicCategoryFilter.fromJson(Map<String, dynamic> json) {
    return TopicCategoryFilter(
      categoryFilterFunction: (json['CategoryFilterFunction'] as String?)
          ?.toCategoryFilterFunction(),
      categoryFilterType:
          (json['CategoryFilterType'] as String?)?.toCategoryFilterType(),
      constant: json['Constant'] != null
          ? TopicCategoryFilterConstant.fromJson(
              json['Constant'] as Map<String, dynamic>)
          : null,
      inverse: json['Inverse'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryFilterFunction = this.categoryFilterFunction;
    final categoryFilterType = this.categoryFilterType;
    final constant = this.constant;
    final inverse = this.inverse;
    return {
      if (categoryFilterFunction != null)
        'CategoryFilterFunction': categoryFilterFunction.toValue(),
      if (categoryFilterType != null)
        'CategoryFilterType': categoryFilterType.toValue(),
      if (constant != null) 'Constant': constant,
      if (inverse != null) 'Inverse': inverse,
    };
  }
}

/// A constant used in a category filter.
class TopicCategoryFilterConstant {
  /// A collective constant used in a category filter. This element is used to
  /// specify a list of values for the constant.
  final CollectiveConstant? collectiveConstant;

  /// The type of category filter constant. This element is used to specify
  /// whether a constant is a singular or collective. Valid values are
  /// <code>SINGULAR</code> and <code>COLLECTIVE</code>.
  final ConstantType? constantType;

  /// A singular constant used in a category filter. This element is used to
  /// specify a single value for the constant.
  final String? singularConstant;

  TopicCategoryFilterConstant({
    this.collectiveConstant,
    this.constantType,
    this.singularConstant,
  });

  factory TopicCategoryFilterConstant.fromJson(Map<String, dynamic> json) {
    return TopicCategoryFilterConstant(
      collectiveConstant: json['CollectiveConstant'] != null
          ? CollectiveConstant.fromJson(
              json['CollectiveConstant'] as Map<String, dynamic>)
          : null,
      constantType: (json['ConstantType'] as String?)?.toConstantType(),
      singularConstant: json['SingularConstant'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final collectiveConstant = this.collectiveConstant;
    final constantType = this.constantType;
    final singularConstant = this.singularConstant;
    return {
      if (collectiveConstant != null) 'CollectiveConstant': collectiveConstant,
      if (constantType != null) 'ConstantType': constantType.toValue(),
      if (singularConstant != null) 'SingularConstant': singularConstant,
    };
  }
}

/// Represents a column in a dataset.
class TopicColumn {
  /// The name of the column.
  final String columnName;

  /// The type of aggregation that is performed on the column data when it's
  /// queried.
  final DefaultAggregation? aggregation;

  /// The list of aggregation types that are allowed for the column. Valid values
  /// for this structure are <code>COUNT</code>, <code>DISTINCT_COUNT</code>,
  /// <code>MIN</code>, <code>MAX</code>, <code>MEDIAN</code>, <code>SUM</code>,
  /// <code>AVERAGE</code>, <code>STDEV</code>, <code>STDEVP</code>,
  /// <code>VAR</code>, <code>VARP</code>, and <code>PERCENTILE</code>.
  final List<AuthorSpecifiedAggregation>? allowedAggregations;

  /// The other names or aliases for the column cell value.
  final List<CellValueSynonym>? cellValueSynonyms;

  /// The role of the column in the data. Valid values are <code>DIMENSION</code>
  /// and <code>MEASURE</code>.
  final ColumnDataRole? columnDataRole;

  /// A description of the column and its contents.
  final String? columnDescription;

  /// A user-friendly name for the column.
  final String? columnFriendlyName;

  /// The other names or aliases for the column.
  final List<String>? columnSynonyms;

  /// The order in which data is displayed for the column when it's used in a
  /// comparative context.
  final ComparativeOrder? comparativeOrder;

  /// The default formatting used for values in the column.
  final DefaultFormatting? defaultFormatting;

  /// A Boolean value that indicates whether the column shows in the autocomplete
  /// functionality.
  final bool? disableIndexing;

  /// A Boolean value that indicates whether the column is included in the query
  /// results.
  final bool? isIncludedInTopic;

  /// A Boolean value that indicates whether to aggregate the column data when
  /// it's used in a filter context.
  final bool? neverAggregateInFilter;

  /// The non additive value for the column.
  final bool? nonAdditive;

  /// The list of aggregation types that are not allowed for the column. Valid
  /// values for this structure are <code>COUNT</code>,
  /// <code>DISTINCT_COUNT</code>, <code>MIN</code>, <code>MAX</code>,
  /// <code>MEDIAN</code>, <code>SUM</code>, <code>AVERAGE</code>,
  /// <code>STDEV</code>, <code>STDEVP</code>, <code>VAR</code>,
  /// <code>VARP</code>, and <code>PERCENTILE</code>.
  final List<AuthorSpecifiedAggregation>? notAllowedAggregations;

  /// The semantic type of data contained in the column.
  final SemanticType? semanticType;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TopicTimeGranularity? timeGranularity;

  TopicColumn({
    required this.columnName,
    this.aggregation,
    this.allowedAggregations,
    this.cellValueSynonyms,
    this.columnDataRole,
    this.columnDescription,
    this.columnFriendlyName,
    this.columnSynonyms,
    this.comparativeOrder,
    this.defaultFormatting,
    this.disableIndexing,
    this.isIncludedInTopic,
    this.neverAggregateInFilter,
    this.nonAdditive,
    this.notAllowedAggregations,
    this.semanticType,
    this.timeGranularity,
  });

  factory TopicColumn.fromJson(Map<String, dynamic> json) {
    return TopicColumn(
      columnName: json['ColumnName'] as String,
      aggregation: (json['Aggregation'] as String?)?.toDefaultAggregation(),
      allowedAggregations: (json['AllowedAggregations'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toAuthorSpecifiedAggregation())
          .toList(),
      cellValueSynonyms: (json['CellValueSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => CellValueSynonym.fromJson(e as Map<String, dynamic>))
          .toList(),
      columnDataRole: (json['ColumnDataRole'] as String?)?.toColumnDataRole(),
      columnDescription: json['ColumnDescription'] as String?,
      columnFriendlyName: json['ColumnFriendlyName'] as String?,
      columnSynonyms: (json['ColumnSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      comparativeOrder: json['ComparativeOrder'] != null
          ? ComparativeOrder.fromJson(
              json['ComparativeOrder'] as Map<String, dynamic>)
          : null,
      defaultFormatting: json['DefaultFormatting'] != null
          ? DefaultFormatting.fromJson(
              json['DefaultFormatting'] as Map<String, dynamic>)
          : null,
      disableIndexing: json['DisableIndexing'] as bool?,
      isIncludedInTopic: json['IsIncludedInTopic'] as bool?,
      neverAggregateInFilter: json['NeverAggregateInFilter'] as bool?,
      nonAdditive: json['NonAdditive'] as bool?,
      notAllowedAggregations: (json['NotAllowedAggregations'] as List?)
          ?.whereNotNull()
          .map((e) => (e as String).toAuthorSpecifiedAggregation())
          .toList(),
      semanticType: json['SemanticType'] != null
          ? SemanticType.fromJson(json['SemanticType'] as Map<String, dynamic>)
          : null,
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTopicTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final aggregation = this.aggregation;
    final allowedAggregations = this.allowedAggregations;
    final cellValueSynonyms = this.cellValueSynonyms;
    final columnDataRole = this.columnDataRole;
    final columnDescription = this.columnDescription;
    final columnFriendlyName = this.columnFriendlyName;
    final columnSynonyms = this.columnSynonyms;
    final comparativeOrder = this.comparativeOrder;
    final defaultFormatting = this.defaultFormatting;
    final disableIndexing = this.disableIndexing;
    final isIncludedInTopic = this.isIncludedInTopic;
    final neverAggregateInFilter = this.neverAggregateInFilter;
    final nonAdditive = this.nonAdditive;
    final notAllowedAggregations = this.notAllowedAggregations;
    final semanticType = this.semanticType;
    final timeGranularity = this.timeGranularity;
    return {
      'ColumnName': columnName,
      if (aggregation != null) 'Aggregation': aggregation.toValue(),
      if (allowedAggregations != null)
        'AllowedAggregations':
            allowedAggregations.map((e) => e.toValue()).toList(),
      if (cellValueSynonyms != null) 'CellValueSynonyms': cellValueSynonyms,
      if (columnDataRole != null) 'ColumnDataRole': columnDataRole.toValue(),
      if (columnDescription != null) 'ColumnDescription': columnDescription,
      if (columnFriendlyName != null) 'ColumnFriendlyName': columnFriendlyName,
      if (columnSynonyms != null) 'ColumnSynonyms': columnSynonyms,
      if (comparativeOrder != null) 'ComparativeOrder': comparativeOrder,
      if (defaultFormatting != null) 'DefaultFormatting': defaultFormatting,
      if (disableIndexing != null) 'DisableIndexing': disableIndexing,
      if (isIncludedInTopic != null) 'IsIncludedInTopic': isIncludedInTopic,
      if (neverAggregateInFilter != null)
        'NeverAggregateInFilter': neverAggregateInFilter,
      if (nonAdditive != null) 'NonAdditive': nonAdditive,
      if (notAllowedAggregations != null)
        'NotAllowedAggregations':
            notAllowedAggregations.map((e) => e.toValue()).toList(),
      if (semanticType != null) 'SemanticType': semanticType,
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

/// A filter used to restrict data based on a range of dates or times.
class TopicDateRangeFilter {
  /// The constant used in a date range filter.
  final TopicRangeFilterConstant? constant;

  /// A Boolean value that indicates whether the date range filter should include
  /// the boundary values. If set to true, the filter includes the start and end
  /// dates. If set to false, the filter excludes them.
  final bool? inclusive;

  TopicDateRangeFilter({
    this.constant,
    this.inclusive,
  });

  factory TopicDateRangeFilter.fromJson(Map<String, dynamic> json) {
    return TopicDateRangeFilter(
      constant: json['Constant'] != null
          ? TopicRangeFilterConstant.fromJson(
              json['Constant'] as Map<String, dynamic>)
          : null,
      inclusive: json['Inclusive'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final constant = this.constant;
    final inclusive = this.inclusive;
    return {
      if (constant != null) 'Constant': constant,
      if (inclusive != null) 'Inclusive': inclusive,
    };
  }
}

/// A structure that describes the details of a topic, such as its name,
/// description, and associated data sets.
class TopicDetails {
  /// The data sets that the topic is associated with.
  final List<DatasetMetadata>? dataSets;

  /// The description of the topic.
  final String? description;

  /// The name of the topic.
  final String? name;

  /// The user experience version of a topic.
  final TopicUserExperienceVersion? userExperienceVersion;

  TopicDetails({
    this.dataSets,
    this.description,
    this.name,
    this.userExperienceVersion,
  });

  factory TopicDetails.fromJson(Map<String, dynamic> json) {
    return TopicDetails(
      dataSets: (json['DataSets'] as List?)
          ?.whereNotNull()
          .map((e) => DatasetMetadata.fromJson(e as Map<String, dynamic>))
          .toList(),
      description: json['Description'] as String?,
      name: json['Name'] as String?,
      userExperienceVersion: (json['UserExperienceVersion'] as String?)
          ?.toTopicUserExperienceVersion(),
    );
  }

  Map<String, dynamic> toJson() {
    final dataSets = this.dataSets;
    final description = this.description;
    final name = this.name;
    final userExperienceVersion = this.userExperienceVersion;
    return {
      if (dataSets != null) 'DataSets': dataSets,
      if (description != null) 'Description': description,
      if (name != null) 'Name': name,
      if (userExperienceVersion != null)
        'UserExperienceVersion': userExperienceVersion.toValue(),
    };
  }
}

/// A structure that represents a filter used to select items for a topic.
class TopicFilter {
  /// The name of the filter.
  final String filterName;

  /// The name of the field that the filter operates on.
  final String operandFieldName;

  /// The category filter that is associated with this filter.
  final TopicCategoryFilter? categoryFilter;

  /// The date range filter.
  final TopicDateRangeFilter? dateRangeFilter;

  /// The class of the filter. Valid values for this structure are
  /// <code>ENFORCED_VALUE_FILTER</code>, <code>CONDITIONAL_VALUE_FILTER</code>,
  /// and <code>NAMED_VALUE_FILTER</code>.
  final FilterClass? filterClass;

  /// A description of the filter used to select items for a topic.
  final String? filterDescription;

  /// The other names or aliases for the filter.
  final List<String>? filterSynonyms;

  /// The type of the filter. Valid values for this structure are
  /// <code>CATEGORY_FILTER</code>, <code>NUMERIC_EQUALITY_FILTER</code>,
  /// <code>NUMERIC_RANGE_FILTER</code>, <code>DATE_RANGE_FILTER</code>, and
  /// <code>RELATIVE_DATE_FILTER</code>.
  final NamedFilterType? filterType;

  /// The numeric equality filter.
  final TopicNumericEqualityFilter? numericEqualityFilter;

  /// The numeric range filter.
  final TopicNumericRangeFilter? numericRangeFilter;

  /// The relative date filter.
  final TopicRelativeDateFilter? relativeDateFilter;

  TopicFilter({
    required this.filterName,
    required this.operandFieldName,
    this.categoryFilter,
    this.dateRangeFilter,
    this.filterClass,
    this.filterDescription,
    this.filterSynonyms,
    this.filterType,
    this.numericEqualityFilter,
    this.numericRangeFilter,
    this.relativeDateFilter,
  });

  factory TopicFilter.fromJson(Map<String, dynamic> json) {
    return TopicFilter(
      filterName: json['FilterName'] as String,
      operandFieldName: json['OperandFieldName'] as String,
      categoryFilter: json['CategoryFilter'] != null
          ? TopicCategoryFilter.fromJson(
              json['CategoryFilter'] as Map<String, dynamic>)
          : null,
      dateRangeFilter: json['DateRangeFilter'] != null
          ? TopicDateRangeFilter.fromJson(
              json['DateRangeFilter'] as Map<String, dynamic>)
          : null,
      filterClass: (json['FilterClass'] as String?)?.toFilterClass(),
      filterDescription: json['FilterDescription'] as String?,
      filterSynonyms: (json['FilterSynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      filterType: (json['FilterType'] as String?)?.toNamedFilterType(),
      numericEqualityFilter: json['NumericEqualityFilter'] != null
          ? TopicNumericEqualityFilter.fromJson(
              json['NumericEqualityFilter'] as Map<String, dynamic>)
          : null,
      numericRangeFilter: json['NumericRangeFilter'] != null
          ? TopicNumericRangeFilter.fromJson(
              json['NumericRangeFilter'] as Map<String, dynamic>)
          : null,
      relativeDateFilter: json['RelativeDateFilter'] != null
          ? TopicRelativeDateFilter.fromJson(
              json['RelativeDateFilter'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filterName = this.filterName;
    final operandFieldName = this.operandFieldName;
    final categoryFilter = this.categoryFilter;
    final dateRangeFilter = this.dateRangeFilter;
    final filterClass = this.filterClass;
    final filterDescription = this.filterDescription;
    final filterSynonyms = this.filterSynonyms;
    final filterType = this.filterType;
    final numericEqualityFilter = this.numericEqualityFilter;
    final numericRangeFilter = this.numericRangeFilter;
    final relativeDateFilter = this.relativeDateFilter;
    return {
      'FilterName': filterName,
      'OperandFieldName': operandFieldName,
      if (categoryFilter != null) 'CategoryFilter': categoryFilter,
      if (dateRangeFilter != null) 'DateRangeFilter': dateRangeFilter,
      if (filterClass != null) 'FilterClass': filterClass.toValue(),
      if (filterDescription != null) 'FilterDescription': filterDescription,
      if (filterSynonyms != null) 'FilterSynonyms': filterSynonyms,
      if (filterType != null) 'FilterType': filterType.toValue(),
      if (numericEqualityFilter != null)
        'NumericEqualityFilter': numericEqualityFilter,
      if (numericRangeFilter != null) 'NumericRangeFilter': numericRangeFilter,
      if (relativeDateFilter != null) 'RelativeDateFilter': relativeDateFilter,
    };
  }
}

/// A structure that represents a named entity.
class TopicNamedEntity {
  /// The name of the named entity.
  final String entityName;

  /// The definition of a named entity.
  final List<NamedEntityDefinition>? definition;

  /// The description of the named entity.
  final String? entityDescription;

  /// The other names or aliases for the named entity.
  final List<String>? entitySynonyms;

  /// The type of named entity that a topic represents.
  final SemanticEntityType? semanticEntityType;

  TopicNamedEntity({
    required this.entityName,
    this.definition,
    this.entityDescription,
    this.entitySynonyms,
    this.semanticEntityType,
  });

  factory TopicNamedEntity.fromJson(Map<String, dynamic> json) {
    return TopicNamedEntity(
      entityName: json['EntityName'] as String,
      definition: (json['Definition'] as List?)
          ?.whereNotNull()
          .map((e) => NamedEntityDefinition.fromJson(e as Map<String, dynamic>))
          .toList(),
      entityDescription: json['EntityDescription'] as String?,
      entitySynonyms: (json['EntitySynonyms'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      semanticEntityType: json['SemanticEntityType'] != null
          ? SemanticEntityType.fromJson(
              json['SemanticEntityType'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final entityName = this.entityName;
    final definition = this.definition;
    final entityDescription = this.entityDescription;
    final entitySynonyms = this.entitySynonyms;
    final semanticEntityType = this.semanticEntityType;
    return {
      'EntityName': entityName,
      if (definition != null) 'Definition': definition,
      if (entityDescription != null) 'EntityDescription': entityDescription,
      if (entitySynonyms != null) 'EntitySynonyms': entitySynonyms,
      if (semanticEntityType != null) 'SemanticEntityType': semanticEntityType,
    };
  }
}

/// A filter that filters topics based on the value of a numeric field. The
/// filter includes only topics whose numeric field value matches the specified
/// value.
class TopicNumericEqualityFilter {
  /// An aggregation function that specifies how to calculate the value of a
  /// numeric field for a topic. Valid values for this structure are
  /// <code>NO_AGGREGATION</code>, <code>SUM</code>, <code>AVERAGE</code>,
  /// <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MAX</code>,
  /// <code>MEDIAN</code>, <code>MIN</code>, <code>STDEV</code>,
  /// <code>STDEVP</code>, <code>VAR</code>, and <code>VARP</code>.
  final NamedFilterAggType? aggregation;

  /// The constant used in a numeric equality filter.
  final TopicSingularFilterConstant? constant;

  TopicNumericEqualityFilter({
    this.aggregation,
    this.constant,
  });

  factory TopicNumericEqualityFilter.fromJson(Map<String, dynamic> json) {
    return TopicNumericEqualityFilter(
      aggregation: (json['Aggregation'] as String?)?.toNamedFilterAggType(),
      constant: json['Constant'] != null
          ? TopicSingularFilterConstant.fromJson(
              json['Constant'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final aggregation = this.aggregation;
    final constant = this.constant;
    return {
      if (aggregation != null) 'Aggregation': aggregation.toValue(),
      if (constant != null) 'Constant': constant,
    };
  }
}

/// A filter that filters topics based on the value of a numeric field. The
/// filter includes only topics whose numeric field value falls within the
/// specified range.
class TopicNumericRangeFilter {
  /// An aggregation function that specifies how to calculate the value of a
  /// numeric field for a topic, Valid values for this structure are
  /// <code>NO_AGGREGATION</code>, <code>SUM</code>, <code>AVERAGE</code>,
  /// <code>COUNT</code>, <code>DISTINCT_COUNT</code>, <code>MAX</code>,
  /// <code>MEDIAN</code>, <code>MIN</code>, <code>STDEV</code>,
  /// <code>STDEVP</code>, <code>VAR</code>, and <code>VARP</code>.
  final NamedFilterAggType? aggregation;

  /// The constant used in a numeric range filter.
  final TopicRangeFilterConstant? constant;

  /// A Boolean value that indicates whether the endpoints of the numeric range
  /// are included in the filter. If set to true, topics whose numeric field value
  /// is equal to the endpoint values will be included in the filter. If set to
  /// false, topics whose numeric field value is equal to the endpoint values will
  /// be excluded from the filter.
  final bool? inclusive;

  TopicNumericRangeFilter({
    this.aggregation,
    this.constant,
    this.inclusive,
  });

  factory TopicNumericRangeFilter.fromJson(Map<String, dynamic> json) {
    return TopicNumericRangeFilter(
      aggregation: (json['Aggregation'] as String?)?.toNamedFilterAggType(),
      constant: json['Constant'] != null
          ? TopicRangeFilterConstant.fromJson(
              json['Constant'] as Map<String, dynamic>)
          : null,
      inclusive: json['Inclusive'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    final aggregation = this.aggregation;
    final constant = this.constant;
    final inclusive = this.inclusive;
    return {
      if (aggregation != null) 'Aggregation': aggregation.toValue(),
      if (constant != null) 'Constant': constant,
      if (inclusive != null) 'Inclusive': inclusive,
    };
  }
}

enum TopicNumericSeparatorSymbol {
  comma,
  dot,
}

extension TopicNumericSeparatorSymbolValueExtension
    on TopicNumericSeparatorSymbol {
  String toValue() {
    switch (this) {
      case TopicNumericSeparatorSymbol.comma:
        return 'COMMA';
      case TopicNumericSeparatorSymbol.dot:
        return 'DOT';
    }
  }
}

extension TopicNumericSeparatorSymbolFromString on String {
  TopicNumericSeparatorSymbol toTopicNumericSeparatorSymbol() {
    switch (this) {
      case 'COMMA':
        return TopicNumericSeparatorSymbol.comma;
      case 'DOT':
        return TopicNumericSeparatorSymbol.dot;
    }
    throw Exception('$this is not known in enum TopicNumericSeparatorSymbol');
  }
}

/// A constant value that is used in a range filter to specify the endpoints of
/// the range.
class TopicRangeFilterConstant {
  /// The data type of the constant value that is used in a range filter. Valid
  /// values for this structure are <code>RANGE</code>.
  final ConstantType? constantType;

  /// The value of the constant that is used to specify the endpoints of a range
  /// filter.
  final RangeConstant? rangeConstant;

  TopicRangeFilterConstant({
    this.constantType,
    this.rangeConstant,
  });

  factory TopicRangeFilterConstant.fromJson(Map<String, dynamic> json) {
    return TopicRangeFilterConstant(
      constantType: (json['ConstantType'] as String?)?.toConstantType(),
      rangeConstant: json['RangeConstant'] != null
          ? RangeConstant.fromJson(
              json['RangeConstant'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final constantType = this.constantType;
    final rangeConstant = this.rangeConstant;
    return {
      if (constantType != null) 'ConstantType': constantType.toValue(),
      if (rangeConstant != null) 'RangeConstant': rangeConstant,
    };
  }
}

/// The details about the refresh of a topic.
class TopicRefreshDetails {
  /// The Amazon Resource Name (ARN) of the topic refresh.
  final String? refreshArn;

  /// The ID of the refresh, which occurs as a result of topic creation or topic
  /// update.
  final String? refreshId;

  /// The status of the refresh job that indicates whether the job is still
  /// running, completed successfully, or failed.
  final TopicRefreshStatus? refreshStatus;

  TopicRefreshDetails({
    this.refreshArn,
    this.refreshId,
    this.refreshStatus,
  });

  factory TopicRefreshDetails.fromJson(Map<String, dynamic> json) {
    return TopicRefreshDetails(
      refreshArn: json['RefreshArn'] as String?,
      refreshId: json['RefreshId'] as String?,
      refreshStatus: (json['RefreshStatus'] as String?)?.toTopicRefreshStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final refreshArn = this.refreshArn;
    final refreshId = this.refreshId;
    final refreshStatus = this.refreshStatus;
    return {
      if (refreshArn != null) 'RefreshArn': refreshArn,
      if (refreshId != null) 'RefreshId': refreshId,
      if (refreshStatus != null) 'RefreshStatus': refreshStatus.toValue(),
    };
  }
}

/// A structure that represents a topic refresh schedule.
class TopicRefreshSchedule {
  /// A Boolean value that controls whether to schedule runs at the same schedule
  /// that is specified in SPICE dataset.
  final bool basedOnSpiceSchedule;

  /// A Boolean value that controls whether to schedule is enabled.
  final bool isEnabled;

  /// The time of day when the refresh should run, for example, Monday-Sunday.
  final String? repeatAt;

  /// The starting date and time for the refresh schedule.
  final DateTime? startingAt;

  /// The timezone that you want the refresh schedule to use.
  final String? timezone;

  /// The type of refresh schedule. Valid values for this structure are
  /// <code>HOURLY</code>, <code>DAILY</code>, <code>WEEKLY</code>, and
  /// <code>MONTHLY</code>.
  final TopicScheduleType? topicScheduleType;

  TopicRefreshSchedule({
    required this.basedOnSpiceSchedule,
    required this.isEnabled,
    this.repeatAt,
    this.startingAt,
    this.timezone,
    this.topicScheduleType,
  });

  factory TopicRefreshSchedule.fromJson(Map<String, dynamic> json) {
    return TopicRefreshSchedule(
      basedOnSpiceSchedule: json['BasedOnSpiceSchedule'] as bool,
      isEnabled: json['IsEnabled'] as bool,
      repeatAt: json['RepeatAt'] as String?,
      startingAt: timeStampFromJson(json['StartingAt']),
      timezone: json['Timezone'] as String?,
      topicScheduleType:
          (json['TopicScheduleType'] as String?)?.toTopicScheduleType(),
    );
  }

  Map<String, dynamic> toJson() {
    final basedOnSpiceSchedule = this.basedOnSpiceSchedule;
    final isEnabled = this.isEnabled;
    final repeatAt = this.repeatAt;
    final startingAt = this.startingAt;
    final timezone = this.timezone;
    final topicScheduleType = this.topicScheduleType;
    return {
      'BasedOnSpiceSchedule': basedOnSpiceSchedule,
      'IsEnabled': isEnabled,
      if (repeatAt != null) 'RepeatAt': repeatAt,
      if (startingAt != null) 'StartingAt': unixTimestampToJson(startingAt),
      if (timezone != null) 'Timezone': timezone,
      if (topicScheduleType != null)
        'TopicScheduleType': topicScheduleType.toValue(),
    };
  }
}

/// A summary of the refresh schedule details for a dataset.
class TopicRefreshScheduleSummary {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? datasetArn;

  /// The ID of the dataset.
  final String? datasetId;

  /// The name of the dataset.
  final String? datasetName;

  /// The definition of a refresh schedule.
  final TopicRefreshSchedule? refreshSchedule;

  TopicRefreshScheduleSummary({
    this.datasetArn,
    this.datasetId,
    this.datasetName,
    this.refreshSchedule,
  });

  factory TopicRefreshScheduleSummary.fromJson(Map<String, dynamic> json) {
    return TopicRefreshScheduleSummary(
      datasetArn: json['DatasetArn'] as String?,
      datasetId: json['DatasetId'] as String?,
      datasetName: json['DatasetName'] as String?,
      refreshSchedule: json['RefreshSchedule'] != null
          ? TopicRefreshSchedule.fromJson(
              json['RefreshSchedule'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final datasetArn = this.datasetArn;
    final datasetId = this.datasetId;
    final datasetName = this.datasetName;
    final refreshSchedule = this.refreshSchedule;
    return {
      if (datasetArn != null) 'DatasetArn': datasetArn,
      if (datasetId != null) 'DatasetId': datasetId,
      if (datasetName != null) 'DatasetName': datasetName,
      if (refreshSchedule != null) 'RefreshSchedule': refreshSchedule,
    };
  }
}

enum TopicRefreshStatus {
  initialized,
  running,
  failed,
  completed,
  cancelled,
}

extension TopicRefreshStatusValueExtension on TopicRefreshStatus {
  String toValue() {
    switch (this) {
      case TopicRefreshStatus.initialized:
        return 'INITIALIZED';
      case TopicRefreshStatus.running:
        return 'RUNNING';
      case TopicRefreshStatus.failed:
        return 'FAILED';
      case TopicRefreshStatus.completed:
        return 'COMPLETED';
      case TopicRefreshStatus.cancelled:
        return 'CANCELLED';
    }
  }
}

extension TopicRefreshStatusFromString on String {
  TopicRefreshStatus toTopicRefreshStatus() {
    switch (this) {
      case 'INITIALIZED':
        return TopicRefreshStatus.initialized;
      case 'RUNNING':
        return TopicRefreshStatus.running;
      case 'FAILED':
        return TopicRefreshStatus.failed;
      case 'COMPLETED':
        return TopicRefreshStatus.completed;
      case 'CANCELLED':
        return TopicRefreshStatus.cancelled;
    }
    throw Exception('$this is not known in enum TopicRefreshStatus');
  }
}

/// A structure that represents a relative date filter.
class TopicRelativeDateFilter {
  /// The constant used in a relative date filter.
  final TopicSingularFilterConstant? constant;

  /// The function to be used in a relative date filter to determine the range of
  /// dates to include in the results. Valid values for this structure are
  /// <code>BEFORE</code>, <code>AFTER</code>, and <code>BETWEEN</code>.
  final TopicRelativeDateFilterFunction? relativeDateFilterFunction;

  /// The level of time precision that is used to aggregate <code>DateTime</code>
  /// values.
  final TopicTimeGranularity? timeGranularity;

  TopicRelativeDateFilter({
    this.constant,
    this.relativeDateFilterFunction,
    this.timeGranularity,
  });

  factory TopicRelativeDateFilter.fromJson(Map<String, dynamic> json) {
    return TopicRelativeDateFilter(
      constant: json['Constant'] != null
          ? TopicSingularFilterConstant.fromJson(
              json['Constant'] as Map<String, dynamic>)
          : null,
      relativeDateFilterFunction:
          (json['RelativeDateFilterFunction'] as String?)
              ?.toTopicRelativeDateFilterFunction(),
      timeGranularity:
          (json['TimeGranularity'] as String?)?.toTopicTimeGranularity(),
    );
  }

  Map<String, dynamic> toJson() {
    final constant = this.constant;
    final relativeDateFilterFunction = this.relativeDateFilterFunction;
    final timeGranularity = this.timeGranularity;
    return {
      if (constant != null) 'Constant': constant,
      if (relativeDateFilterFunction != null)
        'RelativeDateFilterFunction': relativeDateFilterFunction.toValue(),
      if (timeGranularity != null) 'TimeGranularity': timeGranularity.toValue(),
    };
  }
}

enum TopicRelativeDateFilterFunction {
  previous,
  $this,
  last,
  next,
  now,
}

extension TopicRelativeDateFilterFunctionValueExtension
    on TopicRelativeDateFilterFunction {
  String toValue() {
    switch (this) {
      case TopicRelativeDateFilterFunction.previous:
        return 'PREVIOUS';
      case TopicRelativeDateFilterFunction.$this:
        return 'THIS';
      case TopicRelativeDateFilterFunction.last:
        return 'LAST';
      case TopicRelativeDateFilterFunction.next:
        return 'NEXT';
      case TopicRelativeDateFilterFunction.now:
        return 'NOW';
    }
  }
}

extension TopicRelativeDateFilterFunctionFromString on String {
  TopicRelativeDateFilterFunction toTopicRelativeDateFilterFunction() {
    switch (this) {
      case 'PREVIOUS':
        return TopicRelativeDateFilterFunction.previous;
      case 'THIS':
        return TopicRelativeDateFilterFunction.$this;
      case 'LAST':
        return TopicRelativeDateFilterFunction.last;
      case 'NEXT':
        return TopicRelativeDateFilterFunction.next;
      case 'NOW':
        return TopicRelativeDateFilterFunction.now;
    }
    throw Exception(
        '$this is not known in enum TopicRelativeDateFilterFunction');
  }
}

enum TopicScheduleType {
  hourly,
  daily,
  weekly,
  monthly,
}

extension TopicScheduleTypeValueExtension on TopicScheduleType {
  String toValue() {
    switch (this) {
      case TopicScheduleType.hourly:
        return 'HOURLY';
      case TopicScheduleType.daily:
        return 'DAILY';
      case TopicScheduleType.weekly:
        return 'WEEKLY';
      case TopicScheduleType.monthly:
        return 'MONTHLY';
    }
  }
}

extension TopicScheduleTypeFromString on String {
  TopicScheduleType toTopicScheduleType() {
    switch (this) {
      case 'HOURLY':
        return TopicScheduleType.hourly;
      case 'DAILY':
        return TopicScheduleType.daily;
      case 'WEEKLY':
        return TopicScheduleType.weekly;
      case 'MONTHLY':
        return TopicScheduleType.monthly;
    }
    throw Exception('$this is not known in enum TopicScheduleType');
  }
}

/// A structure that represents a singular filter constant, used in filters to
/// specify a single value to match against.
class TopicSingularFilterConstant {
  /// The type of the singular filter constant. Valid values for this structure
  /// are <code>SINGULAR</code>.
  final ConstantType? constantType;

  /// The value of the singular filter constant.
  final String? singularConstant;

  TopicSingularFilterConstant({
    this.constantType,
    this.singularConstant,
  });

  factory TopicSingularFilterConstant.fromJson(Map<String, dynamic> json) {
    return TopicSingularFilterConstant(
      constantType: (json['ConstantType'] as String?)?.toConstantType(),
      singularConstant: json['SingularConstant'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final constantType = this.constantType;
    final singularConstant = this.singularConstant;
    return {
      if (constantType != null) 'ConstantType': constantType.toValue(),
      if (singularConstant != null) 'SingularConstant': singularConstant,
    };
  }
}

/// A topic summary.
class TopicSummary {
  /// The Amazon Resource Name (ARN) of the topic.
  final String? arn;

  /// The name of the topic.
  final String? name;

  /// The ID for the topic. This ID is unique per Amazon Web Services Region for
  /// each Amazon Web Services account.
  final String? topicId;

  /// The user experience version of the topic.
  final TopicUserExperienceVersion? userExperienceVersion;

  TopicSummary({
    this.arn,
    this.name,
    this.topicId,
    this.userExperienceVersion,
  });

  factory TopicSummary.fromJson(Map<String, dynamic> json) {
    return TopicSummary(
      arn: json['Arn'] as String?,
      name: json['Name'] as String?,
      topicId: json['TopicId'] as String?,
      userExperienceVersion: (json['UserExperienceVersion'] as String?)
          ?.toTopicUserExperienceVersion(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final name = this.name;
    final topicId = this.topicId;
    final userExperienceVersion = this.userExperienceVersion;
    return {
      if (arn != null) 'Arn': arn,
      if (name != null) 'Name': name,
      if (topicId != null) 'TopicId': topicId,
      if (userExperienceVersion != null)
        'UserExperienceVersion': userExperienceVersion.toValue(),
    };
  }
}

enum TopicTimeGranularity {
  second,
  minute,
  hour,
  day,
  week,
  month,
  quarter,
  year,
}

extension TopicTimeGranularityValueExtension on TopicTimeGranularity {
  String toValue() {
    switch (this) {
      case TopicTimeGranularity.second:
        return 'SECOND';
      case TopicTimeGranularity.minute:
        return 'MINUTE';
      case TopicTimeGranularity.hour:
        return 'HOUR';
      case TopicTimeGranularity.day:
        return 'DAY';
      case TopicTimeGranularity.week:
        return 'WEEK';
      case TopicTimeGranularity.month:
        return 'MONTH';
      case TopicTimeGranularity.quarter:
        return 'QUARTER';
      case TopicTimeGranularity.year:
        return 'YEAR';
    }
  }
}

extension TopicTimeGranularityFromString on String {
  TopicTimeGranularity toTopicTimeGranularity() {
    switch (this) {
      case 'SECOND':
        return TopicTimeGranularity.second;
      case 'MINUTE':
        return TopicTimeGranularity.minute;
      case 'HOUR':
        return TopicTimeGranularity.hour;
      case 'DAY':
        return TopicTimeGranularity.day;
      case 'WEEK':
        return TopicTimeGranularity.week;
      case 'MONTH':
        return TopicTimeGranularity.month;
      case 'QUARTER':
        return TopicTimeGranularity.quarter;
      case 'YEAR':
        return TopicTimeGranularity.year;
    }
    throw Exception('$this is not known in enum TopicTimeGranularity');
  }
}

enum TopicUserExperienceVersion {
  legacy,
  newReaderExperience,
}

extension TopicUserExperienceVersionValueExtension
    on TopicUserExperienceVersion {
  String toValue() {
    switch (this) {
      case TopicUserExperienceVersion.legacy:
        return 'LEGACY';
      case TopicUserExperienceVersion.newReaderExperience:
        return 'NEW_READER_EXPERIENCE';
    }
  }
}

extension TopicUserExperienceVersionFromString on String {
  TopicUserExperienceVersion toTopicUserExperienceVersion() {
    switch (this) {
      case 'LEGACY':
        return TopicUserExperienceVersion.legacy;
      case 'NEW_READER_EXPERIENCE':
        return TopicUserExperienceVersion.newReaderExperience;
    }
    throw Exception('$this is not known in enum TopicUserExperienceVersion');
  }
}

/// The total aggregation computation configuration.
class TotalAggregationComputation {
  /// The ID for a computation.
  final String computationId;

  /// The name of a computation.
  final String? name;

  /// The value field that is used in a computation.
  final MeasureField? value;

  TotalAggregationComputation({
    required this.computationId,
    this.name,
    this.value,
  });

  factory TotalAggregationComputation.fromJson(Map<String, dynamic> json) {
    return TotalAggregationComputation(
      computationId: json['ComputationId'] as String,
      name: json['Name'] as String?,
      value: json['Value'] != null
          ? MeasureField.fromJson(json['Value'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final name = this.name;
    final value = this.value;
    return {
      'ComputationId': computationId,
      if (name != null) 'Name': name,
      if (value != null) 'Value': value,
    };
  }
}

/// An aggregation function that aggregates the total values of a measure.
class TotalAggregationFunction {
  /// A built in aggregation function for total values.
  final SimpleTotalAggregationFunction? simpleTotalAggregationFunction;

  TotalAggregationFunction({
    this.simpleTotalAggregationFunction,
  });

  factory TotalAggregationFunction.fromJson(Map<String, dynamic> json) {
    return TotalAggregationFunction(
      simpleTotalAggregationFunction:
          (json['SimpleTotalAggregationFunction'] as String?)
              ?.toSimpleTotalAggregationFunction(),
    );
  }

  Map<String, dynamic> toJson() {
    final simpleTotalAggregationFunction = this.simpleTotalAggregationFunction;
    return {
      if (simpleTotalAggregationFunction != null)
        'SimpleTotalAggregationFunction':
            simpleTotalAggregationFunction.toValue(),
    };
  }
}

/// The total aggregation settings map of a field id.
class TotalAggregationOption {
  /// The field id that's associated with the total aggregation option.
  final String fieldId;

  /// The total aggregation function that you want to set for a specified field
  /// id.
  final TotalAggregationFunction totalAggregationFunction;

  TotalAggregationOption({
    required this.fieldId,
    required this.totalAggregationFunction,
  });

  factory TotalAggregationOption.fromJson(Map<String, dynamic> json) {
    return TotalAggregationOption(
      fieldId: json['FieldId'] as String,
      totalAggregationFunction: TotalAggregationFunction.fromJson(
          json['TotalAggregationFunction'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    final fieldId = this.fieldId;
    final totalAggregationFunction = this.totalAggregationFunction;
    return {
      'FieldId': fieldId,
      'TotalAggregationFunction': totalAggregationFunction,
    };
  }
}

/// The total options for a table visual.
class TotalOptions {
  /// The custom label string for the total cells.
  final String? customLabel;

  /// The placement (start, end) for the total cells.
  final TableTotalsPlacement? placement;

  /// The scroll status (pinned, scrolled) for the total cells.
  final TableTotalsScrollStatus? scrollStatus;

  /// The total aggregation settings for each value field.
  final List<TotalAggregationOption>? totalAggregationOptions;

  /// Cell styling options for the total cells.
  final TableCellStyle? totalCellStyle;

  /// The visibility configuration for the total cells.
  final Visibility? totalsVisibility;

  TotalOptions({
    this.customLabel,
    this.placement,
    this.scrollStatus,
    this.totalAggregationOptions,
    this.totalCellStyle,
    this.totalsVisibility,
  });

  factory TotalOptions.fromJson(Map<String, dynamic> json) {
    return TotalOptions(
      customLabel: json['CustomLabel'] as String?,
      placement: (json['Placement'] as String?)?.toTableTotalsPlacement(),
      scrollStatus:
          (json['ScrollStatus'] as String?)?.toTableTotalsScrollStatus(),
      totalAggregationOptions: (json['TotalAggregationOptions'] as List?)
          ?.whereNotNull()
          .map(
              (e) => TotalAggregationOption.fromJson(e as Map<String, dynamic>))
          .toList(),
      totalCellStyle: json['TotalCellStyle'] != null
          ? TableCellStyle.fromJson(
              json['TotalCellStyle'] as Map<String, dynamic>)
          : null,
      totalsVisibility: (json['TotalsVisibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final customLabel = this.customLabel;
    final placement = this.placement;
    final scrollStatus = this.scrollStatus;
    final totalAggregationOptions = this.totalAggregationOptions;
    final totalCellStyle = this.totalCellStyle;
    final totalsVisibility = this.totalsVisibility;
    return {
      if (customLabel != null) 'CustomLabel': customLabel,
      if (placement != null) 'Placement': placement.toValue(),
      if (scrollStatus != null) 'ScrollStatus': scrollStatus.toValue(),
      if (totalAggregationOptions != null)
        'TotalAggregationOptions': totalAggregationOptions,
      if (totalCellStyle != null) 'TotalCellStyle': totalCellStyle,
      if (totalsVisibility != null)
        'TotalsVisibility': totalsVisibility.toValue(),
    };
  }
}

/// A data transformation on a logical table. This is a variant type structure.
/// For this structure to be valid, only one of the attributes can be non-null.
class TransformOperation {
  /// A transform operation that casts a column to a different type.
  final CastColumnTypeOperation? castColumnTypeOperation;

  /// An operation that creates calculated columns. Columns created in one such
  /// operation form a lexical closure.
  final CreateColumnsOperation? createColumnsOperation;

  /// An operation that filters rows based on some condition.
  final FilterOperation? filterOperation;
  final OverrideDatasetParameterOperation? overrideDatasetParameterOperation;

  /// An operation that projects columns. Operations that come after a projection
  /// can only refer to projected columns.
  final ProjectOperation? projectOperation;

  /// An operation that renames a column.
  final RenameColumnOperation? renameColumnOperation;

  /// An operation that tags a column with additional information.
  final TagColumnOperation? tagColumnOperation;
  final UntagColumnOperation? untagColumnOperation;

  TransformOperation({
    this.castColumnTypeOperation,
    this.createColumnsOperation,
    this.filterOperation,
    this.overrideDatasetParameterOperation,
    this.projectOperation,
    this.renameColumnOperation,
    this.tagColumnOperation,
    this.untagColumnOperation,
  });

  factory TransformOperation.fromJson(Map<String, dynamic> json) {
    return TransformOperation(
      castColumnTypeOperation: json['CastColumnTypeOperation'] != null
          ? CastColumnTypeOperation.fromJson(
              json['CastColumnTypeOperation'] as Map<String, dynamic>)
          : null,
      createColumnsOperation: json['CreateColumnsOperation'] != null
          ? CreateColumnsOperation.fromJson(
              json['CreateColumnsOperation'] as Map<String, dynamic>)
          : null,
      filterOperation: json['FilterOperation'] != null
          ? FilterOperation.fromJson(
              json['FilterOperation'] as Map<String, dynamic>)
          : null,
      overrideDatasetParameterOperation:
          json['OverrideDatasetParameterOperation'] != null
              ? OverrideDatasetParameterOperation.fromJson(
                  json['OverrideDatasetParameterOperation']
                      as Map<String, dynamic>)
              : null,
      projectOperation: json['ProjectOperation'] != null
          ? ProjectOperation.fromJson(
              json['ProjectOperation'] as Map<String, dynamic>)
          : null,
      renameColumnOperation: json['RenameColumnOperation'] != null
          ? RenameColumnOperation.fromJson(
              json['RenameColumnOperation'] as Map<String, dynamic>)
          : null,
      tagColumnOperation: json['TagColumnOperation'] != null
          ? TagColumnOperation.fromJson(
              json['TagColumnOperation'] as Map<String, dynamic>)
          : null,
      untagColumnOperation: json['UntagColumnOperation'] != null
          ? UntagColumnOperation.fromJson(
              json['UntagColumnOperation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final castColumnTypeOperation = this.castColumnTypeOperation;
    final createColumnsOperation = this.createColumnsOperation;
    final filterOperation = this.filterOperation;
    final overrideDatasetParameterOperation =
        this.overrideDatasetParameterOperation;
    final projectOperation = this.projectOperation;
    final renameColumnOperation = this.renameColumnOperation;
    final tagColumnOperation = this.tagColumnOperation;
    final untagColumnOperation = this.untagColumnOperation;
    return {
      if (castColumnTypeOperation != null)
        'CastColumnTypeOperation': castColumnTypeOperation,
      if (createColumnsOperation != null)
        'CreateColumnsOperation': createColumnsOperation,
      if (filterOperation != null) 'FilterOperation': filterOperation,
      if (overrideDatasetParameterOperation != null)
        'OverrideDatasetParameterOperation': overrideDatasetParameterOperation,
      if (projectOperation != null) 'ProjectOperation': projectOperation,
      if (renameColumnOperation != null)
        'RenameColumnOperation': renameColumnOperation,
      if (tagColumnOperation != null) 'TagColumnOperation': tagColumnOperation,
      if (untagColumnOperation != null)
        'UntagColumnOperation': untagColumnOperation,
    };
  }
}

/// Aggregated field wells of a tree map.
class TreeMapAggregatedFieldWells {
  /// The color field well of a tree map. Values are grouped by aggregations based
  /// on group by fields.
  final List<MeasureField>? colors;

  /// The group by field well of a tree map. Values are grouped based on group by
  /// fields.
  final List<DimensionField>? groups;

  /// The size field well of a tree map. Values are aggregated based on group by
  /// fields.
  final List<MeasureField>? sizes;

  TreeMapAggregatedFieldWells({
    this.colors,
    this.groups,
    this.sizes,
  });

  factory TreeMapAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return TreeMapAggregatedFieldWells(
      colors: (json['Colors'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
      groups: (json['Groups'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      sizes: (json['Sizes'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final colors = this.colors;
    final groups = this.groups;
    final sizes = this.sizes;
    return {
      if (colors != null) 'Colors': colors,
      if (groups != null) 'Groups': groups,
      if (sizes != null) 'Sizes': sizes,
    };
  }
}

/// The configuration of a tree map.
class TreeMapConfiguration {
  /// The label options (label text, label visibility) for the colors displayed in
  /// a tree map.
  final ChartAxisLabelOptions? colorLabelOptions;

  /// The color options (gradient color, point of divergence) of a tree map.
  final ColorScale? colorScale;

  /// The options that determine if visual data labels are displayed.
  final DataLabelOptions? dataLabels;

  /// The field wells of the visual.
  final TreeMapFieldWells? fieldWells;

  /// The label options (label text, label visibility) of the groups that are
  /// displayed in a tree map.
  final ChartAxisLabelOptions? groupLabelOptions;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend display setup of the visual.
  final LegendOptions? legend;

  /// The label options (label text, label visibility) of the sizes that are
  /// displayed in a tree map.
  final ChartAxisLabelOptions? sizeLabelOptions;

  /// The sort configuration of a tree map.
  final TreeMapSortConfiguration? sortConfiguration;

  /// The tooltip display setup of the visual.
  final TooltipOptions? tooltip;

  TreeMapConfiguration({
    this.colorLabelOptions,
    this.colorScale,
    this.dataLabels,
    this.fieldWells,
    this.groupLabelOptions,
    this.interactions,
    this.legend,
    this.sizeLabelOptions,
    this.sortConfiguration,
    this.tooltip,
  });

  factory TreeMapConfiguration.fromJson(Map<String, dynamic> json) {
    return TreeMapConfiguration(
      colorLabelOptions: json['ColorLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['ColorLabelOptions'] as Map<String, dynamic>)
          : null,
      colorScale: json['ColorScale'] != null
          ? ColorScale.fromJson(json['ColorScale'] as Map<String, dynamic>)
          : null,
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? TreeMapFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      groupLabelOptions: json['GroupLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['GroupLabelOptions'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      sizeLabelOptions: json['SizeLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['SizeLabelOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? TreeMapSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      tooltip: json['Tooltip'] != null
          ? TooltipOptions.fromJson(json['Tooltip'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final colorLabelOptions = this.colorLabelOptions;
    final colorScale = this.colorScale;
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final groupLabelOptions = this.groupLabelOptions;
    final interactions = this.interactions;
    final legend = this.legend;
    final sizeLabelOptions = this.sizeLabelOptions;
    final sortConfiguration = this.sortConfiguration;
    final tooltip = this.tooltip;
    return {
      if (colorLabelOptions != null) 'ColorLabelOptions': colorLabelOptions,
      if (colorScale != null) 'ColorScale': colorScale,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (groupLabelOptions != null) 'GroupLabelOptions': groupLabelOptions,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (sizeLabelOptions != null) 'SizeLabelOptions': sizeLabelOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (tooltip != null) 'Tooltip': tooltip,
    };
  }
}

/// The field wells of a tree map.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class TreeMapFieldWells {
  /// The aggregated field wells of a tree map.
  final TreeMapAggregatedFieldWells? treeMapAggregatedFieldWells;

  TreeMapFieldWells({
    this.treeMapAggregatedFieldWells,
  });

  factory TreeMapFieldWells.fromJson(Map<String, dynamic> json) {
    return TreeMapFieldWells(
      treeMapAggregatedFieldWells: json['TreeMapAggregatedFieldWells'] != null
          ? TreeMapAggregatedFieldWells.fromJson(
              json['TreeMapAggregatedFieldWells'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final treeMapAggregatedFieldWells = this.treeMapAggregatedFieldWells;
    return {
      if (treeMapAggregatedFieldWells != null)
        'TreeMapAggregatedFieldWells': treeMapAggregatedFieldWells,
    };
  }
}

/// The sort configuration of a tree map.
class TreeMapSortConfiguration {
  /// The limit on the number of groups that are displayed.
  final ItemsLimitConfiguration? treeMapGroupItemsLimitConfiguration;

  /// The sort configuration of group by fields.
  final List<FieldSortOptions>? treeMapSort;

  TreeMapSortConfiguration({
    this.treeMapGroupItemsLimitConfiguration,
    this.treeMapSort,
  });

  factory TreeMapSortConfiguration.fromJson(Map<String, dynamic> json) {
    return TreeMapSortConfiguration(
      treeMapGroupItemsLimitConfiguration:
          json['TreeMapGroupItemsLimitConfiguration'] != null
              ? ItemsLimitConfiguration.fromJson(
                  json['TreeMapGroupItemsLimitConfiguration']
                      as Map<String, dynamic>)
              : null,
      treeMapSort: (json['TreeMapSort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final treeMapGroupItemsLimitConfiguration =
        this.treeMapGroupItemsLimitConfiguration;
    final treeMapSort = this.treeMapSort;
    return {
      if (treeMapGroupItemsLimitConfiguration != null)
        'TreeMapGroupItemsLimitConfiguration':
            treeMapGroupItemsLimitConfiguration,
      if (treeMapSort != null) 'TreeMapSort': treeMapSort,
    };
  }
}

/// A tree map.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using
/// tree maps</a> in the <i>Amazon QuickSight User Guide</i>.
class TreeMapVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final TreeMapConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  TreeMapVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory TreeMapVisual.fromJson(Map<String, dynamic> json) {
    return TreeMapVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? TreeMapConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// The options that determine the presentation of trend arrows in a KPI visual.
class TrendArrowOptions {
  /// The visibility of the trend arrows.
  final Visibility? visibility;

  TrendArrowOptions({
    this.visibility,
  });

  factory TrendArrowOptions.fromJson(Map<String, dynamic> json) {
    return TrendArrowOptions(
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final visibility = this.visibility;
    return {
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The parameters that are required to connect to a Trino data source.
class TrinoParameters {
  /// The catalog name for the Trino data source.
  final String catalog;

  /// The host name of the Trino data source.
  final String host;

  /// The port for the Trino data source.
  final int port;

  TrinoParameters({
    required this.catalog,
    required this.host,
    required this.port,
  });

  factory TrinoParameters.fromJson(Map<String, dynamic> json) {
    return TrinoParameters(
      catalog: json['Catalog'] as String,
      host: json['Host'] as String,
      port: json['Port'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    final catalog = this.catalog;
    final host = this.host;
    final port = this.port;
    return {
      'Catalog': catalog,
      'Host': host,
      'Port': port,
    };
  }
}

/// The parameters for Twitter.
class TwitterParameters {
  /// Maximum number of rows to query Twitter.
  final int maxRows;

  /// Twitter query string.
  final String query;

  TwitterParameters({
    required this.maxRows,
    required this.query,
  });

  factory TwitterParameters.fromJson(Map<String, dynamic> json) {
    return TwitterParameters(
      maxRows: json['MaxRows'] as int,
      query: json['Query'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final maxRows = this.maxRows;
    final query = this.query;
    return {
      'MaxRows': maxRows,
      'Query': query,
    };
  }
}

/// Determines the typography options.
class Typography {
  /// Determines the list of font families.
  final List<Font>? fontFamilies;

  Typography({
    this.fontFamilies,
  });

  factory Typography.fromJson(Map<String, dynamic> json) {
    return Typography(
      fontFamilies: (json['FontFamilies'] as List?)
          ?.whereNotNull()
          .map((e) => Font.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final fontFamilies = this.fontFamilies;
    return {
      if (fontFamilies != null) 'FontFamilies': fontFamilies,
    };
  }
}

/// The theme colors that apply to UI and to charts, excluding data colors. The
/// colors description is a hexadecimal color code that consists of six
/// alphanumerical characters, prefixed with <code>#</code>, for example
/// #37BFF5. For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/themes-in-quicksight.html">Using
/// Themes in Amazon QuickSight</a> in the <i>Amazon QuickSight User Guide.</i>
class UIColorPalette {
  /// This color is that applies to selected states and buttons.
  final String? accent;

  /// The foreground color that applies to any text or other elements that appear
  /// over the accent color.
  final String? accentForeground;

  /// The color that applies to error messages.
  final String? danger;

  /// The foreground color that applies to any text or other elements that appear
  /// over the error color.
  final String? dangerForeground;

  /// The color that applies to the names of fields that are identified as
  /// dimensions.
  final String? dimension;

  /// The foreground color that applies to any text or other elements that appear
  /// over the dimension color.
  final String? dimensionForeground;

  /// The color that applies to the names of fields that are identified as
  /// measures.
  final String? measure;

  /// The foreground color that applies to any text or other elements that appear
  /// over the measure color.
  final String? measureForeground;

  /// The background color that applies to visuals and other high emphasis UI.
  final String? primaryBackground;

  /// The color of text and other foreground elements that appear over the primary
  /// background regions, such as grid lines, borders, table banding, icons, and
  /// so on.
  final String? primaryForeground;

  /// The background color that applies to the sheet background and sheet
  /// controls.
  final String? secondaryBackground;

  /// The foreground color that applies to any sheet title, sheet control text, or
  /// UI that appears over the secondary background.
  final String? secondaryForeground;

  /// The color that applies to success messages, for example the check mark for a
  /// successful download.
  final String? success;

  /// The foreground color that applies to any text or other elements that appear
  /// over the success color.
  final String? successForeground;

  /// This color that applies to warning and informational messages.
  final String? warning;

  /// The foreground color that applies to any text or other elements that appear
  /// over the warning color.
  final String? warningForeground;

  UIColorPalette({
    this.accent,
    this.accentForeground,
    this.danger,
    this.dangerForeground,
    this.dimension,
    this.dimensionForeground,
    this.measure,
    this.measureForeground,
    this.primaryBackground,
    this.primaryForeground,
    this.secondaryBackground,
    this.secondaryForeground,
    this.success,
    this.successForeground,
    this.warning,
    this.warningForeground,
  });

  factory UIColorPalette.fromJson(Map<String, dynamic> json) {
    return UIColorPalette(
      accent: json['Accent'] as String?,
      accentForeground: json['AccentForeground'] as String?,
      danger: json['Danger'] as String?,
      dangerForeground: json['DangerForeground'] as String?,
      dimension: json['Dimension'] as String?,
      dimensionForeground: json['DimensionForeground'] as String?,
      measure: json['Measure'] as String?,
      measureForeground: json['MeasureForeground'] as String?,
      primaryBackground: json['PrimaryBackground'] as String?,
      primaryForeground: json['PrimaryForeground'] as String?,
      secondaryBackground: json['SecondaryBackground'] as String?,
      secondaryForeground: json['SecondaryForeground'] as String?,
      success: json['Success'] as String?,
      successForeground: json['SuccessForeground'] as String?,
      warning: json['Warning'] as String?,
      warningForeground: json['WarningForeground'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final accent = this.accent;
    final accentForeground = this.accentForeground;
    final danger = this.danger;
    final dangerForeground = this.dangerForeground;
    final dimension = this.dimension;
    final dimensionForeground = this.dimensionForeground;
    final measure = this.measure;
    final measureForeground = this.measureForeground;
    final primaryBackground = this.primaryBackground;
    final primaryForeground = this.primaryForeground;
    final secondaryBackground = this.secondaryBackground;
    final secondaryForeground = this.secondaryForeground;
    final success = this.success;
    final successForeground = this.successForeground;
    final warning = this.warning;
    final warningForeground = this.warningForeground;
    return {
      if (accent != null) 'Accent': accent,
      if (accentForeground != null) 'AccentForeground': accentForeground,
      if (danger != null) 'Danger': danger,
      if (dangerForeground != null) 'DangerForeground': dangerForeground,
      if (dimension != null) 'Dimension': dimension,
      if (dimensionForeground != null)
        'DimensionForeground': dimensionForeground,
      if (measure != null) 'Measure': measure,
      if (measureForeground != null) 'MeasureForeground': measureForeground,
      if (primaryBackground != null) 'PrimaryBackground': primaryBackground,
      if (primaryForeground != null) 'PrimaryForeground': primaryForeground,
      if (secondaryBackground != null)
        'SecondaryBackground': secondaryBackground,
      if (secondaryForeground != null)
        'SecondaryForeground': secondaryForeground,
      if (success != null) 'Success': success,
      if (successForeground != null) 'SuccessForeground': successForeground,
      if (warning != null) 'Warning': warning,
      if (warningForeground != null) 'WarningForeground': warningForeground,
    };
  }
}

enum URLTargetConfiguration {
  newTab,
  newWindow,
  sameTab,
}

extension URLTargetConfigurationValueExtension on URLTargetConfiguration {
  String toValue() {
    switch (this) {
      case URLTargetConfiguration.newTab:
        return 'NEW_TAB';
      case URLTargetConfiguration.newWindow:
        return 'NEW_WINDOW';
      case URLTargetConfiguration.sameTab:
        return 'SAME_TAB';
    }
  }
}

extension URLTargetConfigurationFromString on String {
  URLTargetConfiguration toURLTargetConfiguration() {
    switch (this) {
      case 'NEW_TAB':
        return URLTargetConfiguration.newTab;
      case 'NEW_WINDOW':
        return URLTargetConfiguration.newWindow;
      case 'SAME_TAB':
        return URLTargetConfiguration.sameTab;
    }
    throw Exception('$this is not known in enum URLTargetConfiguration');
  }
}

/// The unaggregated field for a table.
class UnaggregatedField {
  /// The column that is used in the <code>UnaggregatedField</code>.
  final ColumnIdentifier column;

  /// The custom field ID.
  final String fieldId;

  /// The format configuration of the field.
  final FormatConfiguration? formatConfiguration;

  UnaggregatedField({
    required this.column,
    required this.fieldId,
    this.formatConfiguration,
  });

  factory UnaggregatedField.fromJson(Map<String, dynamic> json) {
    return UnaggregatedField(
      column: ColumnIdentifier.fromJson(json['Column'] as Map<String, dynamic>),
      fieldId: json['FieldId'] as String,
      formatConfiguration: json['FormatConfiguration'] != null
          ? FormatConfiguration.fromJson(
              json['FormatConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final column = this.column;
    final fieldId = this.fieldId;
    final formatConfiguration = this.formatConfiguration;
    return {
      'Column': column,
      'FieldId': fieldId,
      if (formatConfiguration != null)
        'FormatConfiguration': formatConfiguration,
    };
  }
}

enum UndefinedSpecifiedValueType {
  least,
  most,
}

extension UndefinedSpecifiedValueTypeValueExtension
    on UndefinedSpecifiedValueType {
  String toValue() {
    switch (this) {
      case UndefinedSpecifiedValueType.least:
        return 'LEAST';
      case UndefinedSpecifiedValueType.most:
        return 'MOST';
    }
  }
}

extension UndefinedSpecifiedValueTypeFromString on String {
  UndefinedSpecifiedValueType toUndefinedSpecifiedValueType() {
    switch (this) {
      case 'LEAST':
        return UndefinedSpecifiedValueType.least;
      case 'MOST':
        return UndefinedSpecifiedValueType.most;
    }
    throw Exception('$this is not known in enum UndefinedSpecifiedValueType');
  }
}

/// The unique values computation configuration.
class UniqueValuesComputation {
  /// The ID for a computation.
  final String computationId;

  /// The category field that is used in a computation.
  final DimensionField? category;

  /// The name of a computation.
  final String? name;

  UniqueValuesComputation({
    required this.computationId,
    this.category,
    this.name,
  });

  factory UniqueValuesComputation.fromJson(Map<String, dynamic> json) {
    return UniqueValuesComputation(
      computationId: json['ComputationId'] as String,
      category: json['Category'] != null
          ? DimensionField.fromJson(json['Category'] as Map<String, dynamic>)
          : null,
      name: json['Name'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final computationId = this.computationId;
    final category = this.category;
    final name = this.name;
    return {
      'ComputationId': computationId,
      if (category != null) 'Category': category,
      if (name != null) 'Name': name,
    };
  }
}

/// A transform operation that removes tags associated with a column.
class UntagColumnOperation {
  /// The column that this operation acts on.
  final String columnName;

  /// The column tags to remove from this column.
  final List<ColumnTagName> tagNames;

  UntagColumnOperation({
    required this.columnName,
    required this.tagNames,
  });

  factory UntagColumnOperation.fromJson(Map<String, dynamic> json) {
    return UntagColumnOperation(
      columnName: json['ColumnName'] as String,
      tagNames: (json['TagNames'] as List)
          .whereNotNull()
          .map((e) => (e as String).toColumnTagName())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final columnName = this.columnName;
    final tagNames = this.tagNames;
    return {
      'ColumnName': columnName,
      'TagNames': tagNames.map((e) => e.toValue()).toList(),
    };
  }
}

class UntagResourceResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UntagResourceResponse({
    this.requestId,
    this.status,
  });

  factory UntagResourceResponse.fromJson(Map<String, dynamic> json) {
    return UntagResourceResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateAccountCustomizationResponse {
  /// The Amazon QuickSight customizations you're updating in the current Amazon
  /// Web Services Region.
  final AccountCustomization? accountCustomization;

  /// The Amazon Resource Name (ARN) for the updated customization for this Amazon
  /// Web Services account.
  final String? arn;

  /// The ID for the Amazon Web Services account that you want to update Amazon
  /// QuickSight customizations for.
  final String? awsAccountId;

  /// The namespace associated with the customization that you're updating.
  final String? namespace;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateAccountCustomizationResponse({
    this.accountCustomization,
    this.arn,
    this.awsAccountId,
    this.namespace,
    this.requestId,
    this.status,
  });

  factory UpdateAccountCustomizationResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateAccountCustomizationResponse(
      accountCustomization: json['AccountCustomization'] != null
          ? AccountCustomization.fromJson(
              json['AccountCustomization'] as Map<String, dynamic>)
          : null,
      arn: json['Arn'] as String?,
      awsAccountId: json['AwsAccountId'] as String?,
      namespace: json['Namespace'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final accountCustomization = this.accountCustomization;
    final arn = this.arn;
    final awsAccountId = this.awsAccountId;
    final namespace = this.namespace;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (accountCustomization != null)
        'AccountCustomization': accountCustomization,
      if (arn != null) 'Arn': arn,
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (namespace != null) 'Namespace': namespace,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateAccountSettingsResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateAccountSettingsResponse({
    this.requestId,
    this.status,
  });

  factory UpdateAccountSettingsResponse.fromJson(Map<String, dynamic> json) {
    return UpdateAccountSettingsResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateAnalysisPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the analysis that you updated.
  final String? analysisArn;

  /// The ID of the analysis that you updated permissions for.
  final String? analysisId;

  /// A structure that describes the principals and the resource-level permissions
  /// on an analysis.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateAnalysisPermissionsResponse({
    this.analysisArn,
    this.analysisId,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory UpdateAnalysisPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateAnalysisPermissionsResponse(
      analysisArn: json['AnalysisArn'] as String?,
      analysisId: json['AnalysisId'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final analysisArn = this.analysisArn;
    final analysisId = this.analysisId;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (analysisArn != null) 'AnalysisArn': analysisArn,
      if (analysisId != null) 'AnalysisId': analysisId,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateAnalysisResponse {
  /// The ID of the analysis.
  final String? analysisId;

  /// The ARN of the analysis that you're updating.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The update status of the last update that was made to the analysis.
  final ResourceStatus? updateStatus;

  UpdateAnalysisResponse({
    this.analysisId,
    this.arn,
    this.requestId,
    this.status,
    this.updateStatus,
  });

  factory UpdateAnalysisResponse.fromJson(Map<String, dynamic> json) {
    return UpdateAnalysisResponse(
      analysisId: json['AnalysisId'] as String?,
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      updateStatus: (json['UpdateStatus'] as String?)?.toResourceStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final analysisId = this.analysisId;
    final arn = this.arn;
    final requestId = this.requestId;
    final status = this.status;
    final updateStatus = this.updateStatus;
    return {
      if (analysisId != null) 'AnalysisId': analysisId,
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (updateStatus != null) 'UpdateStatus': updateStatus.toValue(),
    };
  }
}

class UpdateDashboardLinksResponse {
  /// The Amazon Resource Name (ARN) of the dashboard.
  final String? dashboardArn;

  /// A list of analysis Amazon Resource Names (ARNs) to be linked to the
  /// dashboard.
  final List<String>? linkEntities;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateDashboardLinksResponse({
    this.dashboardArn,
    this.linkEntities,
    this.requestId,
    this.status,
  });

  factory UpdateDashboardLinksResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDashboardLinksResponse(
      dashboardArn: json['DashboardArn'] as String?,
      linkEntities: (json['LinkEntities'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardArn = this.dashboardArn;
    final linkEntities = this.linkEntities;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardArn != null) 'DashboardArn': dashboardArn,
      if (linkEntities != null) 'LinkEntities': linkEntities,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateDashboardPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the dashboard.
  final String? dashboardArn;

  /// The ID for the dashboard.
  final String? dashboardId;

  /// Updates the permissions of a shared link to an Amazon QuickSight dashboard.
  final LinkSharingConfiguration? linkSharingConfiguration;

  /// Information about the permissions on the dashboard.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateDashboardPermissionsResponse({
    this.dashboardArn,
    this.dashboardId,
    this.linkSharingConfiguration,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory UpdateDashboardPermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateDashboardPermissionsResponse(
      dashboardArn: json['DashboardArn'] as String?,
      dashboardId: json['DashboardId'] as String?,
      linkSharingConfiguration: json['LinkSharingConfiguration'] != null
          ? LinkSharingConfiguration.fromJson(
              json['LinkSharingConfiguration'] as Map<String, dynamic>)
          : null,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardArn = this.dashboardArn;
    final dashboardId = this.dashboardId;
    final linkSharingConfiguration = this.linkSharingConfiguration;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardArn != null) 'DashboardArn': dashboardArn,
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (linkSharingConfiguration != null)
        'LinkSharingConfiguration': linkSharingConfiguration,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateDashboardPublishedVersionResponse {
  /// The Amazon Resource Name (ARN) of the dashboard.
  final String? dashboardArn;

  /// The ID for the dashboard.
  final String? dashboardId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateDashboardPublishedVersionResponse({
    this.dashboardArn,
    this.dashboardId,
    this.requestId,
    this.status,
  });

  factory UpdateDashboardPublishedVersionResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateDashboardPublishedVersionResponse(
      dashboardArn: json['DashboardArn'] as String?,
      dashboardId: json['DashboardId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dashboardArn = this.dashboardArn;
    final dashboardId = this.dashboardId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dashboardArn != null) 'DashboardArn': dashboardArn,
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateDashboardResponse {
  /// The Amazon Resource Name (ARN) of the resource.
  final String? arn;

  /// The creation status of the request.
  final ResourceStatus? creationStatus;

  /// The ID for the dashboard.
  final String? dashboardId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ARN of the dashboard, including the version number.
  final String? versionArn;

  UpdateDashboardResponse({
    this.arn,
    this.creationStatus,
    this.dashboardId,
    this.requestId,
    this.status,
    this.versionArn,
  });

  factory UpdateDashboardResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDashboardResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      dashboardId: json['DashboardId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      versionArn: json['VersionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final dashboardId = this.dashboardId;
    final requestId = this.requestId;
    final status = this.status;
    final versionArn = this.versionArn;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (dashboardId != null) 'DashboardId': dashboardId,
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
      if (versionArn != null) 'VersionArn': versionArn,
    };
  }
}

class UpdateDataSetPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? dataSetArn;

  /// The ID for the dataset whose permissions you want to update. This ID is
  /// unique per Amazon Web Services Region for each Amazon Web Services account.
  final String? dataSetId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateDataSetPermissionsResponse({
    this.dataSetArn,
    this.dataSetId,
    this.requestId,
    this.status,
  });

  factory UpdateDataSetPermissionsResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDataSetPermissionsResponse(
      dataSetArn: json['DataSetArn'] as String?,
      dataSetId: json['DataSetId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSetArn = this.dataSetArn;
    final dataSetId = this.dataSetId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSetArn != null) 'DataSetArn': dataSetArn,
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateDataSetResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? arn;

  /// The ID for the dataset that you want to create. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? dataSetId;

  /// The ARN for the ingestion, which is triggered as a result of dataset
  /// creation if the import mode is SPICE.
  final String? ingestionArn;

  /// The ID of the ingestion, which is triggered as a result of dataset creation
  /// if the import mode is SPICE.
  final String? ingestionId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateDataSetResponse({
    this.arn,
    this.dataSetId,
    this.ingestionArn,
    this.ingestionId,
    this.requestId,
    this.status,
  });

  factory UpdateDataSetResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDataSetResponse(
      arn: json['Arn'] as String?,
      dataSetId: json['DataSetId'] as String?,
      ingestionArn: json['IngestionArn'] as String?,
      ingestionId: json['IngestionId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSetId = this.dataSetId;
    final ingestionArn = this.ingestionArn;
    final ingestionId = this.ingestionId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (dataSetId != null) 'DataSetId': dataSetId,
      if (ingestionArn != null) 'IngestionArn': ingestionArn,
      if (ingestionId != null) 'IngestionId': ingestionId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateDataSourcePermissionsResponse {
  /// The Amazon Resource Name (ARN) of the data source.
  final String? dataSourceArn;

  /// The ID of the data source. This ID is unique per Amazon Web Services Region
  /// for each Amazon Web Services account.
  final String? dataSourceId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateDataSourcePermissionsResponse({
    this.dataSourceArn,
    this.dataSourceId,
    this.requestId,
    this.status,
  });

  factory UpdateDataSourcePermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateDataSourcePermissionsResponse(
      dataSourceArn: json['DataSourceArn'] as String?,
      dataSourceId: json['DataSourceId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final dataSourceArn = this.dataSourceArn;
    final dataSourceId = this.dataSourceId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (dataSourceArn != null) 'DataSourceArn': dataSourceArn,
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateDataSourceResponse {
  /// The Amazon Resource Name (ARN) of the data source.
  final String? arn;

  /// The ID of the data source. This ID is unique per Amazon Web Services Region
  /// for each Amazon Web Services account.
  final String? dataSourceId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The update status of the data source's last update.
  final ResourceStatus? updateStatus;

  UpdateDataSourceResponse({
    this.arn,
    this.dataSourceId,
    this.requestId,
    this.status,
    this.updateStatus,
  });

  factory UpdateDataSourceResponse.fromJson(Map<String, dynamic> json) {
    return UpdateDataSourceResponse(
      arn: json['Arn'] as String?,
      dataSourceId: json['DataSourceId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      updateStatus: (json['UpdateStatus'] as String?)?.toResourceStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final dataSourceId = this.dataSourceId;
    final requestId = this.requestId;
    final status = this.status;
    final updateStatus = this.updateStatus;
    return {
      if (arn != null) 'Arn': arn,
      if (dataSourceId != null) 'DataSourceId': dataSourceId,
      if (requestId != null) 'RequestId': requestId,
      if (updateStatus != null) 'UpdateStatus': updateStatus.toValue(),
    };
  }
}

class UpdateFolderPermissionsResponse {
  /// The Amazon Resource Name (ARN) of the folder.
  final String? arn;

  /// The ID of the folder.
  final String? folderId;

  /// Information about the permissions for the folder.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateFolderPermissionsResponse({
    this.arn,
    this.folderId,
    this.permissions,
    this.requestId,
    this.status,
  });

  factory UpdateFolderPermissionsResponse.fromJson(Map<String, dynamic> json) {
    return UpdateFolderPermissionsResponse(
      arn: json['Arn'] as String?,
      folderId: json['FolderId'] as String?,
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final folderId = this.folderId;
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (folderId != null) 'FolderId': folderId,
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class UpdateFolderResponse {
  /// The Amazon Resource Name (ARN) of the folder.
  final String? arn;

  /// The ID of the folder.
  final String? folderId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateFolderResponse({
    this.arn,
    this.folderId,
    this.requestId,
    this.status,
  });

  factory UpdateFolderResponse.fromJson(Map<String, dynamic> json) {
    return UpdateFolderResponse(
      arn: json['Arn'] as String?,
      folderId: json['FolderId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final folderId = this.folderId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (folderId != null) 'FolderId': folderId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateGroupResponse {
  /// The name of the group.
  final Group? group;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateGroupResponse({
    this.group,
    this.requestId,
    this.status,
  });

  factory UpdateGroupResponse.fromJson(Map<String, dynamic> json) {
    return UpdateGroupResponse(
      group: json['Group'] != null
          ? Group.fromJson(json['Group'] as Map<String, dynamic>)
          : null,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final group = this.group;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (group != null) 'Group': group,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateIAMPolicyAssignmentResponse {
  /// The ID of the assignment.
  final String? assignmentId;

  /// The name of the assignment or rule.
  final String? assignmentName;

  /// The status of the assignment. Possible values are as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>ENABLED</code> - Anything specified in this assignment is used when
  /// creating the data source.
  /// </li>
  /// <li>
  /// <code>DISABLED</code> - This assignment isn't used when creating the data
  /// source.
  /// </li>
  /// <li>
  /// <code>DRAFT</code> - This assignment is an unfinished draft and isn't used
  /// when creating the data source.
  /// </li>
  /// </ul>
  final AssignmentStatus? assignmentStatus;

  /// The Amazon QuickSight users, groups, or both that the IAM policy is assigned
  /// to.
  final Map<String, List<String>>? identities;

  /// The ARN for the IAM policy applied to the Amazon QuickSight users and groups
  /// specified in this assignment.
  final String? policyArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateIAMPolicyAssignmentResponse({
    this.assignmentId,
    this.assignmentName,
    this.assignmentStatus,
    this.identities,
    this.policyArn,
    this.requestId,
    this.status,
  });

  factory UpdateIAMPolicyAssignmentResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateIAMPolicyAssignmentResponse(
      assignmentId: json['AssignmentId'] as String?,
      assignmentName: json['AssignmentName'] as String?,
      assignmentStatus:
          (json['AssignmentStatus'] as String?)?.toAssignmentStatus(),
      identities: (json['Identities'] as Map<String, dynamic>?)?.map((k, e) =>
          MapEntry(
              k, (e as List).whereNotNull().map((e) => e as String).toList())),
      policyArn: json['PolicyArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final assignmentId = this.assignmentId;
    final assignmentName = this.assignmentName;
    final assignmentStatus = this.assignmentStatus;
    final identities = this.identities;
    final policyArn = this.policyArn;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (assignmentId != null) 'AssignmentId': assignmentId,
      if (assignmentName != null) 'AssignmentName': assignmentName,
      if (assignmentStatus != null)
        'AssignmentStatus': assignmentStatus.toValue(),
      if (identities != null) 'Identities': identities,
      if (policyArn != null) 'PolicyArn': policyArn,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateIdentityPropagationConfigResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateIdentityPropagationConfigResponse({
    this.requestId,
    this.status,
  });

  factory UpdateIdentityPropagationConfigResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateIdentityPropagationConfigResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateIpRestrictionResponse {
  /// The ID of the Amazon Web Services account that contains the IP rules.
  final String? awsAccountId;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateIpRestrictionResponse({
    this.awsAccountId,
    this.requestId,
    this.status,
  });

  factory UpdateIpRestrictionResponse.fromJson(Map<String, dynamic> json) {
    return UpdateIpRestrictionResponse(
      awsAccountId: json['AwsAccountId'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final awsAccountId = this.awsAccountId;
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (awsAccountId != null) 'AwsAccountId': awsAccountId,
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateKeyRegistrationResponse {
  /// A list of all customer managed key registrations that failed to update.
  final List<FailedKeyRegistrationEntry>? failedKeyRegistration;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// A list of all customer managed key registrations that were successfully
  /// updated.
  final List<SuccessfulKeyRegistrationEntry>? successfulKeyRegistration;

  UpdateKeyRegistrationResponse({
    this.failedKeyRegistration,
    this.requestId,
    this.successfulKeyRegistration,
  });

  factory UpdateKeyRegistrationResponse.fromJson(Map<String, dynamic> json) {
    return UpdateKeyRegistrationResponse(
      failedKeyRegistration: (json['FailedKeyRegistration'] as List?)
          ?.whereNotNull()
          .map((e) =>
              FailedKeyRegistrationEntry.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      successfulKeyRegistration: (json['SuccessfulKeyRegistration'] as List?)
          ?.whereNotNull()
          .map((e) => SuccessfulKeyRegistrationEntry.fromJson(
              e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final failedKeyRegistration = this.failedKeyRegistration;
    final requestId = this.requestId;
    final successfulKeyRegistration = this.successfulKeyRegistration;
    return {
      if (failedKeyRegistration != null)
        'FailedKeyRegistration': failedKeyRegistration,
      if (requestId != null) 'RequestId': requestId,
      if (successfulKeyRegistration != null)
        'SuccessfulKeyRegistration': successfulKeyRegistration,
    };
  }
}

class UpdatePublicSharingSettingsResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdatePublicSharingSettingsResponse({
    this.requestId,
    this.status,
  });

  factory UpdatePublicSharingSettingsResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdatePublicSharingSettingsResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) for the refresh schedule.
  final String? arn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The ID of the refresh schedule.
  final String? scheduleId;

  /// The HTTP status of the request.
  final int? status;

  UpdateRefreshScheduleResponse({
    this.arn,
    this.requestId,
    this.scheduleId,
    this.status,
  });

  factory UpdateRefreshScheduleResponse.fromJson(Map<String, dynamic> json) {
    return UpdateRefreshScheduleResponse(
      arn: json['Arn'] as String?,
      requestId: json['RequestId'] as String?,
      scheduleId: json['ScheduleId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final requestId = this.requestId;
    final scheduleId = this.scheduleId;
    final status = this.status;
    return {
      if (arn != null) 'Arn': arn,
      if (requestId != null) 'RequestId': requestId,
      if (scheduleId != null) 'ScheduleId': scheduleId,
    };
  }
}

class UpdateRoleCustomPermissionResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateRoleCustomPermissionResponse({
    this.requestId,
    this.status,
  });

  factory UpdateRoleCustomPermissionResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateRoleCustomPermissionResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (status != null) 'Status': status,
    };
  }
}

class UpdateSPICECapacityConfigurationResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  UpdateSPICECapacityConfigurationResponse({
    this.requestId,
    this.status,
  });

  factory UpdateSPICECapacityConfigurationResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateSPICECapacityConfigurationResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    return {
      if (requestId != null) 'RequestId': requestId,
    };
  }
}

class UpdateTemplateAliasResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The template alias.
  final TemplateAlias? templateAlias;

  UpdateTemplateAliasResponse({
    this.requestId,
    this.status,
    this.templateAlias,
  });

  factory UpdateTemplateAliasResponse.fromJson(Map<String, dynamic> json) {
    return UpdateTemplateAliasResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateAlias: json['TemplateAlias'] != null
          ? TemplateAlias.fromJson(
              json['TemplateAlias'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final templateAlias = this.templateAlias;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (templateAlias != null) 'TemplateAlias': templateAlias,
    };
  }
}

class UpdateTemplatePermissionsResponse {
  /// A list of resource permissions to be set on the template.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the template.
  final String? templateArn;

  /// The ID for the template.
  final String? templateId;

  UpdateTemplatePermissionsResponse({
    this.permissions,
    this.requestId,
    this.status,
    this.templateArn,
    this.templateId,
  });

  factory UpdateTemplatePermissionsResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateTemplatePermissionsResponse(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateArn: json['TemplateArn'] as String?,
      templateId: json['TemplateId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    final templateArn = this.templateArn;
    final templateId = this.templateId;
    return {
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (templateArn != null) 'TemplateArn': templateArn,
      if (templateId != null) 'TemplateId': templateId,
    };
  }
}

class UpdateTemplateResponse {
  /// The Amazon Resource Name (ARN) for the template.
  final String? arn;

  /// The creation status of the template.
  final ResourceStatus? creationStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID for the template.
  final String? templateId;

  /// The ARN for the template, including the version information of the first
  /// version.
  final String? versionArn;

  UpdateTemplateResponse({
    this.arn,
    this.creationStatus,
    this.requestId,
    this.status,
    this.templateId,
    this.versionArn,
  });

  factory UpdateTemplateResponse.fromJson(Map<String, dynamic> json) {
    return UpdateTemplateResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      templateId: json['TemplateId'] as String?,
      versionArn: json['VersionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final requestId = this.requestId;
    final status = this.status;
    final templateId = this.templateId;
    final versionArn = this.versionArn;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (templateId != null) 'TemplateId': templateId,
      if (versionArn != null) 'VersionArn': versionArn,
    };
  }
}

class UpdateThemeAliasResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// Information about the theme alias.
  final ThemeAlias? themeAlias;

  UpdateThemeAliasResponse({
    this.requestId,
    this.status,
    this.themeAlias,
  });

  factory UpdateThemeAliasResponse.fromJson(Map<String, dynamic> json) {
    return UpdateThemeAliasResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeAlias: json['ThemeAlias'] != null
          ? ThemeAlias.fromJson(json['ThemeAlias'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final themeAlias = this.themeAlias;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (themeAlias != null) 'ThemeAlias': themeAlias,
    };
  }
}

class UpdateThemePermissionsResponse {
  /// The resulting list of resource permissions for the theme.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the theme.
  final String? themeArn;

  /// The ID for the theme.
  final String? themeId;

  UpdateThemePermissionsResponse({
    this.permissions,
    this.requestId,
    this.status,
    this.themeArn,
    this.themeId,
  });

  factory UpdateThemePermissionsResponse.fromJson(Map<String, dynamic> json) {
    return UpdateThemePermissionsResponse(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeArn: json['ThemeArn'] as String?,
      themeId: json['ThemeId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    final themeArn = this.themeArn;
    final themeId = this.themeId;
    return {
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (themeArn != null) 'ThemeArn': themeArn,
      if (themeId != null) 'ThemeId': themeId,
    };
  }
}

class UpdateThemeResponse {
  /// The Amazon Resource Name (ARN) for the theme.
  final String? arn;

  /// The creation status of the theme.
  final ResourceStatus? creationStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID for the theme.
  final String? themeId;

  /// The Amazon Resource Name (ARN) for the new version of the theme.
  final String? versionArn;

  UpdateThemeResponse({
    this.arn,
    this.creationStatus,
    this.requestId,
    this.status,
    this.themeId,
    this.versionArn,
  });

  factory UpdateThemeResponse.fromJson(Map<String, dynamic> json) {
    return UpdateThemeResponse(
      arn: json['Arn'] as String?,
      creationStatus: (json['CreationStatus'] as String?)?.toResourceStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      themeId: json['ThemeId'] as String?,
      versionArn: json['VersionArn'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final creationStatus = this.creationStatus;
    final requestId = this.requestId;
    final status = this.status;
    final themeId = this.themeId;
    final versionArn = this.versionArn;
    return {
      if (arn != null) 'Arn': arn,
      if (creationStatus != null) 'CreationStatus': creationStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (themeId != null) 'ThemeId': themeId,
      if (versionArn != null) 'VersionArn': versionArn,
    };
  }
}

class UpdateTopicPermissionsResponse {
  /// A list of resource permissions on the topic.
  final List<ResourcePermission>? permissions;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  UpdateTopicPermissionsResponse({
    this.permissions,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory UpdateTopicPermissionsResponse.fromJson(Map<String, dynamic> json) {
    return UpdateTopicPermissionsResponse(
      permissions: (json['Permissions'] as List?)
          ?.whereNotNull()
          .map((e) => ResourcePermission.fromJson(e as Map<String, dynamic>))
          .toList(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final permissions = this.permissions;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (permissions != null) 'Permissions': permissions,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class UpdateTopicRefreshScheduleResponse {
  /// The Amazon Resource Name (ARN) of the dataset.
  final String? datasetArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon Resource Name (ARN) of the topic.
  final String? topicArn;

  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  UpdateTopicRefreshScheduleResponse({
    this.datasetArn,
    this.requestId,
    this.status,
    this.topicArn,
    this.topicId,
  });

  factory UpdateTopicRefreshScheduleResponse.fromJson(
      Map<String, dynamic> json) {
    return UpdateTopicRefreshScheduleResponse(
      datasetArn: json['DatasetArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicArn: json['TopicArn'] as String?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final datasetArn = this.datasetArn;
    final requestId = this.requestId;
    final status = this.status;
    final topicArn = this.topicArn;
    final topicId = this.topicId;
    return {
      if (datasetArn != null) 'DatasetArn': datasetArn,
      if (requestId != null) 'RequestId': requestId,
      if (topicArn != null) 'TopicArn': topicArn,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class UpdateTopicResponse {
  /// The Amazon Resource Name (ARN) of the topic.
  final String? arn;

  /// The Amazon Resource Name (ARN) of the topic refresh.
  final String? refreshArn;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The ID of the topic that you want to modify. This ID is unique per Amazon
  /// Web Services Region for each Amazon Web Services account.
  final String? topicId;

  UpdateTopicResponse({
    this.arn,
    this.refreshArn,
    this.requestId,
    this.status,
    this.topicId,
  });

  factory UpdateTopicResponse.fromJson(Map<String, dynamic> json) {
    return UpdateTopicResponse(
      arn: json['Arn'] as String?,
      refreshArn: json['RefreshArn'] as String?,
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      topicId: json['TopicId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final refreshArn = this.refreshArn;
    final requestId = this.requestId;
    final status = this.status;
    final topicId = this.topicId;
    return {
      if (arn != null) 'Arn': arn,
      if (refreshArn != null) 'RefreshArn': refreshArn,
      if (requestId != null) 'RequestId': requestId,
      if (topicId != null) 'TopicId': topicId,
    };
  }
}

class UpdateUserResponse {
  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The Amazon QuickSight user.
  final User? user;

  UpdateUserResponse({
    this.requestId,
    this.status,
    this.user,
  });

  factory UpdateUserResponse.fromJson(Map<String, dynamic> json) {
    return UpdateUserResponse(
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      user: json['User'] != null
          ? User.fromJson(json['User'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final requestId = this.requestId;
    final status = this.status;
    final user = this.user;
    return {
      if (requestId != null) 'RequestId': requestId,
      if (user != null) 'User': user,
    };
  }
}

class UpdateVPCConnectionResponse {
  /// The Amazon Resource Name (ARN) of the VPC connection.
  final String? arn;

  /// The availability status of the VPC connection.
  final VPCConnectionAvailabilityStatus? availabilityStatus;

  /// The Amazon Web Services request ID for this operation.
  final String? requestId;

  /// The HTTP status of the request.
  final int? status;

  /// The update status of the VPC connection's last update.
  final VPCConnectionResourceStatus? updateStatus;

  /// The ID of the VPC connection that you are updating. This ID is a unique
  /// identifier for each Amazon Web Services Region in anAmazon Web Services
  /// account.
  final String? vPCConnectionId;

  UpdateVPCConnectionResponse({
    this.arn,
    this.availabilityStatus,
    this.requestId,
    this.status,
    this.updateStatus,
    this.vPCConnectionId,
  });

  factory UpdateVPCConnectionResponse.fromJson(Map<String, dynamic> json) {
    return UpdateVPCConnectionResponse(
      arn: json['Arn'] as String?,
      availabilityStatus: (json['AvailabilityStatus'] as String?)
          ?.toVPCConnectionAvailabilityStatus(),
      requestId: json['RequestId'] as String?,
      status: json['Status'] as int?,
      updateStatus:
          (json['UpdateStatus'] as String?)?.toVPCConnectionResourceStatus(),
      vPCConnectionId: json['VPCConnectionId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final availabilityStatus = this.availabilityStatus;
    final requestId = this.requestId;
    final status = this.status;
    final updateStatus = this.updateStatus;
    final vPCConnectionId = this.vPCConnectionId;
    return {
      if (arn != null) 'Arn': arn,
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
      if (requestId != null) 'RequestId': requestId,
      if (updateStatus != null) 'UpdateStatus': updateStatus.toValue(),
      if (vPCConnectionId != null) 'VPCConnectionId': vPCConnectionId,
    };
  }
}

/// Information about the format for a source file or files.
class UploadSettings {
  /// Whether the file has a header row, or the files each have a header row.
  final bool? containsHeader;

  /// The delimiter between values in the file.
  final String? delimiter;

  /// File format.
  final FileFormat? format;

  /// A row number to start reading data from.
  final int? startFromRow;

  /// Text qualifier.
  final TextQualifier? textQualifier;

  UploadSettings({
    this.containsHeader,
    this.delimiter,
    this.format,
    this.startFromRow,
    this.textQualifier,
  });

  factory UploadSettings.fromJson(Map<String, dynamic> json) {
    return UploadSettings(
      containsHeader: json['ContainsHeader'] as bool?,
      delimiter: json['Delimiter'] as String?,
      format: (json['Format'] as String?)?.toFileFormat(),
      startFromRow: json['StartFromRow'] as int?,
      textQualifier: (json['TextQualifier'] as String?)?.toTextQualifier(),
    );
  }

  Map<String, dynamic> toJson() {
    final containsHeader = this.containsHeader;
    final delimiter = this.delimiter;
    final format = this.format;
    final startFromRow = this.startFromRow;
    final textQualifier = this.textQualifier;
    return {
      if (containsHeader != null) 'ContainsHeader': containsHeader,
      if (delimiter != null) 'Delimiter': delimiter,
      if (format != null) 'Format': format.toValue(),
      if (startFromRow != null) 'StartFromRow': startFromRow,
      if (textQualifier != null) 'TextQualifier': textQualifier.toValue(),
    };
  }
}

/// A registered user of Amazon QuickSight.
class User {
  /// The active status of user. When you create an Amazon QuickSight user that's
  /// not an IAM user or an Active Directory user, that user is inactive until
  /// they sign in and provide a password.
  final bool? active;

  /// The Amazon Resource Name (ARN) for the user.
  final String? arn;

  /// The custom permissions profile associated with this user.
  final String? customPermissionsName;

  /// The user's email address.
  final String? email;

  /// The type of supported external login provider that provides identity to let
  /// the user federate into Amazon QuickSight with an associated IAM role. The
  /// type can be one of the following.
  ///
  /// <ul>
  /// <li>
  /// <code>COGNITO</code>: Amazon Cognito. The provider URL is
  /// cognito-identity.amazonaws.com.
  /// </li>
  /// <li>
  /// <code>CUSTOM_OIDC</code>: Custom OpenID Connect (OIDC) provider.
  /// </li>
  /// </ul>
  final String? externalLoginFederationProviderType;

  /// The URL of the external login provider.
  final String? externalLoginFederationProviderUrl;

  /// The identity ID for the user in the external login provider.
  final String? externalLoginId;

  /// The type of identity authentication used by the user.
  final IdentityType? identityType;

  /// The principal ID of the user.
  final String? principalId;

  /// The Amazon QuickSight role for the user. The user role can be one of the
  /// following:.
  ///
  /// <ul>
  /// <li>
  /// <code>READER</code>: A user who has read-only access to dashboards.
  /// </li>
  /// <li>
  /// <code>AUTHOR</code>: A user who can create data sources, datasets, analyses,
  /// and dashboards.
  /// </li>
  /// <li>
  /// <code>ADMIN</code>: A user who is an author, who can also manage Amazon
  /// Amazon QuickSight settings.
  /// </li>
  /// <li>
  /// <code>READER_PRO</code>: Reader Pro adds Generative BI capabilities to the
  /// Reader role. Reader Pros have access to Amazon Q in Amazon QuickSight, can
  /// build stories with Amazon Q, and can generate executive summaries from
  /// dashboards.
  /// </li>
  /// <li>
  /// <code>AUTHOR_PRO</code>: Author Pro adds Generative BI capabilities to the
  /// Author role. Author Pros can author dashboards with natural language with
  /// Amazon Q, build stories with Amazon Q, create Topics for Q&amp;A, and
  /// generate executive summaries from dashboards.
  /// </li>
  /// <li>
  /// <code>ADMIN_PRO</code>: Admin Pros are Author Pros who can also manage
  /// Amazon QuickSight administrative settings. Admin Pro users are billed at
  /// Author Pro pricing.
  /// </li>
  /// <li>
  /// <code>RESTRICTED_READER</code>: This role isn't currently available for use.
  /// </li>
  /// <li>
  /// <code>RESTRICTED_AUTHOR</code>: This role isn't currently available for use.
  /// </li>
  /// </ul>
  final UserRole? role;

  /// The user's user name. This value is required if you are registering a user
  /// that will be managed in Amazon QuickSight. In the output, the value for
  /// <code>UserName</code> is <code>N/A</code> when the value for
  /// <code>IdentityType</code> is <code>IAM</code> and the corresponding IAM user
  /// is deleted.
  final String? userName;

  User({
    this.active,
    this.arn,
    this.customPermissionsName,
    this.email,
    this.externalLoginFederationProviderType,
    this.externalLoginFederationProviderUrl,
    this.externalLoginId,
    this.identityType,
    this.principalId,
    this.role,
    this.userName,
  });

  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      active: json['Active'] as bool?,
      arn: json['Arn'] as String?,
      customPermissionsName: json['CustomPermissionsName'] as String?,
      email: json['Email'] as String?,
      externalLoginFederationProviderType:
          json['ExternalLoginFederationProviderType'] as String?,
      externalLoginFederationProviderUrl:
          json['ExternalLoginFederationProviderUrl'] as String?,
      externalLoginId: json['ExternalLoginId'] as String?,
      identityType: (json['IdentityType'] as String?)?.toIdentityType(),
      principalId: json['PrincipalId'] as String?,
      role: (json['Role'] as String?)?.toUserRole(),
      userName: json['UserName'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final active = this.active;
    final arn = this.arn;
    final customPermissionsName = this.customPermissionsName;
    final email = this.email;
    final externalLoginFederationProviderType =
        this.externalLoginFederationProviderType;
    final externalLoginFederationProviderUrl =
        this.externalLoginFederationProviderUrl;
    final externalLoginId = this.externalLoginId;
    final identityType = this.identityType;
    final principalId = this.principalId;
    final role = this.role;
    final userName = this.userName;
    return {
      if (active != null) 'Active': active,
      if (arn != null) 'Arn': arn,
      if (customPermissionsName != null)
        'CustomPermissionsName': customPermissionsName,
      if (email != null) 'Email': email,
      if (externalLoginFederationProviderType != null)
        'ExternalLoginFederationProviderType':
            externalLoginFederationProviderType,
      if (externalLoginFederationProviderUrl != null)
        'ExternalLoginFederationProviderUrl':
            externalLoginFederationProviderUrl,
      if (externalLoginId != null) 'ExternalLoginId': externalLoginId,
      if (identityType != null) 'IdentityType': identityType.toValue(),
      if (principalId != null) 'PrincipalId': principalId,
      if (role != null) 'Role': role.toValue(),
      if (userName != null) 'UserName': userName,
    };
  }
}

enum UserRole {
  admin,
  author,
  reader,
  restrictedAuthor,
  restrictedReader,
  adminPro,
  authorPro,
  readerPro,
}

extension UserRoleValueExtension on UserRole {
  String toValue() {
    switch (this) {
      case UserRole.admin:
        return 'ADMIN';
      case UserRole.author:
        return 'AUTHOR';
      case UserRole.reader:
        return 'READER';
      case UserRole.restrictedAuthor:
        return 'RESTRICTED_AUTHOR';
      case UserRole.restrictedReader:
        return 'RESTRICTED_READER';
      case UserRole.adminPro:
        return 'ADMIN_PRO';
      case UserRole.authorPro:
        return 'AUTHOR_PRO';
      case UserRole.readerPro:
        return 'READER_PRO';
    }
  }
}

extension UserRoleFromString on String {
  UserRole toUserRole() {
    switch (this) {
      case 'ADMIN':
        return UserRole.admin;
      case 'AUTHOR':
        return UserRole.author;
      case 'READER':
        return UserRole.reader;
      case 'RESTRICTED_AUTHOR':
        return UserRole.restrictedAuthor;
      case 'RESTRICTED_READER':
        return UserRole.restrictedReader;
      case 'ADMIN_PRO':
        return UserRole.adminPro;
      case 'AUTHOR_PRO':
        return UserRole.authorPro;
      case 'READER_PRO':
        return UserRole.readerPro;
    }
    throw Exception('$this is not known in enum UserRole');
  }
}

/// The structure of a VPC connection.
class VPCConnection {
  /// The Amazon Resource Name (ARN) of the VPC connection.
  final String? arn;

  /// The availability status of the VPC connection.
  final VPCConnectionAvailabilityStatus? availabilityStatus;

  /// The time that the VPC connection was created.
  final DateTime? createdTime;

  /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
  final List<String>? dnsResolvers;

  /// The time that the VPC connection was last updated.
  final DateTime? lastUpdatedTime;

  /// The display name for the VPC connection.
  final String? name;

  /// A list of network interfaces.
  final List<NetworkInterface>? networkInterfaces;

  /// The ARN of the IAM role associated with the VPC connection.
  final String? roleArn;

  /// The Amazon EC2 security group IDs associated with the VPC connection.
  final List<String>? securityGroupIds;

  /// The status of the VPC connection.
  final VPCConnectionResourceStatus? status;

  /// The ID of the VPC connection that you're creating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  final String? vPCConnectionId;

  /// The Amazon EC2 VPC ID associated with the VPC connection.
  final String? vPCId;

  VPCConnection({
    this.arn,
    this.availabilityStatus,
    this.createdTime,
    this.dnsResolvers,
    this.lastUpdatedTime,
    this.name,
    this.networkInterfaces,
    this.roleArn,
    this.securityGroupIds,
    this.status,
    this.vPCConnectionId,
    this.vPCId,
  });

  factory VPCConnection.fromJson(Map<String, dynamic> json) {
    return VPCConnection(
      arn: json['Arn'] as String?,
      availabilityStatus: (json['AvailabilityStatus'] as String?)
          ?.toVPCConnectionAvailabilityStatus(),
      createdTime: timeStampFromJson(json['CreatedTime']),
      dnsResolvers: (json['DnsResolvers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      networkInterfaces: (json['NetworkInterfaces'] as List?)
          ?.whereNotNull()
          .map((e) => NetworkInterface.fromJson(e as Map<String, dynamic>))
          .toList(),
      roleArn: json['RoleArn'] as String?,
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      status: (json['Status'] as String?)?.toVPCConnectionResourceStatus(),
      vPCConnectionId: json['VPCConnectionId'] as String?,
      vPCId: json['VPCId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final availabilityStatus = this.availabilityStatus;
    final createdTime = this.createdTime;
    final dnsResolvers = this.dnsResolvers;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final networkInterfaces = this.networkInterfaces;
    final roleArn = this.roleArn;
    final securityGroupIds = this.securityGroupIds;
    final status = this.status;
    final vPCConnectionId = this.vPCConnectionId;
    final vPCId = this.vPCId;
    return {
      if (arn != null) 'Arn': arn,
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dnsResolvers != null) 'DnsResolvers': dnsResolvers,
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (networkInterfaces != null) 'NetworkInterfaces': networkInterfaces,
      if (roleArn != null) 'RoleArn': roleArn,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (status != null) 'Status': status.toValue(),
      if (vPCConnectionId != null) 'VPCConnectionId': vPCConnectionId,
      if (vPCId != null) 'VPCId': vPCId,
    };
  }
}

enum VPCConnectionAvailabilityStatus {
  available,
  unavailable,
  partiallyAvailable,
}

extension VPCConnectionAvailabilityStatusValueExtension
    on VPCConnectionAvailabilityStatus {
  String toValue() {
    switch (this) {
      case VPCConnectionAvailabilityStatus.available:
        return 'AVAILABLE';
      case VPCConnectionAvailabilityStatus.unavailable:
        return 'UNAVAILABLE';
      case VPCConnectionAvailabilityStatus.partiallyAvailable:
        return 'PARTIALLY_AVAILABLE';
    }
  }
}

extension VPCConnectionAvailabilityStatusFromString on String {
  VPCConnectionAvailabilityStatus toVPCConnectionAvailabilityStatus() {
    switch (this) {
      case 'AVAILABLE':
        return VPCConnectionAvailabilityStatus.available;
      case 'UNAVAILABLE':
        return VPCConnectionAvailabilityStatus.unavailable;
      case 'PARTIALLY_AVAILABLE':
        return VPCConnectionAvailabilityStatus.partiallyAvailable;
    }
    throw Exception(
        '$this is not known in enum VPCConnectionAvailabilityStatus');
  }
}

enum VPCConnectionResourceStatus {
  creationInProgress,
  creationSuccessful,
  creationFailed,
  updateInProgress,
  updateSuccessful,
  updateFailed,
  deletionInProgress,
  deletionFailed,
  deleted,
}

extension VPCConnectionResourceStatusValueExtension
    on VPCConnectionResourceStatus {
  String toValue() {
    switch (this) {
      case VPCConnectionResourceStatus.creationInProgress:
        return 'CREATION_IN_PROGRESS';
      case VPCConnectionResourceStatus.creationSuccessful:
        return 'CREATION_SUCCESSFUL';
      case VPCConnectionResourceStatus.creationFailed:
        return 'CREATION_FAILED';
      case VPCConnectionResourceStatus.updateInProgress:
        return 'UPDATE_IN_PROGRESS';
      case VPCConnectionResourceStatus.updateSuccessful:
        return 'UPDATE_SUCCESSFUL';
      case VPCConnectionResourceStatus.updateFailed:
        return 'UPDATE_FAILED';
      case VPCConnectionResourceStatus.deletionInProgress:
        return 'DELETION_IN_PROGRESS';
      case VPCConnectionResourceStatus.deletionFailed:
        return 'DELETION_FAILED';
      case VPCConnectionResourceStatus.deleted:
        return 'DELETED';
    }
  }
}

extension VPCConnectionResourceStatusFromString on String {
  VPCConnectionResourceStatus toVPCConnectionResourceStatus() {
    switch (this) {
      case 'CREATION_IN_PROGRESS':
        return VPCConnectionResourceStatus.creationInProgress;
      case 'CREATION_SUCCESSFUL':
        return VPCConnectionResourceStatus.creationSuccessful;
      case 'CREATION_FAILED':
        return VPCConnectionResourceStatus.creationFailed;
      case 'UPDATE_IN_PROGRESS':
        return VPCConnectionResourceStatus.updateInProgress;
      case 'UPDATE_SUCCESSFUL':
        return VPCConnectionResourceStatus.updateSuccessful;
      case 'UPDATE_FAILED':
        return VPCConnectionResourceStatus.updateFailed;
      case 'DELETION_IN_PROGRESS':
        return VPCConnectionResourceStatus.deletionInProgress;
      case 'DELETION_FAILED':
        return VPCConnectionResourceStatus.deletionFailed;
      case 'DELETED':
        return VPCConnectionResourceStatus.deleted;
    }
    throw Exception('$this is not known in enum VPCConnectionResourceStatus');
  }
}

/// The summary metadata that describes a VPC connection.
class VPCConnectionSummary {
  /// The Amazon Resource Name (ARN) of the VPC connection.
  final String? arn;

  /// The availability status of the VPC connection.
  final VPCConnectionAvailabilityStatus? availabilityStatus;

  /// The time that the VPC connection was created.
  final DateTime? createdTime;

  /// A list of IP addresses of DNS resolver endpoints for the VPC connection.
  final List<String>? dnsResolvers;

  /// The time that the VPC connection was last updated.
  final DateTime? lastUpdatedTime;

  /// The display name for the VPC connection.
  final String? name;

  /// A list of network interfaces.
  final List<NetworkInterface>? networkInterfaces;

  /// The ARN of the IAM role associated with the VPC connection.
  final String? roleArn;

  /// The Amazon EC2 security group IDs associated with the VPC connection.
  final List<String>? securityGroupIds;

  /// The status of the VPC connection.
  final VPCConnectionResourceStatus? status;

  /// The ID of the VPC connection that you're creating. This ID is a unique
  /// identifier for each Amazon Web Services Region in an Amazon Web Services
  /// account.
  final String? vPCConnectionId;

  /// The Amazon EC2 VPC ID associated with the VPC connection.
  final String? vPCId;

  VPCConnectionSummary({
    this.arn,
    this.availabilityStatus,
    this.createdTime,
    this.dnsResolvers,
    this.lastUpdatedTime,
    this.name,
    this.networkInterfaces,
    this.roleArn,
    this.securityGroupIds,
    this.status,
    this.vPCConnectionId,
    this.vPCId,
  });

  factory VPCConnectionSummary.fromJson(Map<String, dynamic> json) {
    return VPCConnectionSummary(
      arn: json['Arn'] as String?,
      availabilityStatus: (json['AvailabilityStatus'] as String?)
          ?.toVPCConnectionAvailabilityStatus(),
      createdTime: timeStampFromJson(json['CreatedTime']),
      dnsResolvers: (json['DnsResolvers'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      lastUpdatedTime: timeStampFromJson(json['LastUpdatedTime']),
      name: json['Name'] as String?,
      networkInterfaces: (json['NetworkInterfaces'] as List?)
          ?.whereNotNull()
          .map((e) => NetworkInterface.fromJson(e as Map<String, dynamic>))
          .toList(),
      roleArn: json['RoleArn'] as String?,
      securityGroupIds: (json['SecurityGroupIds'] as List?)
          ?.whereNotNull()
          .map((e) => e as String)
          .toList(),
      status: (json['Status'] as String?)?.toVPCConnectionResourceStatus(),
      vPCConnectionId: json['VPCConnectionId'] as String?,
      vPCId: json['VPCId'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final arn = this.arn;
    final availabilityStatus = this.availabilityStatus;
    final createdTime = this.createdTime;
    final dnsResolvers = this.dnsResolvers;
    final lastUpdatedTime = this.lastUpdatedTime;
    final name = this.name;
    final networkInterfaces = this.networkInterfaces;
    final roleArn = this.roleArn;
    final securityGroupIds = this.securityGroupIds;
    final status = this.status;
    final vPCConnectionId = this.vPCConnectionId;
    final vPCId = this.vPCId;
    return {
      if (arn != null) 'Arn': arn,
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
      if (createdTime != null) 'CreatedTime': unixTimestampToJson(createdTime),
      if (dnsResolvers != null) 'DnsResolvers': dnsResolvers,
      if (lastUpdatedTime != null)
        'LastUpdatedTime': unixTimestampToJson(lastUpdatedTime),
      if (name != null) 'Name': name,
      if (networkInterfaces != null) 'NetworkInterfaces': networkInterfaces,
      if (roleArn != null) 'RoleArn': roleArn,
      if (securityGroupIds != null) 'SecurityGroupIds': securityGroupIds,
      if (status != null) 'Status': status.toValue(),
      if (vPCConnectionId != null) 'VPCConnectionId': vPCConnectionId,
      if (vPCId != null) 'VPCId': vPCId,
    };
  }
}

/// The option to relax the validation that is required to create and update
/// analyses, dashboards, and templates with definition objects. When you set
/// this value to <code>LENIENT</code>, validation is skipped for specific
/// errors.
class ValidationStrategy {
  /// The mode of validation for the asset to be created or updated. When you set
  /// this value to <code>STRICT</code>, strict validation for every error is
  /// enforced. When you set this value to <code>LENIENT</code>, validation is
  /// skipped for specific UI errors.
  final ValidationStrategyMode mode;

  ValidationStrategy({
    required this.mode,
  });

  Map<String, dynamic> toJson() {
    final mode = this.mode;
    return {
      'Mode': mode.toValue(),
    };
  }
}

enum ValidationStrategyMode {
  strict,
  lenient,
}

extension ValidationStrategyModeValueExtension on ValidationStrategyMode {
  String toValue() {
    switch (this) {
      case ValidationStrategyMode.strict:
        return 'STRICT';
      case ValidationStrategyMode.lenient:
        return 'LENIENT';
    }
  }
}

extension ValidationStrategyModeFromString on String {
  ValidationStrategyMode toValidationStrategyMode() {
    switch (this) {
      case 'STRICT':
        return ValidationStrategyMode.strict;
      case 'LENIENT':
        return ValidationStrategyMode.lenient;
    }
    throw Exception('$this is not known in enum ValidationStrategyMode');
  }
}

enum ValueWhenUnsetOption {
  recommendedValue,
  $null,
}

extension ValueWhenUnsetOptionValueExtension on ValueWhenUnsetOption {
  String toValue() {
    switch (this) {
      case ValueWhenUnsetOption.recommendedValue:
        return 'RECOMMENDED_VALUE';
      case ValueWhenUnsetOption.$null:
        return 'NULL';
    }
  }
}

extension ValueWhenUnsetOptionFromString on String {
  ValueWhenUnsetOption toValueWhenUnsetOption() {
    switch (this) {
      case 'RECOMMENDED_VALUE':
        return ValueWhenUnsetOption.recommendedValue;
      case 'NULL':
        return ValueWhenUnsetOption.$null;
    }
    throw Exception('$this is not known in enum ValueWhenUnsetOption');
  }
}

enum VerticalTextAlignment {
  top,
  middle,
  bottom,
  auto,
}

extension VerticalTextAlignmentValueExtension on VerticalTextAlignment {
  String toValue() {
    switch (this) {
      case VerticalTextAlignment.top:
        return 'TOP';
      case VerticalTextAlignment.middle:
        return 'MIDDLE';
      case VerticalTextAlignment.bottom:
        return 'BOTTOM';
      case VerticalTextAlignment.auto:
        return 'AUTO';
    }
  }
}

extension VerticalTextAlignmentFromString on String {
  VerticalTextAlignment toVerticalTextAlignment() {
    switch (this) {
      case 'TOP':
        return VerticalTextAlignment.top;
      case 'MIDDLE':
        return VerticalTextAlignment.middle;
      case 'BOTTOM':
        return VerticalTextAlignment.bottom;
      case 'AUTO':
        return VerticalTextAlignment.auto;
    }
    throw Exception('$this is not known in enum VerticalTextAlignment');
  }
}

enum Visibility {
  hidden,
  visible,
}

extension VisibilityValueExtension on Visibility {
  String toValue() {
    switch (this) {
      case Visibility.hidden:
        return 'HIDDEN';
      case Visibility.visible:
        return 'VISIBLE';
    }
  }
}

extension VisibilityFromString on String {
  Visibility toVisibility() {
    switch (this) {
      case 'HIDDEN':
        return Visibility.hidden;
      case 'VISIBLE':
        return Visibility.visible;
    }
    throw Exception('$this is not known in enum Visibility');
  }
}

/// The range options for the data zoom scroll bar.
class VisibleRangeOptions {
  /// The percent range in the visible range.
  final PercentVisibleRange? percentRange;

  VisibleRangeOptions({
    this.percentRange,
  });

  factory VisibleRangeOptions.fromJson(Map<String, dynamic> json) {
    return VisibleRangeOptions(
      percentRange: json['PercentRange'] != null
          ? PercentVisibleRange.fromJson(
              json['PercentRange'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final percentRange = this.percentRange;
    return {
      if (percentRange != null) 'PercentRange': percentRange,
    };
  }
}

/// A visual displayed on a sheet in an analysis, dashboard, or template.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class Visual {
  /// A bar chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/bar-charts.html">Using
  /// bar charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final BarChartVisual? barChartVisual;

  /// A box plot.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/box-plots.html">Using
  /// box plots</a> in the <i>Amazon QuickSight User Guide</i>.
  final BoxPlotVisual? boxPlotVisual;

  /// A combo chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/combo-charts.html">Using
  /// combo charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final ComboChartVisual? comboChartVisual;

  /// A visual that contains custom content.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/custom-visual-content.html">Using
  /// custom visual content</a> in the <i>Amazon QuickSight User Guide</i>.
  final CustomContentVisual? customContentVisual;

  /// An empty visual.
  final EmptyVisual? emptyVisual;

  /// A filled map.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/filled-maps.html">Creating
  /// filled maps</a> in the <i>Amazon QuickSight User Guide</i>.
  final FilledMapVisual? filledMapVisual;

  /// A funnel chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/funnel-visual-content.html">Using
  /// funnel charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final FunnelChartVisual? funnelChartVisual;

  /// A gauge chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/gauge-chart.html">Using
  /// gauge charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final GaugeChartVisual? gaugeChartVisual;

  /// A geospatial map or a points on map visual.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/point-maps.html">Creating
  /// point maps</a> in the <i>Amazon QuickSight User Guide</i>.
  final GeospatialMapVisual? geospatialMapVisual;

  /// A heat map.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/heat-map.html">Using
  /// heat maps</a> in the <i>Amazon QuickSight User Guide</i>.
  final HeatMapVisual? heatMapVisual;

  /// A histogram.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/histogram-charts.html">Using
  /// histograms</a> in the <i>Amazon QuickSight User Guide</i>.
  final HistogramVisual? histogramVisual;

  /// An insight visual.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/computational-insights.html">Working
  /// with insights</a> in the <i>Amazon QuickSight User Guide</i>.
  final InsightVisual? insightVisual;

  /// A key performance indicator (KPI).
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/kpi.html">Using
  /// KPIs</a> in the <i>Amazon QuickSight User Guide</i>.
  final KPIVisual? kPIVisual;

  /// A line chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/line-charts.html">Using
  /// line charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final LineChartVisual? lineChartVisual;

  /// A pie or donut chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/pie-chart.html">Using
  /// pie charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final PieChartVisual? pieChartVisual;

  /// A pivot table.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/pivot-table.html">Using
  /// pivot tables</a> in the <i>Amazon QuickSight User Guide</i>.
  final PivotTableVisual? pivotTableVisual;

  /// A radar chart visual.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/radar-chart.html">Using
  /// radar charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final RadarChartVisual? radarChartVisual;

  /// A sankey diagram.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/sankey-diagram.html">Using
  /// Sankey diagrams</a> in the <i>Amazon QuickSight User Guide</i>.
  final SankeyDiagramVisual? sankeyDiagramVisual;

  /// A scatter plot.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/scatter-plot.html">Using
  /// scatter plots</a> in the <i>Amazon QuickSight User Guide</i>.
  final ScatterPlotVisual? scatterPlotVisual;

  /// A table visual.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/tabular.html">Using
  /// tables as visuals</a> in the <i>Amazon QuickSight User Guide</i>.
  final TableVisual? tableVisual;

  /// A tree map.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/tree-map.html">Using
  /// tree maps</a> in the <i>Amazon QuickSight User Guide</i>.
  final TreeMapVisual? treeMapVisual;

  /// A waterfall chart.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using
  /// waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.
  final WaterfallVisual? waterfallVisual;

  /// A word cloud.
  ///
  /// For more information, see <a
  /// href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using
  /// word clouds</a> in the <i>Amazon QuickSight User Guide</i>.
  final WordCloudVisual? wordCloudVisual;

  Visual({
    this.barChartVisual,
    this.boxPlotVisual,
    this.comboChartVisual,
    this.customContentVisual,
    this.emptyVisual,
    this.filledMapVisual,
    this.funnelChartVisual,
    this.gaugeChartVisual,
    this.geospatialMapVisual,
    this.heatMapVisual,
    this.histogramVisual,
    this.insightVisual,
    this.kPIVisual,
    this.lineChartVisual,
    this.pieChartVisual,
    this.pivotTableVisual,
    this.radarChartVisual,
    this.sankeyDiagramVisual,
    this.scatterPlotVisual,
    this.tableVisual,
    this.treeMapVisual,
    this.waterfallVisual,
    this.wordCloudVisual,
  });

  factory Visual.fromJson(Map<String, dynamic> json) {
    return Visual(
      barChartVisual: json['BarChartVisual'] != null
          ? BarChartVisual.fromJson(
              json['BarChartVisual'] as Map<String, dynamic>)
          : null,
      boxPlotVisual: json['BoxPlotVisual'] != null
          ? BoxPlotVisual.fromJson(
              json['BoxPlotVisual'] as Map<String, dynamic>)
          : null,
      comboChartVisual: json['ComboChartVisual'] != null
          ? ComboChartVisual.fromJson(
              json['ComboChartVisual'] as Map<String, dynamic>)
          : null,
      customContentVisual: json['CustomContentVisual'] != null
          ? CustomContentVisual.fromJson(
              json['CustomContentVisual'] as Map<String, dynamic>)
          : null,
      emptyVisual: json['EmptyVisual'] != null
          ? EmptyVisual.fromJson(json['EmptyVisual'] as Map<String, dynamic>)
          : null,
      filledMapVisual: json['FilledMapVisual'] != null
          ? FilledMapVisual.fromJson(
              json['FilledMapVisual'] as Map<String, dynamic>)
          : null,
      funnelChartVisual: json['FunnelChartVisual'] != null
          ? FunnelChartVisual.fromJson(
              json['FunnelChartVisual'] as Map<String, dynamic>)
          : null,
      gaugeChartVisual: json['GaugeChartVisual'] != null
          ? GaugeChartVisual.fromJson(
              json['GaugeChartVisual'] as Map<String, dynamic>)
          : null,
      geospatialMapVisual: json['GeospatialMapVisual'] != null
          ? GeospatialMapVisual.fromJson(
              json['GeospatialMapVisual'] as Map<String, dynamic>)
          : null,
      heatMapVisual: json['HeatMapVisual'] != null
          ? HeatMapVisual.fromJson(
              json['HeatMapVisual'] as Map<String, dynamic>)
          : null,
      histogramVisual: json['HistogramVisual'] != null
          ? HistogramVisual.fromJson(
              json['HistogramVisual'] as Map<String, dynamic>)
          : null,
      insightVisual: json['InsightVisual'] != null
          ? InsightVisual.fromJson(
              json['InsightVisual'] as Map<String, dynamic>)
          : null,
      kPIVisual: json['KPIVisual'] != null
          ? KPIVisual.fromJson(json['KPIVisual'] as Map<String, dynamic>)
          : null,
      lineChartVisual: json['LineChartVisual'] != null
          ? LineChartVisual.fromJson(
              json['LineChartVisual'] as Map<String, dynamic>)
          : null,
      pieChartVisual: json['PieChartVisual'] != null
          ? PieChartVisual.fromJson(
              json['PieChartVisual'] as Map<String, dynamic>)
          : null,
      pivotTableVisual: json['PivotTableVisual'] != null
          ? PivotTableVisual.fromJson(
              json['PivotTableVisual'] as Map<String, dynamic>)
          : null,
      radarChartVisual: json['RadarChartVisual'] != null
          ? RadarChartVisual.fromJson(
              json['RadarChartVisual'] as Map<String, dynamic>)
          : null,
      sankeyDiagramVisual: json['SankeyDiagramVisual'] != null
          ? SankeyDiagramVisual.fromJson(
              json['SankeyDiagramVisual'] as Map<String, dynamic>)
          : null,
      scatterPlotVisual: json['ScatterPlotVisual'] != null
          ? ScatterPlotVisual.fromJson(
              json['ScatterPlotVisual'] as Map<String, dynamic>)
          : null,
      tableVisual: json['TableVisual'] != null
          ? TableVisual.fromJson(json['TableVisual'] as Map<String, dynamic>)
          : null,
      treeMapVisual: json['TreeMapVisual'] != null
          ? TreeMapVisual.fromJson(
              json['TreeMapVisual'] as Map<String, dynamic>)
          : null,
      waterfallVisual: json['WaterfallVisual'] != null
          ? WaterfallVisual.fromJson(
              json['WaterfallVisual'] as Map<String, dynamic>)
          : null,
      wordCloudVisual: json['WordCloudVisual'] != null
          ? WordCloudVisual.fromJson(
              json['WordCloudVisual'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final barChartVisual = this.barChartVisual;
    final boxPlotVisual = this.boxPlotVisual;
    final comboChartVisual = this.comboChartVisual;
    final customContentVisual = this.customContentVisual;
    final emptyVisual = this.emptyVisual;
    final filledMapVisual = this.filledMapVisual;
    final funnelChartVisual = this.funnelChartVisual;
    final gaugeChartVisual = this.gaugeChartVisual;
    final geospatialMapVisual = this.geospatialMapVisual;
    final heatMapVisual = this.heatMapVisual;
    final histogramVisual = this.histogramVisual;
    final insightVisual = this.insightVisual;
    final kPIVisual = this.kPIVisual;
    final lineChartVisual = this.lineChartVisual;
    final pieChartVisual = this.pieChartVisual;
    final pivotTableVisual = this.pivotTableVisual;
    final radarChartVisual = this.radarChartVisual;
    final sankeyDiagramVisual = this.sankeyDiagramVisual;
    final scatterPlotVisual = this.scatterPlotVisual;
    final tableVisual = this.tableVisual;
    final treeMapVisual = this.treeMapVisual;
    final waterfallVisual = this.waterfallVisual;
    final wordCloudVisual = this.wordCloudVisual;
    return {
      if (barChartVisual != null) 'BarChartVisual': barChartVisual,
      if (boxPlotVisual != null) 'BoxPlotVisual': boxPlotVisual,
      if (comboChartVisual != null) 'ComboChartVisual': comboChartVisual,
      if (customContentVisual != null)
        'CustomContentVisual': customContentVisual,
      if (emptyVisual != null) 'EmptyVisual': emptyVisual,
      if (filledMapVisual != null) 'FilledMapVisual': filledMapVisual,
      if (funnelChartVisual != null) 'FunnelChartVisual': funnelChartVisual,
      if (gaugeChartVisual != null) 'GaugeChartVisual': gaugeChartVisual,
      if (geospatialMapVisual != null)
        'GeospatialMapVisual': geospatialMapVisual,
      if (heatMapVisual != null) 'HeatMapVisual': heatMapVisual,
      if (histogramVisual != null) 'HistogramVisual': histogramVisual,
      if (insightVisual != null) 'InsightVisual': insightVisual,
      if (kPIVisual != null) 'KPIVisual': kPIVisual,
      if (lineChartVisual != null) 'LineChartVisual': lineChartVisual,
      if (pieChartVisual != null) 'PieChartVisual': pieChartVisual,
      if (pivotTableVisual != null) 'PivotTableVisual': pivotTableVisual,
      if (radarChartVisual != null) 'RadarChartVisual': radarChartVisual,
      if (sankeyDiagramVisual != null)
        'SankeyDiagramVisual': sankeyDiagramVisual,
      if (scatterPlotVisual != null) 'ScatterPlotVisual': scatterPlotVisual,
      if (tableVisual != null) 'TableVisual': tableVisual,
      if (treeMapVisual != null) 'TreeMapVisual': treeMapVisual,
      if (waterfallVisual != null) 'WaterfallVisual': waterfallVisual,
      if (wordCloudVisual != null) 'WordCloudVisual': wordCloudVisual,
    };
  }
}

/// The axis sort options for a visual.
class VisualAxisSortOption {
  /// The availaiblity status of a visual's axis sort options.
  final DashboardBehavior? availabilityStatus;

  VisualAxisSortOption({
    this.availabilityStatus,
  });

  factory VisualAxisSortOption.fromJson(Map<String, dynamic> json) {
    return VisualAxisSortOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// A custom action defined on a visual.
class VisualCustomAction {
  /// A list of <code>VisualCustomActionOperations</code>.
  ///
  /// This is a union type structure. For this structure to be valid, only one of
  /// the attributes can be defined.
  final List<VisualCustomActionOperation> actionOperations;

  /// The ID of the <code>VisualCustomAction</code>.
  final String customActionId;

  /// The name of the <code>VisualCustomAction</code>.
  final String name;

  /// The trigger of the <code>VisualCustomAction</code>.
  ///
  /// Valid values are defined as follows:
  ///
  /// <ul>
  /// <li>
  /// <code>DATA_POINT_CLICK</code>: Initiates a custom action by a left pointer
  /// click on a data point.
  /// </li>
  /// <li>
  /// <code>DATA_POINT_MENU</code>: Initiates a custom action by right pointer
  /// click from the menu.
  /// </li>
  /// </ul>
  final VisualCustomActionTrigger trigger;

  /// The status of the <code>VisualCustomAction</code>.
  final WidgetStatus? status;

  VisualCustomAction({
    required this.actionOperations,
    required this.customActionId,
    required this.name,
    required this.trigger,
    this.status,
  });

  factory VisualCustomAction.fromJson(Map<String, dynamic> json) {
    return VisualCustomAction(
      actionOperations: (json['ActionOperations'] as List)
          .whereNotNull()
          .map((e) =>
              VisualCustomActionOperation.fromJson(e as Map<String, dynamic>))
          .toList(),
      customActionId: json['CustomActionId'] as String,
      name: json['Name'] as String,
      trigger: (json['Trigger'] as String).toVisualCustomActionTrigger(),
      status: (json['Status'] as String?)?.toWidgetStatus(),
    );
  }

  Map<String, dynamic> toJson() {
    final actionOperations = this.actionOperations;
    final customActionId = this.customActionId;
    final name = this.name;
    final trigger = this.trigger;
    final status = this.status;
    return {
      'ActionOperations': actionOperations,
      'CustomActionId': customActionId,
      'Name': name,
      'Trigger': trigger.toValue(),
      if (status != null) 'Status': status.toValue(),
    };
  }
}

/// The operation that is defined by the custom action.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class VisualCustomActionOperation {
  /// The filter operation that filters data included in a visual or in an entire
  /// sheet.
  final CustomActionFilterOperation? filterOperation;

  /// The navigation operation that navigates between different sheets in the same
  /// analysis.
  final CustomActionNavigationOperation? navigationOperation;

  /// The set parameter operation that sets parameters in custom action.
  final CustomActionSetParametersOperation? setParametersOperation;

  /// The URL operation that opens a link to another webpage.
  final CustomActionURLOperation? uRLOperation;

  VisualCustomActionOperation({
    this.filterOperation,
    this.navigationOperation,
    this.setParametersOperation,
    this.uRLOperation,
  });

  factory VisualCustomActionOperation.fromJson(Map<String, dynamic> json) {
    return VisualCustomActionOperation(
      filterOperation: json['FilterOperation'] != null
          ? CustomActionFilterOperation.fromJson(
              json['FilterOperation'] as Map<String, dynamic>)
          : null,
      navigationOperation: json['NavigationOperation'] != null
          ? CustomActionNavigationOperation.fromJson(
              json['NavigationOperation'] as Map<String, dynamic>)
          : null,
      setParametersOperation: json['SetParametersOperation'] != null
          ? CustomActionSetParametersOperation.fromJson(
              json['SetParametersOperation'] as Map<String, dynamic>)
          : null,
      uRLOperation: json['URLOperation'] != null
          ? CustomActionURLOperation.fromJson(
              json['URLOperation'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final filterOperation = this.filterOperation;
    final navigationOperation = this.navigationOperation;
    final setParametersOperation = this.setParametersOperation;
    final uRLOperation = this.uRLOperation;
    return {
      if (filterOperation != null) 'FilterOperation': filterOperation,
      if (navigationOperation != null)
        'NavigationOperation': navigationOperation,
      if (setParametersOperation != null)
        'SetParametersOperation': setParametersOperation,
      if (uRLOperation != null) 'URLOperation': uRLOperation,
    };
  }
}

enum VisualCustomActionTrigger {
  dataPointClick,
  dataPointMenu,
}

extension VisualCustomActionTriggerValueExtension on VisualCustomActionTrigger {
  String toValue() {
    switch (this) {
      case VisualCustomActionTrigger.dataPointClick:
        return 'DATA_POINT_CLICK';
      case VisualCustomActionTrigger.dataPointMenu:
        return 'DATA_POINT_MENU';
    }
  }
}

extension VisualCustomActionTriggerFromString on String {
  VisualCustomActionTrigger toVisualCustomActionTrigger() {
    switch (this) {
      case 'DATA_POINT_CLICK':
        return VisualCustomActionTrigger.dataPointClick;
      case 'DATA_POINT_MENU':
        return VisualCustomActionTrigger.dataPointMenu;
    }
    throw Exception('$this is not known in enum VisualCustomActionTrigger');
  }
}

/// The general visual interactions setup for visual publish options
class VisualInteractionOptions {
  /// The context menu options for a visual.
  final ContextMenuOption? contextMenuOption;

  /// The on-visual menu options for a visual.
  final VisualMenuOption? visualMenuOption;

  VisualInteractionOptions({
    this.contextMenuOption,
    this.visualMenuOption,
  });

  factory VisualInteractionOptions.fromJson(Map<String, dynamic> json) {
    return VisualInteractionOptions(
      contextMenuOption: json['ContextMenuOption'] != null
          ? ContextMenuOption.fromJson(
              json['ContextMenuOption'] as Map<String, dynamic>)
          : null,
      visualMenuOption: json['VisualMenuOption'] != null
          ? VisualMenuOption.fromJson(
              json['VisualMenuOption'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final contextMenuOption = this.contextMenuOption;
    final visualMenuOption = this.visualMenuOption;
    return {
      if (contextMenuOption != null) 'ContextMenuOption': contextMenuOption,
      if (visualMenuOption != null) 'VisualMenuOption': visualMenuOption,
    };
  }
}

/// The menu options for a visual.
class VisualMenuOption {
  /// The availaiblity status of a visual's menu options.
  final DashboardBehavior? availabilityStatus;

  VisualMenuOption({
    this.availabilityStatus,
  });

  factory VisualMenuOption.fromJson(Map<String, dynamic> json) {
    return VisualMenuOption(
      availabilityStatus:
          (json['AvailabilityStatus'] as String?)?.toDashboardBehavior(),
    );
  }

  Map<String, dynamic> toJson() {
    final availabilityStatus = this.availabilityStatus;
    return {
      if (availabilityStatus != null)
        'AvailabilityStatus': availabilityStatus.toValue(),
    };
  }
}

/// The visual display options for the visual palette.
class VisualPalette {
  /// The chart color options for the visual palette.
  final String? chartColor;

  /// The color map options for the visual palette.
  final List<DataPathColor>? colorMap;

  VisualPalette({
    this.chartColor,
    this.colorMap,
  });

  factory VisualPalette.fromJson(Map<String, dynamic> json) {
    return VisualPalette(
      chartColor: json['ChartColor'] as String?,
      colorMap: (json['ColorMap'] as List?)
          ?.whereNotNull()
          .map((e) => DataPathColor.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final chartColor = this.chartColor;
    final colorMap = this.colorMap;
    return {
      if (chartColor != null) 'ChartColor': chartColor,
      if (colorMap != null) 'ColorMap': colorMap,
    };
  }
}

/// The subtitle label options for a visual.
class VisualSubtitleLabelOptions {
  /// The long text format of the subtitle label, such as plain text or rich text.
  final LongFormatText? formatText;

  /// The visibility of the subtitle label.
  final Visibility? visibility;

  VisualSubtitleLabelOptions({
    this.formatText,
    this.visibility,
  });

  factory VisualSubtitleLabelOptions.fromJson(Map<String, dynamic> json) {
    return VisualSubtitleLabelOptions(
      formatText: json['FormatText'] != null
          ? LongFormatText.fromJson(json['FormatText'] as Map<String, dynamic>)
          : null,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final formatText = this.formatText;
    final visibility = this.visibility;
    return {
      if (formatText != null) 'FormatText': formatText,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// The title label options for a visual.
class VisualTitleLabelOptions {
  /// The short text format of the title label, such as plain text or rich text.
  final ShortFormatText? formatText;

  /// The visibility of the title label.
  final Visibility? visibility;

  VisualTitleLabelOptions({
    this.formatText,
    this.visibility,
  });

  factory VisualTitleLabelOptions.fromJson(Map<String, dynamic> json) {
    return VisualTitleLabelOptions(
      formatText: json['FormatText'] != null
          ? ShortFormatText.fromJson(json['FormatText'] as Map<String, dynamic>)
          : null,
      visibility: (json['Visibility'] as String?)?.toVisibility(),
    );
  }

  Map<String, dynamic> toJson() {
    final formatText = this.formatText;
    final visibility = this.visibility;
    return {
      if (formatText != null) 'FormatText': formatText,
      if (visibility != null) 'Visibility': visibility.toValue(),
    };
  }
}

/// VPC connection properties.
class VpcConnectionProperties {
  /// The Amazon Resource Name (ARN) for the VPC connection.
  final String vpcConnectionArn;

  VpcConnectionProperties({
    required this.vpcConnectionArn,
  });

  factory VpcConnectionProperties.fromJson(Map<String, dynamic> json) {
    return VpcConnectionProperties(
      vpcConnectionArn: json['VpcConnectionArn'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    final vpcConnectionArn = this.vpcConnectionArn;
    return {
      'VpcConnectionArn': vpcConnectionArn,
    };
  }
}

/// The field well configuration of a waterfall visual.
class WaterfallChartAggregatedFieldWells {
  /// The breakdown field wells of a waterfall visual.
  final List<DimensionField>? breakdowns;

  /// The category field wells of a waterfall visual.
  final List<DimensionField>? categories;

  /// The value field wells of a waterfall visual.
  final List<MeasureField>? values;

  WaterfallChartAggregatedFieldWells({
    this.breakdowns,
    this.categories,
    this.values,
  });

  factory WaterfallChartAggregatedFieldWells.fromJson(
      Map<String, dynamic> json) {
    return WaterfallChartAggregatedFieldWells(
      breakdowns: (json['Breakdowns'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      categories: (json['Categories'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      values: (json['Values'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final breakdowns = this.breakdowns;
    final categories = this.categories;
    final values = this.values;
    return {
      if (breakdowns != null) 'Breakdowns': breakdowns,
      if (categories != null) 'Categories': categories,
      if (values != null) 'Values': values,
    };
  }
}

/// The color configuration of a waterfall visual.
class WaterfallChartColorConfiguration {
  /// The color configuration for individual groups within a waterfall visual.
  final WaterfallChartGroupColorConfiguration? groupColorConfiguration;

  WaterfallChartColorConfiguration({
    this.groupColorConfiguration,
  });

  factory WaterfallChartColorConfiguration.fromJson(Map<String, dynamic> json) {
    return WaterfallChartColorConfiguration(
      groupColorConfiguration: json['GroupColorConfiguration'] != null
          ? WaterfallChartGroupColorConfiguration.fromJson(
              json['GroupColorConfiguration'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final groupColorConfiguration = this.groupColorConfiguration;
    return {
      if (groupColorConfiguration != null)
        'GroupColorConfiguration': groupColorConfiguration,
    };
  }
}

/// The configuration for a waterfall visual.
class WaterfallChartConfiguration {
  /// The options that determine the presentation of the category axis.
  final AxisDisplayOptions? categoryAxisDisplayOptions;

  /// The options that determine the presentation of the category axis label.
  final ChartAxisLabelOptions? categoryAxisLabelOptions;

  /// The color configuration of a waterfall visual.
  final WaterfallChartColorConfiguration? colorConfiguration;

  /// The data label configuration of a waterfall visual.
  final DataLabelOptions? dataLabels;

  /// The field well configuration of a waterfall visual.
  final WaterfallChartFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The legend configuration of a waterfall visual.
  final LegendOptions? legend;

  /// The options that determine the presentation of the y-axis.
  final AxisDisplayOptions? primaryYAxisDisplayOptions;

  /// The options that determine the presentation of the y-axis label.
  final ChartAxisLabelOptions? primaryYAxisLabelOptions;

  /// The sort configuration of a waterfall visual.
  final WaterfallChartSortConfiguration? sortConfiguration;

  /// The visual palette configuration of a waterfall visual.
  final VisualPalette? visualPalette;

  /// The options that determine the presentation of a waterfall visual.
  final WaterfallChartOptions? waterfallChartOptions;

  WaterfallChartConfiguration({
    this.categoryAxisDisplayOptions,
    this.categoryAxisLabelOptions,
    this.colorConfiguration,
    this.dataLabels,
    this.fieldWells,
    this.interactions,
    this.legend,
    this.primaryYAxisDisplayOptions,
    this.primaryYAxisLabelOptions,
    this.sortConfiguration,
    this.visualPalette,
    this.waterfallChartOptions,
  });

  factory WaterfallChartConfiguration.fromJson(Map<String, dynamic> json) {
    return WaterfallChartConfiguration(
      categoryAxisDisplayOptions: json['CategoryAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['CategoryAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      categoryAxisLabelOptions: json['CategoryAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      colorConfiguration: json['ColorConfiguration'] != null
          ? WaterfallChartColorConfiguration.fromJson(
              json['ColorConfiguration'] as Map<String, dynamic>)
          : null,
      dataLabels: json['DataLabels'] != null
          ? DataLabelOptions.fromJson(
              json['DataLabels'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? WaterfallChartFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      legend: json['Legend'] != null
          ? LegendOptions.fromJson(json['Legend'] as Map<String, dynamic>)
          : null,
      primaryYAxisDisplayOptions: json['PrimaryYAxisDisplayOptions'] != null
          ? AxisDisplayOptions.fromJson(
              json['PrimaryYAxisDisplayOptions'] as Map<String, dynamic>)
          : null,
      primaryYAxisLabelOptions: json['PrimaryYAxisLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['PrimaryYAxisLabelOptions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? WaterfallChartSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      visualPalette: json['VisualPalette'] != null
          ? VisualPalette.fromJson(
              json['VisualPalette'] as Map<String, dynamic>)
          : null,
      waterfallChartOptions: json['WaterfallChartOptions'] != null
          ? WaterfallChartOptions.fromJson(
              json['WaterfallChartOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryAxisDisplayOptions = this.categoryAxisDisplayOptions;
    final categoryAxisLabelOptions = this.categoryAxisLabelOptions;
    final colorConfiguration = this.colorConfiguration;
    final dataLabels = this.dataLabels;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final legend = this.legend;
    final primaryYAxisDisplayOptions = this.primaryYAxisDisplayOptions;
    final primaryYAxisLabelOptions = this.primaryYAxisLabelOptions;
    final sortConfiguration = this.sortConfiguration;
    final visualPalette = this.visualPalette;
    final waterfallChartOptions = this.waterfallChartOptions;
    return {
      if (categoryAxisDisplayOptions != null)
        'CategoryAxisDisplayOptions': categoryAxisDisplayOptions,
      if (categoryAxisLabelOptions != null)
        'CategoryAxisLabelOptions': categoryAxisLabelOptions,
      if (colorConfiguration != null) 'ColorConfiguration': colorConfiguration,
      if (dataLabels != null) 'DataLabels': dataLabels,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (legend != null) 'Legend': legend,
      if (primaryYAxisDisplayOptions != null)
        'PrimaryYAxisDisplayOptions': primaryYAxisDisplayOptions,
      if (primaryYAxisLabelOptions != null)
        'PrimaryYAxisLabelOptions': primaryYAxisLabelOptions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (visualPalette != null) 'VisualPalette': visualPalette,
      if (waterfallChartOptions != null)
        'WaterfallChartOptions': waterfallChartOptions,
    };
  }
}

/// The field well configuration of a waterfall visual.
class WaterfallChartFieldWells {
  /// The field well configuration of a waterfall visual.
  final WaterfallChartAggregatedFieldWells? waterfallChartAggregatedFieldWells;

  WaterfallChartFieldWells({
    this.waterfallChartAggregatedFieldWells,
  });

  factory WaterfallChartFieldWells.fromJson(Map<String, dynamic> json) {
    return WaterfallChartFieldWells(
      waterfallChartAggregatedFieldWells:
          json['WaterfallChartAggregatedFieldWells'] != null
              ? WaterfallChartAggregatedFieldWells.fromJson(
                  json['WaterfallChartAggregatedFieldWells']
                      as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final waterfallChartAggregatedFieldWells =
        this.waterfallChartAggregatedFieldWells;
    return {
      if (waterfallChartAggregatedFieldWells != null)
        'WaterfallChartAggregatedFieldWells':
            waterfallChartAggregatedFieldWells,
    };
  }
}

/// The color configuration for individual groups within a waterfall visual.
class WaterfallChartGroupColorConfiguration {
  /// Defines the color for the negative bars of a waterfall chart.
  final String? negativeBarColor;

  /// Defines the color for the positive bars of a waterfall chart.
  final String? positiveBarColor;

  /// Defines the color for the total bars of a waterfall chart.
  final String? totalBarColor;

  WaterfallChartGroupColorConfiguration({
    this.negativeBarColor,
    this.positiveBarColor,
    this.totalBarColor,
  });

  factory WaterfallChartGroupColorConfiguration.fromJson(
      Map<String, dynamic> json) {
    return WaterfallChartGroupColorConfiguration(
      negativeBarColor: json['NegativeBarColor'] as String?,
      positiveBarColor: json['PositiveBarColor'] as String?,
      totalBarColor: json['TotalBarColor'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final negativeBarColor = this.negativeBarColor;
    final positiveBarColor = this.positiveBarColor;
    final totalBarColor = this.totalBarColor;
    return {
      if (negativeBarColor != null) 'NegativeBarColor': negativeBarColor,
      if (positiveBarColor != null) 'PositiveBarColor': positiveBarColor,
      if (totalBarColor != null) 'TotalBarColor': totalBarColor,
    };
  }
}

/// The options that determine the presentation of a waterfall visual.
class WaterfallChartOptions {
  /// This option determines the total bar label of a waterfall visual.
  final String? totalBarLabel;

  WaterfallChartOptions({
    this.totalBarLabel,
  });

  factory WaterfallChartOptions.fromJson(Map<String, dynamic> json) {
    return WaterfallChartOptions(
      totalBarLabel: json['TotalBarLabel'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    final totalBarLabel = this.totalBarLabel;
    return {
      if (totalBarLabel != null) 'TotalBarLabel': totalBarLabel,
    };
  }
}

/// The sort configuration of a waterfall visual.
class WaterfallChartSortConfiguration {
  /// The limit on the number of bar groups that are displayed.
  final ItemsLimitConfiguration? breakdownItemsLimit;

  /// The sort configuration of the category fields.
  final List<FieldSortOptions>? categorySort;

  WaterfallChartSortConfiguration({
    this.breakdownItemsLimit,
    this.categorySort,
  });

  factory WaterfallChartSortConfiguration.fromJson(Map<String, dynamic> json) {
    return WaterfallChartSortConfiguration(
      breakdownItemsLimit: json['BreakdownItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['BreakdownItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final breakdownItemsLimit = this.breakdownItemsLimit;
    final categorySort = this.categorySort;
    return {
      if (breakdownItemsLimit != null)
        'BreakdownItemsLimit': breakdownItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
    };
  }
}

/// A waterfall chart.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/waterfall-chart.html">Using
/// waterfall charts</a> in the <i>Amazon QuickSight User Guide</i>.
class WaterfallVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers.
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration for a waterfall visual.
  final WaterfallChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  WaterfallVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory WaterfallVisual.fromJson(Map<String, dynamic> json) {
    return WaterfallVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? WaterfallChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

/// Provides the forecast to meet the target for a particular date.
class WhatIfPointScenario {
  /// The date that you need the forecast results for.
  final DateTime date;

  /// The target value that you want to meet for the provided date.
  final double value;

  WhatIfPointScenario({
    required this.date,
    required this.value,
  });

  factory WhatIfPointScenario.fromJson(Map<String, dynamic> json) {
    return WhatIfPointScenario(
      date: nonNullableTimeStampFromJson(json['Date'] as Object),
      value: json['Value'] as double,
    );
  }

  Map<String, dynamic> toJson() {
    final date = this.date;
    final value = this.value;
    return {
      'Date': unixTimestampToJson(date),
      'Value': value,
    };
  }
}

/// Provides the forecast to meet the target for a particular date range.
class WhatIfRangeScenario {
  /// The end date in the date range that you need the forecast results for.
  final DateTime endDate;

  /// The start date in the date range that you need the forecast results for.
  final DateTime startDate;

  /// The target value that you want to meet for the provided date range.
  final double value;

  WhatIfRangeScenario({
    required this.endDate,
    required this.startDate,
    required this.value,
  });

  factory WhatIfRangeScenario.fromJson(Map<String, dynamic> json) {
    return WhatIfRangeScenario(
      endDate: nonNullableTimeStampFromJson(json['EndDate'] as Object),
      startDate: nonNullableTimeStampFromJson(json['StartDate'] as Object),
      value: json['Value'] as double,
    );
  }

  Map<String, dynamic> toJson() {
    final endDate = this.endDate;
    final startDate = this.startDate;
    final value = this.value;
    return {
      'EndDate': unixTimestampToJson(endDate),
      'StartDate': unixTimestampToJson(startDate),
      'Value': value,
    };
  }
}

enum WidgetStatus {
  enabled,
  disabled,
}

extension WidgetStatusValueExtension on WidgetStatus {
  String toValue() {
    switch (this) {
      case WidgetStatus.enabled:
        return 'ENABLED';
      case WidgetStatus.disabled:
        return 'DISABLED';
    }
  }
}

extension WidgetStatusFromString on String {
  WidgetStatus toWidgetStatus() {
    switch (this) {
      case 'ENABLED':
        return WidgetStatus.enabled;
      case 'DISABLED':
        return WidgetStatus.disabled;
    }
    throw Exception('$this is not known in enum WidgetStatus');
  }
}

/// The aggregated field wells of a word cloud.
class WordCloudAggregatedFieldWells {
  /// The group by field well of a word cloud. Values are grouped by group by
  /// fields.
  final List<DimensionField>? groupBy;

  /// The size field well of a word cloud. Values are aggregated based on group by
  /// fields.
  final List<MeasureField>? size;

  WordCloudAggregatedFieldWells({
    this.groupBy,
    this.size,
  });

  factory WordCloudAggregatedFieldWells.fromJson(Map<String, dynamic> json) {
    return WordCloudAggregatedFieldWells(
      groupBy: (json['GroupBy'] as List?)
          ?.whereNotNull()
          .map((e) => DimensionField.fromJson(e as Map<String, dynamic>))
          .toList(),
      size: (json['Size'] as List?)
          ?.whereNotNull()
          .map((e) => MeasureField.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final groupBy = this.groupBy;
    final size = this.size;
    return {
      if (groupBy != null) 'GroupBy': groupBy,
      if (size != null) 'Size': size,
    };
  }
}

/// The configuration of a word cloud visual.
class WordCloudChartConfiguration {
  /// The label options (label text, label visibility, and sort icon visibility)
  /// for the word cloud category.
  final ChartAxisLabelOptions? categoryLabelOptions;

  /// The field wells of the visual.
  final WordCloudFieldWells? fieldWells;

  /// The general visual interactions setup for a visual.
  final VisualInteractionOptions? interactions;

  /// The sort configuration of a word cloud visual.
  final WordCloudSortConfiguration? sortConfiguration;

  /// The options for a word cloud visual.
  final WordCloudOptions? wordCloudOptions;

  WordCloudChartConfiguration({
    this.categoryLabelOptions,
    this.fieldWells,
    this.interactions,
    this.sortConfiguration,
    this.wordCloudOptions,
  });

  factory WordCloudChartConfiguration.fromJson(Map<String, dynamic> json) {
    return WordCloudChartConfiguration(
      categoryLabelOptions: json['CategoryLabelOptions'] != null
          ? ChartAxisLabelOptions.fromJson(
              json['CategoryLabelOptions'] as Map<String, dynamic>)
          : null,
      fieldWells: json['FieldWells'] != null
          ? WordCloudFieldWells.fromJson(
              json['FieldWells'] as Map<String, dynamic>)
          : null,
      interactions: json['Interactions'] != null
          ? VisualInteractionOptions.fromJson(
              json['Interactions'] as Map<String, dynamic>)
          : null,
      sortConfiguration: json['SortConfiguration'] != null
          ? WordCloudSortConfiguration.fromJson(
              json['SortConfiguration'] as Map<String, dynamic>)
          : null,
      wordCloudOptions: json['WordCloudOptions'] != null
          ? WordCloudOptions.fromJson(
              json['WordCloudOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final categoryLabelOptions = this.categoryLabelOptions;
    final fieldWells = this.fieldWells;
    final interactions = this.interactions;
    final sortConfiguration = this.sortConfiguration;
    final wordCloudOptions = this.wordCloudOptions;
    return {
      if (categoryLabelOptions != null)
        'CategoryLabelOptions': categoryLabelOptions,
      if (fieldWells != null) 'FieldWells': fieldWells,
      if (interactions != null) 'Interactions': interactions,
      if (sortConfiguration != null) 'SortConfiguration': sortConfiguration,
      if (wordCloudOptions != null) 'WordCloudOptions': wordCloudOptions,
    };
  }
}

enum WordCloudCloudLayout {
  fluid,
  normal,
}

extension WordCloudCloudLayoutValueExtension on WordCloudCloudLayout {
  String toValue() {
    switch (this) {
      case WordCloudCloudLayout.fluid:
        return 'FLUID';
      case WordCloudCloudLayout.normal:
        return 'NORMAL';
    }
  }
}

extension WordCloudCloudLayoutFromString on String {
  WordCloudCloudLayout toWordCloudCloudLayout() {
    switch (this) {
      case 'FLUID':
        return WordCloudCloudLayout.fluid;
      case 'NORMAL':
        return WordCloudCloudLayout.normal;
    }
    throw Exception('$this is not known in enum WordCloudCloudLayout');
  }
}

/// The field wells of a word cloud visual.
///
/// This is a union type structure. For this structure to be valid, only one of
/// the attributes can be defined.
class WordCloudFieldWells {
  /// The aggregated field wells of a word cloud.
  final WordCloudAggregatedFieldWells? wordCloudAggregatedFieldWells;

  WordCloudFieldWells({
    this.wordCloudAggregatedFieldWells,
  });

  factory WordCloudFieldWells.fromJson(Map<String, dynamic> json) {
    return WordCloudFieldWells(
      wordCloudAggregatedFieldWells:
          json['WordCloudAggregatedFieldWells'] != null
              ? WordCloudAggregatedFieldWells.fromJson(
                  json['WordCloudAggregatedFieldWells'] as Map<String, dynamic>)
              : null,
    );
  }

  Map<String, dynamic> toJson() {
    final wordCloudAggregatedFieldWells = this.wordCloudAggregatedFieldWells;
    return {
      if (wordCloudAggregatedFieldWells != null)
        'WordCloudAggregatedFieldWells': wordCloudAggregatedFieldWells,
    };
  }
}

/// The word cloud options for a word cloud visual.
class WordCloudOptions {
  /// The cloud layout options (fluid, normal) of a word cloud.
  final WordCloudCloudLayout? cloudLayout;

  /// The length limit of each word from 1-100.
  final int? maximumStringLength;

  /// The word casing options (lower_case, existing_case) for the words in a word
  /// cloud.
  final WordCloudWordCasing? wordCasing;

  /// The word orientation options (horizontal, horizontal_and_vertical) for the
  /// words in a word cloud.
  final WordCloudWordOrientation? wordOrientation;

  /// The word padding options (none, small, medium, large) for the words in a
  /// word cloud.
  final WordCloudWordPadding? wordPadding;

  /// The word scaling options (emphasize, normal) for the words in a word cloud.
  final WordCloudWordScaling? wordScaling;

  WordCloudOptions({
    this.cloudLayout,
    this.maximumStringLength,
    this.wordCasing,
    this.wordOrientation,
    this.wordPadding,
    this.wordScaling,
  });

  factory WordCloudOptions.fromJson(Map<String, dynamic> json) {
    return WordCloudOptions(
      cloudLayout: (json['CloudLayout'] as String?)?.toWordCloudCloudLayout(),
      maximumStringLength: json['MaximumStringLength'] as int?,
      wordCasing: (json['WordCasing'] as String?)?.toWordCloudWordCasing(),
      wordOrientation:
          (json['WordOrientation'] as String?)?.toWordCloudWordOrientation(),
      wordPadding: (json['WordPadding'] as String?)?.toWordCloudWordPadding(),
      wordScaling: (json['WordScaling'] as String?)?.toWordCloudWordScaling(),
    );
  }

  Map<String, dynamic> toJson() {
    final cloudLayout = this.cloudLayout;
    final maximumStringLength = this.maximumStringLength;
    final wordCasing = this.wordCasing;
    final wordOrientation = this.wordOrientation;
    final wordPadding = this.wordPadding;
    final wordScaling = this.wordScaling;
    return {
      if (cloudLayout != null) 'CloudLayout': cloudLayout.toValue(),
      if (maximumStringLength != null)
        'MaximumStringLength': maximumStringLength,
      if (wordCasing != null) 'WordCasing': wordCasing.toValue(),
      if (wordOrientation != null) 'WordOrientation': wordOrientation.toValue(),
      if (wordPadding != null) 'WordPadding': wordPadding.toValue(),
      if (wordScaling != null) 'WordScaling': wordScaling.toValue(),
    };
  }
}

/// The sort configuration of a word cloud visual.
class WordCloudSortConfiguration {
  /// The limit on the number of groups that are displayed in a word cloud.
  final ItemsLimitConfiguration? categoryItemsLimit;

  /// The sort configuration of group by fields.
  final List<FieldSortOptions>? categorySort;

  WordCloudSortConfiguration({
    this.categoryItemsLimit,
    this.categorySort,
  });

  factory WordCloudSortConfiguration.fromJson(Map<String, dynamic> json) {
    return WordCloudSortConfiguration(
      categoryItemsLimit: json['CategoryItemsLimit'] != null
          ? ItemsLimitConfiguration.fromJson(
              json['CategoryItemsLimit'] as Map<String, dynamic>)
          : null,
      categorySort: (json['CategorySort'] as List?)
          ?.whereNotNull()
          .map((e) => FieldSortOptions.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    final categoryItemsLimit = this.categoryItemsLimit;
    final categorySort = this.categorySort;
    return {
      if (categoryItemsLimit != null) 'CategoryItemsLimit': categoryItemsLimit,
      if (categorySort != null) 'CategorySort': categorySort,
    };
  }
}

/// A word cloud.
///
/// For more information, see <a
/// href="https://docs.aws.amazon.com/quicksight/latest/user/word-cloud.html">Using
/// word clouds</a> in the <i>Amazon QuickSight User Guide</i>.
class WordCloudVisual {
  /// The unique identifier of a visual. This identifier must be unique within the
  /// context of a dashboard, template, or analysis. Two dashboards, analyses, or
  /// templates can have visuals with the same identifiers..
  final String visualId;

  /// The list of custom actions that are configured for a visual.
  final List<VisualCustomAction>? actions;

  /// The configuration settings of the visual.
  final WordCloudChartConfiguration? chartConfiguration;

  /// The column hierarchy that is used during drill-downs and drill-ups.
  final List<ColumnHierarchy>? columnHierarchies;

  /// The subtitle that is displayed on the visual.
  final VisualSubtitleLabelOptions? subtitle;

  /// The title that is displayed on the visual.
  final VisualTitleLabelOptions? title;

  WordCloudVisual({
    required this.visualId,
    this.actions,
    this.chartConfiguration,
    this.columnHierarchies,
    this.subtitle,
    this.title,
  });

  factory WordCloudVisual.fromJson(Map<String, dynamic> json) {
    return WordCloudVisual(
      visualId: json['VisualId'] as String,
      actions: (json['Actions'] as List?)
          ?.whereNotNull()
          .map((e) => VisualCustomAction.fromJson(e as Map<String, dynamic>))
          .toList(),
      chartConfiguration: json['ChartConfiguration'] != null
          ? WordCloudChartConfiguration.fromJson(
              json['ChartConfiguration'] as Map<String, dynamic>)
          : null,
      columnHierarchies: (json['ColumnHierarchies'] as List?)
          ?.whereNotNull()
          .map((e) => ColumnHierarchy.fromJson(e as Map<String, dynamic>))
          .toList(),
      subtitle: json['Subtitle'] != null
          ? VisualSubtitleLabelOptions.fromJson(
              json['Subtitle'] as Map<String, dynamic>)
          : null,
      title: json['Title'] != null
          ? VisualTitleLabelOptions.fromJson(
              json['Title'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    final visualId = this.visualId;
    final actions = this.actions;
    final chartConfiguration = this.chartConfiguration;
    final columnHierarchies = this.columnHierarchies;
    final subtitle = this.subtitle;
    final title = this.title;
    return {
      'VisualId': visualId,
      if (actions != null) 'Actions': actions,
      if (chartConfiguration != null) 'ChartConfiguration': chartConfiguration,
      if (columnHierarchies != null) 'ColumnHierarchies': columnHierarchies,
      if (subtitle != null) 'Subtitle': subtitle,
      if (title != null) 'Title': title,
    };
  }
}

enum WordCloudWordCasing {
  lowerCase,
  existingCase,
}

extension WordCloudWordCasingValueExtension on WordCloudWordCasing {
  String toValue() {
    switch (this) {
      case WordCloudWordCasing.lowerCase:
        return 'LOWER_CASE';
      case WordCloudWordCasing.existingCase:
        return 'EXISTING_CASE';
    }
  }
}

extension WordCloudWordCasingFromString on String {
  WordCloudWordCasing toWordCloudWordCasing() {
    switch (this) {
      case 'LOWER_CASE':
        return WordCloudWordCasing.lowerCase;
      case 'EXISTING_CASE':
        return WordCloudWordCasing.existingCase;
    }
    throw Exception('$this is not known in enum WordCloudWordCasing');
  }
}

enum WordCloudWordOrientation {
  horizontal,
  horizontalAndVertical,
}

extension WordCloudWordOrientationValueExtension on WordCloudWordOrientation {
  String toValue() {
    switch (this) {
      case WordCloudWordOrientation.horizontal:
        return 'HORIZONTAL';
      case WordCloudWordOrientation.horizontalAndVertical:
        return 'HORIZONTAL_AND_VERTICAL';
    }
  }
}

extension WordCloudWordOrientationFromString on String {
  WordCloudWordOrientation toWordCloudWordOrientation() {
    switch (this) {
      case 'HORIZONTAL':
        return WordCloudWordOrientation.horizontal;
      case 'HORIZONTAL_AND_VERTICAL':
        return WordCloudWordOrientation.horizontalAndVertical;
    }
    throw Exception('$this is not known in enum WordCloudWordOrientation');
  }
}

enum WordCloudWordPadding {
  none,
  small,
  medium,
  large,
}

extension WordCloudWordPaddingValueExtension on WordCloudWordPadding {
  String toValue() {
    switch (this) {
      case WordCloudWordPadding.none:
        return 'NONE';
      case WordCloudWordPadding.small:
        return 'SMALL';
      case WordCloudWordPadding.medium:
        return 'MEDIUM';
      case WordCloudWordPadding.large:
        return 'LARGE';
    }
  }
}

extension WordCloudWordPaddingFromString on String {
  WordCloudWordPadding toWordCloudWordPadding() {
    switch (this) {
      case 'NONE':
        return WordCloudWordPadding.none;
      case 'SMALL':
        return WordCloudWordPadding.small;
      case 'MEDIUM':
        return WordCloudWordPadding.medium;
      case 'LARGE':
        return WordCloudWordPadding.large;
    }
    throw Exception('$this is not known in enum WordCloudWordPadding');
  }
}

enum WordCloudWordScaling {
  emphasize,
  normal,
}

extension WordCloudWordScalingValueExtension on WordCloudWordScaling {
  String toValue() {
    switch (this) {
      case WordCloudWordScaling.emphasize:
        return 'EMPHASIZE';
      case WordCloudWordScaling.normal:
        return 'NORMAL';
    }
  }
}

extension WordCloudWordScalingFromString on String {
  WordCloudWordScaling toWordCloudWordScaling() {
    switch (this) {
      case 'EMPHASIZE':
        return WordCloudWordScaling.emphasize;
      case 'NORMAL':
        return WordCloudWordScaling.normal;
    }
    throw Exception('$this is not known in enum WordCloudWordScaling');
  }
}

/// The options that are available for a single Y axis in a chart.
class YAxisOptions {
  /// The Y axis type to be used in the chart.
  ///
  /// If you choose <code>PRIMARY_Y_AXIS</code>, the primary Y Axis is located on
  /// the leftmost vertical axis of the chart.
  final SingleYAxisOption yAxis;

  YAxisOptions({
    required this.yAxis,
  });

  factory YAxisOptions.fromJson(Map<String, dynamic> json) {
    return YAxisOptions(
      yAxis: (json['YAxis'] as String).toSingleYAxisOption(),
    );
  }

  Map<String, dynamic> toJson() {
    final yAxis = this.yAxis;
    return {
      'YAxis': yAxis.toValue(),
    };
  }
}

class AccessDeniedException extends _s.GenericAwsException {
  AccessDeniedException({String? type, String? message})
      : super(type: type, code: 'AccessDeniedException', message: message);
}

class ConcurrentUpdatingException extends _s.GenericAwsException {
  ConcurrentUpdatingException({String? type, String? message})
      : super(
            type: type, code: 'ConcurrentUpdatingException', message: message);
}

class ConflictException extends _s.GenericAwsException {
  ConflictException({String? type, String? message})
      : super(type: type, code: 'ConflictException', message: message);
}

class DomainNotWhitelistedException extends _s.GenericAwsException {
  DomainNotWhitelistedException({String? type, String? message})
      : super(
            type: type,
            code: 'DomainNotWhitelistedException',
            message: message);
}

class IdentityTypeNotSupportedException extends _s.GenericAwsException {
  IdentityTypeNotSupportedException({String? type, String? message})
      : super(
            type: type,
            code: 'IdentityTypeNotSupportedException',
            message: message);
}

class InternalFailureException extends _s.GenericAwsException {
  InternalFailureException({String? type, String? message})
      : super(type: type, code: 'InternalFailureException', message: message);
}

class InvalidNextTokenException extends _s.GenericAwsException {
  InvalidNextTokenException({String? type, String? message})
      : super(type: type, code: 'InvalidNextTokenException', message: message);
}

class InvalidParameterValueException extends _s.GenericAwsException {
  InvalidParameterValueException({String? type, String? message})
      : super(
            type: type,
            code: 'InvalidParameterValueException',
            message: message);
}

class InvalidRequestException extends _s.GenericAwsException {
  InvalidRequestException({String? type, String? message})
      : super(type: type, code: 'InvalidRequestException', message: message);
}

class LimitExceededException extends _s.GenericAwsException {
  LimitExceededException({String? type, String? message})
      : super(type: type, code: 'LimitExceededException', message: message);
}

class PreconditionNotMetException extends _s.GenericAwsException {
  PreconditionNotMetException({String? type, String? message})
      : super(
            type: type, code: 'PreconditionNotMetException', message: message);
}

class QuickSightUserNotFoundException extends _s.GenericAwsException {
  QuickSightUserNotFoundException({String? type, String? message})
      : super(
            type: type,
            code: 'QuickSightUserNotFoundException',
            message: message);
}

class ResourceExistsException extends _s.GenericAwsException {
  ResourceExistsException({String? type, String? message})
      : super(type: type, code: 'ResourceExistsException', message: message);
}

class ResourceNotFoundException extends _s.GenericAwsException {
  ResourceNotFoundException({String? type, String? message})
      : super(type: type, code: 'ResourceNotFoundException', message: message);
}

class ResourceUnavailableException extends _s.GenericAwsException {
  ResourceUnavailableException({String? type, String? message})
      : super(
            type: type, code: 'ResourceUnavailableException', message: message);
}

class SessionLifetimeInMinutesInvalidException extends _s.GenericAwsException {
  SessionLifetimeInMinutesInvalidException({String? type, String? message})
      : super(
            type: type,
            code: 'SessionLifetimeInMinutesInvalidException',
            message: message);
}

class ThrottlingException extends _s.GenericAwsException {
  ThrottlingException({String? type, String? message})
      : super(type: type, code: 'ThrottlingException', message: message);
}

class UnsupportedPricingPlanException extends _s.GenericAwsException {
  UnsupportedPricingPlanException({String? type, String? message})
      : super(
            type: type,
            code: 'UnsupportedPricingPlanException',
            message: message);
}

class UnsupportedUserEditionException extends _s.GenericAwsException {
  UnsupportedUserEditionException({String? type, String? message})
      : super(
            type: type,
            code: 'UnsupportedUserEditionException',
            message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'AccessDeniedException': (type, message) =>
      AccessDeniedException(type: type, message: message),
  'ConcurrentUpdatingException': (type, message) =>
      ConcurrentUpdatingException(type: type, message: message),
  'ConflictException': (type, message) =>
      ConflictException(type: type, message: message),
  'DomainNotWhitelistedException': (type, message) =>
      DomainNotWhitelistedException(type: type, message: message),
  'IdentityTypeNotSupportedException': (type, message) =>
      IdentityTypeNotSupportedException(type: type, message: message),
  'InternalFailureException': (type, message) =>
      InternalFailureException(type: type, message: message),
  'InvalidNextTokenException': (type, message) =>
      InvalidNextTokenException(type: type, message: message),
  'InvalidParameterValueException': (type, message) =>
      InvalidParameterValueException(type: type, message: message),
  'InvalidRequestException': (type, message) =>
      InvalidRequestException(type: type, message: message),
  'LimitExceededException': (type, message) =>
      LimitExceededException(type: type, message: message),
  'PreconditionNotMetException': (type, message) =>
      PreconditionNotMetException(type: type, message: message),
  'QuickSightUserNotFoundException': (type, message) =>
      QuickSightUserNotFoundException(type: type, message: message),
  'ResourceExistsException': (type, message) =>
      ResourceExistsException(type: type, message: message),
  'ResourceNotFoundException': (type, message) =>
      ResourceNotFoundException(type: type, message: message),
  'ResourceUnavailableException': (type, message) =>
      ResourceUnavailableException(type: type, message: message),
  'SessionLifetimeInMinutesInvalidException': (type, message) =>
      SessionLifetimeInMinutesInvalidException(type: type, message: message),
  'ThrottlingException': (type, message) =>
      ThrottlingException(type: type, message: message),
  'UnsupportedPricingPlanException': (type, message) =>
      UnsupportedPricingPlanException(type: type, message: message),
  'UnsupportedUserEditionException': (type, message) =>
      UnsupportedUserEditionException(type: type, message: message),
};
