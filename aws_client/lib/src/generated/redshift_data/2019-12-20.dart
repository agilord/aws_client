// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import 'dart:convert';
import 'dart:typed_data';

import '../../shared/shared.dart' as _s;
import '../../shared/shared.dart'
    show
        Uint8ListConverter,
        Uint8ListListConverter,
        rfc822ToJson,
        iso8601ToJson,
        unixTimestampToJson,
        timeStampFromJson,
        RfcDateTimeConverter,
        IsoDateTimeConverter,
        UnixDateTimeConverter,
        StringJsonConverter,
        Base64JsonConverter;

export '../../shared/shared.dart' show AwsClientCredentials;

part '2019-12-20.g.dart';

/// You can use the Amazon Redshift Data API to run queries on Amazon Redshift
/// tables. You can run individual SQL statements, which are committed if the
/// statement succeeds.
class RedshiftDataApi {
  final _s.JsonProtocol _protocol;
  RedshiftDataApi({
    @_s.required String region,
    _s.AwsClientCredentials credentials,
    _s.Client client,
    String endpointUrl,
  }) : _protocol = _s.JsonProtocol(
          client: client,
          service: _s.ServiceMetadata(
            endpointPrefix: 'redshift-data',
            signingName: 'redshift-data',
          ),
          region: region,
          credentials: credentials,
          endpointUrl: endpointUrl,
        );

  /// Cancels a running query. To be canceled, a query must be running.
  ///
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [id] :
  /// The identifier of the SQL statement to cancel. This value is a universally
  /// unique identifier (UUID) generated by Amazon Redshift Data API. This
  /// identifier is returned by <code>ExecuteStatment</code> and
  /// <code>ListStatements</code>.
  Future<CancelStatementResponse> cancelStatement({
    @_s.required String id,
  }) async {
    ArgumentError.checkNotNull(id, 'id');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.CancelStatement'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Id': id,
      },
    );

    return CancelStatementResponse.fromJson(jsonResponse.body);
  }

  /// Describes the details about a specific instance when a query was run by
  /// the Amazon Redshift Data API. The information includes when the query
  /// started, when it finished, the query status, the number of rows returned,
  /// and the SQL statement.
  ///
  /// May throw [ValidationException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [id] :
  /// The identifier of the SQL statement to describe. This value is a
  /// universally unique identifier (UUID) generated by Amazon Redshift Data
  /// API. This identifier is returned by <code>ExecuteStatment</code> and
  /// <code>ListStatements</code>.
  Future<DescribeStatementResponse> describeStatement({
    @_s.required String id,
  }) async {
    ArgumentError.checkNotNull(id, 'id');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.DescribeStatement'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Id': id,
      },
    );

    return DescribeStatementResponse.fromJson(jsonResponse.body);
  }

  /// Describes the detailed information about a table from metadata in the
  /// cluster. The information includes its columns. A token is returned to page
  /// through the column list. Depending on the authorization method, use one of
  /// the following combinations of request parameters:
  ///
  /// <ul>
  /// <li>
  /// AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret
  /// and the cluster identifier that matches the cluster in the secret.
  /// </li>
  /// <li>
  /// Temporary credentials - specify the cluster identifier, the database name,
  /// and the database user name. Permission to call the
  /// <code>redshift:GetClusterCredentials</code> operation is required to use
  /// this method.
  /// </li>
  /// </ul>
  ///
  /// May throw [ValidationException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [clusterIdentifier] :
  /// The cluster identifier. This parameter is required when authenticating
  /// using either AWS Secrets Manager or temporary credentials.
  ///
  /// Parameter [database] :
  /// The name of the database. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [dbUser] :
  /// The database user name. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of tables to return in the response. If more tables
  /// exist than fit in one response, then <code>NextToken</code> is returned to
  /// page through the results.
  ///
  /// Parameter [nextToken] :
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  ///
  /// Parameter [schema] :
  /// The schema that contains the table. If no schema is specified, then
  /// matching tables for all schemas are returned.
  ///
  /// Parameter [secretArn] :
  /// The name or ARN of the secret that enables access to the database. This
  /// parameter is required when authenticating using AWS Secrets Manager.
  ///
  /// Parameter [table] :
  /// The table name. If no table is specified, then all tables for all matching
  /// schemas are returned. If no table and no schema is specified, then all
  /// tables for all schemas in the database are returned
  Future<DescribeTableResponse> describeTable({
    @_s.required String clusterIdentifier,
    String database,
    String dbUser,
    int maxResults,
    String nextToken,
    String schema,
    String secretArn,
    String table,
  }) async {
    ArgumentError.checkNotNull(clusterIdentifier, 'clusterIdentifier');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.DescribeTable'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ClusterIdentifier': clusterIdentifier,
        if (database != null) 'Database': database,
        if (dbUser != null) 'DbUser': dbUser,
        if (maxResults != null) 'MaxResults': maxResults,
        if (nextToken != null) 'NextToken': nextToken,
        if (schema != null) 'Schema': schema,
        if (secretArn != null) 'SecretArn': secretArn,
        if (table != null) 'Table': table,
      },
    );

    return DescribeTableResponse.fromJson(jsonResponse.body);
  }

  /// Runs an SQL statement, which can be data manipulation language (DML) or
  /// data definition language (DDL). This statement must be a single SQL
  /// statement. Depending on the authorization method, use one of the following
  /// combinations of request parameters:
  ///
  /// <ul>
  /// <li>
  /// AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret
  /// and the cluster identifier that matches the cluster in the secret.
  /// </li>
  /// <li>
  /// Temporary credentials - specify the cluster identifier, the database name,
  /// and the database user name. Permission to call the
  /// <code>redshift:GetClusterCredentials</code> operation is required to use
  /// this method.
  /// </li>
  /// </ul>
  ///
  /// May throw [ValidationException].
  /// May throw [ExecuteStatementException].
  ///
  /// Parameter [clusterIdentifier] :
  /// The cluster identifier. This parameter is required when authenticating
  /// using either AWS Secrets Manager or temporary credentials.
  ///
  /// Parameter [sql] :
  /// The SQL statement text to run.
  ///
  /// Parameter [database] :
  /// The name of the database. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [dbUser] :
  /// The database user name. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [secretArn] :
  /// The name or ARN of the secret that enables access to the database. This
  /// parameter is required when authenticating using AWS Secrets Manager.
  ///
  /// Parameter [statementName] :
  /// The name of the SQL statement. You can name the SQL statement when you
  /// create it to identify the query.
  ///
  /// Parameter [withEvent] :
  /// A value that indicates whether to send an event to the Amazon EventBridge
  /// event bus after the SQL statement runs.
  Future<ExecuteStatementOutput> executeStatement({
    @_s.required String clusterIdentifier,
    @_s.required String sql,
    String database,
    String dbUser,
    String secretArn,
    String statementName,
    bool withEvent,
  }) async {
    ArgumentError.checkNotNull(clusterIdentifier, 'clusterIdentifier');
    ArgumentError.checkNotNull(sql, 'sql');
    _s.validateStringLength(
      'statementName',
      statementName,
      0,
      500,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.ExecuteStatement'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ClusterIdentifier': clusterIdentifier,
        'Sql': sql,
        if (database != null) 'Database': database,
        if (dbUser != null) 'DbUser': dbUser,
        if (secretArn != null) 'SecretArn': secretArn,
        if (statementName != null) 'StatementName': statementName,
        if (withEvent != null) 'WithEvent': withEvent,
      },
    );

    return ExecuteStatementOutput.fromJson(jsonResponse.body);
  }

  /// Fetches the temporarily cached result of an SQL statement. A token is
  /// returned to page through the statement results.
  ///
  /// May throw [ValidationException].
  /// May throw [ResourceNotFoundException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [id] :
  /// The identifier of the SQL statement whose results are to be fetched. This
  /// value is a universally unique identifier (UUID) generated by Amazon
  /// Redshift Data API. This identifier is returned by
  /// <code>ExecuteStatment</code> and <code>ListStatements</code>.
  ///
  /// Parameter [nextToken] :
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  Future<GetStatementResultResponse> getStatementResult({
    @_s.required String id,
    String nextToken,
  }) async {
    ArgumentError.checkNotNull(id, 'id');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.GetStatementResult'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'Id': id,
        if (nextToken != null) 'NextToken': nextToken,
      },
    );

    return GetStatementResultResponse.fromJson(jsonResponse.body);
  }

  /// List the databases in a cluster. A token is returned to page through the
  /// database list. Depending on the authorization method, use one of the
  /// following combinations of request parameters:
  ///
  /// <ul>
  /// <li>
  /// AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret
  /// and the cluster identifier that matches the cluster in the secret.
  /// </li>
  /// <li>
  /// Temporary credentials - specify the cluster identifier, the database name,
  /// and the database user name. Permission to call the
  /// <code>redshift:GetClusterCredentials</code> operation is required to use
  /// this method.
  /// </li>
  /// </ul>
  ///
  /// May throw [ValidationException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [clusterIdentifier] :
  /// The cluster identifier. This parameter is required when authenticating
  /// using either AWS Secrets Manager or temporary credentials.
  ///
  /// Parameter [database] :
  /// The name of the database. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [dbUser] :
  /// The database user name. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of databases to return in the response. If more
  /// databases exist than fit in one response, then <code>NextToken</code> is
  /// returned to page through the results.
  ///
  /// Parameter [nextToken] :
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  ///
  /// Parameter [secretArn] :
  /// The name or ARN of the secret that enables access to the database. This
  /// parameter is required when authenticating using AWS Secrets Manager.
  Future<ListDatabasesResponse> listDatabases({
    @_s.required String clusterIdentifier,
    String database,
    String dbUser,
    int maxResults,
    String nextToken,
    String secretArn,
  }) async {
    ArgumentError.checkNotNull(clusterIdentifier, 'clusterIdentifier');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.ListDatabases'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ClusterIdentifier': clusterIdentifier,
        if (database != null) 'Database': database,
        if (dbUser != null) 'DbUser': dbUser,
        if (maxResults != null) 'MaxResults': maxResults,
        if (nextToken != null) 'NextToken': nextToken,
        if (secretArn != null) 'SecretArn': secretArn,
      },
    );

    return ListDatabasesResponse.fromJson(jsonResponse.body);
  }

  /// Lists the schemas in a database. A token is returned to page through the
  /// schema list. Depending on the authorization method, use one of the
  /// following combinations of request parameters:
  ///
  /// <ul>
  /// <li>
  /// AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret
  /// and the cluster identifier that matches the cluster in the secret.
  /// </li>
  /// <li>
  /// Temporary credentials - specify the cluster identifier, the database name,
  /// and the database user name. Permission to call the
  /// <code>redshift:GetClusterCredentials</code> operation is required to use
  /// this method.
  /// </li>
  /// </ul>
  ///
  /// May throw [ValidationException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [clusterIdentifier] :
  /// The cluster identifier. This parameter is required when authenticating
  /// using either AWS Secrets Manager or temporary credentials.
  ///
  /// Parameter [database] :
  /// The name of the database. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [dbUser] :
  /// The database user name. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of schemas to return in the response. If more schemas
  /// exist than fit in one response, then <code>NextToken</code> is returned to
  /// page through the results.
  ///
  /// Parameter [nextToken] :
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  ///
  /// Parameter [schemaPattern] :
  /// A pattern to filter results by schema name. Within a schema pattern, "%"
  /// means match any substring of 0 or more characters and "_" means match any
  /// one character. Only schema name entries matching the search pattern are
  /// returned.
  ///
  /// Parameter [secretArn] :
  /// The name or ARN of the secret that enables access to the database. This
  /// parameter is required when authenticating using AWS Secrets Manager.
  Future<ListSchemasResponse> listSchemas({
    @_s.required String clusterIdentifier,
    @_s.required String database,
    String dbUser,
    int maxResults,
    String nextToken,
    String schemaPattern,
    String secretArn,
  }) async {
    ArgumentError.checkNotNull(clusterIdentifier, 'clusterIdentifier');
    ArgumentError.checkNotNull(database, 'database');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.ListSchemas'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ClusterIdentifier': clusterIdentifier,
        'Database': database,
        if (dbUser != null) 'DbUser': dbUser,
        if (maxResults != null) 'MaxResults': maxResults,
        if (nextToken != null) 'NextToken': nextToken,
        if (schemaPattern != null) 'SchemaPattern': schemaPattern,
        if (secretArn != null) 'SecretArn': secretArn,
      },
    );

    return ListSchemasResponse.fromJson(jsonResponse.body);
  }

  /// List of SQL statements. By default, only finished statements are shown. A
  /// token is returned to page through the statement list.
  ///
  /// May throw [ValidationException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [maxResults] :
  /// The maximum number of SQL statements to return in the response. If more
  /// SQL statements exist than fit in one response, then <code>NextToken</code>
  /// is returned to page through the results.
  ///
  /// Parameter [nextToken] :
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  ///
  /// Parameter [statementName] :
  /// The name of the SQL statement specified as input to
  /// <code>ExecuteStatement</code> to identify the query. You can list multiple
  /// statements by providing a prefix that matches the beginning of the
  /// statement name. For example, to list myStatement1, myStatement2,
  /// myStatement3, and so on, then provide the a value of
  /// <code>myStatement</code>. Data API does a case-sensitive match of SQL
  /// statement names to the prefix value you provide.
  ///
  /// Parameter [status] :
  /// The status of the SQL statement to list. Status values are defined as
  /// follows:
  ///
  /// <ul>
  /// <li>
  /// ABORTED - The query run was stopped by the user.
  /// </li>
  /// <li>
  /// ALL - A status value that includes all query statuses. This value can be
  /// used to filter results.
  /// </li>
  /// <li>
  /// FAILED - The query run failed.
  /// </li>
  /// <li>
  /// FINISHED - The query has finished running.
  /// </li>
  /// <li>
  /// PICKED - The query has been chosen to be run.
  /// </li>
  /// <li>
  /// STARTED - The query run has started.
  /// </li>
  /// <li>
  /// SUBMITTED - The query was submitted, but not yet processed.
  /// </li>
  /// </ul>
  Future<ListStatementsResponse> listStatements({
    int maxResults,
    String nextToken,
    String statementName,
    StatusString status,
  }) async {
    _s.validateNumRange(
      'maxResults',
      maxResults,
      0,
      100,
    );
    _s.validateStringLength(
      'statementName',
      statementName,
      0,
      500,
    );
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.ListStatements'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        if (maxResults != null) 'MaxResults': maxResults,
        if (nextToken != null) 'NextToken': nextToken,
        if (statementName != null) 'StatementName': statementName,
        if (status != null) 'Status': status.toValue(),
      },
    );

    return ListStatementsResponse.fromJson(jsonResponse.body);
  }

  /// List the tables in a database. If neither <code>SchemaPattern</code> nor
  /// <code>TablePattern</code> are specified, then all tables in the database
  /// are returned. A token is returned to page through the table list.
  /// Depending on the authorization method, use one of the following
  /// combinations of request parameters:
  ///
  /// <ul>
  /// <li>
  /// AWS Secrets Manager - specify the Amazon Resource Name (ARN) of the secret
  /// and the cluster identifier that matches the cluster in the secret.
  /// </li>
  /// <li>
  /// Temporary credentials - specify the cluster identifier, the database name,
  /// and the database user name. Permission to call the
  /// <code>redshift:GetClusterCredentials</code> operation is required to use
  /// this method.
  /// </li>
  /// </ul>
  ///
  /// May throw [ValidationException].
  /// May throw [InternalServerException].
  ///
  /// Parameter [clusterIdentifier] :
  /// The cluster identifier. This parameter is required when authenticating
  /// using either AWS Secrets Manager or temporary credentials.
  ///
  /// Parameter [database] :
  /// The name of the database. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [dbUser] :
  /// The database user name. This parameter is required when authenticating
  /// using temporary credentials.
  ///
  /// Parameter [maxResults] :
  /// The maximum number of tables to return in the response. If more tables
  /// exist than fit in one response, then <code>NextToken</code> is returned to
  /// page through the results.
  ///
  /// Parameter [nextToken] :
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  ///
  /// Parameter [schemaPattern] :
  /// A pattern to filter results by schema name. Within a schema pattern, "%"
  /// means match any substring of 0 or more characters and "_" means match any
  /// one character. Only schema name entries matching the search pattern are
  /// returned. If <code>SchemaPattern</code> is not specified, then all tables
  /// that match <code>TablePattern</code> are returned. If neither
  /// <code>SchemaPattern</code> or <code>TablePattern</code> are specified,
  /// then all tables are returned.
  ///
  /// Parameter [secretArn] :
  /// The name or ARN of the secret that enables access to the database. This
  /// parameter is required when authenticating using AWS Secrets Manager.
  ///
  /// Parameter [tablePattern] :
  /// A pattern to filter results by table name. Within a table pattern, "%"
  /// means match any substring of 0 or more characters and "_" means match any
  /// one character. Only table name entries matching the search pattern are
  /// returned. If <code>TablePattern</code> is not specified, then all tables
  /// that match <code>SchemaPattern</code>are returned. If neither
  /// <code>SchemaPattern</code> or <code>TablePattern</code> are specified,
  /// then all tables are returned.
  Future<ListTablesResponse> listTables({
    @_s.required String clusterIdentifier,
    @_s.required String database,
    String dbUser,
    int maxResults,
    String nextToken,
    String schemaPattern,
    String secretArn,
    String tablePattern,
  }) async {
    ArgumentError.checkNotNull(clusterIdentifier, 'clusterIdentifier');
    ArgumentError.checkNotNull(database, 'database');
    final headers = <String, String>{
      'Content-Type': 'application/x-amz-json-1.1',
      'X-Amz-Target': 'RedshiftData.ListTables'
    };
    final jsonResponse = await _protocol.send(
      method: 'POST',
      requestUri: '/',
      exceptionFnMap: _exceptionFns,
      // TODO queryParams
      headers: headers,
      payload: {
        'ClusterIdentifier': clusterIdentifier,
        'Database': database,
        if (dbUser != null) 'DbUser': dbUser,
        if (maxResults != null) 'MaxResults': maxResults,
        if (nextToken != null) 'NextToken': nextToken,
        if (schemaPattern != null) 'SchemaPattern': schemaPattern,
        if (secretArn != null) 'SecretArn': secretArn,
        if (tablePattern != null) 'TablePattern': tablePattern,
      },
    );

    return ListTablesResponse.fromJson(jsonResponse.body);
  }
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class CancelStatementResponse {
  /// A value that indicates whether the cancel statement succeeded (true).
  @_s.JsonKey(name: 'Status')
  final bool status;

  CancelStatementResponse({
    this.status,
  });
  factory CancelStatementResponse.fromJson(Map<String, dynamic> json) =>
      _$CancelStatementResponseFromJson(json);
}

/// The properties (metadata) of a column.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ColumnMetadata {
  /// The default value of the column.
  @_s.JsonKey(name: 'columnDefault')
  final String columnDefault;

  /// A value that indicates whether the column is case-sensitive.
  @_s.JsonKey(name: 'isCaseSensitive')
  final bool isCaseSensitive;

  /// A value that indicates whether the column contains currency values.
  @_s.JsonKey(name: 'isCurrency')
  final bool isCurrency;

  /// A value that indicates whether an integer column is signed.
  @_s.JsonKey(name: 'isSigned')
  final bool isSigned;

  /// The label for the column.
  @_s.JsonKey(name: 'label')
  final String label;

  /// The length of the column.
  @_s.JsonKey(name: 'length')
  final int length;

  /// The name of the column.
  @_s.JsonKey(name: 'name')
  final String name;

  /// A value that indicates whether the column is nullable.
  @_s.JsonKey(name: 'nullable')
  final int nullable;

  /// The precision value of a decimal number column.
  @_s.JsonKey(name: 'precision')
  final int precision;

  /// The scale value of a decimal number column.
  @_s.JsonKey(name: 'scale')
  final int scale;

  /// The name of the schema that contains the table that includes the column.
  @_s.JsonKey(name: 'schemaName')
  final String schemaName;

  /// The name of the table that includes the column.
  @_s.JsonKey(name: 'tableName')
  final String tableName;

  /// The database-specific data type of the column.
  @_s.JsonKey(name: 'typeName')
  final String typeName;

  ColumnMetadata({
    this.columnDefault,
    this.isCaseSensitive,
    this.isCurrency,
    this.isSigned,
    this.label,
    this.length,
    this.name,
    this.nullable,
    this.precision,
    this.scale,
    this.schemaName,
    this.tableName,
    this.typeName,
  });
  factory ColumnMetadata.fromJson(Map<String, dynamic> json) =>
      _$ColumnMetadataFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class DescribeStatementResponse {
  /// The identifier of the SQL statement described. This value is a universally
  /// unique identifier (UUID) generated by Amazon Redshift Data API.
  @_s.JsonKey(name: 'Id')
  final String id;

  /// The cluster identifier.
  @_s.JsonKey(name: 'ClusterIdentifier')
  final String clusterIdentifier;

  /// The date and time (UTC) when the SQL statement was submitted to run.
  @UnixDateTimeConverter()
  @_s.JsonKey(name: 'CreatedAt')
  final DateTime createdAt;

  /// The name of the database.
  @_s.JsonKey(name: 'Database')
  final String database;

  /// The database user name.
  @_s.JsonKey(name: 'DbUser')
  final String dbUser;

  /// The amount of time in nanoseconds that the statement ran.
  @_s.JsonKey(name: 'Duration')
  final int duration;

  /// The error message from the cluster if the SQL statement encountered an error
  /// while running.
  @_s.JsonKey(name: 'Error')
  final String error;

  /// The SQL statement text.
  @_s.JsonKey(name: 'QueryString')
  final String queryString;

  /// The process identifier from Amazon Redshift.
  @_s.JsonKey(name: 'RedshiftPid')
  final int redshiftPid;

  /// The identifier of the query generated by Amazon Redshift. These identifiers
  /// are also available in the <code>query</code> column of the
  /// <code>STL_QUERY</code> system view.
  @_s.JsonKey(name: 'RedshiftQueryId')
  final int redshiftQueryId;

  /// Either the number of rows returned from the SQL statement or the number of
  /// rows affected. If result size is greater than zero, the result rows can be
  /// the number of rows affected by SQL statements such as INSERT, UPDATE,
  /// DELETE, COPY, and others.
  @_s.JsonKey(name: 'ResultRows')
  final int resultRows;

  /// The size in bytes of the returned results.
  @_s.JsonKey(name: 'ResultSize')
  final int resultSize;

  /// The name or Amazon Resource Name (ARN) of the secret that enables access to
  /// the database.
  @_s.JsonKey(name: 'SecretArn')
  final String secretArn;

  /// The status of the SQL statement being described. Status values are defined
  /// as follows:
  ///
  /// <ul>
  /// <li>
  /// ABORTED - The query run was stopped by the user.
  /// </li>
  /// <li>
  /// ALL - A status value that includes all query statuses. This value can be
  /// used to filter results.
  /// </li>
  /// <li>
  /// FAILED - The query run failed.
  /// </li>
  /// <li>
  /// FINISHED - The query has finished running.
  /// </li>
  /// <li>
  /// PICKED - The query has been chosen to be run.
  /// </li>
  /// <li>
  /// STARTED - The query run has started.
  /// </li>
  /// <li>
  /// SUBMITTED - The query was submitted, but not yet processed.
  /// </li>
  /// </ul>
  @_s.JsonKey(name: 'Status')
  final StatusString status;

  /// The date and time (UTC) that the metadata for the SQL statement was last
  /// updated. An example is the time the status last changed.
  @UnixDateTimeConverter()
  @_s.JsonKey(name: 'UpdatedAt')
  final DateTime updatedAt;

  DescribeStatementResponse({
    @_s.required this.id,
    this.clusterIdentifier,
    this.createdAt,
    this.database,
    this.dbUser,
    this.duration,
    this.error,
    this.queryString,
    this.redshiftPid,
    this.redshiftQueryId,
    this.resultRows,
    this.resultSize,
    this.secretArn,
    this.status,
    this.updatedAt,
  });
  factory DescribeStatementResponse.fromJson(Map<String, dynamic> json) =>
      _$DescribeStatementResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class DescribeTableResponse {
  /// A list of columns in the table.
  @_s.JsonKey(name: 'ColumnList')
  final List<ColumnMetadata> columnList;

  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  /// The table name.
  @_s.JsonKey(name: 'TableName')
  final String tableName;

  DescribeTableResponse({
    this.columnList,
    this.nextToken,
    this.tableName,
  });
  factory DescribeTableResponse.fromJson(Map<String, dynamic> json) =>
      _$DescribeTableResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ExecuteStatementOutput {
  /// The cluster identifier.
  @_s.JsonKey(name: 'ClusterIdentifier')
  final String clusterIdentifier;

  /// The date and time (UTC) the statement was created.
  @UnixDateTimeConverter()
  @_s.JsonKey(name: 'CreatedAt')
  final DateTime createdAt;

  /// The name of the database.
  @_s.JsonKey(name: 'Database')
  final String database;

  /// The database user name.
  @_s.JsonKey(name: 'DbUser')
  final String dbUser;

  /// The identifier of the statement to be run. This value is a universally
  /// unique identifier (UUID) generated by Amazon Redshift Data API.
  @_s.JsonKey(name: 'Id')
  final String id;

  /// The name or ARN of the secret that enables access to the database.
  @_s.JsonKey(name: 'SecretArn')
  final String secretArn;

  ExecuteStatementOutput({
    this.clusterIdentifier,
    this.createdAt,
    this.database,
    this.dbUser,
    this.id,
    this.secretArn,
  });
  factory ExecuteStatementOutput.fromJson(Map<String, dynamic> json) =>
      _$ExecuteStatementOutputFromJson(json);
}

/// A data value in a column.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class Field {
  /// A value of the BLOB data type.
  @Uint8ListConverter()
  @_s.JsonKey(name: 'blobValue')
  final Uint8List blobValue;

  /// A value of the Boolean data type.
  @_s.JsonKey(name: 'booleanValue')
  final bool booleanValue;

  /// A value of the double data type.
  @_s.JsonKey(name: 'doubleValue')
  final double doubleValue;

  /// A value that indicates whether the data is NULL.
  @_s.JsonKey(name: 'isNull')
  final bool isNull;

  /// A value of the long data type.
  @_s.JsonKey(name: 'longValue')
  final int longValue;

  /// A value of the string data type.
  @_s.JsonKey(name: 'stringValue')
  final String stringValue;

  Field({
    this.blobValue,
    this.booleanValue,
    this.doubleValue,
    this.isNull,
    this.longValue,
    this.stringValue,
  });
  factory Field.fromJson(Map<String, dynamic> json) => _$FieldFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class GetStatementResultResponse {
  /// The results of the SQL statement.
  @_s.JsonKey(name: 'Records')
  final List<List<Field>> records;

  /// The properties (metadata) of a column.
  @_s.JsonKey(name: 'ColumnMetadata')
  final List<ColumnMetadata> columnMetadata;

  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  /// The total number of rows in the result set returned from a query. You can
  /// use this number to estimate the number of calls to the
  /// <code>GetStatementResult</code> operation needed to page through the
  /// results.
  @_s.JsonKey(name: 'TotalNumRows')
  final int totalNumRows;

  GetStatementResultResponse({
    @_s.required this.records,
    this.columnMetadata,
    this.nextToken,
    this.totalNumRows,
  });
  factory GetStatementResultResponse.fromJson(Map<String, dynamic> json) =>
      _$GetStatementResultResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListDatabasesResponse {
  /// The names of databases.
  @_s.JsonKey(name: 'Databases')
  final List<String> databases;

  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  ListDatabasesResponse({
    this.databases,
    this.nextToken,
  });
  factory ListDatabasesResponse.fromJson(Map<String, dynamic> json) =>
      _$ListDatabasesResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListSchemasResponse {
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  /// The schemas that match the request pattern.
  @_s.JsonKey(name: 'Schemas')
  final List<String> schemas;

  ListSchemasResponse({
    this.nextToken,
    this.schemas,
  });
  factory ListSchemasResponse.fromJson(Map<String, dynamic> json) =>
      _$ListSchemasResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListStatementsResponse {
  /// The SQL statements.
  @_s.JsonKey(name: 'Statements')
  final List<StatementData> statements;

  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  ListStatementsResponse({
    @_s.required this.statements,
    this.nextToken,
  });
  factory ListStatementsResponse.fromJson(Map<String, dynamic> json) =>
      _$ListStatementsResponseFromJson(json);
}

@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class ListTablesResponse {
  /// A value that indicates the starting point for the next set of response
  /// records in a subsequent request. If a value is returned in a response, you
  /// can retrieve the next set of records by providing this returned NextToken
  /// value in the next NextToken parameter and retrying the command. If the
  /// NextToken field is empty, all response records have been retrieved for the
  /// request.
  @_s.JsonKey(name: 'NextToken')
  final String nextToken;

  /// The tables that match the request pattern.
  @_s.JsonKey(name: 'Tables')
  final List<TableMember> tables;

  ListTablesResponse({
    this.nextToken,
    this.tables,
  });
  factory ListTablesResponse.fromJson(Map<String, dynamic> json) =>
      _$ListTablesResponseFromJson(json);
}

/// The SQL statement to run.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class StatementData {
  /// The SQL statement identifier. This value is a universally unique identifier
  /// (UUID) generated by Amazon Redshift Data API.
  @_s.JsonKey(name: 'Id')
  final String id;

  /// The date and time (UTC) the statement was created.
  @UnixDateTimeConverter()
  @_s.JsonKey(name: 'CreatedAt')
  final DateTime createdAt;

  /// The SQL statement.
  @_s.JsonKey(name: 'QueryString')
  final String queryString;

  /// The name or Amazon Resource Name (ARN) of the secret that enables access to
  /// the database.
  @_s.JsonKey(name: 'SecretArn')
  final String secretArn;

  /// The name of the SQL statement.
  @_s.JsonKey(name: 'StatementName')
  final String statementName;

  /// The status of the SQL statement. An example is the that the SQL statement
  /// finished.
  @_s.JsonKey(name: 'Status')
  final StatusString status;

  /// The date and time (UTC) that the statement metadata was last updated.
  @UnixDateTimeConverter()
  @_s.JsonKey(name: 'UpdatedAt')
  final DateTime updatedAt;

  StatementData({
    @_s.required this.id,
    this.createdAt,
    this.queryString,
    this.secretArn,
    this.statementName,
    this.status,
    this.updatedAt,
  });
  factory StatementData.fromJson(Map<String, dynamic> json) =>
      _$StatementDataFromJson(json);
}

enum StatusString {
  @_s.JsonValue('ABORTED')
  aborted,
  @_s.JsonValue('ALL')
  all,
  @_s.JsonValue('FAILED')
  failed,
  @_s.JsonValue('FINISHED')
  finished,
  @_s.JsonValue('PICKED')
  picked,
  @_s.JsonValue('STARTED')
  started,
  @_s.JsonValue('SUBMITTED')
  submitted,
}

extension on StatusString {
  String toValue() {
    switch (this) {
      case StatusString.aborted:
        return 'ABORTED';
      case StatusString.all:
        return 'ALL';
      case StatusString.failed:
        return 'FAILED';
      case StatusString.finished:
        return 'FINISHED';
      case StatusString.picked:
        return 'PICKED';
      case StatusString.started:
        return 'STARTED';
      case StatusString.submitted:
        return 'SUBMITTED';
    }
    throw Exception('Unknown enum value: $this');
  }
}

/// The properties of a table.
@_s.JsonSerializable(
    includeIfNull: false,
    explicitToJson: true,
    createFactory: true,
    createToJson: false)
class TableMember {
  /// The name of the table.
  @_s.JsonKey(name: 'name')
  final String name;

  /// The schema containing the table.
  @_s.JsonKey(name: 'schema')
  final String schema;

  /// The type of the table. Possible values include TABLE, VIEW, SYSTEM TABLE,
  /// GLOBAL TEMPORARY, LOCAL TEMPORARY, ALIAS, and SYNONYM.
  @_s.JsonKey(name: 'type')
  final String type;

  TableMember({
    this.name,
    this.schema,
    this.type,
  });
  factory TableMember.fromJson(Map<String, dynamic> json) =>
      _$TableMemberFromJson(json);
}

class ExecuteStatementException extends _s.GenericAwsException {
  ExecuteStatementException({String type, String message})
      : super(type: type, code: 'ExecuteStatementException', message: message);
}

class InternalServerException extends _s.GenericAwsException {
  InternalServerException({String type, String message})
      : super(type: type, code: 'InternalServerException', message: message);
}

class ResourceNotFoundException extends _s.GenericAwsException {
  ResourceNotFoundException({String type, String message})
      : super(type: type, code: 'ResourceNotFoundException', message: message);
}

class ValidationException extends _s.GenericAwsException {
  ValidationException({String type, String message})
      : super(type: type, code: 'ValidationException', message: message);
}

final _exceptionFns = <String, _s.AwsExceptionFn>{
  'ExecuteStatementException': (type, message) =>
      ExecuteStatementException(type: type, message: message),
  'InternalServerException': (type, message) =>
      InternalServerException(type: type, message: message),
  'ResourceNotFoundException': (type, message) =>
      ResourceNotFoundException(type: type, message: message),
  'ValidationException': (type, message) =>
      ValidationException(type: type, message: message),
};
